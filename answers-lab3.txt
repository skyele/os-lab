questions:
    
	1.What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
        
		1.if all exception were delivered to the same handler, we cannot deal with the difference between errcode number
        
		   which is to say, for some exception/interrupt cpu will put error number in stack, but some not. we need different exception handler for the situation.
       
		2.besides, we should push trapnumber
    
	2.Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint's code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?
        
		1.是因为我们将pagefault的权限设置为0，而softint是用户态程序，在用户态下使用int 14会触发general protection fault的异常。
       
		2.如果强制将pagefault的权限设置为3.在trapentry.S中我们可以看到，pagefault异常是由cpu push error num的，但是我们的int指令并不会压入错误码。所以就不会对齐。在打印出的信息中，我们可以看到从err这一行开始，栈上的数据开始产生错位。那么在访问trapframe时，由于少了一个error num，那么我们的访问就会越界，访问到KSTACKTOP之上的空间。而在KSTACKTOP之上，是KERNBASE，所以最后print的ss其实是物理地址为0x0的数据。
    
	3.The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?
        
		1.将SETGATE中的权限参数设置为3，即可正常被用户程序触发. 如果设置为0，则会触发general protection fault.
        
		2.就是让用户可以利用这些中断机制，能够使用操作系统提供的服务。
