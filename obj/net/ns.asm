
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 31 e6 00 00       	call   80e662 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 3b a6 00 00       	call   80a683 <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 80 a6 00 00       	call   80a6ed <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 a7 a9 00 00       	call   80aa29 <e2s>
  800082:	50                   	push   %eax
  800083:	68 a0 13 81 00       	push   $0x8113a0
  800088:	6a 7a                	push   $0x7a
  80008a:	68 d5 14 81 00       	push   $0x8114d5
  80008f:	e8 db e6 00 00       	call   80e76f <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 47 f5 00 00       	call   80f5e8 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 b2 a5 00 00       	call   80a65a <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 ab a5 00 00       	call   80a65b <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 da a7 00 00       	call   80a899 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 a4 15 81 00 	jmp    *0x8115a4(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 2d 0e 00 00       	call   800f2a <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 44 f0 00 00       	call   80f152 <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 00 60 81 00 00 	movb   $0x0,0x816000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 fa f2 00 00       	call   80f43b <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 d8 07 01 00       	call   810921 <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 76 14             	pushl  0x14(%esi)
  80015a:	8d 46 04             	lea    0x4(%esi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 36                	pushl  (%esi)
  800160:	e8 77 0f 00 00       	call   8010dc <lwip_bind>
  800165:	89 c7                	mov    %eax,%edi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 76 04             	pushl  0x4(%esi)
  800172:	ff 36                	pushl  (%esi)
  800174:	e8 be 1a 00 00       	call   801c37 <lwip_shutdown>
  800179:	89 c7                	mov    %eax,%edi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 36                	pushl  (%esi)
  800185:	e8 08 10 00 00       	call   801192 <lwip_close>
  80018a:	89 c7                	mov    %eax,%edi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 76 14             	pushl  0x14(%esi)
  800197:	8d 46 04             	lea    0x4(%esi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 36                	pushl  (%esi)
  80019d:	e8 79 10 00 00       	call   80121b <lwip_connect>
  8001a2:	89 c7                	mov    %eax,%edi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 76 04             	pushl  0x4(%esi)
  8001b2:	ff 36                	pushl  (%esi)
  8001b4:	e8 18 11 00 00       	call   8012d1 <lwip_listen>
  8001b9:	89 c7                	mov    %eax,%edi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 76 08             	pushl  0x8(%esi)
  8001c6:	ff 76 04             	pushl  0x4(%esi)
  8001c9:	56                   	push   %esi
  8001ca:	ff 36                	pushl  (%esi)
  8001cc:	e8 eb 13 00 00       	call   8015bc <lwip_recv>
  8001d1:	89 c7                	mov    %eax,%edi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 76 08             	pushl  0x8(%esi)
  8001de:	ff 76 04             	pushl  0x4(%esi)
  8001e1:	8d 46 0c             	lea    0xc(%esi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 36                	pushl  (%esi)
  8001e7:	e8 62 15 00 00       	call   80174e <lwip_send>
  8001ec:	89 c7                	mov    %eax,%edi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 76 08             	pushl  0x8(%esi)
  8001fc:	ff 76 04             	pushl  0x4(%esi)
  8001ff:	ff 36                	pushl  (%esi)
  800201:	e8 d9 15 00 00       	call   8017df <lwip_socket>
  800206:	89 c7                	mov    %eax,%edi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	56                   	push   %esi
  800214:	68 00 c2 b3 00       	push   $0xb3c200
  800219:	e8 fa a8 00 00       	call   80ab18 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	bf 00 00 00 00       	mov    $0x0,%edi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	56                   	push   %esi
  80022f:	ff 73 04             	pushl  0x4(%ebx)
  800232:	68 c0 13 81 00       	push   $0x8113c0
  800237:	e8 29 e6 00 00       	call   80e865 <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	pushl  (%ebx)
  80024b:	68 e0 14 81 00       	push   $0x8114e0
  800250:	6a 64                	push   $0x64
  800252:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800255:	56                   	push   %esi
  800256:	e8 16 ed 00 00       	call   80ef71 <snprintf>
		perror(buf);
  80025b:	89 34 24             	mov    %esi,(%esp)
  80025e:	e8 a2 a7 00 00       	call   80aa05 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	57                   	push   %edi
  800270:	ff 73 04             	pushl  0x4(%ebx)
  800273:	e8 83 f9 00 00       	call   80fbfb <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 ca a3 00 00       	call   80a65a <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 22 22 00 00       	call   8024ca <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 ae a3 00 00       	call   80a65b <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 df a5 00 00       	call   80a899 <thread_wait>
	lwip_core_lock();
  8002ba:	e8 9b a3 00 00       	call   80a65a <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 1b 66 80 00       	push   $0x80661b
  8002d6:	68 03 ac 80 00       	push   $0x80ac03
  8002db:	68 14 60 81 00       	push   $0x816014
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 c2 b3 00       	push   $0xb3c200
  8002f1:	e8 2a 44 00 00       	call   804720 <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 c2 b3 00       	push   $0xb3c200
  800309:	e8 c4 44 00 00       	call   8047d2 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 c2 b3 00 	movl   $0xb3c200,(%esp)
  800315:	e8 c5 44 00 00       	call   8047df <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 ef 14 81 00       	mov    $0x8114ef,%ecx
  800326:	ba dd 95 80 00       	mov    $0x8095dd,%edx
  80032b:	b8 34 60 81 00       	mov    $0x816034,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 f9 14 81 00       	mov    $0x8114f9,%ecx
  800341:	ba a7 57 80 00       	mov    $0x8057a7,%edx
  800346:	b8 28 60 81 00       	mov    $0x816028,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 05 15 81 00       	mov    $0x811505,%ecx
  80035c:	ba 60 5d 80 00       	mov    $0x805d60,%edx
  800361:	b8 1c 60 81 00       	mov    $0x81601c,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 cb 73 00 00       	call   80773e <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a c2 b3 00 	movzbl 0xb3c22a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 c2 b3 00 	movzbl 0xb3c229,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 c2 b3 00 	movzbl 0xb3c228,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 c2 b3 00 	movzbl 0xb3c227,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 c2 b3 00 	movzbl 0xb3c226,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 c2 b3 00 	movzbl 0xb3c225,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 04 14 81 00       	push   $0x811404
  8003a9:	e8 b7 e4 00 00       	call   80e865 <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 a5 a2 00 00       	call   80a65b <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 11 15 81 00       	push   $0x811511
  8003be:	e8 a2 e4 00 00       	call   80e865 <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 e4 13 81 00       	push   $0x8113e4
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 d5 14 81 00       	push   $0x8114d5
  8003dc:	e8 8e e3 00 00       	call   80e76f <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 9d 00 00 00       	jmp    80048f <serve+0xae>
		perm = 0;
  8003f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f9:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003fe:	80 b8 00 60 81 00 00 	cmpb   $0x0,0x816000(%eax)
  800405:	74 1c                	je     800423 <serve+0x42>
	for (i = 0; i < QUEUE_SIZE; i++)
  800407:	83 c0 01             	add    $0x1,%eax
  80040a:	83 f8 14             	cmp    $0x14,%eax
  80040d:	75 ef                	jne    8003fe <serve+0x1d>
		panic("NS: buffer overflow");
  80040f:	83 ec 04             	sub    $0x4,%esp
  800412:	68 2a 15 81 00       	push   $0x81152a
  800417:	6a 3f                	push   $0x3f
  800419:	68 d5 14 81 00       	push   $0x8114d5
  80041e:	e8 4c e3 00 00       	call   80e76f <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800423:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  800429:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042c:	c6 80 00 60 81 00 01 	movb   $0x1,0x816000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800433:	83 ec 04             	sub    $0x4,%esp
  800436:	57                   	push   %edi
  800437:	53                   	push   %ebx
  800438:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043b:	50                   	push   %eax
  80043c:	e8 51 f7 00 00       	call   80fb92 <ipc_recv>
  800441:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800443:	83 c4 10             	add    $0x10,%esp
  800446:	83 f8 0c             	cmp    $0xc,%eax
  800449:	74 69                	je     8004b4 <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80044b:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80044f:	0f 84 ba 00 00 00    	je     80050f <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800455:	83 ec 0c             	sub    $0xc,%esp
  800458:	6a 0c                	push   $0xc
  80045a:	e8 6e 05 01 00       	call   8109cd <malloc>
		if (!args)
  80045f:	83 c4 10             	add    $0x10,%esp
  800462:	85 c0                	test   %eax,%eax
  800464:	0f 84 bd 00 00 00    	je     800527 <serve+0x146>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80046a:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  80046c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80046f:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800472:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  800475:	50                   	push   %eax
  800476:	68 c4 00 80 00       	push   $0x8000c4
  80047b:	68 3e 15 81 00       	push   $0x81153e
  800480:	6a 00                	push   $0x0
  800482:	e8 66 a2 00 00       	call   80a6ed <thread_create>
		thread_yield(); // let the thread created run
  800487:	e8 8a a3 00 00       	call   80a816 <thread_yield>
  80048c:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  800494:	e8 0b a2 00 00       	call   80a6a4 <thread_wakeups_pending>
  800499:	85 c0                	test   %eax,%eax
  80049b:	0f 84 51 ff ff ff    	je     8003f2 <serve+0x11>
  8004a1:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a4:	0f 8f 48 ff ff ff    	jg     8003f2 <serve+0x11>
			thread_yield();
  8004aa:	e8 67 a3 00 00       	call   80a816 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004af:	83 c3 01             	add    $0x1,%ebx
  8004b2:	eb e0                	jmp    800494 <serve+0xb3>
			process_timer(whom);
  8004b4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b7:	3b 35 18 60 81 00    	cmp    0x816018,%esi
  8004bd:	74 23                	je     8004e2 <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004bf:	83 ec 08             	sub    $0x8,%esp
  8004c2:	56                   	push   %esi
  8004c3:	68 40 14 81 00       	push   $0x811440
  8004c8:	e8 98 e3 00 00       	call   80e865 <cprintf>
  8004cd:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004d0:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d6:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d9:	c6 83 00 60 81 00 00 	movb   $0x0,0x816000(%ebx)
  8004e0:	eb ad                	jmp    80048f <serve+0xae>
	start = sys_time_msec();
  8004e2:	e8 01 f1 00 00       	call   80f5e8 <sys_time_msec>
  8004e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ea:	e8 27 a3 00 00       	call   80a816 <thread_yield>
	now = sys_time_msec();
  8004ef:	e8 f4 f0 00 00       	call   80f5e8 <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004f4:	6a 00                	push   $0x0
  8004f6:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004fb:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800501:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800503:	52                   	push   %edx
  800504:	56                   	push   %esi
  800505:	e8 f1 f6 00 00       	call   80fbfb <ipc_send>
  80050a:	83 c4 10             	add    $0x10,%esp
  80050d:	eb c1                	jmp    8004d0 <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050f:	83 ec 08             	sub    $0x8,%esp
  800512:	ff 75 e4             	pushl  -0x1c(%ebp)
  800515:	68 7c 14 81 00       	push   $0x81147c
  80051a:	e8 46 e3 00 00       	call   80e865 <cprintf>
			continue; // just leave it hanging...
  80051f:	83 c4 10             	add    $0x10,%esp
  800522:	e9 68 ff ff ff       	jmp    80048f <serve+0xae>
			panic("could not allocate thread args structure");
  800527:	83 ec 04             	sub    $0x4,%esp
  80052a:	68 ac 14 81 00       	push   $0x8114ac
  80052f:	68 27 01 00 00       	push   $0x127
  800534:	68 d5 14 81 00       	push   $0x8114d5
  800539:	e8 31 e2 00 00       	call   80e76f <_panic>

0080053e <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80053e:	55                   	push   %ebp
  80053f:	89 e5                	mov    %esp,%ebp
  800541:	56                   	push   %esi
  800542:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800543:	83 ec 0c             	sub    $0xc,%esp
  800546:	68 4b 15 81 00       	push   $0x81154b
  80054b:	e8 9d 74 00 00       	call   8079ed <inet_addr>
  800550:	89 c6                	mov    %eax,%esi
  800552:	c7 04 24 54 15 81 00 	movl   $0x811554,(%esp)
  800559:	e8 8f 74 00 00       	call   8079ed <inet_addr>
  80055e:	89 c3                	mov    %eax,%ebx
  800560:	c7 04 24 62 15 81 00 	movl   $0x811562,(%esp)
  800567:	e8 81 74 00 00       	call   8079ed <inet_addr>
  80056c:	83 c4 0c             	add    $0xc,%esp
  80056f:	56                   	push   %esi
  800570:	53                   	push   %ebx
  800571:	50                   	push   %eax
  800572:	e8 09 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800577:	e8 65 fe ff ff       	call   8003e1 <serve>

0080057c <umain>:
}

void
umain(int argc, char **argv)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	53                   	push   %ebx
  800580:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in umain serv.c\n", thisenv->env_id);
  800583:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800588:	8b 40 48             	mov    0x48(%eax),%eax
  80058b:	50                   	push   %eax
  80058c:	68 6c 15 81 00       	push   $0x81156c
  800591:	e8 cf e2 00 00       	call   80e865 <cprintf>
	envid_t ns_envid = sys_getenvid();
  800596:	e8 dd ed 00 00       	call   80f378 <sys_getenvid>
  80059b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80059d:	c7 05 e8 52 81 00 47 	movl   $0x814047,0x8152e8
  8005a4:	40 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005a7:	e8 54 f3 00 00       	call   80f900 <fork>
  8005ac:	a3 18 60 81 00       	mov    %eax,0x816018
	if (timer_envid < 0)
  8005b1:	83 c4 10             	add    $0x10,%esp
  8005b4:	85 c0                	test   %eax,%eax
  8005b6:	78 43                	js     8005fb <umain+0x7f>
		panic("error forking");
	else if (timer_envid == 0) {
  8005b8:	74 58                	je     800612 <umain+0x96>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005ba:	e8 41 f3 00 00       	call   80f900 <fork>
	if (input_envid < 0)
  8005bf:	85 c0                	test   %eax,%eax
  8005c1:	78 65                	js     800628 <umain+0xac>
		panic("error forking");
	else if (input_envid == 0) {
  8005c3:	74 7a                	je     80063f <umain+0xc3>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005c5:	e8 36 f3 00 00       	call   80f900 <fork>
  8005ca:	a3 14 60 81 00       	mov    %eax,0x816014
	if (output_envid < 0)
  8005cf:	85 c0                	test   %eax,%eax
  8005d1:	78 7a                	js     80064d <umain+0xd1>
		panic("error forking");
	else if (output_envid == 0) {
  8005d3:	0f 84 8b 00 00 00    	je     800664 <umain+0xe8>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005d9:	e8 7e a0 00 00       	call   80a65c <thread_init>
	thread_create(0, "main", tmain, 0);
  8005de:	6a 00                	push   $0x0
  8005e0:	68 3e 05 80 00       	push   $0x80053e
  8005e5:	68 9f 15 81 00       	push   $0x81159f
  8005ea:	6a 00                	push   $0x0
  8005ec:	e8 fc a0 00 00       	call   80a6ed <thread_create>
	thread_yield();
  8005f1:	e8 20 a2 00 00       	call   80a816 <thread_yield>
  8005f6:	83 c4 10             	add    $0x10,%esp
  8005f9:	eb 28                	jmp    800623 <umain+0xa7>
		panic("error forking");
  8005fb:	83 ec 04             	sub    $0x4,%esp
  8005fe:	68 81 15 81 00       	push   $0x811581
  800603:	68 45 01 00 00       	push   $0x145
  800608:	68 d5 14 81 00       	push   $0x8114d5
  80060d:	e8 5d e1 00 00       	call   80e76f <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  800612:	83 ec 08             	sub    $0x8,%esp
  800615:	68 fa 00 00 00       	push   $0xfa
  80061a:	53                   	push   %ebx
  80061b:	e8 67 00 00 00       	call   800687 <timer>
		return;
  800620:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800623:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800626:	c9                   	leave  
  800627:	c3                   	ret    
		panic("error forking");
  800628:	83 ec 04             	sub    $0x4,%esp
  80062b:	68 81 15 81 00       	push   $0x811581
  800630:	68 4f 01 00 00       	push   $0x14f
  800635:	68 d5 14 81 00       	push   $0x8114d5
  80063a:	e8 30 e1 00 00       	call   80e76f <_panic>
		input(ns_envid);
  80063f:	83 ec 0c             	sub    $0xc,%esp
  800642:	53                   	push   %ebx
  800643:	e8 d2 00 00 00       	call   80071a <input>
		return;
  800648:	83 c4 10             	add    $0x10,%esp
  80064b:	eb d6                	jmp    800623 <umain+0xa7>
		panic("error forking");
  80064d:	83 ec 04             	sub    $0x4,%esp
  800650:	68 81 15 81 00       	push   $0x811581
  800655:	68 59 01 00 00       	push   $0x159
  80065a:	68 d5 14 81 00       	push   $0x8114d5
  80065f:	e8 0b e1 00 00       	call   80e76f <_panic>
		cprintf("%d: after fork\n", thisenv->env_id);
  800664:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800669:	8b 40 48             	mov    0x48(%eax),%eax
  80066c:	83 ec 08             	sub    $0x8,%esp
  80066f:	50                   	push   %eax
  800670:	68 8f 15 81 00       	push   $0x81158f
  800675:	e8 eb e1 00 00       	call   80e865 <cprintf>
		output(ns_envid);
  80067a:	89 1c 24             	mov    %ebx,(%esp)
  80067d:	e8 1d 01 00 00       	call   80079f <output>
		return;
  800682:	83 c4 10             	add    $0x10,%esp
  800685:	eb 9c                	jmp    800623 <umain+0xa7>

00800687 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800687:	55                   	push   %ebp
  800688:	89 e5                	mov    %esp,%ebp
  80068a:	57                   	push   %edi
  80068b:	56                   	push   %esi
  80068c:	53                   	push   %ebx
  80068d:	83 ec 1c             	sub    $0x1c,%esp
  800690:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800693:	e8 50 ef 00 00       	call   80f5e8 <sys_time_msec>
  800698:	03 45 0c             	add    0xc(%ebp),%eax
  80069b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80069d:	c7 05 e8 52 81 00 d0 	movl   $0x8115d0,0x8152e8
  8006a4:	15 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006a7:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006aa:	eb 33                	jmp    8006df <timer+0x58>
		if (r < 0)
  8006ac:	85 c0                	test   %eax,%eax
  8006ae:	78 45                	js     8006f5 <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006b0:	6a 00                	push   $0x0
  8006b2:	6a 00                	push   $0x0
  8006b4:	6a 0c                	push   $0xc
  8006b6:	56                   	push   %esi
  8006b7:	e8 3f f5 00 00       	call   80fbfb <ipc_send>
  8006bc:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006bf:	83 ec 04             	sub    $0x4,%esp
  8006c2:	6a 00                	push   $0x0
  8006c4:	6a 00                	push   $0x0
  8006c6:	57                   	push   %edi
  8006c7:	e8 c6 f4 00 00       	call   80fb92 <ipc_recv>
  8006cc:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006d1:	83 c4 10             	add    $0x10,%esp
  8006d4:	39 f0                	cmp    %esi,%eax
  8006d6:	75 2f                	jne    800707 <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006d8:	e8 0b ef 00 00       	call   80f5e8 <sys_time_msec>
  8006dd:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006df:	e8 04 ef 00 00       	call   80f5e8 <sys_time_msec>
  8006e4:	89 c2                	mov    %eax,%edx
  8006e6:	85 c0                	test   %eax,%eax
  8006e8:	78 c2                	js     8006ac <timer+0x25>
  8006ea:	39 d8                	cmp    %ebx,%eax
  8006ec:	73 be                	jae    8006ac <timer+0x25>
			sys_yield();
  8006ee:	e8 a4 ec 00 00       	call   80f397 <sys_yield>
  8006f3:	eb ea                	jmp    8006df <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006f5:	52                   	push   %edx
  8006f6:	68 d9 15 81 00       	push   $0x8115d9
  8006fb:	6a 0f                	push   $0xf
  8006fd:	68 eb 15 81 00       	push   $0x8115eb
  800702:	e8 68 e0 00 00       	call   80e76f <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800707:	83 ec 08             	sub    $0x8,%esp
  80070a:	50                   	push   %eax
  80070b:	68 f8 15 81 00       	push   $0x8115f8
  800710:	e8 50 e1 00 00       	call   80e865 <cprintf>
				continue;
  800715:	83 c4 10             	add    $0x10,%esp
  800718:	eb a5                	jmp    8006bf <timer+0x38>

0080071a <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  80071a:	55                   	push   %ebp
  80071b:	89 e5                	mov    %esp,%ebp
  80071d:	57                   	push   %edi
  80071e:	56                   	push   %esi
  80071f:	53                   	push   %ebx
  800720:	81 ec 0c 08 00 00    	sub    $0x80c,%esp
  800726:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_input";
  800729:	c7 05 e8 52 81 00 33 	movl   $0x811633,0x8152e8
  800730:	16 81 00 
	// another packet in to the same physical page.
	
	int r;
	char buf[2048];
	while(1){
		if((r = sys_net_recv(buf, 2048)) < 0) {
  800733:	8d b5 e8 f7 ff ff    	lea    -0x818(%ebp),%esi
  800739:	eb 46                	jmp    800781 <input+0x67>
       		sys_yield();
       		continue;
     	}
     	while (sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_W|PTE_U) < 0) ;
  80073b:	83 ec 04             	sub    $0x4,%esp
  80073e:	6a 07                	push   $0x7
  800740:	68 00 e0 b3 00       	push   $0xb3e000
  800745:	6a 00                	push   $0x0
  800747:	e8 6a ec 00 00       	call   80f3b6 <sys_page_alloc>
  80074c:	83 c4 10             	add    $0x10,%esp
  80074f:	85 c0                	test   %eax,%eax
  800751:	78 e8                	js     80073b <input+0x21>
     	nsipcbuf.pkt.jp_len = r; 
  800753:	89 3d 00 e0 b3 00    	mov    %edi,0xb3e000
     	memcpy(nsipcbuf.pkt.jp_data, buf, r);
  800759:	83 ec 04             	sub    $0x4,%esp
  80075c:	57                   	push   %edi
  80075d:	56                   	push   %esi
  80075e:	68 04 e0 b3 00       	push   $0xb3e004
  800763:	e8 4c ea 00 00       	call   80f1b4 <memcpy>
     	while(sys_ipc_try_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_W|PTE_U) < 0) ;
  800768:	83 c4 10             	add    $0x10,%esp
  80076b:	6a 07                	push   $0x7
  80076d:	68 00 e0 b3 00       	push   $0xb3e000
  800772:	6a 0a                	push   $0xa
  800774:	53                   	push   %ebx
  800775:	e8 c9 ed 00 00       	call   80f543 <sys_ipc_try_send>
  80077a:	83 c4 10             	add    $0x10,%esp
  80077d:	85 c0                	test   %eax,%eax
  80077f:	78 ea                	js     80076b <input+0x51>
		if((r = sys_net_recv(buf, 2048)) < 0) {
  800781:	83 ec 08             	sub    $0x8,%esp
  800784:	68 00 08 00 00       	push   $0x800
  800789:	56                   	push   %esi
  80078a:	e8 99 ee 00 00       	call   80f628 <sys_net_recv>
  80078f:	89 c7                	mov    %eax,%edi
  800791:	83 c4 10             	add    $0x10,%esp
  800794:	85 c0                	test   %eax,%eax
  800796:	79 a3                	jns    80073b <input+0x21>
       		sys_yield();
  800798:	e8 fa eb 00 00       	call   80f397 <sys_yield>
       		continue;
  80079d:	eb e2                	jmp    800781 <input+0x67>

0080079f <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  80079f:	55                   	push   %ebp
  8007a0:	89 e5                	mov    %esp,%ebp
  8007a2:	56                   	push   %esi
  8007a3:	53                   	push   %ebx
  8007a4:	83 ec 18             	sub    $0x18,%esp
	cprintf("in %s\n", __FUNCTION__);
  8007a7:	68 78 16 81 00       	push   $0x811678
  8007ac:	68 e2 39 81 00       	push   $0x8139e2
  8007b1:	e8 af e0 00 00       	call   80e865 <cprintf>
	binaryname = "ns_output";
  8007b6:	c7 05 e8 52 81 00 3c 	movl   $0x81163c,0x8152e8
  8007bd:	16 81 00 
  8007c0:	83 c4 10             	add    $0x10,%esp
	envid_t from_env_store;
	int perm_store; 

	int r;
	while(1){
		r = ipc_recv(&from_env_store, &nsipcbuf, &perm_store);
  8007c3:	8d 75 f0             	lea    -0x10(%ebp),%esi
  8007c6:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8007c9:	83 ec 04             	sub    $0x4,%esp
  8007cc:	56                   	push   %esi
  8007cd:	68 00 e0 b3 00       	push   $0xb3e000
  8007d2:	53                   	push   %ebx
  8007d3:	e8 ba f3 00 00       	call   80fb92 <ipc_recv>
		if(r < 0)
  8007d8:	83 c4 10             	add    $0x10,%esp
  8007db:	85 c0                	test   %eax,%eax
  8007dd:	78 33                	js     800812 <output+0x73>
			panic("ipc_recv panic\n");
		while((r = sys_net_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0){
  8007df:	83 ec 08             	sub    $0x8,%esp
  8007e2:	ff 35 00 e0 b3 00    	pushl  0xb3e000
  8007e8:	68 04 e0 b3 00       	push   $0xb3e004
  8007ed:	e8 15 ee 00 00       	call   80f607 <sys_net_send>
  8007f2:	83 c4 10             	add    $0x10,%esp
  8007f5:	85 c0                	test   %eax,%eax
  8007f7:	79 d0                	jns    8007c9 <output+0x2a>
			if(r != -E_TX_FULL)
  8007f9:	83 f8 ef             	cmp    $0xffffffef,%eax
  8007fc:	74 e1                	je     8007df <output+0x40>
				panic("sys_net_send panic\n");
  8007fe:	83 ec 04             	sub    $0x4,%esp
  800801:	68 63 16 81 00       	push   $0x811663
  800806:	6a 19                	push   $0x19
  800808:	68 56 16 81 00       	push   $0x811656
  80080d:	e8 5d df 00 00       	call   80e76f <_panic>
			panic("ipc_recv panic\n");
  800812:	83 ec 04             	sub    $0x4,%esp
  800815:	68 46 16 81 00       	push   $0x811646
  80081a:	6a 16                	push   $0x16
  80081c:	68 56 16 81 00       	push   $0x811656
  800821:	e8 49 df 00 00       	call   80e76f <_panic>

00800826 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800826:	89 c2                	mov    %eax,%edx
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800828:	83 f8 1f             	cmp    $0x1f,%eax
  80082b:	77 19                	ja     800846 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  80082d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800830:	8d 04 85 60 60 81 00 	lea    0x816060(,%eax,4),%eax

  if (!sock->conn) {
  800837:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80083a:	8b 14 95 60 60 81 00 	mov    0x816060(,%edx,4),%edx
  800841:	85 d2                	test   %edx,%edx
  800843:	74 11                	je     800856 <get_socket+0x30>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  800845:	c3                   	ret    
    set_errno(EBADF);
  800846:	c7 05 e0 c1 b3 00 09 	movl   $0x9,0xb3c1e0
  80084d:	00 00 00 
    return NULL;
  800850:	b8 00 00 00 00       	mov    $0x0,%eax
  800855:	c3                   	ret    
    set_errno(EBADF);
  800856:	c7 05 e0 c1 b3 00 09 	movl   $0x9,0xb3c1e0
  80085d:	00 00 00 
    return NULL;
  800860:	89 d0                	mov    %edx,%eax
  800862:	eb e1                	jmp    800845 <get_socket+0x1f>

00800864 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800864:	55                   	push   %ebp
  800865:	89 e5                	mov    %esp,%ebp
  800867:	57                   	push   %edi
  800868:	56                   	push   %esi
  800869:	53                   	push   %ebx
  80086a:	83 ec 40             	sub    $0x40,%esp
  80086d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800870:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800873:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800876:	6a 04                	push   $0x4
  800878:	6a 00                	push   $0x0
  80087a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80087d:	50                   	push   %eax
  80087e:	e8 87 e8 00 00       	call   80f10a <memset>
  FD_ZERO(&lwriteset);
  800883:	83 c4 0c             	add    $0xc,%esp
  800886:	6a 04                	push   $0x4
  800888:	6a 00                	push   $0x0
  80088a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80088d:	50                   	push   %eax
  80088e:	e8 77 e8 00 00       	call   80f10a <memset>
  FD_ZERO(&lexceptset);
  800893:	83 c4 0c             	add    $0xc,%esp
  800896:	6a 04                	push   $0x4
  800898:	6a 00                	push   $0x0
  80089a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80089d:	50                   	push   %eax
  80089e:	e8 67 e8 00 00       	call   80f10a <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8008a3:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  8008a6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  8008ad:	bf 00 00 00 00       	mov    $0x0,%edi
  8008b2:	eb 33                	jmp    8008e7 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8008b4:	89 f8                	mov    %edi,%eax
  8008b6:	e8 6b ff ff ff       	call   800826 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008bb:	85 c0                	test   %eax,%eax
  8008bd:	74 4c                	je     80090b <lwip_selscan+0xa7>
  8008bf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8008c3:	74 16                	je     8008db <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8008c5:	b8 01 00 00 00       	mov    $0x1,%eax
  8008ca:	89 f1                	mov    %esi,%ecx
  8008cc:	d3 e0                	shl    %cl,%eax
  8008ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008d1:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8008d5:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8008d9:	eb 30                	jmp    80090b <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8008db:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8008e0:	74 29                	je     80090b <lwip_selscan+0xa7>
  8008e2:	eb e1                	jmp    8008c5 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8008e4:	83 c7 01             	add    $0x1,%edi
  8008e7:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8008ea:	7d 53                	jge    80093f <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8008ec:	8d 5f 07             	lea    0x7(%edi),%ebx
  8008ef:	85 ff                	test   %edi,%edi
  8008f1:	0f 49 df             	cmovns %edi,%ebx
  8008f4:	c1 fb 03             	sar    $0x3,%ebx
  8008f7:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8008fa:	89 fe                	mov    %edi,%esi
  8008fc:	83 e6 07             	and    $0x7,%esi
  8008ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800902:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800906:	0f a3 f0             	bt     %esi,%eax
  800909:	72 a9                	jb     8008b4 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  80090b:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80090e:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800912:	0f a3 f0             	bt     %esi,%eax
  800915:	73 cd                	jae    8008e4 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800917:	89 f8                	mov    %edi,%eax
  800919:	e8 08 ff ff ff       	call   800826 <get_socket>
      if (p_sock && p_sock->sendevent) {
  80091e:	85 c0                	test   %eax,%eax
  800920:	74 c2                	je     8008e4 <lwip_selscan+0x80>
  800922:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800927:	74 bb                	je     8008e4 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800929:	b8 01 00 00 00       	mov    $0x1,%eax
  80092e:	89 f1                	mov    %esi,%ecx
  800930:	d3 e0                	shl    %cl,%eax
  800932:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800935:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800939:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  80093d:	eb a5                	jmp    8008e4 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  80093f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800942:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800945:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800947:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80094a:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80094d:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  80094f:	83 ec 04             	sub    $0x4,%esp
  800952:	6a 04                	push   $0x4
  800954:	6a 00                	push   $0x0
  800956:	ff 75 08             	pushl  0x8(%ebp)
  800959:	e8 ac e7 00 00       	call   80f10a <memset>
  
  return nready;
}
  80095e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800961:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800964:	5b                   	pop    %ebx
  800965:	5e                   	pop    %esi
  800966:	5f                   	pop    %edi
  800967:	5d                   	pop    %ebp
  800968:	c3                   	ret    

00800969 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800969:	55                   	push   %ebp
  80096a:	89 e5                	mov    %esp,%ebp
  80096c:	57                   	push   %edi
  80096d:	56                   	push   %esi
  80096e:	53                   	push   %ebx
  80096f:	83 ec 3c             	sub    $0x3c,%esp
  800972:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800975:	89 cf                	mov    %ecx,%edi
  800977:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80097a:	e8 a7 fe ff ff       	call   800826 <get_socket>
  if (!sock)
  80097f:	85 c0                	test   %eax,%eax
  800981:	0f 84 86 00 00 00    	je     800a0d <lwip_getaddrname+0xa4>
  800987:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800989:	83 ec 04             	sub    $0x4,%esp
  80098c:	6a 10                	push   $0x10
  80098e:	6a 00                	push   $0x0
  800990:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800993:	50                   	push   %eax
  800994:	e8 71 e7 00 00       	call   80f10a <memset>
  sin.sin_len = sizeof(sin);
  800999:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  80099d:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8009a1:	89 f0                	mov    %esi,%eax
  8009a3:	0f b6 f0             	movzbl %al,%esi
  8009a6:	56                   	push   %esi
  8009a7:	8d 45 da             	lea    -0x26(%ebp),%eax
  8009aa:	50                   	push   %eax
  8009ab:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8009ae:	50                   	push   %eax
  8009af:	ff 33                	pushl  (%ebx)
  8009b1:	e8 92 a4 00 00       	call   80ae48 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8009b6:	83 c4 14             	add    $0x14,%esp
  8009b9:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8009bd:	50                   	push   %eax
  8009be:	e8 1b 6e 00 00       	call   8077de <htons>
  8009c3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8009c7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8009ca:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8009cd:	83 c4 10             	add    $0x10,%esp
  8009d0:	83 3f 10             	cmpl   $0x10,(%edi)
  8009d3:	76 06                	jbe    8009db <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8009d5:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8009db:	83 ec 04             	sub    $0x4,%esp
  8009de:	ff 37                	pushl  (%edi)
  8009e0:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8009e3:	50                   	push   %eax
  8009e4:	ff 75 c4             	pushl  -0x3c(%ebp)
  8009e7:	e8 c8 e7 00 00       	call   80f1b4 <memcpy>
  sock_set_errno(sock, 0);
  8009ec:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8009f3:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8009fa:	00 00 00 
  return 0;
  8009fd:	83 c4 10             	add    $0x10,%esp
  800a00:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800a05:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a08:	5b                   	pop    %ebx
  800a09:	5e                   	pop    %esi
  800a0a:	5f                   	pop    %edi
  800a0b:	5d                   	pop    %ebp
  800a0c:	c3                   	ret    
    return -1;
  800a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800a12:	eb f1                	jmp    800a05 <lwip_getaddrname+0x9c>

00800a14 <event_callback>:
{
  800a14:	55                   	push   %ebp
  800a15:	89 e5                	mov    %esp,%ebp
  800a17:	57                   	push   %edi
  800a18:	56                   	push   %esi
  800a19:	53                   	push   %ebx
  800a1a:	83 ec 1c             	sub    $0x1c,%esp
  800a1d:	8b 7d 08             	mov    0x8(%ebp),%edi
  800a20:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800a23:	85 ff                	test   %edi,%edi
  800a25:	0f 84 8b 01 00 00    	je     800bb6 <event_callback+0x1a2>
    s = conn->socket;
  800a2b:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800a2e:	85 db                	test   %ebx,%ebx
  800a30:	78 4d                	js     800a7f <event_callback+0x6b>
    sock = get_socket(s);
  800a32:	89 d8                	mov    %ebx,%eax
  800a34:	e8 ed fd ff ff       	call   800826 <get_socket>
  800a39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800a3c:	85 c0                	test   %eax,%eax
  800a3e:	0f 84 72 01 00 00    	je     800bb6 <event_callback+0x1a2>
  sys_sem_wait(selectsem);
  800a44:	83 ec 0c             	sub    $0xc,%esp
  800a47:	ff 35 40 60 81 00    	pushl  0x816040
  800a4d:	e8 90 47 00 00       	call   8051e2 <sys_sem_wait>
  switch (evt) {
  800a52:	83 c4 10             	add    $0x10,%esp
  800a55:	83 fe 01             	cmp    $0x1,%esi
  800a58:	0f 84 a1 00 00 00    	je     800aff <event_callback+0xeb>
  800a5e:	85 f6                	test   %esi,%esi
  800a60:	74 68                	je     800aca <event_callback+0xb6>
  800a62:	83 fe 02             	cmp    $0x2,%esi
  800a65:	0f 84 9e 00 00 00    	je     800b09 <event_callback+0xf5>
  800a6b:	83 fe 03             	cmp    $0x3,%esi
  800a6e:	0f 85 a0 00 00 00    	jne    800b14 <event_callback+0x100>
      sock->sendevent = 0;
  800a74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a77:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800a7d:	eb 53                	jmp    800ad2 <event_callback+0xbe>
      sys_sem_wait(socksem);
  800a7f:	83 ec 0c             	sub    $0xc,%esp
  800a82:	ff 35 44 60 81 00    	pushl  0x816044
  800a88:	e8 55 47 00 00       	call   8051e2 <sys_sem_wait>
      if (conn->socket < 0) {
  800a8d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a90:	83 c4 10             	add    $0x10,%esp
  800a93:	85 c0                	test   %eax,%eax
  800a95:	78 13                	js     800aaa <event_callback+0x96>
      sys_sem_signal(socksem);
  800a97:	83 ec 0c             	sub    $0xc,%esp
  800a9a:	ff 35 44 60 81 00    	pushl  0x816044
  800aa0:	e8 cf 96 00 00       	call   80a174 <sys_sem_signal>
  800aa5:	83 c4 10             	add    $0x10,%esp
  800aa8:	eb 88                	jmp    800a32 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800aaa:	85 f6                	test   %esi,%esi
  800aac:	75 06                	jne    800ab4 <event_callback+0xa0>
          conn->socket--;
  800aae:	83 e8 01             	sub    $0x1,%eax
  800ab1:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800ab4:	83 ec 0c             	sub    $0xc,%esp
  800ab7:	ff 35 44 60 81 00    	pushl  0x816044
  800abd:	e8 b2 96 00 00       	call   80a174 <sys_sem_signal>
        return;
  800ac2:	83 c4 10             	add    $0x10,%esp
  800ac5:	e9 ec 00 00 00       	jmp    800bb6 <event_callback+0x1a2>
      sock->rcvevent++;
  800aca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800acd:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800ad2:	83 ec 0c             	sub    $0xc,%esp
  800ad5:	ff 35 40 60 81 00    	pushl  0x816040
  800adb:	e8 94 96 00 00       	call   80a174 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800ae0:	8d 73 07             	lea    0x7(%ebx),%esi
  800ae3:	83 c4 10             	add    $0x10,%esp
  800ae6:	85 db                	test   %ebx,%ebx
  800ae8:	0f 49 f3             	cmovns %ebx,%esi
  800aeb:	c1 fe 03             	sar    $0x3,%esi
  800aee:	89 d9                	mov    %ebx,%ecx
  800af0:	83 e1 07             	and    $0x7,%ecx
  800af3:	bf 01 00 00 00       	mov    $0x1,%edi
  800af8:	d3 e7                	shl    %cl,%edi
  800afa:	e9 8d 00 00 00       	jmp    800b8c <event_callback+0x178>
      sock->rcvevent--;
  800aff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b02:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800b07:	eb c9                	jmp    800ad2 <event_callback+0xbe>
      sock->sendevent = 1;
  800b09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b0c:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800b12:	eb be                	jmp    800ad2 <event_callback+0xbe>
      LWIP_ASSERT("unknown event", 0);
  800b14:	83 ec 04             	sub    $0x4,%esp
  800b17:	68 7f 16 81 00       	push   $0x81167f
  800b1c:	68 17 04 00 00       	push   $0x417
  800b21:	68 8d 16 81 00       	push   $0x81168d
  800b26:	e8 44 dc 00 00       	call   80e76f <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b2b:	8b 1b                	mov    (%ebx),%ebx
  800b2d:	85 db                	test   %ebx,%ebx
  800b2f:	74 74                	je     800ba5 <event_callback+0x191>
      if (scb->sem_signalled == 0) {
  800b31:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800b35:	75 f4                	jne    800b2b <event_callback+0x117>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800b37:	8b 43 04             	mov    0x4(%ebx),%eax
  800b3a:	85 c0                	test   %eax,%eax
  800b3c:	74 12                	je     800b50 <event_callback+0x13c>
  800b3e:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b42:	85 f8                	test   %edi,%eax
  800b44:	74 0a                	je     800b50 <event_callback+0x13c>
          if (sock->rcvevent)
  800b46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b49:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800b4e:	75 19                	jne    800b69 <event_callback+0x155>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800b50:	8b 43 08             	mov    0x8(%ebx),%eax
  800b53:	85 c0                	test   %eax,%eax
  800b55:	74 d4                	je     800b2b <event_callback+0x117>
  800b57:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800b5b:	85 f8                	test   %edi,%eax
  800b5d:	74 cc                	je     800b2b <event_callback+0x117>
          if (sock->sendevent)
  800b5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b62:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800b67:	74 c2                	je     800b2b <event_callback+0x117>
      scb->sem_signalled = 1;
  800b69:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800b70:	83 ec 0c             	sub    $0xc,%esp
  800b73:	ff 35 40 60 81 00    	pushl  0x816040
  800b79:	e8 f6 95 00 00       	call   80a174 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b7e:	83 c4 04             	add    $0x4,%esp
  800b81:	ff 73 14             	pushl  0x14(%ebx)
  800b84:	e8 eb 95 00 00       	call   80a174 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800b89:	83 c4 10             	add    $0x10,%esp
  800b8c:	83 ec 0c             	sub    $0xc,%esp
  800b8f:	ff 35 40 60 81 00    	pushl  0x816040
  800b95:	e8 48 46 00 00       	call   8051e2 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b9a:	8b 1d 48 60 81 00    	mov    0x816048,%ebx
  800ba0:	83 c4 10             	add    $0x10,%esp
  800ba3:	eb 88                	jmp    800b2d <event_callback+0x119>
      sys_sem_signal(selectsem);
  800ba5:	83 ec 0c             	sub    $0xc,%esp
  800ba8:	ff 35 40 60 81 00    	pushl  0x816040
  800bae:	e8 c1 95 00 00       	call   80a174 <sys_sem_signal>
      break;
  800bb3:	83 c4 10             	add    $0x10,%esp
}
  800bb6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800bb9:	5b                   	pop    %ebx
  800bba:	5e                   	pop    %esi
  800bbb:	5f                   	pop    %edi
  800bbc:	5d                   	pop    %ebp
  800bbd:	c3                   	ret    

00800bbe <alloc_socket>:
{
  800bbe:	55                   	push   %ebp
  800bbf:	89 e5                	mov    %esp,%ebp
  800bc1:	56                   	push   %esi
  800bc2:	53                   	push   %ebx
  800bc3:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800bc5:	83 ec 0c             	sub    $0xc,%esp
  800bc8:	ff 35 44 60 81 00    	pushl  0x816044
  800bce:	e8 0f 46 00 00       	call   8051e2 <sys_sem_wait>
  800bd3:	b8 60 60 81 00       	mov    $0x816060,%eax
  800bd8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800bdb:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800be0:	83 38 00             	cmpl   $0x0,(%eax)
  800be3:	74 23                	je     800c08 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800be5:	83 c3 01             	add    $0x1,%ebx
  800be8:	83 c0 14             	add    $0x14,%eax
  800beb:	83 fb 20             	cmp    $0x20,%ebx
  800bee:	75 f0                	jne    800be0 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800bf0:	83 ec 0c             	sub    $0xc,%esp
  800bf3:	ff 35 44 60 81 00    	pushl  0x816044
  800bf9:	e8 76 95 00 00       	call   80a174 <sys_sem_signal>
  return -1;
  800bfe:	83 c4 10             	add    $0x10,%esp
  800c01:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800c06:	eb 55                	jmp    800c5d <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800c08:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800c0b:	c1 e2 02             	shl    $0x2,%edx
  800c0e:	89 b2 60 60 81 00    	mov    %esi,0x816060(%edx)
      sockets[i].lastdata   = NULL;
  800c14:	c7 82 64 60 81 00 00 	movl   $0x0,0x816064(%edx)
  800c1b:	00 00 00 
      sockets[i].lastoffset = 0;
  800c1e:	66 c7 82 68 60 81 00 	movw   $0x0,0x816068(%edx)
  800c25:	00 00 
      sockets[i].rcvevent   = 0;
  800c27:	66 c7 82 6a 60 81 00 	movw   $0x0,0x81606a(%edx)
  800c2e:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800c30:	66 c7 82 6c 60 81 00 	movw   $0x1,0x81606c(%edx)
  800c37:	01 00 
      sockets[i].flags      = 0;
  800c39:	66 c7 82 6e 60 81 00 	movw   $0x0,0x81606e(%edx)
  800c40:	00 00 
      sockets[i].err        = 0;
  800c42:	c7 82 70 60 81 00 00 	movl   $0x0,0x816070(%edx)
  800c49:	00 00 00 
      sys_sem_signal(socksem);
  800c4c:	83 ec 0c             	sub    $0xc,%esp
  800c4f:	ff 35 44 60 81 00    	pushl  0x816044
  800c55:	e8 1a 95 00 00       	call   80a174 <sys_sem_signal>
      return i;
  800c5a:	83 c4 10             	add    $0x10,%esp
}
  800c5d:	89 d8                	mov    %ebx,%eax
  800c5f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800c62:	5b                   	pop    %ebx
  800c63:	5e                   	pop    %esi
  800c64:	5d                   	pop    %ebp
  800c65:	c3                   	ret    

00800c66 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800c66:	55                   	push   %ebp
  800c67:	89 e5                	mov    %esp,%ebp
  800c69:	53                   	push   %ebx
  800c6a:	83 ec 04             	sub    $0x4,%esp
  800c6d:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c70:	85 c0                	test   %eax,%eax
  800c72:	74 39                	je     800cad <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800c74:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800c76:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800c79:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800c7c:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800c7f:	83 fa 06             	cmp    $0x6,%edx
  800c82:	0f 84 37 01 00 00    	je     800dbf <lwip_getsockopt_internal+0x159>
  800c88:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800c8e:	74 34                	je     800cc4 <lwip_getsockopt_internal+0x5e>
  800c90:	85 d2                	test   %edx,%edx
  800c92:	0f 84 f9 00 00 00    	je     800d91 <lwip_getsockopt_internal+0x12b>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c98:	83 ec 0c             	sub    $0xc,%esp
  800c9b:	8b 03                	mov    (%ebx),%eax
  800c9d:	ff 70 10             	pushl  0x10(%eax)
  800ca0:	e8 cf 94 00 00       	call   80a174 <sys_sem_signal>
}
  800ca5:	83 c4 10             	add    $0x10,%esp
  800ca8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800cab:	c9                   	leave  
  800cac:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800cad:	83 ec 04             	sub    $0x4,%esp
  800cb0:	68 a4 16 81 00       	push   $0x8116a4
  800cb5:	68 38 05 00 00       	push   $0x538
  800cba:	68 8d 16 81 00       	push   $0x81168d
  800cbf:	e8 ab da 00 00       	call   80e76f <_panic>
  800cc4:	83 f9 20             	cmp    $0x20,%ecx
  800cc7:	74 65                	je     800d2e <lwip_getsockopt_internal+0xc8>
  800cc9:	7e 55                	jle    800d20 <lwip_getsockopt_internal+0xba>
  800ccb:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800cd1:	74 6d                	je     800d40 <lwip_getsockopt_internal+0xda>
  800cd3:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800cd9:	0f 84 9f 00 00 00    	je     800d7e <lwip_getsockopt_internal+0x118>
  800cdf:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800ce5:	75 b1                	jne    800c98 <lwip_getsockopt_internal+0x32>
      if (sock->err == 0) {
  800ce7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800ceb:	75 22                	jne    800d0f <lwip_getsockopt_internal+0xa9>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800ced:	8b 13                	mov    (%ebx),%edx
  800cef:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800cf3:	f7 da                	neg    %edx
  800cf5:	b9 05 00 00 00       	mov    $0x5,%ecx
  800cfa:	83 fa 0e             	cmp    $0xe,%edx
  800cfd:	77 07                	ja     800d06 <lwip_getsockopt_internal+0xa0>
  800cff:	8b 0c 95 40 17 81 00 	mov    0x811740(,%edx,4),%ecx
  800d06:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800d09:	89 0d e0 c1 b3 00    	mov    %ecx,0xb3c1e0
      *(int *)optval = sock->err;
  800d0f:	8b 53 10             	mov    0x10(%ebx),%edx
  800d12:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800d14:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800d1b:	e9 78 ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
  800d20:	83 f9 02             	cmp    $0x2,%ecx
  800d23:	74 09                	je     800d2e <lwip_getsockopt_internal+0xc8>
  800d25:	83 f9 08             	cmp    $0x8,%ecx
  800d28:	0f 85 6a ff ff ff    	jne    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800d2e:	8b 13                	mov    (%ebx),%edx
  800d30:	8b 52 08             	mov    0x8(%edx),%edx
  800d33:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800d37:	21 d1                	and    %edx,%ecx
  800d39:	89 08                	mov    %ecx,(%eax)
      break;
  800d3b:	e9 58 ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800d40:	8b 13                	mov    (%ebx),%edx
  800d42:	8b 12                	mov    (%edx),%edx
  800d44:	89 d1                	mov    %edx,%ecx
  800d46:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800d4c:	83 f9 20             	cmp    $0x20,%ecx
  800d4f:	74 22                	je     800d73 <lwip_getsockopt_internal+0x10d>
  800d51:	83 f9 40             	cmp    $0x40,%ecx
  800d54:	74 12                	je     800d68 <lwip_getsockopt_internal+0x102>
        *(int*)optval = sock->conn->type;
  800d56:	83 f9 10             	cmp    $0x10,%ecx
  800d59:	b9 01 00 00 00       	mov    $0x1,%ecx
  800d5e:	0f 44 d1             	cmove  %ecx,%edx
  800d61:	89 10                	mov    %edx,(%eax)
  800d63:	e9 30 ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_RAW;
  800d68:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800d6e:	e9 25 ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_DGRAM;
  800d73:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800d79:	e9 1a ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800d7e:	8b 13                	mov    (%ebx),%edx
  800d80:	8b 52 08             	mov    0x8(%edx),%edx
  800d83:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800d87:	83 e2 01             	and    $0x1,%edx
  800d8a:	89 10                	mov    %edx,(%eax)
      break;
  800d8c:	e9 07 ff ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
  800d91:	83 f9 01             	cmp    $0x1,%ecx
  800d94:	74 19                	je     800daf <lwip_getsockopt_internal+0x149>
  800d96:	83 f9 02             	cmp    $0x2,%ecx
  800d99:	0f 85 f9 fe ff ff    	jne    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d9f:	8b 13                	mov    (%ebx),%edx
  800da1:	8b 52 08             	mov    0x8(%edx),%edx
  800da4:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800da8:	89 10                	mov    %edx,(%eax)
      break;
  800daa:	e9 e9 fe ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800daf:	8b 13                	mov    (%ebx),%edx
  800db1:	8b 52 08             	mov    0x8(%edx),%edx
  800db4:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800db8:	89 10                	mov    %edx,(%eax)
      break;
  800dba:	e9 d9 fe ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
  800dbf:	83 f9 01             	cmp    $0x1,%ecx
  800dc2:	74 1b                	je     800ddf <lwip_getsockopt_internal+0x179>
  800dc4:	83 f9 02             	cmp    $0x2,%ecx
  800dc7:	0f 85 cb fe ff ff    	jne    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800dcd:	8b 13                	mov    (%ebx),%edx
  800dcf:	8b 52 08             	mov    0x8(%edx),%edx
  800dd2:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800dd8:	89 10                	mov    %edx,(%eax)
      break;
  800dda:	e9 b9 fe ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ddf:	8b 13                	mov    (%ebx),%edx
  800de1:	8b 52 08             	mov    0x8(%edx),%edx
  800de4:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800de8:	83 e2 40             	and    $0x40,%edx
  800deb:	0f b6 d2             	movzbl %dl,%edx
  800dee:	89 10                	mov    %edx,(%eax)
      break;
  800df0:	e9 a3 fe ff ff       	jmp    800c98 <lwip_getsockopt_internal+0x32>

00800df5 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800df5:	55                   	push   %ebp
  800df6:	89 e5                	mov    %esp,%ebp
  800df8:	53                   	push   %ebx
  800df9:	83 ec 04             	sub    $0x4,%esp
  800dfc:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dff:	85 c0                	test   %eax,%eax
  800e01:	74 35                	je     800e38 <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800e03:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800e05:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800e08:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800e0b:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800e0e:	83 fa 06             	cmp    $0x6,%edx
  800e11:	0f 84 aa 00 00 00    	je     800ec1 <lwip_setsockopt_internal+0xcc>
  800e17:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800e1d:	74 30                	je     800e4f <lwip_setsockopt_internal+0x5a>
  800e1f:	85 d2                	test   %edx,%edx
  800e21:	74 76                	je     800e99 <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800e23:	83 ec 0c             	sub    $0xc,%esp
  800e26:	8b 03                	mov    (%ebx),%eax
  800e28:	ff 70 10             	pushl  0x10(%eax)
  800e2b:	e8 44 93 00 00       	call   80a174 <sys_sem_signal>
}
  800e30:	83 c4 10             	add    $0x10,%esp
  800e33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800e36:	c9                   	leave  
  800e37:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800e38:	83 ec 04             	sub    $0x4,%esp
  800e3b:	68 a4 16 81 00       	push   $0x8116a4
  800e40:	68 ae 06 00 00       	push   $0x6ae
  800e45:	68 8d 16 81 00       	push   $0x81168d
  800e4a:	e8 20 d9 00 00       	call   80e76f <_panic>
  800e4f:	83 f9 20             	cmp    $0x20,%ecx
  800e52:	74 0d                	je     800e61 <lwip_setsockopt_internal+0x6c>
  800e54:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800e5a:	74 22                	je     800e7e <lwip_setsockopt_internal+0x89>
  800e5c:	83 f9 08             	cmp    $0x8,%ecx
  800e5f:	75 c2                	jne    800e23 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e61:	83 38 00             	cmpl   $0x0,(%eax)
  800e64:	74 0b                	je     800e71 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800e66:	8b 03                	mov    (%ebx),%eax
  800e68:	8b 40 08             	mov    0x8(%eax),%eax
  800e6b:	66 09 48 08          	or     %cx,0x8(%eax)
  800e6f:	eb b2                	jmp    800e23 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800e71:	8b 03                	mov    (%ebx),%eax
  800e73:	8b 40 08             	mov    0x8(%eax),%eax
  800e76:	f7 d1                	not    %ecx
  800e78:	66 21 48 08          	and    %cx,0x8(%eax)
  800e7c:	eb a5                	jmp    800e23 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e7e:	83 38 00             	cmpl   $0x0,(%eax)
  800e81:	74 0b                	je     800e8e <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e83:	8b 03                	mov    (%ebx),%eax
  800e85:	8b 40 08             	mov    0x8(%eax),%eax
  800e88:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e8c:	eb 95                	jmp    800e23 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e8e:	8b 03                	mov    (%ebx),%eax
  800e90:	8b 40 08             	mov    0x8(%eax),%eax
  800e93:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e97:	eb 8a                	jmp    800e23 <lwip_setsockopt_internal+0x2e>
  800e99:	83 f9 01             	cmp    $0x1,%ecx
  800e9c:	74 14                	je     800eb2 <lwip_setsockopt_internal+0xbd>
  800e9e:	83 f9 02             	cmp    $0x2,%ecx
  800ea1:	75 80                	jne    800e23 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800ea3:	8b 13                	mov    (%ebx),%edx
  800ea5:	8b 52 08             	mov    0x8(%edx),%edx
  800ea8:	8b 00                	mov    (%eax),%eax
  800eaa:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800ead:	e9 71 ff ff ff       	jmp    800e23 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800eb2:	8b 13                	mov    (%ebx),%edx
  800eb4:	8b 52 08             	mov    0x8(%edx),%edx
  800eb7:	8b 00                	mov    (%eax),%eax
  800eb9:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800ebc:	e9 62 ff ff ff       	jmp    800e23 <lwip_setsockopt_internal+0x2e>
  800ec1:	83 f9 01             	cmp    $0x1,%ecx
  800ec4:	74 1b                	je     800ee1 <lwip_setsockopt_internal+0xec>
  800ec6:	83 f9 02             	cmp    $0x2,%ecx
  800ec9:	0f 85 54 ff ff ff    	jne    800e23 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800ecf:	8b 13                	mov    (%ebx),%edx
  800ed1:	8b 52 08             	mov    0x8(%edx),%edx
  800ed4:	8b 00                	mov    (%eax),%eax
  800ed6:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800edc:	e9 42 ff ff ff       	jmp    800e23 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800ee1:	83 38 00             	cmpl   $0x0,(%eax)
  800ee4:	74 0e                	je     800ef4 <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800ee6:	8b 03                	mov    (%ebx),%eax
  800ee8:	8b 40 08             	mov    0x8(%eax),%eax
  800eeb:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800eef:	e9 2f ff ff ff       	jmp    800e23 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800ef4:	8b 03                	mov    (%ebx),%eax
  800ef6:	8b 40 08             	mov    0x8(%eax),%eax
  800ef9:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800efd:	e9 21 ff ff ff       	jmp    800e23 <lwip_setsockopt_internal+0x2e>

00800f02 <lwip_socket_init>:
{
  800f02:	55                   	push   %ebp
  800f03:	89 e5                	mov    %esp,%ebp
  800f05:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800f08:	6a 01                	push   $0x1
  800f0a:	e8 a8 8f 00 00       	call   809eb7 <sys_sem_new>
  800f0f:	a3 44 60 81 00       	mov    %eax,0x816044
  selectsem = sys_sem_new(1);
  800f14:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800f1b:	e8 97 8f 00 00       	call   809eb7 <sys_sem_new>
  800f20:	a3 40 60 81 00       	mov    %eax,0x816040
}
  800f25:	83 c4 10             	add    $0x10,%esp
  800f28:	c9                   	leave  
  800f29:	c3                   	ret    

00800f2a <lwip_accept>:
{
  800f2a:	55                   	push   %ebp
  800f2b:	89 e5                	mov    %esp,%ebp
  800f2d:	57                   	push   %edi
  800f2e:	56                   	push   %esi
  800f2f:	53                   	push   %ebx
  800f30:	83 ec 3c             	sub    $0x3c,%esp
  800f33:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800f36:	8b 45 08             	mov    0x8(%ebp),%eax
  800f39:	e8 e8 f8 ff ff       	call   800826 <get_socket>
  if (!sock)
  800f3e:	85 c0                	test   %eax,%eax
  800f40:	0f 84 8c 01 00 00    	je     8010d2 <lwip_accept+0x1a8>
  800f46:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800f48:	83 ec 0c             	sub    $0xc,%esp
  800f4b:	ff 30                	pushl  (%eax)
  800f4d:	e8 ac a0 00 00       	call   80affe <netconn_accept>
  800f52:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800f54:	83 c4 10             	add    $0x10,%esp
  800f57:	85 c0                	test   %eax,%eax
  800f59:	0f 84 de 00 00 00    	je     80103d <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  800f5f:	6a 00                	push   $0x0
  800f61:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800f64:	50                   	push   %eax
  800f65:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800f68:	50                   	push   %eax
  800f69:	53                   	push   %ebx
  800f6a:	e8 d9 9e 00 00       	call   80ae48 <netconn_getaddr>
  800f6f:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800f72:	83 c4 10             	add    $0x10,%esp
  800f75:	84 c0                	test   %al,%al
  800f77:	0f 85 e9 00 00 00    	jne    801066 <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  800f7d:	83 ec 04             	sub    $0x4,%esp
  800f80:	6a 10                	push   $0x10
  800f82:	6a 00                	push   $0x0
  800f84:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f87:	50                   	push   %eax
  800f88:	e8 7d e1 00 00       	call   80f10a <memset>
  sin.sin_len = sizeof(sin);
  800f8d:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f91:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800f95:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800f99:	89 04 24             	mov    %eax,(%esp)
  800f9c:	e8 3d 68 00 00       	call   8077de <htons>
  800fa1:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800fa5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800fa8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800fab:	83 c4 10             	add    $0x10,%esp
  800fae:	83 3f 10             	cmpl   $0x10,(%edi)
  800fb1:	76 06                	jbe    800fb9 <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800fb3:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800fb9:	83 ec 04             	sub    $0x4,%esp
  800fbc:	ff 37                	pushl  (%edi)
  800fbe:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800fc1:	50                   	push   %eax
  800fc2:	ff 75 0c             	pushl  0xc(%ebp)
  800fc5:	e8 ea e1 00 00       	call   80f1b4 <memcpy>
  newsock = alloc_socket(newconn);
  800fca:	89 d8                	mov    %ebx,%eax
  800fcc:	e8 ed fb ff ff       	call   800bbe <alloc_socket>
  800fd1:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800fd3:	83 c4 10             	add    $0x10,%esp
  800fd6:	83 f8 ff             	cmp    $0xffffffff,%eax
  800fd9:	0f 84 ba 00 00 00    	je     801099 <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800fdf:	83 f8 1f             	cmp    $0x1f,%eax
  800fe2:	0f 87 d3 00 00 00    	ja     8010bb <lwip_accept+0x191>
  newconn->callback = event_callback;
  800fe8:	c7 43 2c 14 0a 80 00 	movl   $0x800a14,0x2c(%ebx)
  sys_sem_wait(socksem);
  800fef:	83 ec 0c             	sub    $0xc,%esp
  800ff2:	ff 35 44 60 81 00    	pushl  0x816044
  800ff8:	e8 e5 41 00 00       	call   8051e2 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800ffd:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  801000:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  801004:	f7 d2                	not    %edx
  801006:	66 01 14 85 6a 60 81 	add    %dx,0x81606a(,%eax,4)
  80100d:	00 
  newconn->socket = newsock;
  80100e:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801011:	83 c4 04             	add    $0x4,%esp
  801014:	ff 35 44 60 81 00    	pushl  0x816044
  80101a:	e8 55 91 00 00       	call   80a174 <sys_sem_signal>
  sock_set_errno(sock, 0);
  80101f:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801026:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80102d:	00 00 00 
  return newsock;
  801030:	83 c4 10             	add    $0x10,%esp
}
  801033:	89 f8                	mov    %edi,%eax
  801035:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801038:	5b                   	pop    %ebx
  801039:	5e                   	pop    %esi
  80103a:	5f                   	pop    %edi
  80103b:	5d                   	pop    %ebp
  80103c:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  80103d:	8b 06                	mov    (%esi),%eax
  80103f:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  801043:	f7 d8                	neg    %eax
  801045:	ba 05 00 00 00       	mov    $0x5,%edx
  80104a:	83 f8 0e             	cmp    $0xe,%eax
  80104d:	77 07                	ja     801056 <lwip_accept+0x12c>
  80104f:	8b 14 85 40 17 81 00 	mov    0x811740(,%eax,4),%edx
  801056:	89 56 10             	mov    %edx,0x10(%esi)
  801059:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  80105f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  801064:	eb cd                	jmp    801033 <lwip_accept+0x109>
    netconn_delete(newconn);
  801066:	83 ec 0c             	sub    $0xc,%esp
  801069:	53                   	push   %ebx
  80106a:	e8 71 9d 00 00       	call   80ade0 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80106f:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  801073:	f7 d8                	neg    %eax
  801075:	83 c4 10             	add    $0x10,%esp
  801078:	ba 05 00 00 00       	mov    $0x5,%edx
  80107d:	83 f8 0e             	cmp    $0xe,%eax
  801080:	77 07                	ja     801089 <lwip_accept+0x15f>
  801082:	8b 14 85 40 17 81 00 	mov    0x811740(,%eax,4),%edx
  801089:	89 56 10             	mov    %edx,0x10(%esi)
  80108c:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  801092:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  801097:	eb 9a                	jmp    801033 <lwip_accept+0x109>
    netconn_delete(newconn);
  801099:	83 ec 0c             	sub    $0xc,%esp
  80109c:	53                   	push   %ebx
  80109d:	e8 3e 9d 00 00       	call   80ade0 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  8010a2:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  8010a9:	c7 05 e0 c1 b3 00 17 	movl   $0x17,0xb3c1e0
  8010b0:	00 00 00 
    return -1;
  8010b3:	83 c4 10             	add    $0x10,%esp
  8010b6:	e9 78 ff ff ff       	jmp    801033 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8010bb:	83 ec 04             	sub    $0x4,%esp
  8010be:	68 b0 16 81 00       	push   $0x8116b0
  8010c3:	68 25 01 00 00       	push   $0x125
  8010c8:	68 8d 16 81 00       	push   $0x81168d
  8010cd:	e8 9d d6 00 00       	call   80e76f <_panic>
    return -1;
  8010d2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8010d7:	e9 57 ff ff ff       	jmp    801033 <lwip_accept+0x109>

008010dc <lwip_bind>:
{
  8010dc:	55                   	push   %ebp
  8010dd:	89 e5                	mov    %esp,%ebp
  8010df:	56                   	push   %esi
  8010e0:	53                   	push   %ebx
  8010e1:	83 ec 10             	sub    $0x10,%esp
  8010e4:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8010e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8010ea:	e8 37 f7 ff ff       	call   800826 <get_socket>
  if (!sock)
  8010ef:	85 c0                	test   %eax,%eax
  8010f1:	0f 84 94 00 00 00    	je     80118b <lwip_bind+0xaf>
  8010f7:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010f9:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8010fd:	75 4f                	jne    80114e <lwip_bind+0x72>
  8010ff:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801103:	75 49                	jne    80114e <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801105:	8b 46 04             	mov    0x4(%esi),%eax
  801108:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  80110b:	83 ec 0c             	sub    $0xc,%esp
  80110e:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801112:	50                   	push   %eax
  801113:	e8 d3 66 00 00       	call   8077eb <ntohs>
  801118:	83 c4 0c             	add    $0xc,%esp
  80111b:	0f b7 c0             	movzwl %ax,%eax
  80111e:	50                   	push   %eax
  80111f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801122:	50                   	push   %eax
  801123:	ff 33                	pushl  (%ebx)
  801125:	e8 aa 9d 00 00       	call   80aed4 <netconn_bind>
  if (err != ERR_OK) {
  80112a:	83 c4 10             	add    $0x10,%esp
  80112d:	84 c0                	test   %al,%al
  80112f:	75 34                	jne    801165 <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  801131:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801138:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80113f:	00 00 00 
  return 0;
  801142:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801147:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80114a:	5b                   	pop    %ebx
  80114b:	5e                   	pop    %esi
  80114c:	5d                   	pop    %ebp
  80114d:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80114e:	83 ec 04             	sub    $0x4,%esp
  801151:	68 c5 16 81 00       	push   $0x8116c5
  801156:	68 4a 01 00 00       	push   $0x14a
  80115b:	68 8d 16 81 00       	push   $0x81168d
  801160:	e8 0a d6 00 00       	call   80e76f <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801165:	0f be c0             	movsbl %al,%eax
  801168:	f7 d8                	neg    %eax
  80116a:	ba 05 00 00 00       	mov    $0x5,%edx
  80116f:	83 f8 0e             	cmp    $0xe,%eax
  801172:	77 07                	ja     80117b <lwip_bind+0x9f>
  801174:	8b 14 85 40 17 81 00 	mov    0x811740(,%eax,4),%edx
  80117b:	89 53 10             	mov    %edx,0x10(%ebx)
  80117e:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  801184:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801189:	eb bc                	jmp    801147 <lwip_bind+0x6b>
    return -1;
  80118b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801190:	eb b5                	jmp    801147 <lwip_bind+0x6b>

00801192 <lwip_close>:
{
  801192:	55                   	push   %ebp
  801193:	89 e5                	mov    %esp,%ebp
  801195:	53                   	push   %ebx
  801196:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  801199:	8b 45 08             	mov    0x8(%ebp),%eax
  80119c:	e8 85 f6 ff ff       	call   800826 <get_socket>
  if (!sock) {
  8011a1:	85 c0                	test   %eax,%eax
  8011a3:	74 6f                	je     801214 <lwip_close+0x82>
  8011a5:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  8011a7:	83 ec 0c             	sub    $0xc,%esp
  8011aa:	ff 30                	pushl  (%eax)
  8011ac:	e8 2f 9c 00 00       	call   80ade0 <netconn_delete>
  sys_sem_wait(socksem);
  8011b1:	83 c4 04             	add    $0x4,%esp
  8011b4:	ff 35 44 60 81 00    	pushl  0x816044
  8011ba:	e8 23 40 00 00       	call   8051e2 <sys_sem_wait>
  if (sock->lastdata) {
  8011bf:	8b 43 04             	mov    0x4(%ebx),%eax
  8011c2:	83 c4 10             	add    $0x10,%esp
  8011c5:	85 c0                	test   %eax,%eax
  8011c7:	74 0c                	je     8011d5 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8011c9:	83 ec 0c             	sub    $0xc,%esp
  8011cc:	50                   	push   %eax
  8011cd:	e8 99 13 00 00       	call   80256b <netbuf_delete>
  8011d2:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8011d5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8011dc:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8011e2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8011e8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011ef:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8011f6:	00 00 00 
  sys_sem_signal(socksem);
  8011f9:	83 ec 0c             	sub    $0xc,%esp
  8011fc:	ff 35 44 60 81 00    	pushl  0x816044
  801202:	e8 6d 8f 00 00       	call   80a174 <sys_sem_signal>
  return 0;
  801207:	83 c4 10             	add    $0x10,%esp
  80120a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80120f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801212:	c9                   	leave  
  801213:	c3                   	ret    
    return -1;
  801214:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801219:	eb f4                	jmp    80120f <lwip_close+0x7d>

0080121b <lwip_connect>:
{
  80121b:	55                   	push   %ebp
  80121c:	89 e5                	mov    %esp,%ebp
  80121e:	56                   	push   %esi
  80121f:	53                   	push   %ebx
  801220:	83 ec 10             	sub    $0x10,%esp
  801223:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801226:	8b 45 08             	mov    0x8(%ebp),%eax
  801229:	e8 f8 f5 ff ff       	call   800826 <get_socket>
  if (!sock)
  80122e:	85 c0                	test   %eax,%eax
  801230:	0f 84 94 00 00 00    	je     8012ca <lwip_connect+0xaf>
  801236:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801238:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80123c:	75 4f                	jne    80128d <lwip_connect+0x72>
  80123e:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801242:	75 49                	jne    80128d <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801244:	8b 46 04             	mov    0x4(%esi),%eax
  801247:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80124a:	83 ec 0c             	sub    $0xc,%esp
  80124d:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801251:	50                   	push   %eax
  801252:	e8 94 65 00 00       	call   8077eb <ntohs>
  801257:	83 c4 0c             	add    $0xc,%esp
  80125a:	0f b7 c0             	movzwl %ax,%eax
  80125d:	50                   	push   %eax
  80125e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801261:	50                   	push   %eax
  801262:	ff 33                	pushl  (%ebx)
  801264:	e8 bc 9c 00 00       	call   80af25 <netconn_connect>
  if (err != ERR_OK) {
  801269:	83 c4 10             	add    $0x10,%esp
  80126c:	84 c0                	test   %al,%al
  80126e:	75 34                	jne    8012a4 <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  801270:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801277:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80127e:	00 00 00 
  return 0;
  801281:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801286:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801289:	5b                   	pop    %ebx
  80128a:	5e                   	pop    %esi
  80128b:	5d                   	pop    %ebp
  80128c:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80128d:	83 ec 04             	sub    $0x4,%esp
  801290:	68 e0 16 81 00       	push   $0x8116e0
  801295:	68 86 01 00 00       	push   $0x186
  80129a:	68 8d 16 81 00       	push   $0x81168d
  80129f:	e8 cb d4 00 00       	call   80e76f <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8012a4:	0f be c0             	movsbl %al,%eax
  8012a7:	f7 d8                	neg    %eax
  8012a9:	ba 05 00 00 00       	mov    $0x5,%edx
  8012ae:	83 f8 0e             	cmp    $0xe,%eax
  8012b1:	77 07                	ja     8012ba <lwip_connect+0x9f>
  8012b3:	8b 14 85 40 17 81 00 	mov    0x811740(,%eax,4),%edx
  8012ba:	89 53 10             	mov    %edx,0x10(%ebx)
  8012bd:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  8012c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012c8:	eb bc                	jmp    801286 <lwip_connect+0x6b>
    return -1;
  8012ca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012cf:	eb b5                	jmp    801286 <lwip_connect+0x6b>

008012d1 <lwip_listen>:
{
  8012d1:	55                   	push   %ebp
  8012d2:	89 e5                	mov    %esp,%ebp
  8012d4:	56                   	push   %esi
  8012d5:	53                   	push   %ebx
  8012d6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8012d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8012dc:	e8 45 f5 ff ff       	call   800826 <get_socket>
  if (!sock)
  8012e1:	85 c0                	test   %eax,%eax
  8012e3:	74 6f                	je     801354 <lwip_listen+0x83>
  8012e5:	89 c6                	mov    %eax,%esi
  8012e7:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8012ed:	b8 ff 00 00 00       	mov    $0xff,%eax
  8012f2:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  8012f5:	83 ec 08             	sub    $0x8,%esp
  8012f8:	85 db                	test   %ebx,%ebx
  8012fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8012ff:	0f 48 d8             	cmovs  %eax,%ebx
  801302:	53                   	push   %ebx
  801303:	ff 36                	pushl  (%esi)
  801305:	e8 b0 9c 00 00       	call   80afba <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  80130a:	83 c4 10             	add    $0x10,%esp
  80130d:	84 c0                	test   %al,%al
  80130f:	75 1d                	jne    80132e <lwip_listen+0x5d>
  sock_set_errno(sock, 0);
  801311:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801318:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80131f:	00 00 00 
  return 0;
  801322:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801327:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80132a:	5b                   	pop    %ebx
  80132b:	5e                   	pop    %esi
  80132c:	5d                   	pop    %ebp
  80132d:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  80132e:	0f be c0             	movsbl %al,%eax
  801331:	f7 d8                	neg    %eax
  801333:	ba 05 00 00 00       	mov    $0x5,%edx
  801338:	83 f8 0e             	cmp    $0xe,%eax
  80133b:	77 07                	ja     801344 <lwip_listen+0x73>
  80133d:	8b 14 85 40 17 81 00 	mov    0x811740(,%eax,4),%edx
  801344:	89 56 10             	mov    %edx,0x10(%esi)
  801347:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  80134d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801352:	eb d3                	jmp    801327 <lwip_listen+0x56>
    return -1;
  801354:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801359:	eb cc                	jmp    801327 <lwip_listen+0x56>

0080135b <lwip_recvfrom>:
{
  80135b:	55                   	push   %ebp
  80135c:	89 e5                	mov    %esp,%ebp
  80135e:	57                   	push   %edi
  80135f:	56                   	push   %esi
  801360:	53                   	push   %ebx
  801361:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  801364:	8b 45 08             	mov    0x8(%ebp),%eax
  801367:	e8 ba f4 ff ff       	call   800826 <get_socket>
  if (!sock)
  80136c:	85 c0                	test   %eax,%eax
  80136e:	0f 84 22 02 00 00    	je     801596 <lwip_recvfrom+0x23b>
  801374:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801376:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80137c:	8b 45 14             	mov    0x14(%ebp),%eax
  80137f:	83 e0 08             	and    $0x8,%eax
  801382:	89 45 b8             	mov    %eax,-0x48(%ebp)
  801385:	e9 a7 00 00 00       	jmp    801431 <lwip_recvfrom+0xd6>
  80138a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80138e:	75 06                	jne    801396 <lwip_recvfrom+0x3b>
  801390:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801394:	74 07                	je     80139d <lwip_recvfrom+0x42>
  801396:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80139b:	74 56                	je     8013f3 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  80139d:	83 ec 0c             	sub    $0xc,%esp
  8013a0:	ff 37                	pushl  (%edi)
  8013a2:	e8 c9 9c 00 00       	call   80b070 <netconn_recv>
  8013a7:	89 c6                	mov    %eax,%esi
  8013a9:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  8013ac:	83 c4 10             	add    $0x10,%esp
  8013af:	85 c0                	test   %eax,%eax
  8013b1:	0f 85 85 00 00 00    	jne    80143c <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8013b7:	8b 17                	mov    (%edi),%edx
  8013b9:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8013bd:	74 0b                	je     8013ca <lwip_recvfrom+0x6f>
  8013bf:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8013c4:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8013c8:	74 17                	je     8013e1 <lwip_recvfrom+0x86>
  8013ca:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8013ce:	f7 da                	neg    %edx
  8013d0:	b8 05 00 00 00       	mov    $0x5,%eax
  8013d5:	83 fa 0e             	cmp    $0xe,%edx
  8013d8:	77 07                	ja     8013e1 <lwip_recvfrom+0x86>
  8013da:	8b 04 95 40 17 81 00 	mov    0x811740(,%edx,4),%eax
  8013e1:	89 47 10             	mov    %eax,0x10(%edi)
  8013e4:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
        return 0;
  8013e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8013ee:	e9 0b 01 00 00       	jmp    8014fe <lwip_recvfrom+0x1a3>
        sock_set_errno(sock, EWOULDBLOCK);
  8013f3:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8013fa:	c7 05 e0 c1 b3 00 0b 	movl   $0xb,0xb3c1e0
  801401:	00 00 00 
        return -1;
  801404:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801409:	e9 f0 00 00 00       	jmp    8014fe <lwip_recvfrom+0x1a3>
        sock->lastdata = NULL;
  80140e:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801415:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  80141b:	83 ec 0c             	sub    $0xc,%esp
  80141e:	56                   	push   %esi
  80141f:	e8 47 11 00 00       	call   80256b <netbuf_delete>
  801424:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801427:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80142b:	0f 85 ac 00 00 00    	jne    8014dd <lwip_recvfrom+0x182>
    if (sock->lastdata) {
  801431:	8b 77 04             	mov    0x4(%edi),%esi
  801434:	85 f6                	test   %esi,%esi
  801436:	0f 84 4e ff ff ff    	je     80138a <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  80143c:	8b 16                	mov    (%esi),%edx
  80143e:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801442:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801446:	89 cb                	mov    %ecx,%ebx
  801448:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  80144a:	0f b7 db             	movzwl %bx,%ebx
  80144d:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  801450:	29 c1                	sub    %eax,%ecx
  801452:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  801455:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  80145a:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80145c:	0f b7 c9             	movzwl %cx,%ecx
  80145f:	0f b7 c0             	movzwl %ax,%eax
  801462:	50                   	push   %eax
  801463:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801466:	51                   	push   %ecx
  801467:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80146b:	03 45 0c             	add    0xc(%ebp),%eax
  80146e:	50                   	push   %eax
  80146f:	52                   	push   %edx
  801470:	e8 0b 3c 00 00       	call   805080 <pbuf_copy_partial>
    off += copylen;
  801475:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801479:	83 c4 04             	add    $0x4,%esp
  80147c:	ff 37                	pushl  (%edi)
  80147e:	e8 9d 99 00 00       	call   80ae20 <netconn_type>
  801483:	83 c4 10             	add    $0x10,%esp
      done = 1;
  801486:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80148a:	83 f8 10             	cmp    $0x10,%eax
  80148d:	75 23                	jne    8014b2 <lwip_recvfrom+0x157>
      len -= copylen;
  80148f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801492:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801495:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801499:	7e 17                	jle    8014b2 <lwip_recvfrom+0x157>
  80149b:	8b 06                	mov    (%esi),%eax
  80149d:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  8014a1:	83 e0 01             	and    $0x1,%eax
  8014a4:	88 45 c7             	mov    %al,-0x39(%ebp)
  8014a7:	75 09                	jne    8014b2 <lwip_recvfrom+0x157>
  8014a9:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  8014ae:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8014b2:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8014b6:	75 25                	jne    8014dd <lwip_recvfrom+0x182>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8014b8:	8b 07                	mov    (%edi),%eax
  8014ba:	83 38 10             	cmpl   $0x10,(%eax)
  8014bd:	0f 85 4b ff ff ff    	jne    80140e <lwip_recvfrom+0xb3>
  8014c3:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8014c6:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8014c9:	85 c0                	test   %eax,%eax
  8014cb:	0f 8e 3d ff ff ff    	jle    80140e <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  8014d1:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8014d4:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8014d8:	e9 4a ff ff ff       	jmp    801427 <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  8014dd:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8014e1:	74 06                	je     8014e9 <lwip_recvfrom+0x18e>
  8014e3:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8014e7:	75 1d                	jne    801506 <lwip_recvfrom+0x1ab>
  sock_set_errno(sock, 0);
  8014e9:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8014f0:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8014f7:	00 00 00 
  return off;
  8014fa:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  8014fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801501:	5b                   	pop    %ebx
  801502:	5e                   	pop    %esi
  801503:	5f                   	pop    %edi
  801504:	5d                   	pop    %ebp
  801505:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801506:	83 ec 0c             	sub    $0xc,%esp
  801509:	ff 37                	pushl  (%edi)
  80150b:	e8 10 99 00 00       	call   80ae20 <netconn_type>
  801510:	83 c4 10             	add    $0x10,%esp
  801513:	83 f8 10             	cmp    $0x10,%eax
  801516:	74 65                	je     80157d <lwip_recvfrom+0x222>
      addr = netbuf_fromaddr(buf);
  801518:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80151b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80151f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  801523:	83 ec 04             	sub    $0x4,%esp
  801526:	6a 10                	push   $0x10
  801528:	6a 00                	push   $0x0
  80152a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80152d:	50                   	push   %eax
  80152e:	e8 d7 db 00 00       	call   80f10a <memset>
    sin.sin_len = sizeof(sin);
  801533:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801537:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80153b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80153f:	89 04 24             	mov    %eax,(%esp)
  801542:	e8 97 62 00 00       	call   8077de <htons>
  801547:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80154b:	8b 03                	mov    (%ebx),%eax
  80154d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  801550:	83 c4 10             	add    $0x10,%esp
  801553:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801556:	83 38 10             	cmpl   $0x10,(%eax)
  801559:	76 06                	jbe    801561 <lwip_recvfrom+0x206>
      *fromlen = sizeof(sin);
  80155b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801561:	83 ec 04             	sub    $0x4,%esp
  801564:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801567:	ff 30                	pushl  (%eax)
  801569:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80156c:	50                   	push   %eax
  80156d:	ff 75 18             	pushl  0x18(%ebp)
  801570:	e8 3f dc 00 00       	call   80f1b4 <memcpy>
  801575:	83 c4 10             	add    $0x10,%esp
  801578:	e9 6c ff ff ff       	jmp    8014e9 <lwip_recvfrom+0x18e>
      netconn_getaddr(sock->conn, addr, &port, 0);
  80157d:	6a 00                	push   $0x0
  80157f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801582:	50                   	push   %eax
  801583:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801586:	50                   	push   %eax
  801587:	ff 37                	pushl  (%edi)
  801589:	e8 ba 98 00 00       	call   80ae48 <netconn_getaddr>
  80158e:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801591:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801594:	eb 8d                	jmp    801523 <lwip_recvfrom+0x1c8>
    return -1;
  801596:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80159b:	e9 5e ff ff ff       	jmp    8014fe <lwip_recvfrom+0x1a3>

008015a0 <lwip_read>:
{
  8015a0:	55                   	push   %ebp
  8015a1:	89 e5                	mov    %esp,%ebp
  8015a3:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8015a6:	6a 00                	push   $0x0
  8015a8:	6a 00                	push   $0x0
  8015aa:	6a 00                	push   $0x0
  8015ac:	ff 75 10             	pushl  0x10(%ebp)
  8015af:	ff 75 0c             	pushl  0xc(%ebp)
  8015b2:	ff 75 08             	pushl  0x8(%ebp)
  8015b5:	e8 a1 fd ff ff       	call   80135b <lwip_recvfrom>
}
  8015ba:	c9                   	leave  
  8015bb:	c3                   	ret    

008015bc <lwip_recv>:
{
  8015bc:	55                   	push   %ebp
  8015bd:	89 e5                	mov    %esp,%ebp
  8015bf:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8015c2:	6a 00                	push   $0x0
  8015c4:	6a 00                	push   $0x0
  8015c6:	ff 75 14             	pushl  0x14(%ebp)
  8015c9:	ff 75 10             	pushl  0x10(%ebp)
  8015cc:	ff 75 0c             	pushl  0xc(%ebp)
  8015cf:	ff 75 08             	pushl  0x8(%ebp)
  8015d2:	e8 84 fd ff ff       	call   80135b <lwip_recvfrom>
}
  8015d7:	c9                   	leave  
  8015d8:	c3                   	ret    

008015d9 <lwip_sendto>:
{
  8015d9:	55                   	push   %ebp
  8015da:	89 e5                	mov    %esp,%ebp
  8015dc:	57                   	push   %edi
  8015dd:	56                   	push   %esi
  8015de:	53                   	push   %ebx
  8015df:	83 ec 2c             	sub    $0x2c,%esp
  8015e2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8015e5:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  8015e8:	8b 45 08             	mov    0x8(%ebp),%eax
  8015eb:	e8 36 f2 ff ff       	call   800826 <get_socket>
  if (!sock)
  8015f0:	85 c0                	test   %eax,%eax
  8015f2:	0f 84 28 01 00 00    	je     801720 <lwip_sendto+0x147>
  8015f8:	89 c6                	mov    %eax,%esi
  if (sock->conn->type==NETCONN_TCP) {
  8015fa:	8b 00                	mov    (%eax),%eax
  8015fc:	83 38 10             	cmpl   $0x10,(%eax)
  8015ff:	0f 84 be 00 00 00    	je     8016c3 <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  801605:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80160b:	0f 87 c8 00 00 00    	ja     8016d9 <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801611:	89 f8                	mov    %edi,%eax
  801613:	0b 45 1c             	or     0x1c(%ebp),%eax
  801616:	0f 84 0b 01 00 00    	je     801727 <lwip_sendto+0x14e>
  80161c:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801620:	0f 85 ca 00 00 00    	jne    8016f0 <lwip_sendto+0x117>
  801626:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  80162a:	0f 85 c0 00 00 00    	jne    8016f0 <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  801630:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801637:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80163e:	8b 47 04             	mov    0x4(%edi),%eax
  801641:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801644:	83 ec 0c             	sub    $0xc,%esp
  801647:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80164b:	50                   	push   %eax
  80164c:	e8 9a 61 00 00       	call   8077eb <ntohs>
    buf.addr         = &remote_addr;
  801651:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801654:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801657:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80165b:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80165e:	83 ec 04             	sub    $0x4,%esp
  801661:	0f b7 c3             	movzwl %bx,%eax
  801664:	50                   	push   %eax
  801665:	ff 75 0c             	pushl  0xc(%ebp)
  801668:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80166b:	50                   	push   %eax
  80166c:	e8 f5 0f 00 00       	call   802666 <netbuf_ref>
  801671:	0f be f8             	movsbl %al,%edi
  801674:	83 c4 10             	add    $0x10,%esp
  801677:	85 ff                	test   %edi,%edi
  801679:	0f 84 88 00 00 00    	je     801707 <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  80167f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801682:	85 c0                	test   %eax,%eax
  801684:	74 0c                	je     801692 <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  801686:	83 ec 0c             	sub    $0xc,%esp
  801689:	50                   	push   %eax
  80168a:	e8 75 32 00 00       	call   804904 <pbuf_free>
  80168f:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801692:	89 fa                	mov    %edi,%edx
  801694:	f7 da                	neg    %edx
  801696:	b8 05 00 00 00       	mov    $0x5,%eax
  80169b:	83 fa 0e             	cmp    $0xe,%edx
  80169e:	77 07                	ja     8016a7 <lwip_sendto+0xce>
  8016a0:	8b 04 95 40 17 81 00 	mov    0x811740(,%edx,4),%eax
  8016a7:	89 46 10             	mov    %eax,0x10(%esi)
  8016aa:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
  return (err==ERR_OK?size:-1);
  8016af:	85 ff                	test   %edi,%edi
  8016b1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016b6:	0f 45 d8             	cmovne %eax,%ebx
}
  8016b9:	89 d8                	mov    %ebx,%eax
  8016bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8016be:	5b                   	pop    %ebx
  8016bf:	5e                   	pop    %esi
  8016c0:	5f                   	pop    %edi
  8016c1:	5d                   	pop    %ebp
  8016c2:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8016c3:	ff 75 14             	pushl  0x14(%ebp)
  8016c6:	53                   	push   %ebx
  8016c7:	ff 75 0c             	pushl  0xc(%ebp)
  8016ca:	ff 75 08             	pushl  0x8(%ebp)
  8016cd:	e8 7c 00 00 00       	call   80174e <lwip_send>
  8016d2:	89 c3                	mov    %eax,%ebx
  8016d4:	83 c4 10             	add    $0x10,%esp
  8016d7:	eb e0                	jmp    8016b9 <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8016d9:	83 ec 04             	sub    $0x4,%esp
  8016dc:	68 1c 17 81 00       	push   $0x81171c
  8016e1:	68 97 02 00 00       	push   $0x297
  8016e6:	68 8d 16 81 00       	push   $0x81168d
  8016eb:	e8 7f d0 00 00       	call   80e76f <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8016f0:	83 ec 04             	sub    $0x4,%esp
  8016f3:	68 fe 16 81 00       	push   $0x8116fe
  8016f8:	68 9b 02 00 00       	push   $0x29b
  8016fd:	68 8d 16 81 00       	push   $0x81168d
  801702:	e8 68 d0 00 00       	call   80e76f <_panic>
    err = netconn_send(sock->conn, &buf);
  801707:	83 ec 08             	sub    $0x8,%esp
  80170a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80170d:	50                   	push   %eax
  80170e:	ff 36                	pushl  (%esi)
  801710:	e8 f0 9a 00 00       	call   80b205 <netconn_send>
  801715:	0f be f8             	movsbl %al,%edi
  801718:	83 c4 10             	add    $0x10,%esp
  80171b:	e9 5f ff ff ff       	jmp    80167f <lwip_sendto+0xa6>
    return -1;
  801720:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801725:	eb 92                	jmp    8016b9 <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  801727:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80172e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801735:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  80173c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801743:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  801749:	e9 10 ff ff ff       	jmp    80165e <lwip_sendto+0x85>

0080174e <lwip_send>:
{
  80174e:	55                   	push   %ebp
  80174f:	89 e5                	mov    %esp,%ebp
  801751:	57                   	push   %edi
  801752:	56                   	push   %esi
  801753:	53                   	push   %ebx
  801754:	83 ec 0c             	sub    $0xc,%esp
  801757:	8b 7d 08             	mov    0x8(%ebp),%edi
  80175a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  80175d:	89 f8                	mov    %edi,%eax
  80175f:	e8 c2 f0 ff ff       	call   800826 <get_socket>
  if (!sock)
  801764:	85 c0                	test   %eax,%eax
  801766:	74 70                	je     8017d8 <lwip_send+0x8a>
  801768:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  80176a:	8b 00                	mov    (%eax),%eax
  80176c:	83 38 10             	cmpl   $0x10,(%eax)
  80176f:	74 1f                	je     801790 <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801771:	83 ec 08             	sub    $0x8,%esp
  801774:	6a 00                	push   $0x0
  801776:	6a 00                	push   $0x0
  801778:	ff 75 14             	pushl  0x14(%ebp)
  80177b:	53                   	push   %ebx
  80177c:	ff 75 0c             	pushl  0xc(%ebp)
  80177f:	57                   	push   %edi
  801780:	e8 54 fe ff ff       	call   8015d9 <lwip_sendto>
  801785:	83 c4 20             	add    $0x20,%esp
}
  801788:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80178b:	5b                   	pop    %ebx
  80178c:	5e                   	pop    %esi
  80178d:	5f                   	pop    %edi
  80178e:	5d                   	pop    %ebp
  80178f:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801790:	8b 55 14             	mov    0x14(%ebp),%edx
  801793:	c1 ea 03             	shr    $0x3,%edx
  801796:	83 e2 02             	and    $0x2,%edx
  801799:	83 ca 01             	or     $0x1,%edx
  80179c:	0f b6 d2             	movzbl %dl,%edx
  80179f:	52                   	push   %edx
  8017a0:	53                   	push   %ebx
  8017a1:	ff 75 0c             	pushl  0xc(%ebp)
  8017a4:	50                   	push   %eax
  8017a5:	e8 d7 9a 00 00       	call   80b281 <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  8017aa:	0f be d0             	movsbl %al,%edx
  8017ad:	f7 da                	neg    %edx
  8017af:	83 c4 10             	add    $0x10,%esp
  8017b2:	b9 05 00 00 00       	mov    $0x5,%ecx
  8017b7:	83 fa 0e             	cmp    $0xe,%edx
  8017ba:	77 07                	ja     8017c3 <lwip_send+0x75>
  8017bc:	8b 0c 95 40 17 81 00 	mov    0x811740(,%edx,4),%ecx
  8017c3:	89 4e 10             	mov    %ecx,0x10(%esi)
  8017c6:	89 0d e0 c1 b3 00    	mov    %ecx,0xb3c1e0
  return (err==ERR_OK?size:-1);
  8017cc:	84 c0                	test   %al,%al
  8017ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017d3:	0f 44 c3             	cmove  %ebx,%eax
  8017d6:	eb b0                	jmp    801788 <lwip_send+0x3a>
    return -1;
  8017d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017dd:	eb a9                	jmp    801788 <lwip_send+0x3a>

008017df <lwip_socket>:
{
  8017df:	55                   	push   %ebp
  8017e0:	89 e5                	mov    %esp,%ebp
  8017e2:	56                   	push   %esi
  8017e3:	53                   	push   %ebx
  8017e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  8017e7:	83 f8 02             	cmp    $0x2,%eax
  8017ea:	74 5c                	je     801848 <lwip_socket+0x69>
  8017ec:	83 f8 03             	cmp    $0x3,%eax
  8017ef:	74 16                	je     801807 <lwip_socket+0x28>
  8017f1:	83 f8 01             	cmp    $0x1,%eax
  8017f4:	74 79                	je     80186f <lwip_socket+0x90>
    set_errno(EINVAL);
  8017f6:	c7 05 e0 c1 b3 00 16 	movl   $0x16,0xb3c1e0
  8017fd:	00 00 00 
    return -1;
  801800:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801805:	eb 38                	jmp    80183f <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  801807:	83 ec 04             	sub    $0x4,%esp
  80180a:	68 14 0a 80 00       	push   $0x800a14
  80180f:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801813:	50                   	push   %eax
  801814:	6a 40                	push   $0x40
  801816:	e8 ea 94 00 00       	call   80ad05 <netconn_new_with_proto_and_callback>
  80181b:	89 c6                	mov    %eax,%esi
    break;
  80181d:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  801820:	85 f6                	test   %esi,%esi
  801822:	74 63                	je     801887 <lwip_socket+0xa8>
  i = alloc_socket(conn);
  801824:	89 f0                	mov    %esi,%eax
  801826:	e8 93 f3 ff ff       	call   800bbe <alloc_socket>
  80182b:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  80182d:	83 f8 ff             	cmp    $0xffffffff,%eax
  801830:	74 66                	je     801898 <lwip_socket+0xb9>
  conn->socket = i;
  801832:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801835:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80183c:	00 00 00 
}
  80183f:	89 d8                	mov    %ebx,%eax
  801841:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801844:	5b                   	pop    %ebx
  801845:	5e                   	pop    %esi
  801846:	5d                   	pop    %ebp
  801847:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801848:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80184f:	0f 94 c0             	sete   %al
  801852:	0f b6 c0             	movzbl %al,%eax
  801855:	83 c0 20             	add    $0x20,%eax
  801858:	83 ec 04             	sub    $0x4,%esp
  80185b:	68 14 0a 80 00       	push   $0x800a14
  801860:	6a 00                	push   $0x0
  801862:	50                   	push   %eax
  801863:	e8 9d 94 00 00       	call   80ad05 <netconn_new_with_proto_and_callback>
  801868:	89 c6                	mov    %eax,%esi
    break;
  80186a:	83 c4 10             	add    $0x10,%esp
  80186d:	eb b1                	jmp    801820 <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80186f:	83 ec 04             	sub    $0x4,%esp
  801872:	68 14 0a 80 00       	push   $0x800a14
  801877:	6a 00                	push   $0x0
  801879:	6a 10                	push   $0x10
  80187b:	e8 85 94 00 00       	call   80ad05 <netconn_new_with_proto_and_callback>
  801880:	89 c6                	mov    %eax,%esi
    break;
  801882:	83 c4 10             	add    $0x10,%esp
  801885:	eb 99                	jmp    801820 <lwip_socket+0x41>
    set_errno(ENOBUFS);
  801887:	c7 05 e0 c1 b3 00 69 	movl   $0x69,0xb3c1e0
  80188e:	00 00 00 
    return -1;
  801891:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801896:	eb a7                	jmp    80183f <lwip_socket+0x60>
    netconn_delete(conn);
  801898:	83 ec 0c             	sub    $0xc,%esp
  80189b:	56                   	push   %esi
  80189c:	e8 3f 95 00 00       	call   80ade0 <netconn_delete>
    set_errno(ENFILE);
  8018a1:	c7 05 e0 c1 b3 00 17 	movl   $0x17,0xb3c1e0
  8018a8:	00 00 00 
    return -1;
  8018ab:	83 c4 10             	add    $0x10,%esp
  8018ae:	eb 8f                	jmp    80183f <lwip_socket+0x60>

008018b0 <lwip_write>:
{
  8018b0:	55                   	push   %ebp
  8018b1:	89 e5                	mov    %esp,%ebp
  8018b3:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8018b6:	6a 00                	push   $0x0
  8018b8:	ff 75 10             	pushl  0x10(%ebp)
  8018bb:	ff 75 0c             	pushl  0xc(%ebp)
  8018be:	ff 75 08             	pushl  0x8(%ebp)
  8018c1:	e8 88 fe ff ff       	call   80174e <lwip_send>
}
  8018c6:	c9                   	leave  
  8018c7:	c3                   	ret    

008018c8 <lwip_select>:
{
  8018c8:	55                   	push   %ebp
  8018c9:	89 e5                	mov    %esp,%ebp
  8018cb:	57                   	push   %edi
  8018cc:	56                   	push   %esi
  8018cd:	53                   	push   %ebx
  8018ce:	83 ec 58             	sub    $0x58,%esp
  8018d1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8018d4:	8b 75 10             	mov    0x10(%ebp),%esi
  8018d7:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  8018da:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8018e1:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  8018e4:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8018e7:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8018ea:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  8018f1:	ff 35 40 60 81 00    	pushl  0x816040
  8018f7:	e8 e6 38 00 00       	call   8051e2 <sys_sem_wait>
  if (readset)
  8018fc:	83 c4 10             	add    $0x10,%esp
  8018ff:	85 db                	test   %ebx,%ebx
  801901:	0f 84 0b 01 00 00    	je     801a12 <lwip_select+0x14a>
    lreadset = *readset;
  801907:	8b 03                	mov    (%ebx),%eax
  801909:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  80190c:	85 f6                	test   %esi,%esi
  80190e:	0f 84 16 01 00 00    	je     801a2a <lwip_select+0x162>
    lwriteset = *writeset;
  801914:	8b 06                	mov    (%esi),%eax
  801916:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  801919:	85 ff                	test   %edi,%edi
  80191b:	0f 84 21 01 00 00    	je     801a42 <lwip_select+0x17a>
    lexceptset = *exceptset;
  801921:	8b 07                	mov    (%edi),%eax
  801923:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801926:	83 ec 0c             	sub    $0xc,%esp
  801929:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80192c:	50                   	push   %eax
  80192d:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801930:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801933:	8b 45 08             	mov    0x8(%ebp),%eax
  801936:	e8 29 ef ff ff       	call   800864 <lwip_selscan>
  80193b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  80193e:	83 c4 10             	add    $0x10,%esp
  801941:	85 c0                	test   %eax,%eax
  801943:	0f 85 a0 02 00 00    	jne    801be9 <lwip_select+0x321>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801949:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80194d:	0f 84 ac 02 00 00    	je     801bff <lwip_select+0x337>
  801953:	8b 45 18             	mov    0x18(%ebp),%eax
  801956:	83 38 00             	cmpl   $0x0,(%eax)
  801959:	75 0e                	jne    801969 <lwip_select+0xa1>
  80195b:	8b 40 04             	mov    0x4(%eax),%eax
  80195e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801961:	85 c0                	test   %eax,%eax
  801963:	0f 84 f1 00 00 00    	je     801a5a <lwip_select+0x192>
    select_cb.sem = sys_sem_new(0);
  801969:	83 ec 0c             	sub    $0xc,%esp
  80196c:	6a 00                	push   $0x0
  80196e:	e8 44 85 00 00       	call   809eb7 <sys_sem_new>
  801973:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801976:	a1 48 60 81 00       	mov    0x816048,%eax
  80197b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80197e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801981:	a3 48 60 81 00       	mov    %eax,0x816048
    sys_sem_signal(selectsem);
  801986:	83 c4 04             	add    $0x4,%esp
  801989:	ff 35 40 60 81 00    	pushl  0x816040
  80198f:	e8 e0 87 00 00       	call   80a174 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801994:	8b 45 18             	mov    0x18(%ebp),%eax
  801997:	8b 40 04             	mov    0x4(%eax),%eax
  80199a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  80199d:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  8019a3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8019a8:	89 c8                	mov    %ecx,%eax
  8019aa:	f7 ea                	imul   %edx
  8019ac:	c1 fa 06             	sar    $0x6,%edx
  8019af:	c1 f9 1f             	sar    $0x1f,%ecx
  8019b2:	29 ca                	sub    %ecx,%edx
  8019b4:	8b 45 18             	mov    0x18(%ebp),%eax
  8019b7:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  8019bd:	83 c4 10             	add    $0x10,%esp
  8019c0:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  8019c2:	ba 01 00 00 00       	mov    $0x1,%edx
  8019c7:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8019ca:	83 ec 08             	sub    $0x8,%esp
  8019cd:	50                   	push   %eax
  8019ce:	ff 75 d8             	pushl  -0x28(%ebp)
  8019d1:	e8 dc 39 00 00       	call   8053b2 <sys_sem_wait_timeout>
  8019d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  8019d9:	83 c4 04             	add    $0x4,%esp
  8019dc:	ff 35 40 60 81 00    	pushl  0x816040
  8019e2:	e8 fb 37 00 00       	call   8051e2 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8019e7:	a1 48 60 81 00       	mov    0x816048,%eax
  8019ec:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8019ef:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  8019f2:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  8019f4:	39 d0                	cmp    %edx,%eax
  8019f6:	0f 84 ba 00 00 00    	je     801ab6 <lwip_select+0x1ee>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8019fc:	85 c0                	test   %eax,%eax
  8019fe:	0f 84 c1 00 00 00    	je     801ac5 <lwip_select+0x1fd>
        if (p_selcb->next == &select_cb) {
  801a04:	8b 10                	mov    (%eax),%edx
  801a06:	39 ca                	cmp    %ecx,%edx
  801a08:	0f 84 b2 00 00 00    	je     801ac0 <lwip_select+0x1f8>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801a0e:	89 d0                	mov    %edx,%eax
  801a10:	eb ea                	jmp    8019fc <lwip_select+0x134>
    FD_ZERO(&lreadset);
  801a12:	83 ec 04             	sub    $0x4,%esp
  801a15:	6a 04                	push   $0x4
  801a17:	6a 00                	push   $0x0
  801a19:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a1c:	50                   	push   %eax
  801a1d:	e8 e8 d6 00 00       	call   80f10a <memset>
  801a22:	83 c4 10             	add    $0x10,%esp
  801a25:	e9 e2 fe ff ff       	jmp    80190c <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  801a2a:	83 ec 04             	sub    $0x4,%esp
  801a2d:	6a 04                	push   $0x4
  801a2f:	6a 00                	push   $0x0
  801a31:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801a34:	50                   	push   %eax
  801a35:	e8 d0 d6 00 00       	call   80f10a <memset>
  801a3a:	83 c4 10             	add    $0x10,%esp
  801a3d:	e9 d7 fe ff ff       	jmp    801919 <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  801a42:	83 ec 04             	sub    $0x4,%esp
  801a45:	6a 04                	push   $0x4
  801a47:	6a 00                	push   $0x0
  801a49:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a4c:	50                   	push   %eax
  801a4d:	e8 b8 d6 00 00       	call   80f10a <memset>
  801a52:	83 c4 10             	add    $0x10,%esp
  801a55:	e9 cc fe ff ff       	jmp    801926 <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  801a5a:	83 ec 0c             	sub    $0xc,%esp
  801a5d:	ff 35 40 60 81 00    	pushl  0x816040
  801a63:	e8 0c 87 00 00       	call   80a174 <sys_sem_signal>
      if (readset)
  801a68:	83 c4 10             	add    $0x10,%esp
  801a6b:	85 db                	test   %ebx,%ebx
  801a6d:	74 10                	je     801a7f <lwip_select+0x1b7>
        FD_ZERO(readset);
  801a6f:	83 ec 04             	sub    $0x4,%esp
  801a72:	6a 04                	push   $0x4
  801a74:	6a 00                	push   $0x0
  801a76:	53                   	push   %ebx
  801a77:	e8 8e d6 00 00       	call   80f10a <memset>
  801a7c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801a7f:	85 f6                	test   %esi,%esi
  801a81:	74 10                	je     801a93 <lwip_select+0x1cb>
        FD_ZERO(writeset);
  801a83:	83 ec 04             	sub    $0x4,%esp
  801a86:	6a 04                	push   $0x4
  801a88:	6a 00                	push   $0x0
  801a8a:	56                   	push   %esi
  801a8b:	e8 7a d6 00 00       	call   80f10a <memset>
  801a90:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a93:	85 ff                	test   %edi,%edi
  801a95:	74 10                	je     801aa7 <lwip_select+0x1df>
        FD_ZERO(exceptset);
  801a97:	83 ec 04             	sub    $0x4,%esp
  801a9a:	6a 04                	push   $0x4
  801a9c:	6a 00                	push   $0x0
  801a9e:	57                   	push   %edi
  801a9f:	e8 66 d6 00 00       	call   80f10a <memset>
  801aa4:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801aa7:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801aae:	00 00 00 
      return 0;
  801ab1:	e9 98 00 00 00       	jmp    801b4e <lwip_select+0x286>
      select_cb_list = select_cb.next;
  801ab6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801ab9:	a3 48 60 81 00       	mov    %eax,0x816048
  801abe:	eb 05                	jmp    801ac5 <lwip_select+0x1fd>
          p_selcb->next = select_cb.next;
  801ac0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801ac3:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801ac5:	83 ec 0c             	sub    $0xc,%esp
  801ac8:	ff 35 40 60 81 00    	pushl  0x816040
  801ace:	e8 a1 86 00 00       	call   80a174 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801ad3:	83 c4 04             	add    $0x4,%esp
  801ad6:	ff 75 d8             	pushl  -0x28(%ebp)
  801ad9:	e8 5a 84 00 00       	call   809f38 <sys_sem_free>
    if (i == 0)  {
  801ade:	83 c4 10             	add    $0x10,%esp
  801ae1:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801ae5:	74 72                	je     801b59 <lwip_select+0x291>
    if (readset)
  801ae7:	85 db                	test   %ebx,%ebx
  801ae9:	0f 84 b2 00 00 00    	je     801ba1 <lwip_select+0x2d9>
      lreadset = *readset;
  801aef:	8b 03                	mov    (%ebx),%eax
  801af1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801af4:	85 f6                	test   %esi,%esi
  801af6:	0f 84 bd 00 00 00    	je     801bb9 <lwip_select+0x2f1>
      lwriteset = *writeset;
  801afc:	8b 06                	mov    (%esi),%eax
  801afe:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801b01:	85 ff                	test   %edi,%edi
  801b03:	0f 84 c8 00 00 00    	je     801bd1 <lwip_select+0x309>
      lexceptset = *exceptset;
  801b09:	8b 07                	mov    (%edi),%eax
  801b0b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b0e:	83 ec 0c             	sub    $0xc,%esp
  801b11:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b14:	50                   	push   %eax
  801b15:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b18:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b1b:	8b 45 08             	mov    0x8(%ebp),%eax
  801b1e:	e8 41 ed ff ff       	call   800864 <lwip_selscan>
  801b23:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801b26:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801b29:	85 db                	test   %ebx,%ebx
  801b2b:	74 05                	je     801b32 <lwip_select+0x26a>
    *readset = lreadset;
  801b2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801b30:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801b32:	85 f6                	test   %esi,%esi
  801b34:	74 05                	je     801b3b <lwip_select+0x273>
    *writeset = lwriteset;
  801b36:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b39:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801b3b:	85 ff                	test   %edi,%edi
  801b3d:	74 05                	je     801b44 <lwip_select+0x27c>
    *exceptset = lexceptset;
  801b3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801b42:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801b44:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801b4b:	00 00 00 
}
  801b4e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801b51:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801b54:	5b                   	pop    %ebx
  801b55:	5e                   	pop    %esi
  801b56:	5f                   	pop    %edi
  801b57:	5d                   	pop    %ebp
  801b58:	c3                   	ret    
      if (readset)
  801b59:	85 db                	test   %ebx,%ebx
  801b5b:	74 10                	je     801b6d <lwip_select+0x2a5>
        FD_ZERO(readset);
  801b5d:	83 ec 04             	sub    $0x4,%esp
  801b60:	6a 04                	push   $0x4
  801b62:	6a 00                	push   $0x0
  801b64:	53                   	push   %ebx
  801b65:	e8 a0 d5 00 00       	call   80f10a <memset>
  801b6a:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801b6d:	85 f6                	test   %esi,%esi
  801b6f:	74 10                	je     801b81 <lwip_select+0x2b9>
        FD_ZERO(writeset);
  801b71:	83 ec 04             	sub    $0x4,%esp
  801b74:	6a 04                	push   $0x4
  801b76:	6a 00                	push   $0x0
  801b78:	56                   	push   %esi
  801b79:	e8 8c d5 00 00       	call   80f10a <memset>
  801b7e:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801b81:	85 ff                	test   %edi,%edi
  801b83:	74 10                	je     801b95 <lwip_select+0x2cd>
        FD_ZERO(exceptset);
  801b85:	83 ec 04             	sub    $0x4,%esp
  801b88:	6a 04                	push   $0x4
  801b8a:	6a 00                	push   $0x0
  801b8c:	57                   	push   %edi
  801b8d:	e8 78 d5 00 00       	call   80f10a <memset>
  801b92:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801b95:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801b9c:	00 00 00 
      return 0;
  801b9f:	eb ad                	jmp    801b4e <lwip_select+0x286>
      FD_ZERO(&lreadset);
  801ba1:	83 ec 04             	sub    $0x4,%esp
  801ba4:	6a 04                	push   $0x4
  801ba6:	6a 00                	push   $0x0
  801ba8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801bab:	50                   	push   %eax
  801bac:	e8 59 d5 00 00       	call   80f10a <memset>
  801bb1:	83 c4 10             	add    $0x10,%esp
  801bb4:	e9 3b ff ff ff       	jmp    801af4 <lwip_select+0x22c>
      FD_ZERO(&lwriteset);
  801bb9:	83 ec 04             	sub    $0x4,%esp
  801bbc:	6a 04                	push   $0x4
  801bbe:	6a 00                	push   $0x0
  801bc0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801bc3:	50                   	push   %eax
  801bc4:	e8 41 d5 00 00       	call   80f10a <memset>
  801bc9:	83 c4 10             	add    $0x10,%esp
  801bcc:	e9 30 ff ff ff       	jmp    801b01 <lwip_select+0x239>
      FD_ZERO(&lexceptset);
  801bd1:	83 ec 04             	sub    $0x4,%esp
  801bd4:	6a 04                	push   $0x4
  801bd6:	6a 00                	push   $0x0
  801bd8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801bdb:	50                   	push   %eax
  801bdc:	e8 29 d5 00 00       	call   80f10a <memset>
  801be1:	83 c4 10             	add    $0x10,%esp
  801be4:	e9 25 ff ff ff       	jmp    801b0e <lwip_select+0x246>
    sys_sem_signal(selectsem);
  801be9:	83 ec 0c             	sub    $0xc,%esp
  801bec:	ff 35 40 60 81 00    	pushl  0x816040
  801bf2:	e8 7d 85 00 00       	call   80a174 <sys_sem_signal>
  801bf7:	83 c4 10             	add    $0x10,%esp
  801bfa:	e9 2a ff ff ff       	jmp    801b29 <lwip_select+0x261>
    select_cb.sem = sys_sem_new(0);
  801bff:	83 ec 0c             	sub    $0xc,%esp
  801c02:	6a 00                	push   $0x0
  801c04:	e8 ae 82 00 00       	call   809eb7 <sys_sem_new>
  801c09:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801c0c:	a1 48 60 81 00       	mov    0x816048,%eax
  801c11:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801c14:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801c17:	a3 48 60 81 00       	mov    %eax,0x816048
    sys_sem_signal(selectsem);
  801c1c:	83 c4 04             	add    $0x4,%esp
  801c1f:	ff 35 40 60 81 00    	pushl  0x816040
  801c25:	e8 4a 85 00 00       	call   80a174 <sys_sem_signal>
  801c2a:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801c2d:	b8 00 00 00 00       	mov    $0x0,%eax
  801c32:	e9 93 fd ff ff       	jmp    8019ca <lwip_select+0x102>

00801c37 <lwip_shutdown>:
{
  801c37:	55                   	push   %ebp
  801c38:	89 e5                	mov    %esp,%ebp
  801c3a:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801c3d:	ff 75 08             	pushl  0x8(%ebp)
  801c40:	e8 4d f5 ff ff       	call   801192 <lwip_close>
}
  801c45:	c9                   	leave  
  801c46:	c3                   	ret    

00801c47 <lwip_getpeername>:
{
  801c47:	55                   	push   %ebp
  801c48:	89 e5                	mov    %esp,%ebp
  801c4a:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801c4d:	6a 00                	push   $0x0
  801c4f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801c52:	8b 55 0c             	mov    0xc(%ebp),%edx
  801c55:	8b 45 08             	mov    0x8(%ebp),%eax
  801c58:	e8 0c ed ff ff       	call   800969 <lwip_getaddrname>
}
  801c5d:	c9                   	leave  
  801c5e:	c3                   	ret    

00801c5f <lwip_getsockname>:
{
  801c5f:	55                   	push   %ebp
  801c60:	89 e5                	mov    %esp,%ebp
  801c62:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801c65:	6a 01                	push   $0x1
  801c67:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801c6a:	8b 55 0c             	mov    0xc(%ebp),%edx
  801c6d:	8b 45 08             	mov    0x8(%ebp),%eax
  801c70:	e8 f4 ec ff ff       	call   800969 <lwip_getaddrname>
}
  801c75:	c9                   	leave  
  801c76:	c3                   	ret    

00801c77 <lwip_getsockopt>:
{
  801c77:	55                   	push   %ebp
  801c78:	89 e5                	mov    %esp,%ebp
  801c7a:	57                   	push   %edi
  801c7b:	56                   	push   %esi
  801c7c:	53                   	push   %ebx
  801c7d:	83 ec 2c             	sub    $0x2c,%esp
  801c80:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801c83:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801c86:	8b 45 08             	mov    0x8(%ebp),%eax
  801c89:	e8 98 eb ff ff       	call   800826 <get_socket>
  if (!sock)
  801c8e:	85 c0                	test   %eax,%eax
  801c90:	0f 84 af 01 00 00    	je     801e45 <lwip_getsockopt+0x1ce>
  801c96:	89 c6                	mov    %eax,%esi
  if ((NULL == optval) || (NULL == optlen)) {
  801c98:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801c9c:	74 39                	je     801cd7 <lwip_getsockopt+0x60>
  801c9e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801ca2:	74 33                	je     801cd7 <lwip_getsockopt+0x60>
  switch (level) {
  801ca4:	83 fb 06             	cmp    $0x6,%ebx
  801ca7:	0f 84 36 01 00 00    	je     801de3 <lwip_getsockopt+0x16c>
  801cad:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801cb3:	74 3d                	je     801cf2 <lwip_getsockopt+0x7b>
      err = ENOPROTOOPT;
  801cb5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801cba:	85 db                	test   %ebx,%ebx
  801cbc:	0f 84 a9 00 00 00    	je     801d6b <lwip_getsockopt+0xf4>
    sock_set_errno(sock, err);
  801cc2:	0f be c0             	movsbl %al,%eax
  801cc5:	89 46 10             	mov    %eax,0x10(%esi)
  801cc8:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
    return -1;
  801ccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801cd2:	e9 04 01 00 00       	jmp    801ddb <lwip_getsockopt+0x164>
    sock_set_errno(sock, EFAULT);
  801cd7:	c7 46 10 0e 00 00 00 	movl   $0xe,0x10(%esi)
  801cde:	c7 05 e0 c1 b3 00 0e 	movl   $0xe,0xb3c1e0
  801ce5:	00 00 00 
    return -1;
  801ce8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ced:	e9 e9 00 00 00       	jmp    801ddb <lwip_getsockopt+0x164>
  801cf2:	83 ff 20             	cmp    $0x20,%edi
  801cf5:	74 62                	je     801d59 <lwip_getsockopt+0xe2>
  801cf7:	7e 4d                	jle    801d46 <lwip_getsockopt+0xcf>
  801cf9:	81 ff 07 10 00 00    	cmp    $0x1007,%edi
  801cff:	0f 8c 04 01 00 00    	jl     801e09 <lwip_getsockopt+0x192>
  801d05:	81 ff 08 10 00 00    	cmp    $0x1008,%edi
  801d0b:	7e 4c                	jle    801d59 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801d0d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d12:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  801d18:	75 a8                	jne    801cc2 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801d1a:	8b 45 18             	mov    0x18(%ebp),%eax
  801d1d:	83 38 04             	cmpl   $0x4,(%eax)
  801d20:	19 c0                	sbb    %eax,%eax
  801d22:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801d25:	8b 16                	mov    (%esi),%edx
  801d27:	83 3a 20             	cmpl   $0x20,(%edx)
  801d2a:	0f 85 e3 00 00 00    	jne    801e13 <lwip_getsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801d30:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801d33:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801d37:	0f 85 e0 00 00 00    	jne    801e1d <lwip_getsockopt+0x1a6>
  if (err != ERR_OK) {
  801d3d:	84 c0                	test   %al,%al
  801d3f:	74 42                	je     801d83 <lwip_getsockopt+0x10c>
  801d41:	e9 7c ff ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
  801d46:	83 ff 02             	cmp    $0x2,%edi
  801d49:	74 0e                	je     801d59 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801d4b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d50:	83 ff 08             	cmp    $0x8,%edi
  801d53:	0f 85 69 ff ff ff    	jne    801cc2 <lwip_getsockopt+0x4b>
      if (*optlen < sizeof(int)) {
  801d59:	8b 45 18             	mov    0x18(%ebp),%eax
  801d5c:	83 38 03             	cmpl   $0x3,(%eax)
  801d5f:	77 22                	ja     801d83 <lwip_getsockopt+0x10c>
        err = EINVAL;
  801d61:	b8 16 00 00 00       	mov    $0x16,%eax
  801d66:	e9 57 ff ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
  801d6b:	8d 47 ff             	lea    -0x1(%edi),%eax
  801d6e:	83 f8 01             	cmp    $0x1,%eax
  801d71:	0f 87 b0 00 00 00    	ja     801e27 <lwip_getsockopt+0x1b0>
      if (*optlen < sizeof(int)) {
  801d77:	8b 45 18             	mov    0x18(%ebp),%eax
  801d7a:	83 38 03             	cmpl   $0x3,(%eax)
  801d7d:	0f 86 ae 00 00 00    	jbe    801e31 <lwip_getsockopt+0x1ba>
  data.sock = sock;
  801d83:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801d86:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801d89:	89 7d d8             	mov    %edi,-0x28(%ebp)
  data.optval = optval;
  801d8c:	8b 45 14             	mov    0x14(%ebp),%eax
  801d8f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801d92:	8b 45 18             	mov    0x18(%ebp),%eax
  801d95:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801d98:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d9c:	83 ec 04             	sub    $0x4,%esp
  801d9f:	6a 01                	push   $0x1
  801da1:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801da4:	50                   	push   %eax
  801da5:	68 66 0c 80 00       	push   $0x800c66
  801daa:	e8 dc 05 00 00       	call   80238b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801daf:	83 c4 08             	add    $0x8,%esp
  801db2:	6a 00                	push   $0x0
  801db4:	8b 06                	mov    (%esi),%eax
  801db6:	ff 70 10             	pushl  0x10(%eax)
  801db9:	e8 26 84 00 00       	call   80a1e4 <sys_arch_sem_wait>
  err = data.err;
  801dbe:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801dc2:	0f be d0             	movsbl %al,%edx
  801dc5:	89 56 10             	mov    %edx,0x10(%esi)
  801dc8:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
  return err ? -1 : 0;
  801dce:	83 c4 10             	add    $0x10,%esp
  801dd1:	84 c0                	test   %al,%al
  801dd3:	0f 95 c0             	setne  %al
  801dd6:	0f b6 c0             	movzbl %al,%eax
  801dd9:	f7 d8                	neg    %eax
}
  801ddb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801dde:	5b                   	pop    %ebx
  801ddf:	5e                   	pop    %esi
  801de0:	5f                   	pop    %edi
  801de1:	5d                   	pop    %ebp
  801de2:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801de3:	8b 45 18             	mov    0x18(%ebp),%eax
  801de6:	83 38 03             	cmpl   $0x3,(%eax)
  801de9:	76 50                	jbe    801e3b <lwip_getsockopt+0x1c4>
    if (sock->conn->type != NETCONN_TCP)
  801deb:	8b 16                	mov    (%esi),%edx
      return 0;
  801ded:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801df2:	83 3a 10             	cmpl   $0x10,(%edx)
  801df5:	75 e4                	jne    801ddb <lwip_getsockopt+0x164>
  801df7:	8d 47 ff             	lea    -0x1(%edi),%eax
  801dfa:	83 f8 01             	cmp    $0x1,%eax
  801dfd:	76 84                	jbe    801d83 <lwip_getsockopt+0x10c>
      err = ENOPROTOOPT;
  801dff:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e04:	e9 b9 fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801e09:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e0e:	e9 af fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
        err = EAFNOSUPPORT;
  801e13:	b8 61 00 00 00       	mov    $0x61,%eax
  801e18:	e9 a5 fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
  801e1d:	b8 61 00 00 00       	mov    $0x61,%eax
  801e22:	e9 9b fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801e27:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e2c:	e9 91 fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801e31:	b8 16 00 00 00       	mov    $0x16,%eax
  801e36:	e9 87 fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
      err = EINVAL;
  801e3b:	b8 16 00 00 00       	mov    $0x16,%eax
  801e40:	e9 7d fe ff ff       	jmp    801cc2 <lwip_getsockopt+0x4b>
    return -1;
  801e45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e4a:	eb 8f                	jmp    801ddb <lwip_getsockopt+0x164>

00801e4c <lwip_setsockopt>:
{
  801e4c:	55                   	push   %ebp
  801e4d:	89 e5                	mov    %esp,%ebp
  801e4f:	57                   	push   %edi
  801e50:	56                   	push   %esi
  801e51:	53                   	push   %ebx
  801e52:	83 ec 2c             	sub    $0x2c,%esp
  801e55:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801e58:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801e5b:	8b 45 08             	mov    0x8(%ebp),%eax
  801e5e:	e8 c3 e9 ff ff       	call   800826 <get_socket>
  if (!sock)
  801e63:	85 c0                	test   %eax,%eax
  801e65:	0f 84 69 01 00 00    	je     801fd4 <lwip_setsockopt+0x188>
  801e6b:	89 c6                	mov    %eax,%esi
  if (NULL == optval) {
  801e6d:	85 ff                	test   %edi,%edi
  801e6f:	74 2c                	je     801e9d <lwip_setsockopt+0x51>
  switch (level) {
  801e71:	83 fb 06             	cmp    $0x6,%ebx
  801e74:	0f 84 01 01 00 00    	je     801f7b <lwip_setsockopt+0x12f>
  801e7a:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801e80:	74 36                	je     801eb8 <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801e82:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801e87:	85 db                	test   %ebx,%ebx
  801e89:	74 7b                	je     801f06 <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801e8b:	89 46 10             	mov    %eax,0x10(%esi)
  801e8e:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
    return -1;
  801e93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e98:	e9 d6 00 00 00       	jmp    801f73 <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801e9d:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801ea4:	c7 05 e0 c1 b3 00 0e 	movl   $0xe,0xb3c1e0
  801eab:	00 00 00 
    return -1;
  801eae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eb3:	e9 bb 00 00 00       	jmp    801f73 <lwip_setsockopt+0x127>
  801eb8:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801ebc:	74 14                	je     801ed2 <lwip_setsockopt+0x86>
  801ebe:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801ec5:	74 18                	je     801edf <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801ec7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ecc:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801ed0:	75 b9                	jne    801e8b <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801ed2:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801ed6:	77 47                	ja     801f1f <lwip_setsockopt+0xd3>
        err = EINVAL;
  801ed8:	b8 16 00 00 00       	mov    $0x16,%eax
  801edd:	eb ac                	jmp    801e8b <lwip_setsockopt+0x3f>
        err = EINVAL;
  801edf:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801ee3:	19 c0                	sbb    %eax,%eax
  801ee5:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801ee8:	8b 16                	mov    (%esi),%edx
  801eea:	83 3a 20             	cmpl   $0x20,(%edx)
  801eed:	0f 85 af 00 00 00    	jne    801fa2 <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801ef3:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801ef6:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801efa:	0f 85 ac 00 00 00    	jne    801fac <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801f00:	85 c0                	test   %eax,%eax
  801f02:	74 1b                	je     801f1f <lwip_setsockopt+0xd3>
  801f04:	eb 85                	jmp    801e8b <lwip_setsockopt+0x3f>
  801f06:	8b 45 10             	mov    0x10(%ebp),%eax
  801f09:	83 e8 01             	sub    $0x1,%eax
  801f0c:	83 f8 01             	cmp    $0x1,%eax
  801f0f:	0f 87 a1 00 00 00    	ja     801fb6 <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  801f15:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f19:	0f 86 a1 00 00 00    	jbe    801fc0 <lwip_setsockopt+0x174>
  data.sock = sock;
  801f1f:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801f22:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801f25:	8b 45 10             	mov    0x10(%ebp),%eax
  801f28:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801f2b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801f2e:	8d 45 18             	lea    0x18(%ebp),%eax
  801f31:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801f34:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801f38:	83 ec 04             	sub    $0x4,%esp
  801f3b:	6a 01                	push   $0x1
  801f3d:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801f40:	50                   	push   %eax
  801f41:	68 f5 0d 80 00       	push   $0x800df5
  801f46:	e8 40 04 00 00       	call   80238b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801f4b:	83 c4 08             	add    $0x8,%esp
  801f4e:	6a 00                	push   $0x0
  801f50:	8b 06                	mov    (%esi),%eax
  801f52:	ff 70 10             	pushl  0x10(%eax)
  801f55:	e8 8a 82 00 00       	call   80a1e4 <sys_arch_sem_wait>
  err = data.err;
  801f5a:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801f5e:	89 46 10             	mov    %eax,0x10(%esi)
  801f61:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
  return err ? -1 : 0;
  801f66:	83 c4 10             	add    $0x10,%esp
  801f69:	85 c0                	test   %eax,%eax
  801f6b:	0f 95 c0             	setne  %al
  801f6e:	0f b6 c0             	movzbl %al,%eax
  801f71:	f7 d8                	neg    %eax
}
  801f73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801f76:	5b                   	pop    %ebx
  801f77:	5e                   	pop    %esi
  801f78:	5f                   	pop    %edi
  801f79:	5d                   	pop    %ebp
  801f7a:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801f7b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f7f:	76 49                	jbe    801fca <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  801f81:	8b 10                	mov    (%eax),%edx
      return 0;
  801f83:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801f88:	83 3a 10             	cmpl   $0x10,(%edx)
  801f8b:	75 e6                	jne    801f73 <lwip_setsockopt+0x127>
  801f8d:	8b 45 10             	mov    0x10(%ebp),%eax
  801f90:	83 e8 01             	sub    $0x1,%eax
  801f93:	83 f8 01             	cmp    $0x1,%eax
  801f96:	76 87                	jbe    801f1f <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801f98:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f9d:	e9 e9 fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
        err = EAFNOSUPPORT;
  801fa2:	b8 61 00 00 00       	mov    $0x61,%eax
  801fa7:	e9 df fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
  801fac:	b8 61 00 00 00       	mov    $0x61,%eax
  801fb1:	e9 d5 fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801fb6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fbb:	e9 cb fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
        err = EINVAL;
  801fc0:	b8 16 00 00 00       	mov    $0x16,%eax
  801fc5:	e9 c1 fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
      err = EINVAL;
  801fca:	b8 16 00 00 00       	mov    $0x16,%eax
  801fcf:	e9 b7 fe ff ff       	jmp    801e8b <lwip_setsockopt+0x3f>
    return -1;
  801fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fd9:	eb 98                	jmp    801f73 <lwip_setsockopt+0x127>

00801fdb <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801fdb:	55                   	push   %ebp
  801fdc:	89 e5                	mov    %esp,%ebp
  801fde:	56                   	push   %esi
  801fdf:	53                   	push   %ebx
  801fe0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801fe3:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  801fe9:	e8 38 e8 ff ff       	call   800826 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801fee:	85 c0                	test   %eax,%eax
  801ff0:	0f 84 b4 00 00 00    	je     8020aa <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  801ff6:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801ffc:	74 5d                	je     80205b <lwip_ioctl+0x80>
  801ffe:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802004:	0f 85 88 00 00 00    	jne    802092 <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  80200a:	85 f6                	test   %esi,%esi
  80200c:	74 35                	je     802043 <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80200e:	8b 10                	mov    (%eax),%edx
  802010:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802014:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802017:	8b 48 04             	mov    0x4(%eax),%ecx
  80201a:	85 c9                	test   %ecx,%ecx
  80201c:	74 0d                	je     80202b <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  80201e:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  802020:	66 2b 50 08          	sub    0x8(%eax),%dx
  802024:	66 03 51 08          	add    0x8(%ecx),%dx
  802028:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80202b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802032:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  802039:	00 00 00 
    return 0;
  80203c:	b8 00 00 00 00       	mov    $0x0,%eax
  802041:	eb 4b                	jmp    80208e <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  802043:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  80204a:	c7 05 e0 c1 b3 00 16 	movl   $0x16,0xb3c1e0
  802051:	00 00 00 
      return -1;
  802054:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802059:	eb 33                	jmp    80208e <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  80205b:	85 f6                	test   %esi,%esi
  80205d:	74 0e                	je     80206d <lwip_ioctl+0x92>
  80205f:	83 3e 00             	cmpl   $0x0,(%esi)
  802062:	74 09                	je     80206d <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  802064:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  802068:	80 ce 08             	or     $0x8,%dh
  80206b:	eb 07                	jmp    802074 <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  80206d:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  802071:	80 e6 f7             	and    $0xf7,%dh
  802074:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  802078:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80207f:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  802086:	00 00 00 
    return 0;
  802089:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  80208e:	5b                   	pop    %ebx
  80208f:	5e                   	pop    %esi
  802090:	5d                   	pop    %ebp
  802091:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802092:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  802099:	c7 05 e0 c1 b3 00 26 	movl   $0x26,0xb3c1e0
  8020a0:	00 00 00 
    return -1;
  8020a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020a8:	eb e4                	jmp    80208e <lwip_ioctl+0xb3>
    return -1;
  8020aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020af:	eb dd                	jmp    80208e <lwip_ioctl+0xb3>

008020b1 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8020b1:	55                   	push   %ebp
  8020b2:	89 e5                	mov    %esp,%ebp
  8020b4:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8020b7:	e8 1e 41 00 00       	call   8061da <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8020bc:	83 3d 3c c2 b3 00 00 	cmpl   $0x0,0xb3c23c
  8020c3:	74 19                	je     8020de <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8020c5:	83 ec 04             	sub    $0x4,%esp
  8020c8:	6a 00                	push   $0x0
  8020ca:	68 b1 20 80 00       	push   $0x8020b1
  8020cf:	68 fa 00 00 00       	push   $0xfa
  8020d4:	e8 96 31 00 00       	call   80526f <sys_timeout>
  8020d9:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  8020dc:	c9                   	leave  
  8020dd:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8020de:	83 3d 50 c2 b3 00 00 	cmpl   $0x0,0xb3c250
  8020e5:	75 de                	jne    8020c5 <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  8020e7:	c7 05 e0 62 81 00 00 	movl   $0x0,0x8162e0
  8020ee:	00 00 00 
}
  8020f1:	eb e9                	jmp    8020dc <tcpip_tcp_timer+0x2b>

008020f3 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8020f3:	55                   	push   %ebp
  8020f4:	89 e5                	mov    %esp,%ebp
  8020f6:	53                   	push   %ebx
  8020f7:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8020fa:	6a 00                	push   $0x0
  8020fc:	68 a3 22 80 00       	push   $0x8022a3
  802101:	68 e8 03 00 00       	push   $0x3e8
  802106:	e8 64 31 00 00       	call   80526f <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80210b:	83 c4 0c             	add    $0xc,%esp
  80210e:	6a 00                	push   $0x0
  802110:	68 7f 22 80 00       	push   $0x80227f
  802115:	68 88 13 00 00       	push   $0x1388
  80211a:	e8 50 31 00 00       	call   80526f <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80211f:	83 c4 0c             	add    $0xc,%esp
  802122:	6a 00                	push   $0x0
  802124:	68 5b 22 80 00       	push   $0x80225b
  802129:	68 60 ea 00 00       	push   $0xea60
  80212e:	e8 3c 31 00 00       	call   80526f <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802133:	83 c4 0c             	add    $0xc,%esp
  802136:	6a 00                	push   $0x0
  802138:	68 37 22 80 00       	push   $0x802237
  80213d:	68 f4 01 00 00       	push   $0x1f4
  802142:	e8 28 31 00 00       	call   80526f <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  802147:	a1 e8 62 81 00       	mov    0x8162e8,%eax
  80214c:	83 c4 10             	add    $0x10,%esp
  80214f:	85 c0                	test   %eax,%eax
  802151:	74 0e                	je     802161 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  802153:	83 ec 0c             	sub    $0xc,%esp
  802156:	ff 35 e4 62 81 00    	pushl  0x8162e4
  80215c:	ff d0                	call   *%eax
  80215e:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802161:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802164:	eb 0f                	jmp    802175 <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802166:	8b 42 08             	mov    0x8(%edx),%eax
  802169:	83 ec 0c             	sub    $0xc,%esp
  80216c:	8d 50 04             	lea    0x4(%eax),%edx
  80216f:	52                   	push   %edx
  802170:	ff 10                	call   *(%eax)
      break;
  802172:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802175:	83 ec 08             	sub    $0x8,%esp
  802178:	53                   	push   %ebx
  802179:	ff 35 00 50 81 00    	pushl  0x815000
  80217f:	e8 cb 2f 00 00       	call   80514f <sys_mbox_fetch>
    switch (msg->type) {
  802184:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802187:	8b 02                	mov    (%edx),%eax
  802189:	83 c4 10             	add    $0x10,%esp
  80218c:	83 f8 01             	cmp    $0x1,%eax
  80218f:	74 3a                	je     8021cb <tcpip_thread+0xd8>
  802191:	85 c0                	test   %eax,%eax
  802193:	74 d1                	je     802166 <tcpip_thread+0x73>
  802195:	83 f8 02             	cmp    $0x2,%eax
  802198:	74 6c                	je     802206 <tcpip_thread+0x113>
  80219a:	83 f8 03             	cmp    $0x3,%eax
  80219d:	75 d6                	jne    802175 <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80219f:	8b 42 08             	mov    0x8(%edx),%eax
  8021a2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8021a5:	74 7d                	je     802224 <tcpip_thread+0x131>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8021a7:	83 ec 04             	sub    $0x4,%esp
  8021aa:	ff 72 10             	pushl  0x10(%edx)
  8021ad:	ff 72 0c             	pushl  0xc(%edx)
  8021b0:	50                   	push   %eax
  8021b1:	e8 b9 30 00 00       	call   80526f <sys_timeout>
  8021b6:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8021b9:	83 ec 08             	sub    $0x8,%esp
  8021bc:	ff 75 f4             	pushl  -0xc(%ebp)
  8021bf:	6a 08                	push   $0x8
  8021c1:	e8 f1 23 00 00       	call   8045b7 <memp_free>
      break;
  8021c6:	83 c4 10             	add    $0x10,%esp
  8021c9:	eb aa                	jmp    802175 <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8021cb:	8b 42 0c             	mov    0xc(%edx),%eax
  8021ce:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8021d2:	74 21                	je     8021f5 <tcpip_thread+0x102>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8021d4:	83 ec 08             	sub    $0x8,%esp
  8021d7:	50                   	push   %eax
  8021d8:	ff 72 08             	pushl  0x8(%edx)
  8021db:	e8 2d 7b 00 00       	call   809d0d <ethernet_input>
  8021e0:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8021e3:	83 ec 08             	sub    $0x8,%esp
  8021e6:	ff 75 f4             	pushl  -0xc(%ebp)
  8021e9:	6a 09                	push   $0x9
  8021eb:	e8 c7 23 00 00       	call   8045b7 <memp_free>
      break;
  8021f0:	83 c4 10             	add    $0x10,%esp
  8021f3:	eb 80                	jmp    802175 <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8021f5:	83 ec 08             	sub    $0x8,%esp
  8021f8:	50                   	push   %eax
  8021f9:	ff 72 08             	pushl  0x8(%edx)
  8021fc:	e8 1a 44 00 00       	call   80661b <ip_input>
  802201:	83 c4 10             	add    $0x10,%esp
  802204:	eb dd                	jmp    8021e3 <tcpip_thread+0xf0>
      msg->msg.cb.f(msg->msg.cb.ctx);
  802206:	83 ec 0c             	sub    $0xc,%esp
  802209:	ff 72 0c             	pushl  0xc(%edx)
  80220c:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80220f:	83 c4 08             	add    $0x8,%esp
  802212:	ff 75 f4             	pushl  -0xc(%ebp)
  802215:	6a 08                	push   $0x8
  802217:	e8 9b 23 00 00       	call   8045b7 <memp_free>
      break;
  80221c:	83 c4 10             	add    $0x10,%esp
  80221f:	e9 51 ff ff ff       	jmp    802175 <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802224:	83 ec 08             	sub    $0x8,%esp
  802227:	ff 72 10             	pushl  0x10(%edx)
  80222a:	ff 72 0c             	pushl  0xc(%edx)
  80222d:	e8 00 31 00 00       	call   805332 <sys_untimeout>
  802232:	83 c4 10             	add    $0x10,%esp
  802235:	eb 82                	jmp    8021b9 <tcpip_thread+0xc6>

00802237 <dhcp_timer_fine>:
{
  802237:	55                   	push   %ebp
  802238:	89 e5                	mov    %esp,%ebp
  80223a:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  80223d:	e8 45 1b 00 00       	call   803d87 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802242:	83 ec 04             	sub    $0x4,%esp
  802245:	6a 00                	push   $0x0
  802247:	68 37 22 80 00       	push   $0x802237
  80224c:	68 f4 01 00 00       	push   $0x1f4
  802251:	e8 19 30 00 00       	call   80526f <sys_timeout>
}
  802256:	83 c4 10             	add    $0x10,%esp
  802259:	c9                   	leave  
  80225a:	c3                   	ret    

0080225b <dhcp_timer_coarse>:
{
  80225b:	55                   	push   %ebp
  80225c:	89 e5                	mov    %esp,%ebp
  80225e:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  802261:	e8 55 19 00 00       	call   803bbb <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802266:	83 ec 04             	sub    $0x4,%esp
  802269:	6a 00                	push   $0x0
  80226b:	68 5b 22 80 00       	push   $0x80225b
  802270:	68 60 ea 00 00       	push   $0xea60
  802275:	e8 f5 2f 00 00       	call   80526f <sys_timeout>
}
  80227a:	83 c4 10             	add    $0x10,%esp
  80227d:	c9                   	leave  
  80227e:	c3                   	ret    

0080227f <arp_timer>:
{
  80227f:	55                   	push   %ebp
  802280:	89 e5                	mov    %esp,%ebp
  802282:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  802285:	e8 53 73 00 00       	call   8095dd <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80228a:	83 ec 04             	sub    $0x4,%esp
  80228d:	6a 00                	push   $0x0
  80228f:	68 7f 22 80 00       	push   $0x80227f
  802294:	68 88 13 00 00       	push   $0x1388
  802299:	e8 d1 2f 00 00       	call   80526f <sys_timeout>
}
  80229e:	83 c4 10             	add    $0x10,%esp
  8022a1:	c9                   	leave  
  8022a2:	c3                   	ret    

008022a3 <ip_reass_timer>:
{
  8022a3:	55                   	push   %ebp
  8022a4:	89 e5                	mov    %esp,%ebp
  8022a6:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  8022a9:	e8 68 4a 00 00       	call   806d16 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8022ae:	83 ec 04             	sub    $0x4,%esp
  8022b1:	6a 00                	push   $0x0
  8022b3:	68 a3 22 80 00       	push   $0x8022a3
  8022b8:	68 e8 03 00 00       	push   $0x3e8
  8022bd:	e8 ad 2f 00 00       	call   80526f <sys_timeout>
}
  8022c2:	83 c4 10             	add    $0x10,%esp
  8022c5:	c9                   	leave  
  8022c6:	c3                   	ret    

008022c7 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8022c7:	55                   	push   %ebp
  8022c8:	89 e5                	mov    %esp,%ebp
  8022ca:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8022cd:	ff 75 08             	pushl  0x8(%ebp)
  8022d0:	e8 2f 26 00 00       	call   804904 <pbuf_free>
}
  8022d5:	83 c4 10             	add    $0x10,%esp
  8022d8:	c9                   	leave  
  8022d9:	c3                   	ret    

008022da <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8022da:	83 3d e0 62 81 00 00 	cmpl   $0x0,0x8162e0
  8022e1:	75 38                	jne    80231b <tcp_timer_needed+0x41>
  8022e3:	83 3d 3c c2 b3 00 00 	cmpl   $0x0,0xb3c23c
  8022ea:	74 26                	je     802312 <tcp_timer_needed+0x38>
{
  8022ec:	55                   	push   %ebp
  8022ed:	89 e5                	mov    %esp,%ebp
  8022ef:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  8022f2:	c7 05 e0 62 81 00 01 	movl   $0x1,0x8162e0
  8022f9:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8022fc:	6a 00                	push   $0x0
  8022fe:	68 b1 20 80 00       	push   $0x8020b1
  802303:	68 fa 00 00 00       	push   $0xfa
  802308:	e8 62 2f 00 00       	call   80526f <sys_timeout>
  80230d:	83 c4 10             	add    $0x10,%esp
}
  802310:	c9                   	leave  
  802311:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802312:	83 3d 50 c2 b3 00 00 	cmpl   $0x0,0xb3c250
  802319:	75 d1                	jne    8022ec <tcp_timer_needed+0x12>
  80231b:	c3                   	ret    

0080231c <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  80231c:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802323:	74 59                	je     80237e <tcpip_input+0x62>
{
  802325:	55                   	push   %ebp
  802326:	89 e5                	mov    %esp,%ebp
  802328:	53                   	push   %ebx
  802329:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80232c:	6a 09                	push   $0x9
  80232e:	e8 2e 22 00 00       	call   804561 <memp_malloc>
  802333:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802335:	83 c4 10             	add    $0x10,%esp
  802338:	85 c0                	test   %eax,%eax
  80233a:	74 48                	je     802384 <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  80233c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802342:	8b 45 08             	mov    0x8(%ebp),%eax
  802345:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802348:	8b 45 0c             	mov    0xc(%ebp),%eax
  80234b:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80234e:	83 ec 08             	sub    $0x8,%esp
  802351:	53                   	push   %ebx
  802352:	ff 35 00 50 81 00    	pushl  0x815000
  802358:	e8 97 7f 00 00       	call   80a2f4 <sys_mbox_trypost>
  80235d:	83 c4 10             	add    $0x10,%esp
  802360:	84 c0                	test   %al,%al
  802362:	75 05                	jne    802369 <tcpip_input+0x4d>
}
  802364:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802367:	c9                   	leave  
  802368:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802369:	83 ec 08             	sub    $0x8,%esp
  80236c:	53                   	push   %ebx
  80236d:	6a 09                	push   $0x9
  80236f:	e8 43 22 00 00       	call   8045b7 <memp_free>
      return ERR_MEM;
  802374:	83 c4 10             	add    $0x10,%esp
  802377:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80237c:	eb e6                	jmp    802364 <tcpip_input+0x48>
  return ERR_VAL;
  80237e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802383:	c3                   	ret    
      return ERR_MEM;
  802384:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802389:	eb d9                	jmp    802364 <tcpip_input+0x48>

0080238b <tcpip_callback_with_block>:
{
  80238b:	55                   	push   %ebp
  80238c:	89 e5                	mov    %esp,%ebp
  80238e:	56                   	push   %esi
  80238f:	53                   	push   %ebx
  802390:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802393:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  80239a:	74 76                	je     802412 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80239c:	83 ec 0c             	sub    $0xc,%esp
  80239f:	6a 08                	push   $0x8
  8023a1:	e8 bb 21 00 00       	call   804561 <memp_malloc>
  8023a6:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8023a8:	83 c4 10             	add    $0x10,%esp
  8023ab:	85 c0                	test   %eax,%eax
  8023ad:	74 6a                	je     802419 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  8023af:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  8023b5:	8b 45 08             	mov    0x8(%ebp),%eax
  8023b8:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  8023bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023be:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  8023c1:	89 f0                	mov    %esi,%eax
  8023c3:	84 c0                	test   %al,%al
  8023c5:	75 1d                	jne    8023e4 <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8023c7:	83 ec 08             	sub    $0x8,%esp
  8023ca:	53                   	push   %ebx
  8023cb:	ff 35 00 50 81 00    	pushl  0x815000
  8023d1:	e8 1e 7f 00 00       	call   80a2f4 <sys_mbox_trypost>
  8023d6:	83 c4 10             	add    $0x10,%esp
  8023d9:	84 c0                	test   %al,%al
  8023db:	75 20                	jne    8023fd <tcpip_callback_with_block+0x72>
}
  8023dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8023e0:	5b                   	pop    %ebx
  8023e1:	5e                   	pop    %esi
  8023e2:	5d                   	pop    %ebp
  8023e3:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  8023e4:	83 ec 08             	sub    $0x8,%esp
  8023e7:	53                   	push   %ebx
  8023e8:	ff 35 00 50 81 00    	pushl  0x815000
  8023ee:	e8 c6 7f 00 00       	call   80a3b9 <sys_mbox_post>
  8023f3:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  8023f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8023fb:	eb e0                	jmp    8023dd <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8023fd:	83 ec 08             	sub    $0x8,%esp
  802400:	53                   	push   %ebx
  802401:	6a 08                	push   $0x8
  802403:	e8 af 21 00 00       	call   8045b7 <memp_free>
        return ERR_MEM;
  802408:	83 c4 10             	add    $0x10,%esp
  80240b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802410:	eb cb                	jmp    8023dd <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  802412:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802417:	eb c4                	jmp    8023dd <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  802419:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80241e:	eb bd                	jmp    8023dd <tcpip_callback_with_block+0x52>

00802420 <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  802420:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802427:	74 45                	je     80246e <tcpip_timeout+0x4e>
{
  802429:	55                   	push   %ebp
  80242a:	89 e5                	mov    %esp,%ebp
  80242c:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80242f:	6a 08                	push   $0x8
  802431:	e8 2b 21 00 00       	call   804561 <memp_malloc>
    if (msg == NULL) {
  802436:	83 c4 10             	add    $0x10,%esp
  802439:	85 c0                	test   %eax,%eax
  80243b:	74 37                	je     802474 <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  80243d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802443:	8b 55 08             	mov    0x8(%ebp),%edx
  802446:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802449:	8b 55 0c             	mov    0xc(%ebp),%edx
  80244c:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  80244f:	8b 55 10             	mov    0x10(%ebp),%edx
  802452:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802455:	83 ec 08             	sub    $0x8,%esp
  802458:	50                   	push   %eax
  802459:	ff 35 00 50 81 00    	pushl  0x815000
  80245f:	e8 55 7f 00 00       	call   80a3b9 <sys_mbox_post>
    return ERR_OK;
  802464:	83 c4 10             	add    $0x10,%esp
  802467:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80246c:	c9                   	leave  
  80246d:	c3                   	ret    
  return ERR_VAL;
  80246e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802473:	c3                   	ret    
      return ERR_MEM;
  802474:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802479:	eb f1                	jmp    80246c <tcpip_timeout+0x4c>

0080247b <tcpip_apimsg>:
{
  80247b:	55                   	push   %ebp
  80247c:	89 e5                	mov    %esp,%ebp
  80247e:	53                   	push   %ebx
  80247f:	83 ec 24             	sub    $0x24,%esp
  802482:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802485:	a1 00 50 81 00       	mov    0x815000,%eax
  80248a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80248d:	74 34                	je     8024c3 <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  80248f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802496:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802499:	83 ec 08             	sub    $0x8,%esp
  80249c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80249f:	52                   	push   %edx
  8024a0:	50                   	push   %eax
  8024a1:	e8 13 7f 00 00       	call   80a3b9 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  8024a6:	83 c4 08             	add    $0x8,%esp
  8024a9:	6a 00                	push   $0x0
  8024ab:	8b 43 04             	mov    0x4(%ebx),%eax
  8024ae:	ff 70 10             	pushl  0x10(%eax)
  8024b1:	e8 2e 7d 00 00       	call   80a1e4 <sys_arch_sem_wait>
    return ERR_OK;
  8024b6:	83 c4 10             	add    $0x10,%esp
  8024b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8024be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8024c1:	c9                   	leave  
  8024c2:	c3                   	ret    
  return ERR_VAL;
  8024c3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8024c8:	eb f4                	jmp    8024be <tcpip_apimsg+0x43>

008024ca <tcpip_init>:
{
  8024ca:	55                   	push   %ebp
  8024cb:	89 e5                	mov    %esp,%ebp
  8024cd:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  8024d0:	e8 6a 03 00 00       	call   80283f <lwip_init>
  tcpip_init_done = initfunc;
  8024d5:	8b 45 08             	mov    0x8(%ebp),%eax
  8024d8:	a3 e8 62 81 00       	mov    %eax,0x8162e8
  tcpip_init_done_arg = arg;
  8024dd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8024e0:	a3 e4 62 81 00       	mov    %eax,0x8162e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8024e5:	83 ec 0c             	sub    $0xc,%esp
  8024e8:	6a 00                	push   $0x0
  8024ea:	e8 71 7b 00 00       	call   80a060 <sys_mbox_new>
  8024ef:	a3 00 50 81 00       	mov    %eax,0x815000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8024f4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8024fb:	6a 00                	push   $0x0
  8024fd:	6a 00                	push   $0x0
  8024ff:	68 f3 20 80 00       	push   $0x8020f3
  802504:	68 7c 17 81 00       	push   $0x81177c
  802509:	e8 de 7f 00 00       	call   80a4ec <sys_thread_new>
}
  80250e:	83 c4 20             	add    $0x20,%esp
  802511:	c9                   	leave  
  802512:	c3                   	ret    

00802513 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802513:	55                   	push   %ebp
  802514:	89 e5                	mov    %esp,%ebp
  802516:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802519:	6a 00                	push   $0x0
  80251b:	ff 75 08             	pushl  0x8(%ebp)
  80251e:	68 c7 22 80 00       	push   $0x8022c7
  802523:	e8 63 fe ff ff       	call   80238b <tcpip_callback_with_block>
}
  802528:	c9                   	leave  
  802529:	c3                   	ret    

0080252a <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  80252a:	55                   	push   %ebp
  80252b:	89 e5                	mov    %esp,%ebp
  80252d:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802530:	6a 00                	push   $0x0
  802532:	ff 75 08             	pushl  0x8(%ebp)
  802535:	68 1e 40 80 00       	push   $0x80401e
  80253a:	e8 4c fe ff ff       	call   80238b <tcpip_callback_with_block>
}
  80253f:	c9                   	leave  
  802540:	c3                   	ret    

00802541 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802541:	55                   	push   %ebp
  802542:	89 e5                	mov    %esp,%ebp
  802544:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802547:	6a 06                	push   $0x6
  802549:	e8 13 20 00 00       	call   804561 <memp_malloc>
  if (buf != NULL) {
  80254e:	83 c4 10             	add    $0x10,%esp
  802551:	85 c0                	test   %eax,%eax
  802553:	74 14                	je     802569 <netbuf_new+0x28>
    buf->p = NULL;
  802555:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80255b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802562:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802569:	c9                   	leave  
  80256a:	c3                   	ret    

0080256b <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80256b:	55                   	push   %ebp
  80256c:	89 e5                	mov    %esp,%ebp
  80256e:	53                   	push   %ebx
  80256f:	83 ec 04             	sub    $0x4,%esp
  802572:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802575:	85 db                	test   %ebx,%ebx
  802577:	74 2d                	je     8025a6 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802579:	8b 03                	mov    (%ebx),%eax
  80257b:	85 c0                	test   %eax,%eax
  80257d:	74 19                	je     802598 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  80257f:	83 ec 0c             	sub    $0xc,%esp
  802582:	50                   	push   %eax
  802583:	e8 7c 23 00 00       	call   804904 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802588:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80258f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802595:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802598:	83 ec 08             	sub    $0x8,%esp
  80259b:	53                   	push   %ebx
  80259c:	6a 06                	push   $0x6
  80259e:	e8 14 20 00 00       	call   8045b7 <memp_free>
  8025a3:	83 c4 10             	add    $0x10,%esp
  }
}
  8025a6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025a9:	c9                   	leave  
  8025aa:	c3                   	ret    

008025ab <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  8025ab:	55                   	push   %ebp
  8025ac:	89 e5                	mov    %esp,%ebp
  8025ae:	56                   	push   %esi
  8025af:	53                   	push   %ebx
  8025b0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025b3:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8025b6:	85 db                	test   %ebx,%ebx
  8025b8:	74 3e                	je     8025f8 <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8025ba:	8b 03                	mov    (%ebx),%eax
  8025bc:	85 c0                	test   %eax,%eax
  8025be:	74 0c                	je     8025cc <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  8025c0:	83 ec 0c             	sub    $0xc,%esp
  8025c3:	50                   	push   %eax
  8025c4:	e8 3b 23 00 00       	call   804904 <pbuf_free>
  8025c9:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8025cc:	83 ec 04             	sub    $0x4,%esp
  8025cf:	6a 00                	push   $0x0
  8025d1:	0f b7 c6             	movzwl %si,%eax
  8025d4:	50                   	push   %eax
  8025d5:	6a 00                	push   $0x0
  8025d7:	e8 ee 23 00 00       	call   8049ca <pbuf_alloc>
  8025dc:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8025de:	83 c4 10             	add    $0x10,%esp
  8025e1:	85 c0                	test   %eax,%eax
  8025e3:	74 0c                	je     8025f1 <netbuf_alloc+0x46>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8025e5:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8025e9:	72 21                	jb     80260c <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8025eb:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8025ee:	8b 40 04             	mov    0x4(%eax),%eax
}
  8025f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025f4:	5b                   	pop    %ebx
  8025f5:	5e                   	pop    %esi
  8025f6:	5d                   	pop    %ebp
  8025f7:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8025f8:	83 ec 04             	sub    $0x4,%esp
  8025fb:	68 89 17 81 00       	push   $0x811789
  802600:	6a 63                	push   $0x63
  802602:	68 a3 17 81 00       	push   $0x8117a3
  802607:	e8 63 c1 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  80260c:	83 ec 04             	sub    $0x4,%esp
  80260f:	68 70 18 81 00       	push   $0x811870
  802614:	6a 6e                	push   $0x6e
  802616:	68 a3 17 81 00       	push   $0x8117a3
  80261b:	e8 4f c1 00 00       	call   80e76f <_panic>

00802620 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  802620:	55                   	push   %ebp
  802621:	89 e5                	mov    %esp,%ebp
  802623:	53                   	push   %ebx
  802624:	83 ec 04             	sub    $0x4,%esp
  802627:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80262a:	85 db                	test   %ebx,%ebx
  80262c:	74 24                	je     802652 <netbuf_free+0x32>
  if (buf->p != NULL) {
  80262e:	8b 03                	mov    (%ebx),%eax
  802630:	85 c0                	test   %eax,%eax
  802632:	74 0c                	je     802640 <netbuf_free+0x20>
    pbuf_free(buf->p);
  802634:	83 ec 0c             	sub    $0xc,%esp
  802637:	50                   	push   %eax
  802638:	e8 c7 22 00 00       	call   804904 <pbuf_free>
  80263d:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  802640:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802647:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  80264d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802650:	c9                   	leave  
  802651:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802652:	83 ec 04             	sub    $0x4,%esp
  802655:	68 b9 17 81 00       	push   $0x8117b9
  80265a:	6a 7b                	push   $0x7b
  80265c:	68 a3 17 81 00       	push   $0x8117a3
  802661:	e8 09 c1 00 00       	call   80e76f <_panic>

00802666 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802666:	55                   	push   %ebp
  802667:	89 e5                	mov    %esp,%ebp
  802669:	56                   	push   %esi
  80266a:	53                   	push   %ebx
  80266b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80266e:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802671:	85 db                	test   %ebx,%ebx
  802673:	74 4c                	je     8026c1 <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  802675:	8b 03                	mov    (%ebx),%eax
  802677:	85 c0                	test   %eax,%eax
  802679:	74 0c                	je     802687 <netbuf_ref+0x21>
    pbuf_free(buf->p);
  80267b:	83 ec 0c             	sub    $0xc,%esp
  80267e:	50                   	push   %eax
  80267f:	e8 80 22 00 00       	call   804904 <pbuf_free>
  802684:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802687:	83 ec 04             	sub    $0x4,%esp
  80268a:	6a 02                	push   $0x2
  80268c:	6a 00                	push   $0x0
  80268e:	6a 00                	push   $0x0
  802690:	e8 35 23 00 00       	call   8049ca <pbuf_alloc>
  802695:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802697:	83 c4 10             	add    $0x10,%esp
  80269a:	85 c0                	test   %eax,%eax
  80269c:	74 3a                	je     8026d8 <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80269e:	8b 55 0c             	mov    0xc(%ebp),%edx
  8026a1:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  8026a4:	8b 03                	mov    (%ebx),%eax
  8026a6:	66 89 70 08          	mov    %si,0x8(%eax)
  8026aa:	8b 03                	mov    (%ebx),%eax
  8026ac:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8026b0:	8b 03                	mov    (%ebx),%eax
  8026b2:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8026b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8026ba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026bd:	5b                   	pop    %ebx
  8026be:	5e                   	pop    %esi
  8026bf:	5d                   	pop    %ebp
  8026c0:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8026c1:	83 ec 04             	sub    $0x4,%esp
  8026c4:	68 d2 17 81 00       	push   $0x8117d2
  8026c9:	68 8e 00 00 00       	push   $0x8e
  8026ce:	68 a3 17 81 00       	push   $0x8117a3
  8026d3:	e8 97 c0 00 00       	call   80e76f <_panic>
    buf->ptr = NULL;
  8026d8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8026df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026e4:	eb d4                	jmp    8026ba <netbuf_ref+0x54>

008026e6 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8026e6:	55                   	push   %ebp
  8026e7:	89 e5                	mov    %esp,%ebp
  8026e9:	56                   	push   %esi
  8026ea:	53                   	push   %ebx
  8026eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8026ee:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8026f1:	85 db                	test   %ebx,%ebx
  8026f3:	74 2a                	je     80271f <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8026f5:	85 f6                	test   %esi,%esi
  8026f7:	74 3d                	je     802736 <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  8026f9:	83 ec 08             	sub    $0x8,%esp
  8026fc:	ff 36                	pushl  (%esi)
  8026fe:	ff 33                	pushl  (%ebx)
  802700:	e8 e0 26 00 00       	call   804de5 <pbuf_chain>
  head->ptr = head->p;
  802705:	8b 03                	mov    (%ebx),%eax
  802707:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  80270a:	83 c4 08             	add    $0x8,%esp
  80270d:	56                   	push   %esi
  80270e:	6a 06                	push   $0x6
  802710:	e8 a2 1e 00 00       	call   8045b7 <memp_free>
  802715:	83 c4 10             	add    $0x10,%esp
}
  802718:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80271b:	5b                   	pop    %ebx
  80271c:	5e                   	pop    %esi
  80271d:	5d                   	pop    %ebp
  80271e:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80271f:	83 ec 04             	sub    $0x4,%esp
  802722:	68 ea 17 81 00       	push   $0x8117ea
  802727:	68 a6 00 00 00       	push   $0xa6
  80272c:	68 a3 17 81 00       	push   $0x8117a3
  802731:	e8 39 c0 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802736:	83 ec 04             	sub    $0x4,%esp
  802739:	68 03 18 81 00       	push   $0x811803
  80273e:	68 a7 00 00 00       	push   $0xa7
  802743:	68 a3 17 81 00       	push   $0x8117a3
  802748:	e8 22 c0 00 00       	call   80e76f <_panic>

0080274d <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80274d:	55                   	push   %ebp
  80274e:	89 e5                	mov    %esp,%ebp
  802750:	53                   	push   %ebx
  802751:	83 ec 04             	sub    $0x4,%esp
  802754:	8b 45 08             	mov    0x8(%ebp),%eax
  802757:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80275a:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80275d:	85 c0                	test   %eax,%eax
  80275f:	74 28                	je     802789 <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802761:	85 c9                	test   %ecx,%ecx
  802763:	74 3b                	je     8027a0 <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802765:	85 d2                	test   %edx,%edx
  802767:	74 4e                	je     8027b7 <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  802769:	8b 58 04             	mov    0x4(%eax),%ebx
  80276c:	85 db                	test   %ebx,%ebx
  80276e:	74 5e                	je     8027ce <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802770:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802773:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802775:	8b 40 04             	mov    0x4(%eax),%eax
  802778:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80277c:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  80277f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802784:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802787:	c9                   	leave  
  802788:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802789:	83 ec 04             	sub    $0x4,%esp
  80278c:	68 1e 18 81 00       	push   $0x81181e
  802791:	68 b9 00 00 00       	push   $0xb9
  802796:	68 a3 17 81 00       	push   $0x8117a3
  80279b:	e8 cf bf 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8027a0:	83 ec 04             	sub    $0x4,%esp
  8027a3:	68 37 18 81 00       	push   $0x811837
  8027a8:	68 ba 00 00 00       	push   $0xba
  8027ad:	68 a3 17 81 00       	push   $0x8117a3
  8027b2:	e8 b8 bf 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8027b7:	83 ec 04             	sub    $0x4,%esp
  8027ba:	68 54 18 81 00       	push   $0x811854
  8027bf:	68 bb 00 00 00       	push   $0xbb
  8027c4:	68 a3 17 81 00       	push   $0x8117a3
  8027c9:	e8 a1 bf 00 00       	call   80e76f <_panic>
    return ERR_BUF;
  8027ce:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8027d3:	eb af                	jmp    802784 <netbuf_data+0x37>

008027d5 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8027d5:	55                   	push   %ebp
  8027d6:	89 e5                	mov    %esp,%ebp
  8027d8:	83 ec 08             	sub    $0x8,%esp
  8027db:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8027de:	85 c0                	test   %eax,%eax
  8027e0:	74 14                	je     8027f6 <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  8027e2:	8b 50 04             	mov    0x4(%eax),%edx
  8027e5:	8b 12                	mov    (%edx),%edx
  8027e7:	85 d2                	test   %edx,%edx
  8027e9:	74 22                	je     80280d <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8027eb:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8027ee:	83 3a 00             	cmpl   $0x0,(%edx)
  8027f1:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8027f4:	c9                   	leave  
  8027f5:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8027f6:	83 ec 04             	sub    $0x4,%esp
  8027f9:	68 b9 17 81 00       	push   $0x8117b9
  8027fe:	68 d2 00 00 00       	push   $0xd2
  802803:	68 a3 17 81 00       	push   $0x8117a3
  802808:	e8 62 bf 00 00       	call   80e76f <_panic>
    return -1;
  80280d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802812:	eb e0                	jmp    8027f4 <netbuf_next+0x1f>

00802814 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802814:	55                   	push   %ebp
  802815:	89 e5                	mov    %esp,%ebp
  802817:	83 ec 08             	sub    $0x8,%esp
  80281a:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80281d:	85 c0                	test   %eax,%eax
  80281f:	74 07                	je     802828 <netbuf_first+0x14>
  buf->ptr = buf->p;
  802821:	8b 10                	mov    (%eax),%edx
  802823:	89 50 04             	mov    %edx,0x4(%eax)
}
  802826:	c9                   	leave  
  802827:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802828:	83 ec 04             	sub    $0x4,%esp
  80282b:	68 b9 17 81 00       	push   $0x8117b9
  802830:	68 e7 00 00 00       	push   $0xe7
  802835:	68 a3 17 81 00       	push   $0x8117a3
  80283a:	e8 30 bf 00 00       	call   80e76f <_panic>

0080283f <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  80283f:	55                   	push   %ebp
  802840:	89 e5                	mov    %esp,%ebp
  802842:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802845:	e8 d0 75 00 00       	call   809e1a <sys_init>
  mem_init();
  80284a:	e8 69 17 00 00       	call   803fb8 <mem_init>
  memp_init();
  80284f:	e8 b1 1c 00 00       	call   804505 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802854:	e8 a9 e6 ff ff       	call   800f02 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802859:	c9                   	leave  
  80285a:	c3                   	ret    

0080285b <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  80285b:	38 10                	cmp    %dl,(%eax)
  80285d:	74 06                	je     802865 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  80285f:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802861:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802865:	c3                   	ret    

00802866 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802866:	55                   	push   %ebp
  802867:	89 e5                	mov    %esp,%ebp
  802869:	57                   	push   %edi
  80286a:	56                   	push   %esi
  80286b:	53                   	push   %ebx
  80286c:	83 ec 0c             	sub    $0xc,%esp
  80286f:	89 c7                	mov    %eax,%edi
  802871:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802874:	8b 40 14             	mov    0x14(%eax),%eax
  802877:	85 c0                	test   %eax,%eax
  802879:	74 19                	je     802894 <dhcp_get_option_ptr+0x2e>
  80287b:	89 d6                	mov    %edx,%esi
  80287d:	0f b7 7f 18          	movzwl 0x18(%edi),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802881:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  802886:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80288a:	66 85 ff             	test   %di,%di
  80288d:	75 2d                	jne    8028bc <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80288f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802894:	83 c4 0c             	add    $0xc,%esp
  802897:	5b                   	pop    %ebx
  802898:	5e                   	pop    %esi
  802899:	5f                   	pop    %edi
  80289a:	5d                   	pop    %ebp
  80289b:	c3                   	ret    
        offset += 2;
  80289c:	8d 51 02             	lea    0x2(%ecx),%edx
        overload = options[offset++];
  80289f:	83 c1 03             	add    $0x3,%ecx
  8028a2:	0f b7 d2             	movzwl %dx,%edx
  8028a5:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
  8028a9:	88 5d ef             	mov    %bl,-0x11(%ebp)
  8028ac:	eb 0e                	jmp    8028bc <dhcp_get_option_ptr+0x56>
        offset++;
  8028ae:	8d 51 01             	lea    0x1(%ecx),%edx
        offset += 1 + options[offset];
  8028b1:	0f b7 d2             	movzwl %dx,%edx
  8028b4:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  8028b8:	8d 4c 0a 02          	lea    0x2(%edx,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8028bc:	66 39 cf             	cmp    %cx,%di
  8028bf:	76 22                	jbe    8028e3 <dhcp_get_option_ptr+0x7d>
  8028c1:	0f b7 d9             	movzwl %cx,%ebx
  8028c4:	01 c3                	add    %eax,%ebx
  8028c6:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  8028c9:	0f b6 13             	movzbl (%ebx),%edx
  8028cc:	80 fa ff             	cmp    $0xff,%dl
  8028cf:	74 12                	je     8028e3 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8028d1:	80 fa 34             	cmp    $0x34,%dl
  8028d4:	74 c6                	je     80289c <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  8028d6:	89 f3                	mov    %esi,%ebx
  8028d8:	38 da                	cmp    %bl,%dl
  8028da:	75 d2                	jne    8028ae <dhcp_get_option_ptr+0x48>
  8028dc:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8028df:	89 d8                	mov    %ebx,%eax
  8028e1:	eb b1                	jmp    802894 <dhcp_get_option_ptr+0x2e>
  return NULL;
  8028e3:	b8 00 00 00 00       	mov    $0x0,%eax
    if (overload != DHCP_OVERLOAD_NONE) {
  8028e8:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  8028ec:	84 c9                	test   %cl,%cl
  8028ee:	74 a4                	je     802894 <dhcp_get_option_ptr+0x2e>
      if (overload == DHCP_OVERLOAD_FILE) {
  8028f0:	80 f9 01             	cmp    $0x1,%cl
  8028f3:	74 55                	je     80294a <dhcp_get_option_ptr+0xe4>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8028f5:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8028f9:	74 5f                	je     80295a <dhcp_get_option_ptr+0xf4>
        options = (u8_t *)&dhcp->msg_in->sname;
  8028fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8028fe:	8b 48 10             	mov    0x10(%eax),%ecx
  802901:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802904:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  802909:	ba 00 00 00 00       	mov    $0x0,%edx
  80290e:	89 f0                	mov    %esi,%eax
  802910:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802913:	0f b7 c2             	movzwl %dx,%eax
  802916:	01 c8                	add    %ecx,%eax
  802918:	0f b6 30             	movzbl (%eax),%esi
  80291b:	89 f3                	mov    %esi,%ebx
  80291d:	80 fb ff             	cmp    $0xff,%bl
  802920:	74 48                	je     80296a <dhcp_get_option_ptr+0x104>
        if (options[offset] == option_type) {
  802922:	89 f3                	mov    %esi,%ebx
  802924:	3a 5d f0             	cmp    -0x10(%ebp),%bl
  802927:	0f 84 67 ff ff ff    	je     802894 <dhcp_get_option_ptr+0x2e>
          offset++;
  80292d:	8d 42 01             	lea    0x1(%edx),%eax
          offset += 1 + options[offset];
  802930:	0f b7 c0             	movzwl %ax,%eax
  802933:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  802937:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80293b:	66 39 d7             	cmp    %dx,%di
  80293e:	77 d3                	ja     802913 <dhcp_get_option_ptr+0xad>
  return NULL;
  802940:	b8 00 00 00 00       	mov    $0x0,%eax
  802945:	e9 4a ff ff ff       	jmp    802894 <dhcp_get_option_ptr+0x2e>
        options = (u8_t *)&dhcp->msg_in->file;
  80294a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80294d:	8b 48 10             	mov    0x10(%eax),%ecx
  802950:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  802953:	bf 80 00 00 00       	mov    $0x80,%edi
  802958:	eb af                	jmp    802909 <dhcp_get_option_ptr+0xa3>
        options = (u8_t *)&dhcp->msg_in->sname;
  80295a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80295d:	8b 48 10             	mov    0x10(%eax),%ecx
  802960:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  802963:	bf 40 00 00 00       	mov    $0x40,%edi
  802968:	eb 9f                	jmp    802909 <dhcp_get_option_ptr+0xa3>
  return NULL;
  80296a:	b8 00 00 00 00       	mov    $0x0,%eax
  80296f:	e9 20 ff ff ff       	jmp    802894 <dhcp_get_option_ptr+0x2e>

00802974 <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802974:	0f b6 10             	movzbl (%eax),%edx
  802977:	89 d1                	mov    %edx,%ecx
  802979:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  80297c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802980:	c1 e2 10             	shl    $0x10,%edx
  802983:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802985:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802989:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  80298b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  80298f:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  802992:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802994:	c3                   	ret    

00802995 <dhcp_option_byte>:
{
  802995:	55                   	push   %ebp
  802996:	89 e5                	mov    %esp,%ebp
  802998:	56                   	push   %esi
  802999:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80299a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80299e:	66 83 f9 43          	cmp    $0x43,%cx
  8029a2:	77 1b                	ja     8029bf <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  8029a4:	8b 58 20             	mov    0x20(%eax),%ebx
  8029a7:	8d 71 01             	lea    0x1(%ecx),%esi
  8029aa:	66 89 70 24          	mov    %si,0x24(%eax)
  8029ae:	0f b7 c9             	movzwl %cx,%ecx
  8029b1:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  8029b8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8029bb:	5b                   	pop    %ebx
  8029bc:	5e                   	pop    %esi
  8029bd:	5d                   	pop    %ebp
  8029be:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029bf:	83 ec 04             	sub    $0x4,%esp
  8029c2:	68 94 18 81 00       	push   $0x811894
  8029c7:	68 65 04 00 00       	push   $0x465
  8029cc:	68 e2 1b 81 00       	push   $0x811be2
  8029d1:	e8 99 bd 00 00       	call   80e76f <_panic>

008029d6 <dhcp_option>:
{
  8029d6:	55                   	push   %ebp
  8029d7:	89 e5                	mov    %esp,%ebp
  8029d9:	57                   	push   %edi
  8029da:	56                   	push   %esi
  8029db:	53                   	push   %ebx
  8029dc:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8029df:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8029e3:	0f b6 f9             	movzbl %cl,%edi
  8029e6:	0f b7 f3             	movzwl %bx,%esi
  8029e9:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8029ed:	83 fe 44             	cmp    $0x44,%esi
  8029f0:	77 34                	ja     802a26 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8029f2:	8b 70 20             	mov    0x20(%eax),%esi
  8029f5:	8d 7b 01             	lea    0x1(%ebx),%edi
  8029f8:	66 89 78 24          	mov    %di,0x24(%eax)
  8029fc:	0f b7 db             	movzwl %bx,%ebx
  8029ff:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802a06:	8b 58 20             	mov    0x20(%eax),%ebx
  802a09:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a0d:	8d 72 01             	lea    0x1(%edx),%esi
  802a10:	66 89 70 24          	mov    %si,0x24(%eax)
  802a14:	0f b7 d2             	movzwl %dx,%edx
  802a17:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802a1e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802a21:	5b                   	pop    %ebx
  802a22:	5e                   	pop    %esi
  802a23:	5f                   	pop    %edi
  802a24:	5d                   	pop    %ebp
  802a25:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802a26:	83 ec 04             	sub    $0x4,%esp
  802a29:	68 d0 18 81 00       	push   $0x8118d0
  802a2e:	68 5a 04 00 00       	push   $0x45a
  802a33:	68 e2 1b 81 00       	push   $0x811be2
  802a38:	e8 32 bd 00 00       	call   80e76f <_panic>

00802a3d <dhcp_option_short>:
{
  802a3d:	55                   	push   %ebp
  802a3e:	89 e5                	mov    %esp,%ebp
  802a40:	56                   	push   %esi
  802a41:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802a42:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a46:	0f b7 d9             	movzwl %cx,%ebx
  802a49:	83 c3 02             	add    $0x2,%ebx
  802a4c:	83 fb 44             	cmp    $0x44,%ebx
  802a4f:	77 33                	ja     802a84 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802a51:	8b 58 20             	mov    0x20(%eax),%ebx
  802a54:	8d 71 01             	lea    0x1(%ecx),%esi
  802a57:	66 89 70 24          	mov    %si,0x24(%eax)
  802a5b:	0f b7 c9             	movzwl %cx,%ecx
  802a5e:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802a65:	8b 58 20             	mov    0x20(%eax),%ebx
  802a68:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a6c:	8d 71 01             	lea    0x1(%ecx),%esi
  802a6f:	66 89 70 24          	mov    %si,0x24(%eax)
  802a73:	0f b7 c9             	movzwl %cx,%ecx
  802a76:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a7d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a80:	5b                   	pop    %ebx
  802a81:	5e                   	pop    %esi
  802a82:	5d                   	pop    %ebp
  802a83:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802a84:	83 ec 04             	sub    $0x4,%esp
  802a87:	68 18 19 81 00       	push   $0x811918
  802a8c:	68 6c 04 00 00       	push   $0x46c
  802a91:	68 e2 1b 81 00       	push   $0x811be2
  802a96:	e8 d4 bc 00 00       	call   80e76f <_panic>

00802a9b <dhcp_option_trailer>:
{
  802a9b:	55                   	push   %ebp
  802a9c:	89 e5                	mov    %esp,%ebp
  802a9e:	53                   	push   %ebx
  802a9f:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802aa2:	85 c0                	test   %eax,%eax
  802aa4:	74 25                	je     802acb <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802aa6:	8b 48 20             	mov    0x20(%eax),%ecx
  802aa9:	85 c9                	test   %ecx,%ecx
  802aab:	74 35                	je     802ae2 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aad:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ab1:	66 83 fa 43          	cmp    $0x43,%dx
  802ab5:	77 42                	ja     802af9 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802ab7:	8d 5a 01             	lea    0x1(%edx),%ebx
  802aba:	66 89 58 24          	mov    %bx,0x24(%eax)
  802abe:	0f b7 d2             	movzwl %dx,%edx
  802ac1:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802ac8:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802ac9:	eb 5a                	jmp    802b25 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802acb:	83 ec 04             	sub    $0x4,%esp
  802ace:	68 5c 19 81 00       	push   $0x81195c
  802ad3:	68 80 05 00 00       	push   $0x580
  802ad8:	68 e2 1b 81 00       	push   $0x811be2
  802add:	e8 8d bc 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802ae2:	83 ec 04             	sub    $0x4,%esp
  802ae5:	68 80 19 81 00       	push   $0x811980
  802aea:	68 81 05 00 00       	push   $0x581
  802aef:	68 e2 1b 81 00       	push   $0x811be2
  802af4:	e8 76 bc 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802af9:	83 ec 04             	sub    $0x4,%esp
  802afc:	68 ac 19 81 00       	push   $0x8119ac
  802b01:	68 82 05 00 00       	push   $0x582
  802b06:	68 e2 1b 81 00       	push   $0x811be2
  802b0b:	e8 5f bc 00 00       	call   80e76f <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802b10:	8b 48 20             	mov    0x20(%eax),%ecx
  802b13:	8d 5a 01             	lea    0x1(%edx),%ebx
  802b16:	66 89 58 24          	mov    %bx,0x24(%eax)
  802b1a:	0f b7 d2             	movzwl %dx,%edx
  802b1d:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802b24:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802b25:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802b29:	66 83 fa 43          	cmp    $0x43,%dx
  802b2d:	76 e1                	jbe    802b10 <dhcp_option_trailer+0x75>
  802b2f:	f6 c2 03             	test   $0x3,%dl
  802b32:	74 17                	je     802b4b <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802b34:	83 ec 04             	sub    $0x4,%esp
  802b37:	68 ac 19 81 00       	push   $0x8119ac
  802b3c:	68 87 05 00 00       	push   $0x587
  802b41:	68 e2 1b 81 00       	push   $0x811be2
  802b46:	e8 24 bc 00 00       	call   80e76f <_panic>
}
  802b4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802b4e:	c9                   	leave  
  802b4f:	c3                   	ret    

00802b50 <dhcp_option_long>:
{
  802b50:	55                   	push   %ebp
  802b51:	89 e5                	mov    %esp,%ebp
  802b53:	56                   	push   %esi
  802b54:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802b55:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b59:	0f b7 d9             	movzwl %cx,%ebx
  802b5c:	83 c3 04             	add    $0x4,%ebx
  802b5f:	83 fb 44             	cmp    $0x44,%ebx
  802b62:	77 6d                	ja     802bd1 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802b64:	8d 71 01             	lea    0x1(%ecx),%esi
  802b67:	66 89 70 24          	mov    %si,0x24(%eax)
  802b6b:	0f b7 c9             	movzwl %cx,%ecx
  802b6e:	89 d3                	mov    %edx,%ebx
  802b70:	c1 eb 18             	shr    $0x18,%ebx
  802b73:	8b 70 20             	mov    0x20(%eax),%esi
  802b76:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b7d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b81:	8d 71 01             	lea    0x1(%ecx),%esi
  802b84:	66 89 70 24          	mov    %si,0x24(%eax)
  802b88:	0f b7 c9             	movzwl %cx,%ecx
  802b8b:	89 d3                	mov    %edx,%ebx
  802b8d:	c1 eb 10             	shr    $0x10,%ebx
  802b90:	8b 70 20             	mov    0x20(%eax),%esi
  802b93:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b9a:	8b 58 20             	mov    0x20(%eax),%ebx
  802b9d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ba1:	8d 71 01             	lea    0x1(%ecx),%esi
  802ba4:	66 89 70 24          	mov    %si,0x24(%eax)
  802ba8:	0f b7 c9             	movzwl %cx,%ecx
  802bab:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802bb2:	8b 58 20             	mov    0x20(%eax),%ebx
  802bb5:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802bb9:	8d 71 01             	lea    0x1(%ecx),%esi
  802bbc:	66 89 70 24          	mov    %si,0x24(%eax)
  802bc0:	0f b7 c9             	movzwl %cx,%ecx
  802bc3:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802bca:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802bcd:	5b                   	pop    %ebx
  802bce:	5e                   	pop    %esi
  802bcf:	5d                   	pop    %ebp
  802bd0:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802bd1:	83 ec 04             	sub    $0x4,%esp
  802bd4:	68 ec 19 81 00       	push   $0x8119ec
  802bd9:	68 74 04 00 00       	push   $0x474
  802bde:	68 e2 1b 81 00       	push   $0x811be2
  802be3:	e8 87 bb 00 00       	call   80e76f <_panic>

00802be8 <dhcp_create_request>:
{
  802be8:	55                   	push   %ebp
  802be9:	89 e5                	mov    %esp,%ebp
  802beb:	57                   	push   %edi
  802bec:	56                   	push   %esi
  802bed:	53                   	push   %ebx
  802bee:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802bf1:	85 c0                	test   %eax,%eax
  802bf3:	0f 84 d8 00 00 00    	je     802cd1 <dhcp_create_request+0xe9>
  802bf9:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802bfb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bfe:	85 db                	test   %ebx,%ebx
  802c00:	0f 84 e2 00 00 00    	je     802ce8 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802c06:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802c0a:	0f 85 ef 00 00 00    	jne    802cff <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802c10:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802c14:	0f 85 fc 00 00 00    	jne    802d16 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802c1a:	83 ec 04             	sub    $0x4,%esp
  802c1d:	6a 00                	push   $0x0
  802c1f:	68 34 01 00 00       	push   $0x134
  802c24:	6a 00                	push   $0x0
  802c26:	e8 9f 1d 00 00       	call   8049ca <pbuf_alloc>
  802c2b:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802c2e:	83 c4 10             	add    $0x10,%esp
  802c31:	85 c0                	test   %eax,%eax
  802c33:	0f 84 9b 01 00 00    	je     802dd4 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c39:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802c3f:	0f 86 e8 00 00 00    	jbe    802d2d <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802c45:	8b 15 04 50 81 00    	mov    0x815004,%edx
  802c4b:	8d 4a 01             	lea    0x1(%edx),%ecx
  802c4e:	89 0d 04 50 81 00    	mov    %ecx,0x815004
  802c54:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802c57:	8b 40 04             	mov    0x4(%eax),%eax
  802c5a:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802c5d:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802c60:	8b 43 20             	mov    0x20(%ebx),%eax
  802c63:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802c67:	8b 43 20             	mov    0x20(%ebx),%eax
  802c6a:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802c6e:	8b 43 20             	mov    0x20(%ebx),%eax
  802c71:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802c75:	8b 7b 20             	mov    0x20(%ebx),%edi
  802c78:	83 ec 0c             	sub    $0xc,%esp
  802c7b:	ff 73 04             	pushl  0x4(%ebx)
  802c7e:	e8 75 4b 00 00       	call   8077f8 <htonl>
  802c83:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802c86:	8b 43 20             	mov    0x20(%ebx),%eax
  802c89:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c8f:	8b 43 20             	mov    0x20(%ebx),%eax
  802c92:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c98:	8b 43 20             	mov    0x20(%ebx),%eax
  802c9b:	8b 56 04             	mov    0x4(%esi),%edx
  802c9e:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802ca1:	8b 43 20             	mov    0x20(%ebx),%eax
  802ca4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802cab:	8b 43 20             	mov    0x20(%ebx),%eax
  802cae:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802cb5:	8b 43 20             	mov    0x20(%ebx),%eax
  802cb8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802cbf:	83 c4 10             	add    $0x10,%esp
  802cc2:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cc7:	bf 00 00 00 00       	mov    $0x0,%edi
  802ccc:	e9 82 00 00 00       	jmp    802d53 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802cd1:	83 ec 04             	sub    $0x4,%esp
  802cd4:	68 2c 1a 81 00       	push   $0x811a2c
  802cd9:	68 2d 05 00 00       	push   $0x52d
  802cde:	68 e2 1b 81 00       	push   $0x811be2
  802ce3:	e8 87 ba 00 00       	call   80e76f <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802ce8:	83 ec 04             	sub    $0x4,%esp
  802ceb:	68 50 1a 81 00       	push   $0x811a50
  802cf0:	68 2f 05 00 00       	push   $0x52f
  802cf5:	68 e2 1b 81 00       	push   $0x811be2
  802cfa:	e8 70 ba 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802cff:	83 ec 04             	sub    $0x4,%esp
  802d02:	68 74 1a 81 00       	push   $0x811a74
  802d07:	68 30 05 00 00       	push   $0x530
  802d0c:	68 e2 1b 81 00       	push   $0x811be2
  802d11:	e8 59 ba 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802d16:	83 ec 04             	sub    $0x4,%esp
  802d19:	68 a0 1a 81 00       	push   $0x811aa0
  802d1e:	68 31 05 00 00       	push   $0x531
  802d23:	68 e2 1b 81 00       	push   $0x811be2
  802d28:	e8 42 ba 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802d2d:	83 ec 04             	sub    $0x4,%esp
  802d30:	68 cc 1a 81 00       	push   $0x811acc
  802d35:	68 38 05 00 00       	push   $0x538
  802d3a:	68 e2 1b 81 00       	push   $0x811be2
  802d3f:	e8 2b ba 00 00       	call   80e76f <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d44:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802d47:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802d4b:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802d4e:	83 f8 10             	cmp    $0x10,%eax
  802d51:	74 12                	je     802d65 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802d53:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802d57:	89 fa                	mov    %edi,%edx
  802d59:	66 39 c1             	cmp    %ax,%cx
  802d5c:	76 e6                	jbe    802d44 <dhcp_create_request+0x15c>
  802d5e:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802d63:	eb df                	jmp    802d44 <dhcp_create_request+0x15c>
  802d65:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802d6a:	8b 53 20             	mov    0x20(%ebx),%edx
  802d6d:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802d72:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802d75:	83 f8 40             	cmp    $0x40,%eax
  802d78:	75 f0                	jne    802d6a <dhcp_create_request+0x182>
  802d7a:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802d7f:	8b 53 20             	mov    0x20(%ebx),%edx
  802d82:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802d87:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802d8a:	3d 80 00 00 00       	cmp    $0x80,%eax
  802d8f:	75 ee                	jne    802d7f <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802d91:	8b 73 20             	mov    0x20(%ebx),%esi
  802d94:	83 ec 0c             	sub    $0xc,%esp
  802d97:	68 63 53 82 63       	push   $0x63825363
  802d9c:	e8 57 4a 00 00       	call   8077f8 <htonl>
  802da1:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802da7:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802dad:	83 c4 10             	add    $0x10,%esp
  802db0:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802db5:	8b 53 20             	mov    0x20(%ebx),%edx
  802db8:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802dbf:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802dc2:	83 f8 44             	cmp    $0x44,%eax
  802dc5:	75 ee                	jne    802db5 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802dc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802dcc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802dcf:	5b                   	pop    %ebx
  802dd0:	5e                   	pop    %esi
  802dd1:	5f                   	pop    %edi
  802dd2:	5d                   	pop    %ebp
  802dd3:	c3                   	ret    
    return ERR_MEM;
  802dd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802dd9:	eb f1                	jmp    802dcc <dhcp_create_request+0x1e4>

00802ddb <dhcp_delete_request>:
{
  802ddb:	55                   	push   %ebp
  802ddc:	89 e5                	mov    %esp,%ebp
  802dde:	53                   	push   %ebx
  802ddf:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802de2:	85 c0                	test   %eax,%eax
  802de4:	74 33                	je     802e19 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802de6:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802de9:	85 db                	test   %ebx,%ebx
  802deb:	74 43                	je     802e30 <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ded:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802df0:	85 c0                	test   %eax,%eax
  802df2:	74 53                	je     802e47 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802df4:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802df8:	74 64                	je     802e5e <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802dfa:	83 ec 0c             	sub    $0xc,%esp
  802dfd:	50                   	push   %eax
  802dfe:	e8 01 1b 00 00       	call   804904 <pbuf_free>
  dhcp->p_out = NULL;
  802e03:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802e0a:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802e11:	83 c4 10             	add    $0x10,%esp
}
  802e14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802e17:	c9                   	leave  
  802e18:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802e19:	83 ec 04             	sub    $0x4,%esp
  802e1c:	68 10 1b 81 00       	push   $0x811b10
  802e21:	68 69 05 00 00       	push   $0x569
  802e26:	68 e2 1b 81 00       	push   $0x811be2
  802e2b:	e8 3f b9 00 00       	call   80e76f <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802e30:	83 ec 04             	sub    $0x4,%esp
  802e33:	68 34 1b 81 00       	push   $0x811b34
  802e38:	68 6b 05 00 00       	push   $0x56b
  802e3d:	68 e2 1b 81 00       	push   $0x811be2
  802e42:	e8 28 b9 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802e47:	83 ec 04             	sub    $0x4,%esp
  802e4a:	68 58 1b 81 00       	push   $0x811b58
  802e4f:	68 6c 05 00 00       	push   $0x56c
  802e54:	68 e2 1b 81 00       	push   $0x811be2
  802e59:	e8 11 b9 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802e5e:	83 ec 04             	sub    $0x4,%esp
  802e61:	68 84 1b 81 00       	push   $0x811b84
  802e66:	68 6d 05 00 00       	push   $0x56d
  802e6b:	68 e2 1b 81 00       	push   $0x811be2
  802e70:	e8 fa b8 00 00       	call   80e76f <_panic>

00802e75 <dhcp_rebind>:
{
  802e75:	55                   	push   %ebp
  802e76:	89 e5                	mov    %esp,%ebp
  802e78:	57                   	push   %edi
  802e79:	56                   	push   %esi
  802e7a:	53                   	push   %ebx
  802e7b:	83 ec 0c             	sub    $0xc,%esp
  802e7e:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e80:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802e83:	ba 04 00 00 00       	mov    $0x4,%edx
  802e88:	89 d8                	mov    %ebx,%eax
  802e8a:	e8 cc f9 ff ff       	call   80285b <dhcp_set_state>
  result = dhcp_create_request(netif);
  802e8f:	89 f8                	mov    %edi,%eax
  802e91:	e8 52 fd ff ff       	call   802be8 <dhcp_create_request>
  802e96:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e98:	84 c0                	test   %al,%al
  802e9a:	74 3e                	je     802eda <dhcp_rebind+0x65>
  dhcp->tries++;
  802e9c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802ea0:	83 c0 01             	add    $0x1,%eax
  802ea3:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802ea6:	ba 10 27 00 00       	mov    $0x2710,%edx
  802eab:	3c 09                	cmp    $0x9,%al
  802ead:	77 08                	ja     802eb7 <dhcp_rebind+0x42>
  802eaf:	0f b6 d0             	movzbl %al,%edx
  802eb2:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802eb7:	0f b7 d2             	movzwl %dx,%edx
  802eba:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802ec0:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802ec5:	89 d0                	mov    %edx,%eax
  802ec7:	f7 e9                	imul   %ecx
  802ec9:	c1 fa 05             	sar    $0x5,%edx
  802ecc:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802ed0:	89 f0                	mov    %esi,%eax
  802ed2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ed5:	5b                   	pop    %ebx
  802ed6:	5e                   	pop    %esi
  802ed7:	5f                   	pop    %edi
  802ed8:	5d                   	pop    %ebp
  802ed9:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802eda:	b9 01 00 00 00       	mov    $0x1,%ecx
  802edf:	ba 35 00 00 00       	mov    $0x35,%edx
  802ee4:	89 d8                	mov    %ebx,%eax
  802ee6:	e8 eb fa ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802eeb:	ba 03 00 00 00       	mov    $0x3,%edx
  802ef0:	89 d8                	mov    %ebx,%eax
  802ef2:	e8 9e fa ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ef7:	b9 02 00 00 00       	mov    $0x2,%ecx
  802efc:	ba 39 00 00 00       	mov    $0x39,%edx
  802f01:	89 d8                	mov    %ebx,%eax
  802f03:	e8 ce fa ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f08:	ba 40 02 00 00       	mov    $0x240,%edx
  802f0d:	89 d8                	mov    %ebx,%eax
  802f0f:	e8 29 fb ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802f14:	89 d8                	mov    %ebx,%eax
  802f16:	e8 80 fb ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f1b:	83 ec 08             	sub    $0x8,%esp
  802f1e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f22:	66 05 f0 00          	add    $0xf0,%ax
  802f26:	0f b7 c0             	movzwl %ax,%eax
  802f29:	50                   	push   %eax
  802f2a:	ff 73 1c             	pushl  0x1c(%ebx)
  802f2d:	e8 0a 1d 00 00       	call   804c3c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802f32:	83 c4 0c             	add    $0xc,%esp
  802f35:	6a 43                	push   $0x43
  802f37:	68 88 24 81 00       	push   $0x812488
  802f3c:	ff 73 08             	pushl  0x8(%ebx)
  802f3f:	e8 ad 60 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f44:	89 3c 24             	mov    %edi,(%esp)
  802f47:	6a 43                	push   $0x43
  802f49:	68 84 24 81 00       	push   $0x812484
  802f4e:	ff 73 1c             	pushl  0x1c(%ebx)
  802f51:	ff 73 08             	pushl  0x8(%ebx)
  802f54:	e8 a3 5e 00 00       	call   808dfc <udp_sendto_if>
    dhcp_delete_request(netif);
  802f59:	83 c4 20             	add    $0x20,%esp
  802f5c:	89 f8                	mov    %edi,%eax
  802f5e:	e8 78 fe ff ff       	call   802ddb <dhcp_delete_request>
  802f63:	e9 34 ff ff ff       	jmp    802e9c <dhcp_rebind+0x27>

00802f68 <dhcp_discover>:
{
  802f68:	55                   	push   %ebp
  802f69:	89 e5                	mov    %esp,%ebp
  802f6b:	57                   	push   %edi
  802f6c:	56                   	push   %esi
  802f6d:	53                   	push   %ebx
  802f6e:	83 ec 0c             	sub    $0xc,%esp
  802f71:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f73:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802f76:	a1 88 24 81 00       	mov    0x812488,%eax
  802f7b:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802f7e:	89 f8                	mov    %edi,%eax
  802f80:	e8 63 fc ff ff       	call   802be8 <dhcp_create_request>
  802f85:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f87:	84 c0                	test   %al,%al
  802f89:	74 41                	je     802fcc <dhcp_discover+0x64>
  dhcp->tries++;
  802f8b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f8f:	83 c0 01             	add    $0x1,%eax
  802f92:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802f95:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f9a:	3c 03                	cmp    $0x3,%al
  802f9c:	77 0b                	ja     802fa9 <dhcp_discover+0x41>
  802f9e:	0f b6 d0             	movzbl %al,%edx
  802fa1:	83 c2 01             	add    $0x1,%edx
  802fa4:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fa9:	0f b7 d2             	movzwl %dx,%edx
  802fac:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802fb2:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802fb7:	89 d0                	mov    %edx,%eax
  802fb9:	f7 e9                	imul   %ecx
  802fbb:	c1 fa 05             	sar    $0x5,%edx
  802fbe:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802fc2:	89 f0                	mov    %esi,%eax
  802fc4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802fc7:	5b                   	pop    %ebx
  802fc8:	5e                   	pop    %esi
  802fc9:	5f                   	pop    %edi
  802fca:	5d                   	pop    %ebp
  802fcb:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802fcc:	b9 01 00 00 00       	mov    $0x1,%ecx
  802fd1:	ba 35 00 00 00       	mov    $0x35,%edx
  802fd6:	89 d8                	mov    %ebx,%eax
  802fd8:	e8 f9 f9 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802fdd:	ba 01 00 00 00       	mov    $0x1,%edx
  802fe2:	89 d8                	mov    %ebx,%eax
  802fe4:	e8 ac f9 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802fe9:	b9 02 00 00 00       	mov    $0x2,%ecx
  802fee:	ba 39 00 00 00       	mov    $0x39,%edx
  802ff3:	89 d8                	mov    %ebx,%eax
  802ff5:	e8 dc f9 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ffa:	ba 40 02 00 00       	mov    $0x240,%edx
  802fff:	89 d8                	mov    %ebx,%eax
  803001:	e8 37 fa ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803006:	b9 04 00 00 00       	mov    $0x4,%ecx
  80300b:	ba 37 00 00 00       	mov    $0x37,%edx
  803010:	89 d8                	mov    %ebx,%eax
  803012:	e8 bf f9 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803017:	ba 01 00 00 00       	mov    $0x1,%edx
  80301c:	89 d8                	mov    %ebx,%eax
  80301e:	e8 72 f9 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803023:	ba 03 00 00 00       	mov    $0x3,%edx
  803028:	89 d8                	mov    %ebx,%eax
  80302a:	e8 66 f9 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80302f:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803034:	89 d8                	mov    %ebx,%eax
  803036:	e8 5a f9 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80303b:	ba 06 00 00 00       	mov    $0x6,%edx
  803040:	89 d8                	mov    %ebx,%eax
  803042:	e8 4e f9 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803047:	89 d8                	mov    %ebx,%eax
  803049:	e8 4d fa ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80304e:	83 ec 08             	sub    $0x8,%esp
  803051:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803055:	66 05 f0 00          	add    $0xf0,%ax
  803059:	0f b7 c0             	movzwl %ax,%eax
  80305c:	50                   	push   %eax
  80305d:	ff 73 1c             	pushl  0x1c(%ebx)
  803060:	e8 d7 1b 00 00       	call   804c3c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803065:	83 c4 0c             	add    $0xc,%esp
  803068:	6a 43                	push   $0x43
  80306a:	68 88 24 81 00       	push   $0x812488
  80306f:	ff 73 08             	pushl  0x8(%ebx)
  803072:	e8 7a 5f 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803077:	89 3c 24             	mov    %edi,(%esp)
  80307a:	6a 43                	push   $0x43
  80307c:	68 84 24 81 00       	push   $0x812484
  803081:	ff 73 1c             	pushl  0x1c(%ebx)
  803084:	ff 73 08             	pushl  0x8(%ebx)
  803087:	e8 70 5d 00 00       	call   808dfc <udp_sendto_if>
    dhcp_delete_request(netif);
  80308c:	83 c4 20             	add    $0x20,%esp
  80308f:	89 f8                	mov    %edi,%eax
  803091:	e8 45 fd ff ff       	call   802ddb <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  803096:	ba 06 00 00 00       	mov    $0x6,%edx
  80309b:	89 d8                	mov    %ebx,%eax
  80309d:	e8 b9 f7 ff ff       	call   80285b <dhcp_set_state>
  8030a2:	e9 e4 fe ff ff       	jmp    802f8b <dhcp_discover+0x23>

008030a7 <dhcp_select>:
{
  8030a7:	55                   	push   %ebp
  8030a8:	89 e5                	mov    %esp,%ebp
  8030aa:	57                   	push   %edi
  8030ab:	56                   	push   %esi
  8030ac:	53                   	push   %ebx
  8030ad:	83 ec 0c             	sub    $0xc,%esp
  8030b0:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8030b2:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  8030b5:	e8 2e fb ff ff       	call   802be8 <dhcp_create_request>
  8030ba:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8030bc:	84 c0                	test   %al,%al
  8030be:	74 3e                	je     8030fe <dhcp_select+0x57>
  dhcp->tries++;
  8030c0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8030c4:	83 c0 01             	add    $0x1,%eax
  8030c7:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8030ca:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8030cf:	3c 03                	cmp    $0x3,%al
  8030d1:	77 08                	ja     8030db <dhcp_select+0x34>
  8030d3:	0f b6 d0             	movzbl %al,%edx
  8030d6:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8030db:	0f b7 d2             	movzwl %dx,%edx
  8030de:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8030e4:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8030e9:	89 d0                	mov    %edx,%eax
  8030eb:	f7 e9                	imul   %ecx
  8030ed:	c1 fa 05             	sar    $0x5,%edx
  8030f0:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8030f4:	89 f0                	mov    %esi,%eax
  8030f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8030f9:	5b                   	pop    %ebx
  8030fa:	5e                   	pop    %esi
  8030fb:	5f                   	pop    %edi
  8030fc:	5d                   	pop    %ebp
  8030fd:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8030fe:	b9 01 00 00 00       	mov    $0x1,%ecx
  803103:	ba 35 00 00 00       	mov    $0x35,%edx
  803108:	89 d8                	mov    %ebx,%eax
  80310a:	e8 c7 f8 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80310f:	ba 03 00 00 00       	mov    $0x3,%edx
  803114:	89 d8                	mov    %ebx,%eax
  803116:	e8 7a f8 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80311b:	b9 02 00 00 00       	mov    $0x2,%ecx
  803120:	ba 39 00 00 00       	mov    $0x39,%edx
  803125:	89 d8                	mov    %ebx,%eax
  803127:	e8 aa f8 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80312c:	ba 40 02 00 00       	mov    $0x240,%edx
  803131:	89 d8                	mov    %ebx,%eax
  803133:	e8 05 f9 ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803138:	b9 04 00 00 00       	mov    $0x4,%ecx
  80313d:	ba 32 00 00 00       	mov    $0x32,%edx
  803142:	89 d8                	mov    %ebx,%eax
  803144:	e8 8d f8 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803149:	83 ec 0c             	sub    $0xc,%esp
  80314c:	ff 73 30             	pushl  0x30(%ebx)
  80314f:	e8 bb 48 00 00       	call   807a0f <ntohl>
  803154:	89 c2                	mov    %eax,%edx
  803156:	89 d8                	mov    %ebx,%eax
  803158:	e8 f3 f9 ff ff       	call   802b50 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80315d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803162:	ba 36 00 00 00       	mov    $0x36,%edx
  803167:	89 d8                	mov    %ebx,%eax
  803169:	e8 68 f8 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80316e:	83 c4 04             	add    $0x4,%esp
  803171:	ff 73 2c             	pushl  0x2c(%ebx)
  803174:	e8 96 48 00 00       	call   807a0f <ntohl>
  803179:	89 c2                	mov    %eax,%edx
  80317b:	89 d8                	mov    %ebx,%eax
  80317d:	e8 ce f9 ff ff       	call   802b50 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803182:	b9 04 00 00 00       	mov    $0x4,%ecx
  803187:	ba 37 00 00 00       	mov    $0x37,%edx
  80318c:	89 d8                	mov    %ebx,%eax
  80318e:	e8 43 f8 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803193:	ba 01 00 00 00       	mov    $0x1,%edx
  803198:	89 d8                	mov    %ebx,%eax
  80319a:	e8 f6 f7 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80319f:	ba 03 00 00 00       	mov    $0x3,%edx
  8031a4:	89 d8                	mov    %ebx,%eax
  8031a6:	e8 ea f7 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8031ab:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8031b0:	89 d8                	mov    %ebx,%eax
  8031b2:	e8 de f7 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8031b7:	ba 06 00 00 00       	mov    $0x6,%edx
  8031bc:	89 d8                	mov    %ebx,%eax
  8031be:	e8 d2 f7 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  8031c3:	89 d8                	mov    %ebx,%eax
  8031c5:	e8 d1 f8 ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8031ca:	83 c4 08             	add    $0x8,%esp
  8031cd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8031d1:	66 05 f0 00          	add    $0xf0,%ax
  8031d5:	0f b7 c0             	movzwl %ax,%eax
  8031d8:	50                   	push   %eax
  8031d9:	ff 73 1c             	pushl  0x1c(%ebx)
  8031dc:	e8 5b 1a 00 00       	call   804c3c <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8031e1:	89 3c 24             	mov    %edi,(%esp)
  8031e4:	6a 43                	push   $0x43
  8031e6:	68 84 24 81 00       	push   $0x812484
  8031eb:	ff 73 1c             	pushl  0x1c(%ebx)
  8031ee:	ff 73 08             	pushl  0x8(%ebx)
  8031f1:	e8 06 5c 00 00       	call   808dfc <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8031f6:	83 c4 1c             	add    $0x1c,%esp
  8031f9:	6a 43                	push   $0x43
  8031fb:	68 88 24 81 00       	push   $0x812488
  803200:	ff 73 08             	pushl  0x8(%ebx)
  803203:	e8 e9 5d 00 00       	call   808ff1 <udp_connect>
    dhcp_delete_request(netif);
  803208:	89 f8                	mov    %edi,%eax
  80320a:	e8 cc fb ff ff       	call   802ddb <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80320f:	ba 01 00 00 00       	mov    $0x1,%edx
  803214:	89 d8                	mov    %ebx,%eax
  803216:	e8 40 f6 ff ff       	call   80285b <dhcp_set_state>
  80321b:	83 c4 10             	add    $0x10,%esp
  80321e:	e9 9d fe ff ff       	jmp    8030c0 <dhcp_select+0x19>

00803223 <dhcp_check>:
{
  803223:	55                   	push   %ebp
  803224:	89 e5                	mov    %esp,%ebp
  803226:	53                   	push   %ebx
  803227:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  80322a:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80322d:	6a 00                	push   $0x0
  80322f:	8d 53 30             	lea    0x30(%ebx),%edx
  803232:	52                   	push   %edx
  803233:	50                   	push   %eax
  803234:	e8 ac 67 00 00       	call   8099e5 <etharp_query>
  dhcp->tries++;
  803239:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80323d:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803243:	ba 08 00 00 00       	mov    $0x8,%edx
  803248:	89 d8                	mov    %ebx,%eax
  80324a:	e8 0c f6 ff ff       	call   80285b <dhcp_set_state>
}
  80324f:	83 c4 10             	add    $0x10,%esp
  803252:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803255:	c9                   	leave  
  803256:	c3                   	ret    

00803257 <dhcp_bind>:
{
  803257:	55                   	push   %ebp
  803258:	89 e5                	mov    %esp,%ebp
  80325a:	56                   	push   %esi
  80325b:	53                   	push   %ebx
  80325c:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80325f:	85 c0                	test   %eax,%eax
  803261:	0f 84 cf 00 00 00    	je     803336 <dhcp_bind+0xdf>
  803267:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803269:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80326c:	85 db                	test   %ebx,%ebx
  80326e:	0f 84 d9 00 00 00    	je     80334d <dhcp_bind+0xf6>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803274:	8b 53 50             	mov    0x50(%ebx),%edx
  803277:	83 fa ff             	cmp    $0xffffffff,%edx
  80327a:	74 2a                	je     8032a6 <dhcp_bind+0x4f>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80327c:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80327f:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803285:	0f 87 74 01 00 00    	ja     8033ff <dhcp_bind+0x1a8>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80328b:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803290:	89 d0                	mov    %edx,%eax
  803292:	f7 e1                	mul    %ecx
  803294:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t1_timeout == 0) {
  803297:	66 85 d2             	test   %dx,%dx
  80329a:	0f 85 c4 00 00 00    	jne    803364 <dhcp_bind+0x10d>
      dhcp->t1_timeout = 1;
  8032a0:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  8032a6:	8b 53 54             	mov    0x54(%ebx),%edx
  8032a9:	83 fa ff             	cmp    $0xffffffff,%edx
  8032ac:	74 2a                	je     8032d8 <dhcp_bind+0x81>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8032ae:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  8032b1:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  8032b7:	0f 87 37 01 00 00    	ja     8033f4 <dhcp_bind+0x19d>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8032bd:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8032c2:	89 d0                	mov    %edx,%eax
  8032c4:	f7 e1                	mul    %ecx
  8032c6:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t2_timeout == 0) {
  8032c9:	66 85 d2             	test   %dx,%dx
  8032cc:	0f 85 9b 00 00 00    	jne    80336d <dhcp_bind+0x116>
      dhcp->t2_timeout = 1;
  8032d2:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8032d8:	8b 43 34             	mov    0x34(%ebx),%eax
  8032db:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8032de:	85 c0                	test   %eax,%eax
  8032e0:	0f 84 90 00 00 00    	je     803376 <dhcp_bind+0x11f>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8032e6:	8b 43 38             	mov    0x38(%ebx),%eax
  8032e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8032ec:	85 c0                	test   %eax,%eax
  8032ee:	0f 84 e2 00 00 00    	je     8033d6 <dhcp_bind+0x17f>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8032f4:	83 ec 08             	sub    $0x8,%esp
  8032f7:	8d 43 30             	lea    0x30(%ebx),%eax
  8032fa:	50                   	push   %eax
  8032fb:	56                   	push   %esi
  8032fc:	e8 73 13 00 00       	call   804674 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  803301:	83 c4 08             	add    $0x8,%esp
  803304:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803307:	50                   	push   %eax
  803308:	56                   	push   %esi
  803309:	e8 ab 14 00 00       	call   8047b9 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  80330e:	83 c4 08             	add    $0x8,%esp
  803311:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803314:	50                   	push   %eax
  803315:	56                   	push   %esi
  803316:	e8 85 14 00 00       	call   8047a0 <netif_set_gw>
  netif_set_up(netif);
  80331b:	89 34 24             	mov    %esi,(%esp)
  80331e:	e8 bc 14 00 00       	call   8047df <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  803323:	ba 0a 00 00 00       	mov    $0xa,%edx
  803328:	89 d8                	mov    %ebx,%eax
  80332a:	e8 2c f5 ff ff       	call   80285b <dhcp_set_state>
}
  80332f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803332:	5b                   	pop    %ebx
  803333:	5e                   	pop    %esi
  803334:	5d                   	pop    %ebp
  803335:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803336:	83 ec 04             	sub    $0x4,%esp
  803339:	68 f7 1b 81 00       	push   $0x811bf7
  80333e:	68 3d 03 00 00       	push   $0x33d
  803343:	68 e2 1b 81 00       	push   $0x811be2
  803348:	e8 22 b4 00 00       	call   80e76f <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80334d:	83 ec 04             	sub    $0x4,%esp
  803350:	68 10 1c 81 00       	push   $0x811c10
  803355:	68 3f 03 00 00       	push   $0x33f
  80335a:	68 e2 1b 81 00       	push   $0x811be2
  80335f:	e8 0b b4 00 00       	call   80e76f <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803364:	66 89 53 28          	mov    %dx,0x28(%ebx)
  803368:	e9 39 ff ff ff       	jmp    8032a6 <dhcp_bind+0x4f>
    dhcp->t2_timeout = (u16_t)timeout;
  80336d:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  803371:	e9 62 ff ff ff       	jmp    8032d8 <dhcp_bind+0x81>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803376:	83 ec 0c             	sub    $0xc,%esp
  803379:	6a 00                	push   $0x0
  80337b:	e8 8f 46 00 00       	call   807a0f <ntohl>
  803380:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803383:	83 c4 10             	add    $0x10,%esp
  803386:	84 c0                	test   %al,%al
  803388:	79 1c                	jns    8033a6 <dhcp_bind+0x14f>
    } else if (first_octet >= 192) {
  80338a:	3c bf                	cmp    $0xbf,%al
  80338c:	76 30                	jbe    8033be <dhcp_bind+0x167>
      sn_mask.addr = htonl(0xffffff00);
  80338e:	83 ec 0c             	sub    $0xc,%esp
  803391:	68 00 ff ff ff       	push   $0xffffff00
  803396:	e8 5d 44 00 00       	call   8077f8 <htonl>
  80339b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80339e:	83 c4 10             	add    $0x10,%esp
  8033a1:	e9 40 ff ff ff       	jmp    8032e6 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xff000000);
  8033a6:	83 ec 0c             	sub    $0xc,%esp
  8033a9:	68 00 00 00 ff       	push   $0xff000000
  8033ae:	e8 45 44 00 00       	call   8077f8 <htonl>
  8033b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8033b6:	83 c4 10             	add    $0x10,%esp
  8033b9:	e9 28 ff ff ff       	jmp    8032e6 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xffff0000);
  8033be:	83 ec 0c             	sub    $0xc,%esp
  8033c1:	68 00 00 ff ff       	push   $0xffff0000
  8033c6:	e8 2d 44 00 00       	call   8077f8 <htonl>
  8033cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8033ce:	83 c4 10             	add    $0x10,%esp
  8033d1:	e9 10 ff ff ff       	jmp    8032e6 <dhcp_bind+0x8f>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8033d6:	8b 43 30             	mov    0x30(%ebx),%eax
  8033d9:	23 45 f4             	and    -0xc(%ebp),%eax
  8033dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8033df:	83 ec 0c             	sub    $0xc,%esp
  8033e2:	6a 01                	push   $0x1
  8033e4:	e8 0f 44 00 00       	call   8077f8 <htonl>
  8033e9:	09 45 f0             	or     %eax,-0x10(%ebp)
  8033ec:	83 c4 10             	add    $0x10,%esp
  8033ef:	e9 00 ff ff ff       	jmp    8032f4 <dhcp_bind+0x9d>
    dhcp->t2_timeout = (u16_t)timeout;
  8033f4:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8033fa:	e9 d9 fe ff ff       	jmp    8032d8 <dhcp_bind+0x81>
    dhcp->t1_timeout = (u16_t)timeout;
  8033ff:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  803405:	e9 9c fe ff ff       	jmp    8032a6 <dhcp_bind+0x4f>

0080340a <dhcp_free_reply>:
{
  80340a:	55                   	push   %ebp
  80340b:	89 e5                	mov    %esp,%ebp
  80340d:	53                   	push   %ebx
  80340e:	83 ec 04             	sub    $0x4,%esp
  803411:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803413:	8b 40 10             	mov    0x10(%eax),%eax
  803416:	85 c0                	test   %eax,%eax
  803418:	74 13                	je     80342d <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  80341a:	83 ec 0c             	sub    $0xc,%esp
  80341d:	50                   	push   %eax
  80341e:	e8 fb 0b 00 00       	call   80401e <mem_free>
    dhcp->msg_in = NULL;
  803423:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80342a:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  80342d:	8b 43 14             	mov    0x14(%ebx),%eax
  803430:	85 c0                	test   %eax,%eax
  803432:	74 19                	je     80344d <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803434:	83 ec 0c             	sub    $0xc,%esp
  803437:	50                   	push   %eax
  803438:	e8 e1 0b 00 00       	call   80401e <mem_free>
    dhcp->options_in = NULL;
  80343d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803444:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80344a:	83 c4 10             	add    $0x10,%esp
}
  80344d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803450:	c9                   	leave  
  803451:	c3                   	ret    

00803452 <dhcp_recv>:
{
  803452:	55                   	push   %ebp
  803453:	89 e5                	mov    %esp,%ebp
  803455:	57                   	push   %edi
  803456:	56                   	push   %esi
  803457:	53                   	push   %ebx
  803458:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  80345b:	8b 45 08             	mov    0x8(%ebp),%eax
  80345e:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803461:	8b 45 10             	mov    0x10(%ebp),%eax
  803464:	8b 70 04             	mov    0x4(%eax),%esi
  803467:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  80346a:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80346d:	80 3e 02             	cmpb   $0x2,(%esi)
  803470:	75 26                	jne    803498 <dhcp_recv+0x46>
  803472:	8b 45 08             	mov    0x8(%ebp),%eax
  803475:	83 c0 25             	add    $0x25,%eax
  803478:	8d 56 1c             	lea    0x1c(%esi),%edx
  80347b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80347e:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803482:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803484:	39 f0                	cmp    %esi,%eax
  803486:	74 2a                	je     8034b2 <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803488:	0f b6 18             	movzbl (%eax),%ebx
  80348b:	0f b6 0a             	movzbl (%edx),%ecx
  80348e:	83 c0 01             	add    $0x1,%eax
  803491:	83 c2 01             	add    $0x1,%edx
  803494:	38 cb                	cmp    %cl,%bl
  803496:	74 ec                	je     803484 <dhcp_recv+0x32>
  pbuf_free(p);
  803498:	83 ec 0c             	sub    $0xc,%esp
  80349b:	ff 75 10             	pushl  0x10(%ebp)
  80349e:	e8 61 14 00 00       	call   804904 <pbuf_free>
  dhcp->p = NULL;
  8034a3:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  8034aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8034ad:	5b                   	pop    %ebx
  8034ae:	5e                   	pop    %esi
  8034af:	5f                   	pop    %edi
  8034b0:	5d                   	pop    %ebp
  8034b1:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8034b2:	83 ec 0c             	sub    $0xc,%esp
  8034b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8034b8:	ff 70 04             	pushl  0x4(%eax)
  8034bb:	e8 4f 45 00 00       	call   807a0f <ntohl>
  8034c0:	83 c4 10             	add    $0x10,%esp
  8034c3:	3b 47 04             	cmp    0x4(%edi),%eax
  8034c6:	75 d0                	jne    803498 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8034c8:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  8034cc:	0f 84 20 01 00 00    	je     8035f2 <dhcp_recv+0x1a0>
  dhcp_free_reply(dhcp);
  8034d2:	89 f8                	mov    %edi,%eax
  8034d4:	e8 31 ff ff ff       	call   80340a <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8034d9:	8b 47 0c             	mov    0xc(%edi),%eax
  8034dc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8034e0:	66 3d f0 00          	cmp    $0xf0,%ax
  8034e4:	76 1e                	jbe    803504 <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034e6:	66 2d f0 00          	sub    $0xf0,%ax
  8034ea:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8034ee:	83 ec 0c             	sub    $0xc,%esp
  8034f1:	0f b7 c0             	movzwl %ax,%eax
  8034f4:	50                   	push   %eax
  8034f5:	e8 13 0e 00 00       	call   80430d <mem_malloc>
  8034fa:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8034fd:	83 c4 10             	add    $0x10,%esp
  803500:	85 c0                	test   %eax,%eax
  803502:	74 94                	je     803498 <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803504:	83 ec 0c             	sub    $0xc,%esp
  803507:	68 f0 00 00 00       	push   $0xf0
  80350c:	e8 fc 0d 00 00       	call   80430d <mem_malloc>
  803511:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  803514:	83 c4 10             	add    $0x10,%esp
  803517:	85 c0                	test   %eax,%eax
  803519:	0f 84 ea 00 00 00    	je     803609 <dhcp_recv+0x1b7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80351f:	6a 00                	push   $0x0
  803521:	68 f0 00 00 00       	push   $0xf0
  803526:	50                   	push   %eax
  803527:	ff 77 0c             	pushl  0xc(%edi)
  80352a:	e8 51 1b 00 00       	call   805080 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80352f:	83 c4 10             	add    $0x10,%esp
  803532:	66 3d f0 00          	cmp    $0xf0,%ax
  803536:	0f 85 e7 00 00 00    	jne    803623 <dhcp_recv+0x1d1>
  if (dhcp->options_in != NULL) {
  80353c:	8b 47 14             	mov    0x14(%edi),%eax
  80353f:	85 c0                	test   %eax,%eax
  803541:	74 20                	je     803563 <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803543:	68 f0 00 00 00       	push   $0xf0
  803548:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  80354c:	52                   	push   %edx
  80354d:	50                   	push   %eax
  80354e:	ff 77 0c             	pushl  0xc(%edi)
  803551:	e8 2a 1b 00 00       	call   805080 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803556:	83 c4 10             	add    $0x10,%esp
  803559:	66 3b 47 18          	cmp    0x18(%edi),%ax
  80355d:	0f 85 d7 00 00 00    	jne    80363a <dhcp_recv+0x1e8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803563:	ba 35 00 00 00       	mov    $0x35,%edx
  803568:	89 f8                	mov    %edi,%eax
  80356a:	e8 f7 f2 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80356f:	85 c0                	test   %eax,%eax
  803571:	0f 84 21 ff ff ff    	je     803498 <dhcp_recv+0x46>
  return *ptr;
  803577:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  80357b:	3c 05                	cmp    $0x5,%al
  80357d:	0f 84 ce 00 00 00    	je     803651 <dhcp_recv+0x1ff>
  else if ((msg_type == DHCP_NAK) &&
  803583:	3c 06                	cmp    $0x6,%al
  803585:	0f 84 6e 02 00 00    	je     8037f9 <dhcp_recv+0x3a7>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80358b:	3c 02                	cmp    $0x2,%al
  80358d:	0f 85 05 ff ff ff    	jne    803498 <dhcp_recv+0x46>
  803593:	80 3f 06             	cmpb   $0x6,(%edi)
  803596:	0f 85 fc fe ff ff    	jne    803498 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  80359c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8035a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8035a5:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  8035a8:	ba 36 00 00 00       	mov    $0x36,%edx
  8035ad:	89 d8                	mov    %ebx,%eax
  8035af:	e8 b2 f2 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035b4:	85 c0                	test   %eax,%eax
  8035b6:	0f 84 dc fe ff ff    	je     803498 <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035bc:	83 c0 02             	add    $0x2,%eax
  8035bf:	e8 b0 f3 ff ff       	call   802974 <dhcp_get_option_long>
  8035c4:	83 ec 0c             	sub    $0xc,%esp
  8035c7:	50                   	push   %eax
  8035c8:	e8 2b 42 00 00       	call   8077f8 <htonl>
  8035cd:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8035d0:	8b 43 10             	mov    0x10(%ebx),%eax
  8035d3:	83 c4 10             	add    $0x10,%esp
  8035d6:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8035d9:	0f 84 8e 02 00 00    	je     80386d <dhcp_recv+0x41b>
  8035df:	8b 40 10             	mov    0x10(%eax),%eax
  8035e2:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8035e5:	8b 45 08             	mov    0x8(%ebp),%eax
  8035e8:	e8 ba fa ff ff       	call   8030a7 <dhcp_select>
  8035ed:	e9 a6 fe ff ff       	jmp    803498 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8035f2:	83 ec 04             	sub    $0x4,%esp
  8035f5:	68 28 1c 81 00       	push   $0x811c28
  8035fa:	68 8a 04 00 00       	push   $0x48a
  8035ff:	68 e2 1b 81 00       	push   $0x811be2
  803604:	e8 66 b1 00 00       	call   80e76f <_panic>
    mem_free((void *)dhcp->options_in);
  803609:	83 ec 0c             	sub    $0xc,%esp
  80360c:	ff 77 14             	pushl  0x14(%edi)
  80360f:	e8 0a 0a 00 00       	call   80401e <mem_free>
    dhcp->options_in = NULL;
  803614:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
  80361b:	83 c4 10             	add    $0x10,%esp
  80361e:	e9 75 fe ff ff       	jmp    803498 <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803623:	83 ec 04             	sub    $0x4,%esp
  803626:	68 b0 1b 81 00       	push   $0x811bb0
  80362b:	68 a0 04 00 00       	push   $0x4a0
  803630:	68 e2 1b 81 00       	push   $0x811be2
  803635:	e8 35 b1 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80363a:	83 ec 04             	sub    $0x4,%esp
  80363d:	68 38 1c 81 00       	push   $0x811c38
  803642:	68 a7 04 00 00       	push   $0x4a7
  803647:	68 e2 1b 81 00       	push   $0x811be2
  80364c:	e8 1e b1 00 00       	call   80e76f <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803651:	0f b6 07             	movzbl (%edi),%eax
  803654:	3c 01                	cmp    $0x1,%al
  803656:	74 1e                	je     803676 <dhcp_recv+0x224>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803658:	83 e8 03             	sub    $0x3,%eax
  80365b:	3c 02                	cmp    $0x2,%al
  80365d:	0f 87 35 fe ff ff    	ja     803498 <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  803663:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803669:	8b 45 08             	mov    0x8(%ebp),%eax
  80366c:	e8 e6 fb ff ff       	call   803257 <dhcp_bind>
  803671:	e9 22 fe ff ff       	jmp    803498 <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  803676:	8b 45 08             	mov    0x8(%ebp),%eax
  803679:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  80367c:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803683:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  80368a:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803691:	ba 33 00 00 00       	mov    $0x33,%edx
  803696:	89 f0                	mov    %esi,%eax
  803698:	e8 c9 f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80369d:	85 c0                	test   %eax,%eax
  80369f:	74 0b                	je     8036ac <dhcp_recv+0x25a>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  8036a1:	83 c0 02             	add    $0x2,%eax
  8036a4:	e8 cb f2 ff ff       	call   802974 <dhcp_get_option_long>
  8036a9:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  8036ac:	ba 3a 00 00 00       	mov    $0x3a,%edx
  8036b1:	89 f0                	mov    %esi,%eax
  8036b3:	e8 ae f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036b8:	85 c0                	test   %eax,%eax
  8036ba:	0f 84 e7 00 00 00    	je     8037a7 <dhcp_recv+0x355>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8036c0:	83 c0 02             	add    $0x2,%eax
  8036c3:	e8 ac f2 ff ff       	call   802974 <dhcp_get_option_long>
  8036c8:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8036cb:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8036d0:	89 f0                	mov    %esi,%eax
  8036d2:	e8 8f f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036d7:	85 c0                	test   %eax,%eax
  8036d9:	0f 84 d2 00 00 00    	je     8037b1 <dhcp_recv+0x35f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8036df:	83 c0 02             	add    $0x2,%eax
  8036e2:	e8 8d f2 ff ff       	call   802974 <dhcp_get_option_long>
  8036e7:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8036ea:	8b 56 10             	mov    0x10(%esi),%edx
  8036ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8036f2:	83 fa f0             	cmp    $0xfffffff0,%edx
  8036f5:	74 03                	je     8036fa <dhcp_recv+0x2a8>
  8036f7:	8b 42 10             	mov    0x10(%edx),%eax
  8036fa:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8036fd:	ba 01 00 00 00       	mov    $0x1,%edx
  803702:	89 f0                	mov    %esi,%eax
  803704:	e8 5d f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803709:	85 c0                	test   %eax,%eax
  80370b:	74 17                	je     803724 <dhcp_recv+0x2d2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80370d:	83 c0 02             	add    $0x2,%eax
  803710:	e8 5f f2 ff ff       	call   802974 <dhcp_get_option_long>
  803715:	83 ec 0c             	sub    $0xc,%esp
  803718:	50                   	push   %eax
  803719:	e8 da 40 00 00       	call   8077f8 <htonl>
  80371e:	89 46 34             	mov    %eax,0x34(%esi)
  803721:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803724:	ba 03 00 00 00       	mov    $0x3,%edx
  803729:	89 f0                	mov    %esi,%eax
  80372b:	e8 36 f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803730:	85 c0                	test   %eax,%eax
  803732:	74 17                	je     80374b <dhcp_recv+0x2f9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803734:	83 c0 02             	add    $0x2,%eax
  803737:	e8 38 f2 ff ff       	call   802974 <dhcp_get_option_long>
  80373c:	83 ec 0c             	sub    $0xc,%esp
  80373f:	50                   	push   %eax
  803740:	e8 b3 40 00 00       	call   8077f8 <htonl>
  803745:	89 46 38             	mov    %eax,0x38(%esi)
  803748:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80374b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803750:	89 f0                	mov    %esi,%eax
  803752:	e8 0f f1 ff ff       	call   802866 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803757:	85 c0                	test   %eax,%eax
  803759:	74 17                	je     803772 <dhcp_recv+0x320>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80375b:	83 c0 02             	add    $0x2,%eax
  80375e:	e8 11 f2 ff ff       	call   802974 <dhcp_get_option_long>
  803763:	83 ec 0c             	sub    $0xc,%esp
  803766:	50                   	push   %eax
  803767:	e8 8c 40 00 00       	call   8077f8 <htonl>
  80376c:	89 46 3c             	mov    %eax,0x3c(%esi)
  80376f:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803772:	ba 06 00 00 00       	mov    $0x6,%edx
  803777:	89 f0                	mov    %esi,%eax
  803779:	e8 e8 f0 ff ff       	call   802866 <dhcp_get_option_ptr>
  80377e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803781:	85 c0                	test   %eax,%eax
  803783:	74 61                	je     8037e6 <dhcp_recv+0x394>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803785:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803789:	c0 e8 02             	shr    $0x2,%al
  80378c:	0f b6 c0             	movzbl %al,%eax
  80378f:	83 f8 02             	cmp    $0x2,%eax
  803792:	ba 02 00 00 00       	mov    $0x2,%edx
  803797:	0f 47 c2             	cmova  %edx,%eax
  80379a:	89 46 40             	mov    %eax,0x40(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80379d:	bb 00 00 00 00       	mov    $0x0,%ebx
  8037a2:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8037a5:	eb 34                	jmp    8037db <dhcp_recv+0x389>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8037a7:	8b 46 4c             	mov    0x4c(%esi),%eax
  8037aa:	d1 e8                	shr    %eax
  8037ac:	e9 17 ff ff ff       	jmp    8036c8 <dhcp_recv+0x276>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8037b1:	8b 46 4c             	mov    0x4c(%esi),%eax
  8037b4:	e9 2e ff ff ff       	jmp    8036e7 <dhcp_recv+0x295>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8037b9:	0f b6 fb             	movzbl %bl,%edi
  8037bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8037bf:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  8037c3:	e8 ac f1 ff ff       	call   802974 <dhcp_get_option_long>
  8037c8:	83 ec 0c             	sub    $0xc,%esp
  8037cb:	50                   	push   %eax
  8037cc:	e8 27 40 00 00       	call   8077f8 <htonl>
  8037d1:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  8037d5:	83 c3 01             	add    $0x1,%ebx
  8037d8:	83 c4 10             	add    $0x10,%esp
  8037db:	0f b6 c3             	movzbl %bl,%eax
  8037de:	3b 46 40             	cmp    0x40(%esi),%eax
  8037e1:	72 d6                	jb     8037b9 <dhcp_recv+0x367>
  8037e3:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  8037e6:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8037ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8037ef:	e8 2f fa ff ff       	call   803223 <dhcp_check>
  8037f4:	e9 9f fc ff ff       	jmp    803498 <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8037f9:	0f b6 07             	movzbl (%edi),%eax
  8037fc:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8037ff:	80 fa 02             	cmp    $0x2,%dl
  803802:	76 08                	jbe    80380c <dhcp_recv+0x3ba>
  803804:	3c 01                	cmp    $0x1,%al
  803806:	0f 85 8c fc ff ff    	jne    803498 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  80380c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803812:	8b 45 08             	mov    0x8(%ebp),%eax
  803815:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  803818:	83 ec 0c             	sub    $0xc,%esp
  80381b:	50                   	push   %eax
  80381c:	e8 f1 0f 00 00       	call   804812 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803821:	83 c4 08             	add    $0x8,%esp
  803824:	68 88 24 81 00       	push   $0x812488
  803829:	ff 75 08             	pushl  0x8(%ebp)
  80382c:	e8 43 0e 00 00       	call   804674 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803831:	83 c4 08             	add    $0x8,%esp
  803834:	68 88 24 81 00       	push   $0x812488
  803839:	ff 75 08             	pushl  0x8(%ebp)
  80383c:	e8 5f 0f 00 00       	call   8047a0 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803841:	83 c4 08             	add    $0x8,%esp
  803844:	68 88 24 81 00       	push   $0x812488
  803849:	ff 75 08             	pushl  0x8(%ebp)
  80384c:	e8 68 0f 00 00       	call   8047b9 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803851:	ba 0c 00 00 00       	mov    $0xc,%edx
  803856:	89 d8                	mov    %ebx,%eax
  803858:	e8 fe ef ff ff       	call   80285b <dhcp_set_state>
  dhcp_discover(netif);
  80385d:	8b 45 08             	mov    0x8(%ebp),%eax
  803860:	e8 03 f7 ff ff       	call   802f68 <dhcp_discover>
  803865:	83 c4 10             	add    $0x10,%esp
  803868:	e9 2b fc ff ff       	jmp    803498 <dhcp_recv+0x46>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80386d:	b8 00 00 00 00       	mov    $0x0,%eax
  803872:	e9 6b fd ff ff       	jmp    8035e2 <dhcp_recv+0x190>

00803877 <dhcp_inform>:
{
  803877:	55                   	push   %ebp
  803878:	89 e5                	mov    %esp,%ebp
  80387a:	57                   	push   %edi
  80387b:	56                   	push   %esi
  80387c:	53                   	push   %ebx
  80387d:	83 ec 18             	sub    $0x18,%esp
  803880:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803883:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803886:	6a 58                	push   $0x58
  803888:	e8 80 0a 00 00       	call   80430d <mem_malloc>
  if (dhcp == NULL) {
  80388d:	83 c4 10             	add    $0x10,%esp
  803890:	85 c0                	test   %eax,%eax
  803892:	74 55                	je     8038e9 <dhcp_inform+0x72>
  803894:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803896:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803899:	83 ec 04             	sub    $0x4,%esp
  80389c:	6a 58                	push   $0x58
  80389e:	6a 00                	push   $0x0
  8038a0:	50                   	push   %eax
  8038a1:	e8 64 b8 00 00       	call   80f10a <memset>
  dhcp->pcb = udp_new();
  8038a6:	e8 2a 58 00 00       	call   8090d5 <udp_new>
  8038ab:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8038ae:	83 c4 10             	add    $0x10,%esp
  8038b1:	85 c0                	test   %eax,%eax
  8038b3:	74 3c                	je     8038f1 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  8038b5:	89 f0                	mov    %esi,%eax
  8038b7:	e8 2c f3 ff ff       	call   802be8 <dhcp_create_request>
  if (result == ERR_OK) {
  8038bc:	84 c0                	test   %al,%al
  8038be:	74 3f                	je     8038ff <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  8038c0:	8b 43 08             	mov    0x8(%ebx),%eax
  8038c3:	85 c0                	test   %eax,%eax
  8038c5:	74 0c                	je     8038d3 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  8038c7:	83 ec 0c             	sub    $0xc,%esp
  8038ca:	50                   	push   %eax
  8038cb:	e8 c1 57 00 00       	call   809091 <udp_remove>
  8038d0:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  8038d3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8038da:	83 ec 0c             	sub    $0xc,%esp
  8038dd:	53                   	push   %ebx
  8038de:	e8 3b 07 00 00       	call   80401e <mem_free>
    netif->dhcp = old_dhcp;
  8038e3:	89 7e 20             	mov    %edi,0x20(%esi)
  8038e6:	83 c4 10             	add    $0x10,%esp
}
  8038e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8038ec:	5b                   	pop    %ebx
  8038ed:	5e                   	pop    %esi
  8038ee:	5f                   	pop    %edi
  8038ef:	5d                   	pop    %ebp
  8038f0:	c3                   	ret    
    mem_free((void *)dhcp);
  8038f1:	83 ec 0c             	sub    $0xc,%esp
  8038f4:	53                   	push   %ebx
  8038f5:	e8 24 07 00 00       	call   80401e <mem_free>
    return;
  8038fa:	83 c4 10             	add    $0x10,%esp
  8038fd:	eb ea                	jmp    8038e9 <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8038ff:	b9 01 00 00 00       	mov    $0x1,%ecx
  803904:	ba 35 00 00 00       	mov    $0x35,%edx
  803909:	89 d8                	mov    %ebx,%eax
  80390b:	e8 c6 f0 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803910:	ba 08 00 00 00       	mov    $0x8,%edx
  803915:	89 d8                	mov    %ebx,%eax
  803917:	e8 79 f0 ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80391c:	b9 02 00 00 00       	mov    $0x2,%ecx
  803921:	ba 39 00 00 00       	mov    $0x39,%edx
  803926:	89 d8                	mov    %ebx,%eax
  803928:	e8 a9 f0 ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80392d:	ba 40 02 00 00       	mov    $0x240,%edx
  803932:	89 d8                	mov    %ebx,%eax
  803934:	e8 04 f1 ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803939:	89 d8                	mov    %ebx,%eax
  80393b:	e8 5b f1 ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803940:	83 ec 08             	sub    $0x8,%esp
  803943:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803947:	66 05 f0 00          	add    $0xf0,%ax
  80394b:	0f b7 c0             	movzwl %ax,%eax
  80394e:	50                   	push   %eax
  80394f:	ff 73 1c             	pushl  0x1c(%ebx)
  803952:	e8 e5 12 00 00       	call   804c3c <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803957:	83 c4 0c             	add    $0xc,%esp
  80395a:	6a 44                	push   $0x44
  80395c:	68 88 24 81 00       	push   $0x812488
  803961:	ff 73 08             	pushl  0x8(%ebx)
  803964:	e8 d8 53 00 00       	call   808d41 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803969:	83 c4 0c             	add    $0xc,%esp
  80396c:	6a 43                	push   $0x43
  80396e:	68 84 24 81 00       	push   $0x812484
  803973:	ff 73 08             	pushl  0x8(%ebx)
  803976:	e8 76 56 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80397b:	89 34 24             	mov    %esi,(%esp)
  80397e:	6a 43                	push   $0x43
  803980:	68 84 24 81 00       	push   $0x812484
  803985:	ff 73 1c             	pushl  0x1c(%ebx)
  803988:	ff 73 08             	pushl  0x8(%ebx)
  80398b:	e8 6c 54 00 00       	call   808dfc <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803990:	83 c4 1c             	add    $0x1c,%esp
  803993:	6a 43                	push   $0x43
  803995:	68 88 24 81 00       	push   $0x812488
  80399a:	ff 73 08             	pushl  0x8(%ebx)
  80399d:	e8 4f 56 00 00       	call   808ff1 <udp_connect>
    dhcp_delete_request(netif);
  8039a2:	89 f0                	mov    %esi,%eax
  8039a4:	e8 32 f4 ff ff       	call   802ddb <dhcp_delete_request>
  8039a9:	83 c4 10             	add    $0x10,%esp
  8039ac:	e9 0f ff ff ff       	jmp    8038c0 <dhcp_inform+0x49>

008039b1 <dhcp_arp_reply>:
{
  8039b1:	55                   	push   %ebp
  8039b2:	89 e5                	mov    %esp,%ebp
  8039b4:	56                   	push   %esi
  8039b5:	53                   	push   %ebx
  8039b6:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8039b9:	85 f6                	test   %esi,%esi
  8039bb:	74 13                	je     8039d0 <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  8039bd:	8b 5e 20             	mov    0x20(%esi),%ebx
  8039c0:	85 db                	test   %ebx,%ebx
  8039c2:	74 05                	je     8039c9 <dhcp_arp_reply+0x18>
  8039c4:	80 3b 08             	cmpb   $0x8,(%ebx)
  8039c7:	74 1e                	je     8039e7 <dhcp_arp_reply+0x36>
}
  8039c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8039cc:	5b                   	pop    %ebx
  8039cd:	5e                   	pop    %esi
  8039ce:	5d                   	pop    %ebp
  8039cf:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8039d0:	83 ec 04             	sub    $0x4,%esp
  8039d3:	68 02 1c 81 00       	push   $0x811c02
  8039d8:	68 b5 02 00 00       	push   $0x2b5
  8039dd:	68 e2 1b 81 00       	push   $0x811be2
  8039e2:	e8 88 ad 00 00       	call   80e76f <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8039e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8039ea:	8b 4b 30             	mov    0x30(%ebx),%ecx
  8039ed:	39 08                	cmp    %ecx,(%eax)
  8039ef:	75 d8                	jne    8039c9 <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8039f1:	ba 0c 00 00 00       	mov    $0xc,%edx
  8039f6:	89 d8                	mov    %ebx,%eax
  8039f8:	e8 5e ee ff ff       	call   80285b <dhcp_set_state>
  result = dhcp_create_request(netif);
  8039fd:	89 f0                	mov    %esi,%eax
  8039ff:	e8 e4 f1 ff ff       	call   802be8 <dhcp_create_request>
  if (result == ERR_OK) {
  803a04:	84 c0                	test   %al,%al
  803a06:	74 0c                	je     803a14 <dhcp_arp_reply+0x63>
  dhcp->tries++;
  803a08:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a0c:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  803a12:	eb b5                	jmp    8039c9 <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a14:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a19:	ba 35 00 00 00       	mov    $0x35,%edx
  803a1e:	89 d8                	mov    %ebx,%eax
  803a20:	e8 b1 ef ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803a25:	ba 04 00 00 00       	mov    $0x4,%edx
  803a2a:	89 d8                	mov    %ebx,%eax
  803a2c:	e8 64 ef ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a31:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a36:	ba 39 00 00 00       	mov    $0x39,%edx
  803a3b:	89 d8                	mov    %ebx,%eax
  803a3d:	e8 94 ef ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803a42:	ba 40 02 00 00       	mov    $0x240,%edx
  803a47:	89 d8                	mov    %ebx,%eax
  803a49:	e8 ef ef ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803a4e:	b9 04 00 00 00       	mov    $0x4,%ecx
  803a53:	ba 32 00 00 00       	mov    $0x32,%edx
  803a58:	89 d8                	mov    %ebx,%eax
  803a5a:	e8 77 ef ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803a5f:	83 ec 0c             	sub    $0xc,%esp
  803a62:	ff 73 30             	pushl  0x30(%ebx)
  803a65:	e8 a5 3f 00 00       	call   807a0f <ntohl>
  803a6a:	89 c2                	mov    %eax,%edx
  803a6c:	89 d8                	mov    %ebx,%eax
  803a6e:	e8 dd f0 ff ff       	call   802b50 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803a73:	89 d8                	mov    %ebx,%eax
  803a75:	e8 21 f0 ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a7a:	83 c4 08             	add    $0x8,%esp
  803a7d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a81:	66 05 f0 00          	add    $0xf0,%ax
  803a85:	0f b7 c0             	movzwl %ax,%eax
  803a88:	50                   	push   %eax
  803a89:	ff 73 1c             	pushl  0x1c(%ebx)
  803a8c:	e8 ab 11 00 00       	call   804c3c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a91:	83 c4 0c             	add    $0xc,%esp
  803a94:	6a 43                	push   $0x43
  803a96:	68 88 24 81 00       	push   $0x812488
  803a9b:	ff 73 08             	pushl  0x8(%ebx)
  803a9e:	e8 4e 55 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803aa3:	89 34 24             	mov    %esi,(%esp)
  803aa6:	6a 43                	push   $0x43
  803aa8:	68 84 24 81 00       	push   $0x812484
  803aad:	ff 73 1c             	pushl  0x1c(%ebx)
  803ab0:	ff 73 08             	pushl  0x8(%ebx)
  803ab3:	e8 44 53 00 00       	call   808dfc <udp_sendto_if>
    dhcp_delete_request(netif);
  803ab8:	83 c4 20             	add    $0x20,%esp
  803abb:	89 f0                	mov    %esi,%eax
  803abd:	e8 19 f3 ff ff       	call   802ddb <dhcp_delete_request>
  803ac2:	e9 41 ff ff ff       	jmp    803a08 <dhcp_arp_reply+0x57>

00803ac7 <dhcp_renew>:
{
  803ac7:	55                   	push   %ebp
  803ac8:	89 e5                	mov    %esp,%ebp
  803aca:	57                   	push   %edi
  803acb:	56                   	push   %esi
  803acc:	53                   	push   %ebx
  803acd:	83 ec 1c             	sub    $0x1c,%esp
  803ad0:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803ad3:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803ad6:	ba 05 00 00 00       	mov    $0x5,%edx
  803adb:	89 d8                	mov    %ebx,%eax
  803add:	e8 79 ed ff ff       	call   80285b <dhcp_set_state>
  result = dhcp_create_request(netif);
  803ae2:	89 f0                	mov    %esi,%eax
  803ae4:	e8 ff f0 ff ff       	call   802be8 <dhcp_create_request>
  803ae9:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803aeb:	84 c0                	test   %al,%al
  803aed:	74 3e                	je     803b2d <dhcp_renew+0x66>
  dhcp->tries++;
  803aef:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803af3:	83 c0 01             	add    $0x1,%eax
  803af6:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803af9:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803afe:	3c 09                	cmp    $0x9,%al
  803b00:	77 08                	ja     803b0a <dhcp_renew+0x43>
  803b02:	0f b6 d0             	movzbl %al,%edx
  803b05:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803b0a:	0f b7 d2             	movzwl %dx,%edx
  803b0d:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803b13:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803b18:	89 d0                	mov    %edx,%eax
  803b1a:	f7 e9                	imul   %ecx
  803b1c:	c1 fa 05             	sar    $0x5,%edx
  803b1f:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803b23:	89 f8                	mov    %edi,%eax
  803b25:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803b28:	5b                   	pop    %ebx
  803b29:	5e                   	pop    %esi
  803b2a:	5f                   	pop    %edi
  803b2b:	5d                   	pop    %ebp
  803b2c:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803b2d:	b9 01 00 00 00       	mov    $0x1,%ecx
  803b32:	ba 35 00 00 00       	mov    $0x35,%edx
  803b37:	89 d8                	mov    %ebx,%eax
  803b39:	e8 98 ee ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803b3e:	ba 03 00 00 00       	mov    $0x3,%edx
  803b43:	89 d8                	mov    %ebx,%eax
  803b45:	e8 4b ee ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803b4a:	b9 02 00 00 00       	mov    $0x2,%ecx
  803b4f:	ba 39 00 00 00       	mov    $0x39,%edx
  803b54:	89 d8                	mov    %ebx,%eax
  803b56:	e8 7b ee ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803b5b:	ba 40 02 00 00       	mov    $0x240,%edx
  803b60:	89 d8                	mov    %ebx,%eax
  803b62:	e8 d6 ee ff ff       	call   802a3d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803b67:	89 d8                	mov    %ebx,%eax
  803b69:	e8 2d ef ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b6e:	83 ec 08             	sub    $0x8,%esp
  803b71:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b75:	66 05 f0 00          	add    $0xf0,%ax
  803b79:	0f b7 c0             	movzwl %ax,%eax
  803b7c:	50                   	push   %eax
  803b7d:	ff 73 1c             	pushl  0x1c(%ebx)
  803b80:	e8 b7 10 00 00       	call   804c3c <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803b85:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803b88:	83 c4 0c             	add    $0xc,%esp
  803b8b:	6a 43                	push   $0x43
  803b8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803b90:	50                   	push   %eax
  803b91:	ff 73 08             	pushl  0x8(%ebx)
  803b94:	e8 58 54 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803b99:	89 34 24             	mov    %esi,(%esp)
  803b9c:	6a 43                	push   $0x43
  803b9e:	ff 75 e4             	pushl  -0x1c(%ebp)
  803ba1:	ff 73 1c             	pushl  0x1c(%ebx)
  803ba4:	ff 73 08             	pushl  0x8(%ebx)
  803ba7:	e8 50 52 00 00       	call   808dfc <udp_sendto_if>
    dhcp_delete_request(netif);
  803bac:	83 c4 20             	add    $0x20,%esp
  803baf:	89 f0                	mov    %esi,%eax
  803bb1:	e8 25 f2 ff ff       	call   802ddb <dhcp_delete_request>
  803bb6:	e9 34 ff ff ff       	jmp    803aef <dhcp_renew+0x28>

00803bbb <dhcp_coarse_tmr>:
{
  803bbb:	55                   	push   %ebp
  803bbc:	89 e5                	mov    %esp,%ebp
  803bbe:	53                   	push   %ebx
  803bbf:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803bc2:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  while (netif != NULL) {
  803bc8:	eb 1d                	jmp    803be7 <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803bca:	8b 43 20             	mov    0x20(%ebx),%eax
  803bcd:	0f b6 00             	movzbl (%eax),%eax
  803bd0:	89 c2                	mov    %eax,%edx
  803bd2:	83 e2 fb             	and    $0xfffffffb,%edx
  803bd5:	80 fa 01             	cmp    $0x1,%dl
  803bd8:	74 04                	je     803bde <dhcp_coarse_tmr+0x23>
  803bda:	3c 0a                	cmp    $0xa,%al
  803bdc:	75 07                	jne    803be5 <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803bde:	89 d8                	mov    %ebx,%eax
  803be0:	e8 90 f2 ff ff       	call   802e75 <dhcp_rebind>
    netif = netif->next;
  803be5:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803be7:	85 db                	test   %ebx,%ebx
  803be9:	74 4e                	je     803c39 <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803beb:	8b 43 20             	mov    0x20(%ebx),%eax
  803bee:	85 c0                	test   %eax,%eax
  803bf0:	74 f3                	je     803be5 <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803bf2:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803bf6:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803bf9:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803bfd:	66 83 fa 01          	cmp    $0x1,%dx
  803c01:	74 c7                	je     803bca <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803c03:	8b 53 20             	mov    0x20(%ebx),%edx
  803c06:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803c0a:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803c0d:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803c11:	66 83 f8 01          	cmp    $0x1,%ax
  803c15:	75 ce                	jne    803be5 <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803c17:	8b 43 20             	mov    0x20(%ebx),%eax
  803c1a:	0f b6 00             	movzbl (%eax),%eax
  803c1d:	89 c2                	mov    %eax,%edx
  803c1f:	83 e2 fb             	and    $0xfffffffb,%edx
  803c22:	80 fa 01             	cmp    $0x1,%dl
  803c25:	74 04                	je     803c2b <dhcp_coarse_tmr+0x70>
  803c27:	3c 0a                	cmp    $0xa,%al
  803c29:	75 ba                	jne    803be5 <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803c2b:	83 ec 0c             	sub    $0xc,%esp
  803c2e:	53                   	push   %ebx
  803c2f:	e8 93 fe ff ff       	call   803ac7 <dhcp_renew>
  803c34:	83 c4 10             	add    $0x10,%esp
  803c37:	eb ac                	jmp    803be5 <dhcp_coarse_tmr+0x2a>
}
  803c39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803c3c:	c9                   	leave  
  803c3d:	c3                   	ret    

00803c3e <dhcp_release>:
{
  803c3e:	55                   	push   %ebp
  803c3f:	89 e5                	mov    %esp,%ebp
  803c41:	57                   	push   %edi
  803c42:	56                   	push   %esi
  803c43:	53                   	push   %ebx
  803c44:	83 ec 1c             	sub    $0x1c,%esp
  803c47:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803c4a:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803c4d:	ba 0d 00 00 00       	mov    $0xd,%edx
  803c52:	89 d8                	mov    %ebx,%eax
  803c54:	e8 02 ec ff ff       	call   80285b <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803c59:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803c60:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803c67:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803c6e:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803c75:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803c7c:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803c83:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803c8a:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803c91:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803c98:	89 f0                	mov    %esi,%eax
  803c9a:	e8 49 ef ff ff       	call   802be8 <dhcp_create_request>
  803c9f:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803ca1:	84 c0                	test   %al,%al
  803ca3:	74 71                	je     803d16 <dhcp_release+0xd8>
  dhcp->tries++;
  803ca5:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803ca9:	83 c0 01             	add    $0x1,%eax
  803cac:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803caf:	ba 10 27 00 00       	mov    $0x2710,%edx
  803cb4:	3c 09                	cmp    $0x9,%al
  803cb6:	77 08                	ja     803cc0 <dhcp_release+0x82>
  803cb8:	0f b6 d0             	movzbl %al,%edx
  803cbb:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803cc0:	0f b7 d2             	movzwl %dx,%edx
  803cc3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803cc9:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803cce:	89 d0                	mov    %edx,%eax
  803cd0:	f7 e9                	imul   %ecx
  803cd2:	c1 fa 05             	sar    $0x5,%edx
  803cd5:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803cd9:	83 ec 0c             	sub    $0xc,%esp
  803cdc:	56                   	push   %esi
  803cdd:	e8 30 0b 00 00       	call   804812 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803ce2:	83 c4 08             	add    $0x8,%esp
  803ce5:	68 88 24 81 00       	push   $0x812488
  803cea:	56                   	push   %esi
  803ceb:	e8 84 09 00 00       	call   804674 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803cf0:	83 c4 08             	add    $0x8,%esp
  803cf3:	68 88 24 81 00       	push   $0x812488
  803cf8:	56                   	push   %esi
  803cf9:	e8 a2 0a 00 00       	call   8047a0 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803cfe:	83 c4 08             	add    $0x8,%esp
  803d01:	68 88 24 81 00       	push   $0x812488
  803d06:	56                   	push   %esi
  803d07:	e8 ad 0a 00 00       	call   8047b9 <netif_set_netmask>
}
  803d0c:	89 f8                	mov    %edi,%eax
  803d0e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803d11:	5b                   	pop    %ebx
  803d12:	5e                   	pop    %esi
  803d13:	5f                   	pop    %edi
  803d14:	5d                   	pop    %ebp
  803d15:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803d16:	b9 01 00 00 00       	mov    $0x1,%ecx
  803d1b:	ba 35 00 00 00       	mov    $0x35,%edx
  803d20:	89 d8                	mov    %ebx,%eax
  803d22:	e8 af ec ff ff       	call   8029d6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803d27:	ba 07 00 00 00       	mov    $0x7,%edx
  803d2c:	89 d8                	mov    %ebx,%eax
  803d2e:	e8 62 ec ff ff       	call   802995 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803d33:	89 d8                	mov    %ebx,%eax
  803d35:	e8 61 ed ff ff       	call   802a9b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803d3a:	83 ec 08             	sub    $0x8,%esp
  803d3d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803d41:	66 05 f0 00          	add    $0xf0,%ax
  803d45:	0f b7 c0             	movzwl %ax,%eax
  803d48:	50                   	push   %eax
  803d49:	ff 73 1c             	pushl  0x1c(%ebx)
  803d4c:	e8 eb 0e 00 00       	call   804c3c <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803d51:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803d54:	83 c4 0c             	add    $0xc,%esp
  803d57:	6a 43                	push   $0x43
  803d59:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803d5c:	50                   	push   %eax
  803d5d:	ff 73 08             	pushl  0x8(%ebx)
  803d60:	e8 8c 52 00 00       	call   808ff1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803d65:	89 34 24             	mov    %esi,(%esp)
  803d68:	6a 43                	push   $0x43
  803d6a:	ff 75 e4             	pushl  -0x1c(%ebp)
  803d6d:	ff 73 1c             	pushl  0x1c(%ebx)
  803d70:	ff 73 08             	pushl  0x8(%ebx)
  803d73:	e8 84 50 00 00       	call   808dfc <udp_sendto_if>
    dhcp_delete_request(netif);
  803d78:	83 c4 20             	add    $0x20,%esp
  803d7b:	89 f0                	mov    %esi,%eax
  803d7d:	e8 59 f0 ff ff       	call   802ddb <dhcp_delete_request>
  803d82:	e9 1e ff ff ff       	jmp    803ca5 <dhcp_release+0x67>

00803d87 <dhcp_fine_tmr>:
{
  803d87:	55                   	push   %ebp
  803d88:	89 e5                	mov    %esp,%ebp
  803d8a:	53                   	push   %ebx
  803d8b:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803d8e:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  while (netif != NULL) {
  803d94:	eb 04                	jmp    803d9a <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803d96:	74 24                	je     803dbc <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803d98:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803d9a:	85 db                	test   %ebx,%ebx
  803d9c:	0f 84 c4 00 00 00    	je     803e66 <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803da2:	8b 43 20             	mov    0x20(%ebx),%eax
  803da5:	85 c0                	test   %eax,%eax
  803da7:	74 ef                	je     803d98 <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803da9:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803dad:	66 83 fa 01          	cmp    $0x1,%dx
  803db1:	76 e3                	jbe    803d96 <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803db3:	83 ea 01             	sub    $0x1,%edx
  803db6:	66 89 50 26          	mov    %dx,0x26(%eax)
  803dba:	eb dc                	jmp    803d98 <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803dbc:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803dc2:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803dc5:	0f b6 02             	movzbl (%edx),%eax
  803dc8:	3c 0c                	cmp    $0xc,%al
  803dca:	74 23                	je     803def <dhcp_fine_tmr+0x68>
  803dcc:	3c 06                	cmp    $0x6,%al
  803dce:	74 1f                	je     803def <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803dd0:	3c 01                	cmp    $0x1,%al
  803dd2:	74 24                	je     803df8 <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803dd4:	3c 08                	cmp    $0x8,%al
  803dd6:	74 47                	je     803e1f <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803dd8:	3c 05                	cmp    $0x5,%al
  803dda:	74 61                	je     803e3d <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803ddc:	3c 04                	cmp    $0x4,%al
  803dde:	75 b8                	jne    803d98 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803de0:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803de4:	77 68                	ja     803e4e <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803de6:	89 d8                	mov    %ebx,%eax
  803de8:	e8 88 f0 ff ff       	call   802e75 <dhcp_rebind>
  803ded:	eb a9                	jmp    803d98 <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803def:	89 d8                	mov    %ebx,%eax
  803df1:	e8 72 f1 ff ff       	call   802f68 <dhcp_discover>
  803df6:	eb a0                	jmp    803d98 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803df8:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803dfc:	77 09                	ja     803e07 <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803dfe:	89 d8                	mov    %ebx,%eax
  803e00:	e8 a2 f2 ff ff       	call   8030a7 <dhcp_select>
  803e05:	eb 91                	jmp    803d98 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803e07:	83 ec 0c             	sub    $0xc,%esp
  803e0a:	53                   	push   %ebx
  803e0b:	e8 2e fe ff ff       	call   803c3e <dhcp_release>
      dhcp_discover(netif);
  803e10:	89 d8                	mov    %ebx,%eax
  803e12:	e8 51 f1 ff ff       	call   802f68 <dhcp_discover>
  803e17:	83 c4 10             	add    $0x10,%esp
  803e1a:	e9 79 ff ff ff       	jmp    803d98 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803e1f:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803e23:	76 0c                	jbe    803e31 <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803e25:	89 d8                	mov    %ebx,%eax
  803e27:	e8 2b f4 ff ff       	call   803257 <dhcp_bind>
  803e2c:	e9 67 ff ff ff       	jmp    803d98 <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803e31:	89 d8                	mov    %ebx,%eax
  803e33:	e8 eb f3 ff ff       	call   803223 <dhcp_check>
  803e38:	e9 5b ff ff ff       	jmp    803d98 <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803e3d:	83 ec 0c             	sub    $0xc,%esp
  803e40:	53                   	push   %ebx
  803e41:	e8 81 fc ff ff       	call   803ac7 <dhcp_renew>
  803e46:	83 c4 10             	add    $0x10,%esp
  803e49:	e9 4a ff ff ff       	jmp    803d98 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803e4e:	83 ec 0c             	sub    $0xc,%esp
  803e51:	53                   	push   %ebx
  803e52:	e8 e7 fd ff ff       	call   803c3e <dhcp_release>
      dhcp_discover(netif);
  803e57:	89 d8                	mov    %ebx,%eax
  803e59:	e8 0a f1 ff ff       	call   802f68 <dhcp_discover>
  803e5e:	83 c4 10             	add    $0x10,%esp
  803e61:	e9 32 ff ff ff       	jmp    803d98 <dhcp_fine_tmr+0x11>
}
  803e66:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803e69:	c9                   	leave  
  803e6a:	c3                   	ret    

00803e6b <dhcp_stop>:
{
  803e6b:	55                   	push   %ebp
  803e6c:	89 e5                	mov    %esp,%ebp
  803e6e:	56                   	push   %esi
  803e6f:	53                   	push   %ebx
  803e70:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803e73:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e76:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803e7a:	85 db                	test   %ebx,%ebx
  803e7c:	74 4e                	je     803ecc <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803e7e:	8b 43 08             	mov    0x8(%ebx),%eax
  803e81:	85 c0                	test   %eax,%eax
  803e83:	74 13                	je     803e98 <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803e85:	83 ec 0c             	sub    $0xc,%esp
  803e88:	50                   	push   %eax
  803e89:	e8 03 52 00 00       	call   809091 <udp_remove>
      dhcp->pcb = NULL;
  803e8e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803e95:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803e98:	8b 43 0c             	mov    0xc(%ebx),%eax
  803e9b:	85 c0                	test   %eax,%eax
  803e9d:	74 13                	je     803eb2 <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803e9f:	83 ec 0c             	sub    $0xc,%esp
  803ea2:	50                   	push   %eax
  803ea3:	e8 5c 0a 00 00       	call   804904 <pbuf_free>
      dhcp->p = NULL;
  803ea8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803eaf:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803eb2:	89 d8                	mov    %ebx,%eax
  803eb4:	e8 51 f5 ff ff       	call   80340a <dhcp_free_reply>
    mem_free((void *)dhcp);
  803eb9:	83 ec 0c             	sub    $0xc,%esp
  803ebc:	53                   	push   %ebx
  803ebd:	e8 5c 01 00 00       	call   80401e <mem_free>
    netif->dhcp = NULL;
  803ec2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803ec9:	83 c4 10             	add    $0x10,%esp
}
  803ecc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803ecf:	5b                   	pop    %ebx
  803ed0:	5e                   	pop    %esi
  803ed1:	5d                   	pop    %ebp
  803ed2:	c3                   	ret    

00803ed3 <dhcp_start>:
{
  803ed3:	55                   	push   %ebp
  803ed4:	89 e5                	mov    %esp,%ebp
  803ed6:	56                   	push   %esi
  803ed7:	53                   	push   %ebx
  803ed8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803edb:	85 db                	test   %ebx,%ebx
  803edd:	74 73                	je     803f52 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803edf:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803ee2:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803ee6:	85 f6                	test   %esi,%esi
  803ee8:	74 7f                	je     803f69 <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803eea:	83 ec 04             	sub    $0x4,%esp
  803eed:	6a 58                	push   $0x58
  803eef:	6a 00                	push   $0x0
  803ef1:	56                   	push   %esi
  803ef2:	e8 13 b2 00 00       	call   80f10a <memset>
  dhcp->pcb = udp_new();
  803ef7:	e8 d9 51 00 00       	call   8090d5 <udp_new>
  803efc:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803eff:	83 c4 10             	add    $0x10,%esp
  803f02:	85 c0                	test   %eax,%eax
  803f04:	74 7e                	je     803f84 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803f06:	83 ec 04             	sub    $0x4,%esp
  803f09:	6a 44                	push   $0x44
  803f0b:	68 88 24 81 00       	push   $0x812488
  803f10:	50                   	push   %eax
  803f11:	e8 2b 4e 00 00       	call   808d41 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803f16:	83 c4 0c             	add    $0xc,%esp
  803f19:	6a 43                	push   $0x43
  803f1b:	68 88 24 81 00       	push   $0x812488
  803f20:	ff 76 08             	pushl  0x8(%esi)
  803f23:	e8 c9 50 00 00       	call   808ff1 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803f28:	83 c4 0c             	add    $0xc,%esp
  803f2b:	53                   	push   %ebx
  803f2c:	68 52 34 80 00       	push   $0x803452
  803f31:	ff 76 08             	pushl  0x8(%esi)
  803f34:	e8 44 51 00 00       	call   80907d <udp_recv>
  result = dhcp_discover(netif);
  803f39:	89 d8                	mov    %ebx,%eax
  803f3b:	e8 28 f0 ff ff       	call   802f68 <dhcp_discover>
  if (result != ERR_OK) {
  803f40:	83 c4 10             	add    $0x10,%esp
  803f43:	84 c0                	test   %al,%al
  803f45:	75 57                	jne    803f9e <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803f47:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803f4b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803f4e:	5b                   	pop    %ebx
  803f4f:	5e                   	pop    %esi
  803f50:	5d                   	pop    %ebp
  803f51:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803f52:	83 ec 04             	sub    $0x4,%esp
  803f55:	68 02 1c 81 00       	push   $0x811c02
  803f5a:	68 38 02 00 00       	push   $0x238
  803f5f:	68 e2 1b 81 00       	push   $0x811be2
  803f64:	e8 06 a8 00 00       	call   80e76f <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803f69:	83 ec 0c             	sub    $0xc,%esp
  803f6c:	6a 58                	push   $0x58
  803f6e:	e8 9a 03 00 00       	call   80430d <mem_malloc>
  803f73:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803f75:	83 c4 10             	add    $0x10,%esp
  803f78:	85 c0                	test   %eax,%eax
  803f7a:	74 35                	je     803fb1 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803f7c:	89 43 20             	mov    %eax,0x20(%ebx)
  803f7f:	e9 66 ff ff ff       	jmp    803eea <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803f84:	83 ec 0c             	sub    $0xc,%esp
  803f87:	56                   	push   %esi
  803f88:	e8 91 00 00 00       	call   80401e <mem_free>
    netif->dhcp = dhcp = NULL;
  803f8d:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803f94:	83 c4 10             	add    $0x10,%esp
  803f97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f9c:	eb ad                	jmp    803f4b <dhcp_start+0x78>
    dhcp_stop(netif);
  803f9e:	83 ec 0c             	sub    $0xc,%esp
  803fa1:	53                   	push   %ebx
  803fa2:	e8 c4 fe ff ff       	call   803e6b <dhcp_stop>
    return ERR_MEM;
  803fa7:	83 c4 10             	add    $0x10,%esp
  803faa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803faf:	eb 9a                	jmp    803f4b <dhcp_start+0x78>
      return ERR_MEM;
  803fb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803fb6:	eb 93                	jmp    803f4b <dhcp_start+0x78>

00803fb8 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803fb8:	55                   	push   %ebp
  803fb9:	89 e5                	mov    %esp,%ebp
  803fbb:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803fbe:	b8 23 63 81 00       	mov    $0x816323,%eax
  803fc3:	83 e0 fc             	and    $0xfffffffc,%eax
  803fc6:	a3 0c 63 81 00       	mov    %eax,0x81630c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803fcb:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803fd1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803fd8:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803fdc:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803fe2:	89 15 08 63 81 00    	mov    %edx,0x816308
  ram_end->used = 1;
  803fe8:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803fef:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803ff6:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803ff9:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  804000:	00 22 00 

  mem_sem = sys_sem_new(1);
  804003:	6a 01                	push   $0x1
  804005:	e8 ad 5e 00 00       	call   809eb7 <sys_sem_new>
  80400a:	a3 00 63 81 00       	mov    %eax,0x816300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80400f:	a1 0c 63 81 00       	mov    0x81630c,%eax
  804014:	a3 04 63 81 00       	mov    %eax,0x816304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804019:	83 c4 10             	add    $0x10,%esp
  80401c:	c9                   	leave  
  80401d:	c3                   	ret    

0080401e <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80401e:	55                   	push   %ebp
  80401f:	89 e5                	mov    %esp,%ebp
  804021:	56                   	push   %esi
  804022:	53                   	push   %ebx
  804023:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  804026:	85 db                	test   %ebx,%ebx
  804028:	0f 84 e1 00 00 00    	je     80410f <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80402e:	f6 c3 03             	test   $0x3,%bl
  804031:	0f 85 df 00 00 00    	jne    804116 <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804037:	39 1d 0c 63 81 00    	cmp    %ebx,0x81630c
  80403d:	0f 87 ea 00 00 00    	ja     80412d <mem_free+0x10f>
  804043:	39 1d 08 63 81 00    	cmp    %ebx,0x816308
  804049:	0f 86 de 00 00 00    	jbe    80412d <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80404f:	83 ec 08             	sub    $0x8,%esp
  804052:	6a 00                	push   $0x0
  804054:	ff 35 00 63 81 00    	pushl  0x816300
  80405a:	e8 85 61 00 00       	call   80a1e4 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80405f:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804062:	83 c4 10             	add    $0x10,%esp
  804065:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804069:	0f 84 d5 00 00 00    	je     804144 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  80406f:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804073:	39 05 04 63 81 00    	cmp    %eax,0x816304
  804079:	76 05                	jbe    804080 <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80407b:	a3 04 63 81 00       	mov    %eax,0x816304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804080:	8b 0d 0c 63 81 00    	mov    0x81630c,%ecx
  804086:	39 c8                	cmp    %ecx,%eax
  804088:	0f 82 cd 00 00 00    	jb     80415b <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80408e:	8b 35 08 63 81 00    	mov    0x816308,%esi
  804094:	39 f0                	cmp    %esi,%eax
  804096:	0f 83 d6 00 00 00    	jae    804172 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80409c:	8b 53 f4             	mov    -0xc(%ebx),%edx
  80409f:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8040a5:	0f 87 de 00 00 00    	ja     804189 <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  8040ab:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  8040ad:	39 d0                	cmp    %edx,%eax
  8040af:	74 25                	je     8040d6 <mem_free+0xb8>
  8040b1:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8040b5:	75 1f                	jne    8040d6 <mem_free+0xb8>
  8040b7:	39 d6                	cmp    %edx,%esi
  8040b9:	74 1b                	je     8040d6 <mem_free+0xb8>
    if (lfree == nmem) {
  8040bb:	3b 15 04 63 81 00    	cmp    0x816304,%edx
  8040c1:	0f 84 d9 00 00 00    	je     8041a0 <mem_free+0x182>
    mem->next = nmem->next;
  8040c7:	8b 32                	mov    (%edx),%esi
  8040c9:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8040cc:	8b 12                	mov    (%edx),%edx
  8040ce:	89 c6                	mov    %eax,%esi
  8040d0:	29 ce                	sub    %ecx,%esi
  8040d2:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  8040d6:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8040d9:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  8040dc:	39 d0                	cmp    %edx,%eax
  8040de:	74 1e                	je     8040fe <mem_free+0xe0>
  8040e0:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8040e4:	75 18                	jne    8040fe <mem_free+0xe0>
    if (lfree == mem) {
  8040e6:	3b 05 04 63 81 00    	cmp    0x816304,%eax
  8040ec:	0f 84 b8 00 00 00    	je     8041aa <mem_free+0x18c>
    pmem->next = mem->next;
  8040f2:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040f5:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8040f7:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8040fa:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8040fe:	83 ec 0c             	sub    $0xc,%esp
  804101:	ff 35 00 63 81 00    	pushl  0x816300
  804107:	e8 68 60 00 00       	call   80a174 <sys_sem_signal>
  80410c:	83 c4 10             	add    $0x10,%esp
}
  80410f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804112:	5b                   	pop    %ebx
  804113:	5e                   	pop    %esi
  804114:	5d                   	pop    %ebp
  804115:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804116:	83 ec 04             	sub    $0x4,%esp
  804119:	68 54 1c 81 00       	push   $0x811c54
  80411e:	68 30 01 00 00       	push   $0x130
  804123:	68 4b 1d 81 00       	push   $0x811d4b
  804128:	e8 42 a6 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80412d:	83 ec 04             	sub    $0x4,%esp
  804130:	68 5f 1d 81 00       	push   $0x811d5f
  804135:	68 33 01 00 00       	push   $0x133
  80413a:	68 4b 1d 81 00       	push   $0x811d4b
  80413f:	e8 2b a6 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804144:	83 ec 04             	sub    $0x4,%esp
  804147:	68 76 1d 81 00       	push   $0x811d76
  80414c:	68 43 01 00 00       	push   $0x143
  804151:	68 4b 1d 81 00       	push   $0x811d4b
  804156:	e8 14 a6 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80415b:	83 ec 04             	sub    $0x4,%esp
  80415e:	68 8a 1d 81 00       	push   $0x811d8a
  804163:	68 e3 00 00 00       	push   $0xe3
  804168:	68 4b 1d 81 00       	push   $0x811d4b
  80416d:	e8 fd a5 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804172:	83 ec 04             	sub    $0x4,%esp
  804175:	68 a1 1d 81 00       	push   $0x811da1
  80417a:	68 e4 00 00 00       	push   $0xe4
  80417f:	68 4b 1d 81 00       	push   $0x811d4b
  804184:	e8 e6 a5 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804189:	83 ec 04             	sub    $0x4,%esp
  80418c:	68 78 1c 81 00       	push   $0x811c78
  804191:	68 e8 00 00 00       	push   $0xe8
  804196:	68 4b 1d 81 00       	push   $0x811d4b
  80419b:	e8 cf a5 00 00       	call   80e76f <_panic>
      lfree = mem;
  8041a0:	a3 04 63 81 00       	mov    %eax,0x816304
  8041a5:	e9 1d ff ff ff       	jmp    8040c7 <mem_free+0xa9>
      lfree = pmem;
  8041aa:	89 15 04 63 81 00    	mov    %edx,0x816304
  8041b0:	e9 3d ff ff ff       	jmp    8040f2 <mem_free+0xd4>

008041b5 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8041b5:	55                   	push   %ebp
  8041b6:	89 e5                	mov    %esp,%ebp
  8041b8:	57                   	push   %edi
  8041b9:	56                   	push   %esi
  8041ba:	53                   	push   %ebx
  8041bb:	83 ec 1c             	sub    $0x1c,%esp
  8041be:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8041c1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8041c4:	8d 58 03             	lea    0x3(%eax),%ebx
  8041c7:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8041ca:	83 fb 0b             	cmp    $0xb,%ebx
  8041cd:	76 12                	jbe    8041e1 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8041cf:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8041d5:	76 0f                	jbe    8041e6 <mem_realloc+0x31>
    return NULL;
  8041d7:	be 00 00 00 00       	mov    $0x0,%esi
  8041dc:	e9 a1 00 00 00       	jmp    804282 <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  8041e1:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8041e6:	a1 0c 63 81 00       	mov    0x81630c,%eax
  8041eb:	39 f0                	cmp    %esi,%eax
  8041ed:	0f 87 99 00 00 00    	ja     80428c <mem_realloc+0xd7>
  8041f3:	39 35 08 63 81 00    	cmp    %esi,0x816308
  8041f9:	0f 86 8d 00 00 00    	jbe    80428c <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8041ff:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804202:	29 c2                	sub    %eax,%edx
  804204:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  804207:	8b 4e f4             	mov    -0xc(%esi),%ecx
  80420a:	8d 79 f4             	lea    -0xc(%ecx),%edi
  80420d:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80420f:	39 df                	cmp    %ebx,%edi
  804211:	0f 82 8c 00 00 00    	jb     8042a3 <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804217:	74 69                	je     804282 <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804219:	83 ec 08             	sub    $0x8,%esp
  80421c:	6a 00                	push   $0x0
  80421e:	ff 35 00 63 81 00    	pushl  0x816300
  804224:	e8 bb 5f 00 00       	call   80a1e4 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804229:	a1 0c 63 81 00       	mov    0x81630c,%eax
  80422e:	89 c2                	mov    %eax,%edx
  804230:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804233:	83 c4 10             	add    $0x10,%esp
  804236:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80423a:	0f 85 85 00 00 00    	jne    8042c5 <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804240:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804242:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804245:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804249:	39 15 04 63 81 00    	cmp    %edx,0x816304
  80424f:	74 69                	je     8042ba <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804251:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804254:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804258:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80425a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80425d:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804260:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804263:	8b 12                	mov    (%edx),%edx
  804265:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80426b:	74 04                	je     804271 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80426d:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804271:	83 ec 0c             	sub    $0xc,%esp
  804274:	ff 35 00 63 81 00    	pushl  0x816300
  80427a:	e8 f5 5e 00 00       	call   80a174 <sys_sem_signal>
  return rmem;
  80427f:	83 c4 10             	add    $0x10,%esp
}
  804282:	89 f0                	mov    %esi,%eax
  804284:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804287:	5b                   	pop    %ebx
  804288:	5e                   	pop    %esi
  804289:	5f                   	pop    %edi
  80428a:	5d                   	pop    %ebp
  80428b:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80428c:	83 ec 04             	sub    $0x4,%esp
  80428f:	68 bb 1d 81 00       	push   $0x811dbb
  804294:	68 79 01 00 00       	push   $0x179
  804299:	68 4b 1d 81 00       	push   $0x811d4b
  80429e:	e8 cc a4 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8042a3:	83 ec 04             	sub    $0x4,%esp
  8042a6:	68 a4 1c 81 00       	push   $0x811ca4
  8042ab:	68 8a 01 00 00       	push   $0x18a
  8042b0:	68 4b 1d 81 00       	push   $0x811d4b
  8042b5:	e8 b5 a4 00 00       	call   80e76f <_panic>
      lfree = (struct mem *)&ram[ptr2];
  8042ba:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8042bd:	89 15 04 63 81 00    	mov    %edx,0x816304
  8042c3:	eb 8c                	jmp    804251 <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8042c5:	8d 53 18             	lea    0x18(%ebx),%edx
  8042c8:	39 fa                	cmp    %edi,%edx
  8042ca:	77 a5                	ja     804271 <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8042cc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8042cf:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8042d3:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8042d6:	39 15 04 63 81 00    	cmp    %edx,0x816304
  8042dc:	76 06                	jbe    8042e4 <mem_realloc+0x12f>
      lfree = mem2;
  8042de:	89 15 04 63 81 00    	mov    %edx,0x816304
    mem2->used = 0;
  8042e4:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8042e8:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8042eb:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8042ed:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042f0:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8042f3:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8042f6:	8b 12                	mov    (%edx),%edx
  8042f8:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8042fe:	0f 84 6d ff ff ff    	je     804271 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804304:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  804308:	e9 64 ff ff ff       	jmp    804271 <mem_realloc+0xbc>

0080430d <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80430d:	55                   	push   %ebp
  80430e:	89 e5                	mov    %esp,%ebp
  804310:	57                   	push   %edi
  804311:	56                   	push   %esi
  804312:	53                   	push   %ebx
  804313:	83 ec 1c             	sub    $0x1c,%esp
  804316:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804319:	85 c0                	test   %eax,%eax
  80431b:	0f 84 a0 01 00 00    	je     8044c1 <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804321:	83 c0 03             	add    $0x3,%eax
  804324:	83 e0 fc             	and    $0xfffffffc,%eax
  804327:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  804329:	83 f8 0b             	cmp    $0xb,%eax
  80432c:	76 3a                	jbe    804368 <mem_malloc+0x5b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80432e:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804333:	0f 87 8f 01 00 00    	ja     8044c8 <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804339:	83 ec 08             	sub    $0x8,%esp
  80433c:	6a 00                	push   $0x0
  80433e:	ff 35 00 63 81 00    	pushl  0x816300
  804344:	e8 9b 5e 00 00       	call   80a1e4 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804349:	a1 04 63 81 00       	mov    0x816304,%eax
  80434e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804351:	8b 35 0c 63 81 00    	mov    0x81630c,%esi
  804357:	29 f0                	sub    %esi,%eax
  804359:	83 c4 10             	add    $0x10,%esp
  80435c:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804361:	29 f9                	sub    %edi,%ecx
  804363:	e9 e2 00 00 00       	jmp    80444a <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  804368:	bf 0c 00 00 00       	mov    $0xc,%edi
  80436d:	eb ca                	jmp    804339 <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80436f:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804373:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804376:	74 4c                	je     8043c4 <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804378:	83 ec 0c             	sub    $0xc,%esp
  80437b:	ff 35 00 63 81 00    	pushl  0x816300
  804381:	e8 ee 5d 00 00       	call   80a174 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804386:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  80438a:	83 c4 10             	add    $0x10,%esp
  80438d:	39 05 08 63 81 00    	cmp    %eax,0x816308
  804393:	0f 82 81 00 00 00    	jb     80441a <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804399:	8d 43 0c             	lea    0xc(%ebx),%eax
  80439c:	a8 03                	test   $0x3,%al
  80439e:	0f 85 8d 00 00 00    	jne    804431 <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  8043a4:	f6 c3 03             	test   $0x3,%bl
  8043a7:	0f 84 0c 01 00 00    	je     8044b9 <mem_malloc+0x1ac>
  8043ad:	83 ec 04             	sub    $0x4,%esp
  8043b0:	68 28 1d 81 00       	push   $0x811d28
  8043b5:	68 4f 02 00 00       	push   $0x24f
  8043ba:	68 4b 1d 81 00       	push   $0x811d4b
  8043bf:	e8 ab a3 00 00       	call   80e76f <_panic>
          while (lfree->used && lfree != ram_end) {
  8043c4:	8b 15 08 63 81 00    	mov    0x816308,%edx
  8043ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8043cf:	b9 01 00 00 00       	mov    $0x1,%ecx
  8043d4:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8043d7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8043da:	eb 08                	jmp    8043e4 <mem_malloc+0xd7>
            lfree = (struct mem *)&ram[lfree->next];
  8043dc:	89 f0                	mov    %esi,%eax
  8043de:	03 07                	add    (%edi),%eax
  8043e0:	89 c7                	mov    %eax,%edi
  8043e2:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8043e4:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8043e8:	74 18                	je     804402 <mem_malloc+0xf5>
  8043ea:	39 fa                	cmp    %edi,%edx
  8043ec:	75 ee                	jne    8043dc <mem_malloc+0xcf>
  8043ee:	89 fe                	mov    %edi,%esi
  8043f0:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8043f3:	84 c0                	test   %al,%al
  8043f5:	74 81                	je     804378 <mem_malloc+0x6b>
  8043f7:	89 35 04 63 81 00    	mov    %esi,0x816304
  8043fd:	e9 76 ff ff ff       	jmp    804378 <mem_malloc+0x6b>
  804402:	89 fe                	mov    %edi,%esi
  804404:	8b 7d e0             	mov    -0x20(%ebp),%edi
  804407:	84 c0                	test   %al,%al
  804409:	0f 84 69 ff ff ff    	je     804378 <mem_malloc+0x6b>
  80440f:	89 35 04 63 81 00    	mov    %esi,0x816304
  804415:	e9 5e ff ff ff       	jmp    804378 <mem_malloc+0x6b>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80441a:	83 ec 04             	sub    $0x4,%esp
  80441d:	68 c8 1c 81 00       	push   $0x811cc8
  804422:	68 4b 02 00 00       	push   $0x24b
  804427:	68 4b 1d 81 00       	push   $0x811d4b
  80442c:	e8 3e a3 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804431:	83 ec 04             	sub    $0x4,%esp
  804434:	68 f8 1c 81 00       	push   $0x811cf8
  804439:	68 4d 02 00 00       	push   $0x24d
  80443e:	68 4b 1d 81 00       	push   $0x811d4b
  804443:	e8 27 a3 00 00       	call   80e76f <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804448:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80444a:	39 c1                	cmp    %eax,%ecx
  80444c:	76 55                	jbe    8044a3 <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  80444e:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  804451:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804455:	75 f1                	jne    804448 <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804457:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  80445c:	29 c2                	sub    %eax,%edx
  80445e:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  804460:	39 fa                	cmp    %edi,%edx
  804462:	72 e4                	jb     804448 <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804464:	8d 4f 18             	lea    0x18(%edi),%ecx
  804467:	39 ca                	cmp    %ecx,%edx
  804469:	0f 82 00 ff ff ff    	jb     80436f <mem_malloc+0x62>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80446f:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  804473:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804476:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804479:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80447d:	8b 0b                	mov    (%ebx),%ecx
  80447f:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804481:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804484:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804487:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  804489:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  80448d:	8b 02                	mov    (%edx),%eax
  80448f:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804494:	0f 84 d9 fe ff ff    	je     804373 <mem_malloc+0x66>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80449a:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  80449e:	e9 d0 fe ff ff       	jmp    804373 <mem_malloc+0x66>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  8044a3:	83 ec 0c             	sub    $0xc,%esp
  8044a6:	ff 35 00 63 81 00    	pushl  0x816300
  8044ac:	e8 c3 5c 00 00       	call   80a174 <sys_sem_signal>
  return NULL;
  8044b1:	83 c4 10             	add    $0x10,%esp
  8044b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8044b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8044bc:	5b                   	pop    %ebx
  8044bd:	5e                   	pop    %esi
  8044be:	5f                   	pop    %edi
  8044bf:	5d                   	pop    %ebp
  8044c0:	c3                   	ret    
    return NULL;
  8044c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8044c6:	eb f1                	jmp    8044b9 <mem_malloc+0x1ac>
    return NULL;
  8044c8:	b8 00 00 00 00       	mov    $0x0,%eax
  8044cd:	eb ea                	jmp    8044b9 <mem_malloc+0x1ac>

008044cf <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8044cf:	55                   	push   %ebp
  8044d0:	89 e5                	mov    %esp,%ebp
  8044d2:	56                   	push   %esi
  8044d3:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8044d4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8044d7:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8044db:	83 ec 0c             	sub    $0xc,%esp
  8044de:	53                   	push   %ebx
  8044df:	e8 29 fe ff ff       	call   80430d <mem_malloc>
  8044e4:	89 c6                	mov    %eax,%esi
  if (p) {
  8044e6:	83 c4 10             	add    $0x10,%esp
  8044e9:	85 c0                	test   %eax,%eax
  8044eb:	74 0f                	je     8044fc <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8044ed:	83 ec 04             	sub    $0x4,%esp
  8044f0:	53                   	push   %ebx
  8044f1:	6a 00                	push   $0x0
  8044f3:	50                   	push   %eax
  8044f4:	e8 11 ac 00 00       	call   80f10a <memset>
  8044f9:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8044fc:	89 f0                	mov    %esi,%eax
  8044fe:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804501:	5b                   	pop    %ebx
  804502:	5e                   	pop    %esi
  804503:	5d                   	pop    %ebp
  804504:	c3                   	ret    

00804505 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  804505:	55                   	push   %ebp
  804506:	89 e5                	mov    %esp,%ebp
  804508:	56                   	push   %esi
  804509:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80450a:	b8 43 63 a3 00       	mov    $0xa36343,%eax
  80450f:	83 e0 fc             	and    $0xfffffffc,%eax
  804512:	ba 00 00 00 00       	mov    $0x0,%edx
  804517:	eb 08                	jmp    804521 <memp_init+0x1c>
  804519:	83 c2 01             	add    $0x1,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80451c:	83 fa 0e             	cmp    $0xe,%edx
  80451f:	74 3c                	je     80455d <memp_init+0x58>
    memp_tab[i] = NULL;
  804521:	c7 04 95 c0 53 b3 00 	movl   $0x0,0xb353c0(,%edx,4)
  804528:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80452c:	0f b7 b4 12 4c 1e 81 	movzwl 0x811e4c(%edx,%edx,1),%esi
  804533:	00 
  804534:	b9 00 00 00 00       	mov    $0x0,%ecx
  804539:	66 39 ce             	cmp    %cx,%si
  80453c:	74 db                	je     804519 <memp_init+0x14>
      memp->next = memp_tab[i];
  80453e:	8b 1c 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%ebx
  804545:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804547:	89 04 95 c0 53 b3 00 	mov    %eax,0xb353c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80454e:	0f b7 9c 12 68 1e 81 	movzwl 0x811e68(%edx,%edx,1),%ebx
  804555:	00 
  804556:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804558:	83 c1 01             	add    $0x1,%ecx
  80455b:	eb dc                	jmp    804539 <memp_init+0x34>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80455d:	5b                   	pop    %ebx
  80455e:	5e                   	pop    %esi
  80455f:	5d                   	pop    %ebp
  804560:	c3                   	ret    

00804561 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804561:	55                   	push   %ebp
  804562:	89 e5                	mov    %esp,%ebp
  804564:	83 ec 08             	sub    $0x8,%esp
  804567:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80456a:	83 fa 0d             	cmp    $0xd,%edx
  80456d:	77 1a                	ja     804589 <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80456f:	8b 04 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804576:	85 c0                	test   %eax,%eax
  804578:	74 0d                	je     804587 <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  80457a:	8b 08                	mov    (%eax),%ecx
  80457c:	89 0c 95 c0 53 b3 00 	mov    %ecx,0xb353c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804583:	a8 03                	test   $0x3,%al
  804585:	75 19                	jne    8045a0 <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804587:	c9                   	leave  
  804588:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804589:	83 ec 04             	sub    $0x4,%esp
  80458c:	68 d5 1d 81 00       	push   $0x811dd5
  804591:	68 2d 01 00 00       	push   $0x12d
  804596:	68 f2 1d 81 00       	push   $0x811df2
  80459b:	e8 cf a1 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  8045a0:	83 ec 04             	sub    $0x4,%esp
  8045a3:	68 08 1e 81 00       	push   $0x811e08
  8045a8:	68 3f 01 00 00       	push   $0x13f
  8045ad:	68 f2 1d 81 00       	push   $0x811df2
  8045b2:	e8 b8 a1 00 00       	call   80e76f <_panic>

008045b7 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8045b7:	55                   	push   %ebp
  8045b8:	89 e5                	mov    %esp,%ebp
  8045ba:	83 ec 08             	sub    $0x8,%esp
  8045bd:	8b 55 08             	mov    0x8(%ebp),%edx
  8045c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8045c3:	85 c0                	test   %eax,%eax
  8045c5:	74 14                	je     8045db <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8045c7:	a8 03                	test   $0x3,%al
  8045c9:	75 12                	jne    8045dd <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8045cb:	8b 0c 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%ecx
  8045d2:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8045d4:	89 04 95 c0 53 b3 00 	mov    %eax,0xb353c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8045db:	c9                   	leave  
  8045dc:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8045dd:	83 ec 04             	sub    $0x4,%esp
  8045e0:	68 2c 1e 81 00       	push   $0x811e2c
  8045e5:	68 5b 01 00 00       	push   $0x15b
  8045ea:	68 f2 1d 81 00       	push   $0x811df2
  8045ef:	e8 7b a1 00 00       	call   80e76f <_panic>

008045f4 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8045f4:	55                   	push   %ebp
  8045f5:	89 e5                	mov    %esp,%ebp
  8045f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8045fa:	85 c9                	test   %ecx,%ecx
  8045fc:	74 2c                	je     80462a <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8045fe:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  804603:	39 c8                	cmp    %ecx,%eax
  804605:	74 0e                	je     804615 <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804607:	85 c0                	test   %eax,%eax
  804609:	74 1f                	je     80462a <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  80460b:	8b 10                	mov    (%eax),%edx
  80460d:	39 ca                	cmp    %ecx,%edx
  80460f:	74 0d                	je     80461e <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804611:	89 d0                	mov    %edx,%eax
  804613:	eb f2                	jmp    804607 <netif_remove+0x13>
    netif_list = netif->next;
  804615:	8b 01                	mov    (%ecx),%eax
  804617:	a3 34 c2 b3 00       	mov    %eax,0xb3c234
  80461c:	eb 04                	jmp    804622 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  80461e:	8b 11                	mov    (%ecx),%edx
  804620:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804622:	39 0d 38 c2 b3 00    	cmp    %ecx,0xb3c238
  804628:	74 02                	je     80462c <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80462a:	5d                   	pop    %ebp
  80462b:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80462c:	c7 05 38 c2 b3 00 00 	movl   $0x0,0xb3c238
  804633:	00 00 00 
  804636:	eb f2                	jmp    80462a <netif_remove+0x36>

00804638 <netif_find>:
{
  804638:	55                   	push   %ebp
  804639:	89 e5                	mov    %esp,%ebp
  80463b:	53                   	push   %ebx
  80463c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  80463f:	85 c9                	test   %ecx,%ecx
  804641:	74 2d                	je     804670 <netif_find+0x38>
  num = name[2] - '0';
  804643:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804647:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80464a:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  80464f:	eb 02                	jmp    804653 <netif_find+0x1b>
  804651:	8b 00                	mov    (%eax),%eax
  804653:	85 c0                	test   %eax,%eax
  804655:	74 16                	je     80466d <netif_find+0x35>
    if (num == netif->num &&
  804657:	38 50 31             	cmp    %dl,0x31(%eax)
  80465a:	75 f5                	jne    804651 <netif_find+0x19>
  80465c:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804660:	38 19                	cmp    %bl,(%ecx)
  804662:	75 ed                	jne    804651 <netif_find+0x19>
       name[0] == netif->name[0] &&
  804664:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804668:	38 59 01             	cmp    %bl,0x1(%ecx)
  80466b:	75 e4                	jne    804651 <netif_find+0x19>
}
  80466d:	5b                   	pop    %ebx
  80466e:	5d                   	pop    %ebp
  80466f:	c3                   	ret    
    return NULL;
  804670:	89 c8                	mov    %ecx,%eax
  804672:	eb f9                	jmp    80466d <netif_find+0x35>

00804674 <netif_set_ipaddr>:
{
  804674:	55                   	push   %ebp
  804675:	89 e5                	mov    %esp,%ebp
  804677:	57                   	push   %edi
  804678:	56                   	push   %esi
  804679:	53                   	push   %ebx
  80467a:	83 ec 0c             	sub    $0xc,%esp
  80467d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804680:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804683:	8b 43 04             	mov    0x4(%ebx),%eax
  804686:	39 06                	cmp    %eax,(%esi)
  804688:	74 47                	je     8046d1 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  80468a:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
    while (pcb != NULL) {
  80468f:	eb 11                	jmp    8046a2 <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  804691:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804694:	83 ec 0c             	sub    $0xc,%esp
  804697:	50                   	push   %eax
  804698:	e8 cd 15 00 00       	call   805c6a <tcp_abort>
  80469d:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  8046a0:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  8046a2:	85 c0                	test   %eax,%eax
  8046a4:	74 0c                	je     8046b2 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8046a6:	8b 4b 04             	mov    0x4(%ebx),%ecx
  8046a9:	39 08                	cmp    %ecx,(%eax)
  8046ab:	74 e4                	je     804691 <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  8046ad:	8b 40 0c             	mov    0xc(%eax),%eax
  8046b0:	eb f0                	jmp    8046a2 <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8046b2:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  8046b7:	eb 03                	jmp    8046bc <netif_set_ipaddr+0x48>
  8046b9:	8b 40 0c             	mov    0xc(%eax),%eax
  8046bc:	85 c0                	test   %eax,%eax
  8046be:	74 11                	je     8046d1 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8046c0:	8b 10                	mov    (%eax),%edx
  8046c2:	85 d2                	test   %edx,%edx
  8046c4:	74 f3                	je     8046b9 <netif_set_ipaddr+0x45>
  8046c6:	3b 53 04             	cmp    0x4(%ebx),%edx
  8046c9:	75 ee                	jne    8046b9 <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8046cb:	8b 16                	mov    (%esi),%edx
  8046cd:	89 10                	mov    %edx,(%eax)
  8046cf:	eb e8                	jmp    8046b9 <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8046d1:	8b 06                	mov    (%esi),%eax
  8046d3:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8046d6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8046d9:	5b                   	pop    %ebx
  8046da:	5e                   	pop    %esi
  8046db:	5f                   	pop    %edi
  8046dc:	5d                   	pop    %ebp
  8046dd:	c3                   	ret    

008046de <netif_set_addr>:
{
  8046de:	55                   	push   %ebp
  8046df:	89 e5                	mov    %esp,%ebp
  8046e1:	57                   	push   %edi
  8046e2:	56                   	push   %esi
  8046e3:	53                   	push   %ebx
  8046e4:	83 ec 14             	sub    $0x14,%esp
  8046e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8046ea:	8b 7d 10             	mov    0x10(%ebp),%edi
  8046ed:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8046f0:	ff 75 0c             	pushl  0xc(%ebp)
  8046f3:	53                   	push   %ebx
  8046f4:	e8 7b ff ff ff       	call   804674 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8046f9:	83 c4 10             	add    $0x10,%esp
  8046fc:	b8 00 00 00 00       	mov    $0x0,%eax
  804701:	85 ff                	test   %edi,%edi
  804703:	74 02                	je     804707 <netif_set_addr+0x29>
  804705:	8b 07                	mov    (%edi),%eax
  804707:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  80470a:	b8 00 00 00 00       	mov    $0x0,%eax
  80470f:	85 f6                	test   %esi,%esi
  804711:	74 02                	je     804715 <netif_set_addr+0x37>
  804713:	8b 06                	mov    (%esi),%eax
  804715:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  804718:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80471b:	5b                   	pop    %ebx
  80471c:	5e                   	pop    %esi
  80471d:	5f                   	pop    %edi
  80471e:	5d                   	pop    %ebp
  80471f:	c3                   	ret    

00804720 <netif_add>:
{
  804720:	55                   	push   %ebp
  804721:	89 e5                	mov    %esp,%ebp
  804723:	53                   	push   %ebx
  804724:	83 ec 04             	sub    $0x4,%esp
  804727:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  80472a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804731:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804738:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80473f:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804743:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  80474a:	8b 45 18             	mov    0x18(%ebp),%eax
  80474d:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804750:	0f b6 05 f8 53 b3 00 	movzbl 0xb353f8,%eax
  804757:	8d 50 01             	lea    0x1(%eax),%edx
  80475a:	88 15 f8 53 b3 00    	mov    %dl,0xb353f8
  804760:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804763:	8b 45 20             	mov    0x20(%ebp),%eax
  804766:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804769:	ff 75 14             	pushl  0x14(%ebp)
  80476c:	ff 75 10             	pushl  0x10(%ebp)
  80476f:	ff 75 0c             	pushl  0xc(%ebp)
  804772:	53                   	push   %ebx
  804773:	e8 66 ff ff ff       	call   8046de <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804778:	89 1c 24             	mov    %ebx,(%esp)
  80477b:	ff 55 1c             	call   *0x1c(%ebp)
  80477e:	83 c4 10             	add    $0x10,%esp
  804781:	84 c0                	test   %al,%al
  804783:	75 14                	jne    804799 <netif_add+0x79>
  netif->next = netif_list;
  804785:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  80478a:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80478c:	89 1d 34 c2 b3 00    	mov    %ebx,0xb3c234
  return netif;
  804792:	89 d8                	mov    %ebx,%eax
}
  804794:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804797:	c9                   	leave  
  804798:	c3                   	ret    
    return NULL;
  804799:	b8 00 00 00 00       	mov    $0x0,%eax
  80479e:	eb f4                	jmp    804794 <netif_add+0x74>

008047a0 <netif_set_gw>:
{
  8047a0:	55                   	push   %ebp
  8047a1:	89 e5                	mov    %esp,%ebp
  8047a3:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8047a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8047ab:	85 d2                	test   %edx,%edx
  8047ad:	74 02                	je     8047b1 <netif_set_gw+0x11>
  8047af:	8b 02                	mov    (%edx),%eax
  8047b1:	8b 55 08             	mov    0x8(%ebp),%edx
  8047b4:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8047b7:	5d                   	pop    %ebp
  8047b8:	c3                   	ret    

008047b9 <netif_set_netmask>:
{
  8047b9:	55                   	push   %ebp
  8047ba:	89 e5                	mov    %esp,%ebp
  8047bc:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  8047bf:	b8 00 00 00 00       	mov    $0x0,%eax
  8047c4:	85 d2                	test   %edx,%edx
  8047c6:	74 02                	je     8047ca <netif_set_netmask+0x11>
  8047c8:	8b 02                	mov    (%edx),%eax
  8047ca:	8b 55 08             	mov    0x8(%ebp),%edx
  8047cd:	89 42 08             	mov    %eax,0x8(%edx)
}
  8047d0:	5d                   	pop    %ebp
  8047d1:	c3                   	ret    

008047d2 <netif_set_default>:
{
  8047d2:	55                   	push   %ebp
  8047d3:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8047d5:	8b 45 08             	mov    0x8(%ebp),%eax
  8047d8:	a3 38 c2 b3 00       	mov    %eax,0xb3c238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8047dd:	5d                   	pop    %ebp
  8047de:	c3                   	ret    

008047df <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8047df:	55                   	push   %ebp
  8047e0:	89 e5                	mov    %esp,%ebp
  8047e2:	83 ec 08             	sub    $0x8,%esp
  8047e5:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8047e8:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8047ec:	a8 01                	test   $0x1,%al
  8047ee:	75 0c                	jne    8047fc <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  8047f0:	89 c1                	mov    %eax,%ecx
  8047f2:	83 c9 01             	or     $0x1,%ecx
  8047f5:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8047f8:	a8 20                	test   $0x20,%al
  8047fa:	75 02                	jne    8047fe <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  8047fc:	c9                   	leave  
  8047fd:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  8047fe:	83 ec 04             	sub    $0x4,%esp
  804801:	6a 00                	push   $0x0
  804803:	8d 42 04             	lea    0x4(%edx),%eax
  804806:	50                   	push   %eax
  804807:	52                   	push   %edx
  804808:	e8 d8 51 00 00       	call   8099e5 <etharp_query>
  80480d:	83 c4 10             	add    $0x10,%esp
}
  804810:	eb ea                	jmp    8047fc <netif_set_up+0x1d>

00804812 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804812:	55                   	push   %ebp
  804813:	89 e5                	mov    %esp,%ebp
  804815:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804818:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80481c:	a8 01                	test   $0x1,%al
  80481e:	74 06                	je     804826 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804820:	83 e0 fe             	and    $0xfffffffe,%eax
  804823:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804826:	5d                   	pop    %ebp
  804827:	c3                   	ret    

00804828 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804828:	55                   	push   %ebp
  804829:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80482b:	8b 45 08             	mov    0x8(%ebp),%eax
  80482e:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804832:	83 e0 01             	and    $0x1,%eax
}
  804835:	5d                   	pop    %ebp
  804836:	c3                   	ret    

00804837 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804837:	55                   	push   %ebp
  804838:	89 e5                	mov    %esp,%ebp
  80483a:	56                   	push   %esi
  80483b:	53                   	push   %ebx
  80483c:	8b 55 08             	mov    0x8(%ebp),%edx
  80483f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804842:	85 d2                	test   %edx,%edx
  804844:	74 42                	je     804888 <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  804846:	66 85 c9             	test   %cx,%cx
  804849:	0f 84 ae 00 00 00    	je     8048fd <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80484f:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  804851:	78 4c                	js     80489f <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804853:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804857:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80485a:	66 85 c0             	test   %ax,%ax
  80485d:	74 5f                	je     8048be <pbuf_header+0x87>
  80485f:	66 83 f8 03          	cmp    $0x3,%ax
  804863:	74 59                	je     8048be <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804865:	83 e8 01             	sub    $0x1,%eax
  804868:	66 83 f8 01          	cmp    $0x1,%ax
  80486c:	77 78                	ja     8048e6 <pbuf_header+0xaf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80486e:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804873:	66 85 c9             	test   %cx,%cx
  804876:	79 67                	jns    8048df <pbuf_header+0xa8>
  804878:	66 39 72 0a          	cmp    %si,0xa(%edx)
  80487c:	72 61                	jb     8048df <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  80487e:	0f bf c1             	movswl %cx,%eax
  804881:	29 c3                	sub    %eax,%ebx
  804883:	89 5a 04             	mov    %ebx,0x4(%edx)
  804886:	eb 4a                	jmp    8048d2 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  804888:	83 ec 04             	sub    $0x4,%esp
  80488b:	68 48 1f 81 00       	push   $0x811f48
  804890:	68 64 01 00 00       	push   $0x164
  804895:	68 84 1e 81 00       	push   $0x811e84
  80489a:	e8 d0 9e 00 00       	call   80e76f <_panic>
    increment_magnitude = -header_size_increment;
  80489f:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  8048a1:	66 39 72 0a          	cmp    %si,0xa(%edx)
  8048a5:	73 ac                	jae    804853 <pbuf_header+0x1c>
  8048a7:	83 ec 04             	sub    $0x4,%esp
  8048aa:	68 99 1e 81 00       	push   $0x811e99
  8048af:	68 6b 01 00 00       	push   $0x16b
  8048b4:	68 84 1e 81 00       	push   $0x811e84
  8048b9:	e8 b1 9e 00 00       	call   80e76f <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8048be:	0f bf c1             	movswl %cx,%eax
  8048c1:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8048c3:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  8048c6:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8048cb:	39 f3                	cmp    %esi,%ebx
  8048cd:	72 10                	jb     8048df <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8048cf:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8048d2:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8048d6:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8048da:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8048df:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048e2:	5b                   	pop    %ebx
  8048e3:	5e                   	pop    %esi
  8048e4:	5d                   	pop    %ebp
  8048e5:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  8048e6:	83 ec 04             	sub    $0x4,%esp
  8048e9:	68 b7 1e 81 00       	push   $0x811eb7
  8048ee:	68 9a 01 00 00       	push   $0x19a
  8048f3:	68 84 1e 81 00       	push   $0x811e84
  8048f8:	e8 72 9e 00 00       	call   80e76f <_panic>
    return 0;
  8048fd:	b8 00 00 00 00       	mov    $0x0,%eax
  804902:	eb db                	jmp    8048df <pbuf_header+0xa8>

00804904 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804904:	55                   	push   %ebp
  804905:	89 e5                	mov    %esp,%ebp
  804907:	56                   	push   %esi
  804908:	53                   	push   %ebx
  804909:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80490c:	85 c0                	test   %eax,%eax
  80490e:	74 0d                	je     80491d <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804910:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  804914:	77 1e                	ja     804934 <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  804916:	bb 00 00 00 00       	mov    $0x0,%ebx
  80491b:	eb 6c                	jmp    804989 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  80491d:	83 ec 04             	sub    $0x4,%esp
  804920:	68 48 1f 81 00       	push   $0x811f48
  804925:	68 d0 01 00 00       	push   $0x1d0
  80492a:	68 84 1e 81 00       	push   $0x811e84
  80492f:	e8 3b 9e 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804934:	83 ec 04             	sub    $0x4,%esp
  804937:	68 c5 1e 81 00       	push   $0x811ec5
  80493c:	68 db 01 00 00       	push   $0x1db
  804941:	68 84 1e 81 00       	push   $0x811e84
  804946:	e8 24 9e 00 00       	call   80e76f <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80494b:	83 ec 04             	sub    $0x4,%esp
  80494e:	68 da 1e 81 00       	push   $0x811eda
  804953:	68 e8 01 00 00       	push   $0x1e8
  804958:	68 84 1e 81 00       	push   $0x811e84
  80495d:	e8 0d 9e 00 00       	call   80e76f <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804962:	83 ec 08             	sub    $0x8,%esp
  804965:	50                   	push   %eax
  804966:	6a 0d                	push   $0xd
  804968:	e8 4a fc ff ff       	call   8045b7 <memp_free>
  80496d:	83 c4 10             	add    $0x10,%esp
  804970:	eb 0e                	jmp    804980 <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804972:	83 ec 08             	sub    $0x8,%esp
  804975:	50                   	push   %eax
  804976:	6a 0c                	push   $0xc
  804978:	e8 3a fc ff ff       	call   8045b7 <memp_free>
  80497d:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  804980:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  804983:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  804985:	85 f6                	test   %esi,%esi
  804987:	74 38                	je     8049c1 <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804989:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  80498d:	66 85 d2             	test   %dx,%dx
  804990:	74 b9                	je     80494b <pbuf_free+0x47>
    ref = --(p->ref);
  804992:	83 ea 01             	sub    $0x1,%edx
  804995:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804999:	66 85 d2             	test   %dx,%dx
  80499c:	75 23                	jne    8049c1 <pbuf_free+0xbd>
      q = p->next;
  80499e:	8b 30                	mov    (%eax),%esi
      type = p->type;
  8049a0:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  8049a4:	66 83 fa 03          	cmp    $0x3,%dx
  8049a8:	74 b8                	je     804962 <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  8049aa:	83 ea 01             	sub    $0x1,%edx
  8049ad:	66 83 fa 01          	cmp    $0x1,%dx
  8049b1:	76 bf                	jbe    804972 <pbuf_free+0x6e>
        mem_free(p);
  8049b3:	83 ec 0c             	sub    $0xc,%esp
  8049b6:	50                   	push   %eax
  8049b7:	e8 62 f6 ff ff       	call   80401e <mem_free>
  8049bc:	83 c4 10             	add    $0x10,%esp
  8049bf:	eb bf                	jmp    804980 <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8049c1:	89 d8                	mov    %ebx,%eax
  8049c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8049c6:	5b                   	pop    %ebx
  8049c7:	5e                   	pop    %esi
  8049c8:	5d                   	pop    %ebp
  8049c9:	c3                   	ret    

008049ca <pbuf_alloc>:
{
  8049ca:	55                   	push   %ebp
  8049cb:	89 e5                	mov    %esp,%ebp
  8049cd:	57                   	push   %edi
  8049ce:	56                   	push   %esi
  8049cf:	53                   	push   %ebx
  8049d0:	83 ec 1c             	sub    $0x1c,%esp
  8049d3:	8b 45 08             	mov    0x8(%ebp),%eax
  8049d6:	8b 75 0c             	mov    0xc(%ebp),%esi
  8049d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  8049dc:	83 f8 01             	cmp    $0x1,%eax
  8049df:	0f 84 8a 00 00 00    	je     804a6f <pbuf_alloc+0xa5>
  8049e5:	85 c0                	test   %eax,%eax
  8049e7:	0f 84 89 00 00 00    	je     804a76 <pbuf_alloc+0xac>
  8049ed:	83 f8 02             	cmp    $0x2,%eax
  8049f0:	0f 84 94 00 00 00    	je     804a8a <pbuf_alloc+0xc0>
  8049f6:	83 f8 03             	cmp    $0x3,%eax
  8049f9:	0f 85 92 00 00 00    	jne    804a91 <pbuf_alloc+0xc7>
  offset = 0;
  8049ff:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804a05:	83 fb 02             	cmp    $0x2,%ebx
  804a08:	0f 87 9a 00 00 00    	ja     804aa8 <pbuf_alloc+0xde>
  804a0e:	85 db                	test   %ebx,%ebx
  804a10:	0f 85 db 01 00 00    	jne    804bf1 <pbuf_alloc+0x227>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804a16:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804a1a:	83 ec 0c             	sub    $0xc,%esp
  804a1d:	8d 43 13             	lea    0x13(%ebx),%eax
  804a20:	83 e0 fc             	and    $0xfffffffc,%eax
  804a23:	89 c2                	mov    %eax,%edx
  804a25:	0f b7 c6             	movzwl %si,%eax
  804a28:	83 c0 03             	add    $0x3,%eax
  804a2b:	83 e0 fc             	and    $0xfffffffc,%eax
  804a2e:	01 d0                	add    %edx,%eax
  804a30:	50                   	push   %eax
  804a31:	e8 d7 f8 ff ff       	call   80430d <mem_malloc>
  804a36:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804a38:	83 c4 10             	add    $0x10,%esp
  804a3b:	85 c0                	test   %eax,%eax
  804a3d:	74 26                	je     804a65 <pbuf_alloc+0x9b>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804a3f:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804a43:	83 e0 fc             	and    $0xfffffffc,%eax
  804a46:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804a49:	66 89 77 08          	mov    %si,0x8(%edi)
  804a4d:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804a51:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804a57:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  804a5b:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804a61:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804a65:	89 f8                	mov    %edi,%eax
  804a67:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804a6a:	5b                   	pop    %ebx
  804a6b:	5e                   	pop    %esi
  804a6c:	5f                   	pop    %edi
  804a6d:	5d                   	pop    %ebp
  804a6e:	c3                   	ret    
  offset = 0;
  804a6f:	bf 00 00 00 00       	mov    $0x0,%edi
  804a74:	eb 05                	jmp    804a7b <pbuf_alloc+0xb1>
    offset += PBUF_TRANSPORT_HLEN;
  804a76:	bf 14 00 00 00       	mov    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804a7b:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804a7e:	8d 47 0e             	lea    0xe(%edi),%eax
  804a81:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804a85:	e9 7b ff ff ff       	jmp    804a05 <pbuf_alloc+0x3b>
  offset = 0;
  804a8a:	bf 00 00 00 00       	mov    $0x0,%edi
  804a8f:	eb ed                	jmp    804a7e <pbuf_alloc+0xb4>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804a91:	83 ec 04             	sub    $0x4,%esp
  804a94:	68 f0 1e 81 00       	push   $0x811ef0
  804a99:	68 8a 00 00 00       	push   $0x8a
  804a9e:	68 84 1e 81 00       	push   $0x811e84
  804aa3:	e8 c7 9c 00 00       	call   80e76f <_panic>
  switch (type) {
  804aa8:	83 fb 03             	cmp    $0x3,%ebx
  804aab:	0f 85 74 01 00 00    	jne    804c25 <pbuf_alloc+0x25b>
      p = memp_malloc(MEMP_PBUF_POOL);
  804ab1:	83 ec 0c             	sub    $0xc,%esp
  804ab4:	6a 0d                	push   $0xd
  804ab6:	e8 a6 fa ff ff       	call   804561 <memp_malloc>
  804abb:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804abd:	83 c4 10             	add    $0x10,%esp
  804ac0:	85 c0                	test   %eax,%eax
  804ac2:	74 a1                	je     804a65 <pbuf_alloc+0x9b>
    p->type = type;
  804ac4:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804ac8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804ace:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804ad2:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804ad6:	83 e2 fc             	and    $0xfffffffc,%edx
  804ad9:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804adc:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804ae0:	0f b7 f6             	movzwl %si,%esi
  804ae3:	83 c0 03             	add    $0x3,%eax
  804ae6:	83 e0 fc             	and    $0xfffffffc,%eax
  804ae9:	89 c1                	mov    %eax,%ecx
  804aeb:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804af0:	29 c8                	sub    %ecx,%eax
  804af2:	39 f0                	cmp    %esi,%eax
  804af4:	0f 4f c6             	cmovg  %esi,%eax
  804af7:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804afb:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804b01:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804b04:	01 c2                	add    %eax,%edx
  804b06:	39 d3                	cmp    %edx,%ebx
  804b08:	72 76                	jb     804b80 <pbuf_alloc+0x1b6>
    p->ref = 1;
  804b0a:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804b10:	29 c6                	sub    %eax,%esi
    r = p;
  804b12:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804b14:	85 f6                	test   %esi,%esi
  804b16:	0f 8e 3f ff ff ff    	jle    804a5b <pbuf_alloc+0x91>
      q = memp_malloc(MEMP_PBUF_POOL);
  804b1c:	83 ec 0c             	sub    $0xc,%esp
  804b1f:	6a 0d                	push   $0xd
  804b21:	e8 3b fa ff ff       	call   804561 <memp_malloc>
      if (q == NULL) {
  804b26:	83 c4 10             	add    $0x10,%esp
  804b29:	85 c0                	test   %eax,%eax
  804b2b:	74 6a                	je     804b97 <pbuf_alloc+0x1cd>
      q->type = type;
  804b2d:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804b31:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804b35:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804b3b:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804b3d:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804b43:	7f 67                	jg     804bac <pbuf_alloc+0x1e2>
      q->tot_len = (u16_t)rem_len;
  804b45:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804b49:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804b4e:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804b53:	0f 46 d6             	cmovbe %esi,%edx
  804b56:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804b5a:	8d 48 10             	lea    0x10(%eax),%ecx
  804b5d:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804b60:	f6 c1 03             	test   $0x3,%cl
  804b63:	75 5e                	jne    804bc3 <pbuf_alloc+0x1f9>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b65:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804b69:	03 4f 04             	add    0x4(%edi),%ecx
  804b6c:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804b6f:	72 69                	jb     804bda <pbuf_alloc+0x210>
      q->ref = 1;
  804b71:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804b77:	0f b7 d2             	movzwl %dx,%edx
  804b7a:	29 d6                	sub    %edx,%esi
      r = q;
  804b7c:	89 c3                	mov    %eax,%ebx
  804b7e:	eb 94                	jmp    804b14 <pbuf_alloc+0x14a>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b80:	83 ec 04             	sub    $0x4,%esp
  804b83:	68 08 20 81 00       	push   $0x812008
  804b88:	68 a3 00 00 00       	push   $0xa3
  804b8d:	68 84 1e 81 00       	push   $0x811e84
  804b92:	e8 d8 9b 00 00       	call   80e76f <_panic>
  804b97:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804b99:	83 ec 0c             	sub    $0xc,%esp
  804b9c:	57                   	push   %edi
  804b9d:	e8 62 fd ff ff       	call   804904 <pbuf_free>
        return NULL;
  804ba2:	83 c4 10             	add    $0x10,%esp
  804ba5:	89 df                	mov    %ebx,%edi
  804ba7:	e9 b9 fe ff ff       	jmp    804a65 <pbuf_alloc+0x9b>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804bac:	83 ec 04             	sub    $0x4,%esp
  804baf:	68 0b 1f 81 00       	push   $0x811f0b
  804bb4:	68 bc 00 00 00       	push   $0xbc
  804bb9:	68 84 1e 81 00       	push   $0x811e84
  804bbe:	e8 ac 9b 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804bc3:	83 ec 04             	sub    $0x4,%esp
  804bc6:	68 3c 20 81 00       	push   $0x81203c
  804bcb:	68 c2 00 00 00       	push   $0xc2
  804bd0:	68 84 1e 81 00       	push   $0x811e84
  804bd5:	e8 95 9b 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804bda:	83 ec 04             	sub    $0x4,%esp
  804bdd:	68 08 20 81 00       	push   $0x812008
  804be2:	68 c5 00 00 00       	push   $0xc5
  804be7:	68 84 1e 81 00       	push   $0x811e84
  804bec:	e8 7e 9b 00 00       	call   80e76f <_panic>
    p = memp_malloc(MEMP_PBUF);
  804bf1:	83 ec 0c             	sub    $0xc,%esp
  804bf4:	6a 0c                	push   $0xc
  804bf6:	e8 66 f9 ff ff       	call   804561 <memp_malloc>
  804bfb:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804bfd:	83 c4 10             	add    $0x10,%esp
  804c00:	85 c0                	test   %eax,%eax
  804c02:	0f 84 5d fe ff ff    	je     804a65 <pbuf_alloc+0x9b>
    p->payload = NULL;
  804c08:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804c0f:	66 89 70 08          	mov    %si,0x8(%eax)
  804c13:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804c17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804c1d:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804c20:	e9 36 fe ff ff       	jmp    804a5b <pbuf_alloc+0x91>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804c25:	83 ec 04             	sub    $0x4,%esp
  804c28:	68 1f 1f 81 00       	push   $0x811f1f
  804c2d:	68 f1 00 00 00       	push   $0xf1
  804c32:	68 84 1e 81 00       	push   $0x811e84
  804c37:	e8 33 9b 00 00       	call   80e76f <_panic>

00804c3c <pbuf_realloc>:
{
  804c3c:	55                   	push   %ebp
  804c3d:	89 e5                	mov    %esp,%ebp
  804c3f:	57                   	push   %edi
  804c40:	56                   	push   %esi
  804c41:	53                   	push   %ebx
  804c42:	83 ec 0c             	sub    $0xc,%esp
  804c45:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804c48:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804c4b:	85 db                	test   %ebx,%ebx
  804c4d:	74 53                	je     804ca2 <pbuf_realloc+0x66>
  804c4f:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804c51:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804c55:	77 62                	ja     804cb9 <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804c57:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804c5b:	66 39 f0             	cmp    %si,%ax
  804c5e:	0f 86 ae 00 00 00    	jbe    804d12 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804c64:	0f b7 ce             	movzwl %si,%ecx
  804c67:	0f b7 f8             	movzwl %ax,%edi
  804c6a:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804c6c:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804c6e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804c72:	66 39 f0             	cmp    %si,%ax
  804c75:	73 70                	jae    804ce7 <pbuf_realloc+0xab>
    rem_len -= q->len;
  804c77:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804c79:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804c7f:	7f 4f                	jg     804cd0 <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804c81:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804c85:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804c87:	85 db                	test   %ebx,%ebx
  804c89:	75 e3                	jne    804c6e <pbuf_realloc+0x32>
  804c8b:	83 ec 04             	sub    $0x4,%esp
  804c8e:	68 7e 1f 81 00       	push   $0x811f7e
  804c93:	68 2f 01 00 00       	push   $0x12f
  804c98:	68 84 1e 81 00       	push   $0x811e84
  804c9d:	e8 cd 9a 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804ca2:	83 ec 04             	sub    $0x4,%esp
  804ca5:	68 3a 1f 81 00       	push   $0x811f3a
  804caa:	68 13 01 00 00       	push   $0x113
  804caf:	68 84 1e 81 00       	push   $0x811e84
  804cb4:	e8 b6 9a 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804cb9:	83 ec 04             	sub    $0x4,%esp
  804cbc:	68 52 1f 81 00       	push   $0x811f52
  804cc1:	68 17 01 00 00       	push   $0x117
  804cc6:	68 84 1e 81 00       	push   $0x811e84
  804ccb:	e8 9f 9a 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804cd0:	83 ec 04             	sub    $0x4,%esp
  804cd3:	68 6d 1f 81 00       	push   $0x811f6d
  804cd8:	68 2b 01 00 00       	push   $0x12b
  804cdd:	68 84 1e 81 00       	push   $0x811e84
  804ce2:	e8 88 9a 00 00       	call   80e76f <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804ce7:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804ceb:	75 05                	jne    804cf2 <pbuf_realloc+0xb6>
  804ced:	66 39 f0             	cmp    %si,%ax
  804cf0:	75 28                	jne    804d1a <pbuf_realloc+0xde>
  q->len = rem_len;
  804cf2:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804cf6:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804cfa:	8b 03                	mov    (%ebx),%eax
  804cfc:	85 c0                	test   %eax,%eax
  804cfe:	74 0c                	je     804d0c <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804d00:	83 ec 0c             	sub    $0xc,%esp
  804d03:	50                   	push   %eax
  804d04:	e8 fb fb ff ff       	call   804904 <pbuf_free>
  804d09:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804d0c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804d12:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804d15:	5b                   	pop    %ebx
  804d16:	5e                   	pop    %esi
  804d17:	5f                   	pop    %edi
  804d18:	5d                   	pop    %ebp
  804d19:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804d1a:	8b 43 04             	mov    0x4(%ebx),%eax
  804d1d:	29 d8                	sub    %ebx,%eax
  804d1f:	0f b7 d6             	movzwl %si,%edx
  804d22:	01 d0                	add    %edx,%eax
  804d24:	83 ec 08             	sub    $0x8,%esp
  804d27:	50                   	push   %eax
  804d28:	53                   	push   %ebx
  804d29:	e8 87 f4 ff ff       	call   8041b5 <mem_realloc>
  804d2e:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804d30:	83 c4 10             	add    $0x10,%esp
  804d33:	85 c0                	test   %eax,%eax
  804d35:	75 bb                	jne    804cf2 <pbuf_realloc+0xb6>
  804d37:	83 ec 04             	sub    $0x4,%esp
  804d3a:	68 96 1f 81 00       	push   $0x811f96
  804d3f:	68 39 01 00 00       	push   $0x139
  804d44:	68 84 1e 81 00       	push   $0x811e84
  804d49:	e8 21 9a 00 00       	call   80e76f <_panic>

00804d4e <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804d4e:	55                   	push   %ebp
  804d4f:	89 e5                	mov    %esp,%ebp
  804d51:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804d54:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804d59:	85 d2                	test   %edx,%edx
  804d5b:	74 07                	je     804d64 <pbuf_clen+0x16>
    ++len;
  804d5d:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804d60:	8b 12                	mov    (%edx),%edx
  804d62:	eb f5                	jmp    804d59 <pbuf_clen+0xb>
  }
  return len;
}
  804d64:	5d                   	pop    %ebp
  804d65:	c3                   	ret    

00804d66 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804d66:	55                   	push   %ebp
  804d67:	89 e5                	mov    %esp,%ebp
  804d69:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804d6c:	85 c0                	test   %eax,%eax
  804d6e:	74 05                	je     804d75 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804d70:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804d75:	5d                   	pop    %ebp
  804d76:	c3                   	ret    

00804d77 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804d77:	55                   	push   %ebp
  804d78:	89 e5                	mov    %esp,%ebp
  804d7a:	53                   	push   %ebx
  804d7b:	83 ec 04             	sub    $0x4,%esp
  804d7e:	8b 45 08             	mov    0x8(%ebp),%eax
  804d81:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804d84:	85 c0                	test   %eax,%eax
  804d86:	74 16                	je     804d9e <pbuf_cat+0x27>
  804d88:	85 db                	test   %ebx,%ebx
  804d8a:	74 12                	je     804d9e <pbuf_cat+0x27>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804d8c:	8b 10                	mov    (%eax),%edx
  804d8e:	85 d2                	test   %edx,%edx
  804d90:	74 23                	je     804db5 <pbuf_cat+0x3e>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804d92:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804d96:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804d9a:	89 d0                	mov    %edx,%eax
  804d9c:	eb ee                	jmp    804d8c <pbuf_cat+0x15>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804d9e:	83 ec 04             	sub    $0x4,%esp
  804da1:	68 6c 20 81 00       	push   $0x81206c
  804da6:	68 42 02 00 00       	push   $0x242
  804dab:	68 84 1e 81 00       	push   $0x811e84
  804db0:	e8 ba 99 00 00       	call   80e76f <_panic>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804db5:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804db9:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804dbd:	75 0f                	jne    804dce <pbuf_cat+0x57>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804dbf:	66 03 53 08          	add    0x8(%ebx),%dx
  804dc3:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804dc7:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804dc9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804dcc:	c9                   	leave  
  804dcd:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804dce:	83 ec 04             	sub    $0x4,%esp
  804dd1:	68 a4 20 81 00       	push   $0x8120a4
  804dd6:	68 4a 02 00 00       	push   $0x24a
  804ddb:	68 84 1e 81 00       	push   $0x811e84
  804de0:	e8 8a 99 00 00       	call   80e76f <_panic>

00804de5 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804de5:	55                   	push   %ebp
  804de6:	89 e5                	mov    %esp,%ebp
  804de8:	53                   	push   %ebx
  804de9:	83 ec 0c             	sub    $0xc,%esp
  804dec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804def:	53                   	push   %ebx
  804df0:	ff 75 08             	pushl  0x8(%ebp)
  804df3:	e8 7f ff ff ff       	call   804d77 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804df8:	89 1c 24             	mov    %ebx,(%esp)
  804dfb:	e8 66 ff ff ff       	call   804d66 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804e00:	83 c4 10             	add    $0x10,%esp
  804e03:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804e06:	c9                   	leave  
  804e07:	c3                   	ret    

00804e08 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804e08:	55                   	push   %ebp
  804e09:	89 e5                	mov    %esp,%ebp
  804e0b:	57                   	push   %edi
  804e0c:	56                   	push   %esi
  804e0d:	53                   	push   %ebx
  804e0e:	83 ec 1c             	sub    $0x1c,%esp
  804e11:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804e14:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804e16:	85 f6                	test   %esi,%esi
  804e18:	74 71                	je     804e8b <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804e1a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e1e:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e22:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804e26:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804e29:	0f b7 d0             	movzwl %ax,%edx
  804e2c:	0f b7 f9             	movzwl %cx,%edi
  804e2f:	29 fa                	sub    %edi,%edx
  804e31:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804e34:	75 3e                	jne    804e74 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804e36:	29 c8                	sub    %ecx,%eax
  804e38:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804e3c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804e42:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e46:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804e4a:	83 ec 0c             	sub    $0xc,%esp
  804e4d:	56                   	push   %esi
  804e4e:	e8 b1 fa ff ff       	call   804904 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804e53:	83 c4 10             	add    $0x10,%esp
  804e56:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804e5a:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804e5e:	75 35                	jne    804e95 <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804e60:	84 c0                	test   %al,%al
  804e62:	b8 00 00 00 00       	mov    $0x0,%eax
  804e67:	0f 45 f0             	cmovne %eax,%esi
}
  804e6a:	89 f0                	mov    %esi,%eax
  804e6c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e6f:	5b                   	pop    %ebx
  804e70:	5e                   	pop    %esi
  804e71:	5f                   	pop    %edi
  804e72:	5d                   	pop    %ebp
  804e73:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804e74:	83 ec 04             	sub    $0x4,%esp
  804e77:	68 d4 20 81 00       	push   $0x8120d4
  804e7c:	68 80 02 00 00       	push   $0x280
  804e81:	68 84 1e 81 00       	push   $0x811e84
  804e86:	e8 e4 98 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804e8b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e8f:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804e93:	74 d5                	je     804e6a <pbuf_dechain+0x62>
  804e95:	83 ec 04             	sub    $0x4,%esp
  804e98:	68 b1 1f 81 00       	push   $0x811fb1
  804e9d:	68 91 02 00 00       	push   $0x291
  804ea2:	68 84 1e 81 00       	push   $0x811e84
  804ea7:	e8 c3 98 00 00       	call   80e76f <_panic>

00804eac <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804eac:	55                   	push   %ebp
  804ead:	89 e5                	mov    %esp,%ebp
  804eaf:	57                   	push   %edi
  804eb0:	56                   	push   %esi
  804eb1:	53                   	push   %ebx
  804eb2:	83 ec 1c             	sub    $0x1c,%esp
  804eb5:	8b 7d 08             	mov    0x8(%ebp),%edi
  804eb8:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804ebb:	85 ff                	test   %edi,%edi
  804ebd:	74 22                	je     804ee1 <pbuf_copy+0x35>
  804ebf:	85 db                	test   %ebx,%ebx
  804ec1:	74 1e                	je     804ee1 <pbuf_copy+0x35>
  804ec3:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804ec7:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804ecb:	72 14                	jb     804ee1 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804ecd:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ed3:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804ed9:	89 7d 08             	mov    %edi,0x8(%ebp)
  804edc:	e9 92 00 00 00       	jmp    804f73 <pbuf_copy+0xc7>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804ee1:	83 ec 04             	sub    $0x4,%esp
  804ee4:	68 f8 20 81 00       	push   $0x8120f8
  804ee9:	68 b1 02 00 00       	push   $0x2b1
  804eee:	68 84 1e 81 00       	push   $0x811e84
  804ef3:	e8 77 98 00 00       	call   80e76f <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804ef8:	83 ec 04             	sub    $0x4,%esp
  804efb:	68 c6 1f 81 00       	push   $0x811fc6
  804f00:	68 c2 02 00 00       	push   $0x2c2
  804f05:	68 84 1e 81 00       	push   $0x811e84
  804f0a:	e8 60 98 00 00       	call   80e76f <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804f0f:	8b 45 08             	mov    0x8(%ebp),%eax
  804f12:	8b 00                	mov    (%eax),%eax
  804f14:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804f17:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804f1d:	e9 c7 00 00 00       	jmp    804fe9 <pbuf_copy+0x13d>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804f22:	83 ec 04             	sub    $0x4,%esp
  804f25:	68 dd 1f 81 00       	push   $0x811fdd
  804f2a:	68 c8 02 00 00       	push   $0x2c8
  804f2f:	68 84 1e 81 00       	push   $0x811e84
  804f34:	e8 36 98 00 00       	call   80e76f <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804f39:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f3f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f43:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804f47:	0f 84 cf 00 00 00    	je     80501c <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f4d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804f51:	0f 84 05 01 00 00    	je     80505c <pbuf_copy+0x1b0>
  804f57:	8b 45 08             	mov    0x8(%ebp),%eax
  804f5a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804f5e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804f61:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804f65:	0f 84 d1 00 00 00    	je     80503c <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804f6b:	85 db                	test   %ebx,%ebx
  804f6d:	0f 84 00 01 00 00    	je     805073 <pbuf_copy+0x1c7>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804f73:	8b 45 08             	mov    0x8(%ebp),%eax
  804f76:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804f7a:	0f b7 ce             	movzwl %si,%ecx
  804f7d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804f81:	29 c1                	sub    %eax,%ecx
  804f83:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804f87:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f8b:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804f8d:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804f91:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  804f95:	89 f8                	mov    %edi,%eax
  804f97:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804f9b:	29 fe                	sub    %edi,%esi
  804f9d:	39 d1                	cmp    %edx,%ecx
  804f9f:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804fa2:	83 ec 04             	sub    $0x4,%esp
  804fa5:	0f b7 c6             	movzwl %si,%eax
  804fa8:	50                   	push   %eax
  804fa9:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fad:	03 43 04             	add    0x4(%ebx),%eax
  804fb0:	50                   	push   %eax
  804fb1:	0f b7 c7             	movzwl %di,%eax
  804fb4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804fb7:	03 41 04             	add    0x4(%ecx),%eax
  804fba:	50                   	push   %eax
  804fbb:	e8 f4 a1 00 00       	call   80f1b4 <memcpy>
    offset_to += len;
  804fc0:	89 fa                	mov    %edi,%edx
  804fc2:	01 f2                	add    %esi,%edx
  804fc4:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804fc8:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804fcc:	8b 45 08             	mov    0x8(%ebp),%eax
  804fcf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804fd3:	83 c4 10             	add    $0x10,%esp
  804fd6:	66 39 d0             	cmp    %dx,%ax
  804fd9:	0f 82 19 ff ff ff    	jb     804ef8 <pbuf_copy+0x4c>
    if (offset_to == p_to->len) {
  804fdf:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  804fe3:	0f 84 26 ff ff ff    	je     804f0f <pbuf_copy+0x63>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804fe9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804fed:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804ff1:	0f 82 2b ff ff ff    	jb     804f22 <pbuf_copy+0x76>
    if (offset_from >= p_from->len) {
  804ff7:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804ffb:	0f 85 3e ff ff ff    	jne    804f3f <pbuf_copy+0x93>
      p_from = p_from->next;
  805001:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  805003:	85 db                	test   %ebx,%ebx
  805005:	0f 85 2e ff ff ff    	jne    804f39 <pbuf_copy+0x8d>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80500b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80500f:	74 62                	je     805073 <pbuf_copy+0x1c7>
      offset_from = 0;
  805011:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805017:	e9 3b ff ff ff       	jmp    804f57 <pbuf_copy+0xab>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80501c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80501f:	0f 84 28 ff ff ff    	je     804f4d <pbuf_copy+0xa1>
  805025:	83 ec 04             	sub    $0x4,%esp
  805028:	68 28 21 81 00       	push   $0x812128
  80502d:	68 d2 02 00 00       	push   $0x2d2
  805032:	68 84 1e 81 00       	push   $0x811e84
  805037:	e8 33 97 00 00       	call   80e76f <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80503c:	83 39 00             	cmpl   $0x0,(%ecx)
  80503f:	0f 84 26 ff ff ff    	je     804f6b <pbuf_copy+0xbf>
  805045:	83 ec 04             	sub    $0x4,%esp
  805048:	68 28 21 81 00       	push   $0x812128
  80504d:	68 d7 02 00 00       	push   $0x2d7
  805052:	68 84 1e 81 00       	push   $0x811e84
  805057:	e8 13 97 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80505c:	83 ec 04             	sub    $0x4,%esp
  80505f:	68 f8 1f 81 00       	push   $0x811ff8
  805064:	68 b6 02 00 00       	push   $0x2b6
  805069:	68 84 1e 81 00       	push   $0x811e84
  80506e:	e8 fc 96 00 00       	call   80e76f <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805073:	b8 00 00 00 00       	mov    $0x0,%eax
  805078:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80507b:	5b                   	pop    %ebx
  80507c:	5e                   	pop    %esi
  80507d:	5f                   	pop    %edi
  80507e:	5d                   	pop    %ebp
  80507f:	c3                   	ret    

00805080 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  805080:	55                   	push   %ebp
  805081:	89 e5                	mov    %esp,%ebp
  805083:	57                   	push   %edi
  805084:	56                   	push   %esi
  805085:	53                   	push   %ebx
  805086:	83 ec 1c             	sub    $0x1c,%esp
  805089:	8b 75 08             	mov    0x8(%ebp),%esi
  80508c:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  805090:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  805094:	85 f6                	test   %esi,%esi
  805096:	74 0e                	je     8050a6 <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805098:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80509c:	74 1f                	je     8050bd <pbuf_copy_partial+0x3d>

  left = 0;
  80509e:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8050a4:	eb 65                	jmp    80510b <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8050a6:	83 ec 04             	sub    $0x4,%esp
  8050a9:	68 54 21 81 00       	push   $0x812154
  8050ae:	68 ef 02 00 00       	push   $0x2ef
  8050b3:	68 84 1e 81 00       	push   $0x811e84
  8050b8:	e8 b2 96 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8050bd:	83 ec 04             	sub    $0x4,%esp
  8050c0:	68 78 21 81 00       	push   $0x812178
  8050c5:	68 f0 02 00 00       	push   $0x2f0
  8050ca:	68 84 1e 81 00       	push   $0x811e84
  8050cf:	e8 9b 96 00 00       	call   80e76f <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  8050d4:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  8050d8:	29 c3                	sub    %eax,%ebx
  8050da:	66 39 df             	cmp    %bx,%di
  8050dd:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  8050e0:	83 ec 04             	sub    $0x4,%esp
  8050e3:	0f b7 d3             	movzwl %bx,%edx
  8050e6:	52                   	push   %edx
  8050e7:	0f b7 c0             	movzwl %ax,%eax
  8050ea:	03 46 04             	add    0x4(%esi),%eax
  8050ed:	50                   	push   %eax
  8050ee:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050f2:	03 45 0c             	add    0xc(%ebp),%eax
  8050f5:	50                   	push   %eax
  8050f6:	e8 b9 a0 00 00       	call   80f1b4 <memcpy>
      copied_total += buf_copy_len;
  8050fb:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  8050ff:	29 df                	sub    %ebx,%edi
  805101:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  805104:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805109:	8b 36                	mov    (%esi),%esi
  80510b:	66 85 ff             	test   %di,%di
  80510e:	74 16                	je     805126 <pbuf_copy_partial+0xa6>
  805110:	85 f6                	test   %esi,%esi
  805112:	74 12                	je     805126 <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  805114:	66 85 c0             	test   %ax,%ax
  805117:	74 bb                	je     8050d4 <pbuf_copy_partial+0x54>
  805119:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80511d:	66 39 c2             	cmp    %ax,%dx
  805120:	77 b2                	ja     8050d4 <pbuf_copy_partial+0x54>
      offset -= p->len;
  805122:	29 d0                	sub    %edx,%eax
  805124:	eb e3                	jmp    805109 <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  805126:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80512a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80512d:	5b                   	pop    %ebx
  80512e:	5e                   	pop    %esi
  80512f:	5f                   	pop    %edi
  805130:	5d                   	pop    %ebp
  805131:	c3                   	ret    

00805132 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805132:	55                   	push   %ebp
  805133:	89 e5                	mov    %esp,%ebp
  805135:	83 ec 14             	sub    $0x14,%esp
  805138:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80513b:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805140:	8b 40 04             	mov    0x4(%eax),%eax
  805143:	ff 30                	pushl  (%eax)
  805145:	e8 2a 50 00 00       	call   80a174 <sys_sem_signal>
}
  80514a:	83 c4 10             	add    $0x10,%esp
  80514d:	c9                   	leave  
  80514e:	c3                   	ret    

0080514f <sys_mbox_fetch>:
{
  80514f:	55                   	push   %ebp
  805150:	89 e5                	mov    %esp,%ebp
  805152:	57                   	push   %edi
  805153:	56                   	push   %esi
  805154:	53                   	push   %ebx
  805155:	83 ec 0c             	sub    $0xc,%esp
  805158:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80515b:	eb 40                	jmp    80519d <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80515d:	83 ec 04             	sub    $0x4,%esp
  805160:	6a 00                	push   $0x0
  805162:	57                   	push   %edi
  805163:	ff 75 08             	pushl  0x8(%ebp)
  805166:	e8 7e 52 00 00       	call   80a3e9 <sys_arch_mbox_fetch>
  80516b:	83 c4 10             	add    $0x10,%esp
}
  80516e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805171:	5b                   	pop    %ebx
  805172:	5e                   	pop    %esi
  805173:	5f                   	pop    %edi
  805174:	5d                   	pop    %ebp
  805175:	c3                   	ret    
      tmptimeout = timeouts->next;
  805176:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805178:	8b 10                	mov    (%eax),%edx
  80517a:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  80517c:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80517f:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805182:	83 ec 08             	sub    $0x8,%esp
  805185:	50                   	push   %eax
  805186:	6a 0b                	push   $0xb
  805188:	e8 2a f4 ff ff       	call   8045b7 <memp_free>
      if (h != NULL) {
  80518d:	83 c4 10             	add    $0x10,%esp
  805190:	85 db                	test   %ebx,%ebx
  805192:	74 09                	je     80519d <sys_mbox_fetch+0x4e>
        h(arg);
  805194:	83 ec 0c             	sub    $0xc,%esp
  805197:	56                   	push   %esi
  805198:	ff d3                	call   *%ebx
  80519a:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80519d:	e8 dc 53 00 00       	call   80a57e <sys_arch_timeouts>
  8051a2:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8051a4:	85 c0                	test   %eax,%eax
  8051a6:	74 b5                	je     80515d <sys_mbox_fetch+0xe>
  8051a8:	8b 00                	mov    (%eax),%eax
  8051aa:	85 c0                	test   %eax,%eax
  8051ac:	74 af                	je     80515d <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  8051ae:	8b 40 04             	mov    0x4(%eax),%eax
  8051b1:	85 c0                	test   %eax,%eax
  8051b3:	74 c1                	je     805176 <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8051b5:	83 ec 04             	sub    $0x4,%esp
  8051b8:	50                   	push   %eax
  8051b9:	57                   	push   %edi
  8051ba:	ff 75 08             	pushl  0x8(%ebp)
  8051bd:	e8 27 52 00 00       	call   80a3e9 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8051c2:	83 c4 10             	add    $0x10,%esp
  8051c5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8051c8:	74 ac                	je     805176 <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  8051ca:	8b 1b                	mov    (%ebx),%ebx
  8051cc:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8051cf:	89 ca                	mov    %ecx,%edx
  8051d1:	29 c2                	sub    %eax,%edx
  8051d3:	39 c1                	cmp    %eax,%ecx
  8051d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8051da:	0f 46 d0             	cmovbe %eax,%edx
  8051dd:	89 53 04             	mov    %edx,0x4(%ebx)
  8051e0:	eb 8c                	jmp    80516e <sys_mbox_fetch+0x1f>

008051e2 <sys_sem_wait>:
{
  8051e2:	55                   	push   %ebp
  8051e3:	89 e5                	mov    %esp,%ebp
  8051e5:	57                   	push   %edi
  8051e6:	56                   	push   %esi
  8051e7:	53                   	push   %ebx
  8051e8:	83 ec 0c             	sub    $0xc,%esp
  8051eb:	8b 75 08             	mov    0x8(%ebp),%esi
  8051ee:	eb 3d                	jmp    80522d <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  8051f0:	83 ec 08             	sub    $0x8,%esp
  8051f3:	6a 00                	push   $0x0
  8051f5:	56                   	push   %esi
  8051f6:	e8 e9 4f 00 00       	call   80a1e4 <sys_arch_sem_wait>
  8051fb:	83 c4 10             	add    $0x10,%esp
}
  8051fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805201:	5b                   	pop    %ebx
  805202:	5e                   	pop    %esi
  805203:	5f                   	pop    %edi
  805204:	5d                   	pop    %ebp
  805205:	c3                   	ret    
      tmptimeout = timeouts->next;
  805206:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805208:	8b 10                	mov    (%eax),%edx
  80520a:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  80520c:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80520f:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805212:	83 ec 08             	sub    $0x8,%esp
  805215:	50                   	push   %eax
  805216:	6a 0b                	push   $0xb
  805218:	e8 9a f3 ff ff       	call   8045b7 <memp_free>
      if (h != NULL) {
  80521d:	83 c4 10             	add    $0x10,%esp
  805220:	85 db                	test   %ebx,%ebx
  805222:	74 09                	je     80522d <sys_sem_wait+0x4b>
        h(arg);
  805224:	83 ec 0c             	sub    $0xc,%esp
  805227:	57                   	push   %edi
  805228:	ff d3                	call   *%ebx
  80522a:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80522d:	e8 4c 53 00 00       	call   80a57e <sys_arch_timeouts>
  805232:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805234:	85 c0                	test   %eax,%eax
  805236:	74 b8                	je     8051f0 <sys_sem_wait+0xe>
  805238:	8b 00                	mov    (%eax),%eax
  80523a:	85 c0                	test   %eax,%eax
  80523c:	74 b2                	je     8051f0 <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  80523e:	8b 40 04             	mov    0x4(%eax),%eax
  805241:	85 c0                	test   %eax,%eax
  805243:	74 c1                	je     805206 <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805245:	83 ec 08             	sub    $0x8,%esp
  805248:	50                   	push   %eax
  805249:	56                   	push   %esi
  80524a:	e8 95 4f 00 00       	call   80a1e4 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80524f:	83 c4 10             	add    $0x10,%esp
  805252:	83 f8 ff             	cmp    $0xffffffff,%eax
  805255:	74 af                	je     805206 <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  805257:	8b 1b                	mov    (%ebx),%ebx
  805259:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  80525c:	89 ca                	mov    %ecx,%edx
  80525e:	29 c2                	sub    %eax,%edx
  805260:	39 c1                	cmp    %eax,%ecx
  805262:	b8 00 00 00 00       	mov    $0x0,%eax
  805267:	0f 46 d0             	cmovbe %eax,%edx
  80526a:	89 53 04             	mov    %edx,0x4(%ebx)
  80526d:	eb 8f                	jmp    8051fe <sys_sem_wait+0x1c>

0080526f <sys_timeout>:
{
  80526f:	55                   	push   %ebp
  805270:	89 e5                	mov    %esp,%ebp
  805272:	57                   	push   %edi
  805273:	56                   	push   %esi
  805274:	53                   	push   %ebx
  805275:	83 ec 28             	sub    $0x28,%esp
  805278:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80527b:	6a 0b                	push   $0xb
  80527d:	e8 df f2 ff ff       	call   804561 <memp_malloc>
  if (timeout == NULL) {
  805282:	83 c4 10             	add    $0x10,%esp
  805285:	85 c0                	test   %eax,%eax
  805287:	74 40                	je     8052c9 <sys_timeout+0x5a>
  805289:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  80528b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805291:	8b 45 0c             	mov    0xc(%ebp),%eax
  805294:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  805297:	8b 45 10             	mov    0x10(%ebp),%eax
  80529a:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  80529d:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  8052a0:	e8 d9 52 00 00       	call   80a57e <sys_arch_timeouts>
  if (timeouts == NULL) {
  8052a5:	85 c0                	test   %eax,%eax
  8052a7:	74 37                	je     8052e0 <sys_timeout+0x71>
  if (timeouts->next == NULL) {
  8052a9:	8b 10                	mov    (%eax),%edx
  8052ab:	85 d2                	test   %edx,%edx
  8052ad:	74 48                	je     8052f7 <sys_timeout+0x88>
  if (timeouts->next->time > msecs) {
  8052af:	8b 4a 04             	mov    0x4(%edx),%ecx
  8052b2:	39 f1                	cmp    %esi,%ecx
  8052b4:	76 47                	jbe    8052fd <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  8052b6:	29 f1                	sub    %esi,%ecx
  8052b8:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  8052bb:	8b 10                	mov    (%eax),%edx
  8052bd:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8052bf:	89 18                	mov    %ebx,(%eax)
}
  8052c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052c4:	5b                   	pop    %ebx
  8052c5:	5e                   	pop    %esi
  8052c6:	5f                   	pop    %edi
  8052c7:	5d                   	pop    %ebp
  8052c8:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8052c9:	83 ec 04             	sub    $0x4,%esp
  8052cc:	68 9d 21 81 00       	push   $0x81219d
  8052d1:	68 c3 00 00 00       	push   $0xc3
  8052d6:	68 ba 21 81 00       	push   $0x8121ba
  8052db:	e8 8f 94 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8052e0:	83 ec 04             	sub    $0x4,%esp
  8052e3:	68 ce 21 81 00       	push   $0x8121ce
  8052e8:	68 d1 00 00 00       	push   $0xd1
  8052ed:	68 ba 21 81 00       	push   $0x8121ba
  8052f2:	e8 78 94 00 00       	call   80e76f <_panic>
    timeouts->next = timeout;
  8052f7:	89 18                	mov    %ebx,(%eax)
    return;
  8052f9:	eb c6                	jmp    8052c1 <sys_timeout+0x52>
      if (t->next == NULL || t->next->time > timeout->time) {
  8052fb:	89 c2                	mov    %eax,%edx
      timeout->time -= t->time;
  8052fd:	8b 7b 04             	mov    0x4(%ebx),%edi
  805300:	8b 42 04             	mov    0x4(%edx),%eax
  805303:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805306:	89 f9                	mov    %edi,%ecx
  805308:	29 c1                	sub    %eax,%ecx
  80530a:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  80530d:	8b 02                	mov    (%edx),%eax
  80530f:	85 c0                	test   %eax,%eax
  805311:	74 17                	je     80532a <sys_timeout+0xbb>
  805313:	8b 70 04             	mov    0x4(%eax),%esi
  805316:	89 75 e0             	mov    %esi,-0x20(%ebp)
  805319:	39 f1                	cmp    %esi,%ecx
  80531b:	73 de                	jae    8052fb <sys_timeout+0x8c>
  80531d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
          t->next->time -= timeout->time;
  805320:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  805323:	29 f9                	sub    %edi,%ecx
  805325:	01 ce                	add    %ecx,%esi
  805327:	89 70 04             	mov    %esi,0x4(%eax)
        timeout->next = t->next;
  80532a:	8b 02                	mov    (%edx),%eax
  80532c:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80532e:	89 1a                	mov    %ebx,(%edx)
        break;
  805330:	eb 8f                	jmp    8052c1 <sys_timeout+0x52>

00805332 <sys_untimeout>:
{
  805332:	55                   	push   %ebp
  805333:	89 e5                	mov    %esp,%ebp
  805335:	57                   	push   %edi
  805336:	56                   	push   %esi
  805337:	53                   	push   %ebx
  805338:	83 ec 0c             	sub    $0xc,%esp
  80533b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80533e:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805341:	e8 38 52 00 00       	call   80a57e <sys_arch_timeouts>
  if (timeouts == NULL) {
  805346:	85 c0                	test   %eax,%eax
  805348:	74 0d                	je     805357 <sys_untimeout+0x25>
  if (timeouts->next == NULL) {
  80534a:	8b 10                	mov    (%eax),%edx
  80534c:	85 d2                	test   %edx,%edx
  80534e:	74 5a                	je     8053aa <sys_untimeout+0x78>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805350:	bf 00 00 00 00       	mov    $0x0,%edi
  805355:	eb 27                	jmp    80537e <sys_untimeout+0x4c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805357:	83 ec 04             	sub    $0x4,%esp
  80535a:	68 ec 21 81 00       	push   $0x8121ec
  80535f:	68 00 01 00 00       	push   $0x100
  805364:	68 ba 21 81 00       	push   $0x8121ba
  805369:	e8 01 94 00 00       	call   80e76f <_panic>
        timeouts->next = t->next;
  80536e:	8b 0a                	mov    (%edx),%ecx
  805370:	89 08                	mov    %ecx,(%eax)
  805372:	eb 1c                	jmp    805390 <sys_untimeout+0x5e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805374:	8b 0a                	mov    (%edx),%ecx
  805376:	89 d7                	mov    %edx,%edi
  805378:	85 c9                	test   %ecx,%ecx
  80537a:	74 2e                	je     8053aa <sys_untimeout+0x78>
  80537c:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80537e:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805381:	75 f1                	jne    805374 <sys_untimeout+0x42>
  805383:	39 72 0c             	cmp    %esi,0xc(%edx)
  805386:	75 ec                	jne    805374 <sys_untimeout+0x42>
      if (prev_t == NULL)
  805388:	85 ff                	test   %edi,%edi
  80538a:	74 e2                	je     80536e <sys_untimeout+0x3c>
        prev_t->next = t->next;
  80538c:	8b 02                	mov    (%edx),%eax
  80538e:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  805390:	8b 02                	mov    (%edx),%eax
  805392:	85 c0                	test   %eax,%eax
  805394:	74 06                	je     80539c <sys_untimeout+0x6a>
        t->next->time += t->time;
  805396:	8b 4a 04             	mov    0x4(%edx),%ecx
  805399:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80539c:	83 ec 08             	sub    $0x8,%esp
  80539f:	52                   	push   %edx
  8053a0:	6a 0b                	push   $0xb
  8053a2:	e8 10 f2 ff ff       	call   8045b7 <memp_free>
      return;
  8053a7:	83 c4 10             	add    $0x10,%esp
}
  8053aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8053ad:	5b                   	pop    %ebx
  8053ae:	5e                   	pop    %esi
  8053af:	5f                   	pop    %edi
  8053b0:	5d                   	pop    %ebp
  8053b1:	c3                   	ret    

008053b2 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8053b2:	55                   	push   %ebp
  8053b3:	89 e5                	mov    %esp,%ebp
  8053b5:	83 ec 18             	sub    $0x18,%esp
  8053b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8053bb:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8053be:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8053c1:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8053c7:	85 c0                	test   %eax,%eax
  8053c9:	75 1c                	jne    8053e7 <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  8053cb:	83 ec 0c             	sub    $0xc,%esp
  8053ce:	ff 75 08             	pushl  0x8(%ebp)
  8053d1:	e8 0c fe ff ff       	call   8051e2 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8053d6:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8053d9:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  8053de:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8053e3:	74 19                	je     8053fe <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8053e5:	c9                   	leave  
  8053e6:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8053e7:	83 ec 04             	sub    $0x4,%esp
  8053ea:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8053ed:	52                   	push   %edx
  8053ee:	68 32 51 80 00       	push   $0x805132
  8053f3:	50                   	push   %eax
  8053f4:	e8 76 fe ff ff       	call   80526f <sys_timeout>
  8053f9:	83 c4 10             	add    $0x10,%esp
  8053fc:	eb cd                	jmp    8053cb <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  8053fe:	83 ec 08             	sub    $0x8,%esp
  805401:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805404:	50                   	push   %eax
  805405:	68 32 51 80 00       	push   $0x805132
  80540a:	e8 23 ff ff ff       	call   805332 <sys_untimeout>
    return 1;
  80540f:	83 c4 10             	add    $0x10,%esp
  805412:	b8 01 00 00 00       	mov    $0x1,%eax
  805417:	eb cc                	jmp    8053e5 <sys_sem_wait_timeout+0x33>

00805419 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805419:	55                   	push   %ebp
  80541a:	89 e5                	mov    %esp,%ebp
  80541c:	53                   	push   %ebx
  80541d:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805420:	6a 00                	push   $0x0
  805422:	e8 90 4a 00 00       	call   809eb7 <sys_sem_new>
  805427:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805429:	83 c4 08             	add    $0x8,%esp
  80542c:	ff 75 08             	pushl  0x8(%ebp)
  80542f:	50                   	push   %eax
  805430:	e8 7d ff ff ff       	call   8053b2 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805435:	89 1c 24             	mov    %ebx,(%esp)
  805438:	e8 fb 4a 00 00       	call   809f38 <sys_sem_free>
}
  80543d:	83 c4 10             	add    $0x10,%esp
  805440:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805443:	c9                   	leave  
  805444:	c3                   	ret    

00805445 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805445:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80544a:	c3                   	ret    

0080544b <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80544b:	55                   	push   %ebp
  80544c:	89 e5                	mov    %esp,%ebp
  80544e:	57                   	push   %edi
  80544f:	56                   	push   %esi
  805450:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805451:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805457:	8b 35 50 c2 b3 00    	mov    0xb3c250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80545d:	8b 3d 44 c2 b3 00    	mov    0xb3c244,%edi
  805463:	0f b7 05 0c 50 81 00 	movzwl 0x81500c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  80546a:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80546f:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805473:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805476:	89 da                	mov    %ebx,%edx
  805478:	85 d2                	test   %edx,%edx
  80547a:	74 0b                	je     805487 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  80547c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805480:	74 ed                	je     80546f <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805482:	8b 52 0c             	mov    0xc(%edx),%edx
  805485:	eb f1                	jmp    805478 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805487:	89 f2                	mov    %esi,%edx
  805489:	85 d2                	test   %edx,%edx
  80548b:	74 0b                	je     805498 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  80548d:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805491:	74 dc                	je     80546f <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805493:	8b 52 0c             	mov    0xc(%edx),%edx
  805496:	eb f1                	jmp    805489 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805498:	89 fa                	mov    %edi,%edx
  80549a:	85 d2                	test   %edx,%edx
  80549c:	74 0b                	je     8054a9 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  80549e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8054a2:	74 cb                	je     80546f <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8054a4:	8b 52 0c             	mov    0xc(%edx),%edx
  8054a7:	eb f1                	jmp    80549a <tcp_new_port+0x4f>
  8054a9:	66 a3 0c 50 81 00    	mov    %ax,0x81500c
      goto again;
    }
  }
  return port;
}
  8054af:	5b                   	pop    %ebx
  8054b0:	5e                   	pop    %esi
  8054b1:	5f                   	pop    %edi
  8054b2:	5d                   	pop    %ebp
  8054b3:	c3                   	ret    

008054b4 <tcp_bind>:
{
  8054b4:	55                   	push   %ebp
  8054b5:	89 e5                	mov    %esp,%ebp
  8054b7:	57                   	push   %edi
  8054b8:	56                   	push   %esi
  8054b9:	53                   	push   %ebx
  8054ba:	83 ec 0c             	sub    $0xc,%esp
  8054bd:	8b 75 08             	mov    0x8(%ebp),%esi
  8054c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8054c3:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8054c6:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8054ca:	75 0f                	jne    8054db <tcp_bind+0x27>
  8054cc:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  8054ce:	66 85 d2             	test   %dx,%dx
  8054d1:	74 1f                	je     8054f2 <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8054d3:	8b 15 44 c2 b3 00    	mov    0xb3c244,%edx
  8054d9:	eb 21                	jmp    8054fc <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8054db:	83 ec 04             	sub    $0x4,%esp
  8054de:	68 0c 22 81 00       	push   $0x81220c
  8054e3:	68 05 01 00 00       	push   $0x105
  8054e8:	68 ee 23 81 00       	push   $0x8123ee
  8054ed:	e8 7d 92 00 00       	call   80e76f <_panic>
    port = tcp_new_port();
  8054f2:	e8 54 ff ff ff       	call   80544b <tcp_new_port>
  8054f7:	eb da                	jmp    8054d3 <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  8054f9:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8054fc:	85 d2                	test   %edx,%edx
  8054fe:	74 2c                	je     80552c <tcp_bind+0x78>
    if (cpcb->local_port == port) {
  805500:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805504:	75 f3                	jne    8054f9 <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805506:	8b 0a                	mov    (%edx),%ecx
  805508:	85 db                	test   %ebx,%ebx
  80550a:	0f 84 d4 00 00 00    	je     8055e4 <tcp_bind+0x130>
  805510:	85 c9                	test   %ecx,%ecx
  805512:	0f 84 cc 00 00 00    	je     8055e4 <tcp_bind+0x130>
          ip_addr_isany(ipaddr) ||
  805518:	8b 3b                	mov    (%ebx),%edi
  80551a:	39 f9                	cmp    %edi,%ecx
  80551c:	74 04                	je     805522 <tcp_bind+0x6e>
  80551e:	85 ff                	test   %edi,%edi
  805520:	75 d7                	jne    8054f9 <tcp_bind+0x45>
        return ERR_USE;
  805522:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805527:	e9 bd 00 00 00       	jmp    8055e9 <tcp_bind+0x135>
  for(cpcb = tcp_active_pcbs;
  80552c:	8b 15 3c c2 b3 00    	mov    0xb3c23c,%edx
  805532:	eb 03                	jmp    805537 <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  805534:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805537:	85 d2                	test   %edx,%edx
  805539:	74 2c                	je     805567 <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  80553b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80553f:	75 f3                	jne    805534 <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805541:	8b 0a                	mov    (%edx),%ecx
  805543:	85 db                	test   %ebx,%ebx
  805545:	0f 84 a6 00 00 00    	je     8055f1 <tcp_bind+0x13d>
  80554b:	85 c9                	test   %ecx,%ecx
  80554d:	0f 84 9e 00 00 00    	je     8055f1 <tcp_bind+0x13d>
          ip_addr_isany(ipaddr) ||
  805553:	8b 3b                	mov    (%ebx),%edi
  805555:	39 f9                	cmp    %edi,%ecx
  805557:	74 04                	je     80555d <tcp_bind+0xa9>
  805559:	85 ff                	test   %edi,%edi
  80555b:	75 d7                	jne    805534 <tcp_bind+0x80>
        return ERR_USE;
  80555d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805562:	e9 82 00 00 00       	jmp    8055e9 <tcp_bind+0x135>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805567:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  80556d:	eb 03                	jmp    805572 <tcp_bind+0xbe>
  80556f:	8b 52 0c             	mov    0xc(%edx),%edx
  805572:	85 d2                	test   %edx,%edx
  805574:	74 21                	je     805597 <tcp_bind+0xe3>
    if (cpcb->local_port == port) {
  805576:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80557a:	75 f3                	jne    80556f <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80557c:	8b 0a                	mov    (%edx),%ecx
  80557e:	85 db                	test   %ebx,%ebx
  805580:	74 76                	je     8055f8 <tcp_bind+0x144>
  805582:	85 c9                	test   %ecx,%ecx
  805584:	74 72                	je     8055f8 <tcp_bind+0x144>
          ip_addr_isany(ipaddr) ||
  805586:	8b 3b                	mov    (%ebx),%edi
  805588:	39 f9                	cmp    %edi,%ecx
  80558a:	74 04                	je     805590 <tcp_bind+0xdc>
  80558c:	85 ff                	test   %edi,%edi
  80558e:	75 df                	jne    80556f <tcp_bind+0xbb>
        return ERR_USE;
  805590:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805595:	eb 52                	jmp    8055e9 <tcp_bind+0x135>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805597:	8b 15 50 c2 b3 00    	mov    0xb3c250,%edx
  80559d:	eb 03                	jmp    8055a2 <tcp_bind+0xee>
  80559f:	8b 52 0c             	mov    0xc(%edx),%edx
  8055a2:	85 d2                	test   %edx,%edx
  8055a4:	74 13                	je     8055b9 <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  8055a6:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8055aa:	75 f3                	jne    80559f <tcp_bind+0xeb>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8055ac:	8b 3b                	mov    (%ebx),%edi
  8055ae:	39 3a                	cmp    %edi,(%edx)
  8055b0:	75 ed                	jne    80559f <tcp_bind+0xeb>
        return ERR_USE;
  8055b2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8055b7:	eb 30                	jmp    8055e9 <tcp_bind+0x135>
  if (!ip_addr_isany(ipaddr)) {
  8055b9:	85 db                	test   %ebx,%ebx
  8055bb:	74 09                	je     8055c6 <tcp_bind+0x112>
  8055bd:	83 3b 00             	cmpl   $0x0,(%ebx)
  8055c0:	74 04                	je     8055c6 <tcp_bind+0x112>
    pcb->local_ip = *ipaddr;
  8055c2:	8b 13                	mov    (%ebx),%edx
  8055c4:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  8055c6:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8055ca:	a1 4c c2 b3 00       	mov    0xb3c24c,%eax
  8055cf:	89 46 0c             	mov    %eax,0xc(%esi)
  8055d2:	89 35 4c c2 b3 00    	mov    %esi,0xb3c24c
  8055d8:	e8 fd cc ff ff       	call   8022da <tcp_timer_needed>
  return ERR_OK;
  8055dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8055e2:	eb 05                	jmp    8055e9 <tcp_bind+0x135>
        return ERR_USE;
  8055e4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8055e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8055ec:	5b                   	pop    %ebx
  8055ed:	5e                   	pop    %esi
  8055ee:	5f                   	pop    %edi
  8055ef:	5d                   	pop    %ebp
  8055f0:	c3                   	ret    
        return ERR_USE;
  8055f1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8055f6:	eb f1                	jmp    8055e9 <tcp_bind+0x135>
        return ERR_USE;
  8055f8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8055fd:	eb ea                	jmp    8055e9 <tcp_bind+0x135>

008055ff <tcp_listen_with_backlog>:
{
  8055ff:	55                   	push   %ebp
  805600:	89 e5                	mov    %esp,%ebp
  805602:	57                   	push   %edi
  805603:	56                   	push   %esi
  805604:	53                   	push   %ebx
  805605:	83 ec 1c             	sub    $0x1c,%esp
  805608:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80560b:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80560f:	0f 85 80 00 00 00    	jne    805695 <tcp_listen_with_backlog+0x96>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805615:	83 ec 0c             	sub    $0xc,%esp
  805618:	6a 03                	push   $0x3
  80561a:	e8 42 ef ff ff       	call   804561 <memp_malloc>
  80561f:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805621:	83 c4 10             	add    $0x10,%esp
  805624:	85 c0                	test   %eax,%eax
  805626:	0f 84 b7 00 00 00    	je     8056e3 <tcp_listen_with_backlog+0xe4>
  lpcb->callback_arg = pcb->callback_arg;
  80562c:	8b 43 18             	mov    0x18(%ebx),%eax
  80562f:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805632:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805636:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80563a:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  805641:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805645:	83 c8 02             	or     $0x2,%eax
  805648:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80564c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805650:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805653:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805657:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80565a:	8b 03                	mov    (%ebx),%eax
  80565c:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80565e:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  805664:	39 da                	cmp    %ebx,%edx
  805666:	74 44                	je     8056ac <tcp_listen_with_backlog+0xad>
  805668:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  80566e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805672:	89 df                	mov    %ebx,%edi
  805674:	85 d2                	test   %edx,%edx
  805676:	0f 84 87 00 00 00    	je     805703 <tcp_listen_with_backlog+0x104>
  80567c:	8b 42 0c             	mov    0xc(%edx),%eax
  80567f:	39 f8                	cmp    %edi,%eax
  805681:	0f 94 c3             	sete   %bl
  805684:	85 c0                	test   %eax,%eax
  805686:	0f 95 c1             	setne  %cl
  805689:	84 cb                	test   %cl,%bl
  80568b:	75 60                	jne    8056ed <tcp_listen_with_backlog+0xee>
  80568d:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805691:	89 c2                	mov    %eax,%edx
  805693:	eb df                	jmp    805674 <tcp_listen_with_backlog+0x75>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805695:	83 ec 04             	sub    $0x4,%esp
  805698:	68 38 22 81 00       	push   $0x812238
  80569d:	68 60 01 00 00       	push   $0x160
  8056a2:	68 ee 23 81 00       	push   $0x8123ee
  8056a7:	e8 c3 90 00 00       	call   80e76f <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8056ac:	8b 43 0c             	mov    0xc(%ebx),%eax
  8056af:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  8056b4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8056bb:	83 ec 08             	sub    $0x8,%esp
  8056be:	53                   	push   %ebx
  8056bf:	6a 02                	push   $0x2
  8056c1:	e8 f1 ee ff ff       	call   8045b7 <memp_free>
  lpcb->accept = tcp_accept_null;
  8056c6:	c7 46 20 45 54 80 00 	movl   $0x805445,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8056cd:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  8056d2:	89 46 0c             	mov    %eax,0xc(%esi)
  8056d5:	89 35 44 c2 b3 00    	mov    %esi,0xb3c244
  8056db:	e8 fa cb ff ff       	call   8022da <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8056e0:	83 c4 10             	add    $0x10,%esp
}
  8056e3:	89 f0                	mov    %esi,%eax
  8056e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8056e8:	5b                   	pop    %ebx
  8056e9:	5e                   	pop    %esi
  8056ea:	5f                   	pop    %edi
  8056eb:	5d                   	pop    %ebp
  8056ec:	c3                   	ret    
  8056ed:	89 fb                	mov    %edi,%ebx
  8056ef:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8056f3:	74 06                	je     8056fb <tcp_listen_with_backlog+0xfc>
  8056f5:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8056fb:	8b 43 0c             	mov    0xc(%ebx),%eax
  8056fe:	89 42 0c             	mov    %eax,0xc(%edx)
  805701:	eb b1                	jmp    8056b4 <tcp_listen_with_backlog+0xb5>
  805703:	89 fb                	mov    %edi,%ebx
  805705:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805709:	74 a9                	je     8056b4 <tcp_listen_with_backlog+0xb5>
  80570b:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805712:	00 00 00 
  805715:	eb 9d                	jmp    8056b4 <tcp_listen_with_backlog+0xb5>

00805717 <tcp_recved>:
{
  805717:	55                   	push   %ebp
  805718:	89 e5                	mov    %esp,%ebp
  80571a:	56                   	push   %esi
  80571b:	53                   	push   %ebx
  80571c:	8b 45 08             	mov    0x8(%ebp),%eax
  80571f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805722:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805726:	0f b7 ca             	movzwl %dx,%ecx
  805729:	0f b7 f3             	movzwl %bx,%esi
  80572c:	01 f1                	add    %esi,%ecx
  80572e:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805734:	76 27                	jbe    80575d <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  805736:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80573c:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805742:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805746:	f6 c2 03             	test   $0x3,%dl
  805749:	75 3b                	jne    805786 <tcp_recved+0x6f>
    tcp_ack(pcb);
  80574b:	f6 c2 01             	test   $0x1,%dl
  80574e:	75 1f                	jne    80576f <tcp_recved+0x58>
  805750:	83 ca 01             	or     $0x1,%edx
  805753:	88 50 20             	mov    %dl,0x20(%eax)
}
  805756:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805759:	5b                   	pop    %ebx
  80575a:	5e                   	pop    %esi
  80575b:	5d                   	pop    %ebp
  80575c:	c3                   	ret    
    pcb->rcv_wnd += len;
  80575d:	01 da                	add    %ebx,%edx
  80575f:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805763:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805767:	72 d9                	jb     805742 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805769:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  80576d:	eb d3                	jmp    805742 <tcp_recved+0x2b>
    tcp_ack(pcb);
  80576f:	83 e2 fe             	and    $0xfffffffe,%edx
  805772:	83 ca 02             	or     $0x2,%edx
  805775:	88 50 20             	mov    %dl,0x20(%eax)
  805778:	83 ec 0c             	sub    $0xc,%esp
  80577b:	50                   	push   %eax
  80577c:	e8 be 29 00 00       	call   80813f <tcp_output>
  805781:	83 c4 10             	add    $0x10,%esp
  805784:	eb d0                	jmp    805756 <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805786:	f6 c2 01             	test   $0x1,%dl
  805789:	74 cb                	je     805756 <tcp_recved+0x3f>
  80578b:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805791:	76 c3                	jbe    805756 <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805793:	83 ca 02             	or     $0x2,%edx
  805796:	88 50 20             	mov    %dl,0x20(%eax)
  805799:	83 ec 0c             	sub    $0xc,%esp
  80579c:	50                   	push   %eax
  80579d:	e8 9d 29 00 00       	call   80813f <tcp_output>
  8057a2:	83 c4 10             	add    $0x10,%esp
}
  8057a5:	eb af                	jmp    805756 <tcp_recved+0x3f>

008057a7 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  8057a7:	55                   	push   %ebp
  8057a8:	89 e5                	mov    %esp,%ebp
  8057aa:	53                   	push   %ebx
  8057ab:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8057ae:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
  8057b4:	eb 21                	jmp    8057d7 <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8057b6:	83 ec 0c             	sub    $0xc,%esp
  8057b9:	50                   	push   %eax
  8057ba:	e8 45 f1 ff ff       	call   804904 <pbuf_free>
  8057bf:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8057c2:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8057c9:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8057cc:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8057d0:	a8 01                	test   $0x1,%al
  8057d2:	75 2d                	jne    805801 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8057d4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8057d7:	85 db                	test   %ebx,%ebx
  8057d9:	74 3e                	je     805819 <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  8057db:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8057e1:	85 c0                	test   %eax,%eax
  8057e3:	74 e7                	je     8057cc <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8057e5:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8057eb:	85 d2                	test   %edx,%edx
  8057ed:	74 c7                	je     8057b6 <tcp_fasttmr+0xf>
  8057ef:	6a 00                	push   $0x0
  8057f1:	50                   	push   %eax
  8057f2:	53                   	push   %ebx
  8057f3:	ff 73 18             	pushl  0x18(%ebx)
  8057f6:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8057f8:	83 c4 10             	add    $0x10,%esp
  8057fb:	84 c0                	test   %al,%al
  8057fd:	74 c3                	je     8057c2 <tcp_fasttmr+0x1b>
  8057ff:	eb cb                	jmp    8057cc <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805801:	83 c8 02             	or     $0x2,%eax
  805804:	88 43 20             	mov    %al,0x20(%ebx)
  805807:	83 ec 0c             	sub    $0xc,%esp
  80580a:	53                   	push   %ebx
  80580b:	e8 2f 29 00 00       	call   80813f <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805810:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805814:	83 c4 10             	add    $0x10,%esp
  805817:	eb bb                	jmp    8057d4 <tcp_fasttmr+0x2d>
    }
  }
}
  805819:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80581c:	c9                   	leave  
  80581d:	c3                   	ret    

0080581e <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80581e:	55                   	push   %ebp
  80581f:	89 e5                	mov    %esp,%ebp
  805821:	56                   	push   %esi
  805822:	53                   	push   %ebx
  805823:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  805826:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  80582b:	85 db                	test   %ebx,%ebx
  80582d:	74 23                	je     805852 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  80582f:	8b 43 04             	mov    0x4(%ebx),%eax
  805832:	85 c0                	test   %eax,%eax
  805834:	74 0e                	je     805844 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805836:	83 ec 0c             	sub    $0xc,%esp
  805839:	50                   	push   %eax
  80583a:	e8 c5 f0 ff ff       	call   804904 <pbuf_free>
  80583f:	89 c6                	mov    %eax,%esi
  805841:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805844:	83 ec 08             	sub    $0x8,%esp
  805847:	53                   	push   %ebx
  805848:	6a 04                	push   $0x4
  80584a:	e8 68 ed ff ff       	call   8045b7 <memp_free>
  80584f:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  805852:	89 f0                	mov    %esi,%eax
  805854:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805857:	5b                   	pop    %ebx
  805858:	5e                   	pop    %esi
  805859:	5d                   	pop    %ebp
  80585a:	c3                   	ret    

0080585b <tcp_segs_free>:
{
  80585b:	55                   	push   %ebp
  80585c:	89 e5                	mov    %esp,%ebp
  80585e:	56                   	push   %esi
  80585f:	53                   	push   %ebx
  805860:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805863:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  805868:	85 c0                	test   %eax,%eax
  80586a:	74 14                	je     805880 <tcp_segs_free+0x25>
    next = seg->next;
  80586c:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  80586e:	83 ec 0c             	sub    $0xc,%esp
  805871:	50                   	push   %eax
  805872:	e8 a7 ff ff ff       	call   80581e <tcp_seg_free>
  805877:	01 c3                	add    %eax,%ebx
    seg = next;
  805879:	83 c4 10             	add    $0x10,%esp
  80587c:	89 f0                	mov    %esi,%eax
  80587e:	eb e8                	jmp    805868 <tcp_segs_free+0xd>
}
  805880:	89 d8                	mov    %ebx,%eax
  805882:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805885:	5b                   	pop    %ebx
  805886:	5e                   	pop    %esi
  805887:	5d                   	pop    %ebp
  805888:	c3                   	ret    

00805889 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805889:	55                   	push   %ebp
  80588a:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80588c:	8b 45 08             	mov    0x8(%ebp),%eax
  80588f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805892:	88 50 14             	mov    %dl,0x14(%eax)
}
  805895:	5d                   	pop    %ebp
  805896:	c3                   	ret    

00805897 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805897:	55                   	push   %ebp
  805898:	89 e5                	mov    %esp,%ebp
  80589a:	53                   	push   %ebx
  80589b:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80589e:	6a 04                	push   $0x4
  8058a0:	e8 bc ec ff ff       	call   804561 <memp_malloc>
  8058a5:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8058a7:	83 c4 10             	add    $0x10,%esp
  8058aa:	85 c0                	test   %eax,%eax
  8058ac:	74 1c                	je     8058ca <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8058ae:	83 ec 04             	sub    $0x4,%esp
  8058b1:	6a 14                	push   $0x14
  8058b3:	ff 75 08             	pushl  0x8(%ebp)
  8058b6:	50                   	push   %eax
  8058b7:	e8 f8 98 00 00       	call   80f1b4 <memcpy>
  pbuf_ref(cseg->p);
  8058bc:	83 c4 04             	add    $0x4,%esp
  8058bf:	ff 73 04             	pushl  0x4(%ebx)
  8058c2:	e8 9f f4 ff ff       	call   804d66 <pbuf_ref>
  return cseg;
  8058c7:	83 c4 10             	add    $0x10,%esp
}
  8058ca:	89 d8                	mov    %ebx,%eax
  8058cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8058cf:	c9                   	leave  
  8058d0:	c3                   	ret    

008058d1 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8058d1:	55                   	push   %ebp
  8058d2:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8058d4:	8b 45 08             	mov    0x8(%ebp),%eax
  8058d7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058da:	89 50 18             	mov    %edx,0x18(%eax)
}
  8058dd:	5d                   	pop    %ebp
  8058de:	c3                   	ret    

008058df <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8058df:	55                   	push   %ebp
  8058e0:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8058e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8058e5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058e8:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8058ee:	5d                   	pop    %ebp
  8058ef:	c3                   	ret    

008058f0 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8058f0:	55                   	push   %ebp
  8058f1:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  8058f3:	8b 45 08             	mov    0x8(%ebp),%eax
  8058f6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058f9:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  8058ff:	5d                   	pop    %ebp
  805900:	c3                   	ret    

00805901 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805901:	55                   	push   %ebp
  805902:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805904:	8b 45 08             	mov    0x8(%ebp),%eax
  805907:	8b 55 0c             	mov    0xc(%ebp),%edx
  80590a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805910:	5d                   	pop    %ebp
  805911:	c3                   	ret    

00805912 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805912:	55                   	push   %ebp
  805913:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805915:	8b 45 08             	mov    0x8(%ebp),%eax
  805918:	8b 55 0c             	mov    0xc(%ebp),%edx
  80591b:	89 50 20             	mov    %edx,0x20(%eax)
}
  80591e:	5d                   	pop    %ebp
  80591f:	c3                   	ret    

00805920 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805920:	55                   	push   %ebp
  805921:	89 e5                	mov    %esp,%ebp
  805923:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805926:	8b 55 0c             	mov    0xc(%ebp),%edx
  805929:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  80592f:	8b 55 10             	mov    0x10(%ebp),%edx
  805932:	88 50 31             	mov    %dl,0x31(%eax)
}
  805935:	5d                   	pop    %ebp
  805936:	c3                   	ret    

00805937 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805937:	55                   	push   %ebp
  805938:	89 e5                	mov    %esp,%ebp
  80593a:	53                   	push   %ebx
  80593b:	83 ec 04             	sub    $0x4,%esp
  80593e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805941:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805944:	83 f8 0a             	cmp    $0xa,%eax
  805947:	74 05                	je     80594e <tcp_pcb_purge+0x17>
  805949:	83 f8 01             	cmp    $0x1,%eax
  80594c:	77 05                	ja     805953 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  80594e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805951:	c9                   	leave  
  805952:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805953:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805959:	85 c0                	test   %eax,%eax
  80595b:	74 16                	je     805973 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  80595d:	83 ec 0c             	sub    $0xc,%esp
  805960:	50                   	push   %eax
  805961:	e8 9e ef ff ff       	call   804904 <pbuf_free>
      pcb->refused_data = NULL;
  805966:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80596d:	00 00 00 
  805970:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805973:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805979:	83 ec 0c             	sub    $0xc,%esp
  80597c:	ff 73 7c             	pushl  0x7c(%ebx)
  80597f:	e8 d7 fe ff ff       	call   80585b <tcp_segs_free>
    pcb->ooseq = NULL;
  805984:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  80598b:	83 c4 04             	add    $0x4,%esp
  80598e:	ff 73 74             	pushl  0x74(%ebx)
  805991:	e8 c5 fe ff ff       	call   80585b <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805996:	83 c4 04             	add    $0x4,%esp
  805999:	ff 73 78             	pushl  0x78(%ebx)
  80599c:	e8 ba fe ff ff       	call   80585b <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8059a1:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8059a8:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  8059af:	83 c4 10             	add    $0x10,%esp
}
  8059b2:	eb 9a                	jmp    80594e <tcp_pcb_purge+0x17>

008059b4 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8059b4:	55                   	push   %ebp
  8059b5:	89 e5                	mov    %esp,%ebp
  8059b7:	57                   	push   %edi
  8059b8:	56                   	push   %esi
  8059b9:	53                   	push   %ebx
  8059ba:	83 ec 0c             	sub    $0xc,%esp
  8059bd:	8b 45 08             	mov    0x8(%ebp),%eax
  8059c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8059c3:	8b 10                	mov    (%eax),%edx
  8059c5:	39 da                	cmp    %ebx,%edx
  8059c7:	74 2f                	je     8059f8 <tcp_pcb_remove+0x44>
  8059c9:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  8059cf:	bf 00 00 00 00       	mov    $0x0,%edi
  8059d4:	89 de                	mov    %ebx,%esi
  8059d6:	85 d2                	test   %edx,%edx
  8059d8:	0f 84 82 00 00 00    	je     805a60 <tcp_pcb_remove+0xac>
  8059de:	8b 42 0c             	mov    0xc(%edx),%eax
  8059e1:	39 f0                	cmp    %esi,%eax
  8059e3:	0f 94 c3             	sete   %bl
  8059e6:	85 c0                	test   %eax,%eax
  8059e8:	0f 95 c1             	setne  %cl
  8059eb:	84 cb                	test   %cl,%bl
  8059ed:	75 5b                	jne    805a4a <tcp_pcb_remove+0x96>
  8059ef:	bf 01 00 00 00       	mov    $0x1,%edi
  8059f4:	89 c2                	mov    %eax,%edx
  8059f6:	eb de                	jmp    8059d6 <tcp_pcb_remove+0x22>
  8059f8:	8b 53 0c             	mov    0xc(%ebx),%edx
  8059fb:	89 10                	mov    %edx,(%eax)
  8059fd:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805a04:	83 ec 0c             	sub    $0xc,%esp
  805a07:	53                   	push   %ebx
  805a08:	e8 2a ff ff ff       	call   805937 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805a0d:	8b 43 10             	mov    0x10(%ebx),%eax
  805a10:	83 c4 10             	add    $0x10,%esp
  805a13:	83 f8 0a             	cmp    $0xa,%eax
  805a16:	74 6e                	je     805a86 <tcp_pcb_remove+0xd2>
  805a18:	83 f8 01             	cmp    $0x1,%eax
  805a1b:	74 69                	je     805a86 <tcp_pcb_remove+0xd2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805a1d:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805a21:	a8 01                	test   $0x1,%al
  805a23:	75 4f                	jne    805a74 <tcp_pcb_remove+0xc0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805a25:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805a29:	75 63                	jne    805a8e <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805a2b:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805a2f:	75 74                	jne    805aa5 <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805a31:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805a35:	0f 85 81 00 00 00    	jne    805abc <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805a3b:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805a42:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805a45:	5b                   	pop    %ebx
  805a46:	5e                   	pop    %esi
  805a47:	5f                   	pop    %edi
  805a48:	5d                   	pop    %ebp
  805a49:	c3                   	ret    
  805a4a:	89 f3                	mov    %esi,%ebx
  805a4c:	89 f8                	mov    %edi,%eax
  805a4e:	84 c0                	test   %al,%al
  805a50:	74 06                	je     805a58 <tcp_pcb_remove+0xa4>
  805a52:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(pcblist, pcb);
  805a58:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a5b:	89 42 0c             	mov    %eax,0xc(%edx)
  805a5e:	eb 9d                	jmp    8059fd <tcp_pcb_remove+0x49>
  805a60:	89 f3                	mov    %esi,%ebx
  805a62:	89 f8                	mov    %edi,%eax
  805a64:	84 c0                	test   %al,%al
  805a66:	74 95                	je     8059fd <tcp_pcb_remove+0x49>
  805a68:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805a6f:	00 00 00 
  805a72:	eb 89                	jmp    8059fd <tcp_pcb_remove+0x49>
    pcb->flags |= TF_ACK_NOW;
  805a74:	83 c8 02             	or     $0x2,%eax
  805a77:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805a7a:	83 ec 0c             	sub    $0xc,%esp
  805a7d:	53                   	push   %ebx
  805a7e:	e8 bc 26 00 00       	call   80813f <tcp_output>
  805a83:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805a86:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805a8a:	74 af                	je     805a3b <tcp_pcb_remove+0x87>
  805a8c:	eb 97                	jmp    805a25 <tcp_pcb_remove+0x71>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805a8e:	83 ec 04             	sub    $0x4,%esp
  805a91:	68 02 24 81 00       	push   $0x812402
  805a96:	68 b4 04 00 00       	push   $0x4b4
  805a9b:	68 ee 23 81 00       	push   $0x8123ee
  805aa0:	e8 ca 8c 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805aa5:	83 ec 04             	sub    $0x4,%esp
  805aa8:	68 1a 24 81 00       	push   $0x81241a
  805aad:	68 b5 04 00 00       	push   $0x4b5
  805ab2:	68 ee 23 81 00       	push   $0x8123ee
  805ab7:	e8 b3 8c 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805abc:	83 ec 04             	sub    $0x4,%esp
  805abf:	68 33 24 81 00       	push   $0x812433
  805ac4:	68 b7 04 00 00       	push   $0x4b7
  805ac9:	68 ee 23 81 00       	push   $0x8123ee
  805ace:	e8 9c 8c 00 00       	call   80e76f <_panic>

00805ad3 <tcp_close>:
{
  805ad3:	55                   	push   %ebp
  805ad4:	89 e5                	mov    %esp,%ebp
  805ad6:	57                   	push   %edi
  805ad7:	56                   	push   %esi
  805ad8:	53                   	push   %ebx
  805ad9:	83 ec 0c             	sub    $0xc,%esp
  805adc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  805adf:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805ae3:	0f 87 3e 01 00 00    	ja     805c27 <tcp_close+0x154>
  805ae9:	8b 43 10             	mov    0x10(%ebx),%eax
  805aec:	ff 24 85 4c 24 81 00 	jmp    *0x81244c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805af3:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  805af9:	39 da                	cmp    %ebx,%edx
  805afb:	74 2b                	je     805b28 <tcp_close+0x55>
  805afd:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  805b03:	bf 00 00 00 00       	mov    $0x0,%edi
  805b08:	89 de                	mov    %ebx,%esi
  805b0a:	85 d2                	test   %edx,%edx
  805b0c:	74 57                	je     805b65 <tcp_close+0x92>
  805b0e:	8b 42 0c             	mov    0xc(%edx),%eax
  805b11:	39 f0                	cmp    %esi,%eax
  805b13:	0f 94 c3             	sete   %bl
  805b16:	85 c0                	test   %eax,%eax
  805b18:	0f 95 c1             	setne  %cl
  805b1b:	84 cb                	test   %cl,%bl
  805b1d:	75 30                	jne    805b4f <tcp_close+0x7c>
  805b1f:	bf 01 00 00 00       	mov    $0x1,%edi
  805b24:	89 c2                	mov    %eax,%edx
  805b26:	eb e2                	jmp    805b0a <tcp_close+0x37>
  805b28:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b2b:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  805b30:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805b37:	83 ec 08             	sub    $0x8,%esp
  805b3a:	53                   	push   %ebx
  805b3b:	6a 02                	push   $0x2
  805b3d:	e8 75 ea ff ff       	call   8045b7 <memp_free>
    break;
  805b42:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b45:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b4a:	e9 9a 00 00 00       	jmp    805be9 <tcp_close+0x116>
  805b4f:	89 f3                	mov    %esi,%ebx
  805b51:	89 f8                	mov    %edi,%eax
  805b53:	84 c0                	test   %al,%al
  805b55:	74 06                	je     805b5d <tcp_close+0x8a>
  805b57:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805b5d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b60:	89 42 0c             	mov    %eax,0xc(%edx)
  805b63:	eb cb                	jmp    805b30 <tcp_close+0x5d>
  805b65:	89 f3                	mov    %esi,%ebx
  805b67:	89 f8                	mov    %edi,%eax
  805b69:	84 c0                	test   %al,%al
  805b6b:	74 c3                	je     805b30 <tcp_close+0x5d>
  805b6d:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805b74:	00 00 00 
  805b77:	eb b7                	jmp    805b30 <tcp_close+0x5d>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805b79:	83 ec 08             	sub    $0x8,%esp
  805b7c:	53                   	push   %ebx
  805b7d:	68 44 c2 b3 00       	push   $0xb3c244
  805b82:	e8 2d fe ff ff       	call   8059b4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805b87:	83 c4 08             	add    $0x8,%esp
  805b8a:	53                   	push   %ebx
  805b8b:	6a 03                	push   $0x3
  805b8d:	e8 25 ea ff ff       	call   8045b7 <memp_free>
    break;
  805b92:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b95:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b9a:	eb 4d                	jmp    805be9 <tcp_close+0x116>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b9c:	83 ec 08             	sub    $0x8,%esp
  805b9f:	53                   	push   %ebx
  805ba0:	68 3c c2 b3 00       	push   $0xb3c23c
  805ba5:	e8 0a fe ff ff       	call   8059b4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805baa:	83 c4 08             	add    $0x8,%esp
  805bad:	53                   	push   %ebx
  805bae:	6a 02                	push   $0x2
  805bb0:	e8 02 ea ff ff       	call   8045b7 <memp_free>
    break;
  805bb5:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805bb8:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805bbd:	eb 2a                	jmp    805be9 <tcp_close+0x116>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805bbf:	83 ec 08             	sub    $0x8,%esp
  805bc2:	6a 01                	push   $0x1
  805bc4:	53                   	push   %ebx
  805bc5:	e8 ff 24 00 00       	call   8080c9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805bca:	83 c4 10             	add    $0x10,%esp
  805bcd:	84 c0                	test   %al,%al
  805bcf:	75 18                	jne    805be9 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805bd1:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805bd8:	83 ec 0c             	sub    $0xc,%esp
  805bdb:	53                   	push   %ebx
  805bdc:	e8 5e 25 00 00       	call   80813f <tcp_output>
  805be1:	83 c4 10             	add    $0x10,%esp
  805be4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805be9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805bec:	5b                   	pop    %ebx
  805bed:	5e                   	pop    %esi
  805bee:	5f                   	pop    %edi
  805bef:	5d                   	pop    %ebp
  805bf0:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805bf1:	83 ec 08             	sub    $0x8,%esp
  805bf4:	6a 01                	push   $0x1
  805bf6:	53                   	push   %ebx
  805bf7:	e8 cd 24 00 00       	call   8080c9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805bfc:	83 c4 10             	add    $0x10,%esp
  805bff:	84 c0                	test   %al,%al
  805c01:	75 e6                	jne    805be9 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805c03:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805c0a:	eb cc                	jmp    805bd8 <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805c0c:	83 ec 08             	sub    $0x8,%esp
  805c0f:	6a 01                	push   $0x1
  805c11:	53                   	push   %ebx
  805c12:	e8 b2 24 00 00       	call   8080c9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805c17:	83 c4 10             	add    $0x10,%esp
  805c1a:	84 c0                	test   %al,%al
  805c1c:	75 cb                	jne    805be9 <tcp_close+0x116>
      pcb->state = LAST_ACK;
  805c1e:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805c25:	eb b1                	jmp    805bd8 <tcp_close+0x105>
    err = ERR_OK;
  805c27:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805c2c:	eb bb                	jmp    805be9 <tcp_close+0x116>

00805c2e <tcp_recv_null>:
{
  805c2e:	55                   	push   %ebp
  805c2f:	89 e5                	mov    %esp,%ebp
  805c31:	83 ec 08             	sub    $0x8,%esp
  805c34:	8b 45 10             	mov    0x10(%ebp),%eax
  805c37:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805c3a:	85 c0                	test   %eax,%eax
  805c3c:	74 13                	je     805c51 <tcp_recv_null+0x23>
    pbuf_free(p);
  805c3e:	83 ec 0c             	sub    $0xc,%esp
  805c41:	50                   	push   %eax
  805c42:	e8 bd ec ff ff       	call   804904 <pbuf_free>
  805c47:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805c4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805c4f:	c9                   	leave  
  805c50:	c3                   	ret    
  return ERR_OK;
  805c51:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805c56:	84 d2                	test   %dl,%dl
  805c58:	75 f5                	jne    805c4f <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805c5a:	83 ec 0c             	sub    $0xc,%esp
  805c5d:	ff 75 0c             	pushl  0xc(%ebp)
  805c60:	e8 6e fe ff ff       	call   805ad3 <tcp_close>
  805c65:	83 c4 10             	add    $0x10,%esp
  805c68:	eb e5                	jmp    805c4f <tcp_recv_null+0x21>

00805c6a <tcp_abort>:
{
  805c6a:	55                   	push   %ebp
  805c6b:	89 e5                	mov    %esp,%ebp
  805c6d:	57                   	push   %edi
  805c6e:	56                   	push   %esi
  805c6f:	53                   	push   %ebx
  805c70:	83 ec 2c             	sub    $0x2c,%esp
  805c73:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805c76:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805c7a:	0f 84 c2 00 00 00    	je     805d42 <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805c80:	8b 43 54             	mov    0x54(%ebx),%eax
  805c83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805c86:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805c89:	8b 03                	mov    (%ebx),%eax
  805c8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805c8e:	8b 43 04             	mov    0x4(%ebx),%eax
  805c91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805c94:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c98:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805c9c:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805ca0:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805ca4:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805caa:	8b 43 18             	mov    0x18(%ebx),%eax
  805cad:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805cb0:	83 ec 08             	sub    $0x8,%esp
  805cb3:	53                   	push   %ebx
  805cb4:	68 3c c2 b3 00       	push   $0xb3c23c
  805cb9:	e8 f6 fc ff ff       	call   8059b4 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805cbe:	8b 43 78             	mov    0x78(%ebx),%eax
  805cc1:	83 c4 10             	add    $0x10,%esp
  805cc4:	85 c0                	test   %eax,%eax
  805cc6:	74 0c                	je     805cd4 <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805cc8:	83 ec 0c             	sub    $0xc,%esp
  805ccb:	50                   	push   %eax
  805ccc:	e8 8a fb ff ff       	call   80585b <tcp_segs_free>
  805cd1:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805cd4:	8b 43 74             	mov    0x74(%ebx),%eax
  805cd7:	85 c0                	test   %eax,%eax
  805cd9:	74 0c                	je     805ce7 <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805cdb:	83 ec 0c             	sub    $0xc,%esp
  805cde:	50                   	push   %eax
  805cdf:	e8 77 fb ff ff       	call   80585b <tcp_segs_free>
  805ce4:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805ce7:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805cea:	85 c0                	test   %eax,%eax
  805cec:	74 0c                	je     805cfa <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805cee:	83 ec 0c             	sub    $0xc,%esp
  805cf1:	50                   	push   %eax
  805cf2:	e8 64 fb ff ff       	call   80585b <tcp_segs_free>
  805cf7:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805cfa:	83 ec 08             	sub    $0x8,%esp
  805cfd:	53                   	push   %ebx
  805cfe:	6a 02                	push   $0x2
  805d00:	e8 b2 e8 ff ff       	call   8045b7 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805d05:	83 c4 10             	add    $0x10,%esp
  805d08:	85 f6                	test   %esi,%esi
  805d0a:	74 0d                	je     805d19 <tcp_abort+0xaf>
  805d0c:	83 ec 08             	sub    $0x8,%esp
  805d0f:	6a fb                	push   $0xfffffffb
  805d11:	ff 75 cc             	pushl  -0x34(%ebp)
  805d14:	ff d6                	call   *%esi
  805d16:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805d19:	83 ec 08             	sub    $0x8,%esp
  805d1c:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805d20:	50                   	push   %eax
  805d21:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805d25:	50                   	push   %eax
  805d26:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805d29:	50                   	push   %eax
  805d2a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805d2d:	50                   	push   %eax
  805d2e:	57                   	push   %edi
  805d2f:	ff 75 d4             	pushl  -0x2c(%ebp)
  805d32:	e8 a8 28 00 00       	call   8085df <tcp_rst>
  805d37:	83 c4 20             	add    $0x20,%esp
}
  805d3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805d3d:	5b                   	pop    %ebx
  805d3e:	5e                   	pop    %esi
  805d3f:	5f                   	pop    %edi
  805d40:	5d                   	pop    %ebp
  805d41:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805d42:	83 ec 08             	sub    $0x8,%esp
  805d45:	53                   	push   %ebx
  805d46:	68 50 c2 b3 00       	push   $0xb3c250
  805d4b:	e8 64 fc ff ff       	call   8059b4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805d50:	83 c4 08             	add    $0x8,%esp
  805d53:	53                   	push   %ebx
  805d54:	6a 02                	push   $0x2
  805d56:	e8 5c e8 ff ff       	call   8045b7 <memp_free>
  805d5b:	83 c4 10             	add    $0x10,%esp
  805d5e:	eb da                	jmp    805d3a <tcp_abort+0xd0>

00805d60 <tcp_slowtmr>:
{
  805d60:	55                   	push   %ebp
  805d61:	89 e5                	mov    %esp,%ebp
  805d63:	57                   	push   %edi
  805d64:	56                   	push   %esi
  805d65:	53                   	push   %ebx
  805d66:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805d69:	83 05 40 c2 b3 00 01 	addl   $0x1,0xb3c240
  pcb = tcp_active_pcbs;
  805d70:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
  err = ERR_OK;
  805d76:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805d7a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805d81:	e9 2a 02 00 00       	jmp    805fb0 <tcp_slowtmr+0x250>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805d86:	83 ec 04             	sub    $0x4,%esp
  805d89:	68 5c 22 81 00       	push   $0x81225c
  805d8e:	68 36 02 00 00       	push   $0x236
  805d93:	68 ee 23 81 00       	push   $0x8123ee
  805d98:	e8 d2 89 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805d9d:	83 ec 04             	sub    $0x4,%esp
  805da0:	68 88 22 81 00       	push   $0x812288
  805da5:	68 37 02 00 00       	push   $0x237
  805daa:	68 ee 23 81 00       	push   $0x8123ee
  805daf:	e8 bb 89 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805db4:	83 ec 04             	sub    $0x4,%esp
  805db7:	68 b4 22 81 00       	push   $0x8122b4
  805dbc:	68 38 02 00 00       	push   $0x238
  805dc1:	68 ee 23 81 00       	push   $0x8123ee
  805dc6:	e8 a4 89 00 00       	call   80e76f <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805dcb:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805dcf:	80 fa 06             	cmp    $0x6,%dl
  805dd2:	0f 84 d0 00 00 00    	je     805ea8 <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805dd8:	80 fa 0c             	cmp    $0xc,%dl
  805ddb:	0f 85 0b 02 00 00    	jne    805fec <tcp_slowtmr+0x28c>
  805de1:	be 01 00 00 00       	mov    $0x1,%esi
  805de6:	e9 c2 00 00 00       	jmp    805ead <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805deb:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805def:	66 85 c9             	test   %cx,%cx
  805df2:	78 07                	js     805dfb <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805df4:	83 c1 01             	add    $0x1,%ecx
  805df7:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805dfb:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805dff:	0f 84 45 02 00 00    	je     80604a <tcp_slowtmr+0x2ea>
  805e05:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805e09:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805e0d:	0f 8c 37 02 00 00    	jl     80604a <tcp_slowtmr+0x2ea>
          if (pcb->state != SYN_SENT) {
  805e13:	83 f8 02             	cmp    $0x2,%eax
  805e16:	74 1f                	je     805e37 <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805e18:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805e1c:	66 c1 f8 03          	sar    $0x3,%ax
  805e20:	98                   	cwtl   
  805e21:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805e25:	01 c8                	add    %ecx,%eax
  805e27:	0f b6 d2             	movzbl %dl,%edx
  805e2a:	0f b6 8a 74 24 81 00 	movzbl 0x812474(%edx),%ecx
  805e31:	d3 e0                	shl    %cl,%eax
  805e33:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805e37:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805e3d:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805e41:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805e45:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805e4a:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805e4d:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805e51:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805e54:	66 39 d0             	cmp    %dx,%ax
  805e57:	0f 42 c1             	cmovb  %ecx,%eax
  805e5a:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805e5e:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805e62:	83 ec 0c             	sub    $0xc,%esp
  805e65:	53                   	push   %ebx
  805e66:	e8 9d 28 00 00       	call   808708 <tcp_rexmit_rto>
  805e6b:	83 c4 10             	add    $0x10,%esp
  805e6e:	e9 d7 01 00 00       	jmp    80604a <tcp_slowtmr+0x2ea>
    pcb_remove = 0;
  805e73:	be 00 00 00 00       	mov    $0x0,%esi
  805e78:	e9 cd 01 00 00       	jmp    80604a <tcp_slowtmr+0x2ea>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e7d:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  805e82:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805e85:	83 f8 29             	cmp    $0x29,%eax
  805e88:	89 f0                	mov    %esi,%eax
  805e8a:	1c ff                	sbb    $0xff,%al
  805e8c:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805e8e:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e91:	85 c9                	test   %ecx,%ecx
  805e93:	75 1f                	jne    805eb4 <tcp_slowtmr+0x154>
  805e95:	e9 d0 00 00 00       	jmp    805f6a <tcp_slowtmr+0x20a>
        tcp_abort(pcb);
  805e9a:	83 ec 0c             	sub    $0xc,%esp
  805e9d:	53                   	push   %ebx
  805e9e:	e8 c7 fd ff ff       	call   805c6a <tcp_abort>
  805ea3:	83 c4 10             	add    $0x10,%esp
  805ea6:	eb 05                	jmp    805ead <tcp_slowtmr+0x14d>
  805ea8:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805ead:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805eb0:	85 c9                	test   %ecx,%ecx
  805eb2:	74 16                	je     805eca <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805eb4:	8b 15 40 c2 b3 00    	mov    0xb3c240,%edx
  805eba:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805ebd:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805ec1:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805ec4:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805ec6:	39 c2                	cmp    %eax,%edx
  805ec8:	73 7b                	jae    805f45 <tcp_slowtmr+0x1e5>
    if (pcb->state == SYN_RCVD) {
  805eca:	8b 43 10             	mov    0x10(%ebx),%eax
  805ecd:	83 f8 03             	cmp    $0x3,%eax
  805ed0:	0f 84 87 00 00 00    	je     805f5d <tcp_slowtmr+0x1fd>
    if (pcb->state == LAST_ACK) {
  805ed6:	83 f8 09             	cmp    $0x9,%eax
  805ed9:	0f 85 8b 00 00 00    	jne    805f6a <tcp_slowtmr+0x20a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805edf:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  805ee4:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805ee7:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805eec:	76 7c                	jbe    805f6a <tcp_slowtmr+0x20a>
      tcp_pcb_purge(pcb);      
  805eee:	83 ec 0c             	sub    $0xc,%esp
  805ef1:	53                   	push   %ebx
  805ef2:	e8 40 fa ff ff       	call   805937 <tcp_pcb_purge>
      if (prev != NULL) {
  805ef7:	83 c4 10             	add    $0x10,%esp
  805efa:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805efe:	0f 84 e1 01 00 00    	je     8060e5 <tcp_slowtmr+0x385>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805f04:	3b 1d 3c c2 b3 00    	cmp    0xb3c23c,%ebx
  805f0a:	0f 84 be 01 00 00    	je     8060ce <tcp_slowtmr+0x36e>
        prev->next = pcb->next;
  805f10:	8b 43 0c             	mov    0xc(%ebx),%eax
  805f13:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805f16:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805f19:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805f1f:	85 c0                	test   %eax,%eax
  805f21:	74 0d                	je     805f30 <tcp_slowtmr+0x1d0>
  805f23:	83 ec 08             	sub    $0x8,%esp
  805f26:	6a fb                	push   $0xfffffffb
  805f28:	ff 73 18             	pushl  0x18(%ebx)
  805f2b:	ff d0                	call   *%eax
  805f2d:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  805f30:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805f33:	83 ec 08             	sub    $0x8,%esp
  805f36:	53                   	push   %ebx
  805f37:	6a 02                	push   $0x2
  805f39:	e8 79 e6 ff ff       	call   8045b7 <memp_free>
  805f3e:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805f41:	89 f3                	mov    %esi,%ebx
  805f43:	eb 6b                	jmp    805fb0 <tcp_slowtmr+0x250>
      tcp_segs_free(pcb->ooseq);
  805f45:	83 ec 0c             	sub    $0xc,%esp
  805f48:	51                   	push   %ecx
  805f49:	e8 0d f9 ff ff       	call   80585b <tcp_segs_free>
      pcb->ooseq = NULL;
  805f4e:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805f55:	83 c4 10             	add    $0x10,%esp
  805f58:	e9 6d ff ff ff       	jmp    805eca <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805f5d:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  805f62:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805f65:	83 f8 28             	cmp    $0x28,%eax
  805f68:	77 84                	ja     805eee <tcp_slowtmr+0x18e>
    if (pcb_remove) {
  805f6a:	89 f0                	mov    %esi,%eax
  805f6c:	84 c0                	test   %al,%al
  805f6e:	0f 85 7a ff ff ff    	jne    805eee <tcp_slowtmr+0x18e>
      ++pcb->polltmr;
  805f74:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805f78:	83 c0 01             	add    $0x1,%eax
  805f7b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805f7e:	3a 43 31             	cmp    0x31(%ebx),%al
  805f81:	72 27                	jb     805faa <tcp_slowtmr+0x24a>
        pcb->polltmr = 0;
  805f83:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805f87:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805f8d:	85 c0                	test   %eax,%eax
  805f8f:	74 0f                	je     805fa0 <tcp_slowtmr+0x240>
  805f91:	83 ec 08             	sub    $0x8,%esp
  805f94:	53                   	push   %ebx
  805f95:	ff 73 18             	pushl  0x18(%ebx)
  805f98:	ff d0                	call   *%eax
  805f9a:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805f9d:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805fa0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805fa4:	0f 84 67 01 00 00    	je     806111 <tcp_slowtmr+0x3b1>
      prev = pcb;
  805faa:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  805fad:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805fb0:	85 db                	test   %ebx,%ebx
  805fb2:	0f 84 6a 01 00 00    	je     806122 <tcp_slowtmr+0x3c2>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805fb8:	8b 43 10             	mov    0x10(%ebx),%eax
  805fbb:	85 c0                	test   %eax,%eax
  805fbd:	0f 84 c3 fd ff ff    	je     805d86 <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805fc3:	83 f8 01             	cmp    $0x1,%eax
  805fc6:	0f 84 d1 fd ff ff    	je     805d9d <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805fcc:	83 f8 0a             	cmp    $0xa,%eax
  805fcf:	0f 84 df fd ff ff    	je     805db4 <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805fd5:	83 f8 02             	cmp    $0x2,%eax
  805fd8:	0f 84 ed fd ff ff    	je     805dcb <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805fde:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805fe2:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805fe7:	80 fa 0c             	cmp    $0xc,%dl
  805fea:	74 5e                	je     80604a <tcp_slowtmr+0x2ea>
      if (pcb->persist_backoff > 0) {
  805fec:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805ff3:	89 f1                	mov    %esi,%ecx
  805ff5:	84 c9                	test   %cl,%cl
  805ff7:	0f 84 ee fd ff ff    	je     805deb <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  805ffd:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  806003:	83 c0 01             	add    $0x1,%eax
  806006:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80600c:	0f b6 d1             	movzbl %cl,%edx
  80600f:	bf 6c 24 81 00       	mov    $0x81246c,%edi
  806014:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  806019:	39 d0                	cmp    %edx,%eax
  80601b:	0f 82 52 fe ff ff    	jb     805e73 <tcp_slowtmr+0x113>
          pcb->persist_cnt = 0;
  806021:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806028:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80602b:	80 f9 06             	cmp    $0x6,%cl
  80602e:	77 09                	ja     806039 <tcp_slowtmr+0x2d9>
            pcb->persist_backoff++;
  806030:	8d 46 01             	lea    0x1(%esi),%eax
  806033:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  806039:	83 ec 0c             	sub    $0xc,%esp
  80603c:	53                   	push   %ebx
  80603d:	e8 92 28 00 00       	call   8088d4 <tcp_zero_window_probe>
  806042:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  806045:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  80604a:	8b 43 10             	mov    0x10(%ebx),%eax
  80604d:	83 f8 06             	cmp    $0x6,%eax
  806050:	0f 84 27 fe ff ff    	je     805e7d <tcp_slowtmr+0x11d>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  806056:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80605a:	0f 84 4d fe ff ff    	je     805ead <tcp_slowtmr+0x14d>
  806060:	83 f8 04             	cmp    $0x4,%eax
  806063:	74 09                	je     80606e <tcp_slowtmr+0x30e>
  806065:	83 f8 07             	cmp    $0x7,%eax
  806068:	0f 85 3f fe ff ff    	jne    805ead <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80606e:	8b 0d 40 c2 b3 00    	mov    0xb3c240,%ecx
  806074:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806077:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  80607d:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  806083:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806088:	f7 e2                	mul    %edx
  80608a:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80608d:	39 d1                	cmp    %edx,%ecx
  80608f:	0f 87 05 fe ff ff    	ja     805e9a <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806095:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80609c:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  8060a2:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  8060a4:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8060a9:	f7 e2                	mul    %edx
  8060ab:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  8060ae:	39 d1                	cmp    %edx,%ecx
  8060b0:	0f 86 f7 fd ff ff    	jbe    805ead <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  8060b6:	83 ec 0c             	sub    $0xc,%esp
  8060b9:	53                   	push   %ebx
  8060ba:	e8 ef 26 00 00       	call   8087ae <tcp_keepalive>
        pcb->keep_cnt_sent++;
  8060bf:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  8060c6:	83 c4 10             	add    $0x10,%esp
  8060c9:	e9 df fd ff ff       	jmp    805ead <tcp_slowtmr+0x14d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8060ce:	83 ec 04             	sub    $0x4,%esp
  8060d1:	68 e4 22 81 00       	push   $0x8122e4
  8060d6:	68 c1 02 00 00       	push   $0x2c1
  8060db:	68 ee 23 81 00       	push   $0x8123ee
  8060e0:	e8 8a 86 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8060e5:	3b 1d 3c c2 b3 00    	cmp    0xb3c23c,%ebx
  8060eb:	75 0d                	jne    8060fa <tcp_slowtmr+0x39a>
        tcp_active_pcbs = pcb->next;
  8060ed:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060f0:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
  8060f5:	e9 1f fe ff ff       	jmp    805f19 <tcp_slowtmr+0x1b9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8060fa:	83 ec 04             	sub    $0x4,%esp
  8060fd:	68 10 23 81 00       	push   $0x812310
  806102:	68 c5 02 00 00       	push   $0x2c5
  806107:	68 ee 23 81 00       	push   $0x8123ee
  80610c:	e8 5e 86 00 00       	call   80e76f <_panic>
          tcp_output(pcb);
  806111:	83 ec 0c             	sub    $0xc,%esp
  806114:	53                   	push   %ebx
  806115:	e8 25 20 00 00       	call   80813f <tcp_output>
  80611a:	83 c4 10             	add    $0x10,%esp
  80611d:	e9 88 fe ff ff       	jmp    805faa <tcp_slowtmr+0x24a>
  pcb = tcp_tw_pcbs;
  806122:	8b 35 50 c2 b3 00    	mov    0xb3c250,%esi
  while (pcb != NULL) {
  806128:	eb 48                	jmp    806172 <tcp_slowtmr+0x412>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80612a:	83 ec 04             	sub    $0x4,%esp
  80612d:	68 3c 23 81 00       	push   $0x81233c
  806132:	68 e5 02 00 00       	push   $0x2e5
  806137:	68 ee 23 81 00       	push   $0x8123ee
  80613c:	e8 2e 86 00 00       	call   80e76f <_panic>
      tcp_pcb_purge(pcb);      
  806141:	83 ec 0c             	sub    $0xc,%esp
  806144:	56                   	push   %esi
  806145:	e8 ed f7 ff ff       	call   805937 <tcp_pcb_purge>
      if (prev != NULL) {
  80614a:	83 c4 10             	add    $0x10,%esp
  80614d:	85 db                	test   %ebx,%ebx
  80614f:	74 58                	je     8061a9 <tcp_slowtmr+0x449>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806151:	3b 35 50 c2 b3 00    	cmp    0xb3c250,%esi
  806157:	74 39                	je     806192 <tcp_slowtmr+0x432>
        prev->next = pcb->next;
  806159:	8b 46 0c             	mov    0xc(%esi),%eax
  80615c:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  80615f:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806162:	83 ec 08             	sub    $0x8,%esp
  806165:	56                   	push   %esi
  806166:	6a 02                	push   $0x2
  806168:	e8 4a e4 ff ff       	call   8045b7 <memp_free>
  80616d:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806170:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806172:	85 f6                	test   %esi,%esi
  806174:	74 5c                	je     8061d2 <tcp_slowtmr+0x472>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806176:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  80617a:	75 ae                	jne    80612a <tcp_slowtmr+0x3ca>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80617c:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  806181:	2b 46 2c             	sub    0x2c(%esi),%eax
  806184:	3d f0 00 00 00       	cmp    $0xf0,%eax
  806189:	77 b6                	ja     806141 <tcp_slowtmr+0x3e1>
      prev = pcb;
  80618b:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80618d:	8b 76 0c             	mov    0xc(%esi),%esi
  806190:	eb e0                	jmp    806172 <tcp_slowtmr+0x412>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806192:	83 ec 04             	sub    $0x4,%esp
  806195:	68 6c 23 81 00       	push   $0x81236c
  80619a:	68 f4 02 00 00       	push   $0x2f4
  80619f:	68 ee 23 81 00       	push   $0x8123ee
  8061a4:	e8 c6 85 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8061a9:	3b 35 50 c2 b3 00    	cmp    0xb3c250,%esi
  8061af:	75 0a                	jne    8061bb <tcp_slowtmr+0x45b>
        tcp_tw_pcbs = pcb->next;
  8061b1:	8b 46 0c             	mov    0xc(%esi),%eax
  8061b4:	a3 50 c2 b3 00       	mov    %eax,0xb3c250
  8061b9:	eb a4                	jmp    80615f <tcp_slowtmr+0x3ff>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8061bb:	83 ec 04             	sub    $0x4,%esp
  8061be:	68 94 23 81 00       	push   $0x812394
  8061c3:	68 f8 02 00 00       	push   $0x2f8
  8061c8:	68 ee 23 81 00       	push   $0x8123ee
  8061cd:	e8 9d 85 00 00       	call   80e76f <_panic>
}
  8061d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8061d5:	5b                   	pop    %ebx
  8061d6:	5e                   	pop    %esi
  8061d7:	5f                   	pop    %edi
  8061d8:	5d                   	pop    %ebp
  8061d9:	c3                   	ret    

008061da <tcp_tmr>:
{
  8061da:	55                   	push   %ebp
  8061db:	89 e5                	mov    %esp,%ebp
  8061dd:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  8061e0:	e8 c2 f5 ff ff       	call   8057a7 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8061e5:	0f b6 05 f9 53 b3 00 	movzbl 0xb353f9,%eax
  8061ec:	83 c0 01             	add    $0x1,%eax
  8061ef:	a2 f9 53 b3 00       	mov    %al,0xb353f9
  8061f4:	a8 01                	test   $0x1,%al
  8061f6:	75 02                	jne    8061fa <tcp_tmr+0x20>
}
  8061f8:	c9                   	leave  
  8061f9:	c3                   	ret    
    tcp_slowtmr();
  8061fa:	e8 61 fb ff ff       	call   805d60 <tcp_slowtmr>
}
  8061ff:	eb f7                	jmp    8061f8 <tcp_tmr+0x1e>

00806201 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806201:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  806206:	03 05 08 50 81 00    	add    0x815008,%eax
  80620c:	a3 08 50 81 00       	mov    %eax,0x815008
  return iss;
}
  806211:	c3                   	ret    

00806212 <tcp_alloc>:
{
  806212:	55                   	push   %ebp
  806213:	89 e5                	mov    %esp,%ebp
  806215:	57                   	push   %edi
  806216:	56                   	push   %esi
  806217:	53                   	push   %ebx
  806218:	83 ec 28             	sub    $0x28,%esp
  80621b:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  80621f:	6a 02                	push   $0x2
  806221:	e8 3b e3 ff ff       	call   804561 <memp_malloc>
  806226:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  806228:	83 c4 10             	add    $0x10,%esp
  80622b:	85 c0                	test   %eax,%eax
  80622d:	0f 84 a0 00 00 00    	je     8062d3 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806233:	83 ec 04             	sub    $0x4,%esp
  806236:	68 a8 00 00 00       	push   $0xa8
  80623b:	6a 00                	push   $0x0
  80623d:	53                   	push   %ebx
  80623e:	e8 c7 8e 00 00       	call   80f10a <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806243:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  806247:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80624d:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806253:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  806259:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  80625f:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806263:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806267:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80626d:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806273:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  806279:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  80627f:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806285:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80628b:	e8 71 ff ff ff       	call   806201 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806290:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806293:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806296:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806299:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  80629c:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80629f:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  8062a4:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  8062a7:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  8062ab:	c7 83 88 00 00 00 2e 	movl   $0x805c2e,0x88(%ebx)
  8062b2:	5c 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8062b5:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8062bc:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  8062bf:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  8062c6:	83 c4 10             	add    $0x10,%esp
}
  8062c9:	89 d8                	mov    %ebx,%eax
  8062cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8062ce:	5b                   	pop    %ebx
  8062cf:	5e                   	pop    %esi
  8062d0:	5f                   	pop    %edi
  8062d1:	5d                   	pop    %ebp
  8062d2:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8062d3:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062d8:	8b 3d 40 c2 b3 00    	mov    0xb3c240,%edi
  inactivity = 0;
  8062de:	b9 00 00 00 00       	mov    $0x0,%ecx
  8062e3:	eb 03                	jmp    8062e8 <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8062e5:	8b 40 0c             	mov    0xc(%eax),%eax
  8062e8:	85 c0                	test   %eax,%eax
  8062ea:	74 0f                	je     8062fb <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062ec:	89 fa                	mov    %edi,%edx
  8062ee:	2b 50 2c             	sub    0x2c(%eax),%edx
  8062f1:	39 ca                	cmp    %ecx,%edx
  8062f3:	72 f0                	jb     8062e5 <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8062f5:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8062f7:	89 c3                	mov    %eax,%ebx
  8062f9:	eb ea                	jmp    8062e5 <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8062fb:	85 db                	test   %ebx,%ebx
  8062fd:	74 0c                	je     80630b <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8062ff:	83 ec 0c             	sub    $0xc,%esp
  806302:	53                   	push   %ebx
  806303:	e8 62 f9 ff ff       	call   805c6a <tcp_abort>
  806308:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  80630b:	83 ec 0c             	sub    $0xc,%esp
  80630e:	6a 02                	push   $0x2
  806310:	e8 4c e2 ff ff       	call   804561 <memp_malloc>
  806315:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  806317:	83 c4 10             	add    $0x10,%esp
  80631a:	85 c0                	test   %eax,%eax
  80631c:	0f 85 11 ff ff ff    	jne    806233 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806322:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806327:	8b 3d 40 c2 b3 00    	mov    0xb3c240,%edi
  80632d:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  806330:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  806335:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80633c:	89 df                	mov    %ebx,%edi
  80633e:	89 f1                	mov    %esi,%ecx
  806340:	88 4d e7             	mov    %cl,-0x19(%ebp)
  806343:	eb 03                	jmp    806348 <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806345:	8b 40 0c             	mov    0xc(%eax),%eax
  806348:	85 c0                	test   %eax,%eax
  80634a:	74 29                	je     806375 <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  80634c:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  806350:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  806354:	38 d3                	cmp    %dl,%bl
  806356:	89 d6                	mov    %edx,%esi
  806358:	0f 46 f3             	cmovbe %ebx,%esi
  80635b:	89 f3                	mov    %esi,%ebx
  80635d:	38 cb                	cmp    %cl,%bl
  80635f:	72 e4                	jb     806345 <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806361:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806364:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  806367:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  80636a:	72 d9                	jb     806345 <tcp_alloc+0x133>
      mprio = pcb->prio;
  80636c:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  80636e:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806371:	89 c7                	mov    %eax,%edi
  806373:	eb d0                	jmp    806345 <tcp_alloc+0x133>
  if (inactive != NULL) {
  806375:	85 ff                	test   %edi,%edi
  806377:	74 0c                	je     806385 <tcp_alloc+0x173>
    tcp_abort(inactive);
  806379:	83 ec 0c             	sub    $0xc,%esp
  80637c:	57                   	push   %edi
  80637d:	e8 e8 f8 ff ff       	call   805c6a <tcp_abort>
  806382:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  806385:	83 ec 0c             	sub    $0xc,%esp
  806388:	6a 02                	push   $0x2
  80638a:	e8 d2 e1 ff ff       	call   804561 <memp_malloc>
  80638f:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806391:	83 c4 10             	add    $0x10,%esp
  806394:	85 c0                	test   %eax,%eax
  806396:	0f 84 2d ff ff ff    	je     8062c9 <tcp_alloc+0xb7>
  80639c:	e9 92 fe ff ff       	jmp    806233 <tcp_alloc+0x21>

008063a1 <tcp_new>:
{
  8063a1:	55                   	push   %ebp
  8063a2:	89 e5                	mov    %esp,%ebp
  8063a4:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  8063a7:	6a 40                	push   $0x40
  8063a9:	e8 64 fe ff ff       	call   806212 <tcp_alloc>
}
  8063ae:	c9                   	leave  
  8063af:	c3                   	ret    

008063b0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8063b0:	55                   	push   %ebp
  8063b1:	89 e5                	mov    %esp,%ebp
  8063b3:	56                   	push   %esi
  8063b4:	53                   	push   %ebx
  8063b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8063b8:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8063ba:	83 ec 0c             	sub    $0xc,%esp
  8063bd:	ff 75 0c             	pushl  0xc(%ebp)
  8063c0:	e8 f9 01 00 00       	call   8065be <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8063c5:	83 c4 10             	add    $0x10,%esp
  8063c8:	85 c0                	test   %eax,%eax
  8063ca:	74 14                	je     8063e0 <tcp_eff_send_mss+0x30>
  8063cc:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8063d0:	66 85 c0             	test   %ax,%ax
  8063d3:	74 0b                	je     8063e0 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8063d5:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8063d8:	66 39 c3             	cmp    %ax,%bx
  8063db:	0f 46 c3             	cmovbe %ebx,%eax
  8063de:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  8063e0:	89 f0                	mov    %esi,%eax
  8063e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8063e5:	5b                   	pop    %ebx
  8063e6:	5e                   	pop    %esi
  8063e7:	5d                   	pop    %ebp
  8063e8:	c3                   	ret    

008063e9 <tcp_connect>:
{
  8063e9:	55                   	push   %ebp
  8063ea:	89 e5                	mov    %esp,%ebp
  8063ec:	57                   	push   %edi
  8063ed:	56                   	push   %esi
  8063ee:	53                   	push   %ebx
  8063ef:	83 ec 1c             	sub    $0x1c,%esp
  8063f2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8063f5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8063f8:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8063fb:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8063ff:	0f 85 bd 00 00 00    	jne    8064c2 <tcp_connect+0xd9>
  if (ipaddr != NULL) {
  806405:	85 f6                	test   %esi,%esi
  806407:	0f 84 67 01 00 00    	je     806574 <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  80640d:	8b 16                	mov    (%esi),%edx
  80640f:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  806412:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806416:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  80641b:	0f 84 b8 00 00 00    	je     8064d9 <tcp_connect+0xf0>
  iss = tcp_next_iss();
  806421:	e8 db fd ff ff       	call   806201 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806426:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80642d:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806430:	83 e8 01             	sub    $0x1,%eax
  806433:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806436:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  806439:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  80643f:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806445:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80644b:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806451:	83 ec 08             	sub    $0x8,%esp
  806454:	56                   	push   %esi
  806455:	68 18 02 00 00       	push   $0x218
  80645a:	e8 51 ff ff ff       	call   8063b0 <tcp_eff_send_mss>
  80645f:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806463:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  806469:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80646c:	01 c0                	add    %eax,%eax
  80646e:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806472:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  806479:	8b 45 14             	mov    0x14(%ebp),%eax
  80647c:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806482:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  806488:	83 c4 10             	add    $0x10,%esp
  80648b:	39 da                	cmp    %ebx,%edx
  80648d:	74 58                	je     8064e7 <tcp_connect+0xfe>
  80648f:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  806495:	bf 00 00 00 00       	mov    $0x0,%edi
  80649a:	89 de                	mov    %ebx,%esi
  80649c:	85 d2                	test   %edx,%edx
  80649e:	0f 84 ae 00 00 00    	je     806552 <tcp_connect+0x169>
  8064a4:	8b 42 0c             	mov    0xc(%edx),%eax
  8064a7:	39 f0                	cmp    %esi,%eax
  8064a9:	0f 94 c3             	sete   %bl
  8064ac:	85 c0                	test   %eax,%eax
  8064ae:	0f 95 c1             	setne  %cl
  8064b1:	84 cb                	test   %cl,%bl
  8064b3:	0f 85 83 00 00 00    	jne    80653c <tcp_connect+0x153>
  8064b9:	bf 01 00 00 00       	mov    $0x1,%edi
  8064be:	89 c2                	mov    %eax,%edx
  8064c0:	eb da                	jmp    80649c <tcp_connect+0xb3>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8064c2:	83 ec 04             	sub    $0x4,%esp
  8064c5:	68 bc 23 81 00       	push   $0x8123bc
  8064ca:	68 ec 01 00 00       	push   $0x1ec
  8064cf:	68 ee 23 81 00       	push   $0x8123ee
  8064d4:	e8 96 82 00 00       	call   80e76f <_panic>
    pcb->local_port = tcp_new_port();
  8064d9:	e8 6d ef ff ff       	call   80544b <tcp_new_port>
  8064de:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8064e2:	e9 3a ff ff ff       	jmp    806421 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8064e7:	8b 43 0c             	mov    0xc(%ebx),%eax
  8064ea:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  TCP_REG(&tcp_active_pcbs, pcb);
  8064ef:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  8064f4:	89 43 0c             	mov    %eax,0xc(%ebx)
  8064f7:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
  8064fd:	e8 d8 bd ff ff       	call   8022da <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  806502:	83 ec 0c             	sub    $0xc,%esp
  806505:	68 b4 05 04 02       	push   $0x20405b4
  80650a:	e8 e9 12 00 00       	call   8077f8 <htonl>
  80650f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806512:	83 c4 0c             	add    $0xc,%esp
  806515:	6a 04                	push   $0x4
  806517:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80651a:	50                   	push   %eax
  80651b:	6a 00                	push   $0x0
  80651d:	6a 02                	push   $0x2
  80651f:	6a 00                	push   $0x0
  806521:	6a 00                	push   $0x0
  806523:	53                   	push   %ebx
  806524:	e8 f9 14 00 00       	call   807a22 <tcp_enqueue>
  806529:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80652b:	83 c4 20             	add    $0x20,%esp
  80652e:	84 c0                	test   %al,%al
  806530:	74 34                	je     806566 <tcp_connect+0x17d>
} 
  806532:	89 f0                	mov    %esi,%eax
  806534:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806537:	5b                   	pop    %ebx
  806538:	5e                   	pop    %esi
  806539:	5f                   	pop    %edi
  80653a:	5d                   	pop    %ebp
  80653b:	c3                   	ret    
  80653c:	89 f3                	mov    %esi,%ebx
  80653e:	89 f8                	mov    %edi,%eax
  806540:	84 c0                	test   %al,%al
  806542:	74 06                	je     80654a <tcp_connect+0x161>
  806544:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80654a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80654d:	89 42 0c             	mov    %eax,0xc(%edx)
  806550:	eb 9d                	jmp    8064ef <tcp_connect+0x106>
  806552:	89 f3                	mov    %esi,%ebx
  806554:	89 f8                	mov    %edi,%eax
  806556:	84 c0                	test   %al,%al
  806558:	74 95                	je     8064ef <tcp_connect+0x106>
  80655a:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  806561:	00 00 00 
  806564:	eb 89                	jmp    8064ef <tcp_connect+0x106>
    tcp_output(pcb);
  806566:	83 ec 0c             	sub    $0xc,%esp
  806569:	53                   	push   %ebx
  80656a:	e8 d0 1b 00 00       	call   80813f <tcp_output>
  80656f:	83 c4 10             	add    $0x10,%esp
  806572:	eb be                	jmp    806532 <tcp_connect+0x149>
    return ERR_VAL;
  806574:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  806579:	eb b7                	jmp    806532 <tcp_connect+0x149>

0080657b <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80657b:	55                   	push   %ebp
  80657c:	89 e5                	mov    %esp,%ebp
  80657e:	53                   	push   %ebx
  80657f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806582:	8b 45 08             	mov    0x8(%ebp),%eax
  806585:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806587:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80658a:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80658f:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806592:	77 27                	ja     8065bb <ip_addr_isbroadcast+0x40>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806594:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806598:	83 e0 02             	and    $0x2,%eax
  80659b:	74 1e                	je     8065bb <ip_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80659d:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  8065a0:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  8065a5:	39 d3                	cmp    %edx,%ebx
  8065a7:	74 12                	je     8065bb <ip_addr_isbroadcast+0x40>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8065a9:	8b 49 08             	mov    0x8(%ecx),%ecx
  8065ac:	31 d3                	xor    %edx,%ebx
  8065ae:	85 cb                	test   %ecx,%ebx
  8065b0:	75 09                	jne    8065bb <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8065b2:	f7 d1                	not    %ecx
  8065b4:	21 ca                	and    %ecx,%edx
  8065b6:	39 ca                	cmp    %ecx,%edx
  8065b8:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8065bb:	5b                   	pop    %ebx
  8065bc:	5d                   	pop    %ebp
  8065bd:	c3                   	ret    

008065be <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8065be:	55                   	push   %ebp
  8065bf:	89 e5                	mov    %esp,%ebp
  8065c1:	56                   	push   %esi
  8065c2:	53                   	push   %ebx
  8065c3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8065c6:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  8065cc:	eb 02                	jmp    8065d0 <ip_route+0x12>
  8065ce:	8b 1b                	mov    (%ebx),%ebx
  8065d0:	85 db                	test   %ebx,%ebx
  8065d2:	74 1c                	je     8065f0 <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8065d4:	83 ec 0c             	sub    $0xc,%esp
  8065d7:	53                   	push   %ebx
  8065d8:	e8 4b e2 ff ff       	call   804828 <netif_is_up>
  8065dd:	83 c4 10             	add    $0x10,%esp
  8065e0:	84 c0                	test   %al,%al
  8065e2:	74 ea                	je     8065ce <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8065e4:	8b 06                	mov    (%esi),%eax
  8065e6:	33 43 04             	xor    0x4(%ebx),%eax
  8065e9:	85 43 08             	test   %eax,0x8(%ebx)
  8065ec:	75 e0                	jne    8065ce <ip_route+0x10>
  8065ee:	eb 1e                	jmp    80660e <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8065f0:	a1 38 c2 b3 00       	mov    0xb3c238,%eax
  8065f5:	85 c0                	test   %eax,%eax
  8065f7:	74 1e                	je     806617 <ip_route+0x59>
  8065f9:	83 ec 0c             	sub    $0xc,%esp
  8065fc:	50                   	push   %eax
  8065fd:	e8 26 e2 ff ff       	call   804828 <netif_is_up>
  806602:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806605:	84 c0                	test   %al,%al
  806607:	0f 45 1d 38 c2 b3 00 	cmovne 0xb3c238,%ebx
}
  80660e:	89 d8                	mov    %ebx,%eax
  806610:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806613:	5b                   	pop    %ebx
  806614:	5e                   	pop    %esi
  806615:	5d                   	pop    %ebp
  806616:	c3                   	ret    
    return NULL;
  806617:	89 c3                	mov    %eax,%ebx
  806619:	eb f3                	jmp    80660e <ip_route+0x50>

0080661b <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80661b:	55                   	push   %ebp
  80661c:	89 e5                	mov    %esp,%ebp
  80661e:	57                   	push   %edi
  80661f:	56                   	push   %esi
  806620:	53                   	push   %ebx
  806621:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806624:	8b 45 08             	mov    0x8(%ebp),%eax
  806627:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  80662a:	0f b7 07             	movzwl (%edi),%eax
  80662d:	50                   	push   %eax
  80662e:	e8 b8 11 00 00       	call   8077eb <ntohs>
  806633:	66 c1 e8 0c          	shr    $0xc,%ax
  806637:	83 c4 10             	add    $0x10,%esp
  80663a:	66 83 f8 04          	cmp    $0x4,%ax
  80663e:	74 1b                	je     80665b <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806640:	83 ec 0c             	sub    $0xc,%esp
  806643:	ff 75 08             	pushl  0x8(%ebp)
  806646:	e8 b9 e2 ff ff       	call   804904 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80664b:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80664e:	b8 00 00 00 00       	mov    $0x0,%eax
  806653:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806656:	5b                   	pop    %ebx
  806657:	5e                   	pop    %esi
  806658:	5f                   	pop    %edi
  806659:	5d                   	pop    %ebp
  80665a:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  80665b:	83 ec 0c             	sub    $0xc,%esp
  80665e:	0f b7 07             	movzwl (%edi),%eax
  806661:	50                   	push   %eax
  806662:	e8 84 11 00 00       	call   8077eb <ntohs>
  806667:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  80666b:	83 e0 3c             	and    $0x3c,%eax
  80666e:	89 c6                	mov    %eax,%esi
  806670:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806674:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  806678:	89 04 24             	mov    %eax,(%esp)
  80667b:	e8 6b 11 00 00       	call   8077eb <ntohs>
  806680:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806682:	83 c4 10             	add    $0x10,%esp
  806685:	8b 45 08             	mov    0x8(%ebp),%eax
  806688:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80668c:	72 06                	jb     806694 <ip_input+0x79>
  80668e:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806692:	73 10                	jae    8066a4 <ip_input+0x89>
    pbuf_free(p);
  806694:	83 ec 0c             	sub    $0xc,%esp
  806697:	ff 75 08             	pushl  0x8(%ebp)
  80669a:	e8 65 e2 ff ff       	call   804904 <pbuf_free>
    return ERR_OK;
  80669f:	83 c4 10             	add    $0x10,%esp
  8066a2:	eb aa                	jmp    80664e <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8066a4:	83 ec 08             	sub    $0x8,%esp
  8066a7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8066ab:	50                   	push   %eax
  8066ac:	57                   	push   %edi
  8066ad:	e8 fe 0f 00 00       	call   8076b0 <inet_chksum>
  8066b2:	83 c4 10             	add    $0x10,%esp
  8066b5:	66 85 c0             	test   %ax,%ax
  8066b8:	75 27                	jne    8066e1 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  8066ba:	83 ec 08             	sub    $0x8,%esp
  8066bd:	0f b7 db             	movzwl %bx,%ebx
  8066c0:	53                   	push   %ebx
  8066c1:	ff 75 08             	pushl  0x8(%ebp)
  8066c4:	e8 73 e5 ff ff       	call   804c3c <pbuf_realloc>
  8066c9:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  8066cc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  8066cf:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8066d4:	8d 47 10             	lea    0x10(%edi),%eax
  8066d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8066da:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8066dd:	89 df                	mov    %ebx,%edi
  8066df:	eb 2e                	jmp    80670f <ip_input+0xf4>
    pbuf_free(p);
  8066e1:	83 ec 0c             	sub    $0xc,%esp
  8066e4:	ff 75 08             	pushl  0x8(%ebp)
  8066e7:	e8 18 e2 ff ff       	call   804904 <pbuf_free>
    return ERR_OK;
  8066ec:	83 c4 10             	add    $0x10,%esp
  8066ef:	e9 5a ff ff ff       	jmp    80664e <ip_input+0x33>
      if (first) {
  8066f4:	85 f6                	test   %esi,%esi
  8066f6:	74 56                	je     80674e <ip_input+0x133>
        netif = netif_list;
  8066f8:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
      if (netif == inp) {
  8066fe:	39 df                	cmp    %ebx,%edi
  806700:	74 50                	je     806752 <ip_input+0x137>
  806702:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  806707:	85 db                	test   %ebx,%ebx
  806709:	0f 84 20 01 00 00    	je     80682f <ip_input+0x214>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80670f:	83 ec 0c             	sub    $0xc,%esp
  806712:	53                   	push   %ebx
  806713:	e8 10 e1 ff ff       	call   804828 <netif_is_up>
  806718:	83 c4 10             	add    $0x10,%esp
  80671b:	84 c0                	test   %al,%al
  80671d:	74 d5                	je     8066f4 <ip_input+0xd9>
  80671f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806722:	74 d0                	je     8066f4 <ip_input+0xd9>
  806724:	8b 43 04             	mov    0x4(%ebx),%eax
  806727:	85 c0                	test   %eax,%eax
  806729:	74 c9                	je     8066f4 <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80672b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80672e:	3b 42 10             	cmp    0x10(%edx),%eax
  806731:	74 4a                	je     80677d <ip_input+0x162>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806733:	83 ec 08             	sub    $0x8,%esp
  806736:	53                   	push   %ebx
  806737:	ff 75 dc             	pushl  -0x24(%ebp)
  80673a:	e8 3c fe ff ff       	call   80657b <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80673f:	83 c4 10             	add    $0x10,%esp
  806742:	84 c0                	test   %al,%al
  806744:	74 ae                	je     8066f4 <ip_input+0xd9>
  806746:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806749:	e9 fc 00 00 00       	jmp    80684a <ip_input+0x22f>
        netif = netif->next;
  80674e:	8b 1b                	mov    (%ebx),%ebx
  806750:	eb ac                	jmp    8066fe <ip_input+0xe3>
        netif = netif->next;
  806752:	8b 1b                	mov    (%ebx),%ebx
  806754:	eb ac                	jmp    806702 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806756:	83 ec 0c             	sub    $0xc,%esp
  806759:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80675d:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  806762:	50                   	push   %eax
  806763:	e8 83 10 00 00       	call   8077eb <ntohs>
  806768:	83 c4 10             	add    $0x10,%esp
  80676b:	66 83 f8 44          	cmp    $0x44,%ax
  80676f:	0f 85 d5 00 00 00    	jne    80684a <ip_input+0x22f>
        netif = inp;
  806775:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806778:	e9 10 01 00 00       	jmp    80688d <ip_input+0x272>
  80677d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806780:	e9 c5 00 00 00       	jmp    80684a <ip_input+0x22f>
      pbuf_free(p);
  806785:	83 ec 0c             	sub    $0xc,%esp
  806788:	ff 75 08             	pushl  0x8(%ebp)
  80678b:	e8 74 e1 ff ff       	call   804904 <pbuf_free>
      return ERR_OK;
  806790:	83 c4 10             	add    $0x10,%esp
  806793:	e9 b6 fe ff ff       	jmp    80664e <ip_input+0x33>
    pbuf_free(p);
  806798:	83 ec 0c             	sub    $0xc,%esp
  80679b:	ff 75 08             	pushl  0x8(%ebp)
  80679e:	e8 61 e1 ff ff       	call   804904 <pbuf_free>
    return ERR_OK;
  8067a3:	83 c4 10             	add    $0x10,%esp
  8067a6:	e9 a3 fe ff ff       	jmp    80664e <ip_input+0x33>
      udp_input(p, inp);
  8067ab:	83 ec 08             	sub    $0x8,%esp
  8067ae:	ff 75 0c             	pushl  0xc(%ebp)
  8067b1:	ff 75 08             	pushl  0x8(%ebp)
  8067b4:	e8 6b 22 00 00       	call   808a24 <udp_input>
      break;
  8067b9:	83 c4 10             	add    $0x10,%esp
  8067bc:	e9 8d fe ff ff       	jmp    80664e <ip_input+0x33>
      tcp_input(p, inp);
  8067c1:	83 ec 08             	sub    $0x8,%esp
  8067c4:	ff 75 0c             	pushl  0xc(%ebp)
  8067c7:	ff 75 08             	pushl  0x8(%ebp)
  8067ca:	e8 b3 69 00 00       	call   80d182 <tcp_input>
      break;
  8067cf:	83 c4 10             	add    $0x10,%esp
  8067d2:	e9 77 fe ff ff       	jmp    80664e <ip_input+0x33>
      icmp_input(p, inp);
  8067d7:	83 ec 08             	sub    $0x8,%esp
  8067da:	ff 75 0c             	pushl  0xc(%ebp)
  8067dd:	ff 75 08             	pushl  0x8(%ebp)
  8067e0:	e8 9d 79 00 00       	call   80e182 <icmp_input>
      break;
  8067e5:	83 c4 10             	add    $0x10,%esp
  8067e8:	e9 61 fe ff ff       	jmp    80664e <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8067ed:	8b 5f 10             	mov    0x10(%edi),%ebx
  8067f0:	83 ec 0c             	sub    $0xc,%esp
  8067f3:	68 00 00 00 f0       	push   $0xf0000000
  8067f8:	e8 12 12 00 00       	call   807a0f <ntohl>
  8067fd:	21 c3                	and    %eax,%ebx
  8067ff:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806806:	e8 04 12 00 00       	call   807a0f <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80680b:	83 c4 10             	add    $0x10,%esp
  80680e:	39 c3                	cmp    %eax,%ebx
  806810:	0f 84 18 01 00 00    	je     80692e <ip_input+0x313>
        p->payload = iphdr;
  806816:	8b 45 08             	mov    0x8(%ebp),%eax
  806819:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80681c:	83 ec 08             	sub    $0x8,%esp
  80681f:	6a 02                	push   $0x2
  806821:	50                   	push   %eax
  806822:	e8 75 7c 00 00       	call   80e49c <icmp_dest_unreach>
  806827:	83 c4 10             	add    $0x10,%esp
  80682a:	e9 ff 00 00 00       	jmp    80692e <ip_input+0x313>
  80682f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806832:	83 ec 0c             	sub    $0xc,%esp
  806835:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806839:	50                   	push   %eax
  80683a:	e8 ac 0f 00 00       	call   8077eb <ntohs>
  80683f:	83 c4 10             	add    $0x10,%esp
  806842:	3c 11                	cmp    $0x11,%al
  806844:	0f 84 0c ff ff ff    	je     806756 <ip_input+0x13b>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80684a:	83 ec 08             	sub    $0x8,%esp
  80684d:	ff 75 0c             	pushl  0xc(%ebp)
  806850:	8d 47 0c             	lea    0xc(%edi),%eax
  806853:	50                   	push   %eax
  806854:	e8 22 fd ff ff       	call   80657b <ip_addr_isbroadcast>
  806859:	83 c4 10             	add    $0x10,%esp
  80685c:	84 c0                	test   %al,%al
  80685e:	0f 85 21 ff ff ff    	jne    806785 <ip_input+0x16a>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806864:	8b 77 0c             	mov    0xc(%edi),%esi
  806867:	83 ec 0c             	sub    $0xc,%esp
  80686a:	68 00 00 00 f0       	push   $0xf0000000
  80686f:	e8 9b 11 00 00       	call   807a0f <ntohl>
  806874:	21 c6                	and    %eax,%esi
  806876:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80687d:	e8 8d 11 00 00       	call   807a0f <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806882:	83 c4 10             	add    $0x10,%esp
  806885:	39 c6                	cmp    %eax,%esi
  806887:	0f 84 f8 fe ff ff    	je     806785 <ip_input+0x16a>
  if (netif == NULL) {
  80688d:	85 db                	test   %ebx,%ebx
  80688f:	0f 84 03 ff ff ff    	je     806798 <ip_input+0x17d>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806895:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806899:	83 ec 0c             	sub    $0xc,%esp
  80689c:	68 ff 3f 00 00       	push   $0x3fff
  8068a1:	e8 38 0f 00 00       	call   8077de <htons>
  8068a6:	83 c4 10             	add    $0x10,%esp
  8068a9:	66 85 c3             	test   %ax,%bx
  8068ac:	74 1c                	je     8068ca <ip_input+0x2af>
    p = ip_reass(p);
  8068ae:	83 ec 0c             	sub    $0xc,%esp
  8068b1:	ff 75 08             	pushl  0x8(%ebp)
  8068b4:	e8 95 04 00 00       	call   806d4e <ip_reass>
  8068b9:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  8068bc:	83 c4 10             	add    $0x10,%esp
  8068bf:	85 c0                	test   %eax,%eax
  8068c1:	0f 84 87 fd ff ff    	je     80664e <ip_input+0x33>
    iphdr = p->payload;
  8068c7:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  8068ca:	83 ec 08             	sub    $0x8,%esp
  8068cd:	ff 75 0c             	pushl  0xc(%ebp)
  8068d0:	ff 75 08             	pushl  0x8(%ebp)
  8068d3:	e8 01 76 00 00       	call   80ded9 <raw_input>
  8068d8:	83 c4 10             	add    $0x10,%esp
  8068db:	84 c0                	test   %al,%al
  8068dd:	0f 85 6b fd ff ff    	jne    80664e <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  8068e3:	83 ec 0c             	sub    $0xc,%esp
  8068e6:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8068ea:	50                   	push   %eax
  8068eb:	e8 fb 0e 00 00       	call   8077eb <ntohs>
  8068f0:	0f b6 c0             	movzbl %al,%eax
  8068f3:	83 c4 10             	add    $0x10,%esp
  8068f6:	66 83 f8 06          	cmp    $0x6,%ax
  8068fa:	0f 84 c1 fe ff ff    	je     8067c1 <ip_input+0x1a6>
  806900:	66 83 f8 11          	cmp    $0x11,%ax
  806904:	0f 84 a1 fe ff ff    	je     8067ab <ip_input+0x190>
  80690a:	66 83 f8 01          	cmp    $0x1,%ax
  80690e:	0f 84 c3 fe ff ff    	je     8067d7 <ip_input+0x1bc>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806914:	83 ec 08             	sub    $0x8,%esp
  806917:	ff 75 0c             	pushl  0xc(%ebp)
  80691a:	8d 47 10             	lea    0x10(%edi),%eax
  80691d:	50                   	push   %eax
  80691e:	e8 58 fc ff ff       	call   80657b <ip_addr_isbroadcast>
  806923:	83 c4 10             	add    $0x10,%esp
  806926:	84 c0                	test   %al,%al
  806928:	0f 84 bf fe ff ff    	je     8067ed <ip_input+0x1d2>
      pbuf_free(p);
  80692e:	83 ec 0c             	sub    $0xc,%esp
  806931:	ff 75 08             	pushl  0x8(%ebp)
  806934:	e8 cb df ff ff       	call   804904 <pbuf_free>
  806939:	83 c4 10             	add    $0x10,%esp
  80693c:	e9 0d fd ff ff       	jmp    80664e <ip_input+0x33>

00806941 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806941:	55                   	push   %ebp
  806942:	89 e5                	mov    %esp,%ebp
  806944:	57                   	push   %edi
  806945:	56                   	push   %esi
  806946:	53                   	push   %ebx
  806947:	83 ec 1c             	sub    $0x1c,%esp
  80694a:	8b 75 08             	mov    0x8(%ebp),%esi
  80694d:	8b 7d 14             	mov    0x14(%ebp),%edi
  806950:	8b 45 18             	mov    0x18(%ebp),%eax
  806953:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806956:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806959:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80695c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806960:	0f 84 42 01 00 00    	je     806aa8 <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806966:	83 ec 08             	sub    $0x8,%esp
  806969:	6a 14                	push   $0x14
  80696b:	56                   	push   %esi
  80696c:	e8 c6 de ff ff       	call   804837 <pbuf_header>
  806971:	83 c4 10             	add    $0x10,%esp
  806974:	84 c0                	test   %al,%al
  806976:	0f 85 4b 01 00 00    	jne    806ac7 <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80697c:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80697f:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806984:	0f 86 02 01 00 00    	jbe    806a8c <ip_output_if+0x14b>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80698a:	83 ec 0c             	sub    $0xc,%esp
  80698d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806991:	50                   	push   %eax
  806992:	e8 54 0e 00 00       	call   8077eb <ntohs>
  806997:	0f b6 c0             	movzbl %al,%eax
  80699a:	c1 e7 08             	shl    $0x8,%edi
  80699d:	09 c7                	or     %eax,%edi
  80699f:	0f b7 ff             	movzwl %di,%edi
  8069a2:	89 3c 24             	mov    %edi,(%esp)
  8069a5:	e8 34 0e 00 00       	call   8077de <htons>
  8069aa:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  8069ae:	0f b7 c0             	movzwl %ax,%eax
  8069b1:	89 04 24             	mov    %eax,(%esp)
  8069b4:	e8 32 0e 00 00       	call   8077eb <ntohs>
  8069b9:	89 c2                	mov    %eax,%edx
  8069bb:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8069c1:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  8069c5:	09 d0                	or     %edx,%eax
  8069c7:	0f b7 c0             	movzwl %ax,%eax
  8069ca:	89 04 24             	mov    %eax,(%esp)
  8069cd:	e8 0c 0e 00 00       	call   8077de <htons>
  8069d2:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  8069d6:	8b 45 10             	mov    0x10(%ebp),%eax
  8069d9:	8b 00                	mov    (%eax),%eax
  8069db:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8069de:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8069e2:	80 cc 45             	or     $0x45,%ah
  8069e5:	89 04 24             	mov    %eax,(%esp)
  8069e8:	e8 f1 0d 00 00       	call   8077de <htons>
  8069ed:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8069f0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8069f4:	89 04 24             	mov    %eax,(%esp)
  8069f7:	e8 e2 0d 00 00       	call   8077de <htons>
  8069fc:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806a00:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806a06:	0f b7 05 fa 53 b3 00 	movzwl 0xb353fa,%eax
  806a0d:	89 04 24             	mov    %eax,(%esp)
  806a10:	e8 c9 0d 00 00       	call   8077de <htons>
  806a15:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806a19:	66 83 05 fa 53 b3 00 	addw   $0x1,0xb353fa
  806a20:	01 

    if (ip_addr_isany(src)) {
  806a21:	83 c4 10             	add    $0x10,%esp
  806a24:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806a28:	74 09                	je     806a33 <ip_output_if+0xf2>
  806a2a:	8b 45 0c             	mov    0xc(%ebp),%eax
  806a2d:	8b 00                	mov    (%eax),%eax
  806a2f:	85 c0                	test   %eax,%eax
  806a31:	75 70                	jne    806aa3 <ip_output_if+0x162>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806a33:	b8 00 00 00 00       	mov    $0x0,%eax
  806a38:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806a3c:	74 06                	je     806a44 <ip_output_if+0x103>
  806a3e:	8b 45 20             	mov    0x20(%ebp),%eax
  806a41:	8b 40 04             	mov    0x4(%eax),%eax
  806a44:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806a47:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806a4d:	83 ec 08             	sub    $0x8,%esp
  806a50:	6a 14                	push   $0x14
  806a52:	53                   	push   %ebx
  806a53:	e8 58 0c 00 00       	call   8076b0 <inet_chksum>
  806a58:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806a5c:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806a5f:	8b 45 20             	mov    0x20(%ebp),%eax
  806a62:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806a66:	66 85 c0             	test   %ax,%ax
  806a69:	74 06                	je     806a71 <ip_output_if+0x130>
  806a6b:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806a6f:	72 42                	jb     806ab3 <ip_output_if+0x172>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806a71:	83 ec 04             	sub    $0x4,%esp
  806a74:	ff 75 10             	pushl  0x10(%ebp)
  806a77:	56                   	push   %esi
  806a78:	ff 75 20             	pushl  0x20(%ebp)
  806a7b:	8b 45 20             	mov    0x20(%ebp),%eax
  806a7e:	ff 50 14             	call   *0x14(%eax)
  806a81:	83 c4 10             	add    $0x10,%esp
  }
}
  806a84:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a87:	5b                   	pop    %ebx
  806a88:	5e                   	pop    %esi
  806a89:	5f                   	pop    %edi
  806a8a:	5d                   	pop    %ebp
  806a8b:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806a8c:	83 ec 04             	sub    $0x4,%esp
  806a8f:	68 8c 24 81 00       	push   $0x81248c
  806a94:	68 ee 01 00 00       	push   $0x1ee
  806a99:	68 b9 24 81 00       	push   $0x8124b9
  806a9e:	e8 cc 7c 00 00       	call   80e76f <_panic>
      ip_addr_set(&(iphdr->src), src);
  806aa3:	89 43 0c             	mov    %eax,0xc(%ebx)
  806aa6:	eb 9f                	jmp    806a47 <ip_output_if+0x106>
    dest = &(iphdr->dest);
  806aa8:	8b 46 04             	mov    0x4(%esi),%eax
  806aab:	83 c0 10             	add    $0x10,%eax
  806aae:	89 45 10             	mov    %eax,0x10(%ebp)
  806ab1:	eb ac                	jmp    806a5f <ip_output_if+0x11e>
    return ip_frag(p,netif,dest);
  806ab3:	83 ec 04             	sub    $0x4,%esp
  806ab6:	ff 75 10             	pushl  0x10(%ebp)
  806ab9:	ff 75 20             	pushl  0x20(%ebp)
  806abc:	56                   	push   %esi
  806abd:	e8 5e 07 00 00       	call   807220 <ip_frag>
  806ac2:	83 c4 10             	add    $0x10,%esp
  806ac5:	eb bd                	jmp    806a84 <ip_output_if+0x143>
      return ERR_BUF;
  806ac7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806acc:	eb b6                	jmp    806a84 <ip_output_if+0x143>

00806ace <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806ace:	55                   	push   %ebp
  806acf:	89 e5                	mov    %esp,%ebp
  806ad1:	57                   	push   %edi
  806ad2:	56                   	push   %esi
  806ad3:	53                   	push   %ebx
  806ad4:	83 ec 18             	sub    $0x18,%esp
  806ad7:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806ada:	8b 75 18             	mov    0x18(%ebp),%esi
  806add:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806ae0:	ff 75 10             	pushl  0x10(%ebp)
  806ae3:	e8 d6 fa ff ff       	call   8065be <ip_route>
  806ae8:	83 c4 10             	add    $0x10,%esp
  806aeb:	85 c0                	test   %eax,%eax
  806aed:	74 2d                	je     806b1c <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806aef:	83 ec 04             	sub    $0x4,%esp
  806af2:	50                   	push   %eax
  806af3:	89 f8                	mov    %edi,%eax
  806af5:	0f b6 f8             	movzbl %al,%edi
  806af8:	57                   	push   %edi
  806af9:	89 f0                	mov    %esi,%eax
  806afb:	0f b6 f0             	movzbl %al,%esi
  806afe:	56                   	push   %esi
  806aff:	0f b6 db             	movzbl %bl,%ebx
  806b02:	53                   	push   %ebx
  806b03:	ff 75 10             	pushl  0x10(%ebp)
  806b06:	ff 75 0c             	pushl  0xc(%ebp)
  806b09:	ff 75 08             	pushl  0x8(%ebp)
  806b0c:	e8 30 fe ff ff       	call   806941 <ip_output_if>
  806b11:	83 c4 20             	add    $0x20,%esp
}
  806b14:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b17:	5b                   	pop    %ebx
  806b18:	5e                   	pop    %esi
  806b19:	5f                   	pop    %edi
  806b1a:	5d                   	pop    %ebp
  806b1b:	c3                   	ret    
    return ERR_RTE;
  806b1c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806b21:	eb f1                	jmp    806b14 <ip_output+0x46>

00806b23 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806b23:	55                   	push   %ebp
  806b24:	89 e5                	mov    %esp,%ebp
  806b26:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806b29:	39 05 e0 59 b3 00    	cmp    %eax,0xb359e0
  806b2f:	74 18                	je     806b49 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806b31:	85 d2                	test   %edx,%edx
  806b33:	74 1e                	je     806b53 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806b35:	8b 08                	mov    (%eax),%ecx
  806b37:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806b39:	83 ec 08             	sub    $0x8,%esp
  806b3c:	50                   	push   %eax
  806b3d:	6a 05                	push   $0x5
  806b3f:	e8 73 da ff ff       	call   8045b7 <memp_free>
}
  806b44:	83 c4 10             	add    $0x10,%esp
  806b47:	c9                   	leave  
  806b48:	c3                   	ret    
    reassdatagrams = ipr->next;
  806b49:	8b 10                	mov    (%eax),%edx
  806b4b:	89 15 e0 59 b3 00    	mov    %edx,0xb359e0
  806b51:	eb e6                	jmp    806b39 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806b53:	83 ec 04             	sub    $0x4,%esp
  806b56:	68 d1 24 81 00       	push   $0x8124d1
  806b5b:	68 29 01 00 00       	push   $0x129
  806b60:	68 ea 24 81 00       	push   $0x8124ea
  806b65:	e8 05 7c 00 00       	call   80e76f <_panic>

00806b6a <ip_reass_free_complete_datagram>:
{
  806b6a:	55                   	push   %ebp
  806b6b:	89 e5                	mov    %esp,%ebp
  806b6d:	57                   	push   %edi
  806b6e:	56                   	push   %esi
  806b6f:	53                   	push   %ebx
  806b70:	83 ec 1c             	sub    $0x1c,%esp
  806b73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b76:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806b79:	39 c2                	cmp    %eax,%edx
  806b7b:	74 53                	je     806bd0 <ip_reass_free_complete_datagram+0x66>
  if (prev != NULL) {
  806b7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b80:	85 c0                	test   %eax,%eax
  806b82:	74 07                	je     806b8b <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806b84:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806b87:	39 10                	cmp    %edx,(%eax)
  806b89:	75 5c                	jne    806be7 <ip_reass_free_complete_datagram+0x7d>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806b8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b8e:	8b 58 04             	mov    0x4(%eax),%ebx
  806b91:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806b94:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806b99:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806b9e:	74 5e                	je     806bfe <ip_reass_free_complete_datagram+0x94>
  p = ipr->p;
  806ba0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ba3:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806ba6:	85 db                	test   %ebx,%ebx
  806ba8:	0f 84 8f 00 00 00    	je     806c3d <ip_reass_free_complete_datagram+0xd3>
    iprh = (struct ip_reass_helper *)p->payload;
  806bae:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806bb1:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806bb3:	83 ec 0c             	sub    $0xc,%esp
  806bb6:	53                   	push   %ebx
  806bb7:	e8 92 e1 ff ff       	call   804d4e <pbuf_clen>
  806bbc:	0f b6 c0             	movzbl %al,%eax
  806bbf:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806bc1:	89 1c 24             	mov    %ebx,(%esp)
  806bc4:	e8 3b dd ff ff       	call   804904 <pbuf_free>
  806bc9:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806bcc:	89 fb                	mov    %edi,%ebx
  806bce:	eb d6                	jmp    806ba6 <ip_reass_free_complete_datagram+0x3c>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806bd0:	83 ec 04             	sub    $0x4,%esp
  806bd3:	68 07 25 81 00       	push   $0x812507
  806bd8:	68 99 00 00 00       	push   $0x99
  806bdd:	68 ea 24 81 00       	push   $0x8124ea
  806be2:	e8 88 7b 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806be7:	83 ec 04             	sub    $0x4,%esp
  806bea:	68 13 25 81 00       	push   $0x812513
  806bef:	68 9b 00 00 00       	push   $0x9b
  806bf4:	68 ea 24 81 00       	push   $0x8124ea
  806bf9:	e8 71 7b 00 00       	call   80e76f <_panic>
    ipr->p = iprh->next_pbuf;
  806bfe:	8b 00                	mov    (%eax),%eax
  806c00:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806c03:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806c06:	83 ec 04             	sub    $0x4,%esp
  806c09:	6a 14                	push   $0x14
  806c0b:	8d 41 08             	lea    0x8(%ecx),%eax
  806c0e:	50                   	push   %eax
  806c0f:	ff 73 04             	pushl  0x4(%ebx)
  806c12:	e8 9d 85 00 00       	call   80f1b4 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806c17:	83 c4 08             	add    $0x8,%esp
  806c1a:	6a 01                	push   $0x1
  806c1c:	53                   	push   %ebx
  806c1d:	e8 5d 79 00 00       	call   80e57f <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806c22:	89 1c 24             	mov    %ebx,(%esp)
  806c25:	e8 24 e1 ff ff       	call   804d4e <pbuf_clen>
  806c2a:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806c2d:	89 1c 24             	mov    %ebx,(%esp)
  806c30:	e8 cf dc ff ff       	call   804904 <pbuf_free>
  806c35:	83 c4 10             	add    $0x10,%esp
  806c38:	e9 63 ff ff ff       	jmp    806ba0 <ip_reass_free_complete_datagram+0x36>
  ip_reass_dequeue_datagram(ipr, prev);
  806c3d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806c40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c43:	e8 db fe ff ff       	call   806b23 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806c48:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806c4f:	0f b7 d0             	movzwl %ax,%edx
  806c52:	39 f2                	cmp    %esi,%edx
  806c54:	7c 12                	jl     806c68 <ip_reass_free_complete_datagram+0xfe>
  ip_reass_pbufcount -= pbufs_freed;
  806c56:	29 f0                	sub    %esi,%eax
  806c58:	66 a3 dc 59 b3 00    	mov    %ax,0xb359dc
}
  806c5e:	89 f0                	mov    %esi,%eax
  806c60:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806c63:	5b                   	pop    %ebx
  806c64:	5e                   	pop    %esi
  806c65:	5f                   	pop    %edi
  806c66:	5d                   	pop    %ebp
  806c67:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806c68:	83 ec 04             	sub    $0x4,%esp
  806c6b:	68 25 25 81 00       	push   $0x812525
  806c70:	68 bc 00 00 00       	push   $0xbc
  806c75:	68 ea 24 81 00       	push   $0x8124ea
  806c7a:	e8 f0 7a 00 00       	call   80e76f <_panic>

00806c7f <ip_reass_remove_oldest_datagram>:
{
  806c7f:	55                   	push   %ebp
  806c80:	89 e5                	mov    %esp,%ebp
  806c82:	57                   	push   %edi
  806c83:	56                   	push   %esi
  806c84:	53                   	push   %ebx
  806c85:	83 ec 1c             	sub    $0x1c,%esp
  806c88:	89 c6                	mov    %eax,%esi
  806c8a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806c8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806c94:	eb 5b                	jmp    806cf1 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806c96:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806c9a:	85 c0                	test   %eax,%eax
  806c9c:	74 33                	je     806cd1 <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806c9e:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806ca2:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806ca5:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806ca8:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806caa:	85 ff                	test   %edi,%edi
  806cac:	0f 45 d1             	cmovne %ecx,%edx
  806caf:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806cb1:	85 c9                	test   %ecx,%ecx
  806cb3:	74 20                	je     806cd5 <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806cb5:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806cb8:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806cbb:	75 d9                	jne    806c96 <ip_reass_remove_oldest_datagram+0x17>
  806cbd:	8b 7e 10             	mov    0x10(%esi),%edi
  806cc0:	39 79 18             	cmp    %edi,0x18(%ecx)
  806cc3:	75 d1                	jne    806c96 <ip_reass_remove_oldest_datagram+0x17>
  806cc5:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806cc9:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806ccd:	75 c7                	jne    806c96 <ip_reass_remove_oldest_datagram+0x17>
  806ccf:	eb d7                	jmp    806ca8 <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806cd1:	89 c8                	mov    %ecx,%eax
  806cd3:	eb d3                	jmp    806ca8 <ip_reass_remove_oldest_datagram+0x29>
  806cd5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806cd8:	85 c0                	test   %eax,%eax
  806cda:	74 08                	je     806ce4 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806cdc:	e8 89 fe ff ff       	call   806b6a <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806ce1:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806ce4:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806ce7:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806cea:	7d 1f                	jge    806d0b <ip_reass_remove_oldest_datagram+0x8c>
  806cec:	83 fb 01             	cmp    $0x1,%ebx
  806cef:	7e 1a                	jle    806d0b <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806cf1:	8b 0d e0 59 b3 00    	mov    0xb359e0,%ecx
    other_datagrams = 0;
  806cf7:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806cfc:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806d01:	b8 00 00 00 00       	mov    $0x0,%eax
  806d06:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806d09:	eb a6                	jmp    806cb1 <ip_reass_remove_oldest_datagram+0x32>
}
  806d0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806d0e:	83 c4 1c             	add    $0x1c,%esp
  806d11:	5b                   	pop    %ebx
  806d12:	5e                   	pop    %esi
  806d13:	5f                   	pop    %edi
  806d14:	5d                   	pop    %ebp
  806d15:	c3                   	ret    

00806d16 <ip_reass_tmr>:
{
  806d16:	55                   	push   %ebp
  806d17:	89 e5                	mov    %esp,%ebp
  806d19:	56                   	push   %esi
  806d1a:	53                   	push   %ebx
  r = reassdatagrams;
  806d1b:	a1 e0 59 b3 00       	mov    0xb359e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806d20:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806d25:	eb 0b                	jmp    806d32 <ip_reass_tmr+0x1c>
      r = r->next;
  806d27:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806d29:	89 da                	mov    %ebx,%edx
  806d2b:	e8 3a fe ff ff       	call   806b6a <ip_reass_free_complete_datagram>
      r = r->next;
  806d30:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806d32:	85 c0                	test   %eax,%eax
  806d34:	74 14                	je     806d4a <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806d36:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806d3a:	84 d2                	test   %dl,%dl
  806d3c:	74 e9                	je     806d27 <ip_reass_tmr+0x11>
      r->timer--;
  806d3e:	83 ea 01             	sub    $0x1,%edx
  806d41:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806d44:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806d46:	8b 00                	mov    (%eax),%eax
  806d48:	eb e8                	jmp    806d32 <ip_reass_tmr+0x1c>
}
  806d4a:	5b                   	pop    %ebx
  806d4b:	5e                   	pop    %esi
  806d4c:	5d                   	pop    %ebp
  806d4d:	c3                   	ret    

00806d4e <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806d4e:	55                   	push   %ebp
  806d4f:	89 e5                	mov    %esp,%ebp
  806d51:	57                   	push   %edi
  806d52:	56                   	push   %esi
  806d53:	53                   	push   %ebx
  806d54:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806d57:	8b 45 08             	mov    0x8(%ebp),%eax
  806d5a:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806d5d:	0f b7 03             	movzwl (%ebx),%eax
  806d60:	50                   	push   %eax
  806d61:	e8 85 0a 00 00       	call   8077eb <ntohs>
  806d66:	66 c1 e8 08          	shr    $0x8,%ax
  806d6a:	83 e0 0f             	and    $0xf,%eax
  806d6d:	83 c4 10             	add    $0x10,%esp
  806d70:	83 f8 05             	cmp    $0x5,%eax
  806d73:	0f 85 dc 01 00 00    	jne    806f55 <ip_reass+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d79:	83 ec 0c             	sub    $0xc,%esp
  806d7c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d80:	50                   	push   %eax
  806d81:	e8 65 0a 00 00       	call   8077eb <ntohs>
  806d86:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d8a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d8e:	89 04 24             	mov    %eax,(%esp)
  806d91:	e8 55 0a 00 00       	call   8077eb <ntohs>
  806d96:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806d9a:	0f b7 03             	movzwl (%ebx),%eax
  806d9d:	89 04 24             	mov    %eax,(%esp)
  806da0:	e8 46 0a 00 00       	call   8077eb <ntohs>
  806da5:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806da9:	83 c4 04             	add    $0x4,%esp
  806dac:	ff 75 08             	pushl  0x8(%ebp)
  806daf:	e8 9a df ff ff       	call   804d4e <pbuf_clen>
  806db4:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806db7:	0f b6 f0             	movzbl %al,%esi
  806dba:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806dc1:	01 f0                	add    %esi,%eax
  806dc3:	83 c4 10             	add    $0x10,%esp
  806dc6:	83 f8 0a             	cmp    $0xa,%eax
  806dc9:	7f 0d                	jg     806dd8 <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806dcb:	8b 3d e0 59 b3 00    	mov    0xb359e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806dd1:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806dd6:	eb 28                	jmp    806e00 <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806dd8:	89 f2                	mov    %esi,%edx
  806dda:	89 d8                	mov    %ebx,%eax
  806ddc:	e8 9e fe ff ff       	call   806c7f <ip_reass_remove_oldest_datagram>
  806de1:	85 c0                	test   %eax,%eax
  806de3:	0f 84 6c 01 00 00    	je     806f55 <ip_reass+0x207>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806de9:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806df0:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806df2:	83 f8 0a             	cmp    $0xa,%eax
  806df5:	7e d4                	jle    806dcb <ip_reass+0x7d>
  806df7:	e9 59 01 00 00       	jmp    806f55 <ip_reass+0x207>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806dfc:	89 f8                	mov    %edi,%eax
  806dfe:	8b 3f                	mov    (%edi),%edi
  806e00:	85 ff                	test   %edi,%edi
  806e02:	0f 84 f5 00 00 00    	je     806efd <ip_reass+0x1af>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806e08:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806e0b:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806e0e:	75 ec                	jne    806dfc <ip_reass+0xae>
  806e10:	8b 53 10             	mov    0x10(%ebx),%edx
  806e13:	39 57 18             	cmp    %edx,0x18(%edi)
  806e16:	75 e4                	jne    806dfc <ip_reass+0xae>
  806e18:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806e1c:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806e20:	75 da                	jne    806dfc <ip_reass+0xae>
  806e22:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806e25:	83 ec 0c             	sub    $0xc,%esp
  806e28:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e2c:	50                   	push   %eax
  806e2d:	e8 b9 09 00 00       	call   8077eb <ntohs>
  806e32:	83 c4 10             	add    $0x10,%esp
  806e35:	66 a9 ff 1f          	test   $0x1fff,%ax
  806e39:	0f 84 4b 01 00 00    	je     806f8a <ip_reass+0x23c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806e3f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806e43:	66 01 05 dc 59 b3 00 	add    %ax,0xb359dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806e4a:	83 ec 0c             	sub    $0xc,%esp
  806e4d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e51:	50                   	push   %eax
  806e52:	e8 94 09 00 00       	call   8077eb <ntohs>
  806e57:	83 c4 10             	add    $0x10,%esp
  806e5a:	f6 c4 20             	test   $0x20,%ah
  806e5d:	75 20                	jne    806e7f <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806e5f:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806e63:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806e67:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806e6b:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e6e:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806e72:	66 c1 ea 06          	shr    $0x6,%dx
  806e76:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806e79:	29 d0                	sub    %edx,%eax
  806e7b:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806e7f:	8b 45 08             	mov    0x8(%ebp),%eax
  806e82:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e85:	83 ec 0c             	sub    $0xc,%esp
  806e88:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e8c:	50                   	push   %eax
  806e8d:	e8 59 09 00 00       	call   8077eb <ntohs>
  806e92:	89 c6                	mov    %eax,%esi
  806e94:	0f b7 03             	movzwl (%ebx),%eax
  806e97:	89 04 24             	mov    %eax,(%esp)
  806e9a:	e8 4c 09 00 00       	call   8077eb <ntohs>
  806e9f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806ea3:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806ea7:	89 04 24             	mov    %eax,(%esp)
  806eaa:	e8 3c 09 00 00       	call   8077eb <ntohs>
  806eaf:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806eb6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806eb9:	8b 51 04             	mov    0x4(%ecx),%edx
  806ebc:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806ebf:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806ec5:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806ec9:	01 de                	add    %ebx,%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806ecb:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806ecf:	66 c1 e8 06          	shr    $0x6,%ax
  806ed3:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806ed6:	29 c6                	sub    %eax,%esi
  806ed8:	66 89 75 de          	mov    %si,-0x22(%ebp)
  806edc:	66 89 72 06          	mov    %si,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806ee0:	8b 47 04             	mov    0x4(%edi),%eax
  806ee3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806ee6:	83 c4 10             	add    $0x10,%esp
  int valid = 1;
  806ee9:	b9 01 00 00 00       	mov    $0x1,%ecx
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806eee:	be 00 00 00 00       	mov    $0x0,%esi
  806ef3:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806ef6:	89 cf                	mov    %ecx,%edi
  806ef8:	e9 25 01 00 00       	jmp    807022 <ip_reass+0x2d4>
  806efd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806f00:	83 ec 0c             	sub    $0xc,%esp
  806f03:	6a 05                	push   $0x5
  806f05:	e8 57 d6 ff ff       	call   804561 <memp_malloc>
  806f0a:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806f0c:	83 c4 10             	add    $0x10,%esp
  806f0f:	85 c0                	test   %eax,%eax
  806f11:	74 35                	je     806f48 <ip_reass+0x1fa>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806f13:	83 ec 04             	sub    $0x4,%esp
  806f16:	6a 20                	push   $0x20
  806f18:	6a 00                	push   $0x0
  806f1a:	57                   	push   %edi
  806f1b:	e8 ea 81 00 00       	call   80f10a <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806f20:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806f24:	a1 e0 59 b3 00       	mov    0xb359e0,%eax
  806f29:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806f2b:	89 3d e0 59 b3 00    	mov    %edi,0xb359e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806f31:	83 c4 0c             	add    $0xc,%esp
  806f34:	6a 14                	push   $0x14
  806f36:	53                   	push   %ebx
  806f37:	8d 47 08             	lea    0x8(%edi),%eax
  806f3a:	50                   	push   %eax
  806f3b:	e8 74 82 00 00       	call   80f1b4 <memcpy>
  806f40:	83 c4 10             	add    $0x10,%esp
  806f43:	e9 f7 fe ff ff       	jmp    806e3f <ip_reass+0xf1>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806f48:	89 f2                	mov    %esi,%edx
  806f4a:	89 d8                	mov    %ebx,%eax
  806f4c:	e8 2e fd ff ff       	call   806c7f <ip_reass_remove_oldest_datagram>
  806f51:	39 c6                	cmp    %eax,%esi
  806f53:	7e 20                	jle    806f75 <ip_reass+0x227>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806f55:	83 ec 0c             	sub    $0xc,%esp
  806f58:	ff 75 08             	pushl  0x8(%ebp)
  806f5b:	e8 a4 d9 ff ff       	call   804904 <pbuf_free>
  return NULL;
  806f60:	83 c4 10             	add    $0x10,%esp
  806f63:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806f6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806f6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806f70:	5b                   	pop    %ebx
  806f71:	5e                   	pop    %esi
  806f72:	5f                   	pop    %edi
  806f73:	5d                   	pop    %ebp
  806f74:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806f75:	83 ec 0c             	sub    $0xc,%esp
  806f78:	6a 05                	push   $0x5
  806f7a:	e8 e2 d5 ff ff       	call   804561 <memp_malloc>
  806f7f:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806f81:	83 c4 10             	add    $0x10,%esp
  806f84:	85 c0                	test   %eax,%eax
  806f86:	75 8b                	jne    806f13 <ip_reass+0x1c5>
  806f88:	eb cb                	jmp    806f55 <ip_reass+0x207>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806f8a:	83 ec 0c             	sub    $0xc,%esp
  806f8d:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806f91:	50                   	push   %eax
  806f92:	e8 54 08 00 00       	call   8077eb <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f97:	83 c4 10             	add    $0x10,%esp
  806f9a:	66 a9 ff 1f          	test   $0x1fff,%ax
  806f9e:	0f 84 9b fe ff ff    	je     806e3f <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806fa4:	83 ec 04             	sub    $0x4,%esp
  806fa7:	6a 14                	push   $0x14
  806fa9:	53                   	push   %ebx
  806faa:	8d 47 08             	lea    0x8(%edi),%eax
  806fad:	50                   	push   %eax
  806fae:	e8 01 82 00 00       	call   80f1b4 <memcpy>
  806fb3:	83 c4 10             	add    $0x10,%esp
  806fb6:	e9 84 fe ff ff       	jmp    806e3f <ip_reass+0xf1>
  806fbb:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806fbe:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  806fc1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806fc4:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806fc6:	85 f6                	test   %esi,%esi
  806fc8:	74 4c                	je     807016 <ip_reass+0x2c8>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806fca:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806fce:	0f 82 c5 01 00 00    	jb     807199 <ip_reass+0x44b>
  806fd4:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  806fd8:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806fdc:	0f 87 b7 01 00 00    	ja     807199 <ip_reass+0x44b>
        iprh_prev->next_pbuf = new_p;
  806fe2:	8b 45 08             	mov    0x8(%ebp),%eax
  806fe5:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806fe7:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806feb:	0f 84 cb 01 00 00    	je     8071bc <ip_reass+0x46e>
    if (valid) {
  806ff1:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806ff5:	0f 84 c1 01 00 00    	je     8071bc <ip_reass+0x46e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806ffb:	8b 4f 04             	mov    0x4(%edi),%ecx
  806ffe:	8b 59 04             	mov    0x4(%ecx),%ebx
  807001:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  807006:	0f 85 b0 01 00 00    	jne    8071bc <ip_reass+0x46e>
        q = iprh->next_pbuf;
  80700c:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80700f:	8b 16                	mov    (%esi),%edx
  807011:	e9 85 00 00 00       	jmp    80709b <ip_reass+0x34d>
        ipr->p = new_p;
  807016:	8b 45 08             	mov    0x8(%ebp),%eax
  807019:	89 47 04             	mov    %eax,0x4(%edi)
  80701c:	eb c9                	jmp    806fe7 <ip_reass+0x299>
    q = iprh_tmp->next_pbuf;
  80701e:	8b 02                	mov    (%edx),%eax
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807020:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  807022:	85 c0                	test   %eax,%eax
  807024:	0f 84 c8 01 00 00    	je     8071f2 <ip_reass+0x4a4>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80702a:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  80702d:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  807031:	66 39 cb             	cmp    %cx,%bx
  807034:	72 85                	jb     806fbb <ip_reass+0x26d>
    } else if(iprh->start == iprh_tmp->start) {
  807036:	0f 84 5d 01 00 00    	je     807199 <ip_reass+0x44b>
    } else if(iprh->start < iprh_tmp->end) {
  80703c:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  807040:	0f 82 53 01 00 00    	jb     807199 <ip_reass+0x44b>
      if (iprh_prev != NULL) {
  807046:	85 f6                	test   %esi,%esi
  807048:	74 d4                	je     80701e <ip_reass+0x2d0>
          valid = 0;
  80704a:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  80704e:	b8 00 00 00 00       	mov    $0x0,%eax
  807053:	0f 45 f8             	cmovne %eax,%edi
  807056:	eb c6                	jmp    80701e <ip_reass+0x2d0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807058:	83 ec 04             	sub    $0x4,%esp
  80705b:	68 40 25 81 00       	push   $0x812540
  807060:	68 83 01 00 00       	push   $0x183
  807065:	68 ea 24 81 00       	push   $0x8124ea
  80706a:	e8 00 77 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80706f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  807073:	75 0b                	jne    807080 <ip_reass+0x332>
      ipr->p = new_p;
  807075:	8b 45 08             	mov    0x8(%ebp),%eax
  807078:	89 47 04             	mov    %eax,0x4(%edi)
  80707b:	e9 67 ff ff ff       	jmp    806fe7 <ip_reass+0x299>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807080:	83 ec 04             	sub    $0x4,%esp
  807083:	68 6c 25 81 00       	push   $0x81256c
  807088:	68 8c 01 00 00       	push   $0x18c
  80708d:	68 ea 24 81 00       	push   $0x8124ea
  807092:	e8 d8 76 00 00       	call   80e76f <_panic>
          q = iprh->next_pbuf;
  807097:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  807099:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  80709b:	85 d2                	test   %edx,%edx
  80709d:	74 12                	je     8070b1 <ip_reass+0x363>
          iprh = (struct ip_reass_helper*)q->payload;
  80709f:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  8070a2:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  8070a6:	66 39 56 06          	cmp    %dx,0x6(%esi)
  8070aa:	74 eb                	je     807097 <ip_reass+0x349>
  8070ac:	e9 0b 01 00 00       	jmp    8071bc <ip_reass+0x46e>
  8070b1:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  8070b4:	39 f3                	cmp    %esi,%ebx
  8070b6:	0f 84 98 00 00 00    	je     807154 <ip_reass+0x406>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8070bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8070bf:	83 38 00             	cmpl   $0x0,(%eax)
  8070c2:	0f 85 a3 00 00 00    	jne    80716b <ip_reass+0x41d>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8070c8:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8070cc:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8070cf:	66 39 46 06          	cmp    %ax,0x6(%esi)
  8070d3:	0f 85 a9 00 00 00    	jne    807182 <ip_reass+0x434>
    ipr->datagram_len += IP_HLEN;
  8070d9:	83 c0 14             	add    $0x14,%eax
  8070dc:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8070e0:	8b 71 04             	mov    0x4(%ecx),%esi
  8070e3:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8070e5:	83 ec 04             	sub    $0x4,%esp
  8070e8:	6a 14                	push   $0x14
  8070ea:	8d 47 08             	lea    0x8(%edi),%eax
  8070ed:	50                   	push   %eax
  8070ee:	56                   	push   %esi
  8070ef:	e8 c0 80 00 00       	call   80f1b4 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8070f4:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8070f8:	89 04 24             	mov    %eax,(%esp)
  8070fb:	e8 de 06 00 00       	call   8077de <htons>
  807100:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807104:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  80710a:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807110:	83 c4 08             	add    $0x8,%esp
  807113:	6a 14                	push   $0x14
  807115:	56                   	push   %esi
  807116:	e8 95 05 00 00       	call   8076b0 <inet_chksum>
  80711b:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  80711f:	8b 47 04             	mov    0x4(%edi),%eax
  807122:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807125:	83 c4 10             	add    $0x10,%esp
  807128:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80712b:	89 c7                	mov    %eax,%edi
  80712d:	85 db                	test   %ebx,%ebx
  80712f:	0f 84 93 00 00 00    	je     8071c8 <ip_reass+0x47a>
      iprh = (struct ip_reass_helper*)r->payload;
  807135:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  807138:	83 ec 08             	sub    $0x8,%esp
  80713b:	6a ec                	push   $0xffffffec
  80713d:	53                   	push   %ebx
  80713e:	e8 f4 d6 ff ff       	call   804837 <pbuf_header>
      pbuf_cat(p, r);
  807143:	83 c4 08             	add    $0x8,%esp
  807146:	53                   	push   %ebx
  807147:	57                   	push   %edi
  807148:	e8 2a dc ff ff       	call   804d77 <pbuf_cat>
      r = iprh->next_pbuf;
  80714d:	8b 1e                	mov    (%esi),%ebx
  80714f:	83 c4 10             	add    $0x10,%esp
  807152:	eb d9                	jmp    80712d <ip_reass+0x3df>
          LWIP_ASSERT("sanity check",
  807154:	83 ec 04             	sub    $0x4,%esp
  807157:	68 5e 25 81 00       	push   $0x81255e
  80715c:	68 ae 01 00 00       	push   $0x1ae
  807161:	68 ea 24 81 00       	push   $0x8124ea
  807166:	e8 04 76 00 00       	call   80e76f <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80716b:	83 ec 04             	sub    $0x4,%esp
  80716e:	68 a4 25 81 00       	push   $0x8125a4
  807173:	68 b0 01 00 00       	push   $0x1b0
  807178:	68 ea 24 81 00       	push   $0x8124ea
  80717d:	e8 ed 75 00 00       	call   80e76f <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807182:	83 ec 04             	sub    $0x4,%esp
  807185:	68 c8 25 81 00       	push   $0x8125c8
  80718a:	68 b2 01 00 00       	push   $0x1b2
  80718f:	68 ea 24 81 00       	push   $0x8124ea
  807194:	e8 d6 75 00 00       	call   80e76f <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807199:	83 ec 0c             	sub    $0xc,%esp
  80719c:	ff 75 08             	pushl  0x8(%ebp)
  80719f:	e8 aa db ff ff       	call   804d4e <pbuf_clen>
  8071a4:	0f b6 c0             	movzbl %al,%eax
  8071a7:	66 29 05 dc 59 b3 00 	sub    %ax,0xb359dc
  pbuf_free(new_p);
  8071ae:	83 c4 04             	add    $0x4,%esp
  8071b1:	ff 75 08             	pushl  0x8(%ebp)
  8071b4:	e8 4b d7 ff ff       	call   804904 <pbuf_free>
  8071b9:	83 c4 10             	add    $0x10,%esp
  return NULL;
  8071bc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8071c3:	e9 a2 fd ff ff       	jmp    806f6a <ip_reass+0x21c>
  8071c8:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8071cb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8071ce:	89 f8                	mov    %edi,%eax
  8071d0:	e8 4e f9 ff ff       	call   806b23 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  8071d5:	83 ec 0c             	sub    $0xc,%esp
  8071d8:	ff 75 e4             	pushl  -0x1c(%ebp)
  8071db:	e8 6e db ff ff       	call   804d4e <pbuf_clen>
  8071e0:	0f b6 c0             	movzbl %al,%eax
  8071e3:	66 29 05 dc 59 b3 00 	sub    %ax,0xb359dc
    return p;
  8071ea:	83 c4 10             	add    $0x10,%esp
  8071ed:	e9 78 fd ff ff       	jmp    806f6a <ip_reass+0x21c>
  8071f2:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8071f5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  8071f8:	85 f6                	test   %esi,%esi
  8071fa:	0f 84 6f fe ff ff    	je     80706f <ip_reass+0x321>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807200:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  807204:	66 39 c3             	cmp    %ax,%bx
  807207:	0f 82 4b fe ff ff    	jb     807058 <ip_reass+0x30a>
      iprh_prev->next_pbuf = new_p;
  80720d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807210:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807212:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807215:	66 3b 46 04          	cmp    0x4(%esi),%ax
  807219:	75 a1                	jne    8071bc <ip_reass+0x46e>
  80721b:	e9 c7 fd ff ff       	jmp    806fe7 <ip_reass+0x299>

00807220 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807220:	55                   	push   %ebp
  807221:	89 e5                	mov    %esp,%ebp
  807223:	57                   	push   %edi
  807224:	56                   	push   %esi
  807225:	53                   	push   %ebx
  807226:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807229:	8b 45 0c             	mov    0xc(%ebp),%eax
  80722c:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807230:	6a 02                	push   $0x2
  807232:	6a 00                	push   $0x0
  807234:	6a 02                	push   $0x2
  807236:	e8 8f d7 ff ff       	call   8049ca <pbuf_alloc>
  80723b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  80723e:	83 c4 10             	add    $0x10,%esp
  807241:	85 c0                	test   %eax,%eax
  807243:	0f 84 c2 00 00 00    	je     80730b <ip_frag+0xeb>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  807249:	66 89 70 0a          	mov    %si,0xa(%eax)
  80724d:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807251:	bb 03 54 b3 00       	mov    $0xb35403,%ebx
  807256:	83 e3 fc             	and    $0xfffffffc,%ebx
  807259:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80725c:	83 ec 04             	sub    $0x4,%esp
  80725f:	6a 14                	push   $0x14
  807261:	8b 45 08             	mov    0x8(%ebp),%eax
  807264:	ff 70 04             	pushl  0x4(%eax)
  807267:	53                   	push   %ebx
  807268:	e8 47 7f 00 00       	call   80f1b4 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80726d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807271:	89 04 24             	mov    %eax,(%esp)
  807274:	e8 72 05 00 00       	call   8077eb <ntohs>
  ofo = tmp & IP_OFFMASK;
  807279:	89 c7                	mov    %eax,%edi
  80727b:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807280:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  807284:	66 25 00 20          	and    $0x2000,%ax
  807288:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  80728c:	8b 45 08             	mov    0x8(%ebp),%eax
  80728f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807293:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  807296:	0f b7 f6             	movzwl %si,%esi
  807299:	8d 46 f3             	lea    -0xd(%esi),%eax
  80729c:	83 c4 10             	add    $0x10,%esp
  80729f:	89 f2                	mov    %esi,%edx
  8072a1:	83 ea 14             	sub    $0x14,%edx
  8072a4:	0f 49 c2             	cmovns %edx,%eax
  8072a7:	c1 f8 03             	sar    $0x3,%eax
  8072aa:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8072ae:	c1 e0 03             	shl    $0x3,%eax
  8072b1:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072b5:	0f b7 c8             	movzwl %ax,%ecx
  8072b8:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072bb:	83 c0 14             	add    $0x14,%eax
  8072be:	0f b7 c0             	movzwl %ax,%eax
  8072c1:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  8072c4:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  8072ca:	8d 46 ed             	lea    -0x13(%esi),%eax
  8072cd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072d0:	8d 43 14             	lea    0x14(%ebx),%eax
  8072d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  8072d6:	e9 e3 00 00 00       	jmp    8073be <ip_frag+0x19e>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8072db:	83 ec 0c             	sub    $0xc,%esp
  8072de:	ff 75 dc             	pushl  -0x24(%ebp)
  8072e1:	e8 1e d6 ff ff       	call   804904 <pbuf_free>
      return ERR_MEM;
  8072e6:	83 c4 10             	add    $0x10,%esp
  8072e9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8072ee:	eb 13                	jmp    807303 <ip_frag+0xe3>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8072f0:	83 ec 0c             	sub    $0xc,%esp
  8072f3:	ff 75 dc             	pushl  -0x24(%ebp)
  8072f6:	e8 09 d6 ff ff       	call   804904 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8072fb:	83 c4 10             	add    $0x10,%esp
  8072fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807303:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807306:	5b                   	pop    %ebx
  807307:	5e                   	pop    %esi
  807308:	5f                   	pop    %edi
  807309:	5d                   	pop    %ebp
  80730a:	c3                   	ret    
    return ERR_MEM;
  80730b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807310:	eb f1                	jmp    807303 <ip_frag+0xe3>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807312:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  807316:	52                   	push   %edx
  807317:	50                   	push   %eax
  807318:	ff 75 d4             	pushl  -0x2c(%ebp)
  80731b:	ff 75 08             	pushl  0x8(%ebp)
  80731e:	e8 5d dd ff ff       	call   805080 <pbuf_copy_partial>
  807323:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807327:	0f b7 f6             	movzwl %si,%esi
  80732a:	89 34 24             	mov    %esi,(%esp)
  80732d:	e8 ac 04 00 00       	call   8077de <htons>
  807332:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807336:	8d 77 14             	lea    0x14(%edi),%esi
  807339:	0f b7 f6             	movzwl %si,%esi
  80733c:	89 34 24             	mov    %esi,(%esp)
  80733f:	e8 9a 04 00 00       	call   8077de <htons>
  807344:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807348:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80734e:	83 c4 08             	add    $0x8,%esp
  807351:	6a 14                	push   $0x14
  807353:	53                   	push   %ebx
  807354:	e8 57 03 00 00       	call   8076b0 <inet_chksum>
  807359:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      pbuf_realloc(rambuf, left + IP_HLEN);
  80735d:	83 c4 08             	add    $0x8,%esp
  807360:	56                   	push   %esi
  807361:	ff 75 dc             	pushl  -0x24(%ebp)
  807364:	e8 d3 d8 ff ff       	call   804c3c <pbuf_realloc>
  807369:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  80736c:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807370:	83 ec 04             	sub    $0x4,%esp
  807373:	6a 00                	push   $0x0
  807375:	6a 00                	push   $0x0
  807377:	6a 02                	push   $0x2
  807379:	e8 4c d6 ff ff       	call   8049ca <pbuf_alloc>
  80737e:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  807380:	83 c4 10             	add    $0x10,%esp
  807383:	85 c0                	test   %eax,%eax
  807385:	0f 84 50 ff ff ff    	je     8072db <ip_frag+0xbb>
      pbuf_chain(header, rambuf);
  80738b:	83 ec 08             	sub    $0x8,%esp
  80738e:	ff 75 dc             	pushl  -0x24(%ebp)
  807391:	50                   	push   %eax
  807392:	e8 4e da ff ff       	call   804de5 <pbuf_chain>
      netif->output(netif, header, dest);
  807397:	83 c4 0c             	add    $0xc,%esp
  80739a:	ff 75 10             	pushl  0x10(%ebp)
  80739d:	56                   	push   %esi
  80739e:	ff 75 0c             	pushl  0xc(%ebp)
  8073a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8073a4:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  8073a7:	89 34 24             	mov    %esi,(%esp)
  8073aa:	e8 55 d5 ff ff       	call   804904 <pbuf_free>
    left -= cop;
  8073af:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  8073b3:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  8073b7:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  8073bb:	83 c4 10             	add    $0x10,%esp
  while (left) {
  8073be:	66 85 ff             	test   %di,%di
  8073c1:	0f 84 29 ff ff ff    	je     8072f0 <ip_frag+0xd0>
    last = (left <= mtu - IP_HLEN);
  8073c7:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  8073ca:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  8073ce:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8073d3:	66 0b 75 e0          	or     -0x20(%ebp),%si
    if (!last)
  8073d7:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8073da:	0f 8f 32 ff ff ff    	jg     807312 <ip_frag+0xf2>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8073e0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8073e4:	50                   	push   %eax
  8073e5:	ff 75 cc             	pushl  -0x34(%ebp)
  8073e8:	ff 75 d4             	pushl  -0x2c(%ebp)
  8073eb:	ff 75 08             	pushl  0x8(%ebp)
  8073ee:	e8 8d dc ff ff       	call   805080 <pbuf_copy_partial>
  8073f3:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  8073f7:	66 81 ce 00 20       	or     $0x2000,%si
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8073fc:	0f b7 f6             	movzwl %si,%esi
  8073ff:	89 34 24             	mov    %esi,(%esp)
  807402:	e8 d7 03 00 00       	call   8077de <htons>
  807407:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80740b:	83 c4 04             	add    $0x4,%esp
  80740e:	ff 75 c8             	pushl  -0x38(%ebp)
  807411:	e8 c8 03 00 00       	call   8077de <htons>
  807416:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  80741a:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807420:	83 c4 08             	add    $0x8,%esp
  807423:	6a 14                	push   $0x14
  807425:	53                   	push   %ebx
  807426:	e8 85 02 00 00       	call   8076b0 <inet_chksum>
  80742b:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  80742f:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807432:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  807436:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  80743a:	e9 31 ff ff ff       	jmp    807370 <ip_frag+0x150>

0080743f <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80743f:	55                   	push   %ebp
  807440:	89 e5                	mov    %esp,%ebp
  807442:	57                   	push   %edi
  807443:	56                   	push   %esi
  807444:	53                   	push   %ebx
  807445:	83 ec 1c             	sub    $0x1c,%esp
  807448:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80744b:	89 d7                	mov    %edx,%edi
  80744d:	66 d1 ef             	shr    %di
  807450:	0f b7 d7             	movzwl %di,%edx
  807453:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807456:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80745b:	39 f0                	cmp    %esi,%eax
  80745d:	74 18                	je     807477 <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80745f:	0f b6 10             	movzbl (%eax),%edx
  807462:	89 d1                	mov    %edx,%ecx
  807464:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807467:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80746b:	09 ca                	or     %ecx,%edx
  80746d:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  807470:	0f b7 d2             	movzwl %dx,%edx
  807473:	01 d3                	add    %edx,%ebx
  807475:	eb e4                	jmp    80745b <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  807477:	01 ff                	add    %edi,%edi
  807479:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  80747d:	74 0b                	je     80748a <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80747f:	0f b6 00             	movzbl (%eax),%eax
  807482:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807485:	0f b7 c0             	movzwl %ax,%eax
  807488:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80748a:	89 d8                	mov    %ebx,%eax
  80748c:	c1 e8 10             	shr    $0x10,%eax
  80748f:	0f b7 db             	movzwl %bx,%ebx
  807492:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807494:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  80749a:	74 0a                	je     8074a6 <lwip_standard_chksum+0x67>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80749c:	89 d8                	mov    %ebx,%eax
  80749e:	c1 e8 10             	shr    $0x10,%eax
  8074a1:	0f b7 db             	movzwl %bx,%ebx
  8074a4:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  8074a6:	83 ec 0c             	sub    $0xc,%esp
  8074a9:	0f b7 db             	movzwl %bx,%ebx
  8074ac:	53                   	push   %ebx
  8074ad:	e8 2c 03 00 00       	call   8077de <htons>
}
  8074b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8074b5:	5b                   	pop    %ebx
  8074b6:	5e                   	pop    %esi
  8074b7:	5f                   	pop    %edi
  8074b8:	5d                   	pop    %ebp
  8074b9:	c3                   	ret    

008074ba <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8074ba:	55                   	push   %ebp
  8074bb:	89 e5                	mov    %esp,%ebp
  8074bd:	57                   	push   %edi
  8074be:	56                   	push   %esi
  8074bf:	53                   	push   %ebx
  8074c0:	83 ec 1c             	sub    $0x1c,%esp
  8074c3:	8b 75 08             	mov    0x8(%ebp),%esi
  8074c6:	8b 45 14             	mov    0x14(%ebp),%eax
  8074c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8074cc:	8b 45 18             	mov    0x18(%ebp),%eax
  8074cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8074d2:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8074d7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8074dc:	89 f8                	mov    %edi,%eax
  8074de:	89 df                	mov    %ebx,%edi
  8074e0:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8074e2:	eb 02                	jmp    8074e6 <inet_chksum_pseudo+0x2c>
  8074e4:	8b 36                	mov    (%esi),%esi
  8074e6:	85 f6                	test   %esi,%esi
  8074e8:	74 3d                	je     807527 <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8074ea:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8074ee:	8b 46 04             	mov    0x4(%esi),%eax
  8074f1:	e8 49 ff ff ff       	call   80743f <lwip_standard_chksum>
  8074f6:	0f b7 c0             	movzwl %ax,%eax
  8074f9:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8074fb:	89 c7                	mov    %eax,%edi
  8074fd:	c1 ef 10             	shr    $0x10,%edi
  807500:	0f b7 c0             	movzwl %ax,%eax
  807503:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  807505:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807509:	74 d9                	je     8074e4 <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  80750b:	b8 01 00 00 00       	mov    $0x1,%eax
  807510:	29 d8                	sub    %ebx,%eax
  807512:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807514:	89 fa                	mov    %edi,%edx
  807516:	c1 e2 08             	shl    $0x8,%edx
  807519:	0f b7 d2             	movzwl %dx,%edx
  80751c:	89 f8                	mov    %edi,%eax
  80751e:	0f b6 c4             	movzbl %ah,%eax
  807521:	09 c2                	or     %eax,%edx
  807523:	89 d7                	mov    %edx,%edi
  807525:	eb bd                	jmp    8074e4 <inet_chksum_pseudo+0x2a>
  807527:	89 d8                	mov    %ebx,%eax
  807529:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80752b:	84 c0                	test   %al,%al
  80752d:	74 0d                	je     80753c <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  80752f:	89 f8                	mov    %edi,%eax
  807531:	c1 e0 08             	shl    $0x8,%eax
  807534:	0f b7 c0             	movzwl %ax,%eax
  807537:	0f b6 df             	movzbl %bh,%ebx
  80753a:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80753c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80753f:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807541:	8b 55 10             	mov    0x10(%ebp),%edx
  807544:	8b 12                	mov    (%edx),%edx
  807546:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807549:	c1 ea 10             	shr    $0x10,%edx
  80754c:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  80754e:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807551:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807553:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807556:	01 d0                	add    %edx,%eax
  807558:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  80755a:	83 ec 0c             	sub    $0xc,%esp
  80755d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807561:	50                   	push   %eax
  807562:	e8 77 02 00 00       	call   8077de <htons>
  807567:	0f b7 c0             	movzwl %ax,%eax
  80756a:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80756c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807570:	89 04 24             	mov    %eax,(%esp)
  807573:	e8 66 02 00 00       	call   8077de <htons>
  807578:	0f b7 c0             	movzwl %ax,%eax
  80757b:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80757d:	89 d8                	mov    %ebx,%eax
  80757f:	c1 e8 10             	shr    $0x10,%eax
  807582:	0f b7 db             	movzwl %bx,%ebx
  807585:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807587:	89 d8                	mov    %ebx,%eax
  807589:	c1 e8 10             	shr    $0x10,%eax
  80758c:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80758e:	f7 d0                	not    %eax
}
  807590:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807593:	5b                   	pop    %ebx
  807594:	5e                   	pop    %esi
  807595:	5f                   	pop    %edi
  807596:	5d                   	pop    %ebp
  807597:	c3                   	ret    

00807598 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807598:	55                   	push   %ebp
  807599:	89 e5                	mov    %esp,%ebp
  80759b:	57                   	push   %edi
  80759c:	56                   	push   %esi
  80759d:	53                   	push   %ebx
  80759e:	83 ec 1c             	sub    $0x1c,%esp
  8075a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8075a4:	8b 45 14             	mov    0x14(%ebp),%eax
  8075a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8075aa:	8b 45 18             	mov    0x18(%ebp),%eax
  8075ad:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8075b0:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8075b4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  8075b8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8075bf:	eb 19                	jmp    8075da <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8075c1:	83 ec 04             	sub    $0x4,%esp
  8075c4:	68 f5 25 81 00       	push   $0x8125f5
  8075c9:	68 60 01 00 00       	push   $0x160
  8075ce:	68 00 26 81 00       	push   $0x812600
  8075d3:	e8 97 71 00 00       	call   80e76f <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8075d8:	8b 1b                	mov    (%ebx),%ebx
  8075da:	85 db                	test   %ebx,%ebx
  8075dc:	74 5c                	je     80763a <inet_chksum_pseudo_partial+0xa2>
  8075de:	66 85 f6             	test   %si,%si
  8075e1:	74 57                	je     80763a <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  8075e3:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8075e7:	66 39 fe             	cmp    %di,%si
  8075ea:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  8075ed:	0f b7 d7             	movzwl %di,%edx
  8075f0:	8b 43 04             	mov    0x4(%ebx),%eax
  8075f3:	e8 47 fe ff ff       	call   80743f <lwip_standard_chksum>
  8075f8:	0f b7 c0             	movzwl %ax,%eax
  8075fb:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8075fe:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807600:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  807605:	77 ba                	ja     8075c1 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807607:	89 c2                	mov    %eax,%edx
  807609:	c1 ea 10             	shr    $0x10,%edx
  80760c:	0f b7 c0             	movzwl %ax,%eax
  80760f:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  807612:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807615:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807619:	74 bd                	je     8075d8 <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  80761b:	b8 01 00 00 00       	mov    $0x1,%eax
  807620:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807623:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807626:	89 fa                	mov    %edi,%edx
  807628:	c1 e2 08             	shl    $0x8,%edx
  80762b:	0f b7 d2             	movzwl %dx,%edx
  80762e:	89 f8                	mov    %edi,%eax
  807630:	0f b6 c4             	movzbl %ah,%eax
  807633:	09 c2                	or     %eax,%edx
  807635:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807638:	eb 9e                	jmp    8075d8 <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80763a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80763e:	74 13                	je     807653 <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  807640:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807643:	89 c8                	mov    %ecx,%eax
  807645:	c1 e0 08             	shl    $0x8,%eax
  807648:	0f b7 c0             	movzwl %ax,%eax
  80764b:	0f b6 d5             	movzbl %ch,%edx
  80764e:	09 d0                	or     %edx,%eax
  807650:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807653:	8b 45 0c             	mov    0xc(%ebp),%eax
  807656:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807658:	8b 45 10             	mov    0x10(%ebp),%eax
  80765b:	8b 00                	mov    (%eax),%eax
  80765d:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807660:	c1 e8 10             	shr    $0x10,%eax
  807663:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  807665:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807668:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  80766a:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80766d:	01 c3                	add    %eax,%ebx
  80766f:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807672:	83 ec 0c             	sub    $0xc,%esp
  807675:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807679:	50                   	push   %eax
  80767a:	e8 5f 01 00 00       	call   8077de <htons>
  80767f:	0f b7 f0             	movzwl %ax,%esi
  807682:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  807684:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807688:	89 04 24             	mov    %eax,(%esp)
  80768b:	e8 4e 01 00 00       	call   8077de <htons>
  807690:	0f b7 d8             	movzwl %ax,%ebx
  807693:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807695:	89 d8                	mov    %ebx,%eax
  807697:	c1 e8 10             	shr    $0x10,%eax
  80769a:	0f b7 db             	movzwl %bx,%ebx
  80769d:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80769f:	89 d8                	mov    %ebx,%eax
  8076a1:	c1 e8 10             	shr    $0x10,%eax
  8076a4:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  8076a6:	f7 d0                	not    %eax
}
  8076a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8076ab:	5b                   	pop    %ebx
  8076ac:	5e                   	pop    %esi
  8076ad:	5f                   	pop    %edi
  8076ae:	5d                   	pop    %ebp
  8076af:	c3                   	ret    

008076b0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8076b0:	55                   	push   %ebp
  8076b1:	89 e5                	mov    %esp,%ebp
  8076b3:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8076b6:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8076ba:	8b 45 08             	mov    0x8(%ebp),%eax
  8076bd:	e8 7d fd ff ff       	call   80743f <lwip_standard_chksum>
  8076c2:	f7 d0                	not    %eax
}
  8076c4:	c9                   	leave  
  8076c5:	c3                   	ret    

008076c6 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8076c6:	55                   	push   %ebp
  8076c7:	89 e5                	mov    %esp,%ebp
  8076c9:	57                   	push   %edi
  8076ca:	56                   	push   %esi
  8076cb:	53                   	push   %ebx
  8076cc:	83 ec 0c             	sub    $0xc,%esp
  8076cf:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8076d2:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8076d7:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  8076dc:	eb 02                	jmp    8076e0 <inet_chksum_pbuf+0x1a>
  8076de:	8b 36                	mov    (%esi),%esi
  8076e0:	85 f6                	test   %esi,%esi
  8076e2:	74 3b                	je     80771f <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8076e4:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8076e8:	8b 46 04             	mov    0x4(%esi),%eax
  8076eb:	e8 4f fd ff ff       	call   80743f <lwip_standard_chksum>
  8076f0:	0f b7 c0             	movzwl %ax,%eax
  8076f3:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8076f5:	89 d8                	mov    %ebx,%eax
  8076f7:	c1 e8 10             	shr    $0x10,%eax
  8076fa:	0f b7 db             	movzwl %bx,%ebx
  8076fd:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8076ff:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807703:	74 d9                	je     8076de <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  807705:	b8 01 00 00 00       	mov    $0x1,%eax
  80770a:	89 f9                	mov    %edi,%ecx
  80770c:	29 c8                	sub    %ecx,%eax
  80770e:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807710:	89 da                	mov    %ebx,%edx
  807712:	c1 e2 08             	shl    $0x8,%edx
  807715:	0f b7 d2             	movzwl %dx,%edx
  807718:	0f b6 df             	movzbl %bh,%ebx
  80771b:	09 d3                	or     %edx,%ebx
  80771d:	eb bf                	jmp    8076de <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  80771f:	89 f8                	mov    %edi,%eax
  807721:	84 c0                	test   %al,%al
  807723:	74 0d                	je     807732 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  807725:	89 da                	mov    %ebx,%edx
  807727:	c1 e2 08             	shl    $0x8,%edx
  80772a:	0f b7 d2             	movzwl %dx,%edx
  80772d:	0f b6 df             	movzbl %bh,%ebx
  807730:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807732:	89 d8                	mov    %ebx,%eax
  807734:	f7 d0                	not    %eax
}
  807736:	83 c4 0c             	add    $0xc,%esp
  807739:	5b                   	pop    %ebx
  80773a:	5e                   	pop    %esi
  80773b:	5f                   	pop    %edi
  80773c:	5d                   	pop    %ebp
  80773d:	c3                   	ret    

0080773e <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80773e:	55                   	push   %ebp
  80773f:	89 e5                	mov    %esp,%ebp
  807741:	57                   	push   %edi
  807742:	56                   	push   %esi
  807743:	53                   	push   %ebx
  807744:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807747:	8b 45 08             	mov    0x8(%ebp),%eax
  80774a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80774d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  807751:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  807754:	bf e4 59 b3 00       	mov    $0xb359e4,%edi
  807759:	eb 1a                	jmp    807775 <inet_ntoa+0x37>
  80775b:	0f b6 db             	movzbl %bl,%ebx
  80775e:	01 fb                	add    %edi,%ebx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807760:	8d 7b 01             	lea    0x1(%ebx),%edi
  807763:	c6 03 2e             	movb   $0x2e,(%ebx)
  807766:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  807769:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  80776d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807771:	3c 04                	cmp    $0x4,%al
  807773:	74 59                	je     8077ce <inet_ntoa+0x90>
  rp = str;
  807775:	ba 00 00 00 00       	mov    $0x0,%edx
      rem = *ap % (u8_t)10;
  80777a:	0f b6 0e             	movzbl (%esi),%ecx
      *ap /= (u8_t)10;
  80777d:	0f b6 d9             	movzbl %cl,%ebx
  807780:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807783:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807786:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807789:	66 c1 e8 0b          	shr    $0xb,%ax
  80778d:	88 06                	mov    %al,(%esi)
      inv[i++] = '0' + rem;
  80778f:	8d 5a 01             	lea    0x1(%edx),%ebx
  807792:	0f b6 d2             	movzbl %dl,%edx
  807795:	89 55 e0             	mov    %edx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807798:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80779b:	01 c0                	add    %eax,%eax
  80779d:	89 ca                	mov    %ecx,%edx
  80779f:	29 c2                	sub    %eax,%edx
  8077a1:	89 d0                	mov    %edx,%eax
      inv[i++] = '0' + rem;
  8077a3:	83 c0 30             	add    $0x30,%eax
  8077a6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8077a9:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  8077ad:	89 da                	mov    %ebx,%edx
    } while(*ap);
  8077af:	80 f9 09             	cmp    $0x9,%cl
  8077b2:	77 c6                	ja     80777a <inet_ntoa+0x3c>
  8077b4:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  8077b6:	89 d8                	mov    %ebx,%eax
    while(i--)
  8077b8:	83 e8 01             	sub    $0x1,%eax
  8077bb:	3c ff                	cmp    $0xff,%al
  8077bd:	74 9c                	je     80775b <inet_ntoa+0x1d>
      *rp++ = inv[i];
  8077bf:	0f b6 c8             	movzbl %al,%ecx
  8077c2:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8077c7:	88 0a                	mov    %cl,(%edx)
  8077c9:	83 c2 01             	add    $0x1,%edx
  8077cc:	eb ea                	jmp    8077b8 <inet_ntoa+0x7a>
    ap++;
  }
  *--rp = 0;
  8077ce:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  8077d1:	b8 e4 59 b3 00       	mov    $0xb359e4,%eax
  8077d6:	83 c4 18             	add    $0x18,%esp
  8077d9:	5b                   	pop    %ebx
  8077da:	5e                   	pop    %esi
  8077db:	5f                   	pop    %edi
  8077dc:	5d                   	pop    %ebp
  8077dd:	c3                   	ret    

008077de <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8077de:	55                   	push   %ebp
  8077df:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8077e1:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8077e5:	66 c1 c0 08          	rol    $0x8,%ax
}
  8077e9:	5d                   	pop    %ebp
  8077ea:	c3                   	ret    

008077eb <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8077eb:	55                   	push   %ebp
  8077ec:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8077ee:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8077f2:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  8077f6:	5d                   	pop    %ebp
  8077f7:	c3                   	ret    

008077f8 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8077f8:	55                   	push   %ebp
  8077f9:	89 e5                	mov    %esp,%ebp
  8077fb:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8077fe:	89 d0                	mov    %edx,%eax
  807800:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807803:	89 d1                	mov    %edx,%ecx
  807805:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  807808:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  80780a:	89 d1                	mov    %edx,%ecx
  80780c:	c1 e1 08             	shl    $0x8,%ecx
  80780f:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  807815:	09 c8                	or     %ecx,%eax
  807817:	c1 ea 08             	shr    $0x8,%edx
  80781a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  807820:	09 d0                	or     %edx,%eax
}
  807822:	5d                   	pop    %ebp
  807823:	c3                   	ret    

00807824 <inet_aton>:
{
  807824:	55                   	push   %ebp
  807825:	89 e5                	mov    %esp,%ebp
  807827:	57                   	push   %edi
  807828:	56                   	push   %esi
  807829:	53                   	push   %ebx
  80782a:	83 ec 2c             	sub    $0x2c,%esp
  80782d:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  807830:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  807833:	8d 75 d8             	lea    -0x28(%ebp),%esi
  807836:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807839:	e9 a7 00 00 00       	jmp    8078e5 <inet_aton+0xc1>
      c = *++cp;
  80783e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807842:	89 d1                	mov    %edx,%ecx
  807844:	83 e1 df             	and    $0xffffffdf,%ecx
  807847:	80 f9 58             	cmp    $0x58,%cl
  80784a:	74 10                	je     80785c <inet_aton+0x38>
      c = *++cp;
  80784c:	83 c0 01             	add    $0x1,%eax
  80784f:	0f be d2             	movsbl %dl,%edx
        base = 8;
  807852:	be 08 00 00 00       	mov    $0x8,%esi
  807857:	e9 a3 00 00 00       	jmp    8078ff <inet_aton+0xdb>
        c = *++cp;
  80785c:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807860:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  807863:	be 10 00 00 00       	mov    $0x10,%esi
  807868:	e9 92 00 00 00       	jmp    8078ff <inet_aton+0xdb>
      } else if (base == 16 && isxdigit(c)) {
  80786d:	83 fe 10             	cmp    $0x10,%esi
  807870:	75 4d                	jne    8078bf <inet_aton+0x9b>
  807872:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  807875:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  807878:	89 d1                	mov    %edx,%ecx
  80787a:	83 e1 df             	and    $0xffffffdf,%ecx
  80787d:	83 e9 41             	sub    $0x41,%ecx
  807880:	80 f9 05             	cmp    $0x5,%cl
  807883:	77 3a                	ja     8078bf <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807885:	c1 e3 04             	shl    $0x4,%ebx
  807888:	83 c2 0a             	add    $0xa,%edx
  80788b:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80788f:	19 c9                	sbb    %ecx,%ecx
  807891:	83 e1 20             	and    $0x20,%ecx
  807894:	83 c1 41             	add    $0x41,%ecx
  807897:	29 ca                	sub    %ecx,%edx
  807899:	09 d3                	or     %edx,%ebx
        c = *++cp;
  80789b:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80789e:	0f be 57 01          	movsbl 0x1(%edi),%edx
  8078a2:	83 c0 01             	add    $0x1,%eax
  8078a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (isdigit(c)) {
  8078a8:	89 d7                	mov    %edx,%edi
  8078aa:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8078ad:	80 f9 09             	cmp    $0x9,%cl
  8078b0:	77 bb                	ja     80786d <inet_aton+0x49>
        val = (val * base) + (int)(c - '0');
  8078b2:	0f af de             	imul   %esi,%ebx
  8078b5:	8d 5c 1a d0          	lea    -0x30(%edx,%ebx,1),%ebx
        c = *++cp;
  8078b9:	0f be 50 01          	movsbl 0x1(%eax),%edx
  8078bd:	eb e3                	jmp    8078a2 <inet_aton+0x7e>
    if (c == '.') {
  8078bf:	83 fa 2e             	cmp    $0x2e,%edx
  8078c2:	75 42                	jne    807906 <inet_aton+0xe2>
      if (pp >= parts + 3)
  8078c4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8078c7:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8078ca:	39 c6                	cmp    %eax,%esi
  8078cc:	0f 84 0e 01 00 00    	je     8079e0 <inet_aton+0x1bc>
      *pp++ = val;
  8078d2:	83 c6 04             	add    $0x4,%esi
  8078d5:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8078d8:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  8078db:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8078de:	8d 46 01             	lea    0x1(%esi),%eax
  8078e1:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  8078e5:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8078e8:	80 f9 09             	cmp    $0x9,%cl
  8078eb:	0f 87 e8 00 00 00    	ja     8079d9 <inet_aton+0x1b5>
    base = 10;
  8078f1:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  8078f6:	83 fa 30             	cmp    $0x30,%edx
  8078f9:	0f 84 3f ff ff ff    	je     80783e <inet_aton+0x1a>
    base = 10;
  8078ff:	bb 00 00 00 00       	mov    $0x0,%ebx
  807904:	eb 9f                	jmp    8078a5 <inet_aton+0x81>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807906:	85 d2                	test   %edx,%edx
  807908:	74 26                	je     807930 <inet_aton+0x10c>
    return (0);
  80790a:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80790f:	89 f9                	mov    %edi,%ecx
  807911:	80 f9 1f             	cmp    $0x1f,%cl
  807914:	0f 86 cb 00 00 00    	jbe    8079e5 <inet_aton+0x1c1>
  80791a:	84 d2                	test   %dl,%dl
  80791c:	0f 88 c3 00 00 00    	js     8079e5 <inet_aton+0x1c1>
  807922:	83 fa 20             	cmp    $0x20,%edx
  807925:	74 09                	je     807930 <inet_aton+0x10c>
  807927:	83 fa 0c             	cmp    $0xc,%edx
  80792a:	0f 85 b5 00 00 00    	jne    8079e5 <inet_aton+0x1c1>
  n = pp - parts + 1;
  807930:	8d 45 d8             	lea    -0x28(%ebp),%eax
  807933:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807936:	29 c6                	sub    %eax,%esi
  807938:	89 f0                	mov    %esi,%eax
  80793a:	c1 f8 02             	sar    $0x2,%eax
  80793d:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  807940:	83 f8 02             	cmp    $0x2,%eax
  807943:	74 5e                	je     8079a3 <inet_aton+0x17f>
  807945:	7e 35                	jle    80797c <inet_aton+0x158>
  807947:	83 f8 03             	cmp    $0x3,%eax
  80794a:	74 6e                	je     8079ba <inet_aton+0x196>
  80794c:	83 f8 04             	cmp    $0x4,%eax
  80794f:	75 2f                	jne    807980 <inet_aton+0x15c>
      return (0);
  807951:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  807956:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80795c:	0f 87 83 00 00 00    	ja     8079e5 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807962:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807965:	c1 e0 18             	shl    $0x18,%eax
  807968:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80796b:	c1 e2 10             	shl    $0x10,%edx
  80796e:	09 d0                	or     %edx,%eax
  807970:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807973:	c1 e2 08             	shl    $0x8,%edx
  807976:	09 d0                	or     %edx,%eax
  807978:	09 c3                	or     %eax,%ebx
    break;
  80797a:	eb 04                	jmp    807980 <inet_aton+0x15c>
  switch (n) {
  80797c:	85 c0                	test   %eax,%eax
  80797e:	74 65                	je     8079e5 <inet_aton+0x1c1>
  return (1);
  807980:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  807985:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807989:	74 5a                	je     8079e5 <inet_aton+0x1c1>
    addr->s_addr = htonl(val);
  80798b:	83 ec 0c             	sub    $0xc,%esp
  80798e:	53                   	push   %ebx
  80798f:	e8 64 fe ff ff       	call   8077f8 <htonl>
  807994:	83 c4 10             	add    $0x10,%esp
  807997:	8b 75 0c             	mov    0xc(%ebp),%esi
  80799a:	89 06                	mov    %eax,(%esi)
  return (1);
  80799c:	b8 01 00 00 00       	mov    $0x1,%eax
  8079a1:	eb 42                	jmp    8079e5 <inet_aton+0x1c1>
      return (0);
  8079a3:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  8079a8:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  8079ae:	77 35                	ja     8079e5 <inet_aton+0x1c1>
    val |= parts[0] << 24;
  8079b0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8079b3:	c1 e0 18             	shl    $0x18,%eax
  8079b6:	09 c3                	or     %eax,%ebx
    break;
  8079b8:	eb c6                	jmp    807980 <inet_aton+0x15c>
      return (0);
  8079ba:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  8079bf:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8079c5:	77 1e                	ja     8079e5 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16);
  8079c7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8079ca:	c1 e0 18             	shl    $0x18,%eax
  8079cd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8079d0:	c1 e2 10             	shl    $0x10,%edx
  8079d3:	09 d0                	or     %edx,%eax
  8079d5:	09 c3                	or     %eax,%ebx
    break;
  8079d7:	eb a7                	jmp    807980 <inet_aton+0x15c>
      return (0);
  8079d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8079de:	eb 05                	jmp    8079e5 <inet_aton+0x1c1>
        return (0);
  8079e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8079e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8079e8:	5b                   	pop    %ebx
  8079e9:	5e                   	pop    %esi
  8079ea:	5f                   	pop    %edi
  8079eb:	5d                   	pop    %ebp
  8079ec:	c3                   	ret    

008079ed <inet_addr>:
{
  8079ed:	55                   	push   %ebp
  8079ee:	89 e5                	mov    %esp,%ebp
  8079f0:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  8079f3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8079f6:	50                   	push   %eax
  8079f7:	ff 75 08             	pushl  0x8(%ebp)
  8079fa:	e8 25 fe ff ff       	call   807824 <inet_aton>
  8079ff:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807a02:	85 c0                	test   %eax,%eax
  807a04:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a09:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807a0d:	c9                   	leave  
  807a0e:	c3                   	ret    

00807a0f <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807a0f:	55                   	push   %ebp
  807a10:	89 e5                	mov    %esp,%ebp
  807a12:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  807a15:	ff 75 08             	pushl  0x8(%ebp)
  807a18:	e8 db fd ff ff       	call   8077f8 <htonl>
  807a1d:	83 c4 10             	add    $0x10,%esp
}
  807a20:	c9                   	leave  
  807a21:	c3                   	ret    

00807a22 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807a22:	55                   	push   %ebp
  807a23:	89 e5                	mov    %esp,%ebp
  807a25:	57                   	push   %edi
  807a26:	56                   	push   %esi
  807a27:	53                   	push   %ebx
  807a28:	83 ec 3c             	sub    $0x3c,%esp
  807a2b:	8b 7d 08             	mov    0x8(%ebp),%edi
  807a2e:	8b 75 10             	mov    0x10(%ebp),%esi
  807a31:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807a34:	8b 55 14             	mov    0x14(%ebp),%edx
  807a37:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807a3a:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807a3d:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807a40:	8b 45 20             	mov    0x20(%ebp),%eax
  807a43:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807a47:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807a4a:	89 da                	mov    %ebx,%edx
  807a4c:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807a4f:	66 85 f6             	test   %si,%si
  807a52:	74 04                	je     807a58 <tcp_enqueue+0x36>
  807a54:	84 c0                	test   %al,%al
  807a56:	75 54                	jne    807aac <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807a58:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807a5c:	74 06                	je     807a64 <tcp_enqueue+0x42>
  807a5e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807a62:	75 5f                	jne    807ac3 <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807a64:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807a68:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807a6c:	72 6c                	jb     807ada <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807a6e:	8b 4f 68             	mov    0x68(%edi),%ecx
  807a71:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807a74:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807a78:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807a7c:	66 83 f9 1f          	cmp    $0x1f,%cx
  807a80:	77 66                	ja     807ae8 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807a82:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807a87:	74 6d                	je     807af6 <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807a89:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807a8d:	75 7b                	jne    807b0a <tcp_enqueue+0xe8>
  807a8f:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a93:	75 75                	jne    807b0a <tcp_enqueue+0xe8>
  807a95:	83 ec 04             	sub    $0x4,%esp
  807a98:	68 ac 26 81 00       	push   $0x8126ac
  807a9d:	68 ae 00 00 00       	push   $0xae
  807aa2:	68 c6 27 81 00       	push   $0x8127c6
  807aa7:	e8 c3 6c 00 00       	call   80e76f <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807aac:	83 ec 04             	sub    $0x4,%esp
  807aaf:	68 24 26 81 00       	push   $0x812624
  807ab4:	68 90 00 00 00       	push   $0x90
  807ab9:	68 c6 27 81 00       	push   $0x8127c6
  807abe:	e8 ac 6c 00 00       	call   80e76f <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807ac3:	83 ec 04             	sub    $0x4,%esp
  807ac6:	68 64 26 81 00       	push   $0x812664
  807acb:	68 92 00 00 00       	push   $0x92
  807ad0:	68 c6 27 81 00       	push   $0x8127c6
  807ad5:	e8 95 6c 00 00       	call   80e76f <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807ada:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807ade:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ae3:	e9 a4 03 00 00       	jmp    807e8c <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  807ae8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807aec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807af1:	e9 96 03 00 00       	jmp    807e8c <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807af6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807afa:	0f 85 05 02 00 00    	jne    807d05 <tcp_enqueue+0x2e3>
  807b00:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807b04:	0f 85 fb 01 00 00    	jne    807d05 <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807b0a:	c0 e8 02             	shr    $0x2,%al
  807b0d:	c1 e0 0c             	shl    $0xc,%eax
  807b10:	66 05 00 50          	add    $0x5000,%ax
  807b14:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807b18:	8b 45 0c             	mov    0xc(%ebp),%eax
  807b1b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807b1e:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807b22:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807b26:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807b2b:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807b2f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807b36:	83 e2 01             	and    $0x1,%edx
  807b39:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807b3c:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807b40:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807b43:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807b47:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807b4b:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807b50:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807b54:	83 ec 0c             	sub    $0xc,%esp
  807b57:	6a 04                	push   $0x4
  807b59:	e8 03 ca ff ff       	call   804561 <memp_malloc>
  807b5e:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807b60:	83 c4 10             	add    $0x10,%esp
  807b63:	85 c0                	test   %eax,%eax
  807b65:	0f 84 e6 02 00 00    	je     807e51 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807b6b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807b71:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807b78:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807b7c:	0f 85 b1 01 00 00    	jne    807d33 <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807b82:	85 f6                	test   %esi,%esi
  807b84:	0f 84 92 01 00 00    	je     807d1c <tcp_enqueue+0x2fa>
      useg->next = seg;
  807b8a:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807b8c:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b90:	0f 84 bc 01 00 00    	je     807d52 <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807b96:	83 ec 04             	sub    $0x4,%esp
  807b99:	6a 00                	push   $0x0
  807b9b:	ff 75 cc             	pushl  -0x34(%ebp)
  807b9e:	6a 00                	push   $0x0
  807ba0:	e8 25 ce ff ff       	call   8049ca <pbuf_alloc>
  807ba5:	89 43 04             	mov    %eax,0x4(%ebx)
  807ba8:	83 c4 10             	add    $0x10,%esp
  807bab:	85 c0                	test   %eax,%eax
  807bad:	0f 84 9e 02 00 00    	je     807e51 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807bb3:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807bb7:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807bbb:	0f 82 7a 01 00 00    	jb     807d3b <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807bc1:	83 ec 0c             	sub    $0xc,%esp
  807bc4:	50                   	push   %eax
  807bc5:	e8 84 d1 ff ff       	call   804d4e <pbuf_clen>
  807bca:	0f b6 c0             	movzbl %al,%eax
  807bcd:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807bd1:	8b 43 04             	mov    0x4(%ebx),%eax
  807bd4:	8b 40 04             	mov    0x4(%eax),%eax
  807bd7:	89 43 08             	mov    %eax,0x8(%ebx)
  807bda:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807bdd:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807be2:	0f 87 69 02 00 00    	ja     807e51 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807be8:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807bec:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807bf0:	83 ec 08             	sub    $0x8,%esp
  807bf3:	6a 14                	push   $0x14
  807bf5:	ff 73 04             	pushl  0x4(%ebx)
  807bf8:	e8 3a cc ff ff       	call   804837 <pbuf_header>
  807bfd:	83 c4 10             	add    $0x10,%esp
  807c00:	84 c0                	test   %al,%al
  807c02:	0f 85 49 02 00 00    	jne    807e51 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807c08:	8b 43 04             	mov    0x4(%ebx),%eax
  807c0b:	8b 70 04             	mov    0x4(%eax),%esi
  807c0e:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807c11:	83 ec 0c             	sub    $0xc,%esp
  807c14:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807c18:	50                   	push   %eax
  807c19:	e8 c0 fb ff ff       	call   8077de <htons>
  807c1e:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807c21:	8b 73 10             	mov    0x10(%ebx),%esi
  807c24:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807c28:	89 04 24             	mov    %eax,(%esp)
  807c2b:	e8 ae fb ff ff       	call   8077de <htons>
  807c30:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807c34:	8b 73 10             	mov    0x10(%ebx),%esi
  807c37:	83 c4 04             	add    $0x4,%esp
  807c3a:	ff 75 d8             	pushl  -0x28(%ebp)
  807c3d:	e8 b6 fb ff ff       	call   8077f8 <htonl>
  807c42:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807c45:	8b 43 10             	mov    0x10(%ebx),%eax
  807c48:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807c4e:	8b 43 10             	mov    0x10(%ebx),%eax
  807c51:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c55:	89 04 24             	mov    %eax,(%esp)
  807c58:	e8 8e fb ff ff       	call   8077eb <ntohs>
  807c5d:	8b 73 10             	mov    0x10(%ebx),%esi
  807c60:	83 e0 c0             	and    $0xffffffc0,%eax
  807c63:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807c67:	09 d0                	or     %edx,%eax
  807c69:	0f b7 c0             	movzwl %ax,%eax
  807c6c:	89 04 24             	mov    %eax,(%esp)
  807c6f:	e8 6a fb ff ff       	call   8077de <htons>
  807c74:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807c78:	83 c4 10             	add    $0x10,%esp
  807c7b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c7f:	0f 84 0f 02 00 00    	je     807e94 <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c85:	83 ec 0c             	sub    $0xc,%esp
  807c88:	8b 43 10             	mov    0x10(%ebx),%eax
  807c8b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c8f:	50                   	push   %eax
  807c90:	e8 56 fb ff ff       	call   8077eb <ntohs>
  807c95:	8b 73 10             	mov    0x10(%ebx),%esi
  807c98:	83 e0 3f             	and    $0x3f,%eax
  807c9b:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807c9f:	0f b7 c0             	movzwl %ax,%eax
  807ca2:	89 04 24             	mov    %eax,(%esp)
  807ca5:	e8 34 fb ff ff       	call   8077de <htons>
  807caa:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807cae:	83 c4 0c             	add    $0xc,%esp
  807cb1:	ff 75 cc             	pushl  -0x34(%ebp)
  807cb4:	ff 75 1c             	pushl  0x1c(%ebp)
  807cb7:	ff 73 08             	pushl  0x8(%ebx)
  807cba:	e8 f5 74 00 00       	call   80f1b4 <memcpy>
  807cbf:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807cc2:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807cc6:	0f b7 c1             	movzwl %cx,%eax
  807cc9:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807ccc:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807ccf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807cd3:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807cd7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807cdb:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807cdd:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807ce1:	0f 85 5c fe ff ff    	jne    807b43 <tcp_enqueue+0x121>
  807ce7:	84 c0                	test   %al,%al
  807ce9:	0f 85 54 fe ff ff    	jne    807b43 <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807cef:	8b 47 74             	mov    0x74(%edi),%eax
  807cf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807cf5:	85 c0                	test   %eax,%eax
  807cf7:	0f 84 c1 03 00 00    	je     8080be <tcp_enqueue+0x69c>
  807cfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807d00:	e9 be 01 00 00       	jmp    807ec3 <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807d05:	83 ec 04             	sub    $0x4,%esp
  807d08:	68 e8 26 81 00       	push   $0x8126e8
  807d0d:	68 b1 00 00 00       	push   $0xb1
  807d12:	68 c6 27 81 00       	push   $0x8127c6
  807d17:	e8 53 6a 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807d1c:	83 ec 04             	sub    $0x4,%esp
  807d1f:	68 de 27 81 00       	push   $0x8127de
  807d24:	68 ce 00 00 00       	push   $0xce
  807d29:	68 c6 27 81 00       	push   $0x8127c6
  807d2e:	e8 3c 6a 00 00       	call   80e76f <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807d33:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807d36:	e9 51 fe ff ff       	jmp    807b8c <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807d3b:	83 ec 04             	sub    $0x4,%esp
  807d3e:	68 1c 27 81 00       	push   $0x81271c
  807d43:	68 df 00 00 00       	push   $0xdf
  807d48:	68 c6 27 81 00       	push   $0x8127c6
  807d4d:	e8 1d 6a 00 00       	call   80e76f <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807d52:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807d56:	74 7f                	je     807dd7 <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807d58:	83 ec 04             	sub    $0x4,%esp
  807d5b:	6a 00                	push   $0x0
  807d5d:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807d61:	0f b7 c6             	movzwl %si,%eax
  807d64:	50                   	push   %eax
  807d65:	6a 00                	push   $0x0
  807d67:	e8 5e cc ff ff       	call   8049ca <pbuf_alloc>
  807d6c:	89 43 04             	mov    %eax,0x4(%ebx)
  807d6f:	83 c4 10             	add    $0x10,%esp
  807d72:	85 c0                	test   %eax,%eax
  807d74:	0f 84 d7 00 00 00    	je     807e51 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d7a:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807d7e:	72 40                	jb     807dc0 <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807d80:	83 ec 0c             	sub    $0xc,%esp
  807d83:	50                   	push   %eax
  807d84:	e8 c5 cf ff ff       	call   804d4e <pbuf_clen>
  807d89:	0f b6 c0             	movzbl %al,%eax
  807d8c:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807d90:	83 c4 10             	add    $0x10,%esp
  807d93:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d97:	74 19                	je     807db2 <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807d99:	83 ec 04             	sub    $0x4,%esp
  807d9c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807da0:	50                   	push   %eax
  807da1:	ff 75 d0             	pushl  -0x30(%ebp)
  807da4:	8b 43 04             	mov    0x4(%ebx),%eax
  807da7:	ff 70 04             	pushl  0x4(%eax)
  807daa:	e8 05 74 00 00       	call   80f1b4 <memcpy>
  807daf:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807db2:	8b 43 04             	mov    0x4(%ebx),%eax
  807db5:	8b 40 04             	mov    0x4(%eax),%eax
  807db8:	89 43 08             	mov    %eax,0x8(%ebx)
  807dbb:	e9 1d fe ff ff       	jmp    807bdd <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807dc0:	83 ec 04             	sub    $0x4,%esp
  807dc3:	68 44 27 81 00       	push   $0x812744
  807dc8:	68 ea 00 00 00       	push   $0xea
  807dcd:	68 c6 27 81 00       	push   $0x8127c6
  807dd2:	e8 98 69 00 00       	call   80e76f <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807dd7:	83 ec 04             	sub    $0x4,%esp
  807dda:	6a 01                	push   $0x1
  807ddc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807de0:	50                   	push   %eax
  807de1:	6a 00                	push   $0x0
  807de3:	e8 e2 cb ff ff       	call   8049ca <pbuf_alloc>
  807de8:	89 c6                	mov    %eax,%esi
  807dea:	83 c4 10             	add    $0x10,%esp
  807ded:	85 c0                	test   %eax,%eax
  807def:	74 60                	je     807e51 <tcp_enqueue+0x42f>
      ++queuelen;
  807df1:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807df5:	83 c0 01             	add    $0x1,%eax
  807df8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807dfc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807dff:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807e02:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807e05:	83 ec 04             	sub    $0x4,%esp
  807e08:	6a 00                	push   $0x0
  807e0a:	6a 00                	push   $0x0
  807e0c:	6a 00                	push   $0x0
  807e0e:	e8 b7 cb ff ff       	call   8049ca <pbuf_alloc>
  807e13:	89 43 04             	mov    %eax,0x4(%ebx)
  807e16:	83 c4 10             	add    $0x10,%esp
  807e19:	85 c0                	test   %eax,%eax
  807e1b:	74 28                	je     807e45 <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807e1d:	83 ec 0c             	sub    $0xc,%esp
  807e20:	50                   	push   %eax
  807e21:	e8 28 cf ff ff       	call   804d4e <pbuf_clen>
  807e26:	0f b6 c0             	movzbl %al,%eax
  807e29:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807e2d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807e31:	83 c4 08             	add    $0x8,%esp
  807e34:	56                   	push   %esi
  807e35:	ff 73 04             	pushl  0x4(%ebx)
  807e38:	e8 3a cf ff ff       	call   804d77 <pbuf_cat>
  807e3d:	83 c4 10             	add    $0x10,%esp
  807e40:	e9 98 fd ff ff       	jmp    807bdd <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807e45:	83 ec 0c             	sub    $0xc,%esp
  807e48:	56                   	push   %esi
  807e49:	e8 b6 ca ff ff       	call   804904 <pbuf_free>
        goto memerr;
  807e4e:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807e51:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807e55:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807e58:	85 c0                	test   %eax,%eax
  807e5a:	74 0c                	je     807e68 <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807e5c:	83 ec 0c             	sub    $0xc,%esp
  807e5f:	50                   	push   %eax
  807e60:	e8 f6 d9 ff ff       	call   80585b <tcp_segs_free>
  807e65:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807e68:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807e6d:	0f 84 37 02 00 00    	je     8080aa <tcp_enqueue+0x688>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807e73:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807e77:	0f 85 37 02 00 00    	jne    8080b4 <tcp_enqueue+0x692>
  807e7d:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e81:	0f 84 02 02 00 00    	je     808089 <tcp_enqueue+0x667>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807e87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807e8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807e8f:	5b                   	pop    %ebx
  807e90:	5e                   	pop    %esi
  807e91:	5f                   	pop    %edi
  807e92:	5d                   	pop    %ebp
  807e93:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807e94:	83 ec 0c             	sub    $0xc,%esp
  807e97:	8b 43 10             	mov    0x10(%ebx),%eax
  807e9a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e9e:	50                   	push   %eax
  807e9f:	e8 47 f9 ff ff       	call   8077eb <ntohs>
  807ea4:	8b 73 10             	mov    0x10(%ebx),%esi
  807ea7:	83 e0 3f             	and    $0x3f,%eax
  807eaa:	80 cc 50             	or     $0x50,%ah
  807ead:	89 04 24             	mov    %eax,(%esp)
  807eb0:	e8 29 f9 ff ff       	call   8077de <htons>
  807eb5:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807eb9:	83 c4 10             	add    $0x10,%esp
  807ebc:	e9 01 fe ff ff       	jmp    807cc2 <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807ec1:	89 f0                	mov    %esi,%eax
  807ec3:	8b 30                	mov    (%eax),%esi
  807ec5:	85 f6                	test   %esi,%esi
  807ec7:	75 f8                	jne    807ec1 <tcp_enqueue+0x49f>
  807ec9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  807ecc:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807ed0:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807ed4:	83 ec 0c             	sub    $0xc,%esp
  807ed7:	8b 40 10             	mov    0x10(%eax),%eax
  807eda:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ede:	50                   	push   %eax
  807edf:	e8 07 f9 ff ff       	call   8077eb <ntohs>
  807ee4:	83 c4 10             	add    $0x10,%esp
  807ee7:	a8 01                	test   $0x1,%al
  807ee9:	0f 84 96 00 00 00    	je     807f85 <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807eef:	83 ec 0c             	sub    $0xc,%esp
  807ef2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ef5:	8b 40 10             	mov    0x10(%eax),%eax
  807ef8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807efc:	50                   	push   %eax
  807efd:	e8 e9 f8 ff ff       	call   8077eb <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807f02:	83 c4 10             	add    $0x10,%esp
  807f05:	a8 03                	test   $0x3,%al
  807f07:	0f 85 a0 00 00 00    	jne    807fad <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807f0d:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807f11:	0f 85 96 00 00 00    	jne    807fad <tcp_enqueue+0x58b>
    useg->len + queue->len <= pcb->mss) {
  807f17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f1a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f1e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f21:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807f25:	01 d0                	add    %edx,%eax
  807f27:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807f2b:	39 d0                	cmp    %edx,%eax
  807f2d:	7f 7e                	jg     807fad <tcp_enqueue+0x58b>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807f2f:	83 ec 08             	sub    $0x8,%esp
  807f32:	6a ec                	push   $0xffffffec
  807f34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807f37:	ff 70 04             	pushl  0x4(%eax)
  807f3a:	e8 f8 c8 ff ff       	call   804837 <pbuf_header>
  807f3f:	83 c4 10             	add    $0x10,%esp
  807f42:	84 c0                	test   %al,%al
  807f44:	0f 85 0b 01 00 00    	jne    808055 <tcp_enqueue+0x633>
    pbuf_cat(useg->p, queue->p);
  807f4a:	83 ec 08             	sub    $0x8,%esp
  807f4d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f50:	ff 72 04             	pushl  0x4(%edx)
  807f53:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f56:	ff 71 04             	pushl  0x4(%ecx)
  807f59:	e8 19 ce ff ff       	call   804d77 <pbuf_cat>
    useg->len += queue->len;
  807f5e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f61:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f65:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807f68:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807f6c:	8b 02                	mov    (%edx),%eax
  807f6e:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  807f70:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807f73:	39 da                	cmp    %ebx,%edx
  807f75:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  807f78:	52                   	push   %edx
  807f79:	6a 04                	push   $0x4
  807f7b:	e8 37 c6 ff ff       	call   8045b7 <memp_free>
  807f80:	83 c4 10             	add    $0x10,%esp
  807f83:	eb 49                	jmp    807fce <tcp_enqueue+0x5ac>
    TCP_TCPLEN(useg) != 0 &&
  807f85:	83 ec 0c             	sub    $0xc,%esp
  807f88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f8b:	8b 40 10             	mov    0x10(%eax),%eax
  807f8e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f92:	50                   	push   %eax
  807f93:	e8 53 f8 ff ff       	call   8077eb <ntohs>
  807f98:	66 d1 e8             	shr    %ax
  807f9b:	83 e0 01             	and    $0x1,%eax
  807f9e:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  807fa2:	83 c4 10             	add    $0x10,%esp
  807fa5:	01 d0                	add    %edx,%eax
  807fa7:	0f 85 42 ff ff ff    	jne    807eef <tcp_enqueue+0x4cd>
      useg->next = queue;
  807fad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807fb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807fb3:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807fb5:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807fb9:	83 e2 03             	and    $0x3,%edx
    ++len;
  807fbc:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807fc0:	83 c0 01             	add    $0x1,%eax
  807fc3:	84 d2                	test   %dl,%dl
  807fc5:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807fca:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  807fce:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807fd2:	74 04                	je     807fd8 <tcp_enqueue+0x5b6>
    pcb->flags |= TF_FIN;
  807fd4:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807fd8:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807fdc:	0f b7 c2             	movzwl %dx,%eax
  807fdf:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807fe2:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807fe6:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807fea:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807fee:	66 85 c0             	test   %ax,%ax
  807ff1:	74 06                	je     807ff9 <tcp_enqueue+0x5d7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ff3:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ff7:	74 73                	je     80806c <tcp_enqueue+0x64a>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ff9:	85 db                	test   %ebx,%ebx
  807ffb:	0f 84 9f 00 00 00    	je     8080a0 <tcp_enqueue+0x67e>
  808001:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  808006:	0f 84 94 00 00 00    	je     8080a0 <tcp_enqueue+0x67e>
  80800c:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  80800f:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808014:	85 d2                	test   %edx,%edx
  808016:	0f 84 70 fe ff ff    	je     807e8c <tcp_enqueue+0x46a>
  80801c:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  808020:	0f 85 66 fe ff ff    	jne    807e8c <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  808026:	83 ec 0c             	sub    $0xc,%esp
  808029:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80802d:	50                   	push   %eax
  80802e:	e8 b8 f7 ff ff       	call   8077eb <ntohs>
  808033:	8b 5b 10             	mov    0x10(%ebx),%ebx
  808036:	83 c8 08             	or     $0x8,%eax
  808039:	0f b7 c0             	movzwl %ax,%eax
  80803c:	89 04 24             	mov    %eax,(%esp)
  80803f:	e8 9a f7 ff ff       	call   8077de <htons>
  808044:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  808048:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  80804b:	b8 00 00 00 00       	mov    $0x0,%eax
  808050:	e9 37 fe ff ff       	jmp    807e8c <tcp_enqueue+0x46a>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808055:	83 ec 04             	sub    $0x4,%esp
  808058:	68 eb 27 81 00       	push   $0x8127eb
  80805d:	68 52 01 00 00       	push   $0x152
  808062:	68 c6 27 81 00       	push   $0x8127c6
  808067:	e8 03 67 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80806c:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808070:	75 87                	jne    807ff9 <tcp_enqueue+0x5d7>
  808072:	83 ec 04             	sub    $0x4,%esp
  808075:	68 78 27 81 00       	push   $0x812778
  80807a:	68 7a 01 00 00       	push   $0x17a
  80807f:	68 c6 27 81 00       	push   $0x8127c6
  808084:	e8 e6 66 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808089:	83 ec 04             	sub    $0x4,%esp
  80808c:	68 78 27 81 00       	push   $0x812778
  808091:	68 8d 01 00 00       	push   $0x18d
  808096:	68 c6 27 81 00       	push   $0x8127c6
  80809b:	e8 cf 66 00 00       	call   80e76f <_panic>
  return ERR_OK;
  8080a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8080a5:	e9 e2 fd ff ff       	jmp    807e8c <tcp_enqueue+0x46a>
  return ERR_MEM;
  8080aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080af:	e9 d8 fd ff ff       	jmp    807e8c <tcp_enqueue+0x46a>
  8080b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080b9:	e9 ce fd ff ff       	jmp    807e8c <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  8080be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8080c1:	89 47 74             	mov    %eax,0x74(%edi)
  8080c4:	e9 ec fe ff ff       	jmp    807fb5 <tcp_enqueue+0x593>

008080c9 <tcp_send_ctrl>:
{
  8080c9:	55                   	push   %ebp
  8080ca:	89 e5                	mov    %esp,%ebp
  8080cc:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8080cf:	6a 00                	push   $0x0
  8080d1:	6a 00                	push   $0x0
  8080d3:	6a 01                	push   $0x1
  8080d5:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  8080d9:	50                   	push   %eax
  8080da:	6a 00                	push   $0x0
  8080dc:	6a 00                	push   $0x0
  8080de:	ff 75 08             	pushl  0x8(%ebp)
  8080e1:	e8 3c f9 ff ff       	call   807a22 <tcp_enqueue>
}
  8080e6:	c9                   	leave  
  8080e7:	c3                   	ret    

008080e8 <tcp_write>:
{
  8080e8:	55                   	push   %ebp
  8080e9:	89 e5                	mov    %esp,%ebp
  8080eb:	56                   	push   %esi
  8080ec:	53                   	push   %ebx
  8080ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8080f0:	8b 55 10             	mov    0x10(%ebp),%edx
  8080f3:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  8080f6:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  8080f9:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  8080fc:	83 fb 02             	cmp    $0x2,%ebx
  8080ff:	76 05                	jbe    808106 <tcp_write+0x1e>
  808101:	83 f8 07             	cmp    $0x7,%eax
  808104:	75 32                	jne    808138 <tcp_write+0x50>
    return ERR_OK;
  808106:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  80810b:	66 85 d2             	test   %dx,%dx
  80810e:	75 07                	jne    808117 <tcp_write+0x2f>
}
  808110:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808113:	5b                   	pop    %ebx
  808114:	5e                   	pop    %esi
  808115:	5d                   	pop    %ebp
  808116:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  808117:	83 ec 04             	sub    $0x4,%esp
  80811a:	6a 00                	push   $0x0
  80811c:	6a 00                	push   $0x0
  80811e:	89 f0                	mov    %esi,%eax
  808120:	0f b6 f0             	movzbl %al,%esi
  808123:	56                   	push   %esi
  808124:	6a 00                	push   $0x0
  808126:	0f b7 d2             	movzwl %dx,%edx
  808129:	52                   	push   %edx
  80812a:	ff 75 0c             	pushl  0xc(%ebp)
  80812d:	51                   	push   %ecx
  80812e:	e8 ef f8 ff ff       	call   807a22 <tcp_enqueue>
  808133:	83 c4 20             	add    $0x20,%esp
  808136:	eb d8                	jmp    808110 <tcp_write+0x28>
    return ERR_CONN;
  808138:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80813d:	eb d1                	jmp    808110 <tcp_write+0x28>

0080813f <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80813f:	55                   	push   %ebp
  808140:	89 e5                	mov    %esp,%ebp
  808142:	57                   	push   %edi
  808143:	56                   	push   %esi
  808144:	53                   	push   %ebx
  808145:	83 ec 1c             	sub    $0x1c,%esp
  808148:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80814b:	39 3d 58 c2 b3 00    	cmp    %edi,0xb3c258
  808151:	0f 84 60 04 00 00    	je     8085b7 <tcp_output+0x478>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808157:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80815b:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80815f:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808164:	0f b7 c0             	movzwl %ax,%eax
  808167:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80816a:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80816d:	8b 47 78             	mov    0x78(%edi),%eax
  808170:	89 45 dc             	mov    %eax,-0x24(%ebp)
  808173:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  808176:	85 c0                	test   %eax,%eax
  808178:	75 04                	jne    80817e <tcp_output+0x3f>
  80817a:	eb 0b                	jmp    808187 <tcp_output+0x48>
    for (; useg->next != NULL; useg = useg->next);
  80817c:	89 c2                	mov    %eax,%edx
  80817e:	8b 02                	mov    (%edx),%eax
  808180:	85 c0                	test   %eax,%eax
  808182:	75 f8                	jne    80817c <tcp_output+0x3d>
  808184:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808187:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80818b:	0f 84 e6 03 00 00    	je     808577 <tcp_output+0x438>
  808191:	85 db                	test   %ebx,%ebx
  808193:	74 23                	je     8081b8 <tcp_output+0x79>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808195:	83 ec 0c             	sub    $0xc,%esp
  808198:	8b 43 10             	mov    0x10(%ebx),%eax
  80819b:	ff 70 04             	pushl  0x4(%eax)
  80819e:	e8 6c f8 ff ff       	call   807a0f <ntohl>
  8081a3:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8081a7:	2b 57 48             	sub    0x48(%edi),%edx
  8081aa:	01 c2                	add    %eax,%edx
     (seg == NULL ||
  8081ac:	83 c4 10             	add    $0x10,%esp
  8081af:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  8081b2:	0f 86 bf 03 00 00    	jbe    808577 <tcp_output+0x438>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8081b8:	83 ec 04             	sub    $0x4,%esp
  8081bb:	6a 00                	push   $0x0
  8081bd:	6a 14                	push   $0x14
  8081bf:	6a 01                	push   $0x1
  8081c1:	e8 04 c8 ff ff       	call   8049ca <pbuf_alloc>
  8081c6:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8081c8:	83 c4 10             	add    $0x10,%esp
  8081cb:	85 c0                	test   %eax,%eax
  8081cd:	0f 84 eb 03 00 00    	je     8085be <tcp_output+0x47f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081d3:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  8081d7:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8081da:	83 ec 0c             	sub    $0xc,%esp
  8081dd:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8081e1:	50                   	push   %eax
  8081e2:	e8 f7 f5 ff ff       	call   8077de <htons>
  8081e7:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8081ea:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8081ee:	89 04 24             	mov    %eax,(%esp)
  8081f1:	e8 e8 f5 ff ff       	call   8077de <htons>
  8081f6:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8081fa:	83 c4 04             	add    $0x4,%esp
  8081fd:	ff 77 54             	pushl  0x54(%edi)
  808200:	e8 f3 f5 ff ff       	call   8077f8 <htonl>
  808205:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808208:	83 c4 04             	add    $0x4,%esp
  80820b:	ff 77 24             	pushl  0x24(%edi)
  80820e:	e8 e5 f5 ff ff       	call   8077f8 <htonl>
  808213:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808216:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80821a:	89 04 24             	mov    %eax,(%esp)
  80821d:	e8 c9 f5 ff ff       	call   8077eb <ntohs>
  808222:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808227:	83 c8 10             	or     $0x10,%eax
  80822a:	89 04 24             	mov    %eax,(%esp)
  80822d:	e8 ac f5 ff ff       	call   8077de <htons>
  808232:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808236:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80823a:	89 04 24             	mov    %eax,(%esp)
  80823d:	e8 9c f5 ff ff       	call   8077de <htons>
  808242:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808246:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80824c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808250:	89 04 24             	mov    %eax,(%esp)
  808253:	e8 93 f5 ff ff       	call   8077eb <ntohs>
  808258:	83 e0 3f             	and    $0x3f,%eax
  80825b:	80 cc 50             	or     $0x50,%ah
  80825e:	89 04 24             	mov    %eax,(%esp)
  808261:	e8 78 f5 ff ff       	call   8077de <htons>
  808266:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80826a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808270:	8d 47 04             	lea    0x4(%edi),%eax
  808273:	89 c1                	mov    %eax,%ecx
  808275:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808279:	89 04 24             	mov    %eax,(%esp)
  80827c:	6a 06                	push   $0x6
  80827e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808281:	51                   	push   %ecx
  808282:	57                   	push   %edi
  808283:	56                   	push   %esi
  808284:	e8 31 f2 ff ff       	call   8074ba <inet_chksum_pseudo>
  808289:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80828d:	83 c4 18             	add    $0x18,%esp
  808290:	6a 06                	push   $0x6
  808292:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808296:	50                   	push   %eax
  808297:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80829b:	50                   	push   %eax
  80829c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80829f:	57                   	push   %edi
  8082a0:	56                   	push   %esi
  8082a1:	e8 28 e8 ff ff       	call   806ace <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  8082a6:	83 c4 14             	add    $0x14,%esp
  8082a9:	56                   	push   %esi
  8082aa:	e8 55 c6 ff ff       	call   804904 <pbuf_free>

    return ERR_OK;
  8082af:	83 c4 10             	add    $0x10,%esp
  8082b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8082b7:	e9 1b 03 00 00       	jmp    8085d7 <tcp_output+0x498>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8082bc:	83 ec 04             	sub    $0x4,%esp
  8082bf:	68 ff 27 81 00       	push   $0x8127ff
  8082c4:	68 05 02 00 00       	push   $0x205
  8082c9:	68 c6 27 81 00       	push   $0x8127c6
  8082ce:	e8 9c 64 00 00       	call   80e76f <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8082d3:	83 ec 0c             	sub    $0xc,%esp
  8082d6:	8b 43 10             	mov    0x10(%ebx),%eax
  8082d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082dd:	50                   	push   %eax
  8082de:	e8 08 f5 ff ff       	call   8077eb <ntohs>
  8082e3:	8b 73 10             	mov    0x10(%ebx),%esi
  8082e6:	83 c8 10             	or     $0x10,%eax
  8082e9:	0f b7 c0             	movzwl %ax,%eax
  8082ec:	89 04 24             	mov    %eax,(%esp)
  8082ef:	e8 ea f4 ff ff       	call   8077de <htons>
  8082f4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8082f8:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8082fc:	83 c4 10             	add    $0x10,%esp
  8082ff:	e9 06 01 00 00       	jmp    80840a <tcp_output+0x2cb>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  808304:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  80830a:	e9 49 01 00 00       	jmp    808458 <tcp_output+0x319>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  80830f:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  808314:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808317:	83 ec 0c             	sub    $0xc,%esp
  80831a:	8b 43 10             	mov    0x10(%ebx),%eax
  80831d:	ff 70 04             	pushl  0x4(%eax)
  808320:	e8 ea f6 ff ff       	call   807a0f <ntohl>
  808325:	89 47 3c             	mov    %eax,0x3c(%edi)
  808328:	83 c4 10             	add    $0x10,%esp
  80832b:	e9 32 01 00 00       	jmp    808462 <tcp_output+0x323>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808330:	83 ec 0c             	sub    $0xc,%esp
  808333:	8b 43 10             	mov    0x10(%ebx),%eax
  808336:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80833a:	50                   	push   %eax
  80833b:	e8 ab f4 ff ff       	call   8077eb <ntohs>
  808340:	66 d1 e8             	shr    %ax
  808343:	89 c2                	mov    %eax,%edx
  808345:	83 e2 01             	and    $0x1,%edx
  808348:	83 c4 10             	add    $0x10,%esp
  80834b:	e9 a5 01 00 00       	jmp    8084f5 <tcp_output+0x3b6>
      pcb->snd_max = pcb->snd_nxt;
  808350:	89 77 58             	mov    %esi,0x58(%edi)
  808353:	e9 ae 01 00 00       	jmp    808506 <tcp_output+0x3c7>
    if (TCP_TCPLEN(seg) > 0) {
  808358:	83 ec 0c             	sub    $0xc,%esp
  80835b:	8b 43 10             	mov    0x10(%ebx),%eax
  80835e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808362:	50                   	push   %eax
  808363:	e8 83 f4 ff ff       	call   8077eb <ntohs>
  808368:	66 d1 e8             	shr    %ax
  80836b:	83 e0 01             	and    $0x1,%eax
  80836e:	0f b7 f6             	movzwl %si,%esi
  808371:	83 c4 10             	add    $0x10,%esp
  808374:	01 f0                	add    %esi,%eax
  808376:	0f 85 a9 01 00 00    	jne    808525 <tcp_output+0x3e6>
      tcp_seg_free(seg);
  80837c:	83 ec 0c             	sub    $0xc,%esp
  80837f:	53                   	push   %ebx
  808380:	e8 99 d4 ff ff       	call   80581e <tcp_seg_free>
  808385:	83 c4 10             	add    $0x10,%esp
  808388:	eb 06                	jmp    808390 <tcp_output+0x251>
        pcb->unacked = seg;
  80838a:	89 5f 78             	mov    %ebx,0x78(%edi)
  80838d:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808390:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808393:	85 db                	test   %ebx,%ebx
  808395:	0f 84 33 02 00 00    	je     8085ce <tcp_output+0x48f>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80839b:	83 ec 0c             	sub    $0xc,%esp
  80839e:	8b 43 10             	mov    0x10(%ebx),%eax
  8083a1:	ff 70 04             	pushl  0x4(%eax)
  8083a4:	e8 66 f6 ff ff       	call   807a0f <ntohl>
  8083a9:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8083ad:	2b 57 48             	sub    0x48(%edi),%edx
  8083b0:	01 c2                	add    %eax,%edx
  while (seg != NULL &&
  8083b2:	83 c4 10             	add    $0x10,%esp
  8083b5:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  8083b8:	0f 87 07 02 00 00    	ja     8085c5 <tcp_output+0x486>
    LWIP_ASSERT("RST not expected here!", 
  8083be:	83 ec 0c             	sub    $0xc,%esp
  8083c1:	8b 43 10             	mov    0x10(%ebx),%eax
  8083c4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083c8:	50                   	push   %eax
  8083c9:	e8 1d f4 ff ff       	call   8077eb <ntohs>
  8083ce:	83 c4 10             	add    $0x10,%esp
  8083d1:	a8 04                	test   $0x4,%al
  8083d3:	0f 85 e3 fe ff ff    	jne    8082bc <tcp_output+0x17d>
    if((tcp_do_output_nagle(pcb) == 0) &&
  8083d9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8083dd:	74 1c                	je     8083fb <tcp_output+0x2bc>
  8083df:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8083e3:	a8 40                	test   $0x40,%al
  8083e5:	75 14                	jne    8083fb <tcp_output+0x2bc>
  8083e7:	8b 57 74             	mov    0x74(%edi),%edx
  8083ea:	85 d2                	test   %edx,%edx
  8083ec:	74 05                	je     8083f3 <tcp_output+0x2b4>
  8083ee:	83 3a 00             	cmpl   $0x0,(%edx)
  8083f1:	75 08                	jne    8083fb <tcp_output+0x2bc>
  8083f3:	a8 a0                	test   $0xa0,%al
  8083f5:	0f 84 ca 01 00 00    	je     8085c5 <tcp_output+0x486>
    pcb->unsent = seg->next;
  8083fb:	8b 03                	mov    (%ebx),%eax
  8083fd:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  808400:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  808404:	0f 85 c9 fe ff ff    	jne    8082d3 <tcp_output+0x194>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80840a:	8b 73 10             	mov    0x10(%ebx),%esi
  80840d:	83 ec 0c             	sub    $0xc,%esp
  808410:	ff 77 24             	pushl  0x24(%edi)
  808413:	e8 e0 f3 ff ff       	call   8077f8 <htonl>
  808418:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80841b:	8b 73 10             	mov    0x10(%ebx),%esi
  80841e:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808422:	89 04 24             	mov    %eax,(%esp)
  808425:	e8 b4 f3 ff ff       	call   8077de <htons>
  80842a:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  80842e:	83 c4 10             	add    $0x10,%esp
  808431:	83 3f 00             	cmpl   $0x0,(%edi)
  808434:	75 17                	jne    80844d <tcp_output+0x30e>
    netif = ip_route(&(pcb->remote_ip));
  808436:	83 ec 0c             	sub    $0xc,%esp
  808439:	ff 75 e4             	pushl  -0x1c(%ebp)
  80843c:	e8 7d e1 ff ff       	call   8065be <ip_route>
    if (netif == NULL) {
  808441:	83 c4 10             	add    $0x10,%esp
  808444:	85 c0                	test   %eax,%eax
  808446:	74 79                	je     8084c1 <tcp_output+0x382>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808448:	8b 40 04             	mov    0x4(%eax),%eax
  80844b:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  80844d:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808452:	0f 84 ac fe ff ff    	je     808304 <tcp_output+0x1c5>
  if (pcb->rttest == 0) {
  808458:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80845c:	0f 84 ad fe ff ff    	je     80830f <tcp_output+0x1d0>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808462:	8b 53 04             	mov    0x4(%ebx),%edx
  808465:	8b 43 10             	mov    0x10(%ebx),%eax
  808468:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80846b:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80846f:	8b 53 04             	mov    0x4(%ebx),%edx
  808472:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808476:	8b 53 04             	mov    0x4(%ebx),%edx
  808479:	8b 43 10             	mov    0x10(%ebx),%eax
  80847c:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80847f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808485:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808488:	8b 73 10             	mov    0x10(%ebx),%esi
  80848b:	83 ec 0c             	sub    $0xc,%esp
  80848e:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808492:	52                   	push   %edx
  808493:	6a 06                	push   $0x6
  808495:	ff 75 e4             	pushl  -0x1c(%ebp)
  808498:	57                   	push   %edi
  808499:	50                   	push   %eax
  80849a:	e8 1b f0 ff ff       	call   8074ba <inet_chksum_pseudo>
  80849f:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8084a3:	83 c4 18             	add    $0x18,%esp
  8084a6:	6a 06                	push   $0x6
  8084a8:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  8084ac:	50                   	push   %eax
  8084ad:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8084b1:	50                   	push   %eax
  8084b2:	ff 75 e4             	pushl  -0x1c(%ebp)
  8084b5:	57                   	push   %edi
  8084b6:	ff 73 04             	pushl  0x4(%ebx)
  8084b9:	e8 10 e6 ff ff       	call   806ace <ip_output>
  8084be:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8084c1:	83 ec 0c             	sub    $0xc,%esp
  8084c4:	8b 43 10             	mov    0x10(%ebx),%eax
  8084c7:	ff 70 04             	pushl  0x4(%eax)
  8084ca:	e8 40 f5 ff ff       	call   807a0f <ntohl>
  8084cf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8084d2:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8084d6:	8b 43 10             	mov    0x10(%ebx),%eax
  8084d9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084dd:	89 04 24             	mov    %eax,(%esp)
  8084e0:	e8 06 f3 ff ff       	call   8077eb <ntohs>
  8084e5:	83 c4 10             	add    $0x10,%esp
  8084e8:	ba 01 00 00 00       	mov    $0x1,%edx
  8084ed:	a8 01                	test   $0x1,%al
  8084ef:	0f 84 3b fe ff ff    	je     808330 <tcp_output+0x1f1>
  8084f5:	01 d6                	add    %edx,%esi
  8084f7:	03 75 e0             	add    -0x20(%ebp),%esi
  8084fa:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8084fd:	39 77 58             	cmp    %esi,0x58(%edi)
  808500:	0f 88 4a fe ff ff    	js     808350 <tcp_output+0x211>
    if (TCP_TCPLEN(seg) > 0) {
  808506:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80850a:	83 ec 0c             	sub    $0xc,%esp
  80850d:	8b 43 10             	mov    0x10(%ebx),%eax
  808510:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808514:	50                   	push   %eax
  808515:	e8 d1 f2 ff ff       	call   8077eb <ntohs>
  80851a:	83 c4 10             	add    $0x10,%esp
  80851d:	a8 01                	test   $0x1,%al
  80851f:	0f 84 33 fe ff ff    	je     808358 <tcp_output+0x219>
      seg->next = NULL;
  808525:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  80852b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80852f:	0f 84 55 fe ff ff    	je     80838a <tcp_output+0x24b>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808535:	83 ec 0c             	sub    $0xc,%esp
  808538:	8b 43 10             	mov    0x10(%ebx),%eax
  80853b:	ff 70 04             	pushl  0x4(%eax)
  80853e:	e8 cc f4 ff ff       	call   807a0f <ntohl>
  808543:	89 c6                	mov    %eax,%esi
  808545:	83 c4 04             	add    $0x4,%esp
  808548:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80854b:	8b 40 10             	mov    0x10(%eax),%eax
  80854e:	ff 70 04             	pushl  0x4(%eax)
  808551:	e8 b9 f4 ff ff       	call   807a0f <ntohl>
  808556:	83 c4 10             	add    $0x10,%esp
  808559:	39 c6                	cmp    %eax,%esi
  80855b:	78 0d                	js     80856a <tcp_output+0x42b>
          useg->next = seg;
  80855d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808560:	89 18                	mov    %ebx,(%eax)
  808562:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808565:	e9 26 fe ff ff       	jmp    808390 <tcp_output+0x251>
          seg->next = pcb->unacked;
  80856a:	8b 47 78             	mov    0x78(%edi),%eax
  80856d:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80856f:	89 5f 78             	mov    %ebx,0x78(%edi)
  808572:	e9 19 fe ff ff       	jmp    808390 <tcp_output+0x251>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808577:	8d 47 04             	lea    0x4(%edi),%eax
  80857a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80857d:	e9 11 fe ff ff       	jmp    808393 <tcp_output+0x254>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808582:	83 ec 0c             	sub    $0xc,%esp
  808585:	8b 43 10             	mov    0x10(%ebx),%eax
  808588:	ff 70 04             	pushl  0x4(%eax)
  80858b:	e8 7f f4 ff ff       	call   807a0f <ntohl>
  808590:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808594:	2b 57 48             	sub    0x48(%edi),%edx
  808597:	01 c2                	add    %eax,%edx
  808599:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80859d:	83 c4 10             	add    $0x10,%esp
  8085a0:	39 c2                	cmp    %eax,%edx
  8085a2:	76 2a                	jbe    8085ce <tcp_output+0x48f>
    pcb->persist_cnt = 0;
  8085a4:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  8085ab:	00 00 00 
    pcb->persist_backoff = 1;
  8085ae:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  8085b5:	eb 17                	jmp    8085ce <tcp_output+0x48f>
    return ERR_OK;
  8085b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8085bc:	eb 19                	jmp    8085d7 <tcp_output+0x498>
      return ERR_BUF;
  8085be:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8085c3:	eb 12                	jmp    8085d7 <tcp_output+0x498>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  8085c5:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8085cc:	74 b4                	je     808582 <tcp_output+0x443>
  pcb->flags &= ~TF_NAGLEMEMERR;
  8085ce:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8085d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8085d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8085da:	5b                   	pop    %ebx
  8085db:	5e                   	pop    %esi
  8085dc:	5f                   	pop    %edi
  8085dd:	5d                   	pop    %ebp
  8085de:	c3                   	ret    

008085df <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8085df:	55                   	push   %ebp
  8085e0:	89 e5                	mov    %esp,%ebp
  8085e2:	57                   	push   %edi
  8085e3:	56                   	push   %esi
  8085e4:	53                   	push   %ebx
  8085e5:	83 ec 20             	sub    $0x20,%esp
  8085e8:	8b 7d 18             	mov    0x18(%ebp),%edi
  8085eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8085ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8085f1:	6a 00                	push   $0x0
  8085f3:	6a 14                	push   $0x14
  8085f5:	6a 01                	push   $0x1
  8085f7:	e8 ce c3 ff ff       	call   8049ca <pbuf_alloc>
  if (p == NULL) {
  8085fc:	83 c4 10             	add    $0x10,%esp
  8085ff:	85 c0                	test   %eax,%eax
  808601:	0f 84 e2 00 00 00    	je     8086e9 <tcp_rst+0x10a>
  808607:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808609:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80860e:	0f 86 dd 00 00 00    	jbe    8086f1 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808614:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808617:	83 ec 0c             	sub    $0xc,%esp
  80861a:	0f b7 ff             	movzwl %di,%edi
  80861d:	57                   	push   %edi
  80861e:	e8 bb f1 ff ff       	call   8077de <htons>
  808623:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808626:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80862a:	89 04 24             	mov    %eax,(%esp)
  80862d:	e8 ac f1 ff ff       	call   8077de <htons>
  808632:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808636:	83 c4 04             	add    $0x4,%esp
  808639:	ff 75 08             	pushl  0x8(%ebp)
  80863c:	e8 b7 f1 ff ff       	call   8077f8 <htonl>
  808641:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808644:	83 c4 04             	add    $0x4,%esp
  808647:	ff 75 0c             	pushl  0xc(%ebp)
  80864a:	e8 a9 f1 ff ff       	call   8077f8 <htonl>
  80864f:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808652:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808656:	89 04 24             	mov    %eax,(%esp)
  808659:	e8 8d f1 ff ff       	call   8077eb <ntohs>
  80865e:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808663:	83 c8 14             	or     $0x14,%eax
  808666:	89 04 24             	mov    %eax,(%esp)
  808669:	e8 70 f1 ff ff       	call   8077de <htons>
  80866e:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808672:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808679:	e8 60 f1 ff ff       	call   8077de <htons>
  80867e:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808682:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808688:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80868c:	89 04 24             	mov    %eax,(%esp)
  80868f:	e8 57 f1 ff ff       	call   8077eb <ntohs>
  808694:	83 e0 3f             	and    $0x3f,%eax
  808697:	80 cc 50             	or     $0x50,%ah
  80869a:	89 04 24             	mov    %eax,(%esp)
  80869d:	e8 3c f1 ff ff       	call   8077de <htons>
  8086a2:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  8086a6:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  8086ac:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8086b0:	89 04 24             	mov    %eax,(%esp)
  8086b3:	6a 06                	push   $0x6
  8086b5:	ff 75 14             	pushl  0x14(%ebp)
  8086b8:	ff 75 10             	pushl  0x10(%ebp)
  8086bb:	56                   	push   %esi
  8086bc:	e8 f9 ed ff ff       	call   8074ba <inet_chksum_pseudo>
  8086c1:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8086c5:	83 c4 18             	add    $0x18,%esp
  8086c8:	6a 06                	push   $0x6
  8086ca:	6a 00                	push   $0x0
  8086cc:	68 ff 00 00 00       	push   $0xff
  8086d1:	ff 75 14             	pushl  0x14(%ebp)
  8086d4:	ff 75 10             	pushl  0x10(%ebp)
  8086d7:	56                   	push   %esi
  8086d8:	e8 f1 e3 ff ff       	call   806ace <ip_output>
  pbuf_free(p);
  8086dd:	83 c4 14             	add    $0x14,%esp
  8086e0:	56                   	push   %esi
  8086e1:	e8 1e c2 ff ff       	call   804904 <pbuf_free>
  8086e6:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8086e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8086ec:	5b                   	pop    %ebx
  8086ed:	5e                   	pop    %esi
  8086ee:	5f                   	pop    %edi
  8086ef:	5d                   	pop    %ebp
  8086f0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086f1:	83 ec 04             	sub    $0x4,%esp
  8086f4:	68 98 27 81 00       	push   $0x812798
  8086f9:	68 be 02 00 00       	push   $0x2be
  8086fe:	68 c6 27 81 00       	push   $0x8127c6
  808703:	e8 67 60 00 00       	call   80e76f <_panic>

00808708 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808708:	55                   	push   %ebp
  808709:	89 e5                	mov    %esp,%ebp
  80870b:	53                   	push   %ebx
  80870c:	83 ec 04             	sub    $0x4,%esp
  80870f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808712:	8b 53 78             	mov    0x78(%ebx),%edx
  808715:	85 d2                	test   %edx,%edx
  808717:	75 04                	jne    80871d <tcp_rexmit_rto+0x15>
  808719:	eb 41                	jmp    80875c <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80871b:	89 c2                	mov    %eax,%edx
  80871d:	8b 02                	mov    (%edx),%eax
  80871f:	85 c0                	test   %eax,%eax
  808721:	75 f8                	jne    80871b <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808723:	8b 43 74             	mov    0x74(%ebx),%eax
  808726:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808728:	8b 43 78             	mov    0x78(%ebx),%eax
  80872b:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80872e:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808735:	83 ec 0c             	sub    $0xc,%esp
  808738:	8b 40 10             	mov    0x10(%eax),%eax
  80873b:	ff 70 04             	pushl  0x4(%eax)
  80873e:	e8 cc f2 ff ff       	call   807a0f <ntohl>
  808743:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808746:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80874a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808751:	89 1c 24             	mov    %ebx,(%esp)
  808754:	e8 e6 f9 ff ff       	call   80813f <tcp_output>
  808759:	83 c4 10             	add    $0x10,%esp
}
  80875c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80875f:	c9                   	leave  
  808760:	c3                   	ret    

00808761 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808761:	55                   	push   %ebp
  808762:	89 e5                	mov    %esp,%ebp
  808764:	53                   	push   %ebx
  808765:	83 ec 04             	sub    $0x4,%esp
  808768:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80876b:	8b 43 78             	mov    0x78(%ebx),%eax
  80876e:	85 c0                	test   %eax,%eax
  808770:	74 37                	je     8087a9 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808772:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808774:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808777:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808779:	8b 43 78             	mov    0x78(%ebx),%eax
  80877c:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80877f:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808782:	83 ec 0c             	sub    $0xc,%esp
  808785:	8b 40 10             	mov    0x10(%eax),%eax
  808788:	ff 70 04             	pushl  0x4(%eax)
  80878b:	e8 7f f2 ff ff       	call   807a0f <ntohl>
  808790:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808793:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808797:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80879e:	89 1c 24             	mov    %ebx,(%esp)
  8087a1:	e8 99 f9 ff ff       	call   80813f <tcp_output>
  8087a6:	83 c4 10             	add    $0x10,%esp
}
  8087a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8087ac:	c9                   	leave  
  8087ad:	c3                   	ret    

008087ae <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  8087ae:	55                   	push   %ebp
  8087af:	89 e5                	mov    %esp,%ebp
  8087b1:	57                   	push   %edi
  8087b2:	56                   	push   %esi
  8087b3:	53                   	push   %ebx
  8087b4:	83 ec 20             	sub    $0x20,%esp
  8087b7:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8087ba:	6a 00                	push   $0x0
  8087bc:	6a 14                	push   $0x14
  8087be:	6a 01                	push   $0x1
  8087c0:	e8 05 c2 ff ff       	call   8049ca <pbuf_alloc>
   
  if(p == NULL) {
  8087c5:	83 c4 10             	add    $0x10,%esp
  8087c8:	85 c0                	test   %eax,%eax
  8087ca:	0f 84 e5 00 00 00    	je     8088b5 <tcp_keepalive+0x107>
  8087d0:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087d2:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087d7:	0f 86 e0 00 00 00    	jbe    8088bd <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087dd:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087e0:	83 ec 0c             	sub    $0xc,%esp
  8087e3:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087e7:	50                   	push   %eax
  8087e8:	e8 f1 ef ff ff       	call   8077de <htons>
  8087ed:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8087f0:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8087f4:	89 04 24             	mov    %eax,(%esp)
  8087f7:	e8 e2 ef ff ff       	call   8077de <htons>
  8087fc:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808800:	8b 46 54             	mov    0x54(%esi),%eax
  808803:	83 e8 01             	sub    $0x1,%eax
  808806:	89 04 24             	mov    %eax,(%esp)
  808809:	e8 ea ef ff ff       	call   8077f8 <htonl>
  80880e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808811:	83 c4 04             	add    $0x4,%esp
  808814:	ff 76 24             	pushl  0x24(%esi)
  808817:	e8 dc ef ff ff       	call   8077f8 <htonl>
  80881c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80881f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808823:	89 04 24             	mov    %eax,(%esp)
  808826:	e8 c0 ef ff ff       	call   8077eb <ntohs>
  80882b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808830:	89 04 24             	mov    %eax,(%esp)
  808833:	e8 a6 ef ff ff       	call   8077de <htons>
  808838:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80883c:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808840:	89 04 24             	mov    %eax,(%esp)
  808843:	e8 96 ef ff ff       	call   8077de <htons>
  808848:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80884c:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808852:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808856:	89 04 24             	mov    %eax,(%esp)
  808859:	e8 8d ef ff ff       	call   8077eb <ntohs>
  80885e:	83 e0 3f             	and    $0x3f,%eax
  808861:	80 cc 50             	or     $0x50,%ah
  808864:	89 04 24             	mov    %eax,(%esp)
  808867:	e8 72 ef ff ff       	call   8077de <htons>
  80886c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808870:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808876:	8d 46 04             	lea    0x4(%esi),%eax
  808879:	89 c2                	mov    %eax,%edx
  80887b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80887f:	89 04 24             	mov    %eax,(%esp)
  808882:	6a 06                	push   $0x6
  808884:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808887:	52                   	push   %edx
  808888:	56                   	push   %esi
  808889:	57                   	push   %edi
  80888a:	e8 2b ec ff ff       	call   8074ba <inet_chksum_pseudo>
  80888f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808893:	83 c4 18             	add    $0x18,%esp
  808896:	6a 06                	push   $0x6
  808898:	6a 00                	push   $0x0
  80889a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80889e:	50                   	push   %eax
  80889f:	ff 75 e4             	pushl  -0x1c(%ebp)
  8088a2:	56                   	push   %esi
  8088a3:	57                   	push   %edi
  8088a4:	e8 25 e2 ff ff       	call   806ace <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8088a9:	83 c4 14             	add    $0x14,%esp
  8088ac:	57                   	push   %edi
  8088ad:	e8 52 c0 ff ff       	call   804904 <pbuf_free>
  8088b2:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8088b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088b8:	5b                   	pop    %ebx
  8088b9:	5e                   	pop    %esi
  8088ba:	5f                   	pop    %edi
  8088bb:	5d                   	pop    %ebp
  8088bc:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088bd:	83 ec 04             	sub    $0x4,%esp
  8088c0:	68 98 27 81 00       	push   $0x812798
  8088c5:	68 3a 03 00 00       	push   $0x33a
  8088ca:	68 c6 27 81 00       	push   $0x8127c6
  8088cf:	e8 9b 5e 00 00       	call   80e76f <_panic>

008088d4 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8088d4:	55                   	push   %ebp
  8088d5:	89 e5                	mov    %esp,%ebp
  8088d7:	57                   	push   %edi
  8088d8:	56                   	push   %esi
  8088d9:	53                   	push   %ebx
  8088da:	83 ec 1c             	sub    $0x1c,%esp
  8088dd:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8088e0:	8b 46 78             	mov    0x78(%esi),%eax
  8088e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8088e6:	85 c0                	test   %eax,%eax
  8088e8:	0f 84 10 01 00 00    	je     8089fe <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8088ee:	83 ec 04             	sub    $0x4,%esp
  8088f1:	6a 00                	push   $0x0
  8088f3:	6a 15                	push   $0x15
  8088f5:	6a 01                	push   $0x1
  8088f7:	e8 ce c0 ff ff       	call   8049ca <pbuf_alloc>
  8088fc:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8088fe:	83 c4 10             	add    $0x10,%esp
  808901:	85 c0                	test   %eax,%eax
  808903:	0f 84 ed 00 00 00    	je     8089f6 <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808909:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80890e:	0f 86 f9 00 00 00    	jbe    808a0d <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808914:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808917:	83 ec 0c             	sub    $0xc,%esp
  80891a:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80891e:	50                   	push   %eax
  80891f:	e8 ba ee ff ff       	call   8077de <htons>
  808924:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808927:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80892b:	89 04 24             	mov    %eax,(%esp)
  80892e:	e8 ab ee ff ff       	call   8077de <htons>
  808933:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808937:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80893a:	8b 40 10             	mov    0x10(%eax),%eax
  80893d:	8b 40 04             	mov    0x4(%eax),%eax
  808940:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808943:	83 c4 04             	add    $0x4,%esp
  808946:	ff 76 24             	pushl  0x24(%esi)
  808949:	e8 aa ee ff ff       	call   8077f8 <htonl>
  80894e:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808951:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808955:	89 04 24             	mov    %eax,(%esp)
  808958:	e8 8e ee ff ff       	call   8077eb <ntohs>
  80895d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808962:	89 04 24             	mov    %eax,(%esp)
  808965:	e8 74 ee ff ff       	call   8077de <htons>
  80896a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80896e:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808972:	89 04 24             	mov    %eax,(%esp)
  808975:	e8 64 ee ff ff       	call   8077de <htons>
  80897a:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80897e:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808984:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808988:	89 04 24             	mov    %eax,(%esp)
  80898b:	e8 5b ee ff ff       	call   8077eb <ntohs>
  808990:	83 e0 3f             	and    $0x3f,%eax
  808993:	80 cc 50             	or     $0x50,%ah
  808996:	89 04 24             	mov    %eax,(%esp)
  808999:	e8 40 ee ff ff       	call   8077de <htons>
  80899e:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  8089a2:	8b 47 04             	mov    0x4(%edi),%eax
  8089a5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8089a8:	8b 51 08             	mov    0x8(%ecx),%edx
  8089ab:	0f b6 12             	movzbl (%edx),%edx
  8089ae:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  8089b1:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8089b7:	8d 46 04             	lea    0x4(%esi),%eax
  8089ba:	89 c1                	mov    %eax,%ecx
  8089bc:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8089c0:	89 04 24             	mov    %eax,(%esp)
  8089c3:	6a 06                	push   $0x6
  8089c5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8089c8:	51                   	push   %ecx
  8089c9:	56                   	push   %esi
  8089ca:	57                   	push   %edi
  8089cb:	e8 ea ea ff ff       	call   8074ba <inet_chksum_pseudo>
  8089d0:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8089d4:	83 c4 18             	add    $0x18,%esp
  8089d7:	6a 06                	push   $0x6
  8089d9:	6a 00                	push   $0x0
  8089db:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8089df:	50                   	push   %eax
  8089e0:	ff 75 e4             	pushl  -0x1c(%ebp)
  8089e3:	56                   	push   %esi
  8089e4:	57                   	push   %edi
  8089e5:	e8 e4 e0 ff ff       	call   806ace <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8089ea:	83 c4 14             	add    $0x14,%esp
  8089ed:	57                   	push   %edi
  8089ee:	e8 11 bf ff ff       	call   804904 <pbuf_free>
  8089f3:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8089f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8089f9:	5b                   	pop    %ebx
  8089fa:	5e                   	pop    %esi
  8089fb:	5f                   	pop    %edi
  8089fc:	5d                   	pop    %ebp
  8089fd:	c3                   	ret    
    seg = pcb->unsent;
  8089fe:	8b 46 74             	mov    0x74(%esi),%eax
  808a01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  808a04:	85 c0                	test   %eax,%eax
  808a06:	74 ee                	je     8089f6 <tcp_zero_window_probe+0x122>
  808a08:	e9 e1 fe ff ff       	jmp    8088ee <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808a0d:	83 ec 04             	sub    $0x4,%esp
  808a10:	68 98 27 81 00       	push   $0x812798
  808a15:	68 8d 03 00 00       	push   $0x38d
  808a1a:	68 c6 27 81 00       	push   $0x8127c6
  808a1f:	e8 4b 5d 00 00       	call   80e76f <_panic>

00808a24 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808a24:	55                   	push   %ebp
  808a25:	89 e5                	mov    %esp,%ebp
  808a27:	57                   	push   %edi
  808a28:	56                   	push   %esi
  808a29:	53                   	push   %ebx
  808a2a:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808a2d:	8b 45 08             	mov    0x8(%ebp),%eax
  808a30:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808a33:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808a37:	0f b7 07             	movzwl (%edi),%eax
  808a3a:	50                   	push   %eax
  808a3b:	e8 ab ed ff ff       	call   8077eb <ntohs>
  808a40:	66 c1 e8 08          	shr    $0x8,%ax
  808a44:	83 e0 0f             	and    $0xf,%eax
  808a47:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808a4e:	83 c4 10             	add    $0x10,%esp
  808a51:	39 c3                	cmp    %eax,%ebx
  808a53:	7c 29                	jl     808a7e <udp_input+0x5a>
  808a55:	83 ec 0c             	sub    $0xc,%esp
  808a58:	0f b7 07             	movzwl (%edi),%eax
  808a5b:	50                   	push   %eax
  808a5c:	e8 8a ed ff ff       	call   8077eb <ntohs>
  808a61:	83 c4 08             	add    $0x8,%esp
  808a64:	66 c1 e8 06          	shr    $0x6,%ax
  808a68:	83 e0 3c             	and    $0x3c,%eax
  808a6b:	f7 d8                	neg    %eax
  808a6d:	98                   	cwtl   
  808a6e:	50                   	push   %eax
  808a6f:	ff 75 08             	pushl  0x8(%ebp)
  808a72:	e8 c0 bd ff ff       	call   804837 <pbuf_header>
  808a77:	83 c4 10             	add    $0x10,%esp
  808a7a:	84 c0                	test   %al,%al
  808a7c:	74 16                	je     808a94 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808a7e:	83 ec 0c             	sub    $0xc,%esp
  808a81:	ff 75 08             	pushl  0x8(%ebp)
  808a84:	e8 7b be ff ff       	call   804904 <pbuf_free>
    goto end;
  808a89:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808a8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808a8f:	5b                   	pop    %ebx
  808a90:	5e                   	pop    %esi
  808a91:	5f                   	pop    %edi
  808a92:	5d                   	pop    %ebp
  808a93:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808a94:	8b 45 08             	mov    0x8(%ebp),%eax
  808a97:	8b 70 04             	mov    0x4(%eax),%esi
  808a9a:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808a9d:	83 ec 0c             	sub    $0xc,%esp
  808aa0:	0f b7 06             	movzwl (%esi),%eax
  808aa3:	50                   	push   %eax
  808aa4:	e8 42 ed ff ff       	call   8077eb <ntohs>
  808aa9:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808aad:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808ab1:	89 04 24             	mov    %eax,(%esp)
  808ab4:	e8 32 ed ff ff       	call   8077eb <ntohs>
  808ab9:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808abb:	83 c4 10             	add    $0x10,%esp
  808abe:	66 83 f8 44          	cmp    $0x44,%ax
  808ac2:	74 1f                	je     808ae3 <udp_input+0xbf>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ac4:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
    uncon_pcb = NULL;
  808aca:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808acf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808ad6:	8d 47 10             	lea    0x10(%edi),%eax
  808ad9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808adc:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808adf:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ae1:	eb 51                	jmp    808b34 <udp_input+0x110>
    if (src == DHCP_SERVER_PORT) {
  808ae3:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808ae8:	0f 85 c8 01 00 00    	jne    808cb6 <udp_input+0x292>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808aee:	8b 45 0c             	mov    0xc(%ebp),%eax
  808af1:	8b 40 20             	mov    0x20(%eax),%eax
  808af4:	85 c0                	test   %eax,%eax
  808af6:	0f 84 ba 01 00 00    	je     808cb6 <udp_input+0x292>
  808afc:	8b 58 08             	mov    0x8(%eax),%ebx
  808aff:	85 db                	test   %ebx,%ebx
  808b01:	0f 84 af 01 00 00    	je     808cb6 <udp_input+0x292>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808b07:	8b 43 04             	mov    0x4(%ebx),%eax
  808b0a:	85 c0                	test   %eax,%eax
  808b0c:	0f 84 b4 01 00 00    	je     808cc6 <udp_input+0x2a2>
  808b12:	3b 47 0c             	cmp    0xc(%edi),%eax
  808b15:	0f 85 9b 01 00 00    	jne    808cb6 <udp_input+0x292>
  808b1b:	e9 a6 01 00 00       	jmp    808cc6 <udp_input+0x2a2>
        if ((uncon_pcb == NULL) && 
  808b20:	85 ff                	test   %edi,%edi
  808b22:	74 43                	je     808b67 <udp_input+0x143>
      if ((local_match != 0) &&
  808b24:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808b28:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808b2c:	74 45                	je     808b73 <udp_input+0x14f>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808b2e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808b31:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808b34:	85 db                	test   %ebx,%ebx
  808b36:	0f 84 6d 01 00 00    	je     808ca9 <udp_input+0x285>
      if ((pcb->local_port == dest) &&
  808b3c:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808b40:	75 ec                	jne    808b2e <udp_input+0x10a>
          (ip_addr_isany(&pcb->local_ip) ||
  808b42:	8b 03                	mov    (%ebx),%eax
  808b44:	85 c0                	test   %eax,%eax
  808b46:	74 d8                	je     808b20 <udp_input+0xfc>
  808b48:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808b4b:	3b 41 10             	cmp    0x10(%ecx),%eax
  808b4e:	74 d0                	je     808b20 <udp_input+0xfc>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808b50:	83 ec 08             	sub    $0x8,%esp
  808b53:	ff 75 0c             	pushl  0xc(%ebp)
  808b56:	ff 75 d4             	pushl  -0x2c(%ebp)
  808b59:	e8 1d da ff ff       	call   80657b <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808b5e:	83 c4 10             	add    $0x10,%esp
  808b61:	84 c0                	test   %al,%al
  808b63:	74 c9                	je     808b2e <udp_input+0x10a>
  808b65:	eb b9                	jmp    808b20 <udp_input+0xfc>
        if ((uncon_pcb == NULL) && 
  808b67:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808b6b:	83 e0 04             	and    $0x4,%eax
  808b6e:	0f 44 fb             	cmove  %ebx,%edi
  808b71:	eb b1                	jmp    808b24 <udp_input+0x100>
          (ip_addr_isany(&pcb->remote_ip) ||
  808b73:	8b 43 04             	mov    0x4(%ebx),%eax
  808b76:	85 c0                	test   %eax,%eax
  808b78:	74 08                	je     808b82 <udp_input+0x15e>
  808b7a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808b7d:	3b 42 0c             	cmp    0xc(%edx),%eax
  808b80:	75 ac                	jne    808b2e <udp_input+0x10a>
  808b82:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808b85:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808b88:	85 d2                	test   %edx,%edx
  808b8a:	0f 84 36 01 00 00    	je     808cc6 <udp_input+0x2a2>
          prev->next = pcb->next;
  808b90:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b93:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808b96:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  808b9b:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808b9e:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  808ba4:	e9 1d 01 00 00       	jmp    808cc6 <udp_input+0x2a2>
  808ba9:	89 c3                	mov    %eax,%ebx
  808bab:	e9 16 01 00 00       	jmp    808cc6 <udp_input+0x2a2>
          pbuf_free(p);
  808bb0:	83 ec 0c             	sub    $0xc,%esp
  808bb3:	ff 75 08             	pushl  0x8(%ebp)
  808bb6:	e8 49 bd ff ff       	call   804904 <pbuf_free>
          goto end;
  808bbb:	83 c4 10             	add    $0x10,%esp
  808bbe:	e9 c9 fe ff ff       	jmp    808a8c <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808bc3:	83 ec 04             	sub    $0x4,%esp
  808bc6:	68 eb 27 81 00       	push   $0x8127eb
  808bcb:	68 0a 01 00 00       	push   $0x10a
  808bd0:	68 16 28 81 00       	push   $0x812816
  808bd5:	e8 95 5b 00 00       	call   80e76f <_panic>
        pbuf_free(p);
  808bda:	83 ec 0c             	sub    $0xc,%esp
  808bdd:	ff 75 08             	pushl  0x8(%ebp)
  808be0:	e8 1f bd ff ff       	call   804904 <pbuf_free>
        goto end;
  808be5:	83 c4 10             	add    $0x10,%esp
  808be8:	e9 9f fe ff ff       	jmp    808a8c <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808bed:	83 ec 08             	sub    $0x8,%esp
  808bf0:	ff 75 0c             	pushl  0xc(%ebp)
  808bf3:	8d 47 10             	lea    0x10(%edi),%eax
  808bf6:	50                   	push   %eax
  808bf7:	e8 7f d9 ff ff       	call   80657b <ip_addr_isbroadcast>
  808bfc:	83 c4 10             	add    $0x10,%esp
  808bff:	84 c0                	test   %al,%al
  808c01:	75 25                	jne    808c28 <udp_input+0x204>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808c03:	8b 5f 10             	mov    0x10(%edi),%ebx
  808c06:	83 ec 0c             	sub    $0xc,%esp
  808c09:	68 00 00 00 f0       	push   $0xf0000000
  808c0e:	e8 fc ed ff ff       	call   807a0f <ntohl>
  808c13:	21 c3                	and    %eax,%ebx
  808c15:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808c1c:	e8 ee ed ff ff       	call   807a0f <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808c21:	83 c4 10             	add    $0x10,%esp
  808c24:	39 c3                	cmp    %eax,%ebx
  808c26:	75 13                	jne    808c3b <udp_input+0x217>
      pbuf_free(p);
  808c28:	83 ec 0c             	sub    $0xc,%esp
  808c2b:	ff 75 08             	pushl  0x8(%ebp)
  808c2e:	e8 d1 bc ff ff       	call   804904 <pbuf_free>
  808c33:	83 c4 10             	add    $0x10,%esp
  808c36:	e9 51 fe ff ff       	jmp    808a8c <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808c3b:	83 ec 0c             	sub    $0xc,%esp
  808c3e:	0f b7 07             	movzwl (%edi),%eax
  808c41:	50                   	push   %eax
  808c42:	e8 a4 eb ff ff       	call   8077eb <ntohs>
  808c47:	83 c4 08             	add    $0x8,%esp
  808c4a:	66 c1 e8 08          	shr    $0x8,%ax
  808c4e:	83 e0 0f             	and    $0xf,%eax
  808c51:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808c58:	98                   	cwtl   
  808c59:	50                   	push   %eax
  808c5a:	ff 75 08             	pushl  0x8(%ebp)
  808c5d:	e8 d5 bb ff ff       	call   804837 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808c62:	83 c4 10             	add    $0x10,%esp
  808c65:	8b 45 08             	mov    0x8(%ebp),%eax
  808c68:	3b 78 04             	cmp    0x4(%eax),%edi
  808c6b:	75 12                	jne    808c7f <udp_input+0x25b>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808c6d:	83 ec 08             	sub    $0x8,%esp
  808c70:	6a 03                	push   $0x3
  808c72:	ff 75 08             	pushl  0x8(%ebp)
  808c75:	e8 22 58 00 00       	call   80e49c <icmp_dest_unreach>
  808c7a:	83 c4 10             	add    $0x10,%esp
  808c7d:	eb a9                	jmp    808c28 <udp_input+0x204>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808c7f:	83 ec 04             	sub    $0x4,%esp
  808c82:	68 2a 28 81 00       	push   $0x81282a
  808c87:	68 25 01 00 00       	push   $0x125
  808c8c:	68 16 28 81 00       	push   $0x812816
  808c91:	e8 d9 5a 00 00       	call   80e76f <_panic>
    pbuf_free(p);
  808c96:	83 ec 0c             	sub    $0xc,%esp
  808c99:	ff 75 08             	pushl  0x8(%ebp)
  808c9c:	e8 63 bc ff ff       	call   804904 <pbuf_free>
  808ca1:	83 c4 10             	add    $0x10,%esp
}
  808ca4:	e9 e3 fd ff ff       	jmp    808a8c <udp_input+0x68>
  808ca9:	89 f8                	mov    %edi,%eax
  808cab:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808cae:	85 c0                	test   %eax,%eax
  808cb0:	0f 85 f3 fe ff ff    	jne    808ba9 <udp_input+0x185>
  808cb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  808cb9:	8b 57 10             	mov    0x10(%edi),%edx
  808cbc:	bb 00 00 00 00       	mov    $0x0,%ebx
  808cc1:	39 50 04             	cmp    %edx,0x4(%eax)
  808cc4:	75 d0                	jne    808c96 <udp_input+0x272>
      if (udphdr->chksum != 0) {
  808cc6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808cc9:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808cce:	74 29                	je     808cf9 <udp_input+0x2d5>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808cd0:	83 ec 0c             	sub    $0xc,%esp
  808cd3:	8b 45 08             	mov    0x8(%ebp),%eax
  808cd6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808cda:	50                   	push   %eax
  808cdb:	6a 11                	push   $0x11
  808cdd:	8d 47 10             	lea    0x10(%edi),%eax
  808ce0:	50                   	push   %eax
  808ce1:	8d 47 0c             	lea    0xc(%edi),%eax
  808ce4:	50                   	push   %eax
  808ce5:	ff 75 08             	pushl  0x8(%ebp)
  808ce8:	e8 cd e7 ff ff       	call   8074ba <inet_chksum_pseudo>
  808ced:	83 c4 20             	add    $0x20,%esp
  808cf0:	66 85 c0             	test   %ax,%ax
  808cf3:	0f 85 b7 fe ff ff    	jne    808bb0 <udp_input+0x18c>
    if(pbuf_header(p, -UDP_HLEN)) {
  808cf9:	83 ec 08             	sub    $0x8,%esp
  808cfc:	6a f8                	push   $0xfffffff8
  808cfe:	ff 75 08             	pushl  0x8(%ebp)
  808d01:	e8 31 bb ff ff       	call   804837 <pbuf_header>
  808d06:	83 c4 10             	add    $0x10,%esp
  808d09:	84 c0                	test   %al,%al
  808d0b:	0f 85 b2 fe ff ff    	jne    808bc3 <udp_input+0x19f>
    if (pcb != NULL) {
  808d11:	85 db                	test   %ebx,%ebx
  808d13:	0f 84 d4 fe ff ff    	je     808bed <udp_input+0x1c9>
      if (pcb->recv != NULL) {
  808d19:	8b 43 18             	mov    0x18(%ebx),%eax
  808d1c:	85 c0                	test   %eax,%eax
  808d1e:	0f 84 b6 fe ff ff    	je     808bda <udp_input+0x1b6>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808d24:	83 ec 0c             	sub    $0xc,%esp
  808d27:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808d2b:	52                   	push   %edx
  808d2c:	83 c7 0c             	add    $0xc,%edi
  808d2f:	57                   	push   %edi
  808d30:	ff 75 08             	pushl  0x8(%ebp)
  808d33:	53                   	push   %ebx
  808d34:	ff 73 1c             	pushl  0x1c(%ebx)
  808d37:	ff d0                	call   *%eax
  808d39:	83 c4 20             	add    $0x20,%esp
  808d3c:	e9 4b fd ff ff       	jmp    808a8c <udp_input+0x68>

00808d41 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808d41:	55                   	push   %ebp
  808d42:	89 e5                	mov    %esp,%ebp
  808d44:	57                   	push   %edi
  808d45:	56                   	push   %esi
  808d46:	53                   	push   %ebx
  808d47:	83 ec 0c             	sub    $0xc,%esp
  808d4a:	8b 55 08             	mov    0x8(%ebp),%edx
  808d4d:	8b 7d 10             	mov    0x10(%ebp),%edi
  808d50:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d52:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  rebind = 0;
  808d57:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808d5c:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d61:	eb 1a                	jmp    808d7d <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808d63:	83 ec 04             	sub    $0x4,%esp
  808d66:	68 3e 28 81 00       	push   $0x81283e
  808d6b:	68 41 02 00 00       	push   $0x241
  808d70:	68 16 28 81 00       	push   $0x812816
  808d75:	e8 f5 59 00 00       	call   80e76f <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d7a:	8b 40 0c             	mov    0xc(%eax),%eax
  808d7d:	85 c0                	test   %eax,%eax
  808d7f:	74 0c                	je     808d8d <udp_bind+0x4c>
    if (pcb == ipcb) {
  808d81:	39 d0                	cmp    %edx,%eax
  808d83:	75 f5                	jne    808d7a <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808d85:	84 db                	test   %bl,%bl
  808d87:	75 da                	jne    808d63 <udp_bind+0x22>
      rebind = 1;
  808d89:	89 f3                	mov    %esi,%ebx
  808d8b:	eb ed                	jmp    808d7a <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808d8d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808d91:	74 05                	je     808d98 <udp_bind+0x57>
  808d93:	8b 45 0c             	mov    0xc(%ebp),%eax
  808d96:	8b 00                	mov    (%eax),%eax
  808d98:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808d9a:	66 85 ff             	test   %di,%di
  808d9d:	75 2e                	jne    808dcd <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808d9f:	8b 35 54 c2 b3 00    	mov    0xb3c254,%esi
  808da5:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808da7:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808dac:	eb 03                	jmp    808db1 <udp_bind+0x70>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808dae:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808db1:	85 c0                	test   %eax,%eax
  808db3:	74 14                	je     808dc9 <udp_bind+0x88>
  808db5:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808dba:	74 0d                	je     808dc9 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808dbc:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808dc0:	75 ec                	jne    808dae <udp_bind+0x6d>
        port++;
  808dc2:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808dc5:	89 f0                	mov    %esi,%eax
  808dc7:	eb e8                	jmp    808db1 <udp_bind+0x70>
    }
    if (ipcb != NULL) {
  808dc9:	85 c0                	test   %eax,%eax
  808dcb:	75 28                	jne    808df5 <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808dcd:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808dd1:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808dd6:	84 db                	test   %bl,%bl
  808dd8:	75 13                	jne    808ded <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808dda:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  808ddf:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808de2:	89 15 54 c2 b3 00    	mov    %edx,0xb3c254
  return ERR_OK;
  808de8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808ded:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808df0:	5b                   	pop    %ebx
  808df1:	5e                   	pop    %esi
  808df2:	5f                   	pop    %edi
  808df3:	5d                   	pop    %ebp
  808df4:	c3                   	ret    
      return ERR_USE;
  808df5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808dfa:	eb f1                	jmp    808ded <udp_bind+0xac>

00808dfc <udp_sendto_if>:
{
  808dfc:	55                   	push   %ebp
  808dfd:	89 e5                	mov    %esp,%ebp
  808dff:	57                   	push   %edi
  808e00:	56                   	push   %esi
  808e01:	53                   	push   %ebx
  808e02:	83 ec 1c             	sub    $0x1c,%esp
  808e05:	8b 75 08             	mov    0x8(%ebp),%esi
  808e08:	8b 45 14             	mov    0x14(%ebp),%eax
  808e0b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808e0e:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  808e13:	75 19                	jne    808e2e <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808e15:	83 ec 04             	sub    $0x4,%esp
  808e18:	6a 00                	push   $0x0
  808e1a:	56                   	push   %esi
  808e1b:	56                   	push   %esi
  808e1c:	e8 20 ff ff ff       	call   808d41 <udp_bind>
  808e21:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808e23:	83 c4 10             	add    $0x10,%esp
  808e26:	84 c0                	test   %al,%al
  808e28:	0f 85 b7 00 00 00    	jne    808ee5 <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808e2e:	83 ec 08             	sub    $0x8,%esp
  808e31:	6a 08                	push   $0x8
  808e33:	ff 75 0c             	pushl  0xc(%ebp)
  808e36:	e8 fc b9 ff ff       	call   804837 <pbuf_header>
  808e3b:	83 c4 10             	add    $0x10,%esp
    q = p;
  808e3e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808e41:	84 c0                	test   %al,%al
  808e43:	0f 85 a6 00 00 00    	jne    808eef <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808e49:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808e4e:	0f 86 ca 00 00 00    	jbe    808f1e <udp_sendto_if+0x122>
  udphdr = q->payload;
  808e54:	8b 7b 04             	mov    0x4(%ebx),%edi
  udphdr->src = htons(pcb->local_port);
  808e57:	83 ec 0c             	sub    $0xc,%esp
  808e5a:	0f b7 46 12          	movzwl 0x12(%esi),%eax
  808e5e:	50                   	push   %eax
  808e5f:	e8 7a e9 ff ff       	call   8077de <htons>
  808e64:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808e67:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808e6b:	89 04 24             	mov    %eax,(%esp)
  808e6e:	e8 6b e9 ff ff       	call   8077de <htons>
  808e73:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808e77:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808e7d:	8b 06                	mov    (%esi),%eax
  808e7f:	83 c4 10             	add    $0x10,%esp
  808e82:	85 c0                	test   %eax,%eax
  808e84:	0f 85 ab 00 00 00    	jne    808f35 <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808e8a:	8b 45 18             	mov    0x18(%ebp),%eax
  808e8d:	83 c0 04             	add    $0x4,%eax
  808e90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808e93:	83 ec 0c             	sub    $0xc,%esp
  808e96:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808e9a:	50                   	push   %eax
  808e9b:	e8 3e e9 ff ff       	call   8077de <htons>
  808ea0:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808ea4:	83 c4 10             	add    $0x10,%esp
  808ea7:	f6 46 10 01          	testb  $0x1,0x10(%esi)
  808eab:	0f 84 ac 00 00 00    	je     808f5d <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808eb1:	83 ec 04             	sub    $0x4,%esp
  808eb4:	ff 75 18             	pushl  0x18(%ebp)
  808eb7:	6a 11                	push   $0x11
  808eb9:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808ebd:	50                   	push   %eax
  808ebe:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808ec2:	50                   	push   %eax
  808ec3:	ff 75 10             	pushl  0x10(%ebp)
  808ec6:	ff 75 e4             	pushl  -0x1c(%ebp)
  808ec9:	53                   	push   %ebx
  808eca:	e8 72 da ff ff       	call   806941 <ip_output_if>
  808ecf:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808ed1:	83 c4 20             	add    $0x20,%esp
  808ed4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808ed7:	74 0c                	je     808ee5 <udp_sendto_if+0xe9>
    pbuf_free(q);
  808ed9:	83 ec 0c             	sub    $0xc,%esp
  808edc:	53                   	push   %ebx
  808edd:	e8 22 ba ff ff       	call   804904 <pbuf_free>
  808ee2:	83 c4 10             	add    $0x10,%esp
}
  808ee5:	89 f8                	mov    %edi,%eax
  808ee7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808eea:	5b                   	pop    %ebx
  808eeb:	5e                   	pop    %esi
  808eec:	5f                   	pop    %edi
  808eed:	5d                   	pop    %ebp
  808eee:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808eef:	83 ec 04             	sub    $0x4,%esp
  808ef2:	6a 00                	push   $0x0
  808ef4:	6a 08                	push   $0x8
  808ef6:	6a 01                	push   $0x1
  808ef8:	e8 cd ba ff ff       	call   8049ca <pbuf_alloc>
  808efd:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808eff:	83 c4 10             	add    $0x10,%esp
  808f02:	85 c0                	test   %eax,%eax
  808f04:	0f 84 80 00 00 00    	je     808f8a <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808f0a:	83 ec 08             	sub    $0x8,%esp
  808f0d:	ff 75 0c             	pushl  0xc(%ebp)
  808f10:	50                   	push   %eax
  808f11:	e8 cf be ff ff       	call   804de5 <pbuf_chain>
  808f16:	83 c4 10             	add    $0x10,%esp
  808f19:	e9 2b ff ff ff       	jmp    808e49 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808f1e:	83 ec 04             	sub    $0x4,%esp
  808f21:	68 4c 28 81 00       	push   $0x81284c
  808f26:	68 b2 01 00 00       	push   $0x1b2
  808f2b:	68 16 28 81 00       	push   $0x812816
  808f30:	e8 3a 58 00 00       	call   80e76f <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808f35:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808f38:	3b 41 04             	cmp    0x4(%ecx),%eax
  808f3b:	75 08                	jne    808f45 <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  808f3d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  808f40:	e9 4e ff ff ff       	jmp    808e93 <udp_sendto_if+0x97>
      return ERR_VAL;
  808f45:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  808f4a:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808f4d:	74 96                	je     808ee5 <udp_sendto_if+0xe9>
        pbuf_free(q);
  808f4f:	83 ec 0c             	sub    $0xc,%esp
  808f52:	53                   	push   %ebx
  808f53:	e8 ac b9 ff ff       	call   804904 <pbuf_free>
  808f58:	83 c4 10             	add    $0x10,%esp
  808f5b:	eb 88                	jmp    808ee5 <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808f5d:	83 ec 0c             	sub    $0xc,%esp
  808f60:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808f64:	50                   	push   %eax
  808f65:	6a 11                	push   $0x11
  808f67:	ff 75 10             	pushl  0x10(%ebp)
  808f6a:	ff 75 e4             	pushl  -0x1c(%ebp)
  808f6d:	53                   	push   %ebx
  808f6e:	e8 47 e5 ff ff       	call   8074ba <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808f73:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808f76:	66 85 c0             	test   %ax,%ax
  808f79:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808f7e:	0f 44 c2             	cmove  %edx,%eax
  808f81:	66 89 47 06          	mov    %ax,0x6(%edi)
  808f85:	e9 27 ff ff ff       	jmp    808eb1 <udp_sendto_if+0xb5>
      return ERR_MEM;
  808f8a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  808f8f:	e9 51 ff ff ff       	jmp    808ee5 <udp_sendto_if+0xe9>

00808f94 <udp_sendto>:
{
  808f94:	55                   	push   %ebp
  808f95:	89 e5                	mov    %esp,%ebp
  808f97:	56                   	push   %esi
  808f98:	53                   	push   %ebx
  808f99:	8b 75 10             	mov    0x10(%ebp),%esi
  808f9c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808f9f:	83 ec 0c             	sub    $0xc,%esp
  808fa2:	56                   	push   %esi
  808fa3:	e8 16 d6 ff ff       	call   8065be <ip_route>
  if (netif == NULL) {
  808fa8:	83 c4 10             	add    $0x10,%esp
  808fab:	85 c0                	test   %eax,%eax
  808fad:	74 1e                	je     808fcd <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808faf:	83 ec 0c             	sub    $0xc,%esp
  808fb2:	50                   	push   %eax
  808fb3:	0f b7 db             	movzwl %bx,%ebx
  808fb6:	53                   	push   %ebx
  808fb7:	56                   	push   %esi
  808fb8:	ff 75 0c             	pushl  0xc(%ebp)
  808fbb:	ff 75 08             	pushl  0x8(%ebp)
  808fbe:	e8 39 fe ff ff       	call   808dfc <udp_sendto_if>
  808fc3:	83 c4 20             	add    $0x20,%esp
}
  808fc6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808fc9:	5b                   	pop    %ebx
  808fca:	5e                   	pop    %esi
  808fcb:	5d                   	pop    %ebp
  808fcc:	c3                   	ret    
    return ERR_RTE;
  808fcd:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808fd2:	eb f2                	jmp    808fc6 <udp_sendto+0x32>

00808fd4 <udp_send>:
{
  808fd4:	55                   	push   %ebp
  808fd5:	89 e5                	mov    %esp,%ebp
  808fd7:	83 ec 08             	sub    $0x8,%esp
  808fda:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808fdd:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808fe1:	52                   	push   %edx
  808fe2:	8d 50 04             	lea    0x4(%eax),%edx
  808fe5:	52                   	push   %edx
  808fe6:	ff 75 0c             	pushl  0xc(%ebp)
  808fe9:	50                   	push   %eax
  808fea:	e8 a5 ff ff ff       	call   808f94 <udp_sendto>
}
  808fef:	c9                   	leave  
  808ff0:	c3                   	ret    

00808ff1 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808ff1:	55                   	push   %ebp
  808ff2:	89 e5                	mov    %esp,%ebp
  808ff4:	57                   	push   %edi
  808ff5:	56                   	push   %esi
  808ff6:	53                   	push   %ebx
  808ff7:	83 ec 0c             	sub    $0xc,%esp
  808ffa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808ffd:	8b 75 0c             	mov    0xc(%ebp),%esi
  809000:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809003:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  809008:	74 2b                	je     809035 <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80900a:	b8 00 00 00 00       	mov    $0x0,%eax
  80900f:	85 f6                	test   %esi,%esi
  809011:	74 02                	je     809015 <udp_connect+0x24>
  809013:	8b 06                	mov    (%esi),%eax
  809015:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  809018:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80901c:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809020:	8b 15 54 c2 b3 00    	mov    0xb3c254,%edx
  809026:	89 d0                	mov    %edx,%eax
  809028:	85 c0                	test   %eax,%eax
  80902a:	74 1e                	je     80904a <udp_connect+0x59>
    if (pcb == ipcb) {
  80902c:	39 d8                	cmp    %ebx,%eax
  80902e:	74 2b                	je     80905b <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809030:	8b 40 0c             	mov    0xc(%eax),%eax
  809033:	eb f3                	jmp    809028 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809035:	83 ec 04             	sub    $0x4,%esp
  809038:	6a 00                	push   $0x0
  80903a:	53                   	push   %ebx
  80903b:	53                   	push   %ebx
  80903c:	e8 00 fd ff ff       	call   808d41 <udp_bind>
    if (err != ERR_OK)
  809041:	83 c4 10             	add    $0x10,%esp
  809044:	84 c0                	test   %al,%al
  809046:	74 c2                	je     80900a <udp_connect+0x19>
  809048:	eb 09                	jmp    809053 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80904a:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80904d:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  return ERR_OK;
}
  809053:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809056:	5b                   	pop    %ebx
  809057:	5e                   	pop    %esi
  809058:	5f                   	pop    %edi
  809059:	5d                   	pop    %ebp
  80905a:	c3                   	ret    
      return ERR_OK;
  80905b:	b8 00 00 00 00       	mov    $0x0,%eax
  809060:	eb f1                	jmp    809053 <udp_connect+0x62>

00809062 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  809062:	55                   	push   %ebp
  809063:	89 e5                	mov    %esp,%ebp
  809065:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809068:	8b 15 88 24 81 00    	mov    0x812488,%edx
  80906e:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809071:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809077:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80907b:	5d                   	pop    %ebp
  80907c:	c3                   	ret    

0080907d <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80907d:	55                   	push   %ebp
  80907e:	89 e5                	mov    %esp,%ebp
  809080:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809083:	8b 55 0c             	mov    0xc(%ebp),%edx
  809086:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809089:	8b 55 10             	mov    0x10(%ebp),%edx
  80908c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80908f:	5d                   	pop    %ebp
  809090:	c3                   	ret    

00809091 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809091:	55                   	push   %ebp
  809092:	89 e5                	mov    %esp,%ebp
  809094:	83 ec 08             	sub    $0x8,%esp
  809097:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80909a:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  80909f:	39 c8                	cmp    %ecx,%eax
  8090a1:	75 1b                	jne    8090be <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  8090a3:	8b 41 0c             	mov    0xc(%ecx),%eax
  8090a6:	a3 54 c2 b3 00       	mov    %eax,0xb3c254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8090ab:	83 ec 08             	sub    $0x8,%esp
  8090ae:	51                   	push   %ecx
  8090af:	6a 01                	push   $0x1
  8090b1:	e8 01 b5 ff ff       	call   8045b7 <memp_free>
}
  8090b6:	83 c4 10             	add    $0x10,%esp
  8090b9:	c9                   	leave  
  8090ba:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8090bb:	8b 40 0c             	mov    0xc(%eax),%eax
  8090be:	85 c0                	test   %eax,%eax
  8090c0:	74 e9                	je     8090ab <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8090c2:	8b 50 0c             	mov    0xc(%eax),%edx
  8090c5:	39 ca                	cmp    %ecx,%edx
  8090c7:	75 f2                	jne    8090bb <udp_remove+0x2a>
  8090c9:	85 d2                	test   %edx,%edx
  8090cb:	74 ee                	je     8090bb <udp_remove+0x2a>
        pcb2->next = pcb->next;
  8090cd:	8b 51 0c             	mov    0xc(%ecx),%edx
  8090d0:	89 50 0c             	mov    %edx,0xc(%eax)
  8090d3:	eb e6                	jmp    8090bb <udp_remove+0x2a>

008090d5 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8090d5:	55                   	push   %ebp
  8090d6:	89 e5                	mov    %esp,%ebp
  8090d8:	53                   	push   %ebx
  8090d9:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8090dc:	6a 01                	push   $0x1
  8090de:	e8 7e b4 ff ff       	call   804561 <memp_malloc>
  8090e3:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8090e5:	83 c4 10             	add    $0x10,%esp
  8090e8:	85 c0                	test   %eax,%eax
  8090ea:	74 14                	je     809100 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8090ec:	83 ec 04             	sub    $0x4,%esp
  8090ef:	6a 20                	push   $0x20
  8090f1:	6a 00                	push   $0x0
  8090f3:	50                   	push   %eax
  8090f4:	e8 11 60 00 00       	call   80f10a <memset>
    pcb->ttl = UDP_TTL;
  8090f9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8090fd:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  809100:	89 d8                	mov    %ebx,%eax
  809102:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809105:	c9                   	leave  
  809106:	c3                   	ret    

00809107 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  809107:	55                   	push   %ebp
  809108:	89 e5                	mov    %esp,%ebp
  80910a:	56                   	push   %esi
  80910b:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80910c:	85 c0                	test   %eax,%eax
  80910e:	74 35                	je     809145 <free_etharp_q+0x3e>
  809110:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809112:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  809116:	74 44                	je     80915c <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  809118:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80911a:	8b 43 04             	mov    0x4(%ebx),%eax
  80911d:	85 c0                	test   %eax,%eax
  80911f:	74 52                	je     809173 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  809121:	83 ec 0c             	sub    $0xc,%esp
  809124:	50                   	push   %eax
  809125:	e8 da b7 ff ff       	call   804904 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80912a:	83 c4 08             	add    $0x8,%esp
  80912d:	53                   	push   %ebx
  80912e:	6a 0a                	push   $0xa
  809130:	e8 82 b4 ff ff       	call   8045b7 <memp_free>
    q = q->next;
  809135:	89 f3                	mov    %esi,%ebx
  while (q) {
  809137:	83 c4 10             	add    $0x10,%esp
  80913a:	85 f6                	test   %esi,%esi
  80913c:	75 da                	jne    809118 <free_etharp_q+0x11>
  }
}
  80913e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809141:	5b                   	pop    %ebx
  809142:	5e                   	pop    %esi
  809143:	5d                   	pop    %ebp
  809144:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809145:	83 ec 04             	sub    $0x4,%esp
  809148:	68 8c 1f 81 00       	push   $0x811f8c
  80914d:	68 93 00 00 00       	push   $0x93
  809152:	68 7a 28 81 00       	push   $0x81287a
  809157:	e8 13 56 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80915c:	83 ec 04             	sub    $0x4,%esp
  80915f:	68 92 28 81 00       	push   $0x812892
  809164:	68 94 00 00 00       	push   $0x94
  809169:	68 7a 28 81 00       	push   $0x81287a
  80916e:	e8 fc 55 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809173:	83 ec 04             	sub    $0x4,%esp
  809176:	68 9f 28 81 00       	push   $0x81289f
  80917b:	68 98 00 00 00       	push   $0x98
  809180:	68 7a 28 81 00       	push   $0x81287a
  809185:	e8 e5 55 00 00       	call   80e76f <_panic>

0080918a <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80918a:	55                   	push   %ebp
  80918b:	89 e5                	mov    %esp,%ebp
  80918d:	57                   	push   %edi
  80918e:	56                   	push   %esi
  80918f:	53                   	push   %ebx
  809190:	83 ec 1c             	sub    $0x1c,%esp
  809193:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809196:	85 c0                	test   %eax,%eax
  809198:	0f 84 e9 00 00 00    	je     809287 <find_entry+0xfd>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80919e:	0f b6 15 00 5a b3 00 	movzbl 0xb35a00,%edx
  8091a5:	0f b6 ca             	movzbl %dl,%ecx
  8091a8:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  8091ab:	83 bb 30 5a b3 00 02 	cmpl   $0x2,0xb35a30(%ebx)
  8091b2:	0f 84 9f 00 00 00    	je     809257 <find_entry+0xcd>
  8091b8:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8091bc:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  8091c0:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8091c4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8091c8:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8091cc:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8091d0:	ba 00 00 00 00       	mov    $0x0,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8091d5:	0f b6 ca             	movzbl %dl,%ecx
  8091d8:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8091db:	83 b9 30 5a b3 00 00 	cmpl   $0x0,0xb35a30(%ecx)
  8091e2:	0f 85 c1 00 00 00    	jne    8092a9 <find_entry+0x11f>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8091e8:	89 d1                	mov    %edx,%ecx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8091ea:	83 c2 01             	add    $0x1,%edx
  8091ed:	80 fa 09             	cmp    $0x9,%dl
  8091f0:	0f 86 02 01 00 00    	jbe    8092f8 <find_entry+0x16e>
  8091f6:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8091f9:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8091fb:	80 f9 0a             	cmp    $0xa,%cl
  8091fe:	0f 84 69 01 00 00    	je     80936d <find_entry+0x1e3>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809204:	f6 c2 02             	test   $0x2,%dl
  809207:	0f 85 ff 01 00 00    	jne    80940c <find_entry+0x282>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80920d:	89 ce                	mov    %ecx,%esi
  if (empty < ARP_TABLE_SIZE) {
  80920f:	80 f9 09             	cmp    $0x9,%cl
  809212:	0f 8f 67 01 00 00    	jg     80937f <find_entry+0x1f5>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809218:	89 f0                	mov    %esi,%eax
  80921a:	3c 09                	cmp    $0x9,%al
  80921c:	0f 87 c9 01 00 00    	ja     8093eb <find_entry+0x261>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809222:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809225:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809228:	c7 82 30 5a b3 00 00 	movl   $0x0,0xb35a30(%edx)
  80922f:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809232:	85 db                	test   %ebx,%ebx
  809234:	74 08                	je     80923e <find_entry+0xb4>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809236:	8b 0b                	mov    (%ebx),%ecx
  809238:	89 8a 24 5a b3 00    	mov    %ecx,0xb35a24(%edx)
  }
  arp_table[i].ctime = 0;
  80923e:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809241:	c6 80 34 5a b3 00 00 	movb   $0x0,0xb35a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809248:	89 f0                	mov    %esi,%eax
  80924a:	a2 00 5a b3 00       	mov    %al,0xb35a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80924f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809252:	5b                   	pop    %ebx
  809253:	5e                   	pop    %esi
  809254:	5f                   	pop    %edi
  809255:	5d                   	pop    %ebp
  809256:	c3                   	ret    
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809257:	8b bb 24 5a b3 00    	mov    0xb35a24(%ebx),%edi
  80925d:	39 38                	cmp    %edi,(%eax)
  80925f:	74 22                	je     809283 <find_entry+0xf9>
  809261:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809265:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809269:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80926d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809271:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809275:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809279:	ba 00 00 00 00       	mov    $0x0,%edx
  80927e:	e9 52 ff ff ff       	jmp    8091d5 <find_entry+0x4b>
        return etharp_cached_entry;
  809283:	89 d0                	mov    %edx,%eax
  809285:	eb c8                	jmp    80924f <find_entry+0xc5>
  809287:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80928b:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80928f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809293:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809297:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80929b:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80929f:	ba 00 00 00 00       	mov    $0x0,%edx
  8092a4:	e9 2c ff ff ff       	jmp    8091d5 <find_entry+0x4b>
  8092a9:	b9 0a 00 00 00       	mov    $0xa,%ecx
  8092ae:	eb 48                	jmp    8092f8 <find_entry+0x16e>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8092b0:	85 c0                	test   %eax,%eax
  8092b2:	74 0d                	je     8092c1 <find_entry+0x137>
  8092b4:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8092b7:	8b be 24 5a b3 00    	mov    0xb35a24(%esi),%edi
  8092bd:	39 38                	cmp    %edi,(%eax)
  8092bf:	74 79                	je     80933a <find_entry+0x1b0>
      } else if (arp_table[i].q != NULL) {
  8092c1:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8092c4:	83 be 20 5a b3 00 00 	cmpl   $0x0,0xb35a20(%esi)
  8092cb:	74 7a                	je     809347 <find_entry+0x1bd>
        if (arp_table[i].ctime >= age_queue) {
  8092cd:	0f b6 9e 34 5a b3 00 	movzbl 0xb35a34(%esi),%ebx
  8092d4:	89 cf                	mov    %ecx,%edi
  8092d6:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  8092d9:	72 06                	jb     8092e1 <find_entry+0x157>
          old_queue = i;
  8092db:	88 55 e3             	mov    %dl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8092de:	88 5d e7             	mov    %bl,-0x19(%ebp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8092e1:	83 c2 01             	add    $0x1,%edx
  8092e4:	80 fa 09             	cmp    $0x9,%dl
  8092e7:	0f 87 09 ff ff ff    	ja     8091f6 <find_entry+0x6c>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8092ed:	80 f9 0a             	cmp    $0xa,%cl
  8092f0:	0f 84 df fe ff ff    	je     8091d5 <find_entry+0x4b>
  8092f6:	89 f9                	mov    %edi,%ecx
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8092f8:	0f b6 da             	movzbl %dl,%ebx
  8092fb:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8092fe:	8b b6 30 5a b3 00    	mov    0xb35a30(%esi),%esi
  809304:	83 fe 01             	cmp    $0x1,%esi
  809307:	74 a7                	je     8092b0 <find_entry+0x126>
  809309:	89 cf                	mov    %ecx,%edi
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80930b:	83 fe 02             	cmp    $0x2,%esi
  80930e:	75 d1                	jne    8092e1 <find_entry+0x157>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809310:	85 c0                	test   %eax,%eax
  809312:	74 0d                	je     809321 <find_entry+0x197>
  809314:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809317:	8b be 24 5a b3 00    	mov    0xb35a24(%esi),%edi
  80931d:	39 38                	cmp    %edi,(%eax)
  80931f:	74 3f                	je     809360 <find_entry+0x1d6>
      } else if (arp_table[i].ctime >= age_stable) {
  809321:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809324:	0f b6 9b 34 5a b3 00 	movzbl 0xb35a34(%ebx),%ebx
  80932b:	89 cf                	mov    %ecx,%edi
  80932d:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  809330:	72 af                	jb     8092e1 <find_entry+0x157>
        old_stable = i;
  809332:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809335:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809338:	eb a7                	jmp    8092e1 <find_entry+0x157>
        etharp_cached_entry = i;
  80933a:	88 15 00 5a b3 00    	mov    %dl,0xb35a00
        return i;
  809340:	89 d0                	mov    %edx,%eax
  809342:	e9 08 ff ff ff       	jmp    80924f <find_entry+0xc5>
        if (arp_table[i].ctime >= age_pending) {
  809347:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80934a:	0f b6 9b 34 5a b3 00 	movzbl 0xb35a34(%ebx),%ebx
  809351:	89 cf                	mov    %ecx,%edi
  809353:	3a 5d e4             	cmp    -0x1c(%ebp),%bl
  809356:	72 89                	jb     8092e1 <find_entry+0x157>
          old_pending = i;
  809358:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  80935b:	88 5d e4             	mov    %bl,-0x1c(%ebp)
  80935e:	eb 81                	jmp    8092e1 <find_entry+0x157>
        etharp_cached_entry = i;
  809360:	88 15 00 5a b3 00    	mov    %dl,0xb35a00
        return i;
  809366:	89 d0                	mov    %edx,%eax
  809368:	e9 e2 fe ff ff       	jmp    80924f <find_entry+0xc5>
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80936d:	f6 c2 01             	test   $0x1,%dl
  809370:	0f 84 8c 00 00 00    	je     809402 <find_entry+0x278>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809376:	f6 c2 02             	test   $0x2,%dl
  809379:	0f 85 a1 00 00 00    	jne    809420 <find_entry+0x296>
  else if (old_stable < ARP_TABLE_SIZE) {
  80937f:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809383:	3c 09                	cmp    $0x9,%al
  809385:	7f 2c                	jg     8093b3 <find_entry+0x229>
    i = old_stable;
  809387:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809389:	0f b6 c0             	movzbl %al,%eax
  80938c:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80938f:	83 b8 20 5a b3 00 00 	cmpl   $0x0,0xb35a20(%eax)
  809396:	0f 84 7c fe ff ff    	je     809218 <find_entry+0x8e>
  80939c:	83 ec 04             	sub    $0x4,%esp
  80939f:	68 ac 28 81 00       	push   $0x8128ac
  8093a4:	68 75 01 00 00       	push   $0x175
  8093a9:	68 7a 28 81 00       	push   $0x81287a
  8093ae:	e8 bc 53 00 00       	call   80e76f <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  8093b3:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    i = old_pending;
  8093b7:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  8093b9:	3c 09                	cmp    $0x9,%al
  8093bb:	0f 8e 57 fe ff ff    	jle    809218 <find_entry+0x8e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  8093c1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  8093c5:	3c 09                	cmp    $0x9,%al
  8093c7:	7f 4d                	jg     809416 <find_entry+0x28c>
    i = old_queue;
  8093c9:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  8093cb:	0f b6 f8             	movzbl %al,%edi
  8093ce:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8093d1:	8b 87 20 5a b3 00    	mov    0xb35a20(%edi),%eax
  8093d7:	e8 2b fd ff ff       	call   809107 <free_etharp_q>
    arp_table[i].q = NULL;
  8093dc:	c7 87 20 5a b3 00 00 	movl   $0x0,0xb35a20(%edi)
  8093e3:	00 00 00 
  8093e6:	e9 2d fe ff ff       	jmp    809218 <find_entry+0x8e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8093eb:	83 ec 04             	sub    $0x4,%esp
  8093ee:	68 c3 28 81 00       	push   $0x8128c3
  8093f3:	68 8b 01 00 00       	push   $0x18b
  8093f8:	68 7a 28 81 00       	push   $0x81287a
  8093fd:	e8 6d 53 00 00       	call   80e76f <_panic>
    return (s8_t)ERR_MEM;
  809402:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809407:	e9 43 fe ff ff       	jmp    80924f <find_entry+0xc5>
  80940c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809411:	e9 39 fe ff ff       	jmp    80924f <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  809416:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80941b:	e9 2f fe ff ff       	jmp    80924f <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  809420:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809425:	e9 25 fe ff ff       	jmp    80924f <find_entry+0xc5>

0080942a <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80942a:	55                   	push   %ebp
  80942b:	89 e5                	mov    %esp,%ebp
  80942d:	57                   	push   %edi
  80942e:	56                   	push   %esi
  80942f:	53                   	push   %ebx
  809430:	83 ec 1c             	sub    $0x1c,%esp
  809433:	89 d7                	mov    %edx,%edi
  809435:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  809438:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80943b:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80943f:	75 45                	jne    809486 <etharp_send_ip+0x5c>
  809441:	89 c6                	mov    %eax,%esi
  809443:	b8 05 00 00 00       	mov    $0x5,%eax
  809448:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  80944b:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  80944f:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809452:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809455:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809459:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  80945d:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809460:	83 f8 ff             	cmp    $0xffffffff,%eax
  809463:	75 e6                	jne    80944b <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809465:	83 ec 0c             	sub    $0xc,%esp
  809468:	68 00 08 00 00       	push   $0x800
  80946d:	e8 6c e3 ff ff       	call   8077de <htons>
  809472:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809476:	83 c4 08             	add    $0x8,%esp
  809479:	57                   	push   %edi
  80947a:	56                   	push   %esi
  80947b:	ff 56 18             	call   *0x18(%esi)
}
  80947e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809481:	5b                   	pop    %ebx
  809482:	5e                   	pop    %esi
  809483:	5f                   	pop    %edi
  809484:	5d                   	pop    %ebp
  809485:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809486:	83 ec 04             	sub    $0x4,%esp
  809489:	68 f0 28 81 00       	push   $0x8128f0
  80948e:	68 b3 01 00 00       	push   $0x1b3
  809493:	68 7a 28 81 00       	push   $0x81287a
  809498:	e8 d2 52 00 00       	call   80e76f <_panic>

0080949d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80949d:	55                   	push   %ebp
  80949e:	89 e5                	mov    %esp,%ebp
  8094a0:	57                   	push   %edi
  8094a1:	56                   	push   %esi
  8094a2:	53                   	push   %ebx
  8094a3:	83 ec 1c             	sub    $0x1c,%esp
  8094a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8094a9:	89 cb                	mov    %ecx,%ebx
  8094ab:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8094ae:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8094b1:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8094b5:	0f 85 e9 00 00 00    	jne    8095a4 <update_arp_entry+0x107>
  8094bb:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8094bd:	85 d2                	test   %edx,%edx
  8094bf:	0f 84 f6 00 00 00    	je     8095bb <update_arp_entry+0x11e>
  8094c5:	83 3a 00             	cmpl   $0x0,(%edx)
  8094c8:	0f 84 f4 00 00 00    	je     8095c2 <update_arp_entry+0x125>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8094ce:	83 ec 08             	sub    $0x8,%esp
  8094d1:	ff 75 e4             	pushl  -0x1c(%ebp)
  8094d4:	52                   	push   %edx
  8094d5:	e8 a1 d0 ff ff       	call   80657b <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  8094da:	83 c4 10             	add    $0x10,%esp
  8094dd:	84 c0                	test   %al,%al
  8094df:	0f 85 ea 00 00 00    	jne    8095cf <update_arp_entry+0x132>
      ip_addr_ismulticast(ipaddr)) {
  8094e5:	8b 3e                	mov    (%esi),%edi
  8094e7:	83 ec 0c             	sub    $0xc,%esp
  8094ea:	68 00 00 00 f0       	push   $0xf0000000
  8094ef:	e8 1b e5 ff ff       	call   807a0f <ntohl>
  8094f4:	21 c7                	and    %eax,%edi
  8094f6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8094fd:	e8 0d e5 ff ff       	call   807a0f <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809502:	83 c4 10             	add    $0x10,%esp
  809505:	39 c7                	cmp    %eax,%edi
  809507:	0f 84 c9 00 00 00    	je     8095d6 <update_arp_entry+0x139>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80950d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809511:	89 f0                	mov    %esi,%eax
  809513:	e8 72 fc ff ff       	call   80918a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809518:	84 c0                	test   %al,%al
  80951a:	0f 88 a7 00 00 00    	js     8095c7 <update_arp_entry+0x12a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809520:	0f be c0             	movsbl %al,%eax
  809523:	6b f0 1c             	imul   $0x1c,%eax,%esi
  809526:	c7 86 30 5a b3 00 02 	movl   $0x2,0xb35a30(%esi)
  80952d:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809530:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809533:	89 8e 38 5a b3 00    	mov    %ecx,0xb35a38(%esi)
  809539:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80953e:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  809543:	88 8c 16 2d 5a b3 00 	mov    %cl,0xb35a2d(%esi,%edx,1)
  80954a:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  80954d:	83 fa fa             	cmp    $0xfffffffa,%edx
  809550:	75 ec                	jne    80953e <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809552:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809555:	c6 82 34 5a b3 00 00 	movb   $0x0,0xb35a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80955c:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80955e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809561:	83 c0 25             	add    $0x25,%eax
  809564:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809567:	8b 86 20 5a b3 00    	mov    0xb35a20(%esi),%eax
  80956d:	85 c0                	test   %eax,%eax
  80956f:	74 56                	je     8095c7 <update_arp_entry+0x12a>
    arp_table[i].q = q->next;
  809571:	8b 10                	mov    (%eax),%edx
  809573:	89 96 20 5a b3 00    	mov    %edx,0xb35a20(%esi)
    p = q->p;
  809579:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  80957c:	83 ec 08             	sub    $0x8,%esp
  80957f:	50                   	push   %eax
  809580:	6a 0a                	push   $0xa
  809582:	e8 30 b0 ff ff       	call   8045b7 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809587:	89 1c 24             	mov    %ebx,(%esp)
  80958a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80958d:	89 fa                	mov    %edi,%edx
  80958f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809592:	e8 93 fe ff ff       	call   80942a <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809597:	89 3c 24             	mov    %edi,(%esp)
  80959a:	e8 65 b3 ff ff       	call   804904 <pbuf_free>
  80959f:	83 c4 10             	add    $0x10,%esp
  8095a2:	eb c3                	jmp    809567 <update_arp_entry+0xca>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8095a4:	83 ec 04             	sub    $0x4,%esp
  8095a7:	68 34 29 81 00       	push   $0x812934
  8095ac:	68 d9 01 00 00       	push   $0x1d9
  8095b1:	68 7a 28 81 00       	push   $0x81287a
  8095b6:	e8 b4 51 00 00       	call   80e76f <_panic>
    return ERR_ARG;
  8095bb:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8095c0:	eb 05                	jmp    8095c7 <update_arp_entry+0x12a>
  8095c2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  }
#endif
  return ERR_OK;
}
  8095c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8095ca:	5b                   	pop    %ebx
  8095cb:	5e                   	pop    %esi
  8095cc:	5f                   	pop    %edi
  8095cd:	5d                   	pop    %ebp
  8095ce:	c3                   	ret    
    return ERR_ARG;
  8095cf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8095d4:	eb f1                	jmp    8095c7 <update_arp_entry+0x12a>
  8095d6:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8095db:	eb ea                	jmp    8095c7 <update_arp_entry+0x12a>

008095dd <etharp_tmr>:
{
  8095dd:	55                   	push   %ebp
  8095de:	89 e5                	mov    %esp,%ebp
  8095e0:	57                   	push   %edi
  8095e1:	56                   	push   %esi
  8095e2:	53                   	push   %ebx
  8095e3:	83 ec 0c             	sub    $0xc,%esp
  8095e6:	bb 20 5a b3 00       	mov    $0xb35a20,%ebx
  8095eb:	bf 38 5b b3 00       	mov    $0xb35b38,%edi
  8095f0:	eb 1f                	jmp    809611 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  8095f2:	8b 06                	mov    (%esi),%eax
  8095f4:	85 c0                	test   %eax,%eax
  8095f6:	74 0b                	je     809603 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  8095f8:	e8 0a fb ff ff       	call   809107 <free_etharp_q>
        arp_table[i].q = NULL;
  8095fd:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809603:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80960a:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80960d:	39 fb                	cmp    %edi,%ebx
  80960f:	74 23                	je     809634 <etharp_tmr+0x57>
  809611:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  809613:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  809617:	83 c0 01             	add    $0x1,%eax
  80961a:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80961d:	8b 53 10             	mov    0x10(%ebx),%edx
  809620:	3c ef                	cmp    $0xef,%al
  809622:	76 05                	jbe    809629 <etharp_tmr+0x4c>
  809624:	83 fa 02             	cmp    $0x2,%edx
  809627:	74 c9                	je     8095f2 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809629:	3c 01                	cmp    $0x1,%al
  80962b:	76 dd                	jbe    80960a <etharp_tmr+0x2d>
  80962d:	83 fa 01             	cmp    $0x1,%edx
  809630:	75 d8                	jne    80960a <etharp_tmr+0x2d>
  809632:	eb be                	jmp    8095f2 <etharp_tmr+0x15>
}
  809634:	83 c4 0c             	add    $0xc,%esp
  809637:	5b                   	pop    %ebx
  809638:	5e                   	pop    %esi
  809639:	5f                   	pop    %edi
  80963a:	5d                   	pop    %ebp
  80963b:	c3                   	ret    

0080963c <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80963c:	55                   	push   %ebp
  80963d:	89 e5                	mov    %esp,%ebp
  80963f:	53                   	push   %ebx
  809640:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809643:	ba 02 00 00 00       	mov    $0x2,%edx
  809648:	8b 45 0c             	mov    0xc(%ebp),%eax
  80964b:	e8 3a fb ff ff       	call   80918a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809650:	84 c0                	test   %al,%al
  809652:	78 31                	js     809685 <etharp_find_addr+0x49>
  809654:	0f be d0             	movsbl %al,%edx
  809657:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80965a:	83 ba 30 5a b3 00 02 	cmpl   $0x2,0xb35a30(%edx)
  809661:	75 29                	jne    80968c <etharp_find_addr+0x50>
  809663:	0f be d0             	movsbl %al,%edx
  809666:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809669:	8d 9a 28 5a b3 00    	lea    0xb35a28(%edx),%ebx
  80966f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809672:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809674:	81 c2 24 5a b3 00    	add    $0xb35a24,%edx
  80967a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80967d:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  80967f:	83 c4 04             	add    $0x4,%esp
  809682:	5b                   	pop    %ebx
  809683:	5d                   	pop    %ebp
  809684:	c3                   	ret    
  return -1;
  809685:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80968a:	eb f3                	jmp    80967f <etharp_find_addr+0x43>
  80968c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809691:	eb ec                	jmp    80967f <etharp_find_addr+0x43>

00809693 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809693:	55                   	push   %ebp
  809694:	89 e5                	mov    %esp,%ebp
  809696:	83 ec 08             	sub    $0x8,%esp
  809699:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80969c:	85 c0                	test   %eax,%eax
  80969e:	74 13                	je     8096b3 <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  8096a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8096a3:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  8096a6:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  8096a9:	33 48 04             	xor    0x4(%eax),%ecx
  8096ac:	85 48 08             	test   %ecx,0x8(%eax)
  8096af:	74 19                	je     8096ca <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  8096b1:	c9                   	leave  
  8096b2:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8096b3:	83 ec 04             	sub    $0x4,%esp
  8096b6:	68 02 1c 81 00       	push   $0x811c02
  8096bb:	68 48 02 00 00       	push   $0x248
  8096c0:	68 7a 28 81 00       	push   $0x81287a
  8096c5:	e8 a5 50 00 00       	call   80e76f <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8096ca:	8d 4a 06             	lea    0x6(%edx),%ecx
  8096cd:	83 c2 1c             	add    $0x1c,%edx
  8096d0:	83 ec 0c             	sub    $0xc,%esp
  8096d3:	6a 00                	push   $0x0
  8096d5:	e8 c3 fd ff ff       	call   80949d <update_arp_entry>
  8096da:	83 c4 10             	add    $0x10,%esp
  8096dd:	eb d2                	jmp    8096b1 <etharp_ip_input+0x1e>

008096df <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8096df:	55                   	push   %ebp
  8096e0:	89 e5                	mov    %esp,%ebp
  8096e2:	57                   	push   %edi
  8096e3:	56                   	push   %esi
  8096e4:	53                   	push   %ebx
  8096e5:	83 ec 1c             	sub    $0x1c,%esp
  8096e8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8096eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8096ef:	74 4d                	je     80973e <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8096f1:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8096f6:	76 5d                	jbe    809755 <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8096f8:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8096fb:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8096ff:	83 ec 0c             	sub    $0xc,%esp
  809702:	6a 01                	push   $0x1
  809704:	e8 d5 e0 ff ff       	call   8077de <htons>
  809709:	83 c4 10             	add    $0x10,%esp
  80970c:	66 39 c7             	cmp    %ax,%di
  80970f:	75 19                	jne    80972a <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809711:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809715:	83 ec 0c             	sub    $0xc,%esp
  809718:	68 04 06 00 00       	push   $0x604
  80971d:	e8 bc e0 ff ff       	call   8077de <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809722:	83 c4 10             	add    $0x10,%esp
  809725:	66 39 c7             	cmp    %ax,%di
  809728:	74 39                	je     809763 <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80972a:	83 ec 0c             	sub    $0xc,%esp
  80972d:	53                   	push   %ebx
  80972e:	e8 d1 b1 ff ff       	call   804904 <pbuf_free>
    return;
  809733:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809736:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809739:	5b                   	pop    %ebx
  80973a:	5e                   	pop    %esi
  80973b:	5f                   	pop    %edi
  80973c:	5d                   	pop    %ebp
  80973d:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80973e:	83 ec 04             	sub    $0x4,%esp
  809741:	68 02 1c 81 00       	push   $0x811c02
  809746:	68 75 02 00 00       	push   $0x275
  80974b:	68 7a 28 81 00       	push   $0x81287a
  809750:	e8 1a 50 00 00       	call   80e76f <_panic>
    pbuf_free(p);
  809755:	83 ec 0c             	sub    $0xc,%esp
  809758:	53                   	push   %ebx
  809759:	e8 a6 b1 ff ff       	call   804904 <pbuf_free>
    return;
  80975e:	83 c4 10             	add    $0x10,%esp
  809761:	eb d3                	jmp    809736 <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809763:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809767:	83 ec 0c             	sub    $0xc,%esp
  80976a:	68 00 08 00 00       	push   $0x800
  80976f:	e8 6a e0 ff ff       	call   8077de <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809774:	83 c4 10             	add    $0x10,%esp
  809777:	66 39 c7             	cmp    %ax,%di
  80977a:	75 ae                	jne    80972a <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80977c:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809780:	83 ec 0c             	sub    $0xc,%esp
  809783:	68 06 08 00 00       	push   $0x806
  809788:	e8 51 e0 ff ff       	call   8077de <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80978d:	83 c4 10             	add    $0x10,%esp
  809790:	66 39 c7             	cmp    %ax,%di
  809793:	75 95                	jne    80972a <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809795:	83 ec 04             	sub    $0x4,%esp
  809798:	6a 04                	push   $0x4
  80979a:	8d 46 1c             	lea    0x1c(%esi),%eax
  80979d:	50                   	push   %eax
  80979e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8097a1:	50                   	push   %eax
  8097a2:	e8 0d 5a 00 00       	call   80f1b4 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  8097a7:	83 c4 0c             	add    $0xc,%esp
  8097aa:	6a 04                	push   $0x4
  8097ac:	8d 46 26             	lea    0x26(%esi),%eax
  8097af:	50                   	push   %eax
  8097b0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8097b3:	50                   	push   %eax
  8097b4:	e8 fb 59 00 00       	call   80f1b4 <memcpy>
  if (netif->ip_addr.addr == 0) {
  8097b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8097bc:	8b 40 04             	mov    0x4(%eax),%eax
  8097bf:	83 c4 10             	add    $0x10,%esp
  8097c2:	85 c0                	test   %eax,%eax
  8097c4:	74 05                	je     8097cb <etharp_arp_input+0xec>
  if (for_us) {
  8097c6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8097c9:	74 39                	je     809804 <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8097cb:	8d 4e 16             	lea    0x16(%esi),%ecx
  8097ce:	83 ec 0c             	sub    $0xc,%esp
  8097d1:	6a 00                	push   $0x0
  8097d3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8097d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8097d9:	e8 bf fc ff ff       	call   80949d <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8097de:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8097e2:	89 04 24             	mov    %eax,(%esp)
  8097e5:	e8 f4 df ff ff       	call   8077de <htons>
  8097ea:	83 c4 10             	add    $0x10,%esp
  8097ed:	66 83 f8 02          	cmp    $0x2,%ax
  8097f1:	74 3f                	je     809832 <etharp_arp_input+0x153>
  pbuf_free(p);
  8097f3:	83 ec 0c             	sub    $0xc,%esp
  8097f6:	53                   	push   %ebx
  8097f7:	e8 08 b1 ff ff       	call   804904 <pbuf_free>
  8097fc:	83 c4 10             	add    $0x10,%esp
  8097ff:	e9 32 ff ff ff       	jmp    809736 <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809804:	8d 4e 16             	lea    0x16(%esi),%ecx
  809807:	83 ec 0c             	sub    $0xc,%esp
  80980a:	6a 01                	push   $0x1
  80980c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80980f:	8b 45 08             	mov    0x8(%ebp),%eax
  809812:	e8 86 fc ff ff       	call   80949d <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809817:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80981b:	89 04 24             	mov    %eax,(%esp)
  80981e:	e8 bb df ff ff       	call   8077de <htons>
  809823:	83 c4 10             	add    $0x10,%esp
  809826:	66 83 f8 01          	cmp    $0x1,%ax
  80982a:	74 1a                	je     809846 <etharp_arp_input+0x167>
  80982c:	66 83 f8 02          	cmp    $0x2,%ax
  809830:	75 c1                	jne    8097f3 <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  809832:	83 ec 08             	sub    $0x8,%esp
  809835:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809838:	50                   	push   %eax
  809839:	ff 75 08             	pushl  0x8(%ebp)
  80983c:	e8 70 a1 ff ff       	call   8039b1 <dhcp_arp_reply>
    break;
  809841:	83 c4 10             	add    $0x10,%esp
  809844:	eb ad                	jmp    8097f3 <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  809846:	83 ec 0c             	sub    $0xc,%esp
  809849:	6a 02                	push   $0x2
  80984b:	e8 8e df ff ff       	call   8077de <htons>
  809850:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809854:	8b 46 1c             	mov    0x1c(%esi),%eax
  809857:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80985a:	8b 45 08             	mov    0x8(%ebp),%eax
  80985d:	8b 40 04             	mov    0x4(%eax),%eax
  809860:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809863:	83 c4 10             	add    $0x10,%esp
  809866:	8b 45 08             	mov    0x8(%ebp),%eax
  809869:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80986d:	75 0b                	jne    80987a <etharp_arp_input+0x19b>
  80986f:	8d 46 05             	lea    0x5(%esi),%eax
  809872:	8b 55 0c             	mov    0xc(%ebp),%edx
  809875:	83 c2 05             	add    $0x5,%edx
  809878:	eb 19                	jmp    809893 <etharp_arp_input+0x1b4>
  80987a:	83 ec 04             	sub    $0x4,%esp
  80987d:	68 f0 28 81 00       	push   $0x8128f0
  809882:	68 c7 02 00 00       	push   $0x2c7
  809887:	68 7a 28 81 00       	push   $0x81287a
  80988c:	e8 de 4e 00 00       	call   80e76f <_panic>
  809891:	89 c8                	mov    %ecx,%eax
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809893:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809897:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80989a:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80989c:	0f b6 0a             	movzbl (%edx),%ecx
  80989f:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  8098a2:	88 48 06             	mov    %cl,0x6(%eax)
  8098a5:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8098a8:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  8098ab:	39 f0                	cmp    %esi,%eax
  8098ad:	75 e2                	jne    809891 <etharp_arp_input+0x1b2>
      netif->linkoutput(netif, p);
  8098af:	83 ec 08             	sub    $0x8,%esp
  8098b2:	53                   	push   %ebx
  8098b3:	ff 75 08             	pushl  0x8(%ebp)
  8098b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8098b9:	ff 50 18             	call   *0x18(%eax)
  8098bc:	83 c4 10             	add    $0x10,%esp
  8098bf:	e9 2f ff ff ff       	jmp    8097f3 <etharp_arp_input+0x114>

008098c4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8098c4:	55                   	push   %ebp
  8098c5:	89 e5                	mov    %esp,%ebp
  8098c7:	57                   	push   %edi
  8098c8:	56                   	push   %esi
  8098c9:	53                   	push   %ebx
  8098ca:	83 ec 10             	sub    $0x10,%esp
  8098cd:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8098d0:	6a 00                	push   $0x0
  8098d2:	6a 2a                	push   $0x2a
  8098d4:	6a 02                	push   $0x2
  8098d6:	e8 ef b0 ff ff       	call   8049ca <pbuf_alloc>
  if (p == NULL) {
  8098db:	83 c4 10             	add    $0x10,%esp
  8098de:	85 c0                	test   %eax,%eax
  8098e0:	0f 84 f8 00 00 00    	je     8099de <etharp_request+0x11a>
  8098e6:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8098e8:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8098ed:	0f 86 bd 00 00 00    	jbe    8099b0 <etharp_request+0xec>
  hdr = p->payload;
  8098f3:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8098f6:	83 ec 0c             	sub    $0xc,%esp
  8098f9:	6a 01                	push   $0x1
  8098fb:	e8 de de ff ff       	call   8077de <htons>
  809900:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809904:	83 c4 10             	add    $0x10,%esp
  809907:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80990b:	0f 85 b6 00 00 00    	jne    8099c7 <etharp_request+0x103>
  809911:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809916:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  80991b:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80991f:	0f b6 90 dc 29 81 00 	movzbl 0x8129dc(%eax),%edx
  809926:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80992a:	0f b6 90 e4 29 81 00 	movzbl 0x8129e4(%eax),%edx
  809931:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809934:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809939:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  80993d:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809940:	83 f8 ff             	cmp    $0xffffffff,%eax
  809943:	75 d1                	jne    809916 <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809945:	8b 46 04             	mov    0x4(%esi),%eax
  809948:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80994b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80994e:	8b 00                	mov    (%eax),%eax
  809950:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809953:	83 ec 0c             	sub    $0xc,%esp
  809956:	6a 01                	push   $0x1
  809958:	e8 81 de ff ff       	call   8077de <htons>
  80995d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809961:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809968:	e8 71 de ff ff       	call   8077de <htons>
  80996d:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809971:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809978:	e8 61 de ff ff       	call   8077de <htons>
  80997d:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809981:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809988:	e8 51 de ff ff       	call   8077de <htons>
  80998d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809991:	83 c4 08             	add    $0x8,%esp
  809994:	57                   	push   %edi
  809995:	56                   	push   %esi
  809996:	ff 56 18             	call   *0x18(%esi)
  809999:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  80999b:	89 3c 24             	mov    %edi,(%esp)
  80999e:	e8 61 af ff ff       	call   804904 <pbuf_free>
  8099a3:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  8099a6:	89 d8                	mov    %ebx,%eax
  8099a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8099ab:	5b                   	pop    %ebx
  8099ac:	5e                   	pop    %esi
  8099ad:	5f                   	pop    %edi
  8099ae:	5d                   	pop    %ebp
  8099af:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8099b0:	83 ec 04             	sub    $0x4,%esp
  8099b3:	68 5c 29 81 00       	push   $0x81295c
  8099b8:	68 1c 04 00 00       	push   $0x41c
  8099bd:	68 7a 28 81 00       	push   $0x81287a
  8099c2:	e8 a8 4d 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8099c7:	83 ec 04             	sub    $0x4,%esp
  8099ca:	68 f0 28 81 00       	push   $0x8128f0
  8099cf:	68 23 04 00 00       	push   $0x423
  8099d4:	68 7a 28 81 00       	push   $0x81287a
  8099d9:	e8 91 4d 00 00       	call   80e76f <_panic>
    return ERR_MEM;
  8099de:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  8099e3:	eb c1                	jmp    8099a6 <etharp_request+0xe2>

008099e5 <etharp_query>:
{
  8099e5:	55                   	push   %ebp
  8099e6:	89 e5                	mov    %esp,%ebp
  8099e8:	57                   	push   %edi
  8099e9:	56                   	push   %esi
  8099ea:	53                   	push   %ebx
  8099eb:	83 ec 14             	sub    $0x14,%esp
  8099ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8099f1:	ff 75 08             	pushl  0x8(%ebp)
  8099f4:	53                   	push   %ebx
  8099f5:	e8 81 cb ff ff       	call   80657b <ip_addr_isbroadcast>
  8099fa:	83 c4 10             	add    $0x10,%esp
  8099fd:	84 c0                	test   %al,%al
  8099ff:	0f 85 a2 01 00 00    	jne    809ba7 <etharp_query+0x1c2>
      ip_addr_ismulticast(ipaddr) ||
  809a05:	8b 33                	mov    (%ebx),%esi
  809a07:	83 ec 0c             	sub    $0xc,%esp
  809a0a:	68 00 00 00 f0       	push   $0xf0000000
  809a0f:	e8 fb df ff ff       	call   807a0f <ntohl>
  809a14:	21 c6                	and    %eax,%esi
  809a16:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809a1d:	e8 ed df ff ff       	call   807a0f <ntohl>
  809a22:	83 c4 10             	add    $0x10,%esp
  809a25:	39 c6                	cmp    %eax,%esi
  809a27:	0f 84 84 01 00 00    	je     809bb1 <etharp_query+0x1cc>
      ip_addr_isany(ipaddr)) {
  809a2d:	83 3b 00             	cmpl   $0x0,(%ebx)
  809a30:	0f 84 85 01 00 00    	je     809bbb <etharp_query+0x1d6>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809a36:	ba 01 00 00 00       	mov    $0x1,%edx
  809a3b:	89 d8                	mov    %ebx,%eax
  809a3d:	e8 48 f7 ff ff       	call   80918a <find_entry>
  809a42:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  809a44:	84 c0                	test   %al,%al
  809a46:	0f 88 79 01 00 00    	js     809bc5 <etharp_query+0x1e0>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809a4c:	0f be f8             	movsbl %al,%edi
  809a4f:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a52:	8b 80 30 5a b3 00    	mov    0xb35a30(%eax),%eax
  809a58:	85 c0                	test   %eax,%eax
  809a5a:	75 26                	jne    809a82 <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809a5c:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a5f:	c7 80 30 5a b3 00 01 	movl   $0x1,0xb35a30(%eax)
  809a66:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809a69:	83 ec 08             	sub    $0x8,%esp
  809a6c:	53                   	push   %ebx
  809a6d:	ff 75 08             	pushl  0x8(%ebp)
  809a70:	e8 4f fe ff ff       	call   8098c4 <etharp_request>
  809a75:	89 c3                	mov    %eax,%ebx
  if (q != NULL) {
  809a77:	83 c4 10             	add    $0x10,%esp
  809a7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a7e:	74 2d                	je     809aad <etharp_query+0xc8>
  809a80:	eb 18                	jmp    809a9a <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809a82:	8d 50 ff             	lea    -0x1(%eax),%edx
  809a85:	83 fa 01             	cmp    $0x1,%edx
  809a88:	77 2d                	ja     809ab7 <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809a8a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a8e:	74 d9                	je     809a69 <etharp_query+0x84>
  809a90:	83 f8 01             	cmp    $0x1,%eax
  809a93:	74 d4                	je     809a69 <etharp_query+0x84>
  err_t result = ERR_MEM;
  809a95:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809a9a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a9d:	8b 80 30 5a b3 00    	mov    0xb35a30(%eax),%eax
  809aa3:	83 f8 02             	cmp    $0x2,%eax
  809aa6:	74 26                	je     809ace <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809aa8:	83 f8 01             	cmp    $0x1,%eax
  809aab:	74 4a                	je     809af7 <etharp_query+0x112>
}
  809aad:	89 d8                	mov    %ebx,%eax
  809aaf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809ab2:	5b                   	pop    %ebx
  809ab3:	5e                   	pop    %esi
  809ab4:	5f                   	pop    %edi
  809ab5:	5d                   	pop    %ebp
  809ab6:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809ab7:	83 ec 04             	sub    $0x4,%esp
  809aba:	68 90 29 81 00       	push   $0x812990
  809abf:	68 92 03 00 00       	push   $0x392
  809ac4:	68 7a 28 81 00       	push   $0x81287a
  809ac9:	e8 a1 4c 00 00       	call   80e76f <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809ace:	8b 45 08             	mov    0x8(%ebp),%eax
  809ad1:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809ad4:	83 ec 0c             	sub    $0xc,%esp
  809ad7:	89 f0                	mov    %esi,%eax
  809ad9:	0f be c0             	movsbl %al,%eax
  809adc:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809adf:	05 28 5a b3 00       	add    $0xb35a28,%eax
  809ae4:	50                   	push   %eax
  809ae5:	8b 55 10             	mov    0x10(%ebp),%edx
  809ae8:	8b 45 08             	mov    0x8(%ebp),%eax
  809aeb:	e8 3a f9 ff ff       	call   80942a <etharp_send_ip>
  809af0:	89 c3                	mov    %eax,%ebx
  809af2:	83 c4 10             	add    $0x10,%esp
  809af5:	eb b6                	jmp    809aad <etharp_query+0xc8>
      p = q;
  809af7:	8b 45 10             	mov    0x10(%ebp),%eax
  809afa:	eb 27                	jmp    809b23 <etharp_query+0x13e>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809afc:	83 ec 04             	sub    $0x4,%esp
  809aff:	68 d6 28 81 00       	push   $0x8128d6
  809b04:	68 b1 03 00 00       	push   $0x3b1
  809b09:	68 7a 28 81 00       	push   $0x81287a
  809b0e:	e8 5c 4c 00 00       	call   80e76f <_panic>
        if(p->type != PBUF_ROM) {
  809b13:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809b17:	75 23                	jne    809b3c <etharp_query+0x157>
        p = p->next;
  809b19:	8b 00                	mov    (%eax),%eax
      while (p) {
  809b1b:	85 c0                	test   %eax,%eax
  809b1d:	0f 84 a9 00 00 00    	je     809bcc <etharp_query+0x1e7>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809b23:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809b27:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809b2b:	75 e6                	jne    809b13 <etharp_query+0x12e>
  809b2d:	83 38 00             	cmpl   $0x0,(%eax)
  809b30:	75 ca                	jne    809afc <etharp_query+0x117>
        if(p->type != PBUF_ROM) {
  809b32:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809b36:	0f 84 90 00 00 00    	je     809bcc <etharp_query+0x1e7>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809b3c:	83 ec 04             	sub    $0x4,%esp
  809b3f:	6a 00                	push   $0x0
  809b41:	0f b7 d2             	movzwl %dx,%edx
  809b44:	52                   	push   %edx
  809b45:	6a 03                	push   $0x3
  809b47:	e8 7e ae ff ff       	call   8049ca <pbuf_alloc>
  809b4c:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809b4e:	83 c4 10             	add    $0x10,%esp
  809b51:	85 c0                	test   %eax,%eax
  809b53:	0f 84 54 ff ff ff    	je     809aad <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  809b59:	83 ec 08             	sub    $0x8,%esp
  809b5c:	ff 75 10             	pushl  0x10(%ebp)
  809b5f:	56                   	push   %esi
  809b60:	e8 47 b3 ff ff       	call   804eac <pbuf_copy>
  809b65:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809b68:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809b6b:	84 c0                	test   %al,%al
  809b6d:	74 6b                	je     809bda <etharp_query+0x1f5>
            pbuf_free(p);
  809b6f:	83 ec 0c             	sub    $0xc,%esp
  809b72:	56                   	push   %esi
  809b73:	e8 8c ad ff ff       	call   804904 <pbuf_free>
  809b78:	83 c4 10             	add    $0x10,%esp
  809b7b:	e9 2d ff ff ff       	jmp    809aad <etharp_query+0xc8>
              r = r->next;
  809b80:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809b82:	8b 11                	mov    (%ecx),%edx
  809b84:	85 d2                	test   %edx,%edx
  809b86:	75 f8                	jne    809b80 <etharp_query+0x19b>
            r->next = new_entry;
  809b88:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809b8a:	bb 00 00 00 00       	mov    $0x0,%ebx
  809b8f:	e9 19 ff ff ff       	jmp    809aad <etharp_query+0xc8>
          pbuf_free(p);
  809b94:	83 ec 0c             	sub    $0xc,%esp
  809b97:	ff 75 10             	pushl  0x10(%ebp)
  809b9a:	e8 65 ad ff ff       	call   804904 <pbuf_free>
  809b9f:	83 c4 10             	add    $0x10,%esp
  809ba2:	e9 06 ff ff ff       	jmp    809aad <etharp_query+0xc8>
    return ERR_ARG;
  809ba7:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809bac:	e9 fc fe ff ff       	jmp    809aad <etharp_query+0xc8>
  809bb1:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809bb6:	e9 f2 fe ff ff       	jmp    809aad <etharp_query+0xc8>
  809bbb:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809bc0:	e9 e8 fe ff ff       	jmp    809aad <etharp_query+0xc8>
    return (err_t)i;
  809bc5:	89 c3                	mov    %eax,%ebx
  809bc7:	e9 e1 fe ff ff       	jmp    809aad <etharp_query+0xc8>
        pbuf_ref(p);
  809bcc:	83 ec 0c             	sub    $0xc,%esp
  809bcf:	ff 75 10             	pushl  0x10(%ebp)
  809bd2:	e8 8f b1 ff ff       	call   804d66 <pbuf_ref>
  809bd7:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809bda:	83 ec 0c             	sub    $0xc,%esp
  809bdd:	6a 0a                	push   $0xa
  809bdf:	e8 7d a9 ff ff       	call   804561 <memp_malloc>
        if (new_entry != NULL) {
  809be4:	83 c4 10             	add    $0x10,%esp
  809be7:	85 c0                	test   %eax,%eax
  809be9:	74 a9                	je     809b94 <etharp_query+0x1af>
          new_entry->next = 0;
  809beb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809bf1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809bf4:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809bf7:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809bfa:	8b 8a 20 5a b3 00    	mov    0xb35a20(%edx),%ecx
  809c00:	85 c9                	test   %ecx,%ecx
  809c02:	0f 85 7a ff ff ff    	jne    809b82 <etharp_query+0x19d>
            arp_table[i].q = new_entry;
  809c08:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809c0b:	89 87 20 5a b3 00    	mov    %eax,0xb35a20(%edi)
          result = ERR_OK;
  809c11:	bb 00 00 00 00       	mov    $0x0,%ebx
  809c16:	e9 92 fe ff ff       	jmp    809aad <etharp_query+0xc8>

00809c1b <etharp_output>:
{
  809c1b:	55                   	push   %ebp
  809c1c:	89 e5                	mov    %esp,%ebp
  809c1e:	57                   	push   %edi
  809c1f:	56                   	push   %esi
  809c20:	53                   	push   %ebx
  809c21:	83 ec 24             	sub    $0x24,%esp
  809c24:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809c27:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809c2a:	6a 0e                	push   $0xe
  809c2c:	ff 75 0c             	pushl  0xc(%ebp)
  809c2f:	e8 03 ac ff ff       	call   804837 <pbuf_header>
  809c34:	83 c4 10             	add    $0x10,%esp
  809c37:	84 c0                	test   %al,%al
  809c39:	0f 85 c0 00 00 00    	jne    809cff <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809c3f:	83 ec 08             	sub    $0x8,%esp
  809c42:	53                   	push   %ebx
  809c43:	56                   	push   %esi
  809c44:	e8 32 c9 ff ff       	call   80657b <ip_addr_isbroadcast>
  809c49:	83 c4 10             	add    $0x10,%esp
  809c4c:	84 c0                	test   %al,%al
  809c4e:	0f 85 8a 00 00 00    	jne    809cde <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809c54:	8b 3e                	mov    (%esi),%edi
  809c56:	83 ec 0c             	sub    $0xc,%esp
  809c59:	68 00 00 00 f0       	push   $0xf0000000
  809c5e:	e8 ac dd ff ff       	call   807a0f <ntohl>
  809c63:	21 c7                	and    %eax,%edi
  809c65:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809c6c:	e8 9e dd ff ff       	call   807a0f <ntohl>
  809c71:	83 c4 10             	add    $0x10,%esp
  809c74:	39 c7                	cmp    %eax,%edi
  809c76:	74 25                	je     809c9d <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809c78:	8b 06                	mov    (%esi),%eax
  809c7a:	33 43 04             	xor    0x4(%ebx),%eax
  809c7d:	85 43 08             	test   %eax,0x8(%ebx)
  809c80:	74 09                	je     809c8b <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809c82:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809c86:	74 7e                	je     809d06 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809c88:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809c8b:	83 ec 04             	sub    $0x4,%esp
  809c8e:	ff 75 0c             	pushl  0xc(%ebp)
  809c91:	56                   	push   %esi
  809c92:	53                   	push   %ebx
  809c93:	e8 4d fd ff ff       	call   8099e5 <etharp_query>
  809c98:	83 c4 10             	add    $0x10,%esp
  809c9b:	eb 5a                	jmp    809cf7 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809c9d:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809ca1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809ca5:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809ca9:	83 ec 0c             	sub    $0xc,%esp
  809cac:	ff 36                	pushl  (%esi)
  809cae:	e8 5c dd ff ff       	call   807a0f <ntohl>
  809cb3:	c1 e8 10             	shr    $0x10,%eax
  809cb6:	83 e0 7f             	and    $0x7f,%eax
  809cb9:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809cbc:	83 c4 04             	add    $0x4,%esp
  809cbf:	ff 36                	pushl  (%esi)
  809cc1:	e8 49 dd ff ff       	call   807a0f <ntohl>
  809cc6:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809cc9:	83 c4 04             	add    $0x4,%esp
  809ccc:	ff 36                	pushl  (%esi)
  809cce:	e8 3c dd ff ff       	call   807a0f <ntohl>
  809cd3:	88 45 e7             	mov    %al,-0x19(%ebp)
  809cd6:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809cd9:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809cdc:	eb 05                	jmp    809ce3 <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809cde:	b8 e4 29 81 00       	mov    $0x8129e4,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809ce3:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809ce6:	83 ec 0c             	sub    $0xc,%esp
  809ce9:	50                   	push   %eax
  809cea:	8b 55 0c             	mov    0xc(%ebp),%edx
  809ced:	89 d8                	mov    %ebx,%eax
  809cef:	e8 36 f7 ff ff       	call   80942a <etharp_send_ip>
  809cf4:	83 c4 10             	add    $0x10,%esp
}
  809cf7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809cfa:	5b                   	pop    %ebx
  809cfb:	5e                   	pop    %esi
  809cfc:	5f                   	pop    %edi
  809cfd:	5d                   	pop    %ebp
  809cfe:	c3                   	ret    
    return ERR_BUF;
  809cff:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809d04:	eb f1                	jmp    809cf7 <etharp_output+0xdc>
        return ERR_RTE;
  809d06:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809d0b:	eb ea                	jmp    809cf7 <etharp_output+0xdc>

00809d0d <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809d0d:	55                   	push   %ebp
  809d0e:	89 e5                	mov    %esp,%ebp
  809d10:	56                   	push   %esi
  809d11:	53                   	push   %ebx
  809d12:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809d15:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809d18:	83 ec 0c             	sub    $0xc,%esp
  809d1b:	8b 43 04             	mov    0x4(%ebx),%eax
  809d1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809d22:	50                   	push   %eax
  809d23:	e8 b6 da ff ff       	call   8077de <htons>
  809d28:	83 c4 10             	add    $0x10,%esp
  809d2b:	66 3d 00 08          	cmp    $0x800,%ax
  809d2f:	74 14                	je     809d45 <ethernet_input+0x38>
  809d31:	66 3d 06 08          	cmp    $0x806,%ax
  809d35:	74 50                	je     809d87 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809d37:	83 ec 0c             	sub    $0xc,%esp
  809d3a:	53                   	push   %ebx
  809d3b:	e8 c4 ab ff ff       	call   804904 <pbuf_free>
      p = NULL;
      break;
  809d40:	83 c4 10             	add    $0x10,%esp
  809d43:	eb 53                	jmp    809d98 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809d45:	83 ec 08             	sub    $0x8,%esp
  809d48:	53                   	push   %ebx
  809d49:	56                   	push   %esi
  809d4a:	e8 44 f9 ff ff       	call   809693 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809d4f:	83 c4 08             	add    $0x8,%esp
  809d52:	6a f2                	push   $0xfffffff2
  809d54:	53                   	push   %ebx
  809d55:	e8 dd aa ff ff       	call   804837 <pbuf_header>
  809d5a:	83 c4 10             	add    $0x10,%esp
  809d5d:	84 c0                	test   %al,%al
  809d5f:	75 0f                	jne    809d70 <ethernet_input+0x63>
        ip_input(p, netif);
  809d61:	83 ec 08             	sub    $0x8,%esp
  809d64:	56                   	push   %esi
  809d65:	53                   	push   %ebx
  809d66:	e8 b0 c8 ff ff       	call   80661b <ip_input>
      break;
  809d6b:	83 c4 10             	add    $0x10,%esp
  809d6e:	eb 28                	jmp    809d98 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809d70:	83 ec 04             	sub    $0x4,%esp
  809d73:	68 b8 29 81 00       	push   $0x8129b8
  809d78:	68 7e 04 00 00       	push   $0x47e
  809d7d:	68 7a 28 81 00       	push   $0x81287a
  809d82:	e8 e8 49 00 00       	call   80e76f <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809d87:	83 ec 04             	sub    $0x4,%esp
  809d8a:	53                   	push   %ebx
  809d8b:	8d 46 25             	lea    0x25(%esi),%eax
  809d8e:	50                   	push   %eax
  809d8f:	56                   	push   %esi
  809d90:	e8 4a f9 ff ff       	call   8096df <etharp_arp_input>
      break;
  809d95:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809d98:	b8 00 00 00 00       	mov    $0x0,%eax
  809d9d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809da0:	5b                   	pop    %ebx
  809da1:	5e                   	pop    %esi
  809da2:	5d                   	pop    %ebp
  809da3:	c3                   	ret    

00809da4 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809da4:	55                   	push   %ebp
  809da5:	89 e5                	mov    %esp,%ebp
  809da7:	53                   	push   %ebx
  809da8:	83 ec 10             	sub    $0x10,%esp
  809dab:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809dae:	ff 73 04             	pushl  0x4(%ebx)
  809db1:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809db3:	89 1c 24             	mov    %ebx,(%esp)
  809db6:	e8 66 6b 00 00       	call   810921 <free>
}
  809dbb:	83 c4 10             	add    $0x10,%esp
  809dbe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809dc1:	c9                   	leave  
  809dc2:	c3                   	ret    

00809dc3 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809dc3:	55                   	push   %ebp
  809dc4:	89 e5                	mov    %esp,%ebp
  809dc6:	83 ec 08             	sub    $0x8,%esp
  809dc9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809dcc:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809dd1:	89 c8                	mov    %ecx,%eax
  809dd3:	f7 e2                	mul    %edx
  809dd5:	c1 ea 08             	shr    $0x8,%edx
  809dd8:	89 d0                	mov    %edx,%eax
  809dda:	c1 e0 08             	shl    $0x8,%eax
  809ddd:	01 c2                	add    %eax,%edx
  809ddf:	89 c8                	mov    %ecx,%eax
  809de1:	29 d0                	sub    %edx,%eax
  809de3:	8b 04 85 40 5b b3 00 	mov    0xb35b40(,%eax,4),%eax
  809dea:	85 c0                	test   %eax,%eax
  809dec:	74 2a                	je     809e18 <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809dee:	39 08                	cmp    %ecx,(%eax)
  809df0:	74 05                	je     809df7 <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809df2:	8b 40 08             	mov    0x8(%eax),%eax
  809df5:	eb f3                	jmp    809dea <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809df7:	8b 50 08             	mov    0x8(%eax),%edx
  809dfa:	85 d2                	test   %edx,%edx
  809dfc:	74 06                	je     809e04 <timeout_cleanup+0x41>
  809dfe:	8b 48 0c             	mov    0xc(%eax),%ecx
  809e01:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809e04:	8b 50 0c             	mov    0xc(%eax),%edx
  809e07:	8b 48 08             	mov    0x8(%eax),%ecx
  809e0a:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809e0c:	83 ec 0c             	sub    $0xc,%esp
  809e0f:	50                   	push   %eax
  809e10:	e8 0c 6b 00 00       	call   810921 <free>
	    goto done;
  809e15:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809e18:	c9                   	leave  
  809e19:	c3                   	ret    

00809e1a <sys_init>:
{
  809e1a:	55                   	push   %ebp
  809e1b:	89 e5                	mov    %esp,%ebp
  809e1d:	56                   	push   %esi
  809e1e:	53                   	push   %ebx
  809e1f:	8b 15 60 ad b3 00    	mov    0xb3ad60,%edx
  809e25:	b8 80 ad b3 00       	mov    $0xb3ad80,%eax
  809e2a:	be 80 c1 b3 00       	mov    $0xb3c180,%esi
  809e2f:	eb 10                	jmp    809e41 <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809e31:	c7 41 10 60 ad b3 00 	movl   $0xb3ad60,0x10(%ecx)
  809e38:	83 c0 14             	add    $0x14,%eax
  809e3b:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809e3d:	39 f0                	cmp    %esi,%eax
  809e3f:	74 17                	je     809e58 <sys_init+0x3e>
  809e41:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809e43:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809e49:	89 50 0c             	mov    %edx,0xc(%eax)
  809e4c:	85 d2                	test   %edx,%edx
  809e4e:	74 e1                	je     809e31 <sys_init+0x17>
  809e50:	8d 58 0c             	lea    0xc(%eax),%ebx
  809e53:	89 5a 10             	mov    %ebx,0x10(%edx)
  809e56:	eb d9                	jmp    809e31 <sys_init+0x17>
  809e58:	c7 05 60 ad b3 00 6c 	movl   $0xb3c16c,0xb3ad60
  809e5f:	c1 b3 00 
  809e62:	8b 15 44 5f b3 00    	mov    0xb35f44,%edx
  809e68:	b8 60 5f b3 00       	mov    $0xb35f60,%eax
  809e6d:	be 60 ad b3 00       	mov    $0xb3ad60,%esi
  809e72:	eb 15                	jmp    809e89 <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809e74:	c7 81 98 00 00 00 44 	movl   $0xb35f44,0x98(%ecx)
  809e7b:	5f b3 00 
  809e7e:	05 9c 00 00 00       	add    $0x9c,%eax
  809e83:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809e85:	39 f0                	cmp    %esi,%eax
  809e87:	74 20                	je     809ea9 <sys_init+0x8f>
  809e89:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809e8b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809e91:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809e97:	85 d2                	test   %edx,%edx
  809e99:	74 d9                	je     809e74 <sys_init+0x5a>
  809e9b:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809ea1:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809ea7:	eb cb                	jmp    809e74 <sys_init+0x5a>
  809ea9:	c7 05 44 5f b3 00 c4 	movl   $0xb3acc4,0xb35f44
  809eb0:	ac b3 00 
}
  809eb3:	5b                   	pop    %ebx
  809eb4:	5e                   	pop    %esi
  809eb5:	5d                   	pop    %ebp
  809eb6:	c3                   	ret    

00809eb7 <sys_sem_new>:
{
  809eb7:	55                   	push   %ebp
  809eb8:	89 e5                	mov    %esp,%ebp
  809eba:	53                   	push   %ebx
  809ebb:	83 ec 04             	sub    $0x4,%esp
  809ebe:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809ec1:	a1 60 ad b3 00       	mov    0xb3ad60,%eax
    if (!se) {
  809ec6:	85 c0                	test   %eax,%eax
  809ec8:	74 3e                	je     809f08 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809eca:	8b 48 0c             	mov    0xc(%eax),%ecx
  809ecd:	85 c9                	test   %ecx,%ecx
  809ecf:	74 06                	je     809ed7 <sys_sem_new+0x20>
  809ed1:	8b 58 10             	mov    0x10(%eax),%ebx
  809ed4:	89 59 10             	mov    %ebx,0x10(%ecx)
  809ed7:	8b 48 10             	mov    0x10(%eax),%ecx
  809eda:	8b 58 0c             	mov    0xc(%eax),%ebx
  809edd:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809edf:	83 38 00             	cmpl   $0x0,(%eax)
  809ee2:	74 3b                	je     809f1f <sys_sem_new+0x68>
    se->freed = 0;
  809ee4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809eea:	0f b6 d2             	movzbl %dl,%edx
  809eed:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809ef1:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809ef5:	2d 80 ad b3 00       	sub    $0xb3ad80,%eax
  809efa:	c1 f8 02             	sar    $0x2,%eax
  809efd:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809f03:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809f06:	c9                   	leave  
  809f07:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809f08:	83 ec 0c             	sub    $0xc,%esp
  809f0b:	68 ec 29 81 00       	push   $0x8129ec
  809f10:	e8 50 49 00 00       	call   80e865 <cprintf>
	return SYS_SEM_NULL;
  809f15:	83 c4 10             	add    $0x10,%esp
  809f18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f1d:	eb e4                	jmp    809f03 <sys_sem_new+0x4c>
    assert(se->freed);
  809f1f:	68 61 2b 81 00       	push   $0x812b61
  809f24:	68 6b 2b 81 00       	push   $0x812b6b
  809f29:	68 8d 00 00 00       	push   $0x8d
  809f2e:	68 80 2b 81 00       	push   $0x812b80
  809f33:	e8 37 48 00 00       	call   80e76f <_panic>

00809f38 <sys_sem_free>:
{
  809f38:	55                   	push   %ebp
  809f39:	89 e5                	mov    %esp,%ebp
  809f3b:	83 ec 08             	sub    $0x8,%esp
  809f3e:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809f41:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f44:	83 3c 95 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%edx,4)
  809f4b:	00 
  809f4c:	75 5a                	jne    809fa8 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809f4e:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809f51:	c1 e2 02             	shl    $0x2,%edx
  809f54:	8d 8a 80 ad b3 00    	lea    0xb3ad80(%edx),%ecx
  809f5a:	c7 82 80 ad b3 00 01 	movl   $0x1,0xb3ad80(%edx)
  809f61:	00 00 00 
    sems[sem].gen++;
  809f64:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809f68:	8b 15 60 ad b3 00    	mov    0xb3ad60,%edx
  809f6e:	89 51 0c             	mov    %edx,0xc(%ecx)
  809f71:	85 d2                	test   %edx,%edx
  809f73:	74 0d                	je     809f82 <sys_sem_free+0x4a>
  809f75:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809f78:	8d 0c 8d 8c ad b3 00 	lea    0xb3ad8c(,%ecx,4),%ecx
  809f7f:	89 4a 10             	mov    %ecx,0x10(%edx)
  809f82:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809f89:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809f8c:	8d 0c 8d 80 ad b3 00 	lea    0xb3ad80(,%ecx,4),%ecx
  809f93:	89 0d 60 ad b3 00    	mov    %ecx,0xb3ad60
  809f99:	01 d0                	add    %edx,%eax
  809f9b:	c7 04 85 90 ad b3 00 	movl   $0xb3ad60,0xb3ad90(,%eax,4)
  809fa2:	60 ad b3 00 
}
  809fa6:	c9                   	leave  
  809fa7:	c3                   	ret    
    assert(!sems[sem].freed);
  809fa8:	68 9d 2b 81 00       	push   $0x812b9d
  809fad:	68 6b 2b 81 00       	push   $0x812b6b
  809fb2:	68 98 00 00 00       	push   $0x98
  809fb7:	68 80 2b 81 00       	push   $0x812b80
  809fbc:	e8 ae 47 00 00       	call   80e76f <_panic>

00809fc1 <sys_mbox_free>:
{
  809fc1:	55                   	push   %ebp
  809fc2:	89 e5                	mov    %esp,%ebp
  809fc4:	56                   	push   %esi
  809fc5:	53                   	push   %ebx
  809fc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809fc9:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809fcf:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  809fd6:	75 72                	jne    80a04a <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809fd8:	83 ec 0c             	sub    $0xc,%esp
  809fdb:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809fe1:	ff b6 ec 5f b3 00    	pushl  0xb35fec(%esi)
  809fe7:	e8 4c ff ff ff       	call   809f38 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809fec:	83 c4 04             	add    $0x4,%esp
  809fef:	ff b6 f0 5f b3 00    	pushl  0xb35ff0(%esi)
  809ff5:	e8 3e ff ff ff       	call   809f38 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809ffa:	a1 44 5f b3 00       	mov    0xb35f44,%eax
  809fff:	89 86 f4 5f b3 00    	mov    %eax,0xb35ff4(%esi)
  80a005:	83 c4 10             	add    $0x10,%esp
  80a008:	85 c0                	test   %eax,%eax
  80a00a:	74 12                	je     80a01e <sys_mbox_free+0x5d>
  80a00c:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a012:	81 c2 f4 5f b3 00    	add    $0xb35ff4,%edx
  80a018:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a01e:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a024:	8d 83 60 5f b3 00    	lea    0xb35f60(%ebx),%eax
  80a02a:	a3 44 5f b3 00       	mov    %eax,0xb35f44
  80a02f:	c7 83 f8 5f b3 00 44 	movl   $0xb35f44,0xb35ff8(%ebx)
  80a036:	5f b3 00 
    mboxes[mbox].freed = 1;
  80a039:	c7 83 60 5f b3 00 01 	movl   $0x1,0xb35f60(%ebx)
  80a040:	00 00 00 
}
  80a043:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a046:	5b                   	pop    %ebx
  80a047:	5e                   	pop    %esi
  80a048:	5d                   	pop    %ebp
  80a049:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a04a:	68 ae 2b 81 00       	push   $0x812bae
  80a04f:	68 6b 2b 81 00       	push   $0x812b6b
  80a054:	6a 62                	push   $0x62
  80a056:	68 80 2b 81 00       	push   $0x812b80
  80a05b:	e8 0f 47 00 00       	call   80e76f <_panic>

0080a060 <sys_mbox_new>:
{
  80a060:	55                   	push   %ebp
  80a061:	89 e5                	mov    %esp,%ebp
  80a063:	57                   	push   %edi
  80a064:	56                   	push   %esi
  80a065:	53                   	push   %ebx
  80a066:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a069:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a06d:	0f 8f 9f 00 00 00    	jg     80a112 <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a073:	8b 1d 44 5f b3 00    	mov    0xb35f44,%ebx
    if (!mbe) {
  80a079:	85 db                	test   %ebx,%ebx
  80a07b:	0f 84 a7 00 00 00    	je     80a128 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  80a081:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a087:	85 c0                	test   %eax,%eax
  80a089:	74 0c                	je     80a097 <sys_mbox_new+0x37>
  80a08b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a091:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a097:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a09d:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a0a3:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a0a5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a0a8:	0f 84 91 00 00 00    	je     80a13f <sys_mbox_new+0xdf>
    mbe->freed = 0;
  80a0ae:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a0b4:	89 de                	mov    %ebx,%esi
  80a0b6:	81 ee 60 5f b3 00    	sub    $0xb35f60,%esi
  80a0bc:	c1 fe 02             	sar    $0x2,%esi
  80a0bf:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a0c5:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a0c7:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a0ce:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a0d5:	83 ec 0c             	sub    $0xc,%esp
  80a0d8:	6a 00                	push   $0x0
  80a0da:	e8 d8 fd ff ff       	call   809eb7 <sys_sem_new>
  80a0df:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a0e5:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a0ec:	e8 c6 fd ff ff       	call   809eb7 <sys_sem_new>
  80a0f1:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a0f7:	83 c4 10             	add    $0x10,%esp
  80a0fa:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a101:	74 52                	je     80a155 <sys_mbox_new+0xf5>
  80a103:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a106:	74 4d                	je     80a155 <sys_mbox_new+0xf5>
}
  80a108:	89 f8                	mov    %edi,%eax
  80a10a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a10d:	5b                   	pop    %ebx
  80a10e:	5e                   	pop    %esi
  80a10f:	5f                   	pop    %edi
  80a110:	5d                   	pop    %ebp
  80a111:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a112:	68 c2 2b 81 00       	push   $0x812bc2
  80a117:	68 6b 2b 81 00       	push   $0x812b6b
  80a11c:	6a 45                	push   $0x45
  80a11e:	68 80 2b 81 00       	push   $0x812b80
  80a123:	e8 47 46 00 00       	call   80e76f <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a128:	83 ec 0c             	sub    $0xc,%esp
  80a12b:	68 14 2a 81 00       	push   $0x812a14
  80a130:	e8 30 47 00 00       	call   80e865 <cprintf>
	return SYS_MBOX_NULL;
  80a135:	83 c4 10             	add    $0x10,%esp
  80a138:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a13d:	eb c9                	jmp    80a108 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a13f:	68 d3 2b 81 00       	push   $0x812bd3
  80a144:	68 6b 2b 81 00       	push   $0x812b6b
  80a149:	6a 4c                	push   $0x4c
  80a14b:	68 80 2b 81 00       	push   $0x812b80
  80a150:	e8 1a 46 00 00       	call   80e76f <_panic>
	sys_mbox_free(i);
  80a155:	83 ec 0c             	sub    $0xc,%esp
  80a158:	56                   	push   %esi
  80a159:	e8 63 fe ff ff       	call   809fc1 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a15e:	c7 04 24 3c 2a 81 00 	movl   $0x812a3c,(%esp)
  80a165:	e8 fb 46 00 00       	call   80e865 <cprintf>
	return SYS_MBOX_NULL;
  80a16a:	83 c4 10             	add    $0x10,%esp
  80a16d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a172:	eb 94                	jmp    80a108 <sys_mbox_new+0xa8>

0080a174 <sys_sem_signal>:
{
  80a174:	55                   	push   %ebp
  80a175:	89 e5                	mov    %esp,%ebp
  80a177:	83 ec 08             	sub    $0x8,%esp
  80a17a:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a17d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a180:	83 3c 95 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%edx,4)
  80a187:	00 
  80a188:	75 18                	jne    80a1a2 <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a18a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a18d:	8d 14 95 80 ad b3 00 	lea    0xb3ad80(,%edx,4),%edx
  80a194:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a199:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a19e:	75 1b                	jne    80a1bb <sys_sem_signal+0x47>
}
  80a1a0:	c9                   	leave  
  80a1a1:	c3                   	ret    
    assert(!sems[sem].freed);
  80a1a2:	68 9d 2b 81 00       	push   $0x812b9d
  80a1a7:	68 6b 2b 81 00       	push   $0x812b6b
  80a1ac:	68 a1 00 00 00       	push   $0xa1
  80a1b1:	68 80 2b 81 00       	push   $0x812b80
  80a1b6:	e8 b4 45 00 00       	call   80e76f <_panic>
	sems[sem].waiters = 0;
  80a1bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a1c2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a1c5:	66 c7 04 8d 8a ad b3 	movw   $0x0,0xb3ad8a(,%ecx,4)
  80a1cc:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a1cf:	83 ec 0c             	sub    $0xc,%esp
  80a1d2:	8d 04 8d 88 ad b3 00 	lea    0xb3ad88(,%ecx,4),%eax
  80a1d9:	50                   	push   %eax
  80a1da:	e8 a4 04 00 00       	call   80a683 <thread_wakeup>
  80a1df:	83 c4 10             	add    $0x10,%esp
}
  80a1e2:	eb bc                	jmp    80a1a0 <sys_sem_signal+0x2c>

0080a1e4 <sys_arch_sem_wait>:
{
  80a1e4:	55                   	push   %ebp
  80a1e5:	89 e5                	mov    %esp,%ebp
  80a1e7:	57                   	push   %edi
  80a1e8:	56                   	push   %esi
  80a1e9:	53                   	push   %ebx
  80a1ea:	83 ec 1c             	sub    $0x1c,%esp
  80a1ed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a1f0:	8b 45 08             	mov    0x8(%ebp),%eax
  80a1f3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a1f6:	83 3c 85 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%eax,4)
  80a1fd:	00 
  80a1fe:	75 2c                	jne    80a22c <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a200:	8b 45 08             	mov    0x8(%ebp),%eax
  80a203:	c1 e0 02             	shl    $0x2,%eax
  80a206:	89 c2                	mov    %eax,%edx
  80a208:	03 55 08             	add    0x8(%ebp),%edx
  80a20b:	8b 3c 95 84 ad b3 00 	mov    0xb3ad84(,%edx,4),%edi
  80a212:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a215:	8d 04 95 88 ad b3 00 	lea    0xb3ad88(,%edx,4),%eax
  80a21c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a21f:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a224:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a227:	e9 80 00 00 00       	jmp    80a2ac <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a22c:	68 9d 2b 81 00       	push   $0x812b9d
  80a231:	68 6b 2b 81 00       	push   $0x812b6b
  80a236:	68 ac 00 00 00       	push   $0xac
  80a23b:	68 80 2b 81 00       	push   $0x812b80
  80a240:	e8 2a 45 00 00       	call   80e76f <_panic>
	if (sems[sem].counter > 0) {
  80a245:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a248:	0f b7 04 85 88 ad b3 	movzwl 0xb3ad88(,%eax,4),%eax
  80a24f:	00 
  80a250:	66 85 c0             	test   %ax,%ax
  80a253:	75 6e                	jne    80a2c3 <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a255:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a258:	0f 84 8f 00 00 00    	je     80a2ed <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a25e:	e8 85 53 00 00       	call   80f5e8 <sys_time_msec>
  80a263:	89 c1                	mov    %eax,%ecx
  80a265:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a268:	89 d8                	mov    %ebx,%eax
  80a26a:	29 f8                	sub    %edi,%eax
  80a26c:	01 c8                	add    %ecx,%eax
  80a26e:	85 db                	test   %ebx,%ebx
  80a270:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a275:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a278:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a27b:	8d 34 95 80 ad b3 00 	lea    0xb3ad80(,%edx,4),%esi
  80a282:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a288:	83 ec 04             	sub    $0x4,%esp
  80a28b:	50                   	push   %eax
  80a28c:	ff 76 08             	pushl  0x8(%esi)
  80a28f:	ff 75 dc             	pushl  -0x24(%ebp)
  80a292:	e8 02 06 00 00       	call   80a899 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a297:	83 c4 10             	add    $0x10,%esp
  80a29a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a29d:	39 46 04             	cmp    %eax,0x4(%esi)
  80a2a0:	75 34                	jne    80a2d6 <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a2a2:	e8 41 53 00 00       	call   80f5e8 <sys_time_msec>
	    waited += (b - a);
  80a2a7:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a2aa:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a2ac:	85 db                	test   %ebx,%ebx
  80a2ae:	74 95                	je     80a245 <sys_arch_sem_wait+0x61>
  80a2b0:	39 df                	cmp    %ebx,%edi
  80a2b2:	72 91                	jb     80a245 <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a2b4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a2b9:	89 f8                	mov    %edi,%eax
  80a2bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a2be:	5b                   	pop    %ebx
  80a2bf:	5e                   	pop    %esi
  80a2c0:	5f                   	pop    %edi
  80a2c1:	5d                   	pop    %ebp
  80a2c2:	c3                   	ret    
	    sems[sem].counter--;
  80a2c3:	8b 55 08             	mov    0x8(%ebp),%edx
  80a2c6:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a2c9:	83 e8 01             	sub    $0x1,%eax
  80a2cc:	66 89 04 95 88 ad b3 	mov    %ax,0xb3ad88(,%edx,4)
  80a2d3:	00 
	    return waited;
  80a2d4:	eb e3                	jmp    80a2b9 <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a2d6:	83 ec 0c             	sub    $0xc,%esp
  80a2d9:	68 68 2a 81 00       	push   $0x812a68
  80a2de:	e8 82 45 00 00       	call   80e865 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a2e3:	83 c4 10             	add    $0x10,%esp
  80a2e6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a2eb:	eb cc                	jmp    80a2b9 <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a2ed:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a2f2:	eb c5                	jmp    80a2b9 <sys_arch_sem_wait+0xd5>

0080a2f4 <sys_mbox_trypost>:
{
  80a2f4:	55                   	push   %ebp
  80a2f5:	89 e5                	mov    %esp,%ebp
  80a2f7:	57                   	push   %edi
  80a2f8:	56                   	push   %esi
  80a2f9:	53                   	push   %ebx
  80a2fa:	83 ec 0c             	sub    $0xc,%esp
  80a2fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a300:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a306:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a30d:	75 7f                	jne    80a38e <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a30f:	83 ec 08             	sub    $0x8,%esp
  80a312:	6a 00                	push   $0x0
  80a314:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a31a:	ff b6 f0 5f b3 00    	pushl  0xb35ff0(%esi)
  80a320:	e8 bf fe ff ff       	call   80a1e4 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a325:	8b 96 68 5f b3 00    	mov    0xb35f68(%esi),%edx
  80a32b:	8b 8e 64 5f b3 00    	mov    0xb35f64(%esi),%ecx
  80a331:	83 c4 10             	add    $0x10,%esp
  80a334:	39 ca                	cmp    %ecx,%edx
  80a336:	74 7a                	je     80a3b2 <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a338:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a33e:	8d 42 01             	lea    0x1(%edx),%eax
  80a341:	89 c7                	mov    %eax,%edi
  80a343:	c1 ff 1f             	sar    $0x1f,%edi
  80a346:	c1 ef 1b             	shr    $0x1b,%edi
  80a349:	01 f8                	add    %edi,%eax
  80a34b:	83 e0 1f             	and    $0x1f,%eax
  80a34e:	29 f8                	sub    %edi,%eax
  80a350:	89 86 68 5f b3 00    	mov    %eax,0xb35f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a356:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a359:	01 d0                	add    %edx,%eax
  80a35b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a35e:	89 34 85 6c 5f b3 00 	mov    %esi,0xb35f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a365:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a368:	74 3a                	je     80a3a4 <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a36a:	83 ec 0c             	sub    $0xc,%esp
  80a36d:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a373:	ff b3 ec 5f b3 00    	pushl  0xb35fec(%ebx)
  80a379:	e8 f6 fd ff ff       	call   80a174 <sys_sem_signal>
    return ERR_OK;
  80a37e:	83 c4 10             	add    $0x10,%esp
  80a381:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a386:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a389:	5b                   	pop    %ebx
  80a38a:	5e                   	pop    %esi
  80a38b:	5f                   	pop    %edi
  80a38c:	5d                   	pop    %ebp
  80a38d:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a38e:	68 ae 2b 81 00       	push   $0x812bae
  80a393:	68 6b 2b 81 00       	push   $0x812b6b
  80a398:	6a 72                	push   $0x72
  80a39a:	68 80 2b 81 00       	push   $0x812b80
  80a39f:	e8 cb 43 00 00       	call   80e76f <_panic>
	mboxes[mbox].head = slot;
  80a3a4:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3aa:	89 90 64 5f b3 00    	mov    %edx,0xb35f64(%eax)
  80a3b0:	eb b8                	jmp    80a36a <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a3b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a3b7:	eb cd                	jmp    80a386 <sys_mbox_trypost+0x92>

0080a3b9 <sys_mbox_post>:
{
  80a3b9:	55                   	push   %ebp
  80a3ba:	89 e5                	mov    %esp,%ebp
  80a3bc:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a3bf:	ff 75 0c             	pushl  0xc(%ebp)
  80a3c2:	ff 75 08             	pushl  0x8(%ebp)
  80a3c5:	e8 2a ff ff ff       	call   80a2f4 <sys_mbox_trypost>
  80a3ca:	83 c4 10             	add    $0x10,%esp
  80a3cd:	84 c0                	test   %al,%al
  80a3cf:	75 02                	jne    80a3d3 <sys_mbox_post+0x1a>
}
  80a3d1:	c9                   	leave  
  80a3d2:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a3d3:	68 94 2a 81 00       	push   $0x812a94
  80a3d8:	68 6b 2b 81 00       	push   $0x812b6b
  80a3dd:	6a 6c                	push   $0x6c
  80a3df:	68 80 2b 81 00       	push   $0x812b80
  80a3e4:	e8 86 43 00 00       	call   80e76f <_panic>

0080a3e9 <sys_arch_mbox_fetch>:
{
  80a3e9:	55                   	push   %ebp
  80a3ea:	89 e5                	mov    %esp,%ebp
  80a3ec:	57                   	push   %edi
  80a3ed:	56                   	push   %esi
  80a3ee:	53                   	push   %ebx
  80a3ef:	83 ec 0c             	sub    $0xc,%esp
  80a3f2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a3f5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a3f8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3fe:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a405:	0f 85 8a 00 00 00    	jne    80a495 <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a40b:	83 ec 08             	sub    $0x8,%esp
  80a40e:	ff 75 10             	pushl  0x10(%ebp)
  80a411:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a417:	ff b0 ec 5f b3 00    	pushl  0xb35fec(%eax)
  80a41d:	e8 c2 fd ff ff       	call   80a1e4 <sys_arch_sem_wait>
  80a422:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a424:	83 c4 10             	add    $0x10,%esp
  80a427:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a42a:	74 5f                	je     80a48b <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a42c:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a432:	8b 80 64 5f b3 00    	mov    0xb35f64(%eax),%eax
    if (slot == -1)
  80a438:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a43b:	74 71                	je     80a4ae <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a43d:	85 ff                	test   %edi,%edi
  80a43f:	74 0e                	je     80a44f <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a441:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a444:	01 c2                	add    %eax,%edx
  80a446:	8b 14 95 6c 5f b3 00 	mov    0xb35f6c(,%edx,4),%edx
  80a44d:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a44f:	83 c0 01             	add    $0x1,%eax
  80a452:	99                   	cltd   
  80a453:	c1 ea 1b             	shr    $0x1b,%edx
  80a456:	01 d0                	add    %edx,%eax
  80a458:	83 e0 1f             	and    $0x1f,%eax
  80a45b:	29 d0                	sub    %edx,%eax
  80a45d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a463:	89 82 64 5f b3 00    	mov    %eax,0xb35f64(%edx)
  80a469:	81 c2 60 5f b3 00    	add    $0xb35f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a46f:	3b 42 08             	cmp    0x8(%edx),%eax
  80a472:	74 51                	je     80a4c5 <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a474:	83 ec 0c             	sub    $0xc,%esp
  80a477:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a47d:	ff b3 f0 5f b3 00    	pushl  0xb35ff0(%ebx)
  80a483:	e8 ec fc ff ff       	call   80a174 <sys_sem_signal>
    return waited;
  80a488:	83 c4 10             	add    $0x10,%esp
}
  80a48b:	89 f0                	mov    %esi,%eax
  80a48d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a490:	5b                   	pop    %ebx
  80a491:	5e                   	pop    %esi
  80a492:	5f                   	pop    %edi
  80a493:	5d                   	pop    %ebp
  80a494:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a495:	68 ae 2b 81 00       	push   $0x812bae
  80a49a:	68 6b 2b 81 00       	push   $0x812b6b
  80a49f:	68 ce 00 00 00       	push   $0xce
  80a4a4:	68 80 2b 81 00       	push   $0x812b80
  80a4a9:	e8 c1 42 00 00       	call   80e76f <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a4ae:	83 ec 04             	sub    $0x4,%esp
  80a4b1:	68 bc 2a 81 00       	push   $0x812abc
  80a4b6:	68 d6 00 00 00       	push   $0xd6
  80a4bb:	68 80 2b 81 00       	push   $0x812b80
  80a4c0:	e8 aa 42 00 00       	call   80e76f <_panic>
	mboxes[mbox].head = -1;
  80a4c5:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a4cb:	c7 80 64 5f b3 00 ff 	movl   $0xffffffff,0xb35f64(%eax)
  80a4d2:	ff ff ff 
  80a4d5:	eb 9d                	jmp    80a474 <sys_arch_mbox_fetch+0x8b>

0080a4d7 <sys_arch_mbox_tryfetch>:
{
  80a4d7:	55                   	push   %ebp
  80a4d8:	89 e5                	mov    %esp,%ebp
  80a4da:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a4dd:	6a fe                	push   $0xfffffffe
  80a4df:	ff 75 0c             	pushl  0xc(%ebp)
  80a4e2:	ff 75 08             	pushl  0x8(%ebp)
  80a4e5:	e8 ff fe ff ff       	call   80a3e9 <sys_arch_mbox_fetch>
}
  80a4ea:	c9                   	leave  
  80a4eb:	c3                   	ret    

0080a4ec <sys_thread_new>:
{
  80a4ec:	55                   	push   %ebp
  80a4ed:	89 e5                	mov    %esp,%ebp
  80a4ef:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a4f2:	6a 08                	push   $0x8
  80a4f4:	e8 d4 64 00 00       	call   8109cd <malloc>
    if (lt == 0)
  80a4f9:	83 c4 10             	add    $0x10,%esp
  80a4fc:	85 c0                	test   %eax,%eax
  80a4fe:	74 32                	je     80a532 <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a500:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a507:	7f 40                	jg     80a549 <sys_thread_new+0x5d>
    lt->func = thread;
  80a509:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a50c:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a50e:	8b 55 10             	mov    0x10(%ebp),%edx
  80a511:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a514:	50                   	push   %eax
  80a515:	68 a4 9d 80 00       	push   $0x809da4
  80a51a:	ff 75 08             	pushl  0x8(%ebp)
  80a51d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a520:	50                   	push   %eax
  80a521:	e8 c7 01 00 00       	call   80a6ed <thread_create>
    if (r < 0)
  80a526:	83 c4 10             	add    $0x10,%esp
  80a529:	85 c0                	test   %eax,%eax
  80a52b:	78 33                	js     80a560 <sys_thread_new+0x74>
}
  80a52d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a530:	c9                   	leave  
  80a531:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a532:	83 ec 04             	sub    $0x4,%esp
  80a535:	68 e4 2a 81 00       	push   $0x812ae4
  80a53a:	68 fd 00 00 00       	push   $0xfd
  80a53f:	68 80 2b 81 00       	push   $0x812b80
  80a544:	e8 26 42 00 00       	call   80e76f <_panic>
	panic("large stack %d", stacksize);
  80a549:	ff 75 14             	pushl  0x14(%ebp)
  80a54c:	68 de 2b 81 00       	push   $0x812bde
  80a551:	68 00 01 00 00       	push   $0x100
  80a556:	68 80 2b 81 00       	push   $0x812b80
  80a55b:	e8 0f 42 00 00       	call   80e76f <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a560:	83 ec 0c             	sub    $0xc,%esp
  80a563:	50                   	push   %eax
  80a564:	e8 c0 04 00 00       	call   80aa29 <e2s>
  80a569:	50                   	push   %eax
  80a56a:	68 14 2b 81 00       	push   $0x812b14
  80a56f:	68 09 01 00 00       	push   $0x109
  80a574:	68 80 2b 81 00       	push   $0x812b80
  80a579:	e8 f1 41 00 00       	call   80e76f <_panic>

0080a57e <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a57e:	55                   	push   %ebp
  80a57f:	89 e5                	mov    %esp,%ebp
  80a581:	57                   	push   %edi
  80a582:	56                   	push   %esi
  80a583:	53                   	push   %ebx
  80a584:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a587:	e8 ef 00 00 00       	call   80a67b <thread_id>
  80a58c:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a58e:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a593:	f7 e2                	mul    %edx
  80a595:	c1 ea 08             	shr    $0x8,%edx
  80a598:	89 d7                	mov    %edx,%edi
  80a59a:	c1 e2 08             	shl    $0x8,%edx
  80a59d:	01 d7                	add    %edx,%edi
  80a59f:	89 f0                	mov    %esi,%eax
  80a5a1:	29 f8                	sub    %edi,%eax
  80a5a3:	89 c7                	mov    %eax,%edi
  80a5a5:	8b 1c 85 40 5b b3 00 	mov    0xb35b40(,%eax,4),%ebx
  80a5ac:	85 db                	test   %ebx,%ebx
  80a5ae:	74 09                	je     80a5b9 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a5b0:	39 33                	cmp    %esi,(%ebx)
  80a5b2:	74 66                	je     80a61a <sys_arch_timeouts+0x9c>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a5b4:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a5b7:	eb f3                	jmp    80a5ac <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a5b9:	83 ec 0c             	sub    $0xc,%esp
  80a5bc:	6a 10                	push   $0x10
  80a5be:	e8 0a 64 00 00       	call   8109cd <malloc>
  80a5c3:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a5c5:	83 c4 10             	add    $0x10,%esp
  80a5c8:	85 c0                	test   %eax,%eax
  80a5ca:	74 59                	je     80a625 <sys_arch_timeouts+0xa7>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a5cc:	83 ec 0c             	sub    $0xc,%esp
  80a5cf:	68 c3 9d 80 00       	push   $0x809dc3
  80a5d4:	e8 ea 00 00 00       	call   80a6c3 <thread_onhalt>
    if (r < 0)
  80a5d9:	83 c4 10             	add    $0x10,%esp
  80a5dc:	85 c0                	test   %eax,%eax
  80a5de:	78 5c                	js     80a63c <sys_arch_timeouts+0xbe>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a5e0:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a5e2:	83 ec 04             	sub    $0x4,%esp
  80a5e5:	6a 04                	push   $0x4
  80a5e7:	6a 00                	push   $0x0
  80a5e9:	8d 43 04             	lea    0x4(%ebx),%eax
  80a5ec:	50                   	push   %eax
  80a5ed:	e8 18 4b 00 00       	call   80f10a <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a5f2:	8b 04 bd 40 5b b3 00 	mov    0xb35b40(,%edi,4),%eax
  80a5f9:	89 43 08             	mov    %eax,0x8(%ebx)
  80a5fc:	83 c4 10             	add    $0x10,%esp
  80a5ff:	85 c0                	test   %eax,%eax
  80a601:	74 06                	je     80a609 <sys_arch_timeouts+0x8b>
  80a603:	8d 53 08             	lea    0x8(%ebx),%edx
  80a606:	89 50 0c             	mov    %edx,0xc(%eax)
  80a609:	89 1c bd 40 5b b3 00 	mov    %ebx,0xb35b40(,%edi,4)
  80a610:	8d 04 bd 40 5b b3 00 	lea    0xb35b40(,%edi,4),%eax
  80a617:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a61a:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a61d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a620:	5b                   	pop    %ebx
  80a621:	5e                   	pop    %esi
  80a622:	5f                   	pop    %edi
  80a623:	5d                   	pop    %ebp
  80a624:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a625:	83 ec 04             	sub    $0x4,%esp
  80a628:	68 40 2b 81 00       	push   $0x812b40
  80a62d:	68 2c 01 00 00       	push   $0x12c
  80a632:	68 80 2b 81 00       	push   $0x812b80
  80a637:	e8 33 41 00 00       	call   80e76f <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a63c:	83 ec 0c             	sub    $0xc,%esp
  80a63f:	50                   	push   %eax
  80a640:	e8 e4 03 00 00       	call   80aa29 <e2s>
  80a645:	50                   	push   %eax
  80a646:	68 ed 2b 81 00       	push   $0x812bed
  80a64b:	68 30 01 00 00       	push   $0x130
  80a650:	68 80 2b 81 00       	push   $0x812b80
  80a655:	e8 15 41 00 00       	call   80e76f <_panic>

0080a65a <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a65a:	c3                   	ret    

0080a65b <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a65b:	c3                   	ret    

0080a65c <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a65c:	c7 05 88 c1 b3 00 00 	movl   $0x0,0xb3c188
  80a663:	00 00 00 
    tq->tq_last = 0;
  80a666:	c7 05 8c c1 b3 00 00 	movl   $0x0,0xb3c18c
  80a66d:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a670:	c7 05 94 c1 b3 00 00 	movl   $0x0,0xb3c194
  80a677:	00 00 00 
}
  80a67a:	c3                   	ret    

0080a67b <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a67b:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a680:	8b 00                	mov    (%eax),%eax
}
  80a682:	c3                   	ret    

0080a683 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a683:	55                   	push   %ebp
  80a684:	89 e5                	mov    %esp,%ebp
  80a686:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a689:	a1 88 c1 b3 00       	mov    0xb3c188,%eax
    while (tc) {
  80a68e:	eb 07                	jmp    80a697 <thread_wakeup+0x14>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a690:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a694:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a697:	85 c0                	test   %eax,%eax
  80a699:	74 07                	je     80a6a2 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a69b:	39 50 48             	cmp    %edx,0x48(%eax)
  80a69e:	75 f4                	jne    80a694 <thread_wakeup+0x11>
  80a6a0:	eb ee                	jmp    80a690 <thread_wakeup+0xd>
    }
}
  80a6a2:	5d                   	pop    %ebp
  80a6a3:	c3                   	ret    

0080a6a4 <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a6a4:	8b 15 88 c1 b3 00    	mov    0xb3c188,%edx
    int n = 0;
  80a6aa:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a6af:	85 d2                	test   %edx,%edx
  80a6b1:	74 0f                	je     80a6c2 <thread_wakeups_pending+0x1e>
	if (tc->tc_wakeup)
  80a6b3:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a6b7:	80 f9 01             	cmp    $0x1,%cl
  80a6ba:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a6bd:	8b 52 64             	mov    0x64(%edx),%edx
  80a6c0:	eb ed                	jmp    80a6af <thread_wakeups_pending+0xb>
    }
    return n;
}
  80a6c2:	c3                   	ret    

0080a6c3 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a6c3:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a6c8:	8b 50 60             	mov    0x60(%eax),%edx
  80a6cb:	83 fa 03             	cmp    $0x3,%edx
  80a6ce:	7f 17                	jg     80a6e7 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a6d0:	55                   	push   %ebp
  80a6d1:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a6d3:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a6d6:	89 48 60             	mov    %ecx,0x60(%eax)
  80a6d9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a6dc:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a6e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a6e5:	5d                   	pop    %ebp
  80a6e6:	c3                   	ret    
	return -E_NO_MEM;
  80a6e7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a6ec:	c3                   	ret    

0080a6ed <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a6ed:	55                   	push   %ebp
  80a6ee:	89 e5                	mov    %esp,%ebp
  80a6f0:	57                   	push   %edi
  80a6f1:	56                   	push   %esi
  80a6f2:	53                   	push   %ebx
  80a6f3:	83 ec 18             	sub    $0x18,%esp
  80a6f6:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a6f9:	6a 68                	push   $0x68
  80a6fb:	e8 cd 62 00 00       	call   8109cd <malloc>
    if (!tc)
  80a700:	83 c4 10             	add    $0x10,%esp
  80a703:	85 c0                	test   %eax,%eax
  80a705:	0f 84 04 01 00 00    	je     80a80f <thread_create+0x122>
  80a70b:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a70d:	83 ec 04             	sub    $0x4,%esp
  80a710:	6a 68                	push   $0x68
  80a712:	6a 00                	push   $0x0
  80a714:	50                   	push   %eax
  80a715:	e8 f0 49 00 00       	call   80f10a <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a71a:	83 c4 0c             	add    $0xc,%esp
  80a71d:	6a 1f                	push   $0x1f
  80a71f:	ff 75 0c             	pushl  0xc(%ebp)
  80a722:	8d 43 08             	lea    0x8(%ebx),%eax
  80a725:	50                   	push   %eax
  80a726:	e8 de 48 00 00       	call   80f009 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a72b:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a72f:	a1 94 c1 b3 00       	mov    0xb3c194,%eax
  80a734:	8d 50 01             	lea    0x1(%eax),%edx
  80a737:	89 15 94 c1 b3 00    	mov    %edx,0xb3c194
    if (max_tid == (uint32_t)~0)
  80a73d:	83 c4 10             	add    $0x10,%esp
  80a740:	83 fa ff             	cmp    $0xffffffff,%edx
  80a743:	0f 84 91 00 00 00    	je     80a7da <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a749:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a74b:	83 ec 0c             	sub    $0xc,%esp
  80a74e:	68 00 10 00 00       	push   $0x1000
  80a753:	e8 75 62 00 00       	call   8109cd <malloc>
  80a758:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a75b:	83 c4 10             	add    $0x10,%esp
  80a75e:	85 c0                	test   %eax,%eax
  80a760:	0f 84 88 00 00 00    	je     80a7ee <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a766:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a76c:	83 ec 04             	sub    $0x4,%esp
  80a76f:	6a 04                	push   $0x4
  80a771:	6a 00                	push   $0x0
  80a773:	57                   	push   %edi
  80a774:	e8 91 49 00 00       	call   80f10a <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a779:	83 c4 0c             	add    $0xc,%esp
  80a77c:	6a 18                	push   $0x18
  80a77e:	6a 00                	push   $0x0
  80a780:	8d 43 30             	lea    0x30(%ebx),%eax
  80a783:	50                   	push   %eax
  80a784:	e8 81 49 00 00       	call   80f10a <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a789:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a78c:	c7 43 30 9a a9 80 00 	movl   $0x80a99a,0x30(%ebx)
    tc->tc_entry = entry;
  80a793:	8b 45 10             	mov    0x10(%ebp),%eax
  80a796:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a799:	8b 45 14             	mov    0x14(%ebp),%eax
  80a79c:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a79f:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a7a6:	83 c4 10             	add    $0x10,%esp
  80a7a9:	83 3d 88 c1 b3 00 00 	cmpl   $0x0,0xb3c188
  80a7b0:	74 4f                	je     80a801 <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a7b2:	a1 8c c1 b3 00       	mov    0xb3c18c,%eax
  80a7b7:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a7ba:	89 1d 8c c1 b3 00    	mov    %ebx,0xb3c18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a7c0:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a7c5:	85 f6                	test   %esi,%esi
  80a7c7:	74 09                	je     80a7d2 <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a7c9:	8b 03                	mov    (%ebx),%eax
  80a7cb:	89 06                	mov    %eax,(%esi)
    return 0;
  80a7cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a7d2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a7d5:	5b                   	pop    %ebx
  80a7d6:	5e                   	pop    %esi
  80a7d7:	5f                   	pop    %edi
  80a7d8:	5d                   	pop    %ebp
  80a7d9:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a7da:	83 ec 04             	sub    $0x4,%esp
  80a7dd:	68 06 2c 81 00       	push   $0x812c06
  80a7e2:	6a 54                	push   $0x54
  80a7e4:	68 24 2c 81 00       	push   $0x812c24
  80a7e9:	e8 81 3f 00 00       	call   80e76f <_panic>
	free(tc);
  80a7ee:	83 ec 0c             	sub    $0xc,%esp
  80a7f1:	53                   	push   %ebx
  80a7f2:	e8 2a 61 00 00       	call   810921 <free>
	return -E_NO_MEM;
  80a7f7:	83 c4 10             	add    $0x10,%esp
  80a7fa:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a7ff:	eb d1                	jmp    80a7d2 <thread_create+0xe5>
	tq->tq_first = tc;
  80a801:	89 1d 88 c1 b3 00    	mov    %ebx,0xb3c188
	tq->tq_last = tc;
  80a807:	89 1d 8c c1 b3 00    	mov    %ebx,0xb3c18c
  80a80d:	eb b1                	jmp    80a7c0 <thread_create+0xd3>
	return -E_NO_MEM;
  80a80f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a814:	eb bc                	jmp    80a7d2 <thread_create+0xe5>

0080a816 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a816:	55                   	push   %ebp
  80a817:	89 e5                	mov    %esp,%ebp
  80a819:	53                   	push   %ebx
  80a81a:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a81d:	8b 1d 88 c1 b3 00    	mov    0xb3c188,%ebx
  80a823:	85 db                	test   %ebx,%ebx
  80a825:	74 2b                	je     80a852 <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a827:	8b 43 64             	mov    0x64(%ebx),%eax
  80a82a:	a3 88 c1 b3 00       	mov    %eax,0xb3c188
    tc->tc_queue_link = 0;
  80a82f:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a836:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a83b:	85 c0                	test   %eax,%eax
  80a83d:	74 3b                	je     80a87a <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a83f:	83 ec 0c             	sub    $0xc,%esp
  80a842:	83 c0 30             	add    $0x30,%eax
  80a845:	50                   	push   %eax
  80a846:	e8 75 01 00 00       	call   80a9c0 <jos_setjmp>
  80a84b:	83 c4 10             	add    $0x10,%esp
  80a84e:	85 c0                	test   %eax,%eax
  80a850:	74 05                	je     80a857 <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a852:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a855:	c9                   	leave  
  80a856:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a857:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
    tc->tc_queue_link = 0;
  80a85c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a863:	83 3d 88 c1 b3 00 00 	cmpl   $0x0,0xb3c188
  80a86a:	74 21                	je     80a88d <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a86c:	8b 15 8c c1 b3 00    	mov    0xb3c18c,%edx
  80a872:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a875:	a3 8c c1 b3 00       	mov    %eax,0xb3c18c
    cur_tc = next_tc;
  80a87a:	89 1d 90 c1 b3 00    	mov    %ebx,0xb3c190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a880:	8d 43 30             	lea    0x30(%ebx),%eax
  80a883:	ba 01 00 00 00       	mov    $0x1,%edx
  80a888:	e8 63 01 00 00       	call   80a9f0 <jos_longjmp>
	tq->tq_first = tc;
  80a88d:	a3 88 c1 b3 00       	mov    %eax,0xb3c188
	tq->tq_last = tc;
  80a892:	a3 8c c1 b3 00       	mov    %eax,0xb3c18c
  80a897:	eb e1                	jmp    80a87a <thread_yield+0x64>

0080a899 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a899:	55                   	push   %ebp
  80a89a:	89 e5                	mov    %esp,%ebp
  80a89c:	57                   	push   %edi
  80a89d:	56                   	push   %esi
  80a89e:	53                   	push   %ebx
  80a89f:	83 ec 0c             	sub    $0xc,%esp
  80a8a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a8a5:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a8a8:	e8 3b 4d 00 00       	call   80f5e8 <sys_time_msec>
  80a8ad:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a8af:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a8b4:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a8b7:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a8bb:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a8bd:	eb 17                	jmp    80a8d6 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a8bf:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a8c4:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a8c8:	84 c0                	test   %al,%al
  80a8ca:	75 1d                	jne    80a8e9 <thread_wait+0x50>
	thread_yield();
  80a8cc:	e8 45 ff ff ff       	call   80a816 <thread_yield>
	p = sys_time_msec();
  80a8d1:	e8 12 4d 00 00       	call   80f5e8 <sys_time_msec>
	if (p < s)
  80a8d6:	39 f0                	cmp    %esi,%eax
  80a8d8:	72 0f                	jb     80a8e9 <thread_wait+0x50>
  80a8da:	39 f8                	cmp    %edi,%eax
  80a8dc:	73 0b                	jae    80a8e9 <thread_wait+0x50>
	if (addr && *addr != val)
  80a8de:	85 db                	test   %ebx,%ebx
  80a8e0:	74 dd                	je     80a8bf <thread_wait+0x26>
  80a8e2:	8b 03                	mov    (%ebx),%eax
  80a8e4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a8e7:	74 d6                	je     80a8bf <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a8e9:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a8ee:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a8f5:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a8f9:	83 c4 0c             	add    $0xc,%esp
  80a8fc:	5b                   	pop    %ebx
  80a8fd:	5e                   	pop    %esi
  80a8fe:	5f                   	pop    %edi
  80a8ff:	5d                   	pop    %ebp
  80a900:	c3                   	ret    

0080a901 <thread_halt>:
thread_halt() {
  80a901:	55                   	push   %ebp
  80a902:	89 e5                	mov    %esp,%ebp
  80a904:	56                   	push   %esi
  80a905:	53                   	push   %ebx
    if (!tq->tq_first)
  80a906:	8b 1d 80 c1 b3 00    	mov    0xb3c180,%ebx
  80a90c:	85 db                	test   %ebx,%ebx
  80a90e:	74 40                	je     80a950 <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a910:	8b 43 64             	mov    0x64(%ebx),%eax
  80a913:	a3 80 c1 b3 00       	mov    %eax,0xb3c180
    tc->tc_queue_link = 0;
  80a918:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a91f:	be 00 00 00 00       	mov    $0x0,%esi
  80a924:	eb 0f                	jmp    80a935 <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a926:	83 ec 0c             	sub    $0xc,%esp
  80a929:	ff 33                	pushl  (%ebx)
  80a92b:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a92f:	83 c6 01             	add    $0x1,%esi
  80a932:	83 c4 10             	add    $0x10,%esp
  80a935:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a938:	7c ec                	jl     80a926 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a93a:	83 ec 0c             	sub    $0xc,%esp
  80a93d:	ff 73 04             	pushl  0x4(%ebx)
  80a940:	e8 dc 5f 00 00       	call   810921 <free>
    free(tc);
  80a945:	89 1c 24             	mov    %ebx,(%esp)
  80a948:	e8 d4 5f 00 00       	call   810921 <free>
  80a94d:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a950:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
    tc->tc_queue_link = 0;
  80a955:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a95c:	83 3d 80 c1 b3 00 00 	cmpl   $0x0,0xb3c180
  80a963:	74 29                	je     80a98e <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a965:	8b 15 84 c1 b3 00    	mov    0xb3c184,%edx
  80a96b:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a96e:	a3 84 c1 b3 00       	mov    %eax,0xb3c184
    cur_tc = NULL;
  80a973:	c7 05 90 c1 b3 00 00 	movl   $0x0,0xb3c190
  80a97a:	00 00 00 
    thread_yield();
  80a97d:	e8 94 fe ff ff       	call   80a816 <thread_yield>
    exit();
  80a982:	e8 b4 3d 00 00       	call   80e73b <exit>
}
  80a987:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a98a:	5b                   	pop    %ebx
  80a98b:	5e                   	pop    %esi
  80a98c:	5d                   	pop    %ebp
  80a98d:	c3                   	ret    
	tq->tq_first = tc;
  80a98e:	a3 80 c1 b3 00       	mov    %eax,0xb3c180
	tq->tq_last = tc;
  80a993:	a3 84 c1 b3 00       	mov    %eax,0xb3c184
  80a998:	eb d9                	jmp    80a973 <thread_halt+0x72>

0080a99a <thread_entry>:
thread_entry(void) {
  80a99a:	55                   	push   %ebp
  80a99b:	89 e5                	mov    %esp,%ebp
  80a99d:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a9a0:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a9a5:	ff 70 2c             	pushl  0x2c(%eax)
  80a9a8:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a9ab:	e8 51 ff ff ff       	call   80a901 <thread_halt>
}
  80a9b0:	83 c4 10             	add    $0x10,%esp
  80a9b3:	c9                   	leave  
  80a9b4:	c3                   	ret    
  80a9b5:	66 90                	xchg   %ax,%ax
  80a9b7:	66 90                	xchg   %ax,%ax
  80a9b9:	66 90                	xchg   %ax,%ax
  80a9bb:	66 90                	xchg   %ax,%ax
  80a9bd:	66 90                	xchg   %ax,%ax
  80a9bf:	90                   	nop

0080a9c0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a9c0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a9c4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a9c7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a9c9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a9cd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a9d0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a9d3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a9d6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a9d9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a9dc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a9e1:	c3                   	ret    
  80a9e2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a9e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080a9f0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a9f0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a9f2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a9f5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a9f8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a9fb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a9fe:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80aa01:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80aa03:	ff e1                	jmp    *%ecx

0080aa05 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80aa05:	55                   	push   %ebp
  80aa06:	89 e5                	mov    %esp,%ebp
  80aa08:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80aa0b:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80aa10:	ff 34 85 20 50 81 00 	pushl  0x815020(,%eax,4)
  80aa17:	ff 75 08             	pushl  0x8(%ebp)
  80aa1a:	68 3f 2c 81 00       	push   $0x812c3f
  80aa1f:	e8 41 3e 00 00       	call   80e865 <cprintf>
}
  80aa24:	83 c4 10             	add    $0x10,%esp
  80aa27:	c9                   	leave  
  80aa28:	c3                   	ret    

0080aa29 <e2s>:
e2s(int err) {
  80aa29:	55                   	push   %ebp
  80aa2a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80aa2c:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa2f:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80aa36:	5d                   	pop    %ebp
  80aa37:	c3                   	ret    

0080aa38 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80aa38:	55                   	push   %ebp
  80aa39:	89 e5                	mov    %esp,%ebp
  80aa3b:	57                   	push   %edi
  80aa3c:	56                   	push   %esi
  80aa3d:	53                   	push   %ebx
  80aa3e:	83 ec 20             	sub    $0x20,%esp
  80aa41:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80aa44:	6a 07                	push   $0x7
  80aa46:	68 00 00 00 10       	push   $0x10000000
  80aa4b:	6a 00                	push   $0x0
  80aa4d:	e8 64 49 00 00       	call   80f3b6 <sys_page_alloc>
    if (r < 0)
  80aa52:	83 c4 10             	add    $0x10,%esp
  80aa55:	85 c0                	test   %eax,%eax
  80aa57:	78 49                	js     80aaa2 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80aa59:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa5c:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aa5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80aa62:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80aa67:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80aa6c:	85 db                	test   %ebx,%ebx
  80aa6e:	74 5c                	je     80aacc <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80aa70:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aa74:	0f b7 d0             	movzwl %ax,%edx
  80aa77:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80aa7a:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80aa80:	7f 34                	jg     80aab6 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80aa82:	83 ec 04             	sub    $0x4,%esp
  80aa85:	0f b7 c0             	movzwl %ax,%eax
  80aa88:	50                   	push   %eax
  80aa89:	ff 73 04             	pushl  0x4(%ebx)
  80aa8c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80aa8f:	50                   	push   %eax
  80aa90:	e8 1f 47 00 00       	call   80f1b4 <memcpy>
	txsize += q->len;
  80aa95:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aa99:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80aa9b:	8b 1b                	mov    (%ebx),%ebx
  80aa9d:	83 c4 10             	add    $0x10,%esp
  80aaa0:	eb ca                	jmp    80aa6c <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80aaa2:	83 ec 04             	sub    $0x4,%esp
  80aaa5:	68 24 31 81 00       	push   $0x813124
  80aaaa:	6a 5b                	push   $0x5b
  80aaac:	68 75 31 81 00       	push   $0x813175
  80aab1:	e8 b9 3c 00 00       	call   80e76f <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80aab6:	83 ec 0c             	sub    $0xc,%esp
  80aab9:	56                   	push   %esi
  80aaba:	52                   	push   %edx
  80aabb:	68 4c 31 81 00       	push   $0x81314c
  80aac0:	6a 6a                	push   $0x6a
  80aac2:	68 75 31 81 00       	push   $0x813175
  80aac7:	e8 a3 3c 00 00       	call   80e76f <_panic>
    }

    pkt->jp_len = txsize;
  80aacc:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80aad2:	6a 07                	push   $0x7
  80aad4:	68 00 00 00 10       	push   $0x10000000
  80aad9:	6a 0b                	push   $0xb
  80aadb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aade:	ff 70 04             	pushl  0x4(%eax)
  80aae1:	e8 15 51 00 00       	call   80fbfb <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80aae6:	83 c4 08             	add    $0x8,%esp
  80aae9:	68 00 00 00 10       	push   $0x10000000
  80aaee:	6a 00                	push   $0x0
  80aaf0:	e8 46 49 00 00       	call   80f43b <sys_page_unmap>

    return ERR_OK;
}
  80aaf5:	b8 00 00 00 00       	mov    $0x0,%eax
  80aafa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aafd:	5b                   	pop    %ebx
  80aafe:	5e                   	pop    %esi
  80aaff:	5f                   	pop    %edi
  80ab00:	5d                   	pop    %ebp
  80ab01:	c3                   	ret    

0080ab02 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80ab02:	55                   	push   %ebp
  80ab03:	89 e5                	mov    %esp,%ebp
  80ab05:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80ab08:	ff 75 10             	pushl  0x10(%ebp)
  80ab0b:	ff 75 0c             	pushl  0xc(%ebp)
  80ab0e:	ff 75 08             	pushl  0x8(%ebp)
  80ab11:	e8 05 f1 ff ff       	call   809c1b <etharp_output>
}
  80ab16:	c9                   	leave  
  80ab17:	c3                   	ret    

0080ab18 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80ab18:	55                   	push   %ebp
  80ab19:	89 e5                	mov    %esp,%ebp
  80ab1b:	57                   	push   %edi
  80ab1c:	56                   	push   %esi
  80ab1d:	53                   	push   %ebx
  80ab1e:	83 ec 20             	sub    $0x20,%esp
  80ab21:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80ab24:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab27:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ab2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80ab2d:	8b 06                	mov    (%esi),%eax
  80ab2f:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80ab31:	6a 03                	push   $0x3
  80ab33:	0f b7 c0             	movzwl %ax,%eax
  80ab36:	50                   	push   %eax
  80ab37:	6a 03                	push   $0x3
  80ab39:	e8 8c 9e ff ff       	call   8049ca <pbuf_alloc>
    if (p == 0)
  80ab3e:	83 c4 10             	add    $0x10,%esp
  80ab41:	85 c0                	test   %eax,%eax
  80ab43:	0f 84 9c 00 00 00    	je     80abe5 <jif_input+0xcd>
  80ab49:	89 c7                	mov    %eax,%edi
    void *rxbuf = (void *) pkt->jp_data;
  80ab4b:	8d 46 04             	lea    0x4(%esi),%eax
  80ab4e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80ab51:	89 fe                	mov    %edi,%esi
    int copied = 0;
  80ab53:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80ab58:	0f bf c3             	movswl %bx,%eax
  80ab5b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ab5e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80ab61:	89 d7                	mov    %edx,%edi
	int bytes = q->len;
  80ab63:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80ab67:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ab6a:	29 fb                	sub    %edi,%ebx
  80ab6c:	39 c3                	cmp    %eax,%ebx
  80ab6e:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80ab71:	83 ec 04             	sub    $0x4,%esp
  80ab74:	53                   	push   %ebx
  80ab75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ab78:	01 f8                	add    %edi,%eax
  80ab7a:	50                   	push   %eax
  80ab7b:	ff 76 04             	pushl  0x4(%esi)
  80ab7e:	e8 31 46 00 00       	call   80f1b4 <memcpy>
	copied += bytes;
  80ab83:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80ab85:	8b 36                	mov    (%esi),%esi
  80ab87:	83 c4 10             	add    $0x10,%esp
  80ab8a:	85 f6                	test   %esi,%esi
  80ab8c:	75 d5                	jne    80ab63 <jif_input+0x4b>
  80ab8e:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80ab91:	83 ec 0c             	sub    $0xc,%esp
  80ab94:	8b 47 04             	mov    0x4(%edi),%eax
  80ab97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ab9b:	50                   	push   %eax
  80ab9c:	e8 3d cc ff ff       	call   8077de <htons>
  80aba1:	83 c4 10             	add    $0x10,%esp
  80aba4:	66 3d 00 08          	cmp    $0x800,%ax
  80aba8:	74 14                	je     80abbe <jif_input+0xa6>
  80abaa:	66 3d 06 08          	cmp    $0x806,%ax
  80abae:	74 3d                	je     80abed <jif_input+0xd5>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80abb0:	83 ec 0c             	sub    $0xc,%esp
  80abb3:	57                   	push   %edi
  80abb4:	e8 4b 9d ff ff       	call   804904 <pbuf_free>
  80abb9:	83 c4 10             	add    $0x10,%esp
  80abbc:	eb 27                	jmp    80abe5 <jif_input+0xcd>
	etharp_ip_input(netif, p);
  80abbe:	83 ec 08             	sub    $0x8,%esp
  80abc1:	57                   	push   %edi
  80abc2:	ff 75 08             	pushl  0x8(%ebp)
  80abc5:	e8 c9 ea ff ff       	call   809693 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80abca:	83 c4 08             	add    $0x8,%esp
  80abcd:	6a f2                	push   $0xfffffff2
  80abcf:	57                   	push   %edi
  80abd0:	e8 62 9c ff ff       	call   804837 <pbuf_header>
	netif->input(p, netif);
  80abd5:	83 c4 08             	add    $0x8,%esp
  80abd8:	ff 75 08             	pushl  0x8(%ebp)
  80abdb:	57                   	push   %edi
  80abdc:	8b 45 08             	mov    0x8(%ebp),%eax
  80abdf:	ff 50 10             	call   *0x10(%eax)
	break;
  80abe2:	83 c4 10             	add    $0x10,%esp
    }
}
  80abe5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80abe8:	5b                   	pop    %ebx
  80abe9:	5e                   	pop    %esi
  80abea:	5f                   	pop    %edi
  80abeb:	5d                   	pop    %ebp
  80abec:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80abed:	83 ec 04             	sub    $0x4,%esp
  80abf0:	57                   	push   %edi
  80abf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80abf4:	ff 30                	pushl  (%eax)
  80abf6:	ff 75 08             	pushl  0x8(%ebp)
  80abf9:	e8 e1 ea ff ff       	call   8096df <etharp_arp_input>
	break;
  80abfe:	83 c4 10             	add    $0x10,%esp
  80ac01:	eb e2                	jmp    80abe5 <jif_input+0xcd>

0080ac03 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80ac03:	55                   	push   %ebp
  80ac04:	89 e5                	mov    %esp,%ebp
  80ac06:	57                   	push   %edi
  80ac07:	56                   	push   %esi
  80ac08:	53                   	push   %ebx
  80ac09:	83 ec 38             	sub    $0x38,%esp
  80ac0c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80ac0f:	6a 08                	push   $0x8
  80ac11:	e8 f7 96 ff ff       	call   80430d <mem_malloc>

    if (jif == NULL) {
  80ac16:	83 c4 10             	add    $0x10,%esp
  80ac19:	85 c0                	test   %eax,%eax
  80ac1b:	0f 84 dd 00 00 00    	je     80acfe <jif_init+0xfb>
  80ac21:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ac23:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ac26:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ac29:	c7 43 14 02 ab 80 00 	movl   $0x80ab02,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ac30:	c7 43 18 38 aa 80 00 	movl   $0x80aa38,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ac37:	83 ec 04             	sub    $0x4,%esp
  80ac3a:	6a 02                	push   $0x2
  80ac3c:	68 b0 3f 81 00       	push   $0x813fb0
  80ac41:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ac44:	50                   	push   %eax
  80ac45:	e8 6a 45 00 00       	call   80f1b4 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ac4a:	8d 43 25             	lea    0x25(%ebx),%eax
  80ac4d:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ac4f:	8b 07                	mov    (%edi),%eax
  80ac51:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ac54:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ac58:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ac5e:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    uint64_t mac_addr_store = 0; 
  80ac62:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80ac69:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    sys_get_mac_addr(&mac_addr_store);
  80ac70:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80ac73:	89 04 24             	mov    %eax,(%esp)
  80ac76:	e8 10 4a 00 00       	call   80f68b <sys_get_mac_addr>
    cprintf("the mac_addr is 0x%016lx\n", mac_addr_store);
  80ac7b:	83 c4 0c             	add    $0xc,%esp
  80ac7e:	ff 75 dc             	pushl  -0x24(%ebp)
  80ac81:	ff 75 d8             	pushl  -0x28(%ebp)
  80ac84:	68 8c 31 81 00       	push   $0x81318c
  80ac89:	e8 d7 3b 00 00       	call   80e865 <cprintf>
        netif->hwaddr[i] = (uint8_t)((mac_addr_store>>(8*i)) & 0xff);
  80ac8e:	8b 75 d8             	mov    -0x28(%ebp),%esi
  80ac91:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ac94:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < 6; i++)
  80ac97:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac9c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80ac9f:	eb 14                	jmp    80acb5 <jif_init+0xb2>
        netif->hwaddr[i] = (uint8_t)((mac_addr_store>>(8*i)) & 0xff);
  80aca1:	89 c2                	mov    %eax,%edx
  80aca3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80aca6:	88 54 03 25          	mov    %dl,0x25(%ebx,%eax,1)
    for (int i = 0; i < 6; i++)
  80acaa:	83 c0 01             	add    $0x1,%eax
  80acad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80acb0:	83 f8 06             	cmp    $0x6,%eax
  80acb3:	74 1a                	je     80accf <jif_init+0xcc>
        netif->hwaddr[i] = (uint8_t)((mac_addr_store>>(8*i)) & 0xff);
  80acb5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80acb8:	c1 e0 03             	shl    $0x3,%eax
  80acbb:	89 c1                	mov    %eax,%ecx
  80acbd:	89 f0                	mov    %esi,%eax
  80acbf:	89 fa                	mov    %edi,%edx
  80acc1:	0f ad f8             	shrd   %cl,%edi,%eax
  80acc4:	d3 ea                	shr    %cl,%edx
  80acc6:	f6 c1 20             	test   $0x20,%cl
  80acc9:	74 d6                	je     80aca1 <jif_init+0x9e>
  80accb:	89 d0                	mov    %edx,%eax
  80accd:	eb d2                	jmp    80aca1 <jif_init+0x9e>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80accf:	83 ec 0c             	sub    $0xc,%esp
  80acd2:	68 4b 15 81 00       	push   $0x81154b
  80acd7:	e8 11 cd ff ff       	call   8079ed <inet_addr>
  80acdc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80acdf:	83 c4 0c             	add    $0xc,%esp
  80ace2:	6a 00                	push   $0x0
  80ace4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ace7:	50                   	push   %eax
  80ace8:	53                   	push   %ebx
  80ace9:	e8 f7 ec ff ff       	call   8099e5 <etharp_query>

    return ERR_OK;
  80acee:	83 c4 10             	add    $0x10,%esp
  80acf1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80acf6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80acf9:	5b                   	pop    %ebx
  80acfa:	5e                   	pop    %esi
  80acfb:	5f                   	pop    %edi
  80acfc:	5d                   	pop    %ebp
  80acfd:	c3                   	ret    
	return ERR_MEM;
  80acfe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ad03:	eb f1                	jmp    80acf6 <jif_init+0xf3>

0080ad05 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ad05:	55                   	push   %ebp
  80ad06:	89 e5                	mov    %esp,%ebp
  80ad08:	56                   	push   %esi
  80ad09:	53                   	push   %ebx
  80ad0a:	83 ec 28             	sub    $0x28,%esp
  80ad0d:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ad10:	ff 75 10             	pushl  0x10(%ebp)
  80ad13:	ff 75 08             	pushl  0x8(%ebp)
  80ad16:	e8 47 0f 00 00       	call   80bc62 <netconn_alloc>
  80ad1b:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ad1d:	83 c4 10             	add    $0x10,%esp
  80ad20:	85 c0                	test   %eax,%eax
  80ad22:	74 63                	je     80ad87 <netconn_new_with_proto_and_callback+0x82>
    msg.function = do_newconn;
  80ad24:	c7 45 e4 59 bb 80 00 	movl   $0x80bb59,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ad2b:	89 f0                	mov    %esi,%eax
  80ad2d:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ad30:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ad33:	83 ec 0c             	sub    $0xc,%esp
  80ad36:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad39:	50                   	push   %eax
  80ad3a:	e8 3c 77 ff ff       	call   80247b <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ad3f:	83 c4 10             	add    $0x10,%esp
  80ad42:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ad46:	74 3f                	je     80ad87 <netconn_new_with_proto_and_callback+0x82>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ad48:	8b 73 08             	mov    0x8(%ebx),%esi
  80ad4b:	85 f6                	test   %esi,%esi
  80ad4d:	75 41                	jne    80ad90 <netconn_new_with_proto_and_callback+0x8b>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ad4f:	8b 43 10             	mov    0x10(%ebx),%eax
  80ad52:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ad55:	74 4d                	je     80ada4 <netconn_new_with_proto_and_callback+0x9f>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ad57:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ad5b:	74 5b                	je     80adb8 <netconn_new_with_proto_and_callback+0xb3>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ad5d:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ad61:	75 69                	jne    80adcc <netconn_new_with_proto_and_callback+0xc7>
      sys_sem_free(conn->op_completed);
  80ad63:	83 ec 0c             	sub    $0xc,%esp
  80ad66:	50                   	push   %eax
  80ad67:	e8 cc f1 ff ff       	call   809f38 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ad6c:	83 c4 04             	add    $0x4,%esp
  80ad6f:	ff 73 14             	pushl  0x14(%ebx)
  80ad72:	e8 4a f2 ff ff       	call   809fc1 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ad77:	83 c4 08             	add    $0x8,%esp
  80ad7a:	53                   	push   %ebx
  80ad7b:	6a 07                	push   $0x7
  80ad7d:	e8 35 98 ff ff       	call   8045b7 <memp_free>
      return NULL;
  80ad82:	83 c4 10             	add    $0x10,%esp
  80ad85:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80ad87:	89 d8                	mov    %ebx,%eax
  80ad89:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ad8c:	5b                   	pop    %ebx
  80ad8d:	5e                   	pop    %esi
  80ad8e:	5d                   	pop    %ebp
  80ad8f:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ad90:	83 ec 04             	sub    $0x4,%esp
  80ad93:	68 a8 31 81 00       	push   $0x8131a8
  80ad98:	6a 52                	push   $0x52
  80ad9a:	68 5a 32 81 00       	push   $0x81325a
  80ad9f:	e8 cb 39 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ada4:	83 ec 04             	sub    $0x4,%esp
  80ada7:	68 71 32 81 00       	push   $0x813271
  80adac:	6a 53                	push   $0x53
  80adae:	68 5a 32 81 00       	push   $0x81325a
  80adb3:	e8 b7 39 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80adb8:	83 ec 04             	sub    $0x4,%esp
  80adbb:	68 8a 32 81 00       	push   $0x81328a
  80adc0:	6a 54                	push   $0x54
  80adc2:	68 5a 32 81 00       	push   $0x81325a
  80adc7:	e8 a3 39 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80adcc:	83 ec 04             	sub    $0x4,%esp
  80adcf:	68 cc 31 81 00       	push   $0x8131cc
  80add4:	6a 55                	push   $0x55
  80add6:	68 5a 32 81 00       	push   $0x81325a
  80addb:	e8 8f 39 00 00       	call   80e76f <_panic>

0080ade0 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ade0:	55                   	push   %ebp
  80ade1:	89 e5                	mov    %esp,%ebp
  80ade3:	53                   	push   %ebx
  80ade4:	83 ec 24             	sub    $0x24,%esp
  80ade7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80adea:	85 db                	test   %ebx,%ebx
  80adec:	74 28                	je     80ae16 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80adee:	c7 45 e4 a1 be 80 00 	movl   $0x80bea1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80adf5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80adf8:	83 ec 0c             	sub    $0xc,%esp
  80adfb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adfe:	50                   	push   %eax
  80adff:	e8 77 76 ff ff       	call   80247b <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ae04:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ae0b:	89 1c 24             	mov    %ebx,(%esp)
  80ae0e:	e8 fd 0e 00 00       	call   80bd10 <netconn_free>

  return ERR_OK;
  80ae13:	83 c4 10             	add    $0x10,%esp
}
  80ae16:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae1e:	c9                   	leave  
  80ae1f:	c3                   	ret    

0080ae20 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ae20:	55                   	push   %ebp
  80ae21:	89 e5                	mov    %esp,%ebp
  80ae23:	83 ec 08             	sub    $0x8,%esp
  80ae26:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ae29:	85 c0                	test   %eax,%eax
  80ae2b:	74 04                	je     80ae31 <netconn_type+0x11>
  80ae2d:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ae2f:	c9                   	leave  
  80ae30:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ae31:	83 ec 04             	sub    $0x4,%esp
  80ae34:	68 9f 32 81 00       	push   $0x81329f
  80ae39:	68 84 00 00 00       	push   $0x84
  80ae3e:	68 5a 32 81 00       	push   $0x81325a
  80ae43:	e8 27 39 00 00       	call   80e76f <_panic>

0080ae48 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ae48:	55                   	push   %ebp
  80ae49:	89 e5                	mov    %esp,%ebp
  80ae4b:	53                   	push   %ebx
  80ae4c:	83 ec 24             	sub    $0x24,%esp
  80ae4f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae52:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ae55:	8b 45 10             	mov    0x10(%ebp),%eax
  80ae58:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae5b:	85 db                	test   %ebx,%ebx
  80ae5d:	74 30                	je     80ae8f <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ae5f:	85 d2                	test   %edx,%edx
  80ae61:	74 43                	je     80aea6 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ae63:	85 c0                	test   %eax,%eax
  80ae65:	74 56                	je     80aebd <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80ae67:	c7 45 e4 f0 c2 80 00 	movl   $0x80c2f0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae6e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ae71:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ae74:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ae77:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ae7a:	83 ec 0c             	sub    $0xc,%esp
  80ae7d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae80:	50                   	push   %eax
  80ae81:	e8 f5 75 ff ff       	call   80247b <tcpip_apimsg>

  return conn->err;
  80ae86:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae8d:	c9                   	leave  
  80ae8e:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae8f:	83 ec 04             	sub    $0x4,%esp
  80ae92:	68 ba 32 81 00       	push   $0x8132ba
  80ae97:	68 98 00 00 00       	push   $0x98
  80ae9c:	68 5a 32 81 00       	push   $0x81325a
  80aea1:	e8 c9 38 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80aea6:	83 ec 04             	sub    $0x4,%esp
  80aea9:	68 d8 32 81 00       	push   $0x8132d8
  80aeae:	68 99 00 00 00       	push   $0x99
  80aeb3:	68 5a 32 81 00       	push   $0x81325a
  80aeb8:	e8 b2 38 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80aebd:	83 ec 04             	sub    $0x4,%esp
  80aec0:	68 f6 32 81 00       	push   $0x8132f6
  80aec5:	68 9a 00 00 00       	push   $0x9a
  80aeca:	68 5a 32 81 00       	push   $0x81325a
  80aecf:	e8 9b 38 00 00       	call   80e76f <_panic>

0080aed4 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80aed4:	55                   	push   %ebp
  80aed5:	89 e5                	mov    %esp,%ebp
  80aed7:	53                   	push   %ebx
  80aed8:	83 ec 24             	sub    $0x24,%esp
  80aedb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aede:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80aee1:	85 db                	test   %ebx,%ebx
  80aee3:	74 29                	je     80af0e <netconn_bind+0x3a>

  msg.function = do_bind;
  80aee5:	c7 45 e4 4a bf 80 00 	movl   $0x80bf4a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aeec:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80aeef:	8b 55 0c             	mov    0xc(%ebp),%edx
  80aef2:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80aef5:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80aef9:	83 ec 0c             	sub    $0xc,%esp
  80aefc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aeff:	50                   	push   %eax
  80af00:	e8 76 75 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80af05:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af09:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af0c:	c9                   	leave  
  80af0d:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80af0e:	83 ec 04             	sub    $0x4,%esp
  80af11:	68 14 33 81 00       	push   $0x813314
  80af16:	68 b5 00 00 00       	push   $0xb5
  80af1b:	68 5a 32 81 00       	push   $0x81325a
  80af20:	e8 4a 38 00 00       	call   80e76f <_panic>

0080af25 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80af25:	55                   	push   %ebp
  80af26:	89 e5                	mov    %esp,%ebp
  80af28:	53                   	push   %ebx
  80af29:	83 ec 24             	sub    $0x24,%esp
  80af2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80af2f:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80af32:	85 db                	test   %ebx,%ebx
  80af34:	74 29                	je     80af5f <netconn_connect+0x3a>

  msg.function = do_connect;
  80af36:	c7 45 e4 da bf 80 00 	movl   $0x80bfda,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af3d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80af40:	8b 55 0c             	mov    0xc(%ebp),%edx
  80af43:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80af46:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80af4a:	83 ec 0c             	sub    $0xc,%esp
  80af4d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af50:	50                   	push   %eax
  80af51:	e8 25 75 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80af56:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af5a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af5d:	c9                   	leave  
  80af5e:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80af5f:	83 ec 04             	sub    $0x4,%esp
  80af62:	68 2f 33 81 00       	push   $0x81332f
  80af67:	68 cc 00 00 00       	push   $0xcc
  80af6c:	68 5a 32 81 00       	push   $0x81325a
  80af71:	e8 f9 37 00 00       	call   80e76f <_panic>

0080af76 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80af76:	55                   	push   %ebp
  80af77:	89 e5                	mov    %esp,%ebp
  80af79:	53                   	push   %ebx
  80af7a:	83 ec 24             	sub    $0x24,%esp
  80af7d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80af80:	85 db                	test   %ebx,%ebx
  80af82:	74 1f                	je     80afa3 <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80af84:	c7 45 e4 8f c0 80 00 	movl   $0x80c08f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af8b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80af8e:	83 ec 0c             	sub    $0xc,%esp
  80af91:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af94:	50                   	push   %eax
  80af95:	e8 e1 74 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80af9a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afa1:	c9                   	leave  
  80afa2:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80afa3:	83 ec 04             	sub    $0x4,%esp
  80afa6:	68 f0 31 81 00       	push   $0x8131f0
  80afab:	68 e2 00 00 00       	push   $0xe2
  80afb0:	68 5a 32 81 00       	push   $0x81325a
  80afb5:	e8 b5 37 00 00       	call   80e76f <_panic>

0080afba <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80afba:	55                   	push   %ebp
  80afbb:	89 e5                	mov    %esp,%ebp
  80afbd:	53                   	push   %ebx
  80afbe:	83 ec 24             	sub    $0x24,%esp
  80afc1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80afc4:	85 db                	test   %ebx,%ebx
  80afc6:	74 1f                	je     80afe7 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80afc8:	c7 45 e4 cc c0 80 00 	movl   $0x80c0cc,-0x1c(%ebp)
  msg.msg.conn = conn;
  80afcf:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80afd2:	83 ec 0c             	sub    $0xc,%esp
  80afd5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afd8:	50                   	push   %eax
  80afd9:	e8 9d 74 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80afde:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80afe2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afe5:	c9                   	leave  
  80afe6:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80afe7:	83 ec 04             	sub    $0x4,%esp
  80afea:	68 4d 33 81 00       	push   $0x81334d
  80afef:	68 fa 00 00 00       	push   $0xfa
  80aff4:	68 5a 32 81 00       	push   $0x81325a
  80aff9:	e8 71 37 00 00       	call   80e76f <_panic>

0080affe <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80affe:	55                   	push   %ebp
  80afff:	89 e5                	mov    %esp,%ebp
  80b001:	53                   	push   %ebx
  80b002:	83 ec 14             	sub    $0x14,%esp
  80b005:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b008:	85 db                	test   %ebx,%ebx
  80b00a:	74 36                	je     80b042 <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b00c:	8b 43 18             	mov    0x18(%ebx),%eax
  80b00f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b012:	74 45                	je     80b059 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b014:	83 ec 04             	sub    $0x4,%esp
  80b017:	6a 00                	push   $0x0
  80b019:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b01c:	52                   	push   %edx
  80b01d:	50                   	push   %eax
  80b01e:	e8 c6 f3 ff ff       	call   80a3e9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b023:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b026:	83 c4 10             	add    $0x10,%esp
  80b029:	85 c0                	test   %eax,%eax
  80b02b:	74 0d                	je     80b03a <netconn_accept+0x3c>
  80b02d:	83 ec 04             	sub    $0x4,%esp
  80b030:	6a 00                	push   $0x0
  80b032:	6a 01                	push   $0x1
  80b034:	53                   	push   %ebx
  80b035:	ff d0                	call   *%eax
  80b037:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b03a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b03d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b040:	c9                   	leave  
  80b041:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b042:	83 ec 04             	sub    $0x4,%esp
  80b045:	68 6a 33 81 00       	push   $0x81336a
  80b04a:	68 10 01 00 00       	push   $0x110
  80b04f:	68 5a 32 81 00       	push   $0x81325a
  80b054:	e8 16 37 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b059:	83 ec 04             	sub    $0x4,%esp
  80b05c:	68 14 32 81 00       	push   $0x813214
  80b061:	68 11 01 00 00       	push   $0x111
  80b066:	68 5a 32 81 00       	push   $0x81325a
  80b06b:	e8 ff 36 00 00       	call   80e76f <_panic>

0080b070 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b070:	55                   	push   %ebp
  80b071:	89 e5                	mov    %esp,%ebp
  80b073:	53                   	push   %ebx
  80b074:	83 ec 24             	sub    $0x24,%esp
  80b077:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b07a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b081:	85 db                	test   %ebx,%ebx
  80b083:	0f 84 cc 00 00 00    	je     80b155 <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b089:	8b 43 14             	mov    0x14(%ebx),%eax
  80b08c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b08f:	0f 84 d7 00 00 00    	je     80b16c <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b095:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b099:	0f 8c 27 01 00 00    	jl     80b1c6 <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b09f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b0a2:	0f 85 e0 00 00 00    	jne    80b188 <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b0a8:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b0ac:	0f 84 c5 00 00 00    	je     80b177 <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b0b2:	83 ec 0c             	sub    $0xc,%esp
  80b0b5:	6a 06                	push   $0x6
  80b0b7:	e8 a5 94 ff ff       	call   804561 <memp_malloc>
  80b0bc:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b0bf:	83 c4 10             	add    $0x10,%esp
  80b0c2:	85 c0                	test   %eax,%eax
  80b0c4:	0f 84 b8 00 00 00    	je     80b182 <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b0ca:	83 ec 04             	sub    $0x4,%esp
  80b0cd:	6a 00                	push   $0x0
  80b0cf:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b0d2:	50                   	push   %eax
  80b0d3:	ff 73 14             	pushl  0x14(%ebx)
  80b0d6:	e8 0e f3 ff ff       	call   80a3e9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b0db:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b0de:	83 c4 10             	add    $0x10,%esp
  80b0e1:	85 c0                	test   %eax,%eax
  80b0e3:	0f 84 e4 00 00 00    	je     80b1cd <netconn_recv+0x15d>
      len = p->tot_len;
  80b0e9:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b0ed:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b0f1:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b0f4:	85 c9                	test   %ecx,%ecx
  80b0f6:	74 1a                	je     80b112 <netconn_recv+0xa2>
  80b0f8:	83 ec 04             	sub    $0x4,%esp
  80b0fb:	0f b7 d2             	movzwl %dx,%edx
  80b0fe:	52                   	push   %edx
  80b0ff:	6a 01                	push   $0x1
  80b101:	53                   	push   %ebx
  80b102:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b104:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b107:	83 c4 10             	add    $0x10,%esp
  80b10a:	85 c0                	test   %eax,%eax
  80b10c:	0f 84 cb 00 00 00    	je     80b1dd <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b112:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b115:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b117:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b11a:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b11d:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b123:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b12a:	c7 45 e4 5a c2 80 00 	movl   $0x80c25a,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b131:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b134:	8b 02                	mov    (%edx),%eax
  80b136:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b13a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b13e:	83 ec 0c             	sub    $0xc,%esp
  80b141:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b144:	50                   	push   %eax
  80b145:	e8 31 73 ff ff       	call   80247b <tcpip_apimsg>
  80b14a:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b14d:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b150:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b153:	c9                   	leave  
  80b154:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b155:	83 ec 04             	sub    $0x4,%esp
  80b158:	68 87 33 81 00       	push   $0x813387
  80b15d:	68 3a 01 00 00       	push   $0x13a
  80b162:	68 5a 32 81 00       	push   $0x81325a
  80b167:	e8 03 36 00 00       	call   80e76f <_panic>
    conn->err = ERR_CONN;
  80b16c:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b170:	b8 00 00 00 00       	mov    $0x0,%eax
  80b175:	eb d9                	jmp    80b150 <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80b177:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b17b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b180:	eb ce                	jmp    80b150 <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80b182:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b186:	eb c8                	jmp    80b150 <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b188:	83 ec 04             	sub    $0x4,%esp
  80b18b:	6a 00                	push   $0x0
  80b18d:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b190:	52                   	push   %edx
  80b191:	50                   	push   %eax
  80b192:	e8 52 f2 ff ff       	call   80a3e9 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b197:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b19a:	83 c4 10             	add    $0x10,%esp
  80b19d:	85 c0                	test   %eax,%eax
  80b19f:	74 ac                	je     80b14d <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b1a1:	8b 10                	mov    (%eax),%edx
  80b1a3:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b1a7:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b1ab:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b1ae:	85 d2                	test   %edx,%edx
  80b1b0:	74 9b                	je     80b14d <netconn_recv+0xdd>
  80b1b2:	83 ec 04             	sub    $0x4,%esp
  80b1b5:	8b 00                	mov    (%eax),%eax
  80b1b7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b1bb:	50                   	push   %eax
  80b1bc:	6a 01                	push   $0x1
  80b1be:	53                   	push   %ebx
  80b1bf:	ff d2                	call   *%edx
  80b1c1:	83 c4 10             	add    $0x10,%esp
  80b1c4:	eb 87                	jmp    80b14d <netconn_recv+0xdd>
    return NULL;
  80b1c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80b1cb:	eb 83                	jmp    80b150 <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b1cd:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b1d0:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b1d5:	85 c9                	test   %ecx,%ecx
  80b1d7:	0f 85 1b ff ff ff    	jne    80b0f8 <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b1dd:	83 ec 08             	sub    $0x8,%esp
  80b1e0:	ff 75 e0             	pushl  -0x20(%ebp)
  80b1e3:	6a 06                	push   $0x6
  80b1e5:	e8 cd 93 ff ff       	call   8045b7 <memp_free>
      if (conn->err == ERR_OK) {
  80b1ea:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b1ed:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b1f2:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b1f6:	0f 85 54 ff ff ff    	jne    80b150 <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b1fc:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b200:	e9 4b ff ff ff       	jmp    80b150 <netconn_recv+0xe0>

0080b205 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b205:	55                   	push   %ebp
  80b206:	89 e5                	mov    %esp,%ebp
  80b208:	53                   	push   %ebx
  80b209:	83 ec 24             	sub    $0x24,%esp
  80b20c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b20f:	85 db                	test   %ebx,%ebx
  80b211:	74 25                	je     80b238 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b213:	c7 45 e4 b4 c1 80 00 	movl   $0x80c1b4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b21a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b21d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b220:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b223:	83 ec 0c             	sub    $0xc,%esp
  80b226:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b229:	50                   	push   %eax
  80b22a:	e8 4c 72 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80b22f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b233:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b236:	c9                   	leave  
  80b237:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b238:	83 ec 04             	sub    $0x4,%esp
  80b23b:	68 a2 33 81 00       	push   $0x8133a2
  80b240:	68 b9 01 00 00       	push   $0x1b9
  80b245:	68 5a 32 81 00       	push   $0x81325a
  80b24a:	e8 20 35 00 00       	call   80e76f <_panic>

0080b24f <netconn_sendto>:
{
  80b24f:	55                   	push   %ebp
  80b250:	89 e5                	mov    %esp,%ebp
  80b252:	83 ec 08             	sub    $0x8,%esp
  80b255:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b258:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b25b:	85 c0                	test   %eax,%eax
  80b25d:	74 1b                	je     80b27a <netconn_sendto+0x2b>
    buf->addr = addr;
  80b25f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b262:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b265:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b269:	83 ec 08             	sub    $0x8,%esp
  80b26c:	50                   	push   %eax
  80b26d:	ff 75 08             	pushl  0x8(%ebp)
  80b270:	e8 90 ff ff ff       	call   80b205 <netconn_send>
  80b275:	83 c4 10             	add    $0x10,%esp
}
  80b278:	c9                   	leave  
  80b279:	c3                   	ret    
  return ERR_VAL;
  80b27a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b27f:	eb f7                	jmp    80b278 <netconn_sendto+0x29>

0080b281 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b281:	55                   	push   %ebp
  80b282:	89 e5                	mov    %esp,%ebp
  80b284:	53                   	push   %ebx
  80b285:	83 ec 24             	sub    $0x24,%esp
  80b288:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b28b:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b28e:	85 db                	test   %ebx,%ebx
  80b290:	74 33                	je     80b2c5 <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b292:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b295:	75 45                	jne    80b2dc <netconn_write+0x5b>

  msg.function = do_write;
  80b297:	c7 45 e4 a0 c2 80 00 	movl   $0x80c2a0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b29e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b2a1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b2a4:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b2a7:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b2aa:	8b 45 10             	mov    0x10(%ebp),%eax
  80b2ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b2b0:	83 ec 0c             	sub    $0xc,%esp
  80b2b3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b2b6:	50                   	push   %eax
  80b2b7:	e8 bf 71 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80b2bc:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b2c0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b2c3:	c9                   	leave  
  80b2c4:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b2c5:	83 ec 04             	sub    $0x4,%esp
  80b2c8:	68 bd 33 81 00       	push   $0x8133bd
  80b2cd:	68 d3 01 00 00       	push   $0x1d3
  80b2d2:	68 5a 32 81 00       	push   $0x81325a
  80b2d7:	e8 93 34 00 00       	call   80e76f <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b2dc:	83 ec 04             	sub    $0x4,%esp
  80b2df:	68 38 32 81 00       	push   $0x813238
  80b2e4:	68 d4 01 00 00       	push   $0x1d4
  80b2e9:	68 5a 32 81 00       	push   $0x81325a
  80b2ee:	e8 7c 34 00 00       	call   80e76f <_panic>

0080b2f3 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b2f3:	55                   	push   %ebp
  80b2f4:	89 e5                	mov    %esp,%ebp
  80b2f6:	53                   	push   %ebx
  80b2f7:	83 ec 24             	sub    $0x24,%esp
  80b2fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b2fd:	85 db                	test   %ebx,%ebx
  80b2ff:	74 1f                	je     80b320 <netconn_close+0x2d>

  msg.function = do_close;
  80b301:	c7 45 e4 b7 c3 80 00 	movl   $0x80c3b7,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b308:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b30b:	83 ec 0c             	sub    $0xc,%esp
  80b30e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b311:	50                   	push   %eax
  80b312:	e8 64 71 ff ff       	call   80247b <tcpip_apimsg>
  return conn->err;
  80b317:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b31b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b31e:	c9                   	leave  
  80b31f:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b320:	83 ec 04             	sub    $0x4,%esp
  80b323:	68 d9 33 81 00       	push   $0x8133d9
  80b328:	68 ed 01 00 00       	push   $0x1ed
  80b32d:	68 5a 32 81 00       	push   $0x81325a
  80b332:	e8 38 34 00 00       	call   80e76f <_panic>

0080b337 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b337:	55                   	push   %ebp
  80b338:	89 e5                	mov    %esp,%ebp
  80b33a:	56                   	push   %esi
  80b33b:	53                   	push   %ebx
  80b33c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b33f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b342:	8b 75 10             	mov    0x10(%ebp),%esi
  80b345:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b348:	85 c0                	test   %eax,%eax
  80b34a:	74 5a                	je     80b3a6 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b34c:	85 db                	test   %ebx,%ebx
  80b34e:	74 6d                	je     80b3bd <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b350:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b353:	75 7f                	jne    80b3d4 <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b355:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b359:	0f 84 8c 00 00 00    	je     80b3eb <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b35f:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b362:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b367:	85 f6                	test   %esi,%esi
  80b369:	74 08                	je     80b373 <recv_tcp+0x3c>
    len = p->tot_len;
  80b36b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b36f:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b373:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b376:	85 d2                	test   %edx,%edx
  80b378:	74 0f                	je     80b389 <recv_tcp+0x52>
  80b37a:	83 ec 04             	sub    $0x4,%esp
  80b37d:	0f b7 c0             	movzwl %ax,%eax
  80b380:	50                   	push   %eax
  80b381:	6a 00                	push   $0x0
  80b383:	53                   	push   %ebx
  80b384:	ff d2                	call   *%edx
  80b386:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b389:	83 ec 08             	sub    $0x8,%esp
  80b38c:	56                   	push   %esi
  80b38d:	ff 73 14             	pushl  0x14(%ebx)
  80b390:	e8 5f ef ff ff       	call   80a2f4 <sys_mbox_trypost>
  80b395:	83 c4 10             	add    $0x10,%esp
  80b398:	84 c0                	test   %al,%al
  80b39a:	0f 95 c0             	setne  %al
  80b39d:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b39f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b3a2:	5b                   	pop    %ebx
  80b3a3:	5e                   	pop    %esi
  80b3a4:	5d                   	pop    %ebp
  80b3a5:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b3a6:	83 ec 04             	sub    $0x4,%esp
  80b3a9:	68 f8 33 81 00       	push   $0x8133f8
  80b3ae:	68 c1 00 00 00       	push   $0xc1
  80b3b3:	68 42 35 81 00       	push   $0x813542
  80b3b8:	e8 b2 33 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b3bd:	83 ec 04             	sub    $0x4,%esp
  80b3c0:	68 1c 34 81 00       	push   $0x81341c
  80b3c5:	68 c2 00 00 00       	push   $0xc2
  80b3ca:	68 42 35 81 00       	push   $0x813542
  80b3cf:	e8 9b 33 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b3d4:	83 ec 04             	sub    $0x4,%esp
  80b3d7:	68 59 35 81 00       	push   $0x813559
  80b3dc:	68 c4 00 00 00       	push   $0xc4
  80b3e1:	68 42 35 81 00       	push   $0x813542
  80b3e6:	e8 84 33 00 00       	call   80e76f <_panic>
    return ERR_VAL;
  80b3eb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b3f0:	eb ad                	jmp    80b39f <recv_tcp+0x68>

0080b3f2 <recv_udp>:
{
  80b3f2:	55                   	push   %ebp
  80b3f3:	89 e5                	mov    %esp,%ebp
  80b3f5:	57                   	push   %edi
  80b3f6:	56                   	push   %esi
  80b3f7:	53                   	push   %ebx
  80b3f8:	83 ec 1c             	sub    $0x1c,%esp
  80b3fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b401:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b404:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b407:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b40a:	85 c0                	test   %eax,%eax
  80b40c:	74 7f                	je     80b48d <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b40e:	85 db                	test   %ebx,%ebx
  80b410:	0f 84 8e 00 00 00    	je     80b4a4 <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b416:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b419:	0f 85 9c 00 00 00    	jne    80b4bb <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b41f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b423:	0f 84 a9 00 00 00    	je     80b4d2 <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b429:	83 ec 0c             	sub    $0xc,%esp
  80b42c:	6a 06                	push   $0x6
  80b42e:	e8 2e 91 ff ff       	call   804561 <memp_malloc>
  80b433:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b435:	83 c4 10             	add    $0x10,%esp
  80b438:	85 c0                	test   %eax,%eax
  80b43a:	0f 84 a0 00 00 00    	je     80b4e0 <recv_udp+0xee>
    buf->p = p;
  80b440:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b442:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b445:	8b 45 14             	mov    0x14(%ebp),%eax
  80b448:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b44b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b44f:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b453:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b457:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b45b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b45e:	85 c0                	test   %eax,%eax
  80b460:	74 10                	je     80b472 <recv_udp+0x80>
  80b462:	83 ec 04             	sub    $0x4,%esp
  80b465:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b469:	52                   	push   %edx
  80b46a:	6a 00                	push   $0x0
  80b46c:	53                   	push   %ebx
  80b46d:	ff d0                	call   *%eax
  80b46f:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b472:	83 ec 08             	sub    $0x8,%esp
  80b475:	56                   	push   %esi
  80b476:	ff 73 14             	pushl  0x14(%ebx)
  80b479:	e8 76 ee ff ff       	call   80a2f4 <sys_mbox_trypost>
  80b47e:	83 c4 10             	add    $0x10,%esp
  80b481:	84 c0                	test   %al,%al
  80b483:	75 69                	jne    80b4ee <recv_udp+0xfc>
}
  80b485:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b488:	5b                   	pop    %ebx
  80b489:	5e                   	pop    %esi
  80b48a:	5f                   	pop    %edi
  80b48b:	5d                   	pop    %ebp
  80b48c:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b48d:	83 ec 04             	sub    $0x4,%esp
  80b490:	68 3c 34 81 00       	push   $0x81343c
  80b495:	68 8e 00 00 00       	push   $0x8e
  80b49a:	68 42 35 81 00       	push   $0x813542
  80b49f:	e8 cb 32 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b4a4:	83 ec 04             	sub    $0x4,%esp
  80b4a7:	68 60 34 81 00       	push   $0x813460
  80b4ac:	68 8f 00 00 00       	push   $0x8f
  80b4b1:	68 42 35 81 00       	push   $0x813542
  80b4b6:	e8 b4 32 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b4bb:	83 ec 04             	sub    $0x4,%esp
  80b4be:	68 77 35 81 00       	push   $0x813577
  80b4c3:	68 91 00 00 00       	push   $0x91
  80b4c8:	68 42 35 81 00       	push   $0x813542
  80b4cd:	e8 9d 32 00 00       	call   80e76f <_panic>
    pbuf_free(p);
  80b4d2:	83 ec 0c             	sub    $0xc,%esp
  80b4d5:	57                   	push   %edi
  80b4d6:	e8 29 94 ff ff       	call   804904 <pbuf_free>
    return;
  80b4db:	83 c4 10             	add    $0x10,%esp
  80b4de:	eb a5                	jmp    80b485 <recv_udp+0x93>
    pbuf_free(p);
  80b4e0:	83 ec 0c             	sub    $0xc,%esp
  80b4e3:	57                   	push   %edi
  80b4e4:	e8 1b 94 ff ff       	call   804904 <pbuf_free>
    return;
  80b4e9:	83 c4 10             	add    $0x10,%esp
  80b4ec:	eb 97                	jmp    80b485 <recv_udp+0x93>
    netbuf_delete(buf);
  80b4ee:	83 ec 0c             	sub    $0xc,%esp
  80b4f1:	56                   	push   %esi
  80b4f2:	e8 74 70 ff ff       	call   80256b <netbuf_delete>
    return;
  80b4f7:	83 c4 10             	add    $0x10,%esp
  80b4fa:	eb 89                	jmp    80b485 <recv_udp+0x93>

0080b4fc <recv_raw>:
{
  80b4fc:	55                   	push   %ebp
  80b4fd:	89 e5                	mov    %esp,%ebp
  80b4ff:	57                   	push   %edi
  80b500:	56                   	push   %esi
  80b501:	53                   	push   %ebx
  80b502:	83 ec 0c             	sub    $0xc,%esp
  80b505:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b508:	85 db                	test   %ebx,%ebx
  80b50a:	74 06                	je     80b512 <recv_raw+0x16>
  80b50c:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b510:	75 0d                	jne    80b51f <recv_raw+0x23>
}
  80b512:	b8 00 00 00 00       	mov    $0x0,%eax
  80b517:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b51a:	5b                   	pop    %ebx
  80b51b:	5e                   	pop    %esi
  80b51c:	5f                   	pop    %edi
  80b51d:	5d                   	pop    %ebp
  80b51e:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b51f:	83 ec 04             	sub    $0x4,%esp
  80b522:	6a 00                	push   $0x0
  80b524:	8b 45 10             	mov    0x10(%ebp),%eax
  80b527:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b52b:	50                   	push   %eax
  80b52c:	6a 03                	push   $0x3
  80b52e:	e8 97 94 ff ff       	call   8049ca <pbuf_alloc>
  80b533:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b535:	83 c4 10             	add    $0x10,%esp
  80b538:	85 c0                	test   %eax,%eax
  80b53a:	74 d6                	je     80b512 <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b53c:	83 ec 08             	sub    $0x8,%esp
  80b53f:	ff 75 10             	pushl  0x10(%ebp)
  80b542:	50                   	push   %eax
  80b543:	e8 64 99 ff ff       	call   804eac <pbuf_copy>
  80b548:	83 c4 10             	add    $0x10,%esp
  80b54b:	84 c0                	test   %al,%al
  80b54d:	75 73                	jne    80b5c2 <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b54f:	83 ec 0c             	sub    $0xc,%esp
  80b552:	6a 06                	push   $0x6
  80b554:	e8 08 90 ff ff       	call   804561 <memp_malloc>
  80b559:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b55b:	83 c4 10             	add    $0x10,%esp
  80b55e:	85 c0                	test   %eax,%eax
  80b560:	74 71                	je     80b5d3 <recv_raw+0xd7>
      buf->p = q;
  80b562:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b564:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b567:	8b 46 04             	mov    0x4(%esi),%eax
  80b56a:	83 c0 0c             	add    $0xc,%eax
  80b56d:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b570:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b573:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b577:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b57b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b57f:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b583:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b586:	85 c0                	test   %eax,%eax
  80b588:	74 10                	je     80b59a <recv_raw+0x9e>
  80b58a:	83 ec 04             	sub    $0x4,%esp
  80b58d:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b591:	52                   	push   %edx
  80b592:	6a 00                	push   $0x0
  80b594:	53                   	push   %ebx
  80b595:	ff d0                	call   *%eax
  80b597:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b59a:	83 ec 08             	sub    $0x8,%esp
  80b59d:	57                   	push   %edi
  80b59e:	ff 73 14             	pushl  0x14(%ebx)
  80b5a1:	e8 4e ed ff ff       	call   80a2f4 <sys_mbox_trypost>
  80b5a6:	83 c4 10             	add    $0x10,%esp
  80b5a9:	84 c0                	test   %al,%al
  80b5ab:	0f 84 61 ff ff ff    	je     80b512 <recv_raw+0x16>
        netbuf_delete(buf);
  80b5b1:	83 ec 0c             	sub    $0xc,%esp
  80b5b4:	57                   	push   %edi
  80b5b5:	e8 b1 6f ff ff       	call   80256b <netbuf_delete>
  80b5ba:	83 c4 10             	add    $0x10,%esp
  80b5bd:	e9 50 ff ff ff       	jmp    80b512 <recv_raw+0x16>
        pbuf_free(q);
  80b5c2:	83 ec 0c             	sub    $0xc,%esp
  80b5c5:	56                   	push   %esi
  80b5c6:	e8 39 93 ff ff       	call   804904 <pbuf_free>
  80b5cb:	83 c4 10             	add    $0x10,%esp
  80b5ce:	e9 3f ff ff ff       	jmp    80b512 <recv_raw+0x16>
        pbuf_free(q);
  80b5d3:	83 ec 0c             	sub    $0xc,%esp
  80b5d6:	56                   	push   %esi
  80b5d7:	e8 28 93 ff ff       	call   804904 <pbuf_free>
        return 0;
  80b5dc:	83 c4 10             	add    $0x10,%esp
  80b5df:	e9 2e ff ff ff       	jmp    80b512 <recv_raw+0x16>

0080b5e4 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b5e4:	55                   	push   %ebp
  80b5e5:	89 e5                	mov    %esp,%ebp
  80b5e7:	53                   	push   %ebx
  80b5e8:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b5eb:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b5ee:	50                   	push   %eax
  80b5ef:	53                   	push   %ebx
  80b5f0:	e8 dc a2 ff ff       	call   8058d1 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b5f5:	83 c4 08             	add    $0x8,%esp
  80b5f8:	68 37 b3 80 00       	push   $0x80b337
  80b5fd:	53                   	push   %ebx
  80b5fe:	e8 dc a2 ff ff       	call   8058df <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b603:	83 c4 08             	add    $0x8,%esp
  80b606:	68 c6 ba 80 00       	push   $0x80bac6
  80b60b:	53                   	push   %ebx
  80b60c:	e8 df a2 ff ff       	call   8058f0 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b611:	83 c4 0c             	add    $0xc,%esp
  80b614:	6a 04                	push   $0x4
  80b616:	68 80 ba 80 00       	push   $0x80ba80
  80b61b:	53                   	push   %ebx
  80b61c:	e8 ff a2 ff ff       	call   805920 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b621:	83 c4 08             	add    $0x8,%esp
  80b624:	68 83 b6 80 00       	push   $0x80b683
  80b629:	53                   	push   %ebx
  80b62a:	e8 d2 a2 ff ff       	call   805901 <tcp_err>
}
  80b62f:	83 c4 10             	add    $0x10,%esp
  80b632:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b635:	c9                   	leave  
  80b636:	c3                   	ret    

0080b637 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b637:	55                   	push   %ebp
  80b638:	89 e5                	mov    %esp,%ebp
  80b63a:	53                   	push   %ebx
  80b63b:	83 ec 04             	sub    $0x4,%esp
  80b63e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b641:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b644:	85 db                	test   %ebx,%ebx
  80b646:	74 34                	je     80b67c <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b648:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b64b:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b64e:	75 04                	jne    80b654 <do_connected+0x1d>
  80b650:	84 c0                	test   %al,%al
  80b652:	74 1f                	je     80b673 <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b654:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b65b:	83 ec 0c             	sub    $0xc,%esp
  80b65e:	ff 73 10             	pushl  0x10(%ebx)
  80b661:	e8 0e eb ff ff       	call   80a174 <sys_sem_signal>
  return ERR_OK;
  80b666:	83 c4 10             	add    $0x10,%esp
  80b669:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b66e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b671:	c9                   	leave  
  80b672:	c3                   	ret    
    setup_tcp(conn);
  80b673:	89 d8                	mov    %ebx,%eax
  80b675:	e8 6a ff ff ff       	call   80b5e4 <setup_tcp>
  80b67a:	eb d8                	jmp    80b654 <do_connected+0x1d>
    return ERR_VAL;
  80b67c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b681:	eb eb                	jmp    80b66e <do_connected+0x37>

0080b683 <err_tcp>:
{
  80b683:	55                   	push   %ebp
  80b684:	89 e5                	mov    %esp,%ebp
  80b686:	53                   	push   %ebx
  80b687:	83 ec 04             	sub    $0x4,%esp
  80b68a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b68d:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b690:	85 db                	test   %ebx,%ebx
  80b692:	74 7e                	je     80b712 <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b694:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b69b:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b69e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b6a2:	74 24                	je     80b6c8 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b6a4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6a7:	85 c0                	test   %eax,%eax
  80b6a9:	74 0d                	je     80b6b8 <err_tcp+0x35>
  80b6ab:	83 ec 04             	sub    $0x4,%esp
  80b6ae:	6a 00                	push   $0x0
  80b6b0:	6a 00                	push   $0x0
  80b6b2:	53                   	push   %ebx
  80b6b3:	ff d0                	call   *%eax
  80b6b5:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b6b8:	83 ec 08             	sub    $0x8,%esp
  80b6bb:	6a 00                	push   $0x0
  80b6bd:	ff 73 14             	pushl  0x14(%ebx)
  80b6c0:	e8 f4 ec ff ff       	call   80a3b9 <sys_mbox_post>
  80b6c5:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b6c8:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6cb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b6ce:	74 06                	je     80b6d6 <err_tcp+0x53>
  80b6d0:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b6d4:	74 53                	je     80b729 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b6d6:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b6da:	74 24                	je     80b700 <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b6dc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b6df:	85 c0                	test   %eax,%eax
  80b6e1:	74 0d                	je     80b6f0 <err_tcp+0x6d>
  80b6e3:	83 ec 04             	sub    $0x4,%esp
  80b6e6:	6a 00                	push   $0x0
  80b6e8:	6a 00                	push   $0x0
  80b6ea:	53                   	push   %ebx
  80b6eb:	ff d0                	call   *%eax
  80b6ed:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b6f0:	83 ec 08             	sub    $0x8,%esp
  80b6f3:	6a 00                	push   $0x0
  80b6f5:	ff 73 18             	pushl  0x18(%ebx)
  80b6f8:	e8 bc ec ff ff       	call   80a3b9 <sys_mbox_post>
  80b6fd:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b700:	8b 43 04             	mov    0x4(%ebx),%eax
  80b703:	83 f8 01             	cmp    $0x1,%eax
  80b706:	74 36                	je     80b73e <err_tcp+0xbb>
  80b708:	83 f8 04             	cmp    $0x4,%eax
  80b70b:	74 31                	je     80b73e <err_tcp+0xbb>
}
  80b70d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b710:	c9                   	leave  
  80b711:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b712:	83 ec 04             	sub    $0x4,%esp
  80b715:	68 95 35 81 00       	push   $0x813595
  80b71a:	68 22 01 00 00       	push   $0x122
  80b71f:	68 42 35 81 00       	push   $0x813542
  80b724:	e8 46 30 00 00       	call   80e76f <_panic>
    conn->state = NETCONN_NONE;
  80b729:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b730:	83 ec 0c             	sub    $0xc,%esp
  80b733:	50                   	push   %eax
  80b734:	e8 3b ea ff ff       	call   80a174 <sys_sem_signal>
  80b739:	83 c4 10             	add    $0x10,%esp
  80b73c:	eb 98                	jmp    80b6d6 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b73e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b745:	83 ec 0c             	sub    $0xc,%esp
  80b748:	ff 73 10             	pushl  0x10(%ebx)
  80b74b:	e8 24 ea ff ff       	call   80a174 <sys_sem_signal>
  80b750:	83 c4 10             	add    $0x10,%esp
}
  80b753:	eb b8                	jmp    80b70d <err_tcp+0x8a>

0080b755 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b755:	55                   	push   %ebp
  80b756:	89 e5                	mov    %esp,%ebp
  80b758:	57                   	push   %edi
  80b759:	56                   	push   %esi
  80b75a:	53                   	push   %ebx
  80b75b:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b75e:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b762:	0f 85 c9 00 00 00    	jne    80b831 <do_writemore+0xdc>
  80b768:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b76a:	8b 40 24             	mov    0x24(%eax),%eax
  80b76d:	8b 7e 28             	mov    0x28(%esi),%edi
  80b770:	89 fa                	mov    %edi,%edx
  80b772:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b775:	8b 58 08             	mov    0x8(%eax),%ebx
  80b778:	89 d9                	mov    %ebx,%ecx
  80b77a:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b77c:	29 fb                	sub    %edi,%ebx
  80b77e:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b784:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b789:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b78c:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b78f:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b793:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b798:	0f b7 db             	movzwl %bx,%ebx
  80b79b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b79f:	50                   	push   %eax
  80b7a0:	53                   	push   %ebx
  80b7a1:	52                   	push   %edx
  80b7a2:	51                   	push   %ecx
  80b7a3:	e8 40 c9 ff ff       	call   8080e8 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b7a8:	89 da                	mov    %ebx,%edx
  80b7aa:	03 56 28             	add    0x28(%esi),%edx
  80b7ad:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b7b0:	83 c4 10             	add    $0x10,%esp
  80b7b3:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b7b6:	0f 8f 8c 00 00 00    	jg     80b848 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b7bc:	84 c0                	test   %al,%al
  80b7be:	0f 85 bf 00 00 00    	jne    80b883 <do_writemore+0x12e>
    conn->write_offset += len;
  80b7c4:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b7c7:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b7cc:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b7cf:	0f 84 8a 00 00 00    	je     80b85f <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b7d5:	8b 46 08             	mov    0x8(%esi),%eax
  80b7d8:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b7dc:	74 1a                	je     80b7f8 <do_writemore+0xa3>
  80b7de:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b7e2:	75 14                	jne    80b7f8 <do_writemore+0xa3>
  80b7e4:	8b 50 74             	mov    0x74(%eax),%edx
  80b7e7:	85 d2                	test   %edx,%edx
  80b7e9:	0f 84 88 00 00 00    	je     80b877 <do_writemore+0x122>
  80b7ef:	83 3a 00             	cmpl   $0x0,(%edx)
  80b7f2:	0f 84 85 00 00 00    	je     80b87d <do_writemore+0x128>
  80b7f8:	83 ec 0c             	sub    $0xc,%esp
  80b7fb:	50                   	push   %eax
  80b7fc:	e8 3e c9 ff ff       	call   80813f <tcp_output>
    conn->err = err;
  80b801:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b804:	83 c4 10             	add    $0x10,%esp
  80b807:	84 c0                	test   %al,%al
  80b809:	75 1e                	jne    80b829 <do_writemore+0xd4>
  80b80b:	8b 46 08             	mov    0x8(%esi),%eax
  80b80e:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b814:	77 13                	ja     80b829 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b816:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b819:	85 c0                	test   %eax,%eax
  80b81b:	74 0c                	je     80b829 <do_writemore+0xd4>
  80b81d:	83 ec 04             	sub    $0x4,%esp
  80b820:	53                   	push   %ebx
  80b821:	6a 03                	push   $0x3
  80b823:	56                   	push   %esi
  80b824:	ff d0                	call   *%eax
  80b826:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b829:	89 f8                	mov    %edi,%eax
  80b82b:	84 c0                	test   %al,%al
  80b82d:	74 70                	je     80b89f <do_writemore+0x14a>
  80b82f:	eb 59                	jmp    80b88a <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b831:	83 ec 04             	sub    $0x4,%esp
  80b834:	68 a2 35 81 00       	push   $0x8135a2
  80b839:	68 b8 03 00 00       	push   $0x3b8
  80b83e:	68 42 35 81 00       	push   $0x813542
  80b843:	e8 27 2f 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b848:	83 ec 04             	sub    $0x4,%esp
  80b84b:	68 bf 35 81 00       	push   $0x8135bf
  80b850:	68 cd 03 00 00       	push   $0x3cd
  80b855:	68 42 35 81 00       	push   $0x813542
  80b85a:	e8 10 2f 00 00       	call   80e76f <_panic>
      conn->write_msg = NULL;
  80b85f:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b866:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b86d:	bf 01 00 00 00       	mov    $0x1,%edi
  80b872:	e9 5e ff ff ff       	jmp    80b7d5 <do_writemore+0x80>
    conn->err = err;
  80b877:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b87b:	eb 8e                	jmp    80b80b <do_writemore+0xb6>
  80b87d:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b881:	eb 88                	jmp    80b80b <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b883:	3c ff                	cmp    $0xff,%al
  80b885:	74 25                	je     80b8ac <do_writemore+0x157>
    conn->err = err;
  80b887:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b88a:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b891:	83 ec 0c             	sub    $0xc,%esp
  80b894:	ff 76 10             	pushl  0x10(%esi)
  80b897:	e8 d8 e8 ff ff       	call   80a174 <sys_sem_signal>
  80b89c:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b89f:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b8a7:	5b                   	pop    %ebx
  80b8a8:	5e                   	pop    %esi
  80b8a9:	5f                   	pop    %edi
  80b8aa:	5d                   	pop    %ebp
  80b8ab:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b8ac:	83 ec 0c             	sub    $0xc,%esp
  80b8af:	ff 76 08             	pushl  0x8(%esi)
  80b8b2:	e8 88 c8 ff ff       	call   80813f <tcp_output>
  80b8b7:	83 c4 10             	add    $0x10,%esp
  80b8ba:	eb e3                	jmp    80b89f <do_writemore+0x14a>

0080b8bc <do_close_internal>:
{
  80b8bc:	55                   	push   %ebp
  80b8bd:	89 e5                	mov    %esp,%ebp
  80b8bf:	53                   	push   %ebx
  80b8c0:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b8c3:	85 c0                	test   %eax,%eax
  80b8c5:	0f 84 e2 00 00 00    	je     80b9ad <do_close_internal+0xf1>
  80b8cb:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b8cd:	83 38 10             	cmpl   $0x10,(%eax)
  80b8d0:	0f 85 ee 00 00 00    	jne    80b9c4 <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b8d6:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b8da:	0f 85 fb 00 00 00    	jne    80b9db <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b8e0:	8b 40 08             	mov    0x8(%eax),%eax
  80b8e3:	85 c0                	test   %eax,%eax
  80b8e5:	0f 84 07 01 00 00    	je     80b9f2 <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b8eb:	83 ec 08             	sub    $0x8,%esp
  80b8ee:	6a 00                	push   $0x0
  80b8f0:	50                   	push   %eax
  80b8f1:	e8 db 9f ff ff       	call   8058d1 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b8f6:	8b 43 08             	mov    0x8(%ebx),%eax
  80b8f9:	83 c4 10             	add    $0x10,%esp
  80b8fc:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b900:	0f 84 03 01 00 00    	je     80ba09 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b906:	83 ec 08             	sub    $0x8,%esp
  80b909:	6a 00                	push   $0x0
  80b90b:	50                   	push   %eax
  80b90c:	e8 ce 9f ff ff       	call   8058df <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b911:	83 c4 08             	add    $0x8,%esp
  80b914:	6a 00                	push   $0x0
  80b916:	ff 73 08             	pushl  0x8(%ebx)
  80b919:	e8 f4 9f ff ff       	call   805912 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b91e:	83 c4 08             	add    $0x8,%esp
  80b921:	6a 00                	push   $0x0
  80b923:	ff 73 08             	pushl  0x8(%ebx)
  80b926:	e8 c5 9f ff ff       	call   8058f0 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b92b:	83 c4 0c             	add    $0xc,%esp
  80b92e:	6a 04                	push   $0x4
  80b930:	6a 00                	push   $0x0
  80b932:	ff 73 08             	pushl  0x8(%ebx)
  80b935:	e8 e6 9f ff ff       	call   805920 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b93a:	83 c4 08             	add    $0x8,%esp
  80b93d:	6a 00                	push   $0x0
  80b93f:	ff 73 08             	pushl  0x8(%ebx)
  80b942:	e8 ba 9f ff ff       	call   805901 <tcp_err>
  80b947:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b94a:	83 ec 0c             	sub    $0xc,%esp
  80b94d:	ff 73 08             	pushl  0x8(%ebx)
  80b950:	e8 7e a1 ff ff       	call   805ad3 <tcp_close>
  if (err == ERR_OK) {
  80b955:	83 c4 10             	add    $0x10,%esp
  80b958:	84 c0                	test   %al,%al
  80b95a:	0f 85 bc 00 00 00    	jne    80ba1c <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b960:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b967:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b96e:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b972:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b975:	85 c0                	test   %eax,%eax
  80b977:	74 21                	je     80b99a <do_close_internal+0xde>
  80b979:	83 ec 04             	sub    $0x4,%esp
  80b97c:	6a 00                	push   $0x0
  80b97e:	6a 00                	push   $0x0
  80b980:	53                   	push   %ebx
  80b981:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b983:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b986:	83 c4 10             	add    $0x10,%esp
  80b989:	85 c0                	test   %eax,%eax
  80b98b:	74 0d                	je     80b99a <do_close_internal+0xde>
  80b98d:	83 ec 04             	sub    $0x4,%esp
  80b990:	6a 00                	push   $0x0
  80b992:	6a 02                	push   $0x2
  80b994:	53                   	push   %ebx
  80b995:	ff d0                	call   *%eax
  80b997:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b99a:	83 ec 0c             	sub    $0xc,%esp
  80b99d:	ff 73 10             	pushl  0x10(%ebx)
  80b9a0:	e8 cf e7 ff ff       	call   80a174 <sys_sem_signal>
  80b9a5:	83 c4 10             	add    $0x10,%esp
}
  80b9a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b9ab:	c9                   	leave  
  80b9ac:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b9ad:	83 ec 04             	sub    $0x4,%esp
  80b9b0:	68 b0 33 81 00       	push   $0x8133b0
  80b9b5:	68 53 02 00 00       	push   $0x253
  80b9ba:	68 42 35 81 00       	push   $0x813542
  80b9bf:	e8 ab 2d 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b9c4:	83 ec 04             	sub    $0x4,%esp
  80b9c7:	68 dd 35 81 00       	push   $0x8135dd
  80b9cc:	68 54 02 00 00       	push   $0x254
  80b9d1:	68 42 35 81 00       	push   $0x813542
  80b9d6:	e8 94 2d 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b9db:	83 ec 04             	sub    $0x4,%esp
  80b9de:	68 80 34 81 00       	push   $0x813480
  80b9e3:	68 55 02 00 00       	push   $0x255
  80b9e8:	68 42 35 81 00       	push   $0x813542
  80b9ed:	e8 7d 2d 00 00       	call   80e76f <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b9f2:	83 ec 04             	sub    $0x4,%esp
  80b9f5:	68 fb 35 81 00       	push   $0x8135fb
  80b9fa:	68 56 02 00 00       	push   $0x256
  80b9ff:	68 42 35 81 00       	push   $0x813542
  80ba04:	e8 66 2d 00 00       	call   80e76f <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80ba09:	83 ec 08             	sub    $0x8,%esp
  80ba0c:	6a 00                	push   $0x0
  80ba0e:	50                   	push   %eax
  80ba0f:	e8 fe 9e ff ff       	call   805912 <tcp_accept>
  80ba14:	83 c4 10             	add    $0x10,%esp
  80ba17:	e9 2e ff ff ff       	jmp    80b94a <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ba1c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba1f:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ba23:	74 44                	je     80ba69 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80ba25:	83 ec 08             	sub    $0x8,%esp
  80ba28:	68 c6 ba 80 00       	push   $0x80bac6
  80ba2d:	50                   	push   %eax
  80ba2e:	e8 bd 9e ff ff       	call   8058f0 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80ba33:	83 c4 0c             	add    $0xc,%esp
  80ba36:	6a 04                	push   $0x4
  80ba38:	68 80 ba 80 00       	push   $0x80ba80
  80ba3d:	ff 73 08             	pushl  0x8(%ebx)
  80ba40:	e8 db 9e ff ff       	call   805920 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ba45:	83 c4 08             	add    $0x8,%esp
  80ba48:	68 83 b6 80 00       	push   $0x80b683
  80ba4d:	ff 73 08             	pushl  0x8(%ebx)
  80ba50:	e8 ac 9e ff ff       	call   805901 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80ba55:	83 c4 08             	add    $0x8,%esp
  80ba58:	53                   	push   %ebx
  80ba59:	ff 73 08             	pushl  0x8(%ebx)
  80ba5c:	e8 70 9e ff ff       	call   8058d1 <tcp_arg>
  80ba61:	83 c4 10             	add    $0x10,%esp
}
  80ba64:	e9 3f ff ff ff       	jmp    80b9a8 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ba69:	83 ec 04             	sub    $0x4,%esp
  80ba6c:	68 a4 34 81 00       	push   $0x8134a4
  80ba71:	68 75 02 00 00       	push   $0x275
  80ba76:	68 42 35 81 00       	push   $0x813542
  80ba7b:	e8 ef 2c 00 00       	call   80e76f <_panic>

0080ba80 <poll_tcp>:
{
  80ba80:	55                   	push   %ebp
  80ba81:	89 e5                	mov    %esp,%ebp
  80ba83:	83 ec 08             	sub    $0x8,%esp
  80ba86:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba89:	85 c0                	test   %eax,%eax
  80ba8b:	74 14                	je     80baa1 <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80ba8d:	8b 50 04             	mov    0x4(%eax),%edx
  80ba90:	83 fa 01             	cmp    $0x1,%edx
  80ba93:	74 23                	je     80bab8 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80ba95:	83 fa 04             	cmp    $0x4,%edx
  80ba98:	74 25                	je     80babf <poll_tcp+0x3f>
}
  80ba9a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba9f:	c9                   	leave  
  80baa0:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80baa1:	83 ec 04             	sub    $0x4,%esp
  80baa4:	68 95 35 81 00       	push   $0x813595
  80baa9:	68 eb 00 00 00       	push   $0xeb
  80baae:	68 42 35 81 00       	push   $0x813542
  80bab3:	e8 b7 2c 00 00       	call   80e76f <_panic>
    do_writemore(conn);
  80bab8:	e8 98 fc ff ff       	call   80b755 <do_writemore>
  80babd:	eb db                	jmp    80ba9a <poll_tcp+0x1a>
    do_close_internal(conn);
  80babf:	e8 f8 fd ff ff       	call   80b8bc <do_close_internal>
  80bac4:	eb d4                	jmp    80ba9a <poll_tcp+0x1a>

0080bac6 <sent_tcp>:
{
  80bac6:	55                   	push   %ebp
  80bac7:	89 e5                	mov    %esp,%ebp
  80bac9:	56                   	push   %esi
  80baca:	53                   	push   %ebx
  80bacb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bace:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bad1:	85 db                	test   %ebx,%ebx
  80bad3:	74 3e                	je     80bb13 <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80bad5:	8b 43 04             	mov    0x4(%ebx),%eax
  80bad8:	83 f8 01             	cmp    $0x1,%eax
  80badb:	74 4d                	je     80bb2a <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80badd:	83 f8 04             	cmp    $0x4,%eax
  80bae0:	74 6e                	je     80bb50 <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80bae2:	8b 43 08             	mov    0x8(%ebx),%eax
  80bae5:	85 c0                	test   %eax,%eax
  80bae7:	74 1e                	je     80bb07 <sent_tcp+0x41>
  80bae9:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80baef:	76 16                	jbe    80bb07 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80baf1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80baf4:	85 c0                	test   %eax,%eax
  80baf6:	74 0f                	je     80bb07 <sent_tcp+0x41>
  80baf8:	83 ec 04             	sub    $0x4,%esp
  80bafb:	0f b7 f6             	movzwl %si,%esi
  80bafe:	56                   	push   %esi
  80baff:	6a 02                	push   $0x2
  80bb01:	53                   	push   %ebx
  80bb02:	ff d0                	call   *%eax
  80bb04:	83 c4 10             	add    $0x10,%esp
}
  80bb07:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb0c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bb0f:	5b                   	pop    %ebx
  80bb10:	5e                   	pop    %esi
  80bb11:	5d                   	pop    %ebp
  80bb12:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bb13:	83 ec 04             	sub    $0x4,%esp
  80bb16:	68 95 35 81 00       	push   $0x813595
  80bb1b:	68 03 01 00 00       	push   $0x103
  80bb20:	68 42 35 81 00       	push   $0x813542
  80bb25:	e8 45 2c 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bb2a:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bb2e:	74 09                	je     80bb39 <sent_tcp+0x73>
    do_writemore(conn);
  80bb30:	89 d8                	mov    %ebx,%eax
  80bb32:	e8 1e fc ff ff       	call   80b755 <do_writemore>
  80bb37:	eb a9                	jmp    80bae2 <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bb39:	83 ec 04             	sub    $0x4,%esp
  80bb3c:	68 0e 36 81 00       	push   $0x81360e
  80bb41:	68 06 01 00 00       	push   $0x106
  80bb46:	68 42 35 81 00       	push   $0x813542
  80bb4b:	e8 1f 2c 00 00       	call   80e76f <_panic>
    do_close_internal(conn);
  80bb50:	89 d8                	mov    %ebx,%eax
  80bb52:	e8 65 fd ff ff       	call   80b8bc <do_close_internal>
  80bb57:	eb 89                	jmp    80bae2 <sent_tcp+0x1c>

0080bb59 <do_newconn>:
{
  80bb59:	55                   	push   %ebp
  80bb5a:	89 e5                	mov    %esp,%ebp
  80bb5c:	56                   	push   %esi
  80bb5d:	53                   	push   %ebx
  80bb5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bb61:	8b 03                	mov    (%ebx),%eax
  80bb63:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bb67:	74 17                	je     80bb80 <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80bb69:	83 ec 0c             	sub    $0xc,%esp
  80bb6c:	8b 03                	mov    (%ebx),%eax
  80bb6e:	ff 70 10             	pushl  0x10(%eax)
  80bb71:	e8 fe e5 ff ff       	call   80a174 <sys_sem_signal>
}
  80bb76:	83 c4 10             	add    $0x10,%esp
  80bb79:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bb7c:	5b                   	pop    %ebx
  80bb7d:	5e                   	pop    %esi
  80bb7e:	5d                   	pop    %ebp
  80bb7f:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80bb80:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bb84:	8b 33                	mov    (%ebx),%esi
  80bb86:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bb8a:	75 20                	jne    80bbac <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bb8c:	8b 06                	mov    (%esi),%eax
  80bb8e:	25 f0 00 00 00       	and    $0xf0,%eax
  80bb93:	83 f8 20             	cmp    $0x20,%eax
  80bb96:	74 67                	je     80bbff <do_newconn+0xa6>
  80bb98:	83 f8 40             	cmp    $0x40,%eax
  80bb9b:	74 26                	je     80bbc3 <do_newconn+0x6a>
  80bb9d:	83 f8 10             	cmp    $0x10,%eax
  80bba0:	0f 84 99 00 00 00    	je     80bc3f <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80bba6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bbaa:	eb bd                	jmp    80bb69 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bbac:	83 ec 04             	sub    $0x4,%esp
  80bbaf:	68 c8 34 81 00       	push   $0x8134c8
  80bbb4:	68 8a 01 00 00       	push   $0x18a
  80bbb9:	68 42 35 81 00       	push   $0x813542
  80bbbe:	e8 ac 2b 00 00       	call   80e76f <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80bbc3:	83 ec 0c             	sub    $0xc,%esp
  80bbc6:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80bbca:	50                   	push   %eax
  80bbcb:	e8 67 25 00 00       	call   80e137 <raw_new>
  80bbd0:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80bbd3:	8b 03                	mov    (%ebx),%eax
  80bbd5:	8b 50 08             	mov    0x8(%eax),%edx
  80bbd8:	83 c4 10             	add    $0x10,%esp
  80bbdb:	85 d2                	test   %edx,%edx
  80bbdd:	74 17                	je     80bbf6 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80bbdf:	83 ec 04             	sub    $0x4,%esp
  80bbe2:	50                   	push   %eax
  80bbe3:	68 fc b4 80 00       	push   $0x80b4fc
  80bbe8:	52                   	push   %edx
  80bbe9:	e8 cd 23 00 00       	call   80dfbb <raw_recv>
  80bbee:	83 c4 10             	add    $0x10,%esp
  80bbf1:	e9 73 ff ff ff       	jmp    80bb69 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bbf6:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bbfa:	e9 6a ff ff ff       	jmp    80bb69 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80bbff:	e8 d1 d4 ff ff       	call   8090d5 <udp_new>
  80bc04:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80bc07:	8b 03                	mov    (%ebx),%eax
  80bc09:	8b 50 08             	mov    0x8(%eax),%edx
  80bc0c:	85 d2                	test   %edx,%edx
  80bc0e:	74 20                	je     80bc30 <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80bc10:	83 38 22             	cmpl   $0x22,(%eax)
  80bc13:	74 24                	je     80bc39 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80bc15:	8b 03                	mov    (%ebx),%eax
  80bc17:	83 ec 04             	sub    $0x4,%esp
  80bc1a:	50                   	push   %eax
  80bc1b:	68 f2 b3 80 00       	push   $0x80b3f2
  80bc20:	ff 70 08             	pushl  0x8(%eax)
  80bc23:	e8 55 d4 ff ff       	call   80907d <udp_recv>
  80bc28:	83 c4 10             	add    $0x10,%esp
  80bc2b:	e9 39 ff ff ff       	jmp    80bb69 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bc30:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bc34:	e9 30 ff ff ff       	jmp    80bb69 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bc39:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bc3d:	eb d6                	jmp    80bc15 <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bc3f:	e8 5d a7 ff ff       	call   8063a1 <tcp_new>
  80bc44:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bc47:	8b 03                	mov    (%ebx),%eax
  80bc49:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bc4d:	74 0a                	je     80bc59 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bc4f:	e8 90 f9 ff ff       	call   80b5e4 <setup_tcp>
  80bc54:	e9 10 ff ff ff       	jmp    80bb69 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bc59:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bc5d:	e9 07 ff ff ff       	jmp    80bb69 <do_newconn+0x10>

0080bc62 <netconn_alloc>:
{
  80bc62:	55                   	push   %ebp
  80bc63:	89 e5                	mov    %esp,%ebp
  80bc65:	53                   	push   %ebx
  80bc66:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bc69:	6a 07                	push   $0x7
  80bc6b:	e8 f1 88 ff ff       	call   804561 <memp_malloc>
  80bc70:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bc72:	83 c4 10             	add    $0x10,%esp
  80bc75:	85 c0                	test   %eax,%eax
  80bc77:	74 5b                	je     80bcd4 <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bc79:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bc7d:	8b 45 08             	mov    0x8(%ebp),%eax
  80bc80:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bc82:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bc89:	83 ec 0c             	sub    $0xc,%esp
  80bc8c:	6a 00                	push   $0x0
  80bc8e:	e8 24 e2 ff ff       	call   809eb7 <sys_sem_new>
  80bc93:	89 43 10             	mov    %eax,0x10(%ebx)
  80bc96:	83 c4 10             	add    $0x10,%esp
  80bc99:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc9c:	74 3d                	je     80bcdb <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bc9e:	83 ec 0c             	sub    $0xc,%esp
  80bca1:	6a 00                	push   $0x0
  80bca3:	e8 b8 e3 ff ff       	call   80a060 <sys_mbox_new>
  80bca8:	89 43 14             	mov    %eax,0x14(%ebx)
  80bcab:	83 c4 10             	add    $0x10,%esp
  80bcae:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bcb1:	74 3d                	je     80bcf0 <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bcb3:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bcba:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bcc1:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bcc8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bccb:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bcce:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bcd4:	89 d8                	mov    %ebx,%eax
  80bcd6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bcd9:	c9                   	leave  
  80bcda:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bcdb:	83 ec 08             	sub    $0x8,%esp
  80bcde:	53                   	push   %ebx
  80bcdf:	6a 07                	push   $0x7
  80bce1:	e8 d1 88 ff ff       	call   8045b7 <memp_free>
    return NULL;
  80bce6:	83 c4 10             	add    $0x10,%esp
  80bce9:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bcee:	eb e4                	jmp    80bcd4 <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bcf0:	83 ec 0c             	sub    $0xc,%esp
  80bcf3:	ff 73 10             	pushl  0x10(%ebx)
  80bcf6:	e8 3d e2 ff ff       	call   809f38 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bcfb:	83 c4 08             	add    $0x8,%esp
  80bcfe:	53                   	push   %ebx
  80bcff:	6a 07                	push   $0x7
  80bd01:	e8 b1 88 ff ff       	call   8045b7 <memp_free>
    return NULL;
  80bd06:	83 c4 10             	add    $0x10,%esp
  80bd09:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bd0e:	eb c4                	jmp    80bcd4 <netconn_alloc+0x72>

0080bd10 <netconn_free>:
{
  80bd10:	55                   	push   %ebp
  80bd11:	89 e5                	mov    %esp,%ebp
  80bd13:	56                   	push   %esi
  80bd14:	53                   	push   %ebx
  80bd15:	83 ec 10             	sub    $0x10,%esp
  80bd18:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bd1b:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bd1f:	75 0b                	jne    80bd2c <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd21:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bd24:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bd28:	75 27                	jne    80bd51 <netconn_free+0x41>
  80bd2a:	eb 68                	jmp    80bd94 <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bd2c:	83 ec 04             	sub    $0x4,%esp
  80bd2f:	68 e8 34 81 00       	push   $0x8134e8
  80bd34:	68 26 02 00 00       	push   $0x226
  80bd39:	68 42 35 81 00       	push   $0x813542
  80bd3e:	e8 2c 2a 00 00       	call   80e76f <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bd43:	83 ec 0c             	sub    $0xc,%esp
  80bd46:	ff 75 f4             	pushl  -0xc(%ebp)
  80bd49:	e8 1d 68 ff ff       	call   80256b <netbuf_delete>
  80bd4e:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd51:	83 ec 08             	sub    $0x8,%esp
  80bd54:	56                   	push   %esi
  80bd55:	ff 73 14             	pushl  0x14(%ebx)
  80bd58:	e8 7a e7 ff ff       	call   80a4d7 <sys_arch_mbox_tryfetch>
  80bd5d:	83 c4 10             	add    $0x10,%esp
  80bd60:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd63:	74 1a                	je     80bd7f <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bd65:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bd68:	75 d9                	jne    80bd43 <netconn_free+0x33>
        if(mem != NULL) {
  80bd6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bd6d:	85 c0                	test   %eax,%eax
  80bd6f:	74 e0                	je     80bd51 <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bd71:	83 ec 0c             	sub    $0xc,%esp
  80bd74:	50                   	push   %eax
  80bd75:	e8 8a 8b ff ff       	call   804904 <pbuf_free>
  80bd7a:	83 c4 10             	add    $0x10,%esp
  80bd7d:	eb d2                	jmp    80bd51 <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bd7f:	83 ec 0c             	sub    $0xc,%esp
  80bd82:	ff 73 14             	pushl  0x14(%ebx)
  80bd85:	e8 37 e2 ff ff       	call   809fc1 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bd8a:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bd91:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd94:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bd97:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bd9b:	74 39                	je     80bdd6 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bd9d:	83 ec 08             	sub    $0x8,%esp
  80bda0:	56                   	push   %esi
  80bda1:	ff 73 18             	pushl  0x18(%ebx)
  80bda4:	e8 2e e7 ff ff       	call   80a4d7 <sys_arch_mbox_tryfetch>
  80bda9:	83 c4 10             	add    $0x10,%esp
  80bdac:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bdaf:	74 10                	je     80bdc1 <netconn_free+0xb1>
      netconn_delete((struct netconn *)mem);
  80bdb1:	83 ec 0c             	sub    $0xc,%esp
  80bdb4:	ff 75 f4             	pushl  -0xc(%ebp)
  80bdb7:	e8 24 f0 ff ff       	call   80ade0 <netconn_delete>
  80bdbc:	83 c4 10             	add    $0x10,%esp
  80bdbf:	eb dc                	jmp    80bd9d <netconn_free+0x8d>
    sys_mbox_free(conn->acceptmbox);
  80bdc1:	83 ec 0c             	sub    $0xc,%esp
  80bdc4:	ff 73 18             	pushl  0x18(%ebx)
  80bdc7:	e8 f5 e1 ff ff       	call   809fc1 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bdcc:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bdd3:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bdd6:	83 ec 0c             	sub    $0xc,%esp
  80bdd9:	ff 73 10             	pushl  0x10(%ebx)
  80bddc:	e8 57 e1 ff ff       	call   809f38 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bde1:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bde8:	83 c4 08             	add    $0x8,%esp
  80bdeb:	53                   	push   %ebx
  80bdec:	6a 07                	push   $0x7
  80bdee:	e8 c4 87 ff ff       	call   8045b7 <memp_free>
}
  80bdf3:	83 c4 10             	add    $0x10,%esp
  80bdf6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bdf9:	5b                   	pop    %ebx
  80bdfa:	5e                   	pop    %esi
  80bdfb:	5d                   	pop    %ebp
  80bdfc:	c3                   	ret    

0080bdfd <accept_function>:
{
  80bdfd:	55                   	push   %ebp
  80bdfe:	89 e5                	mov    %esp,%ebp
  80be00:	57                   	push   %edi
  80be01:	56                   	push   %esi
  80be02:	53                   	push   %ebx
  80be03:	83 ec 0c             	sub    $0xc,%esp
  80be06:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80be09:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80be0c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80be10:	74 57                	je     80be69 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80be12:	83 ec 08             	sub    $0x8,%esp
  80be15:	ff 73 2c             	pushl  0x2c(%ebx)
  80be18:	ff 33                	pushl  (%ebx)
  80be1a:	e8 43 fe ff ff       	call   80bc62 <netconn_alloc>
  80be1f:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80be21:	83 c4 10             	add    $0x10,%esp
  80be24:	85 c0                	test   %eax,%eax
  80be26:	74 72                	je     80be9a <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80be28:	8b 45 0c             	mov    0xc(%ebp),%eax
  80be2b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80be2e:	89 f0                	mov    %esi,%eax
  80be30:	e8 af f7 ff ff       	call   80b5e4 <setup_tcp>
  newconn->err = err;
  80be35:	89 f8                	mov    %edi,%eax
  80be37:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80be3a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80be3d:	85 c0                	test   %eax,%eax
  80be3f:	74 0d                	je     80be4e <accept_function+0x51>
  80be41:	83 ec 04             	sub    $0x4,%esp
  80be44:	6a 00                	push   $0x0
  80be46:	6a 00                	push   $0x0
  80be48:	53                   	push   %ebx
  80be49:	ff d0                	call   *%eax
  80be4b:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80be4e:	83 ec 08             	sub    $0x8,%esp
  80be51:	56                   	push   %esi
  80be52:	ff 73 18             	pushl  0x18(%ebx)
  80be55:	e8 9a e4 ff ff       	call   80a2f4 <sys_mbox_trypost>
  80be5a:	83 c4 10             	add    $0x10,%esp
  80be5d:	84 c0                	test   %al,%al
  80be5f:	75 1f                	jne    80be80 <accept_function+0x83>
}
  80be61:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80be64:	5b                   	pop    %ebx
  80be65:	5e                   	pop    %esi
  80be66:	5f                   	pop    %edi
  80be67:	5d                   	pop    %ebp
  80be68:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80be69:	83 ec 04             	sub    $0x4,%esp
  80be6c:	68 18 35 81 00       	push   $0x813518
  80be71:	68 65 01 00 00       	push   $0x165
  80be76:	68 42 35 81 00       	push   $0x813542
  80be7b:	e8 ef 28 00 00       	call   80e76f <_panic>
    newconn->pcb.tcp = NULL;
  80be80:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80be87:	83 ec 0c             	sub    $0xc,%esp
  80be8a:	56                   	push   %esi
  80be8b:	e8 80 fe ff ff       	call   80bd10 <netconn_free>
    return ERR_MEM;
  80be90:	83 c4 10             	add    $0x10,%esp
  80be93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80be98:	eb c7                	jmp    80be61 <accept_function+0x64>
    return ERR_MEM;
  80be9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80be9f:	eb c0                	jmp    80be61 <accept_function+0x64>

0080bea1 <do_delconn>:
{
  80bea1:	55                   	push   %ebp
  80bea2:	89 e5                	mov    %esp,%ebp
  80bea4:	53                   	push   %ebx
  80bea5:	83 ec 04             	sub    $0x4,%esp
  80bea8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80beab:	8b 13                	mov    (%ebx),%edx
  80bead:	8b 4a 08             	mov    0x8(%edx),%ecx
  80beb0:	85 c9                	test   %ecx,%ecx
  80beb2:	74 16                	je     80beca <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80beb4:	8b 02                	mov    (%edx),%eax
  80beb6:	25 f0 00 00 00       	and    $0xf0,%eax
  80bebb:	83 f8 20             	cmp    $0x20,%eax
  80bebe:	74 53                	je     80bf13 <do_delconn+0x72>
  80bec0:	83 f8 40             	cmp    $0x40,%eax
  80bec3:	74 40                	je     80bf05 <do_delconn+0x64>
  80bec5:	83 f8 10             	cmp    $0x10,%eax
  80bec8:	74 62                	je     80bf2c <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80beca:	8b 13                	mov    (%ebx),%edx
  80becc:	8b 42 2c             	mov    0x2c(%edx),%eax
  80becf:	85 c0                	test   %eax,%eax
  80bed1:	74 23                	je     80bef6 <do_delconn+0x55>
  80bed3:	83 ec 04             	sub    $0x4,%esp
  80bed6:	6a 00                	push   $0x0
  80bed8:	6a 00                	push   $0x0
  80beda:	52                   	push   %edx
  80bedb:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bedd:	8b 13                	mov    (%ebx),%edx
  80bedf:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bee2:	83 c4 10             	add    $0x10,%esp
  80bee5:	85 c0                	test   %eax,%eax
  80bee7:	74 0d                	je     80bef6 <do_delconn+0x55>
  80bee9:	83 ec 04             	sub    $0x4,%esp
  80beec:	6a 00                	push   $0x0
  80beee:	6a 02                	push   $0x2
  80bef0:	52                   	push   %edx
  80bef1:	ff d0                	call   *%eax
  80bef3:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bef6:	8b 03                	mov    (%ebx),%eax
  80bef8:	8b 40 10             	mov    0x10(%eax),%eax
  80befb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80befe:	75 3c                	jne    80bf3c <do_delconn+0x9b>
}
  80bf00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf03:	c9                   	leave  
  80bf04:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80bf05:	83 ec 0c             	sub    $0xc,%esp
  80bf08:	51                   	push   %ecx
  80bf09:	e8 e5 21 00 00       	call   80e0f3 <raw_remove>
      break;
  80bf0e:	83 c4 10             	add    $0x10,%esp
  80bf11:	eb b7                	jmp    80beca <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80bf13:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bf1a:	83 ec 0c             	sub    $0xc,%esp
  80bf1d:	8b 03                	mov    (%ebx),%eax
  80bf1f:	ff 70 08             	pushl  0x8(%eax)
  80bf22:	e8 6a d1 ff ff       	call   809091 <udp_remove>
      break;
  80bf27:	83 c4 10             	add    $0x10,%esp
  80bf2a:	eb 9e                	jmp    80beca <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80bf2c:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bf33:	8b 03                	mov    (%ebx),%eax
  80bf35:	e8 82 f9 ff ff       	call   80b8bc <do_close_internal>
      return;
  80bf3a:	eb c4                	jmp    80bf00 <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80bf3c:	83 ec 0c             	sub    $0xc,%esp
  80bf3f:	50                   	push   %eax
  80bf40:	e8 2f e2 ff ff       	call   80a174 <sys_sem_signal>
  80bf45:	83 c4 10             	add    $0x10,%esp
  80bf48:	eb b6                	jmp    80bf00 <do_delconn+0x5f>

0080bf4a <do_bind>:
{
  80bf4a:	55                   	push   %ebp
  80bf4b:	89 e5                	mov    %esp,%ebp
  80bf4d:	56                   	push   %esi
  80bf4e:	53                   	push   %ebx
  80bf4f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf52:	8b 33                	mov    (%ebx),%esi
  80bf54:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bf58:	7c 1d                	jl     80bf77 <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80bf5a:	8b 56 08             	mov    0x8(%esi),%edx
  80bf5d:	85 d2                	test   %edx,%edx
  80bf5f:	74 73                	je     80bfd4 <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bf61:	8b 06                	mov    (%esi),%eax
  80bf63:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf68:	83 f8 20             	cmp    $0x20,%eax
  80bf6b:	74 35                	je     80bfa2 <do_bind+0x58>
  80bf6d:	83 f8 40             	cmp    $0x40,%eax
  80bf70:	74 1c                	je     80bf8e <do_bind+0x44>
  80bf72:	83 f8 10             	cmp    $0x10,%eax
  80bf75:	74 44                	je     80bfbb <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80bf77:	83 ec 0c             	sub    $0xc,%esp
  80bf7a:	8b 03                	mov    (%ebx),%eax
  80bf7c:	ff 70 10             	pushl  0x10(%eax)
  80bf7f:	e8 f0 e1 ff ff       	call   80a174 <sys_sem_signal>
}
  80bf84:	83 c4 10             	add    $0x10,%esp
  80bf87:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bf8a:	5b                   	pop    %ebx
  80bf8b:	5e                   	pop    %esi
  80bf8c:	5d                   	pop    %ebp
  80bf8d:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bf8e:	83 ec 08             	sub    $0x8,%esp
  80bf91:	ff 73 04             	pushl  0x4(%ebx)
  80bf94:	52                   	push   %edx
  80bf95:	e8 e6 1f 00 00       	call   80df80 <raw_bind>
  80bf9a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bf9d:	83 c4 10             	add    $0x10,%esp
  80bfa0:	eb d5                	jmp    80bf77 <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bfa2:	83 ec 04             	sub    $0x4,%esp
  80bfa5:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bfa9:	50                   	push   %eax
  80bfaa:	ff 73 04             	pushl  0x4(%ebx)
  80bfad:	52                   	push   %edx
  80bfae:	e8 8e cd ff ff       	call   808d41 <udp_bind>
  80bfb3:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bfb6:	83 c4 10             	add    $0x10,%esp
  80bfb9:	eb bc                	jmp    80bf77 <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bfbb:	83 ec 04             	sub    $0x4,%esp
  80bfbe:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bfc2:	50                   	push   %eax
  80bfc3:	ff 73 04             	pushl  0x4(%ebx)
  80bfc6:	52                   	push   %edx
  80bfc7:	e8 e8 94 ff ff       	call   8054b4 <tcp_bind>
  80bfcc:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bfcf:	83 c4 10             	add    $0x10,%esp
  80bfd2:	eb a3                	jmp    80bf77 <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80bfd4:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bfd8:	eb 9d                	jmp    80bf77 <do_bind+0x2d>

0080bfda <do_connect>:
{
  80bfda:	55                   	push   %ebp
  80bfdb:	89 e5                	mov    %esp,%ebp
  80bfdd:	56                   	push   %esi
  80bfde:	53                   	push   %ebx
  80bfdf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bfe2:	8b 33                	mov    (%ebx),%esi
  80bfe4:	8b 56 08             	mov    0x8(%esi),%edx
  80bfe7:	85 d2                	test   %edx,%edx
  80bfe9:	74 1d                	je     80c008 <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bfeb:	8b 06                	mov    (%esi),%eax
  80bfed:	25 f0 00 00 00       	and    $0xf0,%eax
  80bff2:	83 f8 20             	cmp    $0x20,%eax
  80bff5:	74 42                	je     80c039 <do_connect+0x5f>
  80bff7:	83 f8 40             	cmp    $0x40,%eax
  80bffa:	74 1c                	je     80c018 <do_connect+0x3e>
  80bffc:	83 f8 10             	cmp    $0x10,%eax
  80bfff:	74 5e                	je     80c05f <do_connect+0x85>
}
  80c001:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c004:	5b                   	pop    %ebx
  80c005:	5e                   	pop    %esi
  80c006:	5d                   	pop    %ebp
  80c007:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80c008:	83 ec 0c             	sub    $0xc,%esp
  80c00b:	ff 76 10             	pushl  0x10(%esi)
  80c00e:	e8 61 e1 ff ff       	call   80a174 <sys_sem_signal>
    return;
  80c013:	83 c4 10             	add    $0x10,%esp
  80c016:	eb e9                	jmp    80c001 <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c018:	83 ec 08             	sub    $0x8,%esp
  80c01b:	ff 73 04             	pushl  0x4(%ebx)
  80c01e:	52                   	push   %edx
  80c01f:	e8 79 1f 00 00       	call   80df9d <raw_connect>
  80c024:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c027:	83 c4 04             	add    $0x4,%esp
  80c02a:	8b 03                	mov    (%ebx),%eax
  80c02c:	ff 70 10             	pushl  0x10(%eax)
  80c02f:	e8 40 e1 ff ff       	call   80a174 <sys_sem_signal>
    break;
  80c034:	83 c4 10             	add    $0x10,%esp
  80c037:	eb c8                	jmp    80c001 <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c039:	83 ec 04             	sub    $0x4,%esp
  80c03c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c040:	50                   	push   %eax
  80c041:	ff 73 04             	pushl  0x4(%ebx)
  80c044:	52                   	push   %edx
  80c045:	e8 a7 cf ff ff       	call   808ff1 <udp_connect>
  80c04a:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c04d:	83 c4 04             	add    $0x4,%esp
  80c050:	8b 03                	mov    (%ebx),%eax
  80c052:	ff 70 10             	pushl  0x10(%eax)
  80c055:	e8 1a e1 ff ff       	call   80a174 <sys_sem_signal>
    break;
  80c05a:	83 c4 10             	add    $0x10,%esp
  80c05d:	eb a2                	jmp    80c001 <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80c05f:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c066:	8b 03                	mov    (%ebx),%eax
  80c068:	e8 77 f5 ff ff       	call   80b5e4 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c06d:	8b 33                	mov    (%ebx),%esi
  80c06f:	68 37 b6 80 00       	push   $0x80b637
  80c074:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c078:	50                   	push   %eax
  80c079:	ff 73 04             	pushl  0x4(%ebx)
  80c07c:	ff 76 08             	pushl  0x8(%esi)
  80c07f:	e8 65 a3 ff ff       	call   8063e9 <tcp_connect>
  80c084:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80c087:	83 c4 10             	add    $0x10,%esp
  80c08a:	e9 72 ff ff ff       	jmp    80c001 <do_connect+0x27>

0080c08f <do_disconnect>:
{
  80c08f:	55                   	push   %ebp
  80c090:	89 e5                	mov    %esp,%ebp
  80c092:	53                   	push   %ebx
  80c093:	83 ec 04             	sub    $0x4,%esp
  80c096:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c099:	8b 13                	mov    (%ebx),%edx
  80c09b:	8b 02                	mov    (%edx),%eax
  80c09d:	25 f0 00 00 00       	and    $0xf0,%eax
  80c0a2:	83 f8 20             	cmp    $0x20,%eax
  80c0a5:	74 15                	je     80c0bc <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80c0a7:	83 ec 0c             	sub    $0xc,%esp
  80c0aa:	8b 03                	mov    (%ebx),%eax
  80c0ac:	ff 70 10             	pushl  0x10(%eax)
  80c0af:	e8 c0 e0 ff ff       	call   80a174 <sys_sem_signal>
}
  80c0b4:	83 c4 10             	add    $0x10,%esp
  80c0b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c0ba:	c9                   	leave  
  80c0bb:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c0bc:	83 ec 0c             	sub    $0xc,%esp
  80c0bf:	ff 72 08             	pushl  0x8(%edx)
  80c0c2:	e8 9b cf ff ff       	call   809062 <udp_disconnect>
  80c0c7:	83 c4 10             	add    $0x10,%esp
  80c0ca:	eb db                	jmp    80c0a7 <do_disconnect+0x18>

0080c0cc <do_listen>:
{
  80c0cc:	55                   	push   %ebp
  80c0cd:	89 e5                	mov    %esp,%ebp
  80c0cf:	57                   	push   %edi
  80c0d0:	56                   	push   %esi
  80c0d1:	53                   	push   %ebx
  80c0d2:	83 ec 0c             	sub    $0xc,%esp
  80c0d5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0d8:	8b 03                	mov    (%ebx),%eax
  80c0da:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c0de:	7c 0c                	jl     80c0ec <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80c0e0:	8b 50 08             	mov    0x8(%eax),%edx
  80c0e3:	85 d2                	test   %edx,%edx
  80c0e5:	74 05                	je     80c0ec <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80c0e7:	83 38 10             	cmpl   $0x10,(%eax)
  80c0ea:	74 18                	je     80c104 <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80c0ec:	83 ec 0c             	sub    $0xc,%esp
  80c0ef:	8b 03                	mov    (%ebx),%eax
  80c0f1:	ff 70 10             	pushl  0x10(%eax)
  80c0f4:	e8 7b e0 ff ff       	call   80a174 <sys_sem_signal>
}
  80c0f9:	83 c4 10             	add    $0x10,%esp
  80c0fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c0ff:	5b                   	pop    %ebx
  80c100:	5e                   	pop    %esi
  80c101:	5f                   	pop    %edi
  80c102:	5d                   	pop    %ebp
  80c103:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c104:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c108:	74 06                	je     80c110 <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80c10a:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c10e:	eb dc                	jmp    80c0ec <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c110:	83 ec 08             	sub    $0x8,%esp
  80c113:	68 ff 00 00 00       	push   $0xff
  80c118:	52                   	push   %edx
  80c119:	e8 e1 94 ff ff       	call   8055ff <tcp_listen_with_backlog>
  80c11e:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c120:	83 c4 10             	add    $0x10,%esp
  80c123:	85 c0                	test   %eax,%eax
  80c125:	74 4e                	je     80c175 <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c127:	8b 03                	mov    (%ebx),%eax
  80c129:	8b 40 14             	mov    0x14(%eax),%eax
  80c12c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c12f:	75 4f                	jne    80c180 <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c131:	8b 3b                	mov    (%ebx),%edi
  80c133:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c137:	74 5e                	je     80c197 <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80c139:	8b 03                	mov    (%ebx),%eax
  80c13b:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c13f:	75 ab                	jne    80c0ec <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80c141:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c148:	8b 03                	mov    (%ebx),%eax
  80c14a:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c14d:	8b 03                	mov    (%ebx),%eax
  80c14f:	83 ec 08             	sub    $0x8,%esp
  80c152:	50                   	push   %eax
  80c153:	ff 70 08             	pushl  0x8(%eax)
  80c156:	e8 76 97 ff ff       	call   8058d1 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c15b:	83 c4 08             	add    $0x8,%esp
  80c15e:	68 fd bd 80 00       	push   $0x80bdfd
  80c163:	8b 03                	mov    (%ebx),%eax
  80c165:	ff 70 08             	pushl  0x8(%eax)
  80c168:	e8 a5 97 ff ff       	call   805912 <tcp_accept>
  80c16d:	83 c4 10             	add    $0x10,%esp
  80c170:	e9 77 ff ff ff       	jmp    80c0ec <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80c175:	8b 03                	mov    (%ebx),%eax
  80c177:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c17b:	e9 6c ff ff ff       	jmp    80c0ec <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c180:	83 ec 0c             	sub    $0xc,%esp
  80c183:	50                   	push   %eax
  80c184:	e8 38 de ff ff       	call   809fc1 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c189:	8b 03                	mov    (%ebx),%eax
  80c18b:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c192:	83 c4 10             	add    $0x10,%esp
  80c195:	eb 9a                	jmp    80c131 <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c197:	83 ec 0c             	sub    $0xc,%esp
  80c19a:	6a 00                	push   $0x0
  80c19c:	e8 bf de ff ff       	call   80a060 <sys_mbox_new>
  80c1a1:	89 47 18             	mov    %eax,0x18(%edi)
  80c1a4:	83 c4 10             	add    $0x10,%esp
  80c1a7:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c1aa:	75 8d                	jne    80c139 <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c1ac:	8b 03                	mov    (%ebx),%eax
  80c1ae:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c1b2:	eb 85                	jmp    80c139 <do_listen+0x6d>

0080c1b4 <do_send>:
{
  80c1b4:	55                   	push   %ebp
  80c1b5:	89 e5                	mov    %esp,%ebp
  80c1b7:	57                   	push   %edi
  80c1b8:	56                   	push   %esi
  80c1b9:	53                   	push   %ebx
  80c1ba:	83 ec 0c             	sub    $0xc,%esp
  80c1bd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c1c0:	8b 33                	mov    (%ebx),%esi
  80c1c2:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c1c6:	7c 34                	jl     80c1fc <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c1c8:	8b 56 08             	mov    0x8(%esi),%edx
  80c1cb:	85 d2                	test   %edx,%edx
  80c1cd:	74 2d                	je     80c1fc <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c1cf:	8b 06                	mov    (%esi),%eax
  80c1d1:	25 f0 00 00 00       	and    $0xf0,%eax
  80c1d6:	83 f8 20             	cmp    $0x20,%eax
  80c1d9:	74 4c                	je     80c227 <do_send+0x73>
  80c1db:	83 f8 40             	cmp    $0x40,%eax
  80c1de:	75 1c                	jne    80c1fc <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c1e0:	8b 43 04             	mov    0x4(%ebx),%eax
  80c1e3:	8b 48 08             	mov    0x8(%eax),%ecx
  80c1e6:	85 c9                	test   %ecx,%ecx
  80c1e8:	74 2a                	je     80c214 <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c1ea:	83 ec 04             	sub    $0x4,%esp
  80c1ed:	51                   	push   %ecx
  80c1ee:	ff 30                	pushl  (%eax)
  80c1f0:	52                   	push   %edx
  80c1f1:	e8 d9 1d 00 00       	call   80dfcf <raw_sendto>
  80c1f6:	88 46 0c             	mov    %al,0xc(%esi)
  80c1f9:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c1fc:	83 ec 0c             	sub    $0xc,%esp
  80c1ff:	8b 03                	mov    (%ebx),%eax
  80c201:	ff 70 10             	pushl  0x10(%eax)
  80c204:	e8 6b df ff ff       	call   80a174 <sys_sem_signal>
}
  80c209:	83 c4 10             	add    $0x10,%esp
  80c20c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c20f:	5b                   	pop    %ebx
  80c210:	5e                   	pop    %esi
  80c211:	5f                   	pop    %edi
  80c212:	5d                   	pop    %ebp
  80c213:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c214:	83 ec 08             	sub    $0x8,%esp
  80c217:	ff 30                	pushl  (%eax)
  80c219:	52                   	push   %edx
  80c21a:	e8 bc 1e 00 00       	call   80e0db <raw_send>
  80c21f:	88 46 0c             	mov    %al,0xc(%esi)
  80c222:	83 c4 10             	add    $0x10,%esp
  80c225:	eb d5                	jmp    80c1fc <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c227:	8b 43 04             	mov    0x4(%ebx),%eax
  80c22a:	8b 48 08             	mov    0x8(%eax),%ecx
  80c22d:	85 c9                	test   %ecx,%ecx
  80c22f:	74 16                	je     80c247 <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c231:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c235:	57                   	push   %edi
  80c236:	51                   	push   %ecx
  80c237:	ff 30                	pushl  (%eax)
  80c239:	52                   	push   %edx
  80c23a:	e8 55 cd ff ff       	call   808f94 <udp_sendto>
  80c23f:	88 46 0c             	mov    %al,0xc(%esi)
  80c242:	83 c4 10             	add    $0x10,%esp
  80c245:	eb b5                	jmp    80c1fc <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c247:	83 ec 08             	sub    $0x8,%esp
  80c24a:	ff 30                	pushl  (%eax)
  80c24c:	52                   	push   %edx
  80c24d:	e8 82 cd ff ff       	call   808fd4 <udp_send>
  80c252:	88 46 0c             	mov    %al,0xc(%esi)
  80c255:	83 c4 10             	add    $0x10,%esp
  80c258:	eb a2                	jmp    80c1fc <do_send+0x48>

0080c25a <do_recv>:
{
  80c25a:	55                   	push   %ebp
  80c25b:	89 e5                	mov    %esp,%ebp
  80c25d:	53                   	push   %ebx
  80c25e:	83 ec 04             	sub    $0x4,%esp
  80c261:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c264:	8b 03                	mov    (%ebx),%eax
  80c266:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c26a:	7c 0c                	jl     80c278 <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c26c:	8b 50 08             	mov    0x8(%eax),%edx
  80c26f:	85 d2                	test   %edx,%edx
  80c271:	74 05                	je     80c278 <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c273:	83 38 10             	cmpl   $0x10,(%eax)
  80c276:	74 15                	je     80c28d <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c278:	83 ec 0c             	sub    $0xc,%esp
  80c27b:	8b 03                	mov    (%ebx),%eax
  80c27d:	ff 70 10             	pushl  0x10(%eax)
  80c280:	e8 ef de ff ff       	call   80a174 <sys_sem_signal>
}
  80c285:	83 c4 10             	add    $0x10,%esp
  80c288:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c28b:	c9                   	leave  
  80c28c:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c28d:	83 ec 08             	sub    $0x8,%esp
  80c290:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c294:	50                   	push   %eax
  80c295:	52                   	push   %edx
  80c296:	e8 7c 94 ff ff       	call   805717 <tcp_recved>
  80c29b:	83 c4 10             	add    $0x10,%esp
  80c29e:	eb d8                	jmp    80c278 <do_recv+0x1e>

0080c2a0 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c2a0:	55                   	push   %ebp
  80c2a1:	89 e5                	mov    %esp,%ebp
  80c2a3:	83 ec 08             	sub    $0x8,%esp
  80c2a6:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c2a9:	8b 02                	mov    (%edx),%eax
  80c2ab:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c2af:	7c 0f                	jl     80c2c0 <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c2b1:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c2b5:	74 05                	je     80c2bc <do_write+0x1c>
  80c2b7:	83 38 10             	cmpl   $0x10,(%eax)
  80c2ba:	74 16                	je     80c2d2 <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c2bc:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c2c0:	83 ec 0c             	sub    $0xc,%esp
  80c2c3:	8b 02                	mov    (%edx),%eax
  80c2c5:	ff 70 10             	pushl  0x10(%eax)
  80c2c8:	e8 a7 de ff ff       	call   80a174 <sys_sem_signal>
  80c2cd:	83 c4 10             	add    $0x10,%esp
}
  80c2d0:	c9                   	leave  
  80c2d1:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c2d2:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c2d9:	8b 02                	mov    (%edx),%eax
  80c2db:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c2de:	8b 02                	mov    (%edx),%eax
  80c2e0:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c2e7:	8b 02                	mov    (%edx),%eax
  80c2e9:	e8 67 f4 ff ff       	call   80b755 <do_writemore>
      return;
  80c2ee:	eb e0                	jmp    80c2d0 <do_write+0x30>

0080c2f0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c2f0:	55                   	push   %ebp
  80c2f1:	89 e5                	mov    %esp,%ebp
  80c2f3:	83 ec 08             	sub    $0x8,%esp
  80c2f6:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c2f9:	8b 08                	mov    (%eax),%ecx
  80c2fb:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2fe:	85 d2                	test   %edx,%edx
  80c300:	0f 84 a8 00 00 00    	je     80c3ae <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c306:	8b 48 04             	mov    0x4(%eax),%ecx
  80c309:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c30d:	74 2f                	je     80c33e <do_getaddr+0x4e>
  80c30f:	8b 12                	mov    (%edx),%edx
  80c311:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c313:	8b 08                	mov    (%eax),%ecx
  80c315:	8b 11                	mov    (%ecx),%edx
  80c317:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c31d:	83 fa 20             	cmp    $0x20,%edx
  80c320:	74 3e                	je     80c360 <do_getaddr+0x70>
  80c322:	83 fa 40             	cmp    $0x40,%edx
  80c325:	74 1e                	je     80c345 <do_getaddr+0x55>
  80c327:	83 fa 10             	cmp    $0x10,%edx
  80c32a:	74 64                	je     80c390 <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c32c:	83 ec 0c             	sub    $0xc,%esp
  80c32f:	8b 00                	mov    (%eax),%eax
  80c331:	ff 70 10             	pushl  0x10(%eax)
  80c334:	e8 3b de ff ff       	call   80a174 <sys_sem_signal>
}
  80c339:	83 c4 10             	add    $0x10,%esp
  80c33c:	c9                   	leave  
  80c33d:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c33e:	8b 52 04             	mov    0x4(%edx),%edx
  80c341:	89 11                	mov    %edx,(%ecx)
  80c343:	eb ce                	jmp    80c313 <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c345:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c349:	74 0f                	je     80c35a <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c34b:	8b 50 08             	mov    0x8(%eax),%edx
  80c34e:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c351:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c355:	66 89 0a             	mov    %cx,(%edx)
  80c358:	eb d2                	jmp    80c32c <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c35a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c35e:	eb cc                	jmp    80c32c <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c360:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c364:	74 0f                	je     80c375 <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c366:	8b 50 08             	mov    0x8(%eax),%edx
  80c369:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c36c:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c370:	66 89 0a             	mov    %cx,(%edx)
  80c373:	eb b7                	jmp    80c32c <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c375:	8b 51 08             	mov    0x8(%ecx),%edx
  80c378:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c37c:	75 06                	jne    80c384 <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c37e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c382:	eb a8                	jmp    80c32c <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c384:	8b 48 08             	mov    0x8(%eax),%ecx
  80c387:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c38b:	66 89 11             	mov    %dx,(%ecx)
  80c38e:	eb 9c                	jmp    80c32c <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c390:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c394:	74 0f                	je     80c3a5 <do_getaddr+0xb5>
  80c396:	8b 51 08             	mov    0x8(%ecx),%edx
  80c399:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c39d:	8b 50 08             	mov    0x8(%eax),%edx
  80c3a0:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c3a3:	eb 87                	jmp    80c32c <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c3a5:	8b 51 08             	mov    0x8(%ecx),%edx
  80c3a8:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c3ac:	eb ef                	jmp    80c39d <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c3ae:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c3b2:	e9 75 ff ff ff       	jmp    80c32c <do_getaddr+0x3c>

0080c3b7 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c3b7:	55                   	push   %ebp
  80c3b8:	89 e5                	mov    %esp,%ebp
  80c3ba:	83 ec 08             	sub    $0x8,%esp
  80c3bd:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c3c0:	8b 02                	mov    (%edx),%eax
  80c3c2:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c3c6:	74 05                	je     80c3cd <do_close+0x16>
  80c3c8:	83 38 10             	cmpl   $0x10,(%eax)
  80c3cb:	74 16                	je     80c3e3 <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c3cd:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c3d1:	83 ec 0c             	sub    $0xc,%esp
  80c3d4:	8b 02                	mov    (%edx),%eax
  80c3d6:	ff 70 10             	pushl  0x10(%eax)
  80c3d9:	e8 96 dd ff ff       	call   80a174 <sys_sem_signal>
  80c3de:	83 c4 10             	add    $0x10,%esp
  }
}
  80c3e1:	c9                   	leave  
  80c3e2:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c3e3:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c3ea:	8b 02                	mov    (%edx),%eax
  80c3ec:	e8 cb f4 ff ff       	call   80b8bc <do_close_internal>
  80c3f1:	eb ee                	jmp    80c3e1 <do_close+0x2a>

0080c3f3 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c3f3:	55                   	push   %ebp
  80c3f4:	89 e5                	mov    %esp,%ebp
  80c3f6:	57                   	push   %edi
  80c3f7:	56                   	push   %esi
  80c3f8:	53                   	push   %ebx
  80c3f9:	83 ec 18             	sub    $0x18,%esp
  80c3fc:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c3fe:	8b 35 b0 c1 b3 00    	mov    0xb3c1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c404:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c408:	50                   	push   %eax
  80c409:	e8 dd b3 ff ff       	call   8077eb <ntohs>
  80c40e:	83 c4 10             	add    $0x10,%esp
  80c411:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c415:	0f 86 84 00 00 00    	jbe    80c49f <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c41b:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c41e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c423:	eb 10                	jmp    80c435 <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c425:	83 c3 01             	add    $0x1,%ebx
  80c428:	eb 0b                	jmp    80c435 <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c42a:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c42f:	84 c0                	test   %al,%al
  80c431:	74 6c                	je     80c49f <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c433:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c435:	83 ec 0c             	sub    $0xc,%esp
  80c438:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80c43d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c441:	50                   	push   %eax
  80c442:	e8 a4 b3 ff ff       	call   8077eb <ntohs>
  80c447:	0f b6 d3             	movzbl %bl,%edx
  80c44a:	66 c1 e8 0c          	shr    $0xc,%ax
  80c44e:	0f b7 c0             	movzwl %ax,%eax
  80c451:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c458:	83 c4 10             	add    $0x10,%esp
  80c45b:	39 c2                	cmp    %eax,%edx
  80c45d:	7d 40                	jge    80c49f <tcp_parseopt+0xac>
      opt = opts[c];
  80c45f:	0f b6 d3             	movzbl %bl,%edx
  80c462:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c466:	84 c0                	test   %al,%al
  80c468:	74 35                	je     80c49f <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c46a:	3c 01                	cmp    $0x1,%al
  80c46c:	74 b7                	je     80c425 <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c46e:	3c 02                	cmp    $0x2,%al
  80c470:	75 b8                	jne    80c42a <tcp_parseopt+0x37>
  80c472:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c477:	75 b1                	jne    80c42a <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c479:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c47e:	c1 e1 08             	shl    $0x8,%ecx
  80c481:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c486:	89 d0                	mov    %edx,%eax
  80c488:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c48a:	83 e8 01             	sub    $0x1,%eax
  80c48d:	09 d1                	or     %edx,%ecx
  80c48f:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c493:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c498:	0f 42 c1             	cmovb  %ecx,%eax
  80c49b:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c49f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c4a2:	5b                   	pop    %ebx
  80c4a3:	5e                   	pop    %esi
  80c4a4:	5f                   	pop    %edi
  80c4a5:	5d                   	pop    %ebp
  80c4a6:	c3                   	ret    

0080c4a7 <tcp_receive>:
{
  80c4a7:	55                   	push   %ebp
  80c4a8:	89 e5                	mov    %esp,%ebp
  80c4aa:	57                   	push   %edi
  80c4ab:	56                   	push   %esi
  80c4ac:	53                   	push   %ebx
  80c4ad:	83 ec 1c             	sub    $0x1c,%esp
  80c4b0:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c4b2:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80c4b9:	0f 84 22 04 00 00    	je     80c8e1 <tcp_receive+0x43a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c4bf:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c4c3:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c4c6:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80c4cb:	39 c2                	cmp    %eax,%edx
  80c4cd:	78 53                	js     80c522 <tcp_receive+0x7b>
  80c4cf:	39 c2                	cmp    %eax,%edx
  80c4d1:	74 36                	je     80c509 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c4d3:	8b 35 a4 c1 b3 00    	mov    0xb3c1a4,%esi
  80c4d9:	39 77 64             	cmp    %esi,0x64(%edi)
  80c4dc:	74 38                	je     80c516 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c4de:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c4e1:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c4e6:	39 c3                	cmp    %eax,%ebx
  80c4e8:	74 68                	je     80c552 <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c4ea:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c4ed:	39 da                	cmp    %ebx,%edx
  80c4ef:	78 0d                	js     80c4fe <tcp_receive+0x57>
  80c4f1:	89 c2                	mov    %eax,%edx
  80c4f3:	2b 57 58             	sub    0x58(%edi),%edx
  80c4f6:	85 d2                	test   %edx,%edx
  80c4f8:	0f 8e fa 00 00 00    	jle    80c5f8 <tcp_receive+0x151>
      pcb->acked = 0;
  80c4fe:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c504:	e9 c2 02 00 00       	jmp    80c7cb <tcp_receive+0x324>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c509:	8b 35 a4 c1 b3 00    	mov    0xb3c1a4,%esi
  80c50f:	39 77 64             	cmp    %esi,0x64(%edi)
  80c512:	79 bf                	jns    80c4d3 <tcp_receive+0x2c>
  80c514:	eb 0c                	jmp    80c522 <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c516:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80c51c:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c520:	73 bc                	jae    80c4de <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c522:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80c528:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c52c:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c530:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c533:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c538:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c53b:	66 85 db             	test   %bx,%bx
  80c53e:	74 9e                	je     80c4de <tcp_receive+0x37>
  80c540:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c547:	74 95                	je     80c4de <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c549:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c550:	eb 8c                	jmp    80c4de <tcp_receive+0x37>
      pcb->acked = 0;
  80c552:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c558:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c55c:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c55f:	0f b7 c9             	movzwl %cx,%ecx
  80c562:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c564:	39 d0                	cmp    %edx,%eax
  80c566:	0f 85 5f 02 00 00    	jne    80c7cb <tcp_receive+0x324>
        ++pcb->dupacks;
  80c56c:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c570:	83 c0 01             	add    $0x1,%eax
  80c573:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c576:	3c 02                	cmp    $0x2,%al
  80c578:	0f 86 4d 02 00 00    	jbe    80c7cb <tcp_receive+0x324>
  80c57e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c582:	0f 84 43 02 00 00    	je     80c7cb <tcp_receive+0x324>
          if (!(pcb->flags & TF_INFR)) {
  80c588:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c58c:	74 1c                	je     80c5aa <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c58e:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c592:	89 d0                	mov    %edx,%eax
  80c594:	66 03 47 34          	add    0x34(%edi),%ax
  80c598:	66 39 c2             	cmp    %ax,%dx
  80c59b:	0f 83 2a 02 00 00    	jae    80c7cb <tcp_receive+0x324>
              pcb->cwnd += pcb->mss;
  80c5a1:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c5a5:	e9 21 02 00 00       	jmp    80c7cb <tcp_receive+0x324>
            tcp_rexmit(pcb);
  80c5aa:	83 ec 0c             	sub    $0xc,%esp
  80c5ad:	57                   	push   %edi
  80c5ae:	e8 ae c1 ff ff       	call   808761 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c5b3:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c5b7:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c5bb:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c5be:	89 c2                	mov    %eax,%edx
  80c5c0:	66 d1 ea             	shr    %dx
  80c5c3:	89 d9                	mov    %ebx,%ecx
  80c5c5:	66 d1 e9             	shr    %cx
  80c5c8:	66 39 c3             	cmp    %ax,%bx
  80c5cb:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c5ce:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c5d2:	0f b7 f1             	movzwl %cx,%esi
  80c5d5:	0f b7 d8             	movzwl %ax,%ebx
  80c5d8:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c5da:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c5dd:	39 de                	cmp    %ebx,%esi
  80c5df:	0f 4d d1             	cmovge %ecx,%edx
  80c5e2:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c5e6:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c5e9:	01 d0                	add    %edx,%eax
  80c5eb:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c5ef:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c5f3:	e9 d3 01 00 00       	jmp    80c7cb <tcp_receive+0x324>
      if (pcb->flags & TF_INFR) {
  80c5f8:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c5fc:	f6 c2 04             	test   $0x4,%dl
  80c5ff:	74 0e                	je     80c60f <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c601:	83 e2 fb             	and    $0xfffffffb,%edx
  80c604:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c607:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c60b:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c60f:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c613:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c617:	66 c1 fa 03          	sar    $0x3,%dx
  80c61b:	66 03 57 42          	add    0x42(%edi),%dx
  80c61f:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c623:	89 c2                	mov    %eax,%edx
  80c625:	29 da                	sub    %ebx,%edx
  80c627:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c62b:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c62f:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c633:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c636:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c63a:	76 1d                	jbe    80c659 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c63c:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c640:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c644:	0f 83 d7 00 00 00    	jae    80c721 <tcp_receive+0x27a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c64a:	89 c8                	mov    %ecx,%eax
  80c64c:	66 03 47 34          	add    0x34(%edi),%ax
  80c650:	66 39 c1             	cmp    %ax,%cx
  80c653:	73 04                	jae    80c659 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c655:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c659:	8b 47 78             	mov    0x78(%edi),%eax
  80c65c:	85 c0                	test   %eax,%eax
  80c65e:	0f 84 18 01 00 00    	je     80c77c <tcp_receive+0x2d5>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c664:	83 ec 0c             	sub    $0xc,%esp
  80c667:	8b 40 10             	mov    0x10(%eax),%eax
  80c66a:	ff 70 04             	pushl  0x4(%eax)
  80c66d:	e8 9d b3 ff ff       	call   807a0f <ntohl>
  80c672:	89 c3                	mov    %eax,%ebx
  80c674:	8b 47 78             	mov    0x78(%edi),%eax
  80c677:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c67b:	8b 40 10             	mov    0x10(%eax),%eax
  80c67e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c682:	89 04 24             	mov    %eax,(%esp)
  80c685:	e8 61 b1 ff ff       	call   8077eb <ntohs>
  80c68a:	83 c4 10             	add    $0x10,%esp
  80c68d:	ba 01 00 00 00       	mov    $0x1,%edx
  80c692:	a8 01                	test   $0x1,%al
  80c694:	0f 84 bf 00 00 00    	je     80c759 <tcp_receive+0x2b2>
  80c69a:	2b 1d a4 c1 b3 00    	sub    0xb3c1a4,%ebx
  80c6a0:	01 d6                	add    %edx,%esi
  80c6a2:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c6a4:	85 db                	test   %ebx,%ebx
  80c6a6:	0f 8f d0 00 00 00    	jg     80c77c <tcp_receive+0x2d5>
        next = pcb->unacked;
  80c6ac:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c6af:	8b 03                	mov    (%ebx),%eax
  80c6b1:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6b4:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c6b8:	83 ec 0c             	sub    $0xc,%esp
  80c6bb:	ff 73 04             	pushl  0x4(%ebx)
  80c6be:	e8 8b 86 ff ff       	call   804d4e <pbuf_clen>
  80c6c3:	0f b6 c0             	movzbl %al,%eax
  80c6c6:	83 c4 10             	add    $0x10,%esp
  80c6c9:	66 39 c6             	cmp    %ax,%si
  80c6cc:	72 74                	jb     80c742 <tcp_receive+0x29b>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c6ce:	83 ec 0c             	sub    $0xc,%esp
  80c6d1:	ff 73 04             	pushl  0x4(%ebx)
  80c6d4:	e8 75 86 ff ff       	call   804d4e <pbuf_clen>
  80c6d9:	0f b6 c0             	movzbl %al,%eax
  80c6dc:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c6e0:	89 1c 24             	mov    %ebx,(%esp)
  80c6e3:	e8 36 91 ff ff       	call   80581e <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c6e8:	83 c4 10             	add    $0x10,%esp
  80c6eb:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c6f0:	0f 84 63 ff ff ff    	je     80c659 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c6f6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c6fa:	0f 85 59 ff ff ff    	jne    80c659 <tcp_receive+0x1b2>
  80c700:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c704:	0f 85 4f ff ff ff    	jne    80c659 <tcp_receive+0x1b2>
  80c70a:	83 ec 04             	sub    $0x4,%esp
  80c70d:	68 4c 36 81 00       	push   $0x81364c
  80c712:	68 5c 03 00 00       	push   $0x35c
  80c717:	68 90 37 81 00       	push   $0x813790
  80c71c:	e8 4e 20 00 00       	call   80e76f <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c721:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c725:	0f af c0             	imul   %eax,%eax
  80c728:	0f b7 d9             	movzwl %cx,%ebx
  80c72b:	99                   	cltd   
  80c72c:	f7 fb                	idiv   %ebx
  80c72e:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c730:	66 39 c1             	cmp    %ax,%cx
  80c733:	0f 83 20 ff ff ff    	jae    80c659 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c739:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c73d:	e9 17 ff ff ff       	jmp    80c659 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c742:	83 ec 04             	sub    $0x4,%esp
  80c745:	68 24 36 81 00       	push   $0x813624
  80c74a:	68 55 03 00 00       	push   $0x355
  80c74f:	68 90 37 81 00       	push   $0x813790
  80c754:	e8 16 20 00 00       	call   80e76f <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c759:	83 ec 0c             	sub    $0xc,%esp
  80c75c:	8b 47 78             	mov    0x78(%edi),%eax
  80c75f:	8b 40 10             	mov    0x10(%eax),%eax
  80c762:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c766:	50                   	push   %eax
  80c767:	e8 7f b0 ff ff       	call   8077eb <ntohs>
  80c76c:	66 d1 e8             	shr    %ax
  80c76f:	89 c2                	mov    %eax,%edx
  80c771:	83 e2 01             	and    $0x1,%edx
  80c774:	83 c4 10             	add    $0x10,%esp
  80c777:	e9 1e ff ff ff       	jmp    80c69a <tcp_receive+0x1f3>
      if(pcb->unacked == NULL)
  80c77c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c780:	0f 94 c0             	sete   %al
  80c783:	0f b6 c0             	movzbl %al,%eax
  80c786:	f7 d8                	neg    %eax
  80c788:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c78c:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c790:	eb 39                	jmp    80c7cb <tcp_receive+0x324>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c792:	83 ec 04             	sub    $0x4,%esp
  80c795:	68 24 36 81 00       	push   $0x813624
  80c79a:	68 7f 03 00 00       	push   $0x37f
  80c79f:	68 90 37 81 00       	push   $0x813790
  80c7a4:	e8 c6 1f 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c7a9:	83 ec 04             	sub    $0x4,%esp
  80c7ac:	68 4c 36 81 00       	push   $0x81364c
  80c7b1:	68 85 03 00 00       	push   $0x385
  80c7b6:	68 90 37 81 00       	push   $0x813790
  80c7bb:	e8 af 1f 00 00       	call   80e76f <_panic>
      if (pcb->unsent != NULL) {
  80c7c0:	8b 47 74             	mov    0x74(%edi),%eax
  80c7c3:	85 c0                	test   %eax,%eax
  80c7c5:	0f 85 c8 00 00 00    	jne    80c893 <tcp_receive+0x3ec>
    while (pcb->unsent != NULL &&
  80c7cb:	8b 47 74             	mov    0x74(%edi),%eax
  80c7ce:	85 c0                	test   %eax,%eax
  80c7d0:	0f 84 f9 00 00 00    	je     80c8cf <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c7d6:	8b 1d a4 c1 b3 00    	mov    0xb3c1a4,%ebx
  80c7dc:	83 ec 0c             	sub    $0xc,%esp
  80c7df:	8b 40 10             	mov    0x10(%eax),%eax
  80c7e2:	ff 70 04             	pushl  0x4(%eax)
  80c7e5:	e8 25 b2 ff ff       	call   807a0f <ntohl>
  80c7ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c7ed:	8b 47 74             	mov    0x74(%edi),%eax
  80c7f0:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c7f4:	8b 40 10             	mov    0x10(%eax),%eax
  80c7f7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c7fb:	89 04 24             	mov    %eax,(%esp)
  80c7fe:	e8 e8 af ff ff       	call   8077eb <ntohs>
  80c803:	83 c4 10             	add    $0x10,%esp
  80c806:	ba 01 00 00 00       	mov    $0x1,%edx
  80c80b:	a8 01                	test   $0x1,%al
  80c80d:	0f 84 99 00 00 00    	je     80c8ac <tcp_receive+0x405>
  80c813:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c816:	01 d6                	add    %edx,%esi
    while (pcb->unsent != NULL &&
  80c818:	39 f3                	cmp    %esi,%ebx
  80c81a:	0f 88 af 00 00 00    	js     80c8cf <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c820:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c825:	2b 47 58             	sub    0x58(%edi),%eax
  80c828:	85 c0                	test   %eax,%eax
  80c82a:	0f 8f 9f 00 00 00    	jg     80c8cf <tcp_receive+0x428>
      next = pcb->unsent;
  80c830:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c833:	8b 03                	mov    (%ebx),%eax
  80c835:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c838:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c83c:	83 ec 0c             	sub    $0xc,%esp
  80c83f:	ff 73 04             	pushl  0x4(%ebx)
  80c842:	e8 07 85 ff ff       	call   804d4e <pbuf_clen>
  80c847:	0f b6 c0             	movzbl %al,%eax
  80c84a:	83 c4 10             	add    $0x10,%esp
  80c84d:	66 39 c6             	cmp    %ax,%si
  80c850:	0f 82 3c ff ff ff    	jb     80c792 <tcp_receive+0x2eb>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c856:	83 ec 0c             	sub    $0xc,%esp
  80c859:	ff 73 04             	pushl  0x4(%ebx)
  80c85c:	e8 ed 84 ff ff       	call   804d4e <pbuf_clen>
  80c861:	0f b6 c0             	movzbl %al,%eax
  80c864:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c868:	89 1c 24             	mov    %ebx,(%esp)
  80c86b:	e8 ae 8f ff ff       	call   80581e <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c870:	83 c4 10             	add    $0x10,%esp
  80c873:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c878:	0f 84 42 ff ff ff    	je     80c7c0 <tcp_receive+0x319>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c87e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c882:	0f 85 38 ff ff ff    	jne    80c7c0 <tcp_receive+0x319>
  80c888:	8b 47 74             	mov    0x74(%edi),%eax
  80c88b:	85 c0                	test   %eax,%eax
  80c88d:	0f 84 16 ff ff ff    	je     80c7a9 <tcp_receive+0x302>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c893:	83 ec 0c             	sub    $0xc,%esp
  80c896:	8b 40 10             	mov    0x10(%eax),%eax
  80c899:	ff 70 04             	pushl  0x4(%eax)
  80c89c:	e8 57 af ff ff       	call   8077f8 <htonl>
  80c8a1:	89 47 54             	mov    %eax,0x54(%edi)
  80c8a4:	83 c4 10             	add    $0x10,%esp
  80c8a7:	e9 1f ff ff ff       	jmp    80c7cb <tcp_receive+0x324>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c8ac:	83 ec 0c             	sub    $0xc,%esp
  80c8af:	8b 47 74             	mov    0x74(%edi),%eax
  80c8b2:	8b 40 10             	mov    0x10(%eax),%eax
  80c8b5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c8b9:	50                   	push   %eax
  80c8ba:	e8 2c af ff ff       	call   8077eb <ntohs>
  80c8bf:	66 d1 e8             	shr    %ax
  80c8c2:	89 c2                	mov    %eax,%edx
  80c8c4:	83 e2 01             	and    $0x1,%edx
  80c8c7:	83 c4 10             	add    $0x10,%esp
  80c8ca:	e9 44 ff ff ff       	jmp    80c813 <tcp_receive+0x36c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c8cf:	8b 47 38             	mov    0x38(%edi),%eax
  80c8d2:	85 c0                	test   %eax,%eax
  80c8d4:	74 0b                	je     80c8e1 <tcp_receive+0x43a>
  80c8d6:	8b 0d a4 c1 b3 00    	mov    0xb3c1a4,%ecx
  80c8dc:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c8df:	78 70                	js     80c951 <tcp_receive+0x4aa>
  if (tcplen > 0) {
  80c8e1:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80c8e8:	66 85 c0             	test   %ax,%ax
  80c8eb:	0f 84 52 08 00 00    	je     80d143 <tcp_receive+0xc9c>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c8f1:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c8f4:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
  80c8fa:	89 d9                	mov    %ebx,%ecx
  80c8fc:	29 d1                	sub    %edx,%ecx
  80c8fe:	89 ce                	mov    %ecx,%esi
  80c900:	83 ee 01             	sub    $0x1,%esi
  80c903:	78 16                	js     80c91b <tcp_receive+0x474>
  80c905:	be 01 00 00 00       	mov    $0x1,%esi
  80c90a:	29 d6                	sub    %edx,%esi
  80c90c:	0f b7 c0             	movzwl %ax,%eax
  80c90f:	29 c6                	sub    %eax,%esi
  80c911:	01 de                	add    %ebx,%esi
  80c913:	85 f6                	test   %esi,%esi
  80c915:	0f 8e 84 00 00 00    	jle    80c99f <tcp_receive+0x4f8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c91b:	39 da                	cmp    %ebx,%edx
  80c91d:	0f 88 bd 01 00 00    	js     80cae0 <tcp_receive+0x639>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c923:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c927:	89 d1                	mov    %edx,%ecx
  80c929:	29 c1                	sub    %eax,%ecx
  80c92b:	8d 41 01             	lea    0x1(%ecx),%eax
  80c92e:	29 d8                	sub    %ebx,%eax
  80c930:	85 c0                	test   %eax,%eax
  80c932:	0f 8e bd 01 00 00    	jle    80caf5 <tcp_receive+0x64e>
      tcp_ack_now(pcb);
  80c938:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c93c:	83 ec 0c             	sub    $0xc,%esp
  80c93f:	57                   	push   %edi
  80c940:	e8 fa b7 ff ff       	call   80813f <tcp_output>
  80c945:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c948:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80c94c:	e9 25 08 00 00       	jmp    80d176 <tcp_receive+0xccf>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c951:	8b 35 40 c2 b3 00    	mov    0xb3c240,%esi
      m = m - (pcb->sa >> 3);
  80c957:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c95b:	89 d3                	mov    %edx,%ebx
  80c95d:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c961:	89 f1                	mov    %esi,%ecx
  80c963:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c965:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80c967:	01 ca                	add    %ecx,%edx
  80c969:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80c96d:	29 f0                	sub    %esi,%eax
  80c96f:	01 d8                	add    %ebx,%eax
  80c971:	66 85 c9             	test   %cx,%cx
  80c974:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80c977:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80c97b:	89 cb                	mov    %ecx,%ebx
  80c97d:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c981:	29 d9                	sub    %ebx,%ecx
  80c983:	01 c8                	add    %ecx,%eax
  80c985:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c989:	66 c1 fa 03          	sar    $0x3,%dx
  80c98d:	01 d0                	add    %edx,%eax
  80c98f:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80c993:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c99a:	e9 42 ff ff ff       	jmp    80c8e1 <tcp_receive+0x43a>
      off = pcb->rcv_nxt - seqno;
  80c99f:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c9a1:	8b 1d b8 c1 b3 00    	mov    0xb3c1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c9a7:	85 db                	test   %ebx,%ebx
  80c9a9:	0f 84 a4 00 00 00    	je     80ca53 <tcp_receive+0x5ac>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c9af:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c9b5:	0f 8f af 00 00 00    	jg     80ca6a <tcp_receive+0x5c3>
      if (inseg.p->len < off) {
  80c9bb:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c9bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c9c2:	39 ca                	cmp    %ecx,%edx
  80c9c4:	0f 8d e5 00 00 00    	jge    80caaf <tcp_receive+0x608>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c9ca:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c9ce:	0f b7 d6             	movzwl %si,%edx
  80c9d1:	39 ca                	cmp    %ecx,%edx
  80c9d3:	0f 8c a8 00 00 00    	jl     80ca81 <tcp_receive+0x5da>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c9d9:	29 ce                	sub    %ecx,%esi
  80c9db:	89 f1                	mov    %esi,%ecx
  80c9dd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80c9e0:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80c9e2:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c9e6:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c9ec:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c9ee:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c9f2:	39 c2                	cmp    %eax,%edx
  80c9f4:	7c ea                	jl     80c9e0 <tcp_receive+0x539>
        if(pbuf_header(p, (s16_t)-off)) {
  80c9f6:	83 ec 08             	sub    $0x8,%esp
  80c9f9:	f7 d8                	neg    %eax
  80c9fb:	98                   	cwtl   
  80c9fc:	50                   	push   %eax
  80c9fd:	53                   	push   %ebx
  80c9fe:	e8 34 7e ff ff       	call   804837 <pbuf_header>
  80ca03:	83 c4 10             	add    $0x10,%esp
  80ca06:	84 c0                	test   %al,%al
  80ca08:	0f 85 8a 00 00 00    	jne    80ca98 <tcp_receive+0x5f1>
      inseg.dataptr = p->payload;
  80ca0e:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca11:	a3 bc c1 b3 00       	mov    %eax,0xb3c1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80ca16:	8b 57 24             	mov    0x24(%edi),%edx
  80ca19:	0f b7 05 c0 c1 b3 00 	movzwl 0xb3c1c0,%eax
  80ca20:	66 03 05 a8 c1 b3 00 	add    0xb3c1a8,%ax
  80ca27:	29 d0                	sub    %edx,%eax
  80ca29:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80ca2f:	89 15 a8 c1 b3 00    	mov    %edx,0xb3c1a8
  80ca35:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ca3a:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80ca3d:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
  80ca43:	8b 5f 24             	mov    0x24(%edi),%ebx
  80ca46:	39 da                	cmp    %ebx,%edx
  80ca48:	0f 88 ea fe ff ff    	js     80c938 <tcp_receive+0x491>
  80ca4e:	e9 d0 fe ff ff       	jmp    80c923 <tcp_receive+0x47c>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80ca53:	83 ec 04             	sub    $0x4,%esp
  80ca56:	68 a7 37 81 00       	push   $0x8137a7
  80ca5b:	68 e5 03 00 00       	push   $0x3e5
  80ca60:	68 90 37 81 00       	push   $0x813790
  80ca65:	e8 05 1d 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80ca6a:	83 ec 04             	sub    $0x4,%esp
  80ca6d:	68 b7 37 81 00       	push   $0x8137b7
  80ca72:	68 e6 03 00 00       	push   $0x3e6
  80ca77:	68 90 37 81 00       	push   $0x813790
  80ca7c:	e8 ee 1c 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80ca81:	83 ec 04             	sub    $0x4,%esp
  80ca84:	68 c6 37 81 00       	push   $0x8137c6
  80ca89:	68 e8 03 00 00       	push   $0x3e8
  80ca8e:	68 90 37 81 00       	push   $0x813790
  80ca93:	e8 d7 1c 00 00       	call   80e76f <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80ca98:	83 ec 04             	sub    $0x4,%esp
  80ca9b:	68 d6 37 81 00       	push   $0x8137d6
  80caa0:	68 f5 03 00 00       	push   $0x3f5
  80caa5:	68 90 37 81 00       	push   $0x813790
  80caaa:	e8 c0 1c 00 00       	call   80e76f <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80caaf:	83 ec 08             	sub    $0x8,%esp
  80cab2:	f7 d9                	neg    %ecx
  80cab4:	0f bf c1             	movswl %cx,%eax
  80cab7:	50                   	push   %eax
  80cab8:	53                   	push   %ebx
  80cab9:	e8 79 7d ff ff       	call   804837 <pbuf_header>
  80cabe:	83 c4 10             	add    $0x10,%esp
  80cac1:	84 c0                	test   %al,%al
  80cac3:	0f 84 45 ff ff ff    	je     80ca0e <tcp_receive+0x567>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cac9:	83 ec 04             	sub    $0x4,%esp
  80cacc:	68 d6 37 81 00       	push   $0x8137d6
  80cad1:	68 fa 03 00 00       	push   $0x3fa
  80cad6:	68 90 37 81 00       	push   $0x813790
  80cadb:	e8 8f 1c 00 00       	call   80e76f <_panic>
        tcp_ack_now(pcb);
  80cae0:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cae4:	83 ec 0c             	sub    $0xc,%esp
  80cae7:	57                   	push   %edi
  80cae8:	e8 52 b6 ff ff       	call   80813f <tcp_output>
  80caed:	83 c4 10             	add    $0x10,%esp
  80caf0:	e9 48 ff ff ff       	jmp    80ca3d <tcp_receive+0x596>
      if (pcb->rcv_nxt == seqno) {
  80caf5:	39 da                	cmp    %ebx,%edx
  80caf7:	0f 85 d2 03 00 00    	jne    80cecf <tcp_receive+0xa28>
        if (pcb->ooseq != NULL &&
  80cafd:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cb00:	85 c0                	test   %eax,%eax
  80cb02:	74 1d                	je     80cb21 <tcp_receive+0x67a>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80cb04:	8b 48 10             	mov    0x10(%eax),%ecx
  80cb07:	8b 59 04             	mov    0x4(%ecx),%ebx
  80cb0a:	0f b7 0d c0 c1 b3 00 	movzwl 0xb3c1c0,%ecx
  80cb11:	89 de                	mov    %ebx,%esi
  80cb13:	29 ce                	sub    %ecx,%esi
  80cb15:	89 f1                	mov    %esi,%ecx
  80cb17:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80cb19:	85 c9                	test   %ecx,%ecx
  80cb1b:	0f 8e b0 00 00 00    	jle    80cbd1 <tcp_receive+0x72a>
        tcplen = TCP_TCPLEN(&inseg);
  80cb21:	0f b7 1d c0 c1 b3 00 	movzwl 0xb3c1c0,%ebx
  80cb28:	83 ec 0c             	sub    $0xc,%esp
  80cb2b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cb30:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb34:	50                   	push   %eax
  80cb35:	e8 b1 ac ff ff       	call   8077eb <ntohs>
  80cb3a:	83 c4 10             	add    $0x10,%esp
  80cb3d:	ba 01 00 00 00       	mov    $0x1,%edx
  80cb42:	a8 01                	test   $0x1,%al
  80cb44:	0f 84 00 01 00 00    	je     80cc4a <tcp_receive+0x7a3>
  80cb4a:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80cb4d:	66 a3 9e c1 b3 00    	mov    %ax,0xb3c19e
        if (pcb->state != CLOSE_WAIT) {
  80cb53:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80cb57:	74 06                	je     80cb5f <tcp_receive+0x6b8>
          pcb->rcv_nxt += tcplen;
  80cb59:	0f b7 d0             	movzwl %ax,%edx
  80cb5c:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80cb5f:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80cb63:	89 ca                	mov    %ecx,%edx
  80cb65:	29 c2                	sub    %eax,%edx
  80cb67:	66 39 c8             	cmp    %cx,%ax
  80cb6a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80cb6f:	0f 47 d1             	cmova  %ecx,%edx
  80cb72:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80cb76:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80cb7a:	89 ca                	mov    %ecx,%edx
  80cb7c:	29 c2                	sub    %eax,%edx
  80cb7e:	66 39 c8             	cmp    %cx,%ax
  80cb81:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb86:	0f 46 c2             	cmovbe %edx,%eax
  80cb89:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80cb8d:	a1 b8 c1 b3 00       	mov    0xb3c1b8,%eax
  80cb92:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cb97:	74 0f                	je     80cba8 <tcp_receive+0x701>
          recv_data = inseg.p;
  80cb99:	a3 98 c1 b3 00       	mov    %eax,0xb3c198
          inseg.p = NULL;
  80cb9e:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80cba5:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80cba8:	83 ec 0c             	sub    $0xc,%esp
  80cbab:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cbb0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbb4:	50                   	push   %eax
  80cbb5:	e8 31 ac ff ff       	call   8077eb <ntohs>
  80cbba:	83 c4 10             	add    $0x10,%esp
  80cbbd:	a8 01                	test   $0x1,%al
  80cbbf:	0f 84 e4 01 00 00    	je     80cda9 <tcp_receive+0x902>
          recv_flags = TF_GOT_FIN;
  80cbc5:	c6 05 9c c1 b3 00 20 	movb   $0x20,0xb3c19c
  80cbcc:	e9 d8 01 00 00       	jmp    80cda9 <tcp_receive+0x902>
          if (pcb->ooseq->len > 0) {
  80cbd1:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80cbd6:	74 23                	je     80cbfb <tcp_receive+0x754>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80cbd8:	29 d3                	sub    %edx,%ebx
  80cbda:	66 89 1d c0 c1 b3 00 	mov    %bx,0xb3c1c0
            pbuf_realloc(inseg.p, inseg.len);
  80cbe1:	83 ec 08             	sub    $0x8,%esp
  80cbe4:	0f b7 db             	movzwl %bx,%ebx
  80cbe7:	53                   	push   %ebx
  80cbe8:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80cbee:	e8 49 80 ff ff       	call   804c3c <pbuf_realloc>
  80cbf3:	83 c4 10             	add    $0x10,%esp
  80cbf6:	e9 26 ff ff ff       	jmp    80cb21 <tcp_receive+0x67a>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cbfb:	83 ec 0c             	sub    $0xc,%esp
  80cbfe:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cc03:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc07:	50                   	push   %eax
  80cc08:	e8 de ab ff ff       	call   8077eb <ntohs>
  80cc0d:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cc0f:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cc12:	8b 40 10             	mov    0x10(%eax),%eax
  80cc15:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc19:	89 04 24             	mov    %eax,(%esp)
  80cc1c:	e8 ca ab ff ff       	call   8077eb <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cc21:	31 c3                	xor    %eax,%ebx
  80cc23:	83 c4 10             	add    $0x10,%esp
  80cc26:	f6 c3 03             	test   $0x3,%bl
  80cc29:	0f 85 f2 fe ff ff    	jne    80cb21 <tcp_receive+0x67a>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cc2f:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cc32:	8b 10                	mov    (%eax),%edx
  80cc34:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cc37:	83 ec 08             	sub    $0x8,%esp
  80cc3a:	50                   	push   %eax
  80cc3b:	6a 04                	push   $0x4
  80cc3d:	e8 75 79 ff ff       	call   8045b7 <memp_free>
  80cc42:	83 c4 10             	add    $0x10,%esp
  80cc45:	e9 d7 fe ff ff       	jmp    80cb21 <tcp_receive+0x67a>
        tcplen = TCP_TCPLEN(&inseg);
  80cc4a:	83 ec 0c             	sub    $0xc,%esp
  80cc4d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cc52:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc56:	50                   	push   %eax
  80cc57:	e8 8f ab ff ff       	call   8077eb <ntohs>
  80cc5c:	66 d1 e8             	shr    %ax
  80cc5f:	89 c2                	mov    %eax,%edx
  80cc61:	83 e2 01             	and    $0x1,%edx
  80cc64:	83 c4 10             	add    $0x10,%esp
  80cc67:	e9 de fe ff ff       	jmp    80cb4a <tcp_receive+0x6a3>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cc6c:	83 ec 0c             	sub    $0xc,%esp
  80cc6f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc72:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc76:	50                   	push   %eax
  80cc77:	e8 6f ab ff ff       	call   8077eb <ntohs>
  80cc7c:	66 d1 e8             	shr    %ax
  80cc7f:	89 c2                	mov    %eax,%edx
  80cc81:	83 e2 01             	and    $0x1,%edx
  80cc84:	83 c4 10             	add    $0x10,%esp
  80cc87:	e9 5d 01 00 00       	jmp    80cde9 <tcp_receive+0x942>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cc8c:	83 ec 0c             	sub    $0xc,%esp
  80cc8f:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc92:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc96:	50                   	push   %eax
  80cc97:	e8 4f ab ff ff       	call   8077eb <ntohs>
  80cc9c:	66 d1 e8             	shr    %ax
  80cc9f:	89 c2                	mov    %eax,%edx
  80cca1:	83 e2 01             	and    $0x1,%edx
  80cca4:	83 c4 10             	add    $0x10,%esp
  80cca7:	e9 6d 01 00 00       	jmp    80ce19 <tcp_receive+0x972>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80ccac:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ccb0:	83 ec 0c             	sub    $0xc,%esp
  80ccb3:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccb6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccba:	50                   	push   %eax
  80ccbb:	e8 2b ab ff ff       	call   8077eb <ntohs>
  80ccc0:	83 c4 10             	add    $0x10,%esp
  80ccc3:	ba 01 00 00 00       	mov    $0x1,%edx
  80ccc8:	a8 01                	test   $0x1,%al
  80ccca:	74 0b                	je     80ccd7 <tcp_receive+0x830>
  80cccc:	01 d6                	add    %edx,%esi
  80ccce:	66 29 77 28          	sub    %si,0x28(%edi)
  80ccd2:	e9 53 01 00 00       	jmp    80ce2a <tcp_receive+0x983>
  80ccd7:	83 ec 0c             	sub    $0xc,%esp
  80ccda:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccdd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cce1:	50                   	push   %eax
  80cce2:	e8 04 ab ff ff       	call   8077eb <ntohs>
  80cce7:	66 d1 e8             	shr    %ax
  80ccea:	89 c2                	mov    %eax,%edx
  80ccec:	83 e2 01             	and    $0x1,%edx
  80ccef:	83 c4 10             	add    $0x10,%esp
  80ccf2:	eb d8                	jmp    80cccc <tcp_receive+0x825>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ccf4:	83 ec 0c             	sub    $0xc,%esp
  80ccf7:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccfa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccfe:	50                   	push   %eax
  80ccff:	e8 e7 aa ff ff       	call   8077eb <ntohs>
  80cd04:	66 d1 e8             	shr    %ax
  80cd07:	89 c2                	mov    %eax,%edx
  80cd09:	83 e2 01             	and    $0x1,%edx
  80cd0c:	83 c4 10             	add    $0x10,%esp
  80cd0f:	e9 41 01 00 00       	jmp    80ce55 <tcp_receive+0x9ae>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cd14:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd18:	83 ec 0c             	sub    $0xc,%esp
  80cd1b:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd22:	50                   	push   %eax
  80cd23:	e8 c3 aa ff ff       	call   8077eb <ntohs>
  80cd28:	83 c4 10             	add    $0x10,%esp
  80cd2b:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd30:	a8 01                	test   $0x1,%al
  80cd32:	74 0b                	je     80cd3f <tcp_receive+0x898>
  80cd34:	01 d6                	add    %edx,%esi
  80cd36:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cd3a:	e9 27 01 00 00       	jmp    80ce66 <tcp_receive+0x9bf>
  80cd3f:	83 ec 0c             	sub    $0xc,%esp
  80cd42:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd45:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd49:	50                   	push   %eax
  80cd4a:	e8 9c aa ff ff       	call   8077eb <ntohs>
  80cd4f:	66 d1 e8             	shr    %ax
  80cd52:	89 c2                	mov    %eax,%edx
  80cd54:	83 e2 01             	and    $0x1,%edx
  80cd57:	83 c4 10             	add    $0x10,%esp
  80cd5a:	eb d8                	jmp    80cd34 <tcp_receive+0x88d>
              pbuf_cat(recv_data, cseg->p);
  80cd5c:	83 ec 08             	sub    $0x8,%esp
  80cd5f:	50                   	push   %eax
  80cd60:	52                   	push   %edx
  80cd61:	e8 11 80 ff ff       	call   804d77 <pbuf_cat>
  80cd66:	83 c4 10             	add    $0x10,%esp
            cseg->p = NULL;
  80cd69:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cd70:	83 ec 0c             	sub    $0xc,%esp
  80cd73:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd76:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd7a:	50                   	push   %eax
  80cd7b:	e8 6b aa ff ff       	call   8077eb <ntohs>
  80cd80:	83 c4 10             	add    $0x10,%esp
  80cd83:	a8 01                	test   $0x1,%al
  80cd85:	74 11                	je     80cd98 <tcp_receive+0x8f1>
            recv_flags = TF_GOT_FIN;
  80cd87:	c6 05 9c c1 b3 00 20 	movb   $0x20,0xb3c19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cd8e:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cd92:	0f 84 f4 00 00 00    	je     80ce8c <tcp_receive+0x9e5>
          pcb->ooseq = cseg->next;
  80cd98:	8b 03                	mov    (%ebx),%eax
  80cd9a:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cd9d:	83 ec 0c             	sub    $0xc,%esp
  80cda0:	53                   	push   %ebx
  80cda1:	e8 78 8a ff ff       	call   80581e <tcp_seg_free>
  80cda6:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cda9:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cdac:	85 db                	test   %ebx,%ebx
  80cdae:	0f 84 e4 00 00 00    	je     80ce98 <tcp_receive+0x9f1>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cdb4:	8b 53 10             	mov    0x10(%ebx),%edx
  80cdb7:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cdba:	3b 47 24             	cmp    0x24(%edi),%eax
  80cdbd:	0f 85 d5 00 00 00    	jne    80ce98 <tcp_receive+0x9f1>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cdc3:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cdc8:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cdcc:	83 ec 0c             	sub    $0xc,%esp
  80cdcf:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cdd3:	50                   	push   %eax
  80cdd4:	e8 12 aa ff ff       	call   8077eb <ntohs>
  80cdd9:	83 c4 10             	add    $0x10,%esp
  80cddc:	ba 01 00 00 00       	mov    $0x1,%edx
  80cde1:	a8 01                	test   $0x1,%al
  80cde3:	0f 84 83 fe ff ff    	je     80cc6c <tcp_receive+0x7c5>
  80cde9:	01 d6                	add    %edx,%esi
  80cdeb:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cdee:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cdf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cdf5:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cdf9:	83 ec 0c             	sub    $0xc,%esp
  80cdfc:	8b 43 10             	mov    0x10(%ebx),%eax
  80cdff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce03:	50                   	push   %eax
  80ce04:	e8 e2 a9 ff ff       	call   8077eb <ntohs>
  80ce09:	83 c4 10             	add    $0x10,%esp
  80ce0c:	ba 01 00 00 00       	mov    $0x1,%edx
  80ce11:	a8 01                	test   $0x1,%al
  80ce13:	0f 84 73 fe ff ff    	je     80cc8c <tcp_receive+0x7e5>
  80ce19:	01 d6                	add    %edx,%esi
  80ce1b:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ce1e:	0f 8d 88 fe ff ff    	jge    80ccac <tcp_receive+0x805>
            pcb->rcv_wnd = 0;
  80ce24:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ce2a:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80ce2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ce31:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ce35:	83 ec 0c             	sub    $0xc,%esp
  80ce38:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce3b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce3f:	50                   	push   %eax
  80ce40:	e8 a6 a9 ff ff       	call   8077eb <ntohs>
  80ce45:	83 c4 10             	add    $0x10,%esp
  80ce48:	ba 01 00 00 00       	mov    $0x1,%edx
  80ce4d:	a8 01                	test   $0x1,%al
  80ce4f:	0f 84 9f fe ff ff    	je     80ccf4 <tcp_receive+0x84d>
  80ce55:	01 d6                	add    %edx,%esi
  80ce57:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ce5a:	0f 8d b4 fe ff ff    	jge    80cd14 <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80ce60:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80ce66:	8b 43 04             	mov    0x4(%ebx),%eax
  80ce69:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ce6e:	0f 84 fc fe ff ff    	je     80cd70 <tcp_receive+0x8c9>
            if (recv_data) {
  80ce74:	8b 15 98 c1 b3 00    	mov    0xb3c198,%edx
  80ce7a:	85 d2                	test   %edx,%edx
  80ce7c:	0f 85 da fe ff ff    	jne    80cd5c <tcp_receive+0x8b5>
              recv_data = cseg->p;
  80ce82:	a3 98 c1 b3 00       	mov    %eax,0xb3c198
  80ce87:	e9 dd fe ff ff       	jmp    80cd69 <tcp_receive+0x8c2>
              pcb->state = CLOSE_WAIT;
  80ce8c:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80ce93:	e9 00 ff ff ff       	jmp    80cd98 <tcp_receive+0x8f1>
        tcp_ack(pcb);
  80ce98:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80ce9c:	89 c1                	mov    %eax,%ecx
  80ce9e:	83 e1 01             	and    $0x1,%ecx
  80cea1:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80cea4:	75 0f                	jne    80ceb5 <tcp_receive+0xa0e>
  80cea6:	83 c8 01             	or     $0x1,%eax
  80cea9:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80ceac:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80ceb0:	e9 c1 02 00 00       	jmp    80d176 <tcp_receive+0xccf>
        tcp_ack(pcb);
  80ceb5:	83 e0 fe             	and    $0xfffffffe,%eax
  80ceb8:	83 c8 02             	or     $0x2,%eax
  80cebb:	88 47 20             	mov    %al,0x20(%edi)
  80cebe:	83 ec 0c             	sub    $0xc,%esp
  80cec1:	57                   	push   %edi
  80cec2:	e8 78 b2 ff ff       	call   80813f <tcp_output>
  80cec7:	83 c4 10             	add    $0x10,%esp
  80ceca:	e9 a7 02 00 00       	jmp    80d176 <tcp_receive+0xccf>
        tcp_ack_now(pcb);
  80cecf:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ced3:	83 ec 0c             	sub    $0xc,%esp
  80ced6:	57                   	push   %edi
  80ced7:	e8 63 b2 ff ff       	call   80813f <tcp_output>
        if (pcb->ooseq == NULL) {
  80cedc:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cedf:	83 c4 10             	add    $0x10,%esp
  80cee2:	85 db                	test   %ebx,%ebx
  80cee4:	74 1e                	je     80cf04 <tcp_receive+0xa5d>
            if (seqno == next->tcphdr->seqno) {
  80cee6:	8b 0d a8 c1 b3 00    	mov    0xb3c1a8,%ecx
  80ceec:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80ceef:	8d 51 01             	lea    0x1(%ecx),%edx
  80cef2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80cef5:	be 00 00 00 00       	mov    $0x0,%esi
  80cefa:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cefd:	89 c7                	mov    %eax,%edi
  80ceff:	e9 d7 00 00 00       	jmp    80cfdb <tcp_receive+0xb34>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cf04:	83 ec 0c             	sub    $0xc,%esp
  80cf07:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80cf0c:	e8 86 89 ff ff       	call   805897 <tcp_seg_copy>
  80cf11:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cf14:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf17:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cf1b:	e9 56 02 00 00       	jmp    80d176 <tcp_receive+0xccf>
  80cf20:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cf23:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80cf27:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cf2b:	66 39 05 c0 c1 b3 00 	cmp    %ax,0xb3c1c0
  80cf32:	0f 86 3e 02 00 00    	jbe    80d176 <tcp_receive+0xccf>
                cseg = tcp_seg_copy(&inseg);
  80cf38:	83 ec 0c             	sub    $0xc,%esp
  80cf3b:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80cf40:	e8 52 89 ff ff       	call   805897 <tcp_seg_copy>
  80cf45:	89 c1                	mov    %eax,%ecx
  80cf47:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80cf4a:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf4d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cf51:	85 c0                	test   %eax,%eax
  80cf53:	0f 84 1d 02 00 00    	je     80d176 <tcp_receive+0xccf>
                  cseg->next = next->next;
  80cf59:	8b 03                	mov    (%ebx),%eax
  80cf5b:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cf5d:	85 f6                	test   %esi,%esi
  80cf5f:	74 5c                	je     80cfbd <tcp_receive+0xb16>
                    prev->next = cseg;
  80cf61:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cf63:	83 ec 0c             	sub    $0xc,%esp
  80cf66:	53                   	push   %ebx
  80cf67:	e8 b2 88 ff ff       	call   80581e <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cf6c:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80cf6f:	8b 06                	mov    (%esi),%eax
  80cf71:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf74:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80cf78:	85 c0                	test   %eax,%eax
  80cf7a:	0f 84 f6 01 00 00    	je     80d176 <tcp_receive+0xccf>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80cf80:	8b 0d a8 c1 b3 00    	mov    0xb3c1a8,%ecx
  80cf86:	8b 40 10             	mov    0x10(%eax),%eax
  80cf89:	8b 40 04             	mov    0x4(%eax),%eax
  80cf8c:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80cf90:	01 ca                	add    %ecx,%edx
  80cf92:	29 c2                	sub    %eax,%edx
  80cf94:	85 d2                	test   %edx,%edx
  80cf96:	0f 8e da 01 00 00    	jle    80d176 <tcp_receive+0xccf>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf9c:	29 c8                	sub    %ecx,%eax
  80cf9e:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cfa2:	83 ec 08             	sub    $0x8,%esp
  80cfa5:	0f b7 c0             	movzwl %ax,%eax
  80cfa8:	50                   	push   %eax
  80cfa9:	ff 76 04             	pushl  0x4(%esi)
  80cfac:	e8 8b 7c ff ff       	call   804c3c <pbuf_realloc>
  80cfb1:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfb4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cfb8:	e9 b9 01 00 00       	jmp    80d176 <tcp_receive+0xccf>
                    pcb->ooseq = cseg;
  80cfbd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80cfc0:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cfc3:	eb 9e                	jmp    80cf63 <tcp_receive+0xabc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80cfc5:	39 c1                	cmp    %eax,%ecx
  80cfc7:	0f 88 a0 00 00 00    	js     80d06d <tcp_receive+0xbc6>
              if (next->next == NULL &&
  80cfcd:	8b 13                	mov    (%ebx),%edx
  80cfcf:	89 de                	mov    %ebx,%esi
  80cfd1:	85 d2                	test   %edx,%edx
  80cfd3:	0f 84 0d 01 00 00    	je     80d0e6 <tcp_receive+0xc3f>
  80cfd9:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80cfdb:	8b 43 10             	mov    0x10(%ebx),%eax
  80cfde:	8b 40 04             	mov    0x4(%eax),%eax
  80cfe1:	39 c8                	cmp    %ecx,%eax
  80cfe3:	0f 84 37 ff ff ff    	je     80cf20 <tcp_receive+0xa79>
              if (prev == NULL) {
  80cfe9:	85 f6                	test   %esi,%esi
  80cfeb:	74 d8                	je     80cfc5 <tcp_receive+0xb1e>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cfed:	8b 56 10             	mov    0x10(%esi),%edx
  80cff0:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cff3:	78 d8                	js     80cfcd <tcp_receive+0xb26>
  80cff5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cff8:	29 c2                	sub    %eax,%edx
  80cffa:	85 d2                	test   %edx,%edx
  80cffc:	7f cf                	jg     80cfcd <tcp_receive+0xb26>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cffe:	0f b7 15 c0 c1 b3 00 	movzwl 0xb3c1c0,%edx
  80d005:	01 ca                	add    %ecx,%edx
  80d007:	29 c2                	sub    %eax,%edx
  80d009:	85 d2                	test   %edx,%edx
  80d00b:	0f 8f b3 00 00 00    	jg     80d0c4 <tcp_receive+0xc1d>
                cseg = tcp_seg_copy(&inseg);
  80d011:	83 ec 0c             	sub    $0xc,%esp
  80d014:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d019:	e8 79 88 ff ff       	call   805897 <tcp_seg_copy>
                if (cseg != NULL) {
  80d01e:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d021:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d025:	85 c0                	test   %eax,%eax
  80d027:	0f 84 49 01 00 00    	je     80d176 <tcp_receive+0xccf>
                  cseg->next = next;
  80d02d:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d02f:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d031:	8b 46 10             	mov    0x10(%esi),%eax
  80d034:	8b 48 04             	mov    0x4(%eax),%ecx
  80d037:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d03c:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d040:	01 ca                	add    %ecx,%edx
  80d042:	29 c2                	sub    %eax,%edx
  80d044:	85 d2                	test   %edx,%edx
  80d046:	0f 8e 2a 01 00 00    	jle    80d176 <tcp_receive+0xccf>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d04c:	29 c8                	sub    %ecx,%eax
  80d04e:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d052:	83 ec 08             	sub    $0x8,%esp
  80d055:	0f b7 c0             	movzwl %ax,%eax
  80d058:	50                   	push   %eax
  80d059:	ff 76 04             	pushl  0x4(%esi)
  80d05c:	e8 db 7b ff ff       	call   804c3c <pbuf_realloc>
  80d061:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d064:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d068:	e9 09 01 00 00       	jmp    80d176 <tcp_receive+0xccf>
  80d06d:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d070:	0f b7 15 c0 c1 b3 00 	movzwl 0xb3c1c0,%edx
  80d077:	01 ca                	add    %ecx,%edx
  80d079:	29 c2                	sub    %eax,%edx
  80d07b:	85 d2                	test   %edx,%edx
  80d07d:	7f 26                	jg     80d0a5 <tcp_receive+0xbfe>
                  cseg = tcp_seg_copy(&inseg);
  80d07f:	83 ec 0c             	sub    $0xc,%esp
  80d082:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d087:	e8 0b 88 ff ff       	call   805897 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d08c:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d08f:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80d093:	85 c0                	test   %eax,%eax
  80d095:	0f 84 db 00 00 00    	je     80d176 <tcp_receive+0xccf>
                    cseg->next = next;
  80d09b:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d09d:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d0a0:	e9 d1 00 00 00       	jmp    80d176 <tcp_receive+0xccf>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d0a5:	29 c8                	sub    %ecx,%eax
  80d0a7:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d0ad:	83 ec 08             	sub    $0x8,%esp
  80d0b0:	0f b7 c0             	movzwl %ax,%eax
  80d0b3:	50                   	push   %eax
  80d0b4:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80d0ba:	e8 7d 7b ff ff       	call   804c3c <pbuf_realloc>
  80d0bf:	83 c4 10             	add    $0x10,%esp
  80d0c2:	eb bb                	jmp    80d07f <tcp_receive+0xbd8>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d0c4:	29 c8                	sub    %ecx,%eax
  80d0c6:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80d0cc:	83 ec 08             	sub    $0x8,%esp
  80d0cf:	0f b7 c0             	movzwl %ax,%eax
  80d0d2:	50                   	push   %eax
  80d0d3:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80d0d9:	e8 5e 7b ff ff       	call   804c3c <pbuf_realloc>
  80d0de:	83 c4 10             	add    $0x10,%esp
  80d0e1:	e9 2b ff ff ff       	jmp    80d011 <tcp_receive+0xb6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d0e6:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d0e8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d0ec:	85 c9                	test   %ecx,%ecx
  80d0ee:	0f 8e 82 00 00 00    	jle    80d176 <tcp_receive+0xccf>
                next->next = tcp_seg_copy(&inseg);
  80d0f4:	83 ec 0c             	sub    $0xc,%esp
  80d0f7:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d0fc:	e8 96 87 ff ff       	call   805897 <tcp_seg_copy>
  80d101:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d103:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d106:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d10a:	85 c0                	test   %eax,%eax
  80d10c:	74 68                	je     80d176 <tcp_receive+0xccf>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d10e:	8b 43 10             	mov    0x10(%ebx),%eax
  80d111:	8b 48 04             	mov    0x4(%eax),%ecx
  80d114:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d119:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d11d:	01 ca                	add    %ecx,%edx
  80d11f:	29 c2                	sub    %eax,%edx
  80d121:	85 d2                	test   %edx,%edx
  80d123:	7e 51                	jle    80d176 <tcp_receive+0xccf>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d125:	29 c8                	sub    %ecx,%eax
  80d127:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d12b:	83 ec 08             	sub    $0x8,%esp
  80d12e:	0f b7 c0             	movzwl %ax,%eax
  80d131:	50                   	push   %eax
  80d132:	ff 73 04             	pushl  0x4(%ebx)
  80d135:	e8 02 7b ff ff       	call   804c3c <pbuf_realloc>
  80d13a:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d13d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d141:	eb 33                	jmp    80d176 <tcp_receive+0xccf>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d143:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d148:	8b 57 24             	mov    0x24(%edi),%edx
  80d14b:	39 d0                	cmp    %edx,%eax
  80d14d:	78 13                	js     80d162 <tcp_receive+0xcbb>
  80d14f:	83 c0 01             	add    $0x1,%eax
  80d152:	29 d0                	sub    %edx,%eax
  80d154:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d158:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d15a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d15e:	85 c0                	test   %eax,%eax
  80d160:	7e 14                	jle    80d176 <tcp_receive+0xccf>
      tcp_ack_now(pcb);
  80d162:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d166:	83 ec 0c             	sub    $0xc,%esp
  80d169:	57                   	push   %edi
  80d16a:	e8 d0 af ff ff       	call   80813f <tcp_output>
  80d16f:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d172:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d176:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d17a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d17d:	5b                   	pop    %ebx
  80d17e:	5e                   	pop    %esi
  80d17f:	5f                   	pop    %edi
  80d180:	5d                   	pop    %ebp
  80d181:	c3                   	ret    

0080d182 <tcp_input>:
{
  80d182:	55                   	push   %ebp
  80d183:	89 e5                	mov    %esp,%ebp
  80d185:	57                   	push   %edi
  80d186:	56                   	push   %esi
  80d187:	53                   	push   %ebx
  80d188:	83 ec 38             	sub    $0x38,%esp
  80d18b:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d18e:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d191:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d197:	0f b7 03             	movzwl (%ebx),%eax
  80d19a:	50                   	push   %eax
  80d19b:	e8 4b a6 ff ff       	call   8077eb <ntohs>
  80d1a0:	66 c1 e8 08          	shr    $0x8,%ax
  80d1a4:	83 e0 0f             	and    $0xf,%eax
  80d1a7:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d1aa:	a3 b0 c1 b3 00       	mov    %eax,0xb3c1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d1af:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d1b4:	0f b7 00             	movzwl (%eax),%eax
  80d1b7:	89 04 24             	mov    %eax,(%esp)
  80d1ba:	e8 2c a6 ff ff       	call   8077eb <ntohs>
  80d1bf:	83 c4 08             	add    $0x8,%esp
  80d1c2:	66 c1 e8 06          	shr    $0x6,%ax
  80d1c6:	83 e0 3c             	and    $0x3c,%eax
  80d1c9:	f7 d8                	neg    %eax
  80d1cb:	98                   	cwtl   
  80d1cc:	50                   	push   %eax
  80d1cd:	56                   	push   %esi
  80d1ce:	e8 64 76 ff ff       	call   804837 <pbuf_header>
  80d1d3:	83 c4 10             	add    $0x10,%esp
  80d1d6:	84 c0                	test   %al,%al
  80d1d8:	75 07                	jne    80d1e1 <tcp_input+0x5f>
  80d1da:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d1df:	77 14                	ja     80d1f5 <tcp_input+0x73>
    pbuf_free(p);
  80d1e1:	83 ec 0c             	sub    $0xc,%esp
  80d1e4:	56                   	push   %esi
  80d1e5:	e8 1a 77 ff ff       	call   804904 <pbuf_free>
    return;
  80d1ea:	83 c4 10             	add    $0x10,%esp
}
  80d1ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d1f0:	5b                   	pop    %ebx
  80d1f1:	5e                   	pop    %esi
  80d1f2:	5f                   	pop    %edi
  80d1f3:	5d                   	pop    %ebp
  80d1f4:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d1f5:	83 ec 08             	sub    $0x8,%esp
  80d1f8:	ff 75 0c             	pushl  0xc(%ebp)
  80d1fb:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d200:	83 c0 10             	add    $0x10,%eax
  80d203:	50                   	push   %eax
  80d204:	e8 72 93 ff ff       	call   80657b <ip_addr_isbroadcast>
  80d209:	83 c4 10             	add    $0x10,%esp
  80d20c:	84 c0                	test   %al,%al
  80d20e:	0f 85 54 01 00 00    	jne    80d368 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d214:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d219:	8b 58 10             	mov    0x10(%eax),%ebx
  80d21c:	83 ec 0c             	sub    $0xc,%esp
  80d21f:	68 00 00 00 f0       	push   $0xf0000000
  80d224:	e8 e6 a7 ff ff       	call   807a0f <ntohl>
  80d229:	21 c3                	and    %eax,%ebx
  80d22b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d232:	e8 d8 a7 ff ff       	call   807a0f <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d237:	83 c4 10             	add    $0x10,%esp
  80d23a:	39 c3                	cmp    %eax,%ebx
  80d23c:	0f 84 26 01 00 00    	je     80d368 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d242:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d247:	83 ec 0c             	sub    $0xc,%esp
  80d24a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d24e:	52                   	push   %edx
  80d24f:	6a 06                	push   $0x6
  80d251:	8d 50 10             	lea    0x10(%eax),%edx
  80d254:	52                   	push   %edx
  80d255:	83 c0 0c             	add    $0xc,%eax
  80d258:	50                   	push   %eax
  80d259:	56                   	push   %esi
  80d25a:	e8 5b a2 ff ff       	call   8074ba <inet_chksum_pseudo>
  80d25f:	83 c4 20             	add    $0x20,%esp
  80d262:	66 85 c0             	test   %ax,%ax
  80d265:	0f 85 0e 01 00 00    	jne    80d379 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d26b:	83 ec 0c             	sub    $0xc,%esp
  80d26e:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80d273:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d277:	50                   	push   %eax
  80d278:	e8 6e a5 ff ff       	call   8077eb <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d27d:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d280:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d284:	f7 d8                	neg    %eax
  80d286:	c1 e0 02             	shl    $0x2,%eax
  80d289:	98                   	cwtl   
  80d28a:	50                   	push   %eax
  80d28b:	56                   	push   %esi
  80d28c:	e8 a6 75 ff ff       	call   804837 <pbuf_header>
  80d291:	83 c4 10             	add    $0x10,%esp
  80d294:	84 c0                	test   %al,%al
  80d296:	0f 85 ee 00 00 00    	jne    80d38a <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d29c:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d2a2:	83 ec 0c             	sub    $0xc,%esp
  80d2a5:	0f b7 03             	movzwl (%ebx),%eax
  80d2a8:	50                   	push   %eax
  80d2a9:	e8 3d a5 ff ff       	call   8077eb <ntohs>
  80d2ae:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d2b1:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d2b7:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d2bb:	89 04 24             	mov    %eax,(%esp)
  80d2be:	e8 28 a5 ff ff       	call   8077eb <ntohs>
  80d2c3:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d2c7:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d2cd:	83 c4 04             	add    $0x4,%esp
  80d2d0:	ff 73 04             	pushl  0x4(%ebx)
  80d2d3:	e8 37 a7 ff ff       	call   807a0f <ntohl>
  80d2d8:	89 43 04             	mov    %eax,0x4(%ebx)
  80d2db:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d2e0:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d2e6:	83 c4 04             	add    $0x4,%esp
  80d2e9:	ff 73 08             	pushl  0x8(%ebx)
  80d2ec:	e8 1e a7 ff ff       	call   807a0f <ntohl>
  80d2f1:	89 43 08             	mov    %eax,0x8(%ebx)
  80d2f4:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d2f9:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d2ff:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d303:	89 04 24             	mov    %eax,(%esp)
  80d306:	e8 e0 a4 ff ff       	call   8077eb <ntohs>
  80d30b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d30f:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80d314:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d318:	89 04 24             	mov    %eax,(%esp)
  80d31b:	e8 cb a4 ff ff       	call   8077eb <ntohs>
  80d320:	89 c1                	mov    %eax,%ecx
  80d322:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d326:	83 e0 3f             	and    $0x3f,%eax
  80d329:	a2 a0 c1 b3 00       	mov    %al,0xb3c1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d32e:	83 c4 10             	add    $0x10,%esp
  80d331:	f6 c1 03             	test   $0x3,%cl
  80d334:	0f 95 c0             	setne  %al
  80d337:	0f b6 c0             	movzbl %al,%eax
  80d33a:	66 03 46 08          	add    0x8(%esi),%ax
  80d33e:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d342:	66 a3 9e c1 b3 00    	mov    %ax,0xb3c19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d348:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80d34d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d350:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d356:	8b 0d ac c1 b3 00    	mov    0xb3c1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d35c:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d35e:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d363:	e9 ab 00 00 00       	jmp    80d413 <tcp_input+0x291>
    pbuf_free(p);
  80d368:	83 ec 0c             	sub    $0xc,%esp
  80d36b:	56                   	push   %esi
  80d36c:	e8 93 75 ff ff       	call   804904 <pbuf_free>
    return;
  80d371:	83 c4 10             	add    $0x10,%esp
  80d374:	e9 74 fe ff ff       	jmp    80d1ed <tcp_input+0x6b>
    pbuf_free(p);
  80d379:	83 ec 0c             	sub    $0xc,%esp
  80d37c:	56                   	push   %esi
  80d37d:	e8 82 75 ff ff       	call   804904 <pbuf_free>
    return;
  80d382:	83 c4 10             	add    $0x10,%esp
  80d385:	e9 63 fe ff ff       	jmp    80d1ed <tcp_input+0x6b>
    pbuf_free(p);
  80d38a:	83 ec 0c             	sub    $0xc,%esp
  80d38d:	56                   	push   %esi
  80d38e:	e8 71 75 ff ff       	call   804904 <pbuf_free>
    return;
  80d393:	83 c4 10             	add    $0x10,%esp
  80d396:	e9 52 fe ff ff       	jmp    80d1ed <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d39b:	83 ec 04             	sub    $0x4,%esp
  80d39e:	68 6c 36 81 00       	push   $0x81366c
  80d3a3:	68 b5 00 00 00       	push   $0xb5
  80d3a8:	68 90 37 81 00       	push   $0x813790
  80d3ad:	e8 bd 13 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d3b2:	83 ec 04             	sub    $0x4,%esp
  80d3b5:	68 94 36 81 00       	push   $0x813694
  80d3ba:	68 b6 00 00 00       	push   $0xb6
  80d3bf:	68 90 37 81 00       	push   $0x813790
  80d3c4:	e8 a6 13 00 00       	call   80e76f <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d3c9:	83 ec 04             	sub    $0x4,%esp
  80d3cc:	68 c0 36 81 00       	push   $0x8136c0
  80d3d1:	68 b7 00 00 00       	push   $0xb7
  80d3d6:	68 90 37 81 00       	push   $0x813790
  80d3db:	e8 8f 13 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d3e0:	83 ec 04             	sub    $0x4,%esp
  80d3e3:	68 e8 36 81 00       	push   $0x8136e8
  80d3e8:	68 c0 00 00 00       	push   $0xc0
  80d3ed:	68 90 37 81 00       	push   $0x813790
  80d3f2:	e8 78 13 00 00       	call   80e76f <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d3f7:	83 ec 04             	sub    $0x4,%esp
  80d3fa:	68 14 37 81 00       	push   $0x813714
  80d3ff:	68 c6 00 00 00       	push   $0xc6
  80d404:	68 90 37 81 00       	push   $0x813790
  80d409:	e8 61 13 00 00       	call   80e76f <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d40e:	89 df                	mov    %ebx,%edi
  80d410:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d413:	85 db                	test   %ebx,%ebx
  80d415:	0f 84 b3 0a 00 00    	je     80dece <tcp_input+0xd4c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d41b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d41e:	85 c0                	test   %eax,%eax
  80d420:	0f 84 75 ff ff ff    	je     80d39b <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d426:	83 f8 0a             	cmp    $0xa,%eax
  80d429:	74 87                	je     80d3b2 <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d42b:	83 f8 01             	cmp    $0x1,%eax
  80d42e:	74 99                	je     80d3c9 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d430:	0f b7 02             	movzwl (%edx),%eax
  80d433:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d437:	75 d5                	jne    80d40e <tcp_input+0x28c>
  80d439:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d43d:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d441:	75 cb                	jne    80d40e <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d443:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d446:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d449:	75 c3                	jne    80d40e <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d44b:	8b 41 10             	mov    0x10(%ecx),%eax
  80d44e:	39 03                	cmp    %eax,(%ebx)
  80d450:	75 bc                	jne    80d40e <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d452:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d455:	39 c3                	cmp    %eax,%ebx
  80d457:	74 87                	je     80d3e0 <tcp_input+0x25e>
      if (prev != NULL) {
  80d459:	85 ff                	test   %edi,%edi
  80d45b:	74 13                	je     80d470 <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d45d:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d460:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d463:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d466:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d46c:	39 c3                	cmp    %eax,%ebx
  80d46e:	74 87                	je     80d3f7 <tcp_input+0x275>
    inseg.next = NULL;
  80d470:	c7 05 b4 c1 b3 00 00 	movl   $0x0,0xb3c1b4
  80d477:	00 00 00 
    inseg.len = p->tot_len;
  80d47a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d47e:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
    inseg.dataptr = p->payload;
  80d484:	8b 46 04             	mov    0x4(%esi),%eax
  80d487:	a3 bc c1 b3 00       	mov    %eax,0xb3c1bc
    inseg.p = p;
  80d48c:	89 35 b8 c1 b3 00    	mov    %esi,0xb3c1b8
    inseg.tcphdr = tcphdr;
  80d492:	89 15 c4 c1 b3 00    	mov    %edx,0xb3c1c4
    recv_data = NULL;
  80d498:	c7 05 98 c1 b3 00 00 	movl   $0x0,0xb3c198
  80d49f:	00 00 00 
    recv_flags = 0;
  80d4a2:	c6 05 9c c1 b3 00 00 	movb   $0x0,0xb3c19c
    if (pcb->refused_data != NULL) {
  80d4a9:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d4af:	85 c0                	test   %eax,%eax
  80d4b1:	74 2c                	je     80d4df <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d4b3:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d4b9:	85 d2                	test   %edx,%edx
  80d4bb:	0f 84 07 03 00 00    	je     80d7c8 <tcp_input+0x646>
  80d4c1:	6a 00                	push   $0x0
  80d4c3:	50                   	push   %eax
  80d4c4:	53                   	push   %ebx
  80d4c5:	ff 73 18             	pushl  0x18(%ebx)
  80d4c8:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d4ca:	83 c4 10             	add    $0x10,%esp
  80d4cd:	84 c0                	test   %al,%al
  80d4cf:	0f 85 04 03 00 00    	jne    80d7d9 <tcp_input+0x657>
        pcb->refused_data = NULL;
  80d4d5:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d4dc:	00 00 00 
    tcp_input_pcb = pcb;
  80d4df:	89 1d 58 c2 b3 00    	mov    %ebx,0xb3c258
  if (flags & TCP_RST) {
  80d4e5:	0f b6 05 a0 c1 b3 00 	movzbl 0xb3c1a0,%eax
  80d4ec:	a8 04                	test   $0x4,%al
  80d4ee:	0f 84 20 03 00 00    	je     80d814 <tcp_input+0x692>
    if (pcb->state == SYN_SENT) {
  80d4f4:	8b 53 10             	mov    0x10(%ebx),%edx
  80d4f7:	83 fa 02             	cmp    $0x2,%edx
  80d4fa:	0f 84 ea 02 00 00    	je     80d7ea <tcp_input+0x668>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d500:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d505:	2b 43 24             	sub    0x24(%ebx),%eax
  80d508:	78 1d                	js     80d527 <tcp_input+0x3a5>
  80d50a:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d50e:	29 c8                	sub    %ecx,%eax
  80d510:	85 c0                	test   %eax,%eax
  80d512:	7f 13                	jg     80d527 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d514:	85 d2                	test   %edx,%edx
  80d516:	0f 84 e1 02 00 00    	je     80d7fd <tcp_input+0x67b>
      recv_flags = TF_RESET;
  80d51c:	c6 05 9c c1 b3 00 08 	movb   $0x8,0xb3c19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d523:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d527:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80d52e:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d531:	0f b6 05 9c c1 b3 00 	movzbl 0xb3c19c,%eax
  80d538:	a8 08                	test   $0x8,%al
  80d53a:	0f 84 37 08 00 00    	je     80dd77 <tcp_input+0xbf5>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d540:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d546:	85 c0                	test   %eax,%eax
  80d548:	74 0d                	je     80d557 <tcp_input+0x3d5>
  80d54a:	83 ec 08             	sub    $0x8,%esp
  80d54d:	6a fa                	push   $0xfffffffa
  80d54f:	ff 73 18             	pushl  0x18(%ebx)
  80d552:	ff d0                	call   *%eax
  80d554:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d557:	83 ec 08             	sub    $0x8,%esp
  80d55a:	53                   	push   %ebx
  80d55b:	68 3c c2 b3 00       	push   $0xb3c23c
  80d560:	e8 4f 84 ff ff       	call   8059b4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d565:	83 c4 08             	add    $0x8,%esp
  80d568:	53                   	push   %ebx
  80d569:	6a 02                	push   $0x2
  80d56b:	e8 47 70 ff ff       	call   8045b7 <memp_free>
  80d570:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d573:	a1 b8 c1 b3 00       	mov    0xb3c1b8,%eax
  80d578:	85 c0                	test   %eax,%eax
  80d57a:	0f 84 6d fc ff ff    	je     80d1ed <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d580:	83 ec 0c             	sub    $0xc,%esp
  80d583:	50                   	push   %eax
  80d584:	e8 7b 73 ff ff       	call   804904 <pbuf_free>
      inseg.p = NULL;
  80d589:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80d590:	00 00 00 
  80d593:	83 c4 10             	add    $0x10,%esp
  80d596:	e9 52 fc ff ff       	jmp    80d1ed <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d59b:	83 ec 04             	sub    $0x4,%esp
  80d59e:	68 40 37 81 00       	push   $0x813740
  80d5a3:	68 d0 00 00 00       	push   $0xd0
  80d5a8:	68 90 37 81 00       	push   $0x813790
  80d5ad:	e8 bd 11 00 00       	call   80e76f <_panic>
    tcp_ack_now(pcb);
  80d5b2:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d5b6:	83 ec 0c             	sub    $0xc,%esp
  80d5b9:	53                   	push   %ebx
  80d5ba:	e8 80 ab ff ff       	call   80813f <tcp_output>
  80d5bf:	83 c4 10             	add    $0x10,%esp
  80d5c2:	eb 4c                	jmp    80d610 <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d5c4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d5c7:	85 db                	test   %ebx,%ebx
  80d5c9:	74 5e                	je     80d629 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d5cb:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d5cf:	75 ca                	jne    80d59b <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d5d1:	0f b7 02             	movzwl (%edx),%eax
  80d5d4:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d5d8:	75 ea                	jne    80d5c4 <tcp_input+0x442>
  80d5da:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d5de:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d5e2:	75 e0                	jne    80d5c4 <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d5e4:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d5e7:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d5ea:	75 d8                	jne    80d5c4 <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d5ec:	8b 41 10             	mov    0x10(%ecx),%eax
  80d5ef:	39 03                	cmp    %eax,(%ebx)
  80d5f1:	75 d1                	jne    80d5c4 <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d5f3:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d5f7:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d5fd:	89 c2                	mov    %eax,%edx
  80d5ff:	2b 53 24             	sub    0x24(%ebx),%edx
  80d602:	85 d2                	test   %edx,%edx
  80d604:	7e 03                	jle    80d609 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d606:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d609:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d60e:	75 a2                	jne    80d5b2 <tcp_input+0x430>
  return tcp_output(pcb);
  80d610:	83 ec 0c             	sub    $0xc,%esp
  80d613:	53                   	push   %ebx
  80d614:	e8 26 ab ff ff       	call   80813f <tcp_output>
        pbuf_free(p);
  80d619:	89 34 24             	mov    %esi,(%esp)
  80d61c:	e8 e3 72 ff ff       	call   804904 <pbuf_free>
        return;
  80d621:	83 c4 10             	add    $0x10,%esp
  80d624:	e9 c4 fb ff ff       	jmp    80d1ed <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d629:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  80d62e:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d631:	89 c7                	mov    %eax,%edi
  80d633:	eb 0f                	jmp    80d644 <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d635:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d639:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d63d:	74 1a                	je     80d659 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d63f:	89 fb                	mov    %edi,%ebx
  80d641:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d644:	85 ff                	test   %edi,%edi
  80d646:	0f 84 5d 08 00 00    	je     80dea9 <tcp_input+0xd27>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d64c:	8b 07                	mov    (%edi),%eax
  80d64e:	85 c0                	test   %eax,%eax
  80d650:	74 e3                	je     80d635 <tcp_input+0x4b3>
  80d652:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d655:	75 e8                	jne    80d63f <tcp_input+0x4bd>
  80d657:	eb dc                	jmp    80d635 <tcp_input+0x4b3>
        if (prev != NULL) {
  80d659:	85 db                	test   %ebx,%ebx
  80d65b:	74 12                	je     80d66f <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d65d:	8b 47 0c             	mov    0xc(%edi),%eax
  80d660:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d663:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d666:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d669:	89 3d 44 c2 b3 00    	mov    %edi,0xb3c244
  if (flags & TCP_ACK) {
  80d66f:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d673:	75 17                	jne    80d68c <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d675:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d679:	75 43                	jne    80d6be <tcp_input+0x53c>
        pbuf_free(p);
  80d67b:	83 ec 0c             	sub    $0xc,%esp
  80d67e:	56                   	push   %esi
  80d67f:	e8 80 72 ff ff       	call   804904 <pbuf_free>
        return;
  80d684:	83 c4 10             	add    $0x10,%esp
  80d687:	e9 61 fb ff ff       	jmp    80d1ed <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d68c:	83 ec 08             	sub    $0x8,%esp
  80d68f:	0f b7 02             	movzwl (%edx),%eax
  80d692:	50                   	push   %eax
  80d693:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d697:	50                   	push   %eax
  80d698:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d69b:	50                   	push   %eax
  80d69c:	83 c1 10             	add    $0x10,%ecx
  80d69f:	51                   	push   %ecx
  80d6a0:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d6a4:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d6aa:	50                   	push   %eax
  80d6ab:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80d6b0:	83 c0 01             	add    $0x1,%eax
  80d6b3:	50                   	push   %eax
  80d6b4:	e8 26 af ff ff       	call   8085df <tcp_rst>
  80d6b9:	83 c4 20             	add    $0x20,%esp
  80d6bc:	eb bd                	jmp    80d67b <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d6be:	83 ec 0c             	sub    $0xc,%esp
  80d6c1:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d6c5:	50                   	push   %eax
  80d6c6:	e8 47 8b ff ff       	call   806212 <tcp_alloc>
  80d6cb:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d6cd:	83 c4 10             	add    $0x10,%esp
  80d6d0:	85 c0                	test   %eax,%eax
  80d6d2:	74 a7                	je     80d67b <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d6d4:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d6d9:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d6dc:	0f 84 c5 00 00 00    	je     80d7a7 <tcp_input+0x625>
  80d6e2:	8b 50 10             	mov    0x10(%eax),%edx
  80d6e5:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d6e7:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d6eb:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d6ef:	8b 50 0c             	mov    0xc(%eax),%edx
  80d6f2:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d6f5:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
  80d6fb:	0f b7 02             	movzwl (%edx),%eax
  80d6fe:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d702:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d709:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d70e:	8d 48 01             	lea    0x1(%eax),%ecx
  80d711:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d714:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d718:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d71c:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d720:	83 e8 01             	sub    $0x1,%eax
  80d723:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d726:	8b 47 18             	mov    0x18(%edi),%eax
  80d729:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d72c:	8b 47 20             	mov    0x20(%edi),%eax
  80d72f:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d735:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d739:	66 25 99 01          	and    $0x199,%ax
  80d73d:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d741:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80d746:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d749:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
  80d74f:	e8 86 4b ff ff       	call   8022da <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d754:	89 d8                	mov    %ebx,%eax
  80d756:	e8 98 ec ff ff       	call   80c3f3 <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d75b:	83 ec 08             	sub    $0x8,%esp
  80d75e:	8d 43 04             	lea    0x4(%ebx),%eax
  80d761:	50                   	push   %eax
  80d762:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d766:	50                   	push   %eax
  80d767:	e8 44 8c ff ff       	call   8063b0 <tcp_eff_send_mss>
  80d76c:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d770:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d777:	e8 7c a0 ff ff       	call   8077f8 <htonl>
  80d77c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d77f:	83 c4 0c             	add    $0xc,%esp
  80d782:	6a 04                	push   $0x4
  80d784:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d787:	50                   	push   %eax
  80d788:	6a 00                	push   $0x0
  80d78a:	6a 12                	push   $0x12
  80d78c:	6a 00                	push   $0x0
  80d78e:	6a 00                	push   $0x0
  80d790:	53                   	push   %ebx
  80d791:	e8 8c a2 ff ff       	call   807a22 <tcp_enqueue>
    return tcp_output(npcb);
  80d796:	83 c4 14             	add    $0x14,%esp
  80d799:	53                   	push   %ebx
  80d79a:	e8 a0 a9 ff ff       	call   80813f <tcp_output>
  80d79f:	83 c4 10             	add    $0x10,%esp
  80d7a2:	e9 d4 fe ff ff       	jmp    80d67b <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d7a7:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    npcb->local_port = pcb->local_port;
  80d7ad:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d7b1:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d7b5:	ba 00 00 00 00       	mov    $0x0,%edx
  80d7ba:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d7bd:	0f 84 2f ff ff ff    	je     80d6f2 <tcp_input+0x570>
  80d7c3:	e9 27 ff ff ff       	jmp    80d6ef <tcp_input+0x56d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d7c8:	83 ec 0c             	sub    $0xc,%esp
  80d7cb:	50                   	push   %eax
  80d7cc:	e8 33 71 ff ff       	call   804904 <pbuf_free>
  80d7d1:	83 c4 10             	add    $0x10,%esp
  80d7d4:	e9 fc fc ff ff       	jmp    80d4d5 <tcp_input+0x353>
        pbuf_free(p);
  80d7d9:	83 ec 0c             	sub    $0xc,%esp
  80d7dc:	56                   	push   %esi
  80d7dd:	e8 22 71 ff ff       	call   804904 <pbuf_free>
        return;
  80d7e2:	83 c4 10             	add    $0x10,%esp
  80d7e5:	e9 03 fa ff ff       	jmp    80d1ed <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d7ea:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80d7ef:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d7f2:	0f 84 24 fd ff ff    	je     80d51c <tcp_input+0x39a>
  80d7f8:	e9 2a fd ff ff       	jmp    80d527 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d7fd:	83 ec 04             	sub    $0x4,%esp
  80d800:	68 70 37 81 00       	push   $0x813770
  80d805:	68 09 02 00 00       	push   $0x209
  80d80a:	68 90 37 81 00       	push   $0x813790
  80d80f:	e8 5b 0f 00 00       	call   80e76f <_panic>
  pcb->tmr = tcp_ticks;
  80d814:	8b 15 40 c2 b3 00    	mov    0xb3c240,%edx
  80d81a:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d81d:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d824:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d828:	0f 87 3a 05 00 00    	ja     80dd68 <tcp_input+0xbe6>
  80d82e:	8b 53 10             	mov    0x10(%ebx),%edx
  80d831:	ff 24 95 14 38 81 00 	jmp    *0x813814(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d838:	83 e0 12             	and    $0x12,%eax
  80d83b:	3c 12                	cmp    $0x12,%al
  80d83d:	74 4d                	je     80d88c <tcp_input+0x70a>
    else if (flags & TCP_ACK) {
  80d83f:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80d846:	0f 84 db fc ff ff    	je     80d527 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d84c:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d852:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d857:	83 ec 08             	sub    $0x8,%esp
  80d85a:	0f b7 0a             	movzwl (%edx),%ecx
  80d85d:	51                   	push   %ecx
  80d85e:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d862:	52                   	push   %edx
  80d863:	8d 50 0c             	lea    0xc(%eax),%edx
  80d866:	52                   	push   %edx
  80d867:	83 c0 10             	add    $0x10,%eax
  80d86a:	50                   	push   %eax
  80d86b:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80d872:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d878:	50                   	push   %eax
  80d879:	ff 35 a4 c1 b3 00    	pushl  0xb3c1a4
  80d87f:	e8 5b ad ff ff       	call   8085df <tcp_rst>
  80d884:	83 c4 20             	add    $0x20,%esp
  80d887:	e9 9b fc ff ff       	jmp    80d527 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d88c:	83 ec 0c             	sub    $0xc,%esp
  80d88f:	8b 43 78             	mov    0x78(%ebx),%eax
  80d892:	8b 40 10             	mov    0x10(%eax),%eax
  80d895:	ff 70 04             	pushl  0x4(%eax)
  80d898:	e8 72 a1 ff ff       	call   807a0f <ntohl>
  80d89d:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80d8a3:	83 c0 01             	add    $0x1,%eax
  80d8a6:	83 c4 10             	add    $0x10,%esp
  80d8a9:	39 d0                	cmp    %edx,%eax
  80d8ab:	75 92                	jne    80d83f <tcp_input+0x6bd>
      pcb->snd_buf++;
  80d8ad:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d8b2:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d8b7:	8d 48 01             	lea    0x1(%eax),%ecx
  80d8ba:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d8bd:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d8c0:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
  80d8c6:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d8ca:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d8ce:	83 e8 01             	sub    $0x1,%eax
  80d8d1:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d8d4:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d8db:	89 d8                	mov    %ebx,%eax
  80d8dd:	e8 11 eb ff ff       	call   80c3f3 <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d8e2:	83 ec 08             	sub    $0x8,%esp
  80d8e5:	8d 43 04             	lea    0x4(%ebx),%eax
  80d8e8:	50                   	push   %eax
  80d8e9:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d8ed:	50                   	push   %eax
  80d8ee:	e8 bd 8a ff ff       	call   8063b0 <tcp_eff_send_mss>
  80d8f3:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d8f7:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d8fa:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d8fe:	83 c4 10             	add    $0x10,%esp
  80d901:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d906:	74 63                	je     80d96b <tcp_input+0x7e9>
  80d908:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d90c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d910:	66 85 c0             	test   %ax,%ax
  80d913:	74 5a                	je     80d96f <tcp_input+0x7ed>
      --pcb->snd_queuelen;
  80d915:	83 e8 01             	sub    $0x1,%eax
  80d918:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d91c:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d91f:	8b 10                	mov    (%eax),%edx
  80d921:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d924:	85 d2                	test   %edx,%edx
  80d926:	74 5e                	je     80d986 <tcp_input+0x804>
        pcb->rtime = 0;
  80d928:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d92e:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d932:	83 ec 0c             	sub    $0xc,%esp
  80d935:	50                   	push   %eax
  80d936:	e8 e3 7e ff ff       	call   80581e <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d93b:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d941:	83 c4 10             	add    $0x10,%esp
  80d944:	85 c0                	test   %eax,%eax
  80d946:	74 0e                	je     80d956 <tcp_input+0x7d4>
  80d948:	83 ec 04             	sub    $0x4,%esp
  80d94b:	6a 00                	push   $0x0
  80d94d:	53                   	push   %ebx
  80d94e:	ff 73 18             	pushl  0x18(%ebx)
  80d951:	ff d0                	call   *%eax
  80d953:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d956:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d95a:	83 ec 0c             	sub    $0xc,%esp
  80d95d:	53                   	push   %ebx
  80d95e:	e8 dc a7 ff ff       	call   80813f <tcp_output>
  80d963:	83 c4 10             	add    $0x10,%esp
  80d966:	e9 bc fb ff ff       	jmp    80d527 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d96b:	01 c0                	add    %eax,%eax
  80d96d:	eb 99                	jmp    80d908 <tcp_input+0x786>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d96f:	83 ec 04             	sub    $0x4,%esp
  80d972:	68 e9 37 81 00       	push   $0x8137e9
  80d977:	68 35 02 00 00       	push   $0x235
  80d97c:	68 90 37 81 00       	push   $0x813790
  80d981:	e8 e9 0d 00 00       	call   80e76f <_panic>
        pcb->rtime = -1;
  80d986:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d98c:	eb a4                	jmp    80d932 <tcp_input+0x7b0>
    if (flags & TCP_ACK &&
  80d98e:	83 e0 14             	and    $0x14,%eax
  80d991:	3c 10                	cmp    $0x10,%al
  80d993:	0f 85 8e fb ff ff    	jne    80d527 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d999:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80d99f:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d9a2:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d9a5:	78 09                	js     80d9b0 <tcp_input+0x82e>
  80d9a7:	89 d0                	mov    %edx,%eax
  80d9a9:	2b 43 54             	sub    0x54(%ebx),%eax
  80d9ac:	85 c0                	test   %eax,%eax
  80d9ae:	7e 3b                	jle    80d9eb <tcp_input+0x869>
                tcphdr->dest, tcphdr->src);
  80d9b0:	8b 0d b0 c1 b3 00    	mov    0xb3c1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d9b6:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d9bb:	83 ec 08             	sub    $0x8,%esp
  80d9be:	0f b7 31             	movzwl (%ecx),%esi
  80d9c1:	56                   	push   %esi
  80d9c2:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d9c6:	51                   	push   %ecx
  80d9c7:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d9ca:	51                   	push   %ecx
  80d9cb:	83 c0 10             	add    $0x10,%eax
  80d9ce:	50                   	push   %eax
  80d9cf:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80d9d6:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d9dc:	50                   	push   %eax
  80d9dd:	52                   	push   %edx
  80d9de:	e8 fc ab ff ff       	call   8085df <tcp_rst>
  80d9e3:	83 c4 20             	add    $0x20,%esp
  80d9e6:	e9 3c fb ff ff       	jmp    80d527 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80d9eb:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d9f2:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d9f8:	85 c0                	test   %eax,%eax
  80d9fa:	74 5c                	je     80da58 <tcp_input+0x8d6>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d9fc:	83 ec 04             	sub    $0x4,%esp
  80d9ff:	6a 00                	push   $0x0
  80da01:	53                   	push   %ebx
  80da02:	ff 73 18             	pushl  0x18(%ebx)
  80da05:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80da07:	83 c4 10             	add    $0x10,%esp
  80da0a:	84 c0                	test   %al,%al
  80da0c:	75 61                	jne    80da6f <tcp_input+0x8ed>
        old_cwnd = pcb->cwnd;
  80da0e:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80da12:	89 d8                	mov    %ebx,%eax
  80da14:	e8 8e ea ff ff       	call   80c4a7 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80da19:	66 83 fe 01          	cmp    $0x1,%si
  80da1d:	74 6b                	je     80da8a <tcp_input+0x908>
  80da1f:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80da23:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80da27:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80da2e:	0f 84 f3 fa ff ff    	je     80d527 <tcp_input+0x3a5>
  80da34:	84 c0                	test   %al,%al
  80da36:	0f 84 eb fa ff ff    	je     80d527 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80da3c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da40:	83 ec 0c             	sub    $0xc,%esp
  80da43:	53                   	push   %ebx
  80da44:	e8 f6 a6 ff ff       	call   80813f <tcp_output>
          pcb->state = CLOSE_WAIT;
  80da49:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80da50:	83 c4 10             	add    $0x10,%esp
  80da53:	e9 cf fa ff ff       	jmp    80d527 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80da58:	83 ec 04             	sub    $0x4,%esp
  80da5b:	68 ff 37 81 00       	push   $0x8137ff
  80da60:	68 5b 02 00 00       	push   $0x25b
  80da65:	68 90 37 81 00       	push   $0x813790
  80da6a:	e8 00 0d 00 00       	call   80e76f <_panic>
          tcp_abort(pcb);
  80da6f:	83 ec 0c             	sub    $0xc,%esp
  80da72:	53                   	push   %ebx
  80da73:	e8 f2 81 ff ff       	call   805c6a <tcp_abort>
    tcp_input_pcb = NULL;
  80da78:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80da7f:	00 00 00 
  80da82:	83 c4 10             	add    $0x10,%esp
  80da85:	e9 e9 fa ff ff       	jmp    80d573 <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80da8a:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80da8e:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80da91:	eb 90                	jmp    80da23 <tcp_input+0x8a1>
    accepted_inseq = tcp_receive(pcb);
  80da93:	89 d8                	mov    %ebx,%eax
  80da95:	e8 0d ea ff ff       	call   80c4a7 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80da9a:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80daa1:	0f 84 80 fa ff ff    	je     80d527 <tcp_input+0x3a5>
  80daa7:	84 c0                	test   %al,%al
  80daa9:	0f 84 78 fa ff ff    	je     80d527 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80daaf:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dab3:	83 ec 0c             	sub    $0xc,%esp
  80dab6:	53                   	push   %ebx
  80dab7:	e8 83 a6 ff ff       	call   80813f <tcp_output>
      pcb->state = CLOSE_WAIT;
  80dabc:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80dac3:	83 c4 10             	add    $0x10,%esp
  80dac6:	e9 5c fa ff ff       	jmp    80d527 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80dacb:	89 d8                	mov    %ebx,%eax
  80dacd:	e8 d5 e9 ff ff       	call   80c4a7 <tcp_receive>
    if (flags & TCP_FIN) {
  80dad2:	0f b6 05 a0 c1 b3 00 	movzbl 0xb3c1a0,%eax
  80dad9:	a8 01                	test   $0x1,%al
  80dadb:	0f 84 c7 00 00 00    	je     80dba8 <tcp_input+0xa26>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dae1:	a8 10                	test   $0x10,%al
  80dae3:	74 0a                	je     80daef <tcp_input+0x96d>
  80dae5:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80daea:	39 43 54             	cmp    %eax,0x54(%ebx)
  80daed:	74 1c                	je     80db0b <tcp_input+0x989>
        tcp_ack_now(pcb);
  80daef:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80daf3:	83 ec 0c             	sub    $0xc,%esp
  80daf6:	53                   	push   %ebx
  80daf7:	e8 43 a6 ff ff       	call   80813f <tcp_output>
        pcb->state = CLOSING;
  80dafc:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80db03:	83 c4 10             	add    $0x10,%esp
  80db06:	e9 1c fa ff ff       	jmp    80d527 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80db0b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db0f:	83 ec 0c             	sub    $0xc,%esp
  80db12:	53                   	push   %ebx
  80db13:	e8 27 a6 ff ff       	call   80813f <tcp_output>
        tcp_pcb_purge(pcb);
  80db18:	89 1c 24             	mov    %ebx,(%esp)
  80db1b:	e8 17 7e ff ff       	call   805937 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80db20:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80db25:	83 c4 10             	add    $0x10,%esp
  80db28:	39 c3                	cmp    %eax,%ebx
  80db2a:	74 2c                	je     80db58 <tcp_input+0x9d6>
  80db2c:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80db31:	ba 00 00 00 00       	mov    $0x0,%edx
  80db36:	89 de                	mov    %ebx,%esi
  80db38:	89 d7                	mov    %edx,%edi
  80db3a:	85 c0                	test   %eax,%eax
  80db3c:	74 56                	je     80db94 <tcp_input+0xa12>
  80db3e:	8b 48 0c             	mov    0xc(%eax),%ecx
  80db41:	39 ce                	cmp    %ecx,%esi
  80db43:	0f 94 c3             	sete   %bl
  80db46:	85 c9                	test   %ecx,%ecx
  80db48:	0f 95 c2             	setne  %dl
  80db4b:	84 d3                	test   %dl,%bl
  80db4d:	75 30                	jne    80db7f <tcp_input+0x9fd>
  80db4f:	bf 01 00 00 00       	mov    $0x1,%edi
  80db54:	89 c8                	mov    %ecx,%eax
  80db56:	eb e2                	jmp    80db3a <tcp_input+0x9b8>
  80db58:	8b 40 0c             	mov    0xc(%eax),%eax
  80db5b:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
        pcb->state = TIME_WAIT;
  80db60:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80db67:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80db6c:	89 43 0c             	mov    %eax,0xc(%ebx)
  80db6f:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80db75:	e8 60 47 ff ff       	call   8022da <tcp_timer_needed>
  80db7a:	e9 a8 f9 ff ff       	jmp    80d527 <tcp_input+0x3a5>
  80db7f:	89 f3                	mov    %esi,%ebx
  80db81:	89 fa                	mov    %edi,%edx
  80db83:	84 d2                	test   %dl,%dl
  80db85:	74 05                	je     80db8c <tcp_input+0xa0a>
  80db87:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
        TCP_RMV(&tcp_active_pcbs, pcb);
  80db8c:	8b 53 0c             	mov    0xc(%ebx),%edx
  80db8f:	89 50 0c             	mov    %edx,0xc(%eax)
  80db92:	eb cc                	jmp    80db60 <tcp_input+0x9de>
  80db94:	89 f3                	mov    %esi,%ebx
  80db96:	89 fa                	mov    %edi,%edx
  80db98:	84 d2                	test   %dl,%dl
  80db9a:	74 c4                	je     80db60 <tcp_input+0x9de>
  80db9c:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80dba3:	00 00 00 
  80dba6:	eb b8                	jmp    80db60 <tcp_input+0x9de>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dba8:	a8 10                	test   $0x10,%al
  80dbaa:	0f 84 77 f9 ff ff    	je     80d527 <tcp_input+0x3a5>
  80dbb0:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dbb5:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dbb8:	0f 85 69 f9 ff ff    	jne    80d527 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80dbbe:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80dbc5:	e9 5d f9 ff ff       	jmp    80d527 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80dbca:	89 d8                	mov    %ebx,%eax
  80dbcc:	e8 d6 e8 ff ff       	call   80c4a7 <tcp_receive>
    if (flags & TCP_FIN) {
  80dbd1:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80dbd8:	0f 84 49 f9 ff ff    	je     80d527 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dbde:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dbe2:	83 ec 0c             	sub    $0xc,%esp
  80dbe5:	53                   	push   %ebx
  80dbe6:	e8 54 a5 ff ff       	call   80813f <tcp_output>
      tcp_pcb_purge(pcb);
  80dbeb:	89 1c 24             	mov    %ebx,(%esp)
  80dbee:	e8 44 7d ff ff       	call   805937 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dbf3:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80dbf8:	83 c4 10             	add    $0x10,%esp
  80dbfb:	39 c3                	cmp    %eax,%ebx
  80dbfd:	74 2c                	je     80dc2b <tcp_input+0xaa9>
  80dbff:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80dc04:	b9 00 00 00 00       	mov    $0x0,%ecx
  80dc09:	89 de                	mov    %ebx,%esi
  80dc0b:	89 cf                	mov    %ecx,%edi
  80dc0d:	85 c0                	test   %eax,%eax
  80dc0f:	74 56                	je     80dc67 <tcp_input+0xae5>
  80dc11:	8b 50 0c             	mov    0xc(%eax),%edx
  80dc14:	85 d2                	test   %edx,%edx
  80dc16:	0f 95 c3             	setne  %bl
  80dc19:	39 d6                	cmp    %edx,%esi
  80dc1b:	0f 94 c1             	sete   %cl
  80dc1e:	84 cb                	test   %cl,%bl
  80dc20:	75 30                	jne    80dc52 <tcp_input+0xad0>
  80dc22:	bf 01 00 00 00       	mov    $0x1,%edi
  80dc27:	89 d0                	mov    %edx,%eax
  80dc29:	eb e2                	jmp    80dc0d <tcp_input+0xa8b>
  80dc2b:	8b 40 0c             	mov    0xc(%eax),%eax
  80dc2e:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
      pcb->state = TIME_WAIT;
  80dc33:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dc3a:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80dc3f:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dc42:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80dc48:	e8 8d 46 ff ff       	call   8022da <tcp_timer_needed>
  80dc4d:	e9 d5 f8 ff ff       	jmp    80d527 <tcp_input+0x3a5>
  80dc52:	89 f3                	mov    %esi,%ebx
  80dc54:	89 f9                	mov    %edi,%ecx
  80dc56:	84 c9                	test   %cl,%cl
  80dc58:	74 05                	je     80dc5f <tcp_input+0xadd>
  80dc5a:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dc5f:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dc62:	89 50 0c             	mov    %edx,0xc(%eax)
  80dc65:	eb cc                	jmp    80dc33 <tcp_input+0xab1>
  80dc67:	89 f3                	mov    %esi,%ebx
  80dc69:	89 f9                	mov    %edi,%ecx
  80dc6b:	84 c9                	test   %cl,%cl
  80dc6d:	74 c4                	je     80dc33 <tcp_input+0xab1>
  80dc6f:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80dc76:	00 00 00 
  80dc79:	eb b8                	jmp    80dc33 <tcp_input+0xab1>
    tcp_receive(pcb);
  80dc7b:	89 d8                	mov    %ebx,%eax
  80dc7d:	e8 25 e8 ff ff       	call   80c4a7 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dc82:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80dc89:	0f 84 98 f8 ff ff    	je     80d527 <tcp_input+0x3a5>
  80dc8f:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dc94:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dc97:	0f 85 8a f8 ff ff    	jne    80d527 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dc9d:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dca1:	83 ec 0c             	sub    $0xc,%esp
  80dca4:	53                   	push   %ebx
  80dca5:	e8 95 a4 ff ff       	call   80813f <tcp_output>
      tcp_pcb_purge(pcb);
  80dcaa:	89 1c 24             	mov    %ebx,(%esp)
  80dcad:	e8 85 7c ff ff       	call   805937 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dcb2:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80dcb7:	83 c4 10             	add    $0x10,%esp
  80dcba:	39 c3                	cmp    %eax,%ebx
  80dcbc:	74 2c                	je     80dcea <tcp_input+0xb68>
  80dcbe:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80dcc3:	ba 00 00 00 00       	mov    $0x0,%edx
  80dcc8:	89 de                	mov    %ebx,%esi
  80dcca:	89 d7                	mov    %edx,%edi
  80dccc:	85 c0                	test   %eax,%eax
  80dcce:	74 56                	je     80dd26 <tcp_input+0xba4>
  80dcd0:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dcd3:	85 c9                	test   %ecx,%ecx
  80dcd5:	0f 95 c3             	setne  %bl
  80dcd8:	39 ce                	cmp    %ecx,%esi
  80dcda:	0f 94 c2             	sete   %dl
  80dcdd:	84 d3                	test   %dl,%bl
  80dcdf:	75 30                	jne    80dd11 <tcp_input+0xb8f>
  80dce1:	bf 01 00 00 00       	mov    $0x1,%edi
  80dce6:	89 c8                	mov    %ecx,%eax
  80dce8:	eb e2                	jmp    80dccc <tcp_input+0xb4a>
  80dcea:	8b 40 0c             	mov    0xc(%eax),%eax
  80dced:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
      pcb->state = TIME_WAIT;
  80dcf2:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dcf9:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80dcfe:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dd01:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80dd07:	e8 ce 45 ff ff       	call   8022da <tcp_timer_needed>
  80dd0c:	e9 16 f8 ff ff       	jmp    80d527 <tcp_input+0x3a5>
  80dd11:	89 f3                	mov    %esi,%ebx
  80dd13:	89 fa                	mov    %edi,%edx
  80dd15:	84 d2                	test   %dl,%dl
  80dd17:	74 05                	je     80dd1e <tcp_input+0xb9c>
  80dd19:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dd1e:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dd21:	89 50 0c             	mov    %edx,0xc(%eax)
  80dd24:	eb cc                	jmp    80dcf2 <tcp_input+0xb70>
  80dd26:	89 f3                	mov    %esi,%ebx
  80dd28:	89 fa                	mov    %edi,%edx
  80dd2a:	84 d2                	test   %dl,%dl
  80dd2c:	74 c4                	je     80dcf2 <tcp_input+0xb70>
  80dd2e:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80dd35:	00 00 00 
  80dd38:	eb b8                	jmp    80dcf2 <tcp_input+0xb70>
    tcp_receive(pcb);
  80dd3a:	89 d8                	mov    %ebx,%eax
  80dd3c:	e8 66 e7 ff ff       	call   80c4a7 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dd41:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80dd48:	0f 84 d9 f7 ff ff    	je     80d527 <tcp_input+0x3a5>
  80dd4e:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dd53:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dd56:	0f 85 cb f7 ff ff    	jne    80d527 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80dd5c:	c6 05 9c c1 b3 00 10 	movb   $0x10,0xb3c19c
  80dd63:	e9 bf f7 ff ff       	jmp    80d527 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80dd68:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80dd6f:	00 00 00 
  80dd72:	e9 ba f7 ff ff       	jmp    80d531 <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80dd77:	a8 10                	test   $0x10,%al
  80dd79:	0f 85 96 00 00 00    	jne    80de15 <tcp_input+0xc93>
        if (pcb->acked > 0) {
  80dd7f:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dd83:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dd88:	66 85 d2             	test   %dx,%dx
  80dd8b:	74 1a                	je     80dda7 <tcp_input+0xc25>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dd8d:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dd93:	85 c9                	test   %ecx,%ecx
  80dd95:	74 10                	je     80dda7 <tcp_input+0xc25>
  80dd97:	83 ec 04             	sub    $0x4,%esp
  80dd9a:	0f b7 d2             	movzwl %dx,%edx
  80dd9d:	52                   	push   %edx
  80dd9e:	53                   	push   %ebx
  80dd9f:	ff 73 18             	pushl  0x18(%ebx)
  80dda2:	ff d1                	call   *%ecx
  80dda4:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dda7:	8b 15 98 c1 b3 00    	mov    0xb3c198,%edx
  80ddad:	85 d2                	test   %edx,%edx
  80ddaf:	0f 84 a9 00 00 00    	je     80de5e <tcp_input+0xcdc>
          if(flags & TCP_PSH) {
  80ddb5:	f6 05 a0 c1 b3 00 08 	testb  $0x8,0xb3c1a0
  80ddbc:	74 04                	je     80ddc2 <tcp_input+0xc40>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80ddbe:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80ddc2:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80ddc8:	85 c0                	test   %eax,%eax
  80ddca:	74 6a                	je     80de36 <tcp_input+0xcb4>
  80ddcc:	6a 00                	push   $0x0
  80ddce:	52                   	push   %edx
  80ddcf:	53                   	push   %ebx
  80ddd0:	ff 73 18             	pushl  0x18(%ebx)
  80ddd3:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80ddd5:	83 c4 10             	add    $0x10,%esp
  80ddd8:	84 c0                	test   %al,%al
  80ddda:	75 68                	jne    80de44 <tcp_input+0xcc2>
        if (recv_flags & TF_GOT_FIN) {
  80dddc:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80dde3:	74 1f                	je     80de04 <tcp_input+0xc82>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dde5:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80ddeb:	85 c0                	test   %eax,%eax
  80dded:	74 15                	je     80de04 <tcp_input+0xc82>
  80ddef:	6a 00                	push   $0x0
  80ddf1:	6a 00                	push   $0x0
  80ddf3:	53                   	push   %ebx
  80ddf4:	ff 73 18             	pushl  0x18(%ebx)
  80ddf7:	ff d0                	call   *%eax
  80ddf9:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80ddfc:	84 c0                	test   %al,%al
  80ddfe:	0f 85 6f f7 ff ff    	jne    80d573 <tcp_input+0x3f1>
          tcp_output(pcb);
  80de04:	83 ec 0c             	sub    $0xc,%esp
  80de07:	53                   	push   %ebx
  80de08:	e8 32 a3 ff ff       	call   80813f <tcp_output>
  80de0d:	83 c4 10             	add    $0x10,%esp
  80de10:	e9 5e f7 ff ff       	jmp    80d573 <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80de15:	83 ec 08             	sub    $0x8,%esp
  80de18:	53                   	push   %ebx
  80de19:	68 3c c2 b3 00       	push   $0xb3c23c
  80de1e:	e8 91 7b ff ff       	call   8059b4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80de23:	83 c4 08             	add    $0x8,%esp
  80de26:	53                   	push   %ebx
  80de27:	6a 02                	push   $0x2
  80de29:	e8 89 67 ff ff       	call   8045b7 <memp_free>
  80de2e:	83 c4 10             	add    $0x10,%esp
  80de31:	e9 3d f7 ff ff       	jmp    80d573 <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80de36:	83 ec 0c             	sub    $0xc,%esp
  80de39:	52                   	push   %edx
  80de3a:	e8 c5 6a ff ff       	call   804904 <pbuf_free>
  80de3f:	83 c4 10             	add    $0x10,%esp
  80de42:	eb 98                	jmp    80dddc <tcp_input+0xc5a>
            pcb->refused_data = recv_data;
  80de44:	a1 98 c1 b3 00       	mov    0xb3c198,%eax
  80de49:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80de4f:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80de56:	0f 84 17 f7 ff ff    	je     80d573 <tcp_input+0x3f1>
  80de5c:	eb 87                	jmp    80dde5 <tcp_input+0xc63>
  80de5e:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80de65:	74 95                	je     80ddfc <tcp_input+0xc7a>
  80de67:	e9 79 ff ff ff       	jmp    80dde5 <tcp_input+0xc63>
        tcphdr->dest, tcphdr->src);
  80de6c:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80de72:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80de77:	83 ec 08             	sub    $0x8,%esp
  80de7a:	0f b7 0a             	movzwl (%edx),%ecx
  80de7d:	51                   	push   %ecx
  80de7e:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80de82:	52                   	push   %edx
  80de83:	8d 50 0c             	lea    0xc(%eax),%edx
  80de86:	52                   	push   %edx
  80de87:	83 c0 10             	add    $0x10,%eax
  80de8a:	50                   	push   %eax
  80de8b:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80de92:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80de98:	50                   	push   %eax
  80de99:	ff 35 a4 c1 b3 00    	pushl  0xb3c1a4
  80de9f:	e8 3b a7 ff ff       	call   8085df <tcp_rst>
  80dea4:	83 c4 20             	add    $0x20,%esp
  80dea7:	eb 14                	jmp    80debd <tcp_input+0xd3b>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dea9:	83 ec 0c             	sub    $0xc,%esp
  80deac:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80deb0:	50                   	push   %eax
  80deb1:	e8 35 99 ff ff       	call   8077eb <ntohs>
  80deb6:	83 c4 10             	add    $0x10,%esp
  80deb9:	a8 04                	test   $0x4,%al
  80debb:	74 af                	je     80de6c <tcp_input+0xcea>
    pbuf_free(p);
  80debd:	83 ec 0c             	sub    $0xc,%esp
  80dec0:	56                   	push   %esi
  80dec1:	e8 3e 6a ff ff       	call   804904 <pbuf_free>
  80dec6:	83 c4 10             	add    $0x10,%esp
  80dec9:	e9 1f f3 ff ff       	jmp    80d1ed <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dece:	8b 1d 50 c2 b3 00    	mov    0xb3c250,%ebx
  80ded4:	e9 ee f6 ff ff       	jmp    80d5c7 <tcp_input+0x445>

0080ded9 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80ded9:	55                   	push   %ebp
  80deda:	89 e5                	mov    %esp,%ebp
  80dedc:	57                   	push   %edi
  80dedd:	56                   	push   %esi
  80dede:	53                   	push   %ebx
  80dedf:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dee2:	8b 45 08             	mov    0x8(%ebp),%eax
  80dee5:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80dee8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80deec:	50                   	push   %eax
  80deed:	e8 f9 98 ff ff       	call   8077eb <ntohs>
  80def2:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80def4:	8b 1d c8 c1 b3 00    	mov    0xb3c1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80defa:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80defd:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80df02:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80df09:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80df0c:	eb 11                	jmp    80df1f <raw_input+0x46>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80df0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80df11:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80df14:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80df19:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80df1c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80df1f:	84 c0                	test   %al,%al
  80df21:	75 55                	jne    80df78 <raw_input+0x9f>
  80df23:	85 db                	test   %ebx,%ebx
  80df25:	74 51                	je     80df78 <raw_input+0x9f>
    if (pcb->protocol == proto) {
  80df27:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80df2b:	b8 00 00 00 00       	mov    $0x0,%eax
  80df30:	39 f2                	cmp    %esi,%edx
  80df32:	75 e5                	jne    80df19 <raw_input+0x40>
      if (pcb->recv != NULL) {
  80df34:	8b 53 14             	mov    0x14(%ebx),%edx
  80df37:	85 d2                	test   %edx,%edx
  80df39:	74 de                	je     80df19 <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80df3b:	8d 47 0c             	lea    0xc(%edi),%eax
  80df3e:	50                   	push   %eax
  80df3f:	ff 75 08             	pushl  0x8(%ebp)
  80df42:	53                   	push   %ebx
  80df43:	ff 73 18             	pushl  0x18(%ebx)
  80df46:	ff d2                	call   *%edx
  80df48:	83 c4 10             	add    $0x10,%esp
  80df4b:	84 c0                	test   %al,%al
  80df4d:	74 ca                	je     80df19 <raw_input+0x40>
          if (prev != NULL) {
  80df4f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80df52:	85 c9                	test   %ecx,%ecx
  80df54:	74 b8                	je     80df0e <raw_input+0x35>
            prev->next = pcb->next;
  80df56:	8b 43 0c             	mov    0xc(%ebx),%eax
  80df59:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80df5c:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80df61:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80df64:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
          eaten = 1;
  80df6a:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80df6f:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80df76:	eb a1                	jmp    80df19 <raw_input+0x40>
  }
  return eaten;
}
  80df78:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80df7b:	5b                   	pop    %ebx
  80df7c:	5e                   	pop    %esi
  80df7d:	5f                   	pop    %edi
  80df7e:	5d                   	pop    %ebp
  80df7f:	c3                   	ret    

0080df80 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80df80:	55                   	push   %ebp
  80df81:	89 e5                	mov    %esp,%ebp
  80df83:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80df86:	b8 00 00 00 00       	mov    $0x0,%eax
  80df8b:	85 d2                	test   %edx,%edx
  80df8d:	74 02                	je     80df91 <raw_bind+0x11>
  80df8f:	8b 02                	mov    (%edx),%eax
  80df91:	8b 55 08             	mov    0x8(%ebp),%edx
  80df94:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80df96:	b8 00 00 00 00       	mov    $0x0,%eax
  80df9b:	5d                   	pop    %ebp
  80df9c:	c3                   	ret    

0080df9d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80df9d:	55                   	push   %ebp
  80df9e:	89 e5                	mov    %esp,%ebp
  80dfa0:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80dfa3:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfa8:	85 d2                	test   %edx,%edx
  80dfaa:	74 02                	je     80dfae <raw_connect+0x11>
  80dfac:	8b 02                	mov    (%edx),%eax
  80dfae:	8b 55 08             	mov    0x8(%ebp),%edx
  80dfb1:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80dfb4:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfb9:	5d                   	pop    %ebp
  80dfba:	c3                   	ret    

0080dfbb <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dfbb:	55                   	push   %ebp
  80dfbc:	89 e5                	mov    %esp,%ebp
  80dfbe:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dfc1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dfc4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80dfc7:	8b 55 10             	mov    0x10(%ebp),%edx
  80dfca:	89 50 18             	mov    %edx,0x18(%eax)
}
  80dfcd:	5d                   	pop    %ebp
  80dfce:	c3                   	ret    

0080dfcf <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80dfcf:	55                   	push   %ebp
  80dfd0:	89 e5                	mov    %esp,%ebp
  80dfd2:	57                   	push   %edi
  80dfd3:	56                   	push   %esi
  80dfd4:	53                   	push   %ebx
  80dfd5:	83 ec 14             	sub    $0x14,%esp
  80dfd8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dfdb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80dfde:	6a 14                	push   $0x14
  80dfe0:	57                   	push   %edi
  80dfe1:	e8 51 68 ff ff       	call   804837 <pbuf_header>
  80dfe6:	83 c4 10             	add    $0x10,%esp
  80dfe9:	84 c0                	test   %al,%al
  80dfeb:	74 52                	je     80e03f <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80dfed:	83 ec 04             	sub    $0x4,%esp
  80dff0:	6a 00                	push   $0x0
  80dff2:	6a 00                	push   $0x0
  80dff4:	6a 01                	push   $0x1
  80dff6:	e8 cf 69 ff ff       	call   8049ca <pbuf_alloc>
  80dffb:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dffd:	83 c4 10             	add    $0x10,%esp
  80e000:	85 c0                	test   %eax,%eax
  80e002:	0f 84 be 00 00 00    	je     80e0c6 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e008:	83 ec 08             	sub    $0x8,%esp
  80e00b:	57                   	push   %edi
  80e00c:	50                   	push   %eax
  80e00d:	e8 d3 6d ff ff       	call   804de5 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e012:	83 c4 04             	add    $0x4,%esp
  80e015:	ff 75 10             	pushl  0x10(%ebp)
  80e018:	e8 a1 85 ff ff       	call   8065be <ip_route>
  80e01d:	83 c4 10             	add    $0x10,%esp
  80e020:	85 c0                	test   %eax,%eax
  80e022:	75 41                	jne    80e065 <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e024:	39 f7                	cmp    %esi,%edi
  80e026:	0f 84 a1 00 00 00    	je     80e0cd <raw_sendto+0xfe>
      pbuf_free(q);
  80e02c:	83 ec 0c             	sub    $0xc,%esp
  80e02f:	56                   	push   %esi
  80e030:	e8 cf 68 ff ff       	call   804904 <pbuf_free>
  80e035:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80e038:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e03d:	eb 66                	jmp    80e0a5 <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80e03f:	83 ec 08             	sub    $0x8,%esp
  80e042:	6a ec                	push   $0xffffffec
  80e044:	57                   	push   %edi
  80e045:	e8 ed 67 ff ff       	call   804837 <pbuf_header>
  80e04a:	83 c4 10             	add    $0x10,%esp
  80e04d:	84 c0                	test   %al,%al
  80e04f:	75 5e                	jne    80e0af <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e051:	83 ec 0c             	sub    $0xc,%esp
  80e054:	ff 75 10             	pushl  0x10(%ebp)
  80e057:	e8 62 85 ff ff       	call   8065be <ip_route>
  80e05c:	83 c4 10             	add    $0x10,%esp
  80e05f:	85 c0                	test   %eax,%eax
  80e061:	74 71                	je     80e0d4 <raw_sendto+0x105>
    q = p;
  80e063:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e065:	89 da                	mov    %ebx,%edx
  80e067:	85 db                	test   %ebx,%ebx
  80e069:	74 05                	je     80e070 <raw_sendto+0xa1>
  80e06b:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e06e:	75 03                	jne    80e073 <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e070:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e073:	83 ec 04             	sub    $0x4,%esp
  80e076:	50                   	push   %eax
  80e077:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e07b:	50                   	push   %eax
  80e07c:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e080:	50                   	push   %eax
  80e081:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e085:	50                   	push   %eax
  80e086:	ff 75 10             	pushl  0x10(%ebp)
  80e089:	52                   	push   %edx
  80e08a:	56                   	push   %esi
  80e08b:	e8 b1 88 ff ff       	call   806941 <ip_output_if>
  80e090:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e092:	83 c4 20             	add    $0x20,%esp
  80e095:	39 f7                	cmp    %esi,%edi
  80e097:	74 0c                	je     80e0a5 <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80e099:	83 ec 0c             	sub    $0xc,%esp
  80e09c:	56                   	push   %esi
  80e09d:	e8 62 68 ff ff       	call   804904 <pbuf_free>
  80e0a2:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e0a5:	89 d8                	mov    %ebx,%eax
  80e0a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e0aa:	5b                   	pop    %ebx
  80e0ab:	5e                   	pop    %esi
  80e0ac:	5f                   	pop    %edi
  80e0ad:	5d                   	pop    %ebp
  80e0ae:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e0af:	83 ec 04             	sub    $0x4,%esp
  80e0b2:	68 3c 38 81 00       	push   $0x81383c
  80e0b7:	68 e3 00 00 00       	push   $0xe3
  80e0bc:	68 62 38 81 00       	push   $0x813862
  80e0c1:	e8 a9 06 00 00       	call   80e76f <_panic>
      return ERR_MEM;
  80e0c6:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80e0cb:	eb d8                	jmp    80e0a5 <raw_sendto+0xd6>
    return ERR_RTE;
  80e0cd:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e0d2:	eb d1                	jmp    80e0a5 <raw_sendto+0xd6>
  80e0d4:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e0d9:	eb ca                	jmp    80e0a5 <raw_sendto+0xd6>

0080e0db <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e0db:	55                   	push   %ebp
  80e0dc:	89 e5                	mov    %esp,%ebp
  80e0de:	83 ec 0c             	sub    $0xc,%esp
  80e0e1:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e0e4:	8d 50 04             	lea    0x4(%eax),%edx
  80e0e7:	52                   	push   %edx
  80e0e8:	ff 75 0c             	pushl  0xc(%ebp)
  80e0eb:	50                   	push   %eax
  80e0ec:	e8 de fe ff ff       	call   80dfcf <raw_sendto>
}
  80e0f1:	c9                   	leave  
  80e0f2:	c3                   	ret    

0080e0f3 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e0f3:	55                   	push   %ebp
  80e0f4:	89 e5                	mov    %esp,%ebp
  80e0f6:	83 ec 08             	sub    $0x8,%esp
  80e0f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e0fc:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e101:	39 c8                	cmp    %ecx,%eax
  80e103:	75 1b                	jne    80e120 <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e105:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e108:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e10d:	83 ec 08             	sub    $0x8,%esp
  80e110:	51                   	push   %ecx
  80e111:	6a 00                	push   $0x0
  80e113:	e8 9f 64 ff ff       	call   8045b7 <memp_free>
}
  80e118:	83 c4 10             	add    $0x10,%esp
  80e11b:	c9                   	leave  
  80e11c:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e11d:	8b 40 0c             	mov    0xc(%eax),%eax
  80e120:	85 c0                	test   %eax,%eax
  80e122:	74 e9                	je     80e10d <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e124:	8b 50 0c             	mov    0xc(%eax),%edx
  80e127:	39 ca                	cmp    %ecx,%edx
  80e129:	75 f2                	jne    80e11d <raw_remove+0x2a>
  80e12b:	85 d2                	test   %edx,%edx
  80e12d:	74 ee                	je     80e11d <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80e12f:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e132:	89 50 0c             	mov    %edx,0xc(%eax)
  80e135:	eb e6                	jmp    80e11d <raw_remove+0x2a>

0080e137 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e137:	55                   	push   %ebp
  80e138:	89 e5                	mov    %esp,%ebp
  80e13a:	56                   	push   %esi
  80e13b:	53                   	push   %ebx
  80e13c:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e13f:	83 ec 0c             	sub    $0xc,%esp
  80e142:	6a 00                	push   $0x0
  80e144:	e8 18 64 ff ff       	call   804561 <memp_malloc>
  80e149:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e14b:	83 c4 10             	add    $0x10,%esp
  80e14e:	85 c0                	test   %eax,%eax
  80e150:	74 27                	je     80e179 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e152:	83 ec 04             	sub    $0x4,%esp
  80e155:	6a 1c                	push   $0x1c
  80e157:	6a 00                	push   $0x0
  80e159:	50                   	push   %eax
  80e15a:	e8 ab 0f 00 00       	call   80f10a <memset>
    pcb->protocol = proto;
  80e15f:	89 f0                	mov    %esi,%eax
  80e161:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e164:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e168:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e16d:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e170:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
  80e176:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e179:	89 d8                	mov    %ebx,%eax
  80e17b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e17e:	5b                   	pop    %ebx
  80e17f:	5e                   	pop    %esi
  80e180:	5d                   	pop    %ebp
  80e181:	c3                   	ret    

0080e182 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e182:	55                   	push   %ebp
  80e183:	89 e5                	mov    %esp,%ebp
  80e185:	57                   	push   %edi
  80e186:	56                   	push   %esi
  80e187:	53                   	push   %ebx
  80e188:	83 ec 28             	sub    $0x28,%esp
  80e18b:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e18e:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e191:	0f b7 07             	movzwl (%edi),%eax
  80e194:	50                   	push   %eax
  80e195:	e8 51 96 ff ff       	call   8077eb <ntohs>
  80e19a:	66 c1 e8 06          	shr    $0x6,%ax
  80e19e:	83 e0 3c             	and    $0x3c,%eax
  80e1a1:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e1a5:	89 c6                	mov    %eax,%esi
  80e1a7:	f7 de                	neg    %esi
  80e1a9:	0f bf f6             	movswl %si,%esi
  80e1ac:	83 c4 08             	add    $0x8,%esp
  80e1af:	56                   	push   %esi
  80e1b0:	53                   	push   %ebx
  80e1b1:	e8 81 66 ff ff       	call   804837 <pbuf_header>
  80e1b6:	83 c4 10             	add    $0x10,%esp
  80e1b9:	84 c0                	test   %al,%al
  80e1bb:	75 67                	jne    80e224 <icmp_input+0xa2>
  80e1bd:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e1c2:	76 60                	jbe    80e224 <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e1c4:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e1c7:	80 38 08             	cmpb   $0x8,(%eax)
  80e1ca:	74 0e                	je     80e1da <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e1cc:	83 ec 0c             	sub    $0xc,%esp
  80e1cf:	53                   	push   %ebx
  80e1d0:	e8 2f 67 ff ff       	call   804904 <pbuf_free>
  return;
  80e1d5:	83 c4 10             	add    $0x10,%esp
  80e1d8:	eb 56                	jmp    80e230 <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e1da:	83 ec 08             	sub    $0x8,%esp
  80e1dd:	ff 75 0c             	pushl  0xc(%ebp)
  80e1e0:	8d 47 10             	lea    0x10(%edi),%eax
  80e1e3:	50                   	push   %eax
  80e1e4:	e8 92 83 ff ff       	call   80657b <ip_addr_isbroadcast>
  80e1e9:	83 c4 10             	add    $0x10,%esp
  80e1ec:	84 c0                	test   %al,%al
  80e1ee:	75 48                	jne    80e238 <icmp_input+0xb6>
  80e1f0:	8b 47 10             	mov    0x10(%edi),%eax
  80e1f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e1f6:	83 ec 0c             	sub    $0xc,%esp
  80e1f9:	68 00 00 00 f0       	push   $0xf0000000
  80e1fe:	e8 0c 98 ff ff       	call   807a0f <ntohl>
  80e203:	23 45 e0             	and    -0x20(%ebp),%eax
  80e206:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e209:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e210:	e8 fa 97 ff ff       	call   807a0f <ntohl>
  80e215:	83 c4 10             	add    $0x10,%esp
  80e218:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e21b:	74 1b                	je     80e238 <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e21d:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e222:	77 22                	ja     80e246 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e224:	83 ec 0c             	sub    $0xc,%esp
  80e227:	53                   	push   %ebx
  80e228:	e8 d7 66 ff ff       	call   804904 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e22d:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e230:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e233:	5b                   	pop    %ebx
  80e234:	5e                   	pop    %esi
  80e235:	5f                   	pop    %edi
  80e236:	5d                   	pop    %ebp
  80e237:	c3                   	ret    
      pbuf_free(p);
  80e238:	83 ec 0c             	sub    $0xc,%esp
  80e23b:	53                   	push   %ebx
  80e23c:	e8 c3 66 ff ff       	call   804904 <pbuf_free>
      return;
  80e241:	83 c4 10             	add    $0x10,%esp
  80e244:	eb ea                	jmp    80e230 <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e246:	83 ec 0c             	sub    $0xc,%esp
  80e249:	53                   	push   %ebx
  80e24a:	e8 77 94 ff ff       	call   8076c6 <inet_chksum_pbuf>
  80e24f:	83 c4 10             	add    $0x10,%esp
  80e252:	66 85 c0             	test   %ax,%ax
  80e255:	0f 85 96 00 00 00    	jne    80e2f1 <icmp_input+0x16f>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e25b:	83 ec 08             	sub    $0x8,%esp
  80e25e:	6a 22                	push   $0x22
  80e260:	53                   	push   %ebx
  80e261:	e8 d1 65 ff ff       	call   804837 <pbuf_header>
  80e266:	83 c4 10             	add    $0x10,%esp
  80e269:	84 c0                	test   %al,%al
  80e26b:	0f 84 fb 00 00 00    	je     80e36c <icmp_input+0x1ea>
      if (pbuf_header(p, hlen)) {
  80e271:	83 ec 08             	sub    $0x8,%esp
  80e274:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e278:	50                   	push   %eax
  80e279:	53                   	push   %ebx
  80e27a:	e8 b8 65 ff ff       	call   804837 <pbuf_header>
  80e27f:	83 c4 10             	add    $0x10,%esp
  80e282:	84 c0                	test   %al,%al
  80e284:	75 7c                	jne    80e302 <icmp_input+0x180>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e286:	83 ec 04             	sub    $0x4,%esp
  80e289:	6a 00                	push   $0x0
  80e28b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e28f:	50                   	push   %eax
  80e290:	6a 02                	push   $0x2
  80e292:	e8 33 67 ff ff       	call   8049ca <pbuf_alloc>
  80e297:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e29a:	83 c4 10             	add    $0x10,%esp
  80e29d:	85 c0                	test   %eax,%eax
  80e29f:	74 75                	je     80e316 <icmp_input+0x194>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e2a1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e2a4:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e2a8:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e2ac:	83 c0 08             	add    $0x8,%eax
  80e2af:	39 c2                	cmp    %eax,%edx
  80e2b1:	72 74                	jb     80e327 <icmp_input+0x1a5>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e2b3:	83 ec 08             	sub    $0x8,%esp
  80e2b6:	53                   	push   %ebx
  80e2b7:	ff 75 e0             	pushl  -0x20(%ebp)
  80e2ba:	e8 ed 6b ff ff       	call   804eac <pbuf_copy>
  80e2bf:	83 c4 10             	add    $0x10,%esp
  80e2c2:	84 c0                	test   %al,%al
  80e2c4:	75 78                	jne    80e33e <icmp_input+0x1bc>
      iphdr = r->payload;
  80e2c6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e2c9:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e2cc:	83 ec 08             	sub    $0x8,%esp
  80e2cf:	56                   	push   %esi
  80e2d0:	50                   	push   %eax
  80e2d1:	e8 61 65 ff ff       	call   804837 <pbuf_header>
  80e2d6:	83 c4 10             	add    $0x10,%esp
  80e2d9:	84 c0                	test   %al,%al
  80e2db:	75 78                	jne    80e355 <icmp_input+0x1d3>
      pbuf_free(p);
  80e2dd:	83 ec 0c             	sub    $0xc,%esp
  80e2e0:	53                   	push   %ebx
  80e2e1:	e8 1e 66 ff ff       	call   804904 <pbuf_free>
  80e2e6:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e2e9:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e2ec:	e9 91 00 00 00       	jmp    80e382 <icmp_input+0x200>
      pbuf_free(p);
  80e2f1:	83 ec 0c             	sub    $0xc,%esp
  80e2f4:	53                   	push   %ebx
  80e2f5:	e8 0a 66 ff ff       	call   804904 <pbuf_free>
      return;
  80e2fa:	83 c4 10             	add    $0x10,%esp
  80e2fd:	e9 2e ff ff ff       	jmp    80e230 <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e302:	83 ec 04             	sub    $0x4,%esp
  80e305:	68 78 38 81 00       	push   $0x813878
  80e30a:	6a 7b                	push   $0x7b
  80e30c:	68 6c 39 81 00       	push   $0x81396c
  80e311:	e8 59 04 00 00       	call   80e76f <_panic>
  pbuf_free(p);
  80e316:	83 ec 0c             	sub    $0xc,%esp
  80e319:	53                   	push   %ebx
  80e31a:	e8 e5 65 ff ff       	call   804904 <pbuf_free>
  return;
  80e31f:	83 c4 10             	add    $0x10,%esp
  80e322:	e9 09 ff ff ff       	jmp    80e230 <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e327:	83 ec 04             	sub    $0x4,%esp
  80e32a:	68 ac 38 81 00       	push   $0x8138ac
  80e32f:	68 85 00 00 00       	push   $0x85
  80e334:	68 6c 39 81 00       	push   $0x81396c
  80e339:	e8 31 04 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e33e:	83 ec 04             	sub    $0x4,%esp
  80e341:	68 e4 38 81 00       	push   $0x8138e4
  80e346:	68 88 00 00 00       	push   $0x88
  80e34b:	68 6c 39 81 00       	push   $0x81396c
  80e350:	e8 1a 04 00 00       	call   80e76f <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e355:	83 ec 04             	sub    $0x4,%esp
  80e358:	68 0c 39 81 00       	push   $0x81390c
  80e35d:	68 8e 00 00 00       	push   $0x8e
  80e362:	68 6c 39 81 00       	push   $0x81396c
  80e367:	e8 03 04 00 00       	call   80e76f <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e36c:	83 ec 08             	sub    $0x8,%esp
  80e36f:	6a de                	push   $0xffffffde
  80e371:	53                   	push   %ebx
  80e372:	e8 c0 64 ff ff       	call   804837 <pbuf_header>
  80e377:	83 c4 10             	add    $0x10,%esp
  80e37a:	84 c0                	test   %al,%al
  80e37c:	0f 85 d3 00 00 00    	jne    80e455 <icmp_input+0x2d3>
    iecho = p->payload;
  80e382:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e385:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e388:	8b 57 10             	mov    0x10(%edi),%edx
  80e38b:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e38e:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e391:	83 ec 0c             	sub    $0xc,%esp
  80e394:	0f b7 06             	movzwl (%esi),%eax
  80e397:	50                   	push   %eax
  80e398:	e8 4e 94 ff ff       	call   8077eb <ntohs>
  80e39d:	0f b6 c0             	movzbl %al,%eax
  80e3a0:	89 04 24             	mov    %eax,(%esp)
  80e3a3:	e8 36 94 ff ff       	call   8077de <htons>
  80e3a8:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e3ab:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e3af:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e3b3:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e3ba:	e8 1f 94 ff ff       	call   8077de <htons>
  80e3bf:	83 c4 10             	add    $0x10,%esp
  80e3c2:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e3c6:	0f 82 a0 00 00 00    	jb     80e46c <icmp_input+0x2ea>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e3cc:	83 ec 0c             	sub    $0xc,%esp
  80e3cf:	68 00 08 00 00       	push   $0x800
  80e3d4:	e8 05 94 ff ff       	call   8077de <htons>
  80e3d9:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e3dd:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e3e1:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e3e5:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e3e8:	83 ec 0c             	sub    $0xc,%esp
  80e3eb:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e3ef:	50                   	push   %eax
  80e3f0:	e8 f6 93 ff ff       	call   8077eb <ntohs>
  80e3f5:	66 0d 00 ff          	or     $0xff00,%ax
  80e3f9:	0f b7 c0             	movzwl %ax,%eax
  80e3fc:	89 04 24             	mov    %eax,(%esp)
  80e3ff:	e8 da 93 ff ff       	call   8077de <htons>
  80e404:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e408:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e40e:	83 c4 08             	add    $0x8,%esp
  80e411:	6a 14                	push   $0x14
  80e413:	57                   	push   %edi
  80e414:	e8 97 92 ff ff       	call   8076b0 <inet_chksum>
  80e419:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e41d:	83 c4 08             	add    $0x8,%esp
  80e420:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e424:	50                   	push   %eax
  80e425:	53                   	push   %ebx
  80e426:	e8 0c 64 ff ff       	call   804837 <pbuf_header>
  80e42b:	83 c4 10             	add    $0x10,%esp
  80e42e:	84 c0                	test   %al,%al
  80e430:	75 53                	jne    80e485 <icmp_input+0x303>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e432:	83 ec 04             	sub    $0x4,%esp
  80e435:	ff 75 0c             	pushl  0xc(%ebp)
  80e438:	6a 01                	push   $0x1
  80e43a:	6a 00                	push   $0x0
  80e43c:	68 ff 00 00 00       	push   $0xff
  80e441:	6a 00                	push   $0x0
  80e443:	83 c7 0c             	add    $0xc,%edi
  80e446:	57                   	push   %edi
  80e447:	53                   	push   %ebx
  80e448:	e8 f4 84 ff ff       	call   806941 <ip_output_if>
  80e44d:	83 c4 20             	add    $0x20,%esp
  80e450:	e9 77 fd ff ff       	jmp    80e1cc <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e455:	83 ec 04             	sub    $0x4,%esp
  80e458:	68 0c 39 81 00       	push   $0x81390c
  80e45d:	68 98 00 00 00       	push   $0x98
  80e462:	68 6c 39 81 00       	push   $0x81396c
  80e467:	e8 03 03 00 00       	call   80e76f <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e46c:	83 ec 0c             	sub    $0xc,%esp
  80e46f:	68 00 08 00 00       	push   $0x800
  80e474:	e8 65 93 ff ff       	call   8077de <htons>
  80e479:	66 01 46 02          	add    %ax,0x2(%esi)
  80e47d:	83 c4 10             	add    $0x10,%esp
  80e480:	e9 63 ff ff ff       	jmp    80e3e8 <icmp_input+0x266>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e485:	83 ec 04             	sub    $0x4,%esp
  80e488:	68 b8 29 81 00       	push   $0x8129b8
  80e48d:	68 b9 00 00 00       	push   $0xb9
  80e492:	68 6c 39 81 00       	push   $0x81396c
  80e497:	e8 d3 02 00 00       	call   80e76f <_panic>

0080e49c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e49c:	55                   	push   %ebp
  80e49d:	89 e5                	mov    %esp,%ebp
  80e49f:	57                   	push   %edi
  80e4a0:	56                   	push   %esi
  80e4a1:	53                   	push   %ebx
  80e4a2:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e4a5:	6a 00                	push   $0x0
  80e4a7:	6a 24                	push   $0x24
  80e4a9:	6a 01                	push   $0x1
  80e4ab:	e8 1a 65 ff ff       	call   8049ca <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e4b0:	83 c4 10             	add    $0x10,%esp
  80e4b3:	85 c0                	test   %eax,%eax
  80e4b5:	0f 84 a5 00 00 00    	je     80e560 <icmp_dest_unreach+0xc4>
  80e4bb:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e4bd:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e4c2:	0f 86 a0 00 00 00    	jbe    80e568 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e4c8:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4cb:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e4ce:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e4d1:	83 ec 0c             	sub    $0xc,%esp
  80e4d4:	0f b7 06             	movzwl (%esi),%eax
  80e4d7:	50                   	push   %eax
  80e4d8:	e8 0e 93 ff ff       	call   8077eb <ntohs>
  80e4dd:	0f b6 c0             	movzbl %al,%eax
  80e4e0:	80 cc 03             	or     $0x3,%ah
  80e4e3:	89 04 24             	mov    %eax,(%esp)
  80e4e6:	e8 f3 92 ff ff       	call   8077de <htons>
  80e4eb:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e4ee:	0f b7 c0             	movzwl %ax,%eax
  80e4f1:	89 04 24             	mov    %eax,(%esp)
  80e4f4:	e8 f2 92 ff ff       	call   8077eb <ntohs>
  80e4f9:	b0 00                	mov    $0x0,%al
  80e4fb:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e4ff:	0f b7 c0             	movzwl %ax,%eax
  80e502:	89 04 24             	mov    %eax,(%esp)
  80e505:	e8 d4 92 ff ff       	call   8077de <htons>
  80e50a:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e50d:	83 c4 0c             	add    $0xc,%esp
  80e510:	6a 1c                	push   $0x1c
  80e512:	8b 45 08             	mov    0x8(%ebp),%eax
  80e515:	ff 70 04             	pushl  0x4(%eax)
  80e518:	8b 43 04             	mov    0x4(%ebx),%eax
  80e51b:	83 c0 08             	add    $0x8,%eax
  80e51e:	50                   	push   %eax
  80e51f:	e8 90 0c 00 00       	call   80f1b4 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e524:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e52a:	83 c4 08             	add    $0x8,%esp
  80e52d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e531:	50                   	push   %eax
  80e532:	56                   	push   %esi
  80e533:	e8 78 91 ff ff       	call   8076b0 <inet_chksum>
  80e538:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e53c:	83 c4 08             	add    $0x8,%esp
  80e53f:	6a 01                	push   $0x1
  80e541:	6a 00                	push   $0x0
  80e543:	68 ff 00 00 00       	push   $0xff
  80e548:	83 c7 0c             	add    $0xc,%edi
  80e54b:	57                   	push   %edi
  80e54c:	6a 00                	push   $0x0
  80e54e:	53                   	push   %ebx
  80e54f:	e8 7a 85 ff ff       	call   806ace <ip_output>
  pbuf_free(q);
  80e554:	83 c4 14             	add    $0x14,%esp
  80e557:	53                   	push   %ebx
  80e558:	e8 a7 63 ff ff       	call   804904 <pbuf_free>
  80e55d:	83 c4 10             	add    $0x10,%esp
}
  80e560:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e563:	5b                   	pop    %ebx
  80e564:	5e                   	pop    %esi
  80e565:	5f                   	pop    %edi
  80e566:	5d                   	pop    %ebp
  80e567:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e568:	83 ec 04             	sub    $0x4,%esp
  80e56b:	68 40 39 81 00       	push   $0x813940
  80e570:	68 ef 00 00 00       	push   $0xef
  80e575:	68 6c 39 81 00       	push   $0x81396c
  80e57a:	e8 f0 01 00 00       	call   80e76f <_panic>

0080e57f <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e57f:	55                   	push   %ebp
  80e580:	89 e5                	mov    %esp,%ebp
  80e582:	57                   	push   %edi
  80e583:	56                   	push   %esi
  80e584:	53                   	push   %ebx
  80e585:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e588:	6a 00                	push   $0x0
  80e58a:	6a 24                	push   $0x24
  80e58c:	6a 01                	push   $0x1
  80e58e:	e8 37 64 ff ff       	call   8049ca <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e593:	83 c4 10             	add    $0x10,%esp
  80e596:	85 c0                	test   %eax,%eax
  80e598:	0f 84 a5 00 00 00    	je     80e643 <icmp_time_exceeded+0xc4>
  80e59e:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e5a0:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e5a5:	0f 86 a0 00 00 00    	jbe    80e64b <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e5ab:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5ae:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e5b1:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e5b4:	83 ec 0c             	sub    $0xc,%esp
  80e5b7:	0f b7 06             	movzwl (%esi),%eax
  80e5ba:	50                   	push   %eax
  80e5bb:	e8 2b 92 ff ff       	call   8077eb <ntohs>
  80e5c0:	0f b6 c0             	movzbl %al,%eax
  80e5c3:	80 cc 0b             	or     $0xb,%ah
  80e5c6:	89 04 24             	mov    %eax,(%esp)
  80e5c9:	e8 10 92 ff ff       	call   8077de <htons>
  80e5ce:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e5d1:	0f b7 c0             	movzwl %ax,%eax
  80e5d4:	89 04 24             	mov    %eax,(%esp)
  80e5d7:	e8 0f 92 ff ff       	call   8077eb <ntohs>
  80e5dc:	b0 00                	mov    $0x0,%al
  80e5de:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e5e2:	0f b7 c0             	movzwl %ax,%eax
  80e5e5:	89 04 24             	mov    %eax,(%esp)
  80e5e8:	e8 f1 91 ff ff       	call   8077de <htons>
  80e5ed:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e5f0:	83 c4 0c             	add    $0xc,%esp
  80e5f3:	6a 1c                	push   $0x1c
  80e5f5:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5f8:	ff 70 04             	pushl  0x4(%eax)
  80e5fb:	8b 43 04             	mov    0x4(%ebx),%eax
  80e5fe:	83 c0 08             	add    $0x8,%eax
  80e601:	50                   	push   %eax
  80e602:	e8 ad 0b 00 00       	call   80f1b4 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e607:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e60d:	83 c4 08             	add    $0x8,%esp
  80e610:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e614:	50                   	push   %eax
  80e615:	56                   	push   %esi
  80e616:	e8 95 90 ff ff       	call   8076b0 <inet_chksum>
  80e61b:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e61f:	83 c4 08             	add    $0x8,%esp
  80e622:	6a 01                	push   $0x1
  80e624:	6a 00                	push   $0x0
  80e626:	68 ff 00 00 00       	push   $0xff
  80e62b:	83 c7 0c             	add    $0xc,%edi
  80e62e:	57                   	push   %edi
  80e62f:	6a 00                	push   $0x0
  80e631:	53                   	push   %ebx
  80e632:	e8 97 84 ff ff       	call   806ace <ip_output>
  pbuf_free(q);
  80e637:	83 c4 14             	add    $0x14,%esp
  80e63a:	53                   	push   %ebx
  80e63b:	e8 c4 62 ff ff       	call   804904 <pbuf_free>
  80e640:	83 c4 10             	add    $0x10,%esp
}
  80e643:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e646:	5b                   	pop    %ebx
  80e647:	5e                   	pop    %esi
  80e648:	5f                   	pop    %edi
  80e649:	5d                   	pop    %ebp
  80e64a:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e64b:	83 ec 04             	sub    $0x4,%esp
  80e64e:	68 40 39 81 00       	push   $0x813940
  80e653:	68 1e 01 00 00       	push   $0x11e
  80e658:	68 6c 39 81 00       	push   $0x81396c
  80e65d:	e8 0d 01 00 00       	call   80e76f <_panic>

0080e662 <libmain>:
        return &envs[ENVX(sys_getenvid())];
} 

void
libmain(int argc, char **argv)
{
  80e662:	55                   	push   %ebp
  80e663:	89 e5                	mov    %esp,%ebp
  80e665:	57                   	push   %edi
  80e666:	56                   	push   %esi
  80e667:	53                   	push   %ebx
  80e668:	83 ec 0c             	sub    $0xc,%esp
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.

	thisenv = 0;
  80e66b:	c7 05 5c c2 b3 00 00 	movl   $0x0,0xb3c25c
  80e672:	00 00 00 
	envid_t find = sys_getenvid();
  80e675:	e8 fe 0c 00 00       	call   80f378 <sys_getenvid>
  80e67a:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  80e680:	be 00 00 00 00       	mov    $0x0,%esi
	for(int i = 0; i < NENV; i++){
  80e685:	ba 00 00 00 00       	mov    $0x0,%edx
		if(envs[i].env_id == find)
  80e68a:	bf 01 00 00 00       	mov    $0x1,%edi
  80e68f:	eb 0b                	jmp    80e69c <libmain+0x3a>
	for(int i = 0; i < NENV; i++){
  80e691:	83 c2 01             	add    $0x1,%edx
  80e694:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  80e69a:	74 21                	je     80e6bd <libmain+0x5b>
		if(envs[i].env_id == find)
  80e69c:	89 d1                	mov    %edx,%ecx
  80e69e:	c1 e1 07             	shl    $0x7,%ecx
  80e6a1:	81 c1 00 00 c0 ee    	add    $0xeec00000,%ecx
  80e6a7:	8b 49 48             	mov    0x48(%ecx),%ecx
  80e6aa:	39 c1                	cmp    %eax,%ecx
  80e6ac:	75 e3                	jne    80e691 <libmain+0x2f>
  80e6ae:	89 d3                	mov    %edx,%ebx
  80e6b0:	c1 e3 07             	shl    $0x7,%ebx
  80e6b3:	81 c3 00 00 c0 ee    	add    $0xeec00000,%ebx
  80e6b9:	89 fe                	mov    %edi,%esi
  80e6bb:	eb d4                	jmp    80e691 <libmain+0x2f>
  80e6bd:	89 f0                	mov    %esi,%eax
  80e6bf:	84 c0                	test   %al,%al
  80e6c1:	74 06                	je     80e6c9 <libmain+0x67>
  80e6c3:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
			thisenv = &envs[i];
	}

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e6c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80e6cd:	7e 0a                	jle    80e6d9 <libmain+0x77>
		binaryname = argv[0];
  80e6cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e6d2:	8b 00                	mov    (%eax),%eax
  80e6d4:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	cprintf("%d: in libmain.c call umain!\n", thisenv->env_id);
  80e6d9:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e6de:	8b 40 48             	mov    0x48(%eax),%eax
  80e6e1:	83 ec 08             	sub    $0x8,%esp
  80e6e4:	50                   	push   %eax
  80e6e5:	68 86 39 81 00       	push   $0x813986
  80e6ea:	e8 76 01 00 00       	call   80e865 <cprintf>
	cprintf("before umain\n");
  80e6ef:	c7 04 24 a4 39 81 00 	movl   $0x8139a4,(%esp)
  80e6f6:	e8 6a 01 00 00       	call   80e865 <cprintf>
	// call user main routine
	umain(argc, argv);
  80e6fb:	83 c4 08             	add    $0x8,%esp
  80e6fe:	ff 75 0c             	pushl  0xc(%ebp)
  80e701:	ff 75 08             	pushl  0x8(%ebp)
  80e704:	e8 73 1e ff ff       	call   80057c <umain>
	cprintf("after umain\n");
  80e709:	c7 04 24 b2 39 81 00 	movl   $0x8139b2,(%esp)
  80e710:	e8 50 01 00 00       	call   80e865 <cprintf>
	cprintf("%d: limain.c exit()\n", thisenv->env_id);
  80e715:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e71a:	8b 40 48             	mov    0x48(%eax),%eax
  80e71d:	83 c4 08             	add    $0x8,%esp
  80e720:	50                   	push   %eax
  80e721:	68 bf 39 81 00       	push   $0x8139bf
  80e726:	e8 3a 01 00 00       	call   80e865 <cprintf>
	// exit gracefully
	exit();
  80e72b:	e8 0b 00 00 00       	call   80e73b <exit>
}
  80e730:	83 c4 10             	add    $0x10,%esp
  80e733:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e736:	5b                   	pop    %ebx
  80e737:	5e                   	pop    %esi
  80e738:	5f                   	pop    %edi
  80e739:	5d                   	pop    %ebp
  80e73a:	c3                   	ret    

0080e73b <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e73b:	55                   	push   %ebp
  80e73c:	89 e5                	mov    %esp,%ebp
  80e73e:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e741:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e746:	8b 40 48             	mov    0x48(%eax),%eax
  80e749:	68 ec 39 81 00       	push   $0x8139ec
  80e74e:	50                   	push   %eax
  80e74f:	68 de 39 81 00       	push   $0x8139de
  80e754:	e8 0c 01 00 00       	call   80e865 <cprintf>
	close_all();
  80e759:	e8 08 17 00 00       	call   80fe66 <close_all>
	sys_env_destroy(0);
  80e75e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e765:	e8 cd 0b 00 00       	call   80f337 <sys_env_destroy>
}
  80e76a:	83 c4 10             	add    $0x10,%esp
  80e76d:	c9                   	leave  
  80e76e:	c3                   	ret    

0080e76f <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e76f:	55                   	push   %ebp
  80e770:	89 e5                	mov    %esp,%ebp
  80e772:	56                   	push   %esi
  80e773:	53                   	push   %ebx
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e774:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e779:	8b 40 48             	mov    0x48(%eax),%eax
  80e77c:	83 ec 04             	sub    $0x4,%esp
  80e77f:	68 18 3a 81 00       	push   $0x813a18
  80e784:	50                   	push   %eax
  80e785:	68 de 39 81 00       	push   $0x8139de
  80e78a:	e8 d6 00 00 00       	call   80e865 <cprintf>
	va_list ap;

	va_start(ap, fmt);
  80e78f:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	// cprintf("[%08x] user panic in %s at %s:%d: ",
	// 	sys_getenvid(), binaryname, file, line);
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e792:	8b 35 e8 52 81 00    	mov    0x8152e8,%esi
  80e798:	e8 db 0b 00 00       	call   80f378 <sys_getenvid>
  80e79d:	83 c4 04             	add    $0x4,%esp
  80e7a0:	ff 75 0c             	pushl  0xc(%ebp)
  80e7a3:	ff 75 08             	pushl  0x8(%ebp)
  80e7a6:	56                   	push   %esi
  80e7a7:	50                   	push   %eax
  80e7a8:	68 f4 39 81 00       	push   $0x8139f4
  80e7ad:	e8 b3 00 00 00       	call   80e865 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e7b2:	83 c4 18             	add    $0x18,%esp
  80e7b5:	53                   	push   %ebx
  80e7b6:	ff 75 10             	pushl  0x10(%ebp)
  80e7b9:	e8 56 00 00 00       	call   80e814 <vcprintf>
	cprintf("\n");
  80e7be:	c7 04 24 a2 39 81 00 	movl   $0x8139a2,(%esp)
  80e7c5:	e8 9b 00 00 00       	call   80e865 <cprintf>
  80e7ca:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e7cd:	cc                   	int3   
  80e7ce:	eb fd                	jmp    80e7cd <_panic+0x5e>

0080e7d0 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e7d0:	55                   	push   %ebp
  80e7d1:	89 e5                	mov    %esp,%ebp
  80e7d3:	53                   	push   %ebx
  80e7d4:	83 ec 04             	sub    $0x4,%esp
  80e7d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e7da:	8b 13                	mov    (%ebx),%edx
  80e7dc:	8d 42 01             	lea    0x1(%edx),%eax
  80e7df:	89 03                	mov    %eax,(%ebx)
  80e7e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e7e4:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e7e8:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e7ed:	74 09                	je     80e7f8 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e7ef:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e7f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e7f6:	c9                   	leave  
  80e7f7:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e7f8:	83 ec 08             	sub    $0x8,%esp
  80e7fb:	68 ff 00 00 00       	push   $0xff
  80e800:	8d 43 08             	lea    0x8(%ebx),%eax
  80e803:	50                   	push   %eax
  80e804:	e8 f1 0a 00 00       	call   80f2fa <sys_cputs>
		b->idx = 0;
  80e809:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e80f:	83 c4 10             	add    $0x10,%esp
  80e812:	eb db                	jmp    80e7ef <putch+0x1f>

0080e814 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e814:	55                   	push   %ebp
  80e815:	89 e5                	mov    %esp,%ebp
  80e817:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e81d:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e824:	00 00 00 
	b.cnt = 0;
  80e827:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e82e:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e831:	ff 75 0c             	pushl  0xc(%ebp)
  80e834:	ff 75 08             	pushl  0x8(%ebp)
  80e837:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e83d:	50                   	push   %eax
  80e83e:	68 d0 e7 80 00       	push   $0x80e7d0
  80e843:	e8 4a 01 00 00       	call   80e992 <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e848:	83 c4 08             	add    $0x8,%esp
  80e84b:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e851:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e857:	50                   	push   %eax
  80e858:	e8 9d 0a 00 00       	call   80f2fa <sys_cputs>

	return b.cnt;
}
  80e85d:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e863:	c9                   	leave  
  80e864:	c3                   	ret    

0080e865 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e865:	55                   	push   %ebp
  80e866:	89 e5                	mov    %esp,%ebp
  80e868:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e86b:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e86e:	50                   	push   %eax
  80e86f:	ff 75 08             	pushl  0x8(%ebp)
  80e872:	e8 9d ff ff ff       	call   80e814 <vcprintf>
	va_end(ap);

	return cnt;
}
  80e877:	c9                   	leave  
  80e878:	c3                   	ret    

0080e879 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e879:	55                   	push   %ebp
  80e87a:	89 e5                	mov    %esp,%ebp
  80e87c:	57                   	push   %edi
  80e87d:	56                   	push   %esi
  80e87e:	53                   	push   %ebx
  80e87f:	83 ec 1c             	sub    $0x1c,%esp
  80e882:	89 c6                	mov    %eax,%esi
  80e884:	89 d7                	mov    %edx,%edi
  80e886:	8b 45 08             	mov    0x8(%ebp),%eax
  80e889:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e88c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e88f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e892:	8b 45 10             	mov    0x10(%ebp),%eax
  80e895:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// if cprintf'parameter includes pattern of the form "%-", padding
	// space on the right side if neccesary.
	// you can add helper function if needed.
	// your code here:
	if(padc == '-'){
  80e898:	83 7d 18 2d          	cmpl   $0x2d,0x18(%ebp)
  80e89c:	74 2c                	je     80e8ca <printnum+0x51>
		while (--width > 0)
			putch(padc, putdat);
	}
	else {
		// first recursively print all preceding (more significant) digits
		if (num >= base) {
  80e89e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e8a1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80e8a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e8ab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e8ae:	39 c2                	cmp    %eax,%edx
  80e8b0:	1b 4d dc             	sbb    -0x24(%ebp),%ecx
  80e8b3:	73 43                	jae    80e8f8 <printnum+0x7f>
			printnum(putch, putdat, num / base, base, width - 1, padc);
		} else {
			// print any needed pad characters before first digit
			while (--width > 0)
  80e8b5:	83 eb 01             	sub    $0x1,%ebx
  80e8b8:	85 db                	test   %ebx,%ebx
  80e8ba:	7e 6c                	jle    80e928 <printnum+0xaf>
				putch(padc, putdat);
  80e8bc:	83 ec 08             	sub    $0x8,%esp
  80e8bf:	57                   	push   %edi
  80e8c0:	ff 75 18             	pushl  0x18(%ebp)
  80e8c3:	ff d6                	call   *%esi
  80e8c5:	83 c4 10             	add    $0x10,%esp
  80e8c8:	eb eb                	jmp    80e8b5 <printnum+0x3c>
		printnum(putch, putdat, num, base, 0, padc);
  80e8ca:	83 ec 0c             	sub    $0xc,%esp
  80e8cd:	6a 20                	push   $0x20
  80e8cf:	6a 00                	push   $0x0
  80e8d1:	50                   	push   %eax
  80e8d2:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e8d5:	ff 75 e0             	pushl  -0x20(%ebp)
  80e8d8:	89 fa                	mov    %edi,%edx
  80e8da:	89 f0                	mov    %esi,%eax
  80e8dc:	e8 98 ff ff ff       	call   80e879 <printnum>
		while (--width > 0)
  80e8e1:	83 c4 20             	add    $0x20,%esp
  80e8e4:	83 eb 01             	sub    $0x1,%ebx
  80e8e7:	85 db                	test   %ebx,%ebx
  80e8e9:	7e 65                	jle    80e950 <printnum+0xd7>
			putch(padc, putdat);
  80e8eb:	83 ec 08             	sub    $0x8,%esp
  80e8ee:	57                   	push   %edi
  80e8ef:	6a 20                	push   $0x20
  80e8f1:	ff d6                	call   *%esi
  80e8f3:	83 c4 10             	add    $0x10,%esp
  80e8f6:	eb ec                	jmp    80e8e4 <printnum+0x6b>
			printnum(putch, putdat, num / base, base, width - 1, padc);
  80e8f8:	83 ec 0c             	sub    $0xc,%esp
  80e8fb:	ff 75 18             	pushl  0x18(%ebp)
  80e8fe:	83 eb 01             	sub    $0x1,%ebx
  80e901:	53                   	push   %ebx
  80e902:	50                   	push   %eax
  80e903:	83 ec 08             	sub    $0x8,%esp
  80e906:	ff 75 dc             	pushl  -0x24(%ebp)
  80e909:	ff 75 d8             	pushl  -0x28(%ebp)
  80e90c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e90f:	ff 75 e0             	pushl  -0x20(%ebp)
  80e912:	e8 39 28 00 00       	call   811150 <__udivdi3>
  80e917:	83 c4 18             	add    $0x18,%esp
  80e91a:	52                   	push   %edx
  80e91b:	50                   	push   %eax
  80e91c:	89 fa                	mov    %edi,%edx
  80e91e:	89 f0                	mov    %esi,%eax
  80e920:	e8 54 ff ff ff       	call   80e879 <printnum>
  80e925:	83 c4 20             	add    $0x20,%esp
		}

		// then print this (the least significant) digit
		putch("0123456789abcdef"[num % base], putdat);
  80e928:	83 ec 08             	sub    $0x8,%esp
  80e92b:	57                   	push   %edi
  80e92c:	83 ec 04             	sub    $0x4,%esp
  80e92f:	ff 75 dc             	pushl  -0x24(%ebp)
  80e932:	ff 75 d8             	pushl  -0x28(%ebp)
  80e935:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e938:	ff 75 e0             	pushl  -0x20(%ebp)
  80e93b:	e8 20 29 00 00       	call   811260 <__umoddi3>
  80e940:	83 c4 14             	add    $0x14,%esp
  80e943:	0f be 80 1f 3a 81 00 	movsbl 0x813a1f(%eax),%eax
  80e94a:	50                   	push   %eax
  80e94b:	ff d6                	call   *%esi
  80e94d:	83 c4 10             	add    $0x10,%esp
	}
}
  80e950:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e953:	5b                   	pop    %ebx
  80e954:	5e                   	pop    %esi
  80e955:	5f                   	pop    %edi
  80e956:	5d                   	pop    %ebp
  80e957:	c3                   	ret    

0080e958 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e958:	55                   	push   %ebp
  80e959:	89 e5                	mov    %esp,%ebp
  80e95b:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e95e:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e962:	8b 10                	mov    (%eax),%edx
  80e964:	3b 50 04             	cmp    0x4(%eax),%edx
  80e967:	73 0a                	jae    80e973 <sprintputch+0x1b>
		*b->buf++ = ch;
  80e969:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e96c:	89 08                	mov    %ecx,(%eax)
  80e96e:	8b 45 08             	mov    0x8(%ebp),%eax
  80e971:	88 02                	mov    %al,(%edx)
}
  80e973:	5d                   	pop    %ebp
  80e974:	c3                   	ret    

0080e975 <printfmt>:
{
  80e975:	55                   	push   %ebp
  80e976:	89 e5                	mov    %esp,%ebp
  80e978:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e97b:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e97e:	50                   	push   %eax
  80e97f:	ff 75 10             	pushl  0x10(%ebp)
  80e982:	ff 75 0c             	pushl  0xc(%ebp)
  80e985:	ff 75 08             	pushl  0x8(%ebp)
  80e988:	e8 05 00 00 00       	call   80e992 <vprintfmt>
}
  80e98d:	83 c4 10             	add    $0x10,%esp
  80e990:	c9                   	leave  
  80e991:	c3                   	ret    

0080e992 <vprintfmt>:
{
  80e992:	55                   	push   %ebp
  80e993:	89 e5                	mov    %esp,%ebp
  80e995:	57                   	push   %edi
  80e996:	56                   	push   %esi
  80e997:	53                   	push   %ebx
  80e998:	83 ec 3c             	sub    $0x3c,%esp
  80e99b:	8b 75 08             	mov    0x8(%ebp),%esi
  80e99e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e9a1:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e9a4:	e9 32 04 00 00       	jmp    80eddb <vprintfmt+0x449>
		padc = ' ';
  80e9a9:	c6 45 cf 20          	movb   $0x20,-0x31(%ebp)
		plusflag = 0;
  80e9ad:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		altflag = 0;
  80e9b4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		precision = -1;
  80e9bb:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80e9c2:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e9c9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80e9d0:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e9d5:	8d 47 01             	lea    0x1(%edi),%eax
  80e9d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e9db:	0f b6 17             	movzbl (%edi),%edx
  80e9de:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e9e1:	3c 55                	cmp    $0x55,%al
  80e9e3:	0f 87 12 05 00 00    	ja     80eefb <vprintfmt+0x569>
  80e9e9:	0f b6 c0             	movzbl %al,%eax
  80e9ec:	ff 24 85 00 3c 81 00 	jmp    *0x813c00(,%eax,4)
  80e9f3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e9f6:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
  80e9fa:	eb d9                	jmp    80e9d5 <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80e9fc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80e9ff:	c6 45 cf 30          	movb   $0x30,-0x31(%ebp)
  80ea03:	eb d0                	jmp    80e9d5 <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80ea05:	0f b6 d2             	movzbl %dl,%edx
  80ea08:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80ea0b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea10:	89 75 08             	mov    %esi,0x8(%ebp)
  80ea13:	eb 03                	jmp    80ea18 <vprintfmt+0x86>
  80ea15:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80ea18:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80ea1b:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80ea1f:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80ea22:	8d 72 d0             	lea    -0x30(%edx),%esi
  80ea25:	83 fe 09             	cmp    $0x9,%esi
  80ea28:	76 eb                	jbe    80ea15 <vprintfmt+0x83>
  80ea2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea2d:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea30:	eb 14                	jmp    80ea46 <vprintfmt+0xb4>
			precision = va_arg(ap, int);
  80ea32:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea35:	8b 00                	mov    (%eax),%eax
  80ea37:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea3a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea3d:	8d 40 04             	lea    0x4(%eax),%eax
  80ea40:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ea43:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80ea46:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ea4a:	79 89                	jns    80e9d5 <vprintfmt+0x43>
				width = precision, precision = -1;
  80ea4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ea4f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ea52:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80ea59:	e9 77 ff ff ff       	jmp    80e9d5 <vprintfmt+0x43>
  80ea5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ea61:	85 c0                	test   %eax,%eax
  80ea63:	0f 48 c1             	cmovs  %ecx,%eax
  80ea66:	89 45 e0             	mov    %eax,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ea69:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80ea6c:	e9 64 ff ff ff       	jmp    80e9d5 <vprintfmt+0x43>
  80ea71:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80ea74:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
			goto reswitch;
  80ea7b:	e9 55 ff ff ff       	jmp    80e9d5 <vprintfmt+0x43>
			lflag++;
  80ea80:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80ea84:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80ea87:	e9 49 ff ff ff       	jmp    80e9d5 <vprintfmt+0x43>
			putch(va_arg(ap, int), putdat);
  80ea8c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea8f:	8d 78 04             	lea    0x4(%eax),%edi
  80ea92:	83 ec 08             	sub    $0x8,%esp
  80ea95:	53                   	push   %ebx
  80ea96:	ff 30                	pushl  (%eax)
  80ea98:	ff d6                	call   *%esi
			break;
  80ea9a:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80ea9d:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80eaa0:	e9 33 03 00 00       	jmp    80edd8 <vprintfmt+0x446>
			err = va_arg(ap, int);
  80eaa5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaa8:	8d 78 04             	lea    0x4(%eax),%edi
  80eaab:	8b 00                	mov    (%eax),%eax
  80eaad:	99                   	cltd   
  80eaae:	31 d0                	xor    %edx,%eax
  80eab0:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80eab2:	83 f8 11             	cmp    $0x11,%eax
  80eab5:	7f 23                	jg     80eada <vprintfmt+0x148>
  80eab7:	8b 14 85 60 3d 81 00 	mov    0x813d60(,%eax,4),%edx
  80eabe:	85 d2                	test   %edx,%edx
  80eac0:	74 18                	je     80eada <vprintfmt+0x148>
				printfmt(putch, putdat, "%s", p);
  80eac2:	52                   	push   %edx
  80eac3:	68 7d 2b 81 00       	push   $0x812b7d
  80eac8:	53                   	push   %ebx
  80eac9:	56                   	push   %esi
  80eaca:	e8 a6 fe ff ff       	call   80e975 <printfmt>
  80eacf:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ead2:	89 7d 14             	mov    %edi,0x14(%ebp)
  80ead5:	e9 fe 02 00 00       	jmp    80edd8 <vprintfmt+0x446>
				printfmt(putch, putdat, "error %d", err);
  80eada:	50                   	push   %eax
  80eadb:	68 37 3a 81 00       	push   $0x813a37
  80eae0:	53                   	push   %ebx
  80eae1:	56                   	push   %esi
  80eae2:	e8 8e fe ff ff       	call   80e975 <printfmt>
  80eae7:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80eaea:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80eaed:	e9 e6 02 00 00       	jmp    80edd8 <vprintfmt+0x446>
			if ((p = va_arg(ap, char *)) == NULL)
  80eaf2:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaf5:	83 c0 04             	add    $0x4,%eax
  80eaf8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80eafb:	8b 45 14             	mov    0x14(%ebp),%eax
  80eafe:	8b 08                	mov    (%eax),%ecx
				p = "(null)";
  80eb00:	85 c9                	test   %ecx,%ecx
  80eb02:	b8 30 3a 81 00       	mov    $0x813a30,%eax
  80eb07:	0f 45 c1             	cmovne %ecx,%eax
  80eb0a:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (width > 0 && padc != '-')
  80eb0d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80eb11:	7e 06                	jle    80eb19 <vprintfmt+0x187>
  80eb13:	80 7d cf 2d          	cmpb   $0x2d,-0x31(%ebp)
  80eb17:	75 0d                	jne    80eb26 <vprintfmt+0x194>
				for (width -= strnlen(p, precision); width > 0; width--)
  80eb19:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80eb1c:	89 c7                	mov    %eax,%edi
  80eb1e:	03 45 e0             	add    -0x20(%ebp),%eax
  80eb21:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eb24:	eb 53                	jmp    80eb79 <vprintfmt+0x1e7>
  80eb26:	83 ec 08             	sub    $0x8,%esp
  80eb29:	ff 75 d8             	pushl  -0x28(%ebp)
  80eb2c:	50                   	push   %eax
  80eb2d:	e8 71 04 00 00       	call   80efa3 <strnlen>
  80eb32:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eb35:	29 c1                	sub    %eax,%ecx
  80eb37:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80eb3a:	83 c4 10             	add    $0x10,%esp
  80eb3d:	89 cf                	mov    %ecx,%edi
					putch(padc, putdat);
  80eb3f:	0f be 45 cf          	movsbl -0x31(%ebp),%eax
  80eb43:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80eb46:	eb 0f                	jmp    80eb57 <vprintfmt+0x1c5>
					putch(padc, putdat);
  80eb48:	83 ec 08             	sub    $0x8,%esp
  80eb4b:	53                   	push   %ebx
  80eb4c:	ff 75 e0             	pushl  -0x20(%ebp)
  80eb4f:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80eb51:	83 ef 01             	sub    $0x1,%edi
  80eb54:	83 c4 10             	add    $0x10,%esp
  80eb57:	85 ff                	test   %edi,%edi
  80eb59:	7f ed                	jg     80eb48 <vprintfmt+0x1b6>
  80eb5b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80eb5e:	85 c9                	test   %ecx,%ecx
  80eb60:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb65:	0f 49 c1             	cmovns %ecx,%eax
  80eb68:	29 c1                	sub    %eax,%ecx
  80eb6a:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80eb6d:	eb aa                	jmp    80eb19 <vprintfmt+0x187>
					putch(ch, putdat);
  80eb6f:	83 ec 08             	sub    $0x8,%esp
  80eb72:	53                   	push   %ebx
  80eb73:	52                   	push   %edx
  80eb74:	ff d6                	call   *%esi
  80eb76:	83 c4 10             	add    $0x10,%esp
  80eb79:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eb7c:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80eb7e:	83 c7 01             	add    $0x1,%edi
  80eb81:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80eb85:	0f be d0             	movsbl %al,%edx
  80eb88:	85 d2                	test   %edx,%edx
  80eb8a:	74 4b                	je     80ebd7 <vprintfmt+0x245>
  80eb8c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80eb90:	78 06                	js     80eb98 <vprintfmt+0x206>
  80eb92:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80eb96:	78 1e                	js     80ebb6 <vprintfmt+0x224>
				if (altflag && (ch < ' ' || ch > '~'))
  80eb98:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80eb9c:	74 d1                	je     80eb6f <vprintfmt+0x1dd>
  80eb9e:	0f be c0             	movsbl %al,%eax
  80eba1:	83 e8 20             	sub    $0x20,%eax
  80eba4:	83 f8 5e             	cmp    $0x5e,%eax
  80eba7:	76 c6                	jbe    80eb6f <vprintfmt+0x1dd>
					putch('?', putdat);
  80eba9:	83 ec 08             	sub    $0x8,%esp
  80ebac:	53                   	push   %ebx
  80ebad:	6a 3f                	push   $0x3f
  80ebaf:	ff d6                	call   *%esi
  80ebb1:	83 c4 10             	add    $0x10,%esp
  80ebb4:	eb c3                	jmp    80eb79 <vprintfmt+0x1e7>
  80ebb6:	89 cf                	mov    %ecx,%edi
  80ebb8:	eb 0e                	jmp    80ebc8 <vprintfmt+0x236>
				putch(' ', putdat);
  80ebba:	83 ec 08             	sub    $0x8,%esp
  80ebbd:	53                   	push   %ebx
  80ebbe:	6a 20                	push   $0x20
  80ebc0:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ebc2:	83 ef 01             	sub    $0x1,%edi
  80ebc5:	83 c4 10             	add    $0x10,%esp
  80ebc8:	85 ff                	test   %edi,%edi
  80ebca:	7f ee                	jg     80ebba <vprintfmt+0x228>
			if ((p = va_arg(ap, char *)) == NULL)
  80ebcc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80ebcf:	89 45 14             	mov    %eax,0x14(%ebp)
  80ebd2:	e9 01 02 00 00       	jmp    80edd8 <vprintfmt+0x446>
  80ebd7:	89 cf                	mov    %ecx,%edi
  80ebd9:	eb ed                	jmp    80ebc8 <vprintfmt+0x236>
		switch (ch = *(unsigned char *) fmt++) {
  80ebdb:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			plusflag = 1;
  80ebde:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
			goto reswitch;
  80ebe5:	e9 eb fd ff ff       	jmp    80e9d5 <vprintfmt+0x43>
	if (lflag >= 2)
  80ebea:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ebee:	7f 21                	jg     80ec11 <vprintfmt+0x27f>
	else if (lflag)
  80ebf0:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ebf4:	74 68                	je     80ec5e <vprintfmt+0x2cc>
		return va_arg(*ap, long);
  80ebf6:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebf9:	8b 00                	mov    (%eax),%eax
  80ebfb:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ebfe:	89 c1                	mov    %eax,%ecx
  80ec00:	c1 f9 1f             	sar    $0x1f,%ecx
  80ec03:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80ec06:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec09:	8d 40 04             	lea    0x4(%eax),%eax
  80ec0c:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec0f:	eb 17                	jmp    80ec28 <vprintfmt+0x296>
		return va_arg(*ap, long long);
  80ec11:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec14:	8b 50 04             	mov    0x4(%eax),%edx
  80ec17:	8b 00                	mov    (%eax),%eax
  80ec19:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ec1c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80ec1f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec22:	8d 40 08             	lea    0x8(%eax),%eax
  80ec25:	89 45 14             	mov    %eax,0x14(%ebp)
			num = getint(&ap, lflag);
  80ec28:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ec2b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ec2e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec31:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if ((long long) num < 0) {
  80ec34:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ec38:	78 3f                	js     80ec79 <vprintfmt+0x2e7>
			base = 10;
  80ec3a:	b8 0a 00 00 00       	mov    $0xa,%eax
			else if(plusflag){
  80ec3f:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  80ec43:	0f 84 71 01 00 00    	je     80edba <vprintfmt+0x428>
				putch('+', putdat);
  80ec49:	83 ec 08             	sub    $0x8,%esp
  80ec4c:	53                   	push   %ebx
  80ec4d:	6a 2b                	push   $0x2b
  80ec4f:	ff d6                	call   *%esi
  80ec51:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ec54:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ec59:	e9 5c 01 00 00       	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, int);
  80ec5e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec61:	8b 00                	mov    (%eax),%eax
  80ec63:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ec66:	89 c1                	mov    %eax,%ecx
  80ec68:	c1 f9 1f             	sar    $0x1f,%ecx
  80ec6b:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80ec6e:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec71:	8d 40 04             	lea    0x4(%eax),%eax
  80ec74:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec77:	eb af                	jmp    80ec28 <vprintfmt+0x296>
				putch('-', putdat);
  80ec79:	83 ec 08             	sub    $0x8,%esp
  80ec7c:	53                   	push   %ebx
  80ec7d:	6a 2d                	push   $0x2d
  80ec7f:	ff d6                	call   *%esi
				num = -(long long) num;
  80ec81:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ec84:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ec87:	f7 d8                	neg    %eax
  80ec89:	83 d2 00             	adc    $0x0,%edx
  80ec8c:	f7 da                	neg    %edx
  80ec8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec91:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec94:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ec97:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ec9c:	e9 19 01 00 00       	jmp    80edba <vprintfmt+0x428>
	if (lflag >= 2)
  80eca1:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80eca5:	7f 29                	jg     80ecd0 <vprintfmt+0x33e>
	else if (lflag)
  80eca7:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ecab:	74 44                	je     80ecf1 <vprintfmt+0x35f>
		return va_arg(*ap, unsigned long);
  80ecad:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecb0:	8b 00                	mov    (%eax),%eax
  80ecb2:	ba 00 00 00 00       	mov    $0x0,%edx
  80ecb7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecba:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ecbd:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecc0:	8d 40 04             	lea    0x4(%eax),%eax
  80ecc3:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ecc6:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eccb:	e9 ea 00 00 00       	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ecd0:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecd3:	8b 50 04             	mov    0x4(%eax),%edx
  80ecd6:	8b 00                	mov    (%eax),%eax
  80ecd8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecdb:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ecde:	8b 45 14             	mov    0x14(%ebp),%eax
  80ece1:	8d 40 08             	lea    0x8(%eax),%eax
  80ece4:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ece7:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ecec:	e9 c9 00 00 00       	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ecf1:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecf4:	8b 00                	mov    (%eax),%eax
  80ecf6:	ba 00 00 00 00       	mov    $0x0,%edx
  80ecfb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecfe:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed01:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed04:	8d 40 04             	lea    0x4(%eax),%eax
  80ed07:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed0a:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ed0f:	e9 a6 00 00 00       	jmp    80edba <vprintfmt+0x428>
			putch('0', putdat);
  80ed14:	83 ec 08             	sub    $0x8,%esp
  80ed17:	53                   	push   %ebx
  80ed18:	6a 30                	push   $0x30
  80ed1a:	ff d6                	call   *%esi
	if (lflag >= 2)
  80ed1c:	83 c4 10             	add    $0x10,%esp
  80ed1f:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ed23:	7f 26                	jg     80ed4b <vprintfmt+0x3b9>
	else if (lflag)
  80ed25:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ed29:	74 3e                	je     80ed69 <vprintfmt+0x3d7>
		return va_arg(*ap, unsigned long);
  80ed2b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed2e:	8b 00                	mov    (%eax),%eax
  80ed30:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed35:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed38:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed3b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed3e:	8d 40 04             	lea    0x4(%eax),%eax
  80ed41:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed44:	b8 08 00 00 00       	mov    $0x8,%eax
  80ed49:	eb 6f                	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ed4b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed4e:	8b 50 04             	mov    0x4(%eax),%edx
  80ed51:	8b 00                	mov    (%eax),%eax
  80ed53:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed56:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed59:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed5c:	8d 40 08             	lea    0x8(%eax),%eax
  80ed5f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed62:	b8 08 00 00 00       	mov    $0x8,%eax
  80ed67:	eb 51                	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ed69:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed6c:	8b 00                	mov    (%eax),%eax
  80ed6e:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed73:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed76:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed79:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed7c:	8d 40 04             	lea    0x4(%eax),%eax
  80ed7f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ed82:	b8 08 00 00 00       	mov    $0x8,%eax
  80ed87:	eb 31                	jmp    80edba <vprintfmt+0x428>
			putch('0', putdat);
  80ed89:	83 ec 08             	sub    $0x8,%esp
  80ed8c:	53                   	push   %ebx
  80ed8d:	6a 30                	push   $0x30
  80ed8f:	ff d6                	call   *%esi
			putch('x', putdat);
  80ed91:	83 c4 08             	add    $0x8,%esp
  80ed94:	53                   	push   %ebx
  80ed95:	6a 78                	push   $0x78
  80ed97:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ed99:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed9c:	8b 00                	mov    (%eax),%eax
  80ed9e:	ba 00 00 00 00       	mov    $0x0,%edx
  80eda3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eda6:	89 55 dc             	mov    %edx,-0x24(%ebp)
			goto number;
  80eda9:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80edac:	8b 45 14             	mov    0x14(%ebp),%eax
  80edaf:	8d 40 04             	lea    0x4(%eax),%eax
  80edb2:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80edb5:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80edba:	83 ec 0c             	sub    $0xc,%esp
  80edbd:	0f be 55 cf          	movsbl -0x31(%ebp),%edx
  80edc1:	52                   	push   %edx
  80edc2:	ff 75 e0             	pushl  -0x20(%ebp)
  80edc5:	50                   	push   %eax
  80edc6:	ff 75 dc             	pushl  -0x24(%ebp)
  80edc9:	ff 75 d8             	pushl  -0x28(%ebp)
  80edcc:	89 da                	mov    %ebx,%edx
  80edce:	89 f0                	mov    %esi,%eax
  80edd0:	e8 a4 fa ff ff       	call   80e879 <printnum>
			break;
  80edd5:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80edd8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80eddb:	83 c7 01             	add    $0x1,%edi
  80edde:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ede2:	83 f8 25             	cmp    $0x25,%eax
  80ede5:	0f 84 be fb ff ff    	je     80e9a9 <vprintfmt+0x17>
			if (ch == '\0')
  80edeb:	85 c0                	test   %eax,%eax
  80eded:	0f 84 28 01 00 00    	je     80ef1b <vprintfmt+0x589>
			putch(ch, putdat);
  80edf3:	83 ec 08             	sub    $0x8,%esp
  80edf6:	53                   	push   %ebx
  80edf7:	50                   	push   %eax
  80edf8:	ff d6                	call   *%esi
  80edfa:	83 c4 10             	add    $0x10,%esp
  80edfd:	eb dc                	jmp    80eddb <vprintfmt+0x449>
	if (lflag >= 2)
  80edff:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ee03:	7f 26                	jg     80ee2b <vprintfmt+0x499>
	else if (lflag)
  80ee05:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ee09:	74 41                	je     80ee4c <vprintfmt+0x4ba>
		return va_arg(*ap, unsigned long);
  80ee0b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee0e:	8b 00                	mov    (%eax),%eax
  80ee10:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee15:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee18:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ee1b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee1e:	8d 40 04             	lea    0x4(%eax),%eax
  80ee21:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee24:	b8 10 00 00 00       	mov    $0x10,%eax
  80ee29:	eb 8f                	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ee2b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee2e:	8b 50 04             	mov    0x4(%eax),%edx
  80ee31:	8b 00                	mov    (%eax),%eax
  80ee33:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee36:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ee39:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee3c:	8d 40 08             	lea    0x8(%eax),%eax
  80ee3f:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee42:	b8 10 00 00 00       	mov    $0x10,%eax
  80ee47:	e9 6e ff ff ff       	jmp    80edba <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ee4c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee4f:	8b 00                	mov    (%eax),%eax
  80ee51:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee56:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee59:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ee5c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee5f:	8d 40 04             	lea    0x4(%eax),%eax
  80ee62:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee65:	b8 10 00 00 00       	mov    $0x10,%eax
  80ee6a:	e9 4b ff ff ff       	jmp    80edba <vprintfmt+0x428>
					if ((p = va_arg(ap, char *)) == NULL){
  80ee6f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee72:	83 c0 04             	add    $0x4,%eax
  80ee75:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee78:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee7b:	8b 00                	mov    (%eax),%eax
  80ee7d:	85 c0                	test   %eax,%eax
  80ee7f:	74 14                	je     80ee95 <vprintfmt+0x503>
					}else if(*(int *)putdat > 127){
  80ee81:	8b 13                	mov    (%ebx),%edx
  80ee83:	83 fa 7f             	cmp    $0x7f,%edx
  80ee86:	7f 37                	jg     80eebf <vprintfmt+0x52d>
						*(char *)p = *(int *)putdat;
  80ee88:	88 10                	mov    %dl,(%eax)
					if ((p = va_arg(ap, char *)) == NULL){
  80ee8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ee8d:	89 45 14             	mov    %eax,0x14(%ebp)
  80ee90:	e9 43 ff ff ff       	jmp    80edd8 <vprintfmt+0x446>
						for (; (ch = *tmp++) != '\0';){
  80ee95:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ee9a:	bf 55 3b 81 00       	mov    $0x813b55,%edi
							putch(ch, putdat);
  80ee9f:	83 ec 08             	sub    $0x8,%esp
  80eea2:	53                   	push   %ebx
  80eea3:	50                   	push   %eax
  80eea4:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80eea6:	83 c7 01             	add    $0x1,%edi
  80eea9:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80eead:	83 c4 10             	add    $0x10,%esp
  80eeb0:	85 c0                	test   %eax,%eax
  80eeb2:	75 eb                	jne    80ee9f <vprintfmt+0x50d>
					if ((p = va_arg(ap, char *)) == NULL){
  80eeb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80eeb7:	89 45 14             	mov    %eax,0x14(%ebp)
  80eeba:	e9 19 ff ff ff       	jmp    80edd8 <vprintfmt+0x446>
						*(char *)p = *(int *)putdat;
  80eebf:	88 10                	mov    %dl,(%eax)
						for (; (ch = *tmp++) != '\0';){
  80eec1:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eec6:	bf 8d 3b 81 00       	mov    $0x813b8d,%edi
							putch(ch, putdat);
  80eecb:	83 ec 08             	sub    $0x8,%esp
  80eece:	53                   	push   %ebx
  80eecf:	50                   	push   %eax
  80eed0:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80eed2:	83 c7 01             	add    $0x1,%edi
  80eed5:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80eed9:	83 c4 10             	add    $0x10,%esp
  80eedc:	85 c0                	test   %eax,%eax
  80eede:	75 eb                	jne    80eecb <vprintfmt+0x539>
					if ((p = va_arg(ap, char *)) == NULL){
  80eee0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80eee3:	89 45 14             	mov    %eax,0x14(%ebp)
  80eee6:	e9 ed fe ff ff       	jmp    80edd8 <vprintfmt+0x446>
			putch(ch, putdat);
  80eeeb:	83 ec 08             	sub    $0x8,%esp
  80eeee:	53                   	push   %ebx
  80eeef:	6a 25                	push   $0x25
  80eef1:	ff d6                	call   *%esi
			break;
  80eef3:	83 c4 10             	add    $0x10,%esp
  80eef6:	e9 dd fe ff ff       	jmp    80edd8 <vprintfmt+0x446>
			putch('%', putdat);
  80eefb:	83 ec 08             	sub    $0x8,%esp
  80eefe:	53                   	push   %ebx
  80eeff:	6a 25                	push   $0x25
  80ef01:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ef03:	83 c4 10             	add    $0x10,%esp
  80ef06:	89 f8                	mov    %edi,%eax
  80ef08:	eb 03                	jmp    80ef0d <vprintfmt+0x57b>
  80ef0a:	83 e8 01             	sub    $0x1,%eax
  80ef0d:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ef11:	75 f7                	jne    80ef0a <vprintfmt+0x578>
  80ef13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ef16:	e9 bd fe ff ff       	jmp    80edd8 <vprintfmt+0x446>
}
  80ef1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ef1e:	5b                   	pop    %ebx
  80ef1f:	5e                   	pop    %esi
  80ef20:	5f                   	pop    %edi
  80ef21:	5d                   	pop    %ebp
  80ef22:	c3                   	ret    

0080ef23 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ef23:	55                   	push   %ebp
  80ef24:	89 e5                	mov    %esp,%ebp
  80ef26:	83 ec 18             	sub    $0x18,%esp
  80ef29:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef2c:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ef2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ef32:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ef36:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ef39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ef40:	85 c0                	test   %eax,%eax
  80ef42:	74 26                	je     80ef6a <vsnprintf+0x47>
  80ef44:	85 d2                	test   %edx,%edx
  80ef46:	7e 22                	jle    80ef6a <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ef48:	ff 75 14             	pushl  0x14(%ebp)
  80ef4b:	ff 75 10             	pushl  0x10(%ebp)
  80ef4e:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ef51:	50                   	push   %eax
  80ef52:	68 58 e9 80 00       	push   $0x80e958
  80ef57:	e8 36 fa ff ff       	call   80e992 <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ef5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ef5f:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ef62:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ef65:	83 c4 10             	add    $0x10,%esp
}
  80ef68:	c9                   	leave  
  80ef69:	c3                   	ret    
		return -E_INVAL;
  80ef6a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ef6f:	eb f7                	jmp    80ef68 <vsnprintf+0x45>

0080ef71 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ef71:	55                   	push   %ebp
  80ef72:	89 e5                	mov    %esp,%ebp
  80ef74:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80ef77:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80ef7a:	50                   	push   %eax
  80ef7b:	ff 75 10             	pushl  0x10(%ebp)
  80ef7e:	ff 75 0c             	pushl  0xc(%ebp)
  80ef81:	ff 75 08             	pushl  0x8(%ebp)
  80ef84:	e8 9a ff ff ff       	call   80ef23 <vsnprintf>
	va_end(ap);

	return rc;
}
  80ef89:	c9                   	leave  
  80ef8a:	c3                   	ret    

0080ef8b <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80ef8b:	55                   	push   %ebp
  80ef8c:	89 e5                	mov    %esp,%ebp
  80ef8e:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80ef91:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef96:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80ef9a:	74 05                	je     80efa1 <strlen+0x16>
		n++;
  80ef9c:	83 c0 01             	add    $0x1,%eax
  80ef9f:	eb f5                	jmp    80ef96 <strlen+0xb>
	return n;
}
  80efa1:	5d                   	pop    %ebp
  80efa2:	c3                   	ret    

0080efa3 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80efa3:	55                   	push   %ebp
  80efa4:	89 e5                	mov    %esp,%ebp
  80efa6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80efa9:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80efac:	ba 00 00 00 00       	mov    $0x0,%edx
  80efb1:	39 c2                	cmp    %eax,%edx
  80efb3:	74 0d                	je     80efc2 <strnlen+0x1f>
  80efb5:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80efb9:	74 05                	je     80efc0 <strnlen+0x1d>
		n++;
  80efbb:	83 c2 01             	add    $0x1,%edx
  80efbe:	eb f1                	jmp    80efb1 <strnlen+0xe>
  80efc0:	89 d0                	mov    %edx,%eax
	return n;
}
  80efc2:	5d                   	pop    %ebp
  80efc3:	c3                   	ret    

0080efc4 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80efc4:	55                   	push   %ebp
  80efc5:	89 e5                	mov    %esp,%ebp
  80efc7:	53                   	push   %ebx
  80efc8:	8b 45 08             	mov    0x8(%ebp),%eax
  80efcb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80efce:	ba 00 00 00 00       	mov    $0x0,%edx
  80efd3:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80efd7:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80efda:	83 c2 01             	add    $0x1,%edx
  80efdd:	84 c9                	test   %cl,%cl
  80efdf:	75 f2                	jne    80efd3 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80efe1:	5b                   	pop    %ebx
  80efe2:	5d                   	pop    %ebp
  80efe3:	c3                   	ret    

0080efe4 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80efe4:	55                   	push   %ebp
  80efe5:	89 e5                	mov    %esp,%ebp
  80efe7:	53                   	push   %ebx
  80efe8:	83 ec 10             	sub    $0x10,%esp
  80efeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80efee:	53                   	push   %ebx
  80efef:	e8 97 ff ff ff       	call   80ef8b <strlen>
  80eff4:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80eff7:	ff 75 0c             	pushl  0xc(%ebp)
  80effa:	01 d8                	add    %ebx,%eax
  80effc:	50                   	push   %eax
  80effd:	e8 c2 ff ff ff       	call   80efc4 <strcpy>
	return dst;
}
  80f002:	89 d8                	mov    %ebx,%eax
  80f004:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f007:	c9                   	leave  
  80f008:	c3                   	ret    

0080f009 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f009:	55                   	push   %ebp
  80f00a:	89 e5                	mov    %esp,%ebp
  80f00c:	56                   	push   %esi
  80f00d:	53                   	push   %ebx
  80f00e:	8b 45 08             	mov    0x8(%ebp),%eax
  80f011:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f014:	89 c6                	mov    %eax,%esi
  80f016:	03 75 10             	add    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f019:	89 c2                	mov    %eax,%edx
  80f01b:	39 f2                	cmp    %esi,%edx
  80f01d:	74 11                	je     80f030 <strncpy+0x27>
		*dst++ = *src;
  80f01f:	83 c2 01             	add    $0x1,%edx
  80f022:	0f b6 19             	movzbl (%ecx),%ebx
  80f025:	88 5a ff             	mov    %bl,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f028:	80 fb 01             	cmp    $0x1,%bl
  80f02b:	83 d9 ff             	sbb    $0xffffffff,%ecx
  80f02e:	eb eb                	jmp    80f01b <strncpy+0x12>
	}
	return ret;
}
  80f030:	5b                   	pop    %ebx
  80f031:	5e                   	pop    %esi
  80f032:	5d                   	pop    %ebp
  80f033:	c3                   	ret    

0080f034 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f034:	55                   	push   %ebp
  80f035:	89 e5                	mov    %esp,%ebp
  80f037:	56                   	push   %esi
  80f038:	53                   	push   %ebx
  80f039:	8b 75 08             	mov    0x8(%ebp),%esi
  80f03c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f03f:	8b 55 10             	mov    0x10(%ebp),%edx
  80f042:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f044:	85 d2                	test   %edx,%edx
  80f046:	74 21                	je     80f069 <strlcpy+0x35>
  80f048:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80f04c:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80f04e:	39 c2                	cmp    %eax,%edx
  80f050:	74 14                	je     80f066 <strlcpy+0x32>
  80f052:	0f b6 19             	movzbl (%ecx),%ebx
  80f055:	84 db                	test   %bl,%bl
  80f057:	74 0b                	je     80f064 <strlcpy+0x30>
			*dst++ = *src++;
  80f059:	83 c1 01             	add    $0x1,%ecx
  80f05c:	83 c2 01             	add    $0x1,%edx
  80f05f:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f062:	eb ea                	jmp    80f04e <strlcpy+0x1a>
  80f064:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80f066:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80f069:	29 f0                	sub    %esi,%eax
}
  80f06b:	5b                   	pop    %ebx
  80f06c:	5e                   	pop    %esi
  80f06d:	5d                   	pop    %ebp
  80f06e:	c3                   	ret    

0080f06f <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f06f:	55                   	push   %ebp
  80f070:	89 e5                	mov    %esp,%ebp
  80f072:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f075:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f078:	0f b6 01             	movzbl (%ecx),%eax
  80f07b:	84 c0                	test   %al,%al
  80f07d:	74 0c                	je     80f08b <strcmp+0x1c>
  80f07f:	3a 02                	cmp    (%edx),%al
  80f081:	75 08                	jne    80f08b <strcmp+0x1c>
		p++, q++;
  80f083:	83 c1 01             	add    $0x1,%ecx
  80f086:	83 c2 01             	add    $0x1,%edx
  80f089:	eb ed                	jmp    80f078 <strcmp+0x9>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f08b:	0f b6 c0             	movzbl %al,%eax
  80f08e:	0f b6 12             	movzbl (%edx),%edx
  80f091:	29 d0                	sub    %edx,%eax
}
  80f093:	5d                   	pop    %ebp
  80f094:	c3                   	ret    

0080f095 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f095:	55                   	push   %ebp
  80f096:	89 e5                	mov    %esp,%ebp
  80f098:	53                   	push   %ebx
  80f099:	8b 45 08             	mov    0x8(%ebp),%eax
  80f09c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f09f:	89 c3                	mov    %eax,%ebx
  80f0a1:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f0a4:	eb 06                	jmp    80f0ac <strncmp+0x17>
		n--, p++, q++;
  80f0a6:	83 c0 01             	add    $0x1,%eax
  80f0a9:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80f0ac:	39 d8                	cmp    %ebx,%eax
  80f0ae:	74 16                	je     80f0c6 <strncmp+0x31>
  80f0b0:	0f b6 08             	movzbl (%eax),%ecx
  80f0b3:	84 c9                	test   %cl,%cl
  80f0b5:	74 04                	je     80f0bb <strncmp+0x26>
  80f0b7:	3a 0a                	cmp    (%edx),%cl
  80f0b9:	74 eb                	je     80f0a6 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f0bb:	0f b6 00             	movzbl (%eax),%eax
  80f0be:	0f b6 12             	movzbl (%edx),%edx
  80f0c1:	29 d0                	sub    %edx,%eax
}
  80f0c3:	5b                   	pop    %ebx
  80f0c4:	5d                   	pop    %ebp
  80f0c5:	c3                   	ret    
		return 0;
  80f0c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80f0cb:	eb f6                	jmp    80f0c3 <strncmp+0x2e>

0080f0cd <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f0cd:	55                   	push   %ebp
  80f0ce:	89 e5                	mov    %esp,%ebp
  80f0d0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0d3:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f0d7:	0f b6 10             	movzbl (%eax),%edx
  80f0da:	84 d2                	test   %dl,%dl
  80f0dc:	74 09                	je     80f0e7 <strchr+0x1a>
		if (*s == c)
  80f0de:	38 ca                	cmp    %cl,%dl
  80f0e0:	74 0a                	je     80f0ec <strchr+0x1f>
	for (; *s; s++)
  80f0e2:	83 c0 01             	add    $0x1,%eax
  80f0e5:	eb f0                	jmp    80f0d7 <strchr+0xa>
			return (char *) s;
	return 0;
  80f0e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f0ec:	5d                   	pop    %ebp
  80f0ed:	c3                   	ret    

0080f0ee <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f0ee:	55                   	push   %ebp
  80f0ef:	89 e5                	mov    %esp,%ebp
  80f0f1:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0f4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f0f8:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f0fb:	38 ca                	cmp    %cl,%dl
  80f0fd:	74 09                	je     80f108 <strfind+0x1a>
  80f0ff:	84 d2                	test   %dl,%dl
  80f101:	74 05                	je     80f108 <strfind+0x1a>
	for (; *s; s++)
  80f103:	83 c0 01             	add    $0x1,%eax
  80f106:	eb f0                	jmp    80f0f8 <strfind+0xa>
			break;
	return (char *) s;
}
  80f108:	5d                   	pop    %ebp
  80f109:	c3                   	ret    

0080f10a <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f10a:	55                   	push   %ebp
  80f10b:	89 e5                	mov    %esp,%ebp
  80f10d:	57                   	push   %edi
  80f10e:	56                   	push   %esi
  80f10f:	53                   	push   %ebx
  80f110:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f113:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f116:	85 c9                	test   %ecx,%ecx
  80f118:	74 31                	je     80f14b <memset+0x41>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f11a:	89 f8                	mov    %edi,%eax
  80f11c:	09 c8                	or     %ecx,%eax
  80f11e:	a8 03                	test   $0x3,%al
  80f120:	75 23                	jne    80f145 <memset+0x3b>
		c &= 0xFF;
  80f122:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f126:	89 d3                	mov    %edx,%ebx
  80f128:	c1 e3 08             	shl    $0x8,%ebx
  80f12b:	89 d0                	mov    %edx,%eax
  80f12d:	c1 e0 18             	shl    $0x18,%eax
  80f130:	89 d6                	mov    %edx,%esi
  80f132:	c1 e6 10             	shl    $0x10,%esi
  80f135:	09 f0                	or     %esi,%eax
  80f137:	09 c2                	or     %eax,%edx
  80f139:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f13b:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f13e:	89 d0                	mov    %edx,%eax
  80f140:	fc                   	cld    
  80f141:	f3 ab                	rep stos %eax,%es:(%edi)
  80f143:	eb 06                	jmp    80f14b <memset+0x41>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f145:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f148:	fc                   	cld    
  80f149:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f14b:	89 f8                	mov    %edi,%eax
  80f14d:	5b                   	pop    %ebx
  80f14e:	5e                   	pop    %esi
  80f14f:	5f                   	pop    %edi
  80f150:	5d                   	pop    %ebp
  80f151:	c3                   	ret    

0080f152 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f152:	55                   	push   %ebp
  80f153:	89 e5                	mov    %esp,%ebp
  80f155:	57                   	push   %edi
  80f156:	56                   	push   %esi
  80f157:	8b 45 08             	mov    0x8(%ebp),%eax
  80f15a:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f15d:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f160:	39 c6                	cmp    %eax,%esi
  80f162:	73 32                	jae    80f196 <memmove+0x44>
  80f164:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f167:	39 c2                	cmp    %eax,%edx
  80f169:	76 2b                	jbe    80f196 <memmove+0x44>
		s += n;
		d += n;
  80f16b:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f16e:	89 fe                	mov    %edi,%esi
  80f170:	09 ce                	or     %ecx,%esi
  80f172:	09 d6                	or     %edx,%esi
  80f174:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f17a:	75 0e                	jne    80f18a <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f17c:	83 ef 04             	sub    $0x4,%edi
  80f17f:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f182:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f185:	fd                   	std    
  80f186:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f188:	eb 09                	jmp    80f193 <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f18a:	83 ef 01             	sub    $0x1,%edi
  80f18d:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f190:	fd                   	std    
  80f191:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f193:	fc                   	cld    
  80f194:	eb 1a                	jmp    80f1b0 <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f196:	89 c2                	mov    %eax,%edx
  80f198:	09 ca                	or     %ecx,%edx
  80f19a:	09 f2                	or     %esi,%edx
  80f19c:	f6 c2 03             	test   $0x3,%dl
  80f19f:	75 0a                	jne    80f1ab <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f1a1:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f1a4:	89 c7                	mov    %eax,%edi
  80f1a6:	fc                   	cld    
  80f1a7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f1a9:	eb 05                	jmp    80f1b0 <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80f1ab:	89 c7                	mov    %eax,%edi
  80f1ad:	fc                   	cld    
  80f1ae:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f1b0:	5e                   	pop    %esi
  80f1b1:	5f                   	pop    %edi
  80f1b2:	5d                   	pop    %ebp
  80f1b3:	c3                   	ret    

0080f1b4 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f1b4:	55                   	push   %ebp
  80f1b5:	89 e5                	mov    %esp,%ebp
  80f1b7:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f1ba:	ff 75 10             	pushl  0x10(%ebp)
  80f1bd:	ff 75 0c             	pushl  0xc(%ebp)
  80f1c0:	ff 75 08             	pushl  0x8(%ebp)
  80f1c3:	e8 8a ff ff ff       	call   80f152 <memmove>
}
  80f1c8:	c9                   	leave  
  80f1c9:	c3                   	ret    

0080f1ca <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f1ca:	55                   	push   %ebp
  80f1cb:	89 e5                	mov    %esp,%ebp
  80f1cd:	56                   	push   %esi
  80f1ce:	53                   	push   %ebx
  80f1cf:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f1d5:	89 c6                	mov    %eax,%esi
  80f1d7:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f1da:	39 f0                	cmp    %esi,%eax
  80f1dc:	74 1c                	je     80f1fa <memcmp+0x30>
		if (*s1 != *s2)
  80f1de:	0f b6 08             	movzbl (%eax),%ecx
  80f1e1:	0f b6 1a             	movzbl (%edx),%ebx
  80f1e4:	38 d9                	cmp    %bl,%cl
  80f1e6:	75 08                	jne    80f1f0 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f1e8:	83 c0 01             	add    $0x1,%eax
  80f1eb:	83 c2 01             	add    $0x1,%edx
  80f1ee:	eb ea                	jmp    80f1da <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80f1f0:	0f b6 c1             	movzbl %cl,%eax
  80f1f3:	0f b6 db             	movzbl %bl,%ebx
  80f1f6:	29 d8                	sub    %ebx,%eax
  80f1f8:	eb 05                	jmp    80f1ff <memcmp+0x35>
	}

	return 0;
  80f1fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f1ff:	5b                   	pop    %ebx
  80f200:	5e                   	pop    %esi
  80f201:	5d                   	pop    %ebp
  80f202:	c3                   	ret    

0080f203 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f203:	55                   	push   %ebp
  80f204:	89 e5                	mov    %esp,%ebp
  80f206:	8b 45 08             	mov    0x8(%ebp),%eax
  80f209:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f20c:	89 c2                	mov    %eax,%edx
  80f20e:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f211:	39 d0                	cmp    %edx,%eax
  80f213:	73 09                	jae    80f21e <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f215:	38 08                	cmp    %cl,(%eax)
  80f217:	74 05                	je     80f21e <memfind+0x1b>
	for (; s < ends; s++)
  80f219:	83 c0 01             	add    $0x1,%eax
  80f21c:	eb f3                	jmp    80f211 <memfind+0xe>
			break;
	return (void *) s;
}
  80f21e:	5d                   	pop    %ebp
  80f21f:	c3                   	ret    

0080f220 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f220:	55                   	push   %ebp
  80f221:	89 e5                	mov    %esp,%ebp
  80f223:	57                   	push   %edi
  80f224:	56                   	push   %esi
  80f225:	53                   	push   %ebx
  80f226:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f229:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f22c:	eb 03                	jmp    80f231 <strtol+0x11>
		s++;
  80f22e:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f231:	0f b6 01             	movzbl (%ecx),%eax
  80f234:	3c 20                	cmp    $0x20,%al
  80f236:	74 f6                	je     80f22e <strtol+0xe>
  80f238:	3c 09                	cmp    $0x9,%al
  80f23a:	74 f2                	je     80f22e <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80f23c:	3c 2b                	cmp    $0x2b,%al
  80f23e:	74 2a                	je     80f26a <strtol+0x4a>
	int neg = 0;
  80f240:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f245:	3c 2d                	cmp    $0x2d,%al
  80f247:	74 2b                	je     80f274 <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f249:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f24f:	75 0f                	jne    80f260 <strtol+0x40>
  80f251:	80 39 30             	cmpb   $0x30,(%ecx)
  80f254:	74 28                	je     80f27e <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f256:	85 db                	test   %ebx,%ebx
  80f258:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f25d:	0f 44 d8             	cmove  %eax,%ebx
  80f260:	b8 00 00 00 00       	mov    $0x0,%eax
  80f265:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f268:	eb 50                	jmp    80f2ba <strtol+0x9a>
		s++;
  80f26a:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f26d:	bf 00 00 00 00       	mov    $0x0,%edi
  80f272:	eb d5                	jmp    80f249 <strtol+0x29>
		s++, neg = 1;
  80f274:	83 c1 01             	add    $0x1,%ecx
  80f277:	bf 01 00 00 00       	mov    $0x1,%edi
  80f27c:	eb cb                	jmp    80f249 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f27e:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f282:	74 0e                	je     80f292 <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80f284:	85 db                	test   %ebx,%ebx
  80f286:	75 d8                	jne    80f260 <strtol+0x40>
		s++, base = 8;
  80f288:	83 c1 01             	add    $0x1,%ecx
  80f28b:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f290:	eb ce                	jmp    80f260 <strtol+0x40>
		s += 2, base = 16;
  80f292:	83 c1 02             	add    $0x2,%ecx
  80f295:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f29a:	eb c4                	jmp    80f260 <strtol+0x40>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80f29c:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f29f:	89 f3                	mov    %esi,%ebx
  80f2a1:	80 fb 19             	cmp    $0x19,%bl
  80f2a4:	77 29                	ja     80f2cf <strtol+0xaf>
			dig = *s - 'a' + 10;
  80f2a6:	0f be d2             	movsbl %dl,%edx
  80f2a9:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f2ac:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f2af:	7d 30                	jge    80f2e1 <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80f2b1:	83 c1 01             	add    $0x1,%ecx
  80f2b4:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f2b8:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f2ba:	0f b6 11             	movzbl (%ecx),%edx
  80f2bd:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f2c0:	89 f3                	mov    %esi,%ebx
  80f2c2:	80 fb 09             	cmp    $0x9,%bl
  80f2c5:	77 d5                	ja     80f29c <strtol+0x7c>
			dig = *s - '0';
  80f2c7:	0f be d2             	movsbl %dl,%edx
  80f2ca:	83 ea 30             	sub    $0x30,%edx
  80f2cd:	eb dd                	jmp    80f2ac <strtol+0x8c>
		else if (*s >= 'A' && *s <= 'Z')
  80f2cf:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f2d2:	89 f3                	mov    %esi,%ebx
  80f2d4:	80 fb 19             	cmp    $0x19,%bl
  80f2d7:	77 08                	ja     80f2e1 <strtol+0xc1>
			dig = *s - 'A' + 10;
  80f2d9:	0f be d2             	movsbl %dl,%edx
  80f2dc:	83 ea 37             	sub    $0x37,%edx
  80f2df:	eb cb                	jmp    80f2ac <strtol+0x8c>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f2e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f2e5:	74 05                	je     80f2ec <strtol+0xcc>
		*endptr = (char *) s;
  80f2e7:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f2ea:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f2ec:	89 c2                	mov    %eax,%edx
  80f2ee:	f7 da                	neg    %edx
  80f2f0:	85 ff                	test   %edi,%edi
  80f2f2:	0f 45 c2             	cmovne %edx,%eax
}
  80f2f5:	5b                   	pop    %ebx
  80f2f6:	5e                   	pop    %esi
  80f2f7:	5f                   	pop    %edi
  80f2f8:	5d                   	pop    %ebp
  80f2f9:	c3                   	ret    

0080f2fa <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f2fa:	55                   	push   %ebp
  80f2fb:	89 e5                	mov    %esp,%ebp
  80f2fd:	57                   	push   %edi
  80f2fe:	56                   	push   %esi
  80f2ff:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f300:	b8 00 00 00 00       	mov    $0x0,%eax
  80f305:	8b 55 08             	mov    0x8(%ebp),%edx
  80f308:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f30b:	89 c3                	mov    %eax,%ebx
  80f30d:	89 c7                	mov    %eax,%edi
  80f30f:	89 c6                	mov    %eax,%esi
  80f311:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f313:	5b                   	pop    %ebx
  80f314:	5e                   	pop    %esi
  80f315:	5f                   	pop    %edi
  80f316:	5d                   	pop    %ebp
  80f317:	c3                   	ret    

0080f318 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f318:	55                   	push   %ebp
  80f319:	89 e5                	mov    %esp,%ebp
  80f31b:	57                   	push   %edi
  80f31c:	56                   	push   %esi
  80f31d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f31e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f323:	b8 01 00 00 00       	mov    $0x1,%eax
  80f328:	89 d1                	mov    %edx,%ecx
  80f32a:	89 d3                	mov    %edx,%ebx
  80f32c:	89 d7                	mov    %edx,%edi
  80f32e:	89 d6                	mov    %edx,%esi
  80f330:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f332:	5b                   	pop    %ebx
  80f333:	5e                   	pop    %esi
  80f334:	5f                   	pop    %edi
  80f335:	5d                   	pop    %ebp
  80f336:	c3                   	ret    

0080f337 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f337:	55                   	push   %ebp
  80f338:	89 e5                	mov    %esp,%ebp
  80f33a:	57                   	push   %edi
  80f33b:	56                   	push   %esi
  80f33c:	53                   	push   %ebx
  80f33d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f340:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f345:	8b 55 08             	mov    0x8(%ebp),%edx
  80f348:	b8 03 00 00 00       	mov    $0x3,%eax
  80f34d:	89 cb                	mov    %ecx,%ebx
  80f34f:	89 cf                	mov    %ecx,%edi
  80f351:	89 ce                	mov    %ecx,%esi
  80f353:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f355:	85 c0                	test   %eax,%eax
  80f357:	7f 08                	jg     80f361 <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f359:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f35c:	5b                   	pop    %ebx
  80f35d:	5e                   	pop    %esi
  80f35e:	5f                   	pop    %edi
  80f35f:	5d                   	pop    %ebp
  80f360:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f361:	83 ec 0c             	sub    $0xc,%esp
  80f364:	50                   	push   %eax
  80f365:	6a 03                	push   $0x3
  80f367:	68 a8 3d 81 00       	push   $0x813da8
  80f36c:	6a 43                	push   $0x43
  80f36e:	68 c5 3d 81 00       	push   $0x813dc5
  80f373:	e8 f7 f3 ff ff       	call   80e76f <_panic>

0080f378 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f378:	55                   	push   %ebp
  80f379:	89 e5                	mov    %esp,%ebp
  80f37b:	57                   	push   %edi
  80f37c:	56                   	push   %esi
  80f37d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f37e:	ba 00 00 00 00       	mov    $0x0,%edx
  80f383:	b8 02 00 00 00       	mov    $0x2,%eax
  80f388:	89 d1                	mov    %edx,%ecx
  80f38a:	89 d3                	mov    %edx,%ebx
  80f38c:	89 d7                	mov    %edx,%edi
  80f38e:	89 d6                	mov    %edx,%esi
  80f390:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f392:	5b                   	pop    %ebx
  80f393:	5e                   	pop    %esi
  80f394:	5f                   	pop    %edi
  80f395:	5d                   	pop    %ebp
  80f396:	c3                   	ret    

0080f397 <sys_yield>:

void
sys_yield(void)
{
  80f397:	55                   	push   %ebp
  80f398:	89 e5                	mov    %esp,%ebp
  80f39a:	57                   	push   %edi
  80f39b:	56                   	push   %esi
  80f39c:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f39d:	ba 00 00 00 00       	mov    $0x0,%edx
  80f3a2:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f3a7:	89 d1                	mov    %edx,%ecx
  80f3a9:	89 d3                	mov    %edx,%ebx
  80f3ab:	89 d7                	mov    %edx,%edi
  80f3ad:	89 d6                	mov    %edx,%esi
  80f3af:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f3b1:	5b                   	pop    %ebx
  80f3b2:	5e                   	pop    %esi
  80f3b3:	5f                   	pop    %edi
  80f3b4:	5d                   	pop    %ebp
  80f3b5:	c3                   	ret    

0080f3b6 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f3b6:	55                   	push   %ebp
  80f3b7:	89 e5                	mov    %esp,%ebp
  80f3b9:	57                   	push   %edi
  80f3ba:	56                   	push   %esi
  80f3bb:	53                   	push   %ebx
  80f3bc:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3bf:	be 00 00 00 00       	mov    $0x0,%esi
  80f3c4:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3ca:	b8 04 00 00 00       	mov    $0x4,%eax
  80f3cf:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f3d2:	89 f7                	mov    %esi,%edi
  80f3d4:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f3d6:	85 c0                	test   %eax,%eax
  80f3d8:	7f 08                	jg     80f3e2 <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f3da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3dd:	5b                   	pop    %ebx
  80f3de:	5e                   	pop    %esi
  80f3df:	5f                   	pop    %edi
  80f3e0:	5d                   	pop    %ebp
  80f3e1:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3e2:	83 ec 0c             	sub    $0xc,%esp
  80f3e5:	50                   	push   %eax
  80f3e6:	6a 04                	push   $0x4
  80f3e8:	68 a8 3d 81 00       	push   $0x813da8
  80f3ed:	6a 43                	push   $0x43
  80f3ef:	68 c5 3d 81 00       	push   $0x813dc5
  80f3f4:	e8 76 f3 ff ff       	call   80e76f <_panic>

0080f3f9 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f3f9:	55                   	push   %ebp
  80f3fa:	89 e5                	mov    %esp,%ebp
  80f3fc:	57                   	push   %edi
  80f3fd:	56                   	push   %esi
  80f3fe:	53                   	push   %ebx
  80f3ff:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f402:	8b 55 08             	mov    0x8(%ebp),%edx
  80f405:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f408:	b8 05 00 00 00       	mov    $0x5,%eax
  80f40d:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f410:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f413:	8b 75 18             	mov    0x18(%ebp),%esi
  80f416:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f418:	85 c0                	test   %eax,%eax
  80f41a:	7f 08                	jg     80f424 <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f41c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f41f:	5b                   	pop    %ebx
  80f420:	5e                   	pop    %esi
  80f421:	5f                   	pop    %edi
  80f422:	5d                   	pop    %ebp
  80f423:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f424:	83 ec 0c             	sub    $0xc,%esp
  80f427:	50                   	push   %eax
  80f428:	6a 05                	push   $0x5
  80f42a:	68 a8 3d 81 00       	push   $0x813da8
  80f42f:	6a 43                	push   $0x43
  80f431:	68 c5 3d 81 00       	push   $0x813dc5
  80f436:	e8 34 f3 ff ff       	call   80e76f <_panic>

0080f43b <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f43b:	55                   	push   %ebp
  80f43c:	89 e5                	mov    %esp,%ebp
  80f43e:	57                   	push   %edi
  80f43f:	56                   	push   %esi
  80f440:	53                   	push   %ebx
  80f441:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f444:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f449:	8b 55 08             	mov    0x8(%ebp),%edx
  80f44c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f44f:	b8 06 00 00 00       	mov    $0x6,%eax
  80f454:	89 df                	mov    %ebx,%edi
  80f456:	89 de                	mov    %ebx,%esi
  80f458:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f45a:	85 c0                	test   %eax,%eax
  80f45c:	7f 08                	jg     80f466 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f45e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f461:	5b                   	pop    %ebx
  80f462:	5e                   	pop    %esi
  80f463:	5f                   	pop    %edi
  80f464:	5d                   	pop    %ebp
  80f465:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f466:	83 ec 0c             	sub    $0xc,%esp
  80f469:	50                   	push   %eax
  80f46a:	6a 06                	push   $0x6
  80f46c:	68 a8 3d 81 00       	push   $0x813da8
  80f471:	6a 43                	push   $0x43
  80f473:	68 c5 3d 81 00       	push   $0x813dc5
  80f478:	e8 f2 f2 ff ff       	call   80e76f <_panic>

0080f47d <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f47d:	55                   	push   %ebp
  80f47e:	89 e5                	mov    %esp,%ebp
  80f480:	57                   	push   %edi
  80f481:	56                   	push   %esi
  80f482:	53                   	push   %ebx
  80f483:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f486:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f48b:	8b 55 08             	mov    0x8(%ebp),%edx
  80f48e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f491:	b8 08 00 00 00       	mov    $0x8,%eax
  80f496:	89 df                	mov    %ebx,%edi
  80f498:	89 de                	mov    %ebx,%esi
  80f49a:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f49c:	85 c0                	test   %eax,%eax
  80f49e:	7f 08                	jg     80f4a8 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f4a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4a3:	5b                   	pop    %ebx
  80f4a4:	5e                   	pop    %esi
  80f4a5:	5f                   	pop    %edi
  80f4a6:	5d                   	pop    %ebp
  80f4a7:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4a8:	83 ec 0c             	sub    $0xc,%esp
  80f4ab:	50                   	push   %eax
  80f4ac:	6a 08                	push   $0x8
  80f4ae:	68 a8 3d 81 00       	push   $0x813da8
  80f4b3:	6a 43                	push   $0x43
  80f4b5:	68 c5 3d 81 00       	push   $0x813dc5
  80f4ba:	e8 b0 f2 ff ff       	call   80e76f <_panic>

0080f4bf <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f4bf:	55                   	push   %ebp
  80f4c0:	89 e5                	mov    %esp,%ebp
  80f4c2:	57                   	push   %edi
  80f4c3:	56                   	push   %esi
  80f4c4:	53                   	push   %ebx
  80f4c5:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f4c8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4cd:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4d3:	b8 09 00 00 00       	mov    $0x9,%eax
  80f4d8:	89 df                	mov    %ebx,%edi
  80f4da:	89 de                	mov    %ebx,%esi
  80f4dc:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4de:	85 c0                	test   %eax,%eax
  80f4e0:	7f 08                	jg     80f4ea <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f4e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4e5:	5b                   	pop    %ebx
  80f4e6:	5e                   	pop    %esi
  80f4e7:	5f                   	pop    %edi
  80f4e8:	5d                   	pop    %ebp
  80f4e9:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4ea:	83 ec 0c             	sub    $0xc,%esp
  80f4ed:	50                   	push   %eax
  80f4ee:	6a 09                	push   $0x9
  80f4f0:	68 a8 3d 81 00       	push   $0x813da8
  80f4f5:	6a 43                	push   $0x43
  80f4f7:	68 c5 3d 81 00       	push   $0x813dc5
  80f4fc:	e8 6e f2 ff ff       	call   80e76f <_panic>

0080f501 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f501:	55                   	push   %ebp
  80f502:	89 e5                	mov    %esp,%ebp
  80f504:	57                   	push   %edi
  80f505:	56                   	push   %esi
  80f506:	53                   	push   %ebx
  80f507:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f50a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f50f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f512:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f515:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f51a:	89 df                	mov    %ebx,%edi
  80f51c:	89 de                	mov    %ebx,%esi
  80f51e:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f520:	85 c0                	test   %eax,%eax
  80f522:	7f 08                	jg     80f52c <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f524:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f527:	5b                   	pop    %ebx
  80f528:	5e                   	pop    %esi
  80f529:	5f                   	pop    %edi
  80f52a:	5d                   	pop    %ebp
  80f52b:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f52c:	83 ec 0c             	sub    $0xc,%esp
  80f52f:	50                   	push   %eax
  80f530:	6a 0a                	push   $0xa
  80f532:	68 a8 3d 81 00       	push   $0x813da8
  80f537:	6a 43                	push   $0x43
  80f539:	68 c5 3d 81 00       	push   $0x813dc5
  80f53e:	e8 2c f2 ff ff       	call   80e76f <_panic>

0080f543 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f543:	55                   	push   %ebp
  80f544:	89 e5                	mov    %esp,%ebp
  80f546:	57                   	push   %edi
  80f547:	56                   	push   %esi
  80f548:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f549:	8b 55 08             	mov    0x8(%ebp),%edx
  80f54c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f54f:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f554:	be 00 00 00 00       	mov    $0x0,%esi
  80f559:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f55c:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f55f:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f561:	5b                   	pop    %ebx
  80f562:	5e                   	pop    %esi
  80f563:	5f                   	pop    %edi
  80f564:	5d                   	pop    %ebp
  80f565:	c3                   	ret    

0080f566 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f566:	55                   	push   %ebp
  80f567:	89 e5                	mov    %esp,%ebp
  80f569:	57                   	push   %edi
  80f56a:	56                   	push   %esi
  80f56b:	53                   	push   %ebx
  80f56c:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f56f:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f574:	8b 55 08             	mov    0x8(%ebp),%edx
  80f577:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f57c:	89 cb                	mov    %ecx,%ebx
  80f57e:	89 cf                	mov    %ecx,%edi
  80f580:	89 ce                	mov    %ecx,%esi
  80f582:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f584:	85 c0                	test   %eax,%eax
  80f586:	7f 08                	jg     80f590 <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f588:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f58b:	5b                   	pop    %ebx
  80f58c:	5e                   	pop    %esi
  80f58d:	5f                   	pop    %edi
  80f58e:	5d                   	pop    %ebp
  80f58f:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f590:	83 ec 0c             	sub    $0xc,%esp
  80f593:	50                   	push   %eax
  80f594:	6a 0d                	push   $0xd
  80f596:	68 a8 3d 81 00       	push   $0x813da8
  80f59b:	6a 43                	push   $0x43
  80f59d:	68 c5 3d 81 00       	push   $0x813dc5
  80f5a2:	e8 c8 f1 ff ff       	call   80e76f <_panic>

0080f5a7 <sys_map_kernel_page>:

int
sys_map_kernel_page(void* kpage, void* va)
{
  80f5a7:	55                   	push   %ebp
  80f5a8:	89 e5                	mov    %esp,%ebp
  80f5aa:	57                   	push   %edi
  80f5ab:	56                   	push   %esi
  80f5ac:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5ad:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f5b2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5b5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5b8:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f5bd:	89 df                	mov    %ebx,%edi
  80f5bf:	89 de                	mov    %ebx,%esi
  80f5c1:	cd 30                	int    $0x30
	return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}
  80f5c3:	5b                   	pop    %ebx
  80f5c4:	5e                   	pop    %esi
  80f5c5:	5f                   	pop    %edi
  80f5c6:	5d                   	pop    %ebp
  80f5c7:	c3                   	ret    

0080f5c8 <sys_sbrk>:

int
sys_sbrk(uint32_t inc)
{
  80f5c8:	55                   	push   %ebp
  80f5c9:	89 e5                	mov    %esp,%ebp
  80f5cb:	57                   	push   %edi
  80f5cc:	56                   	push   %esi
  80f5cd:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5ce:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f5d3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5d6:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f5db:	89 cb                	mov    %ecx,%ebx
  80f5dd:	89 cf                	mov    %ecx,%edi
  80f5df:	89 ce                	mov    %ecx,%esi
  80f5e1:	cd 30                	int    $0x30
	return syscall(SYS_sbrk, 0, (uint32_t)inc, (uint32_t)0, 0, 0, 0);
}
  80f5e3:	5b                   	pop    %ebx
  80f5e4:	5e                   	pop    %esi
  80f5e5:	5f                   	pop    %edi
  80f5e6:	5d                   	pop    %ebp
  80f5e7:	c3                   	ret    

0080f5e8 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f5e8:	55                   	push   %ebp
  80f5e9:	89 e5                	mov    %esp,%ebp
  80f5eb:	57                   	push   %edi
  80f5ec:	56                   	push   %esi
  80f5ed:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5ee:	ba 00 00 00 00       	mov    $0x0,%edx
  80f5f3:	b8 10 00 00 00       	mov    $0x10,%eax
  80f5f8:	89 d1                	mov    %edx,%ecx
  80f5fa:	89 d3                	mov    %edx,%ebx
  80f5fc:	89 d7                	mov    %edx,%edi
  80f5fe:	89 d6                	mov    %edx,%esi
  80f600:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f602:	5b                   	pop    %ebx
  80f603:	5e                   	pop    %esi
  80f604:	5f                   	pop    %edi
  80f605:	5d                   	pop    %ebp
  80f606:	c3                   	ret    

0080f607 <sys_net_send>:

int
sys_net_send(const void *buf, uint32_t len)
{
  80f607:	55                   	push   %ebp
  80f608:	89 e5                	mov    %esp,%ebp
  80f60a:	57                   	push   %edi
  80f60b:	56                   	push   %esi
  80f60c:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f60d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f612:	8b 55 08             	mov    0x8(%ebp),%edx
  80f615:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f618:	b8 11 00 00 00       	mov    $0x11,%eax
  80f61d:	89 df                	mov    %ebx,%edi
  80f61f:	89 de                	mov    %ebx,%esi
  80f621:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_send, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f623:	5b                   	pop    %ebx
  80f624:	5e                   	pop    %esi
  80f625:	5f                   	pop    %edi
  80f626:	5d                   	pop    %ebp
  80f627:	c3                   	ret    

0080f628 <sys_net_recv>:

int
sys_net_recv(void *buf, uint32_t len)
{
  80f628:	55                   	push   %ebp
  80f629:	89 e5                	mov    %esp,%ebp
  80f62b:	57                   	push   %edi
  80f62c:	56                   	push   %esi
  80f62d:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f62e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f633:	8b 55 08             	mov    0x8(%ebp),%edx
  80f636:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f639:	b8 12 00 00 00       	mov    $0x12,%eax
  80f63e:	89 df                	mov    %ebx,%edi
  80f640:	89 de                	mov    %ebx,%esi
  80f642:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_recv, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f644:	5b                   	pop    %ebx
  80f645:	5e                   	pop    %esi
  80f646:	5f                   	pop    %edi
  80f647:	5d                   	pop    %ebp
  80f648:	c3                   	ret    

0080f649 <sys_clear_access_bit>:
int
sys_clear_access_bit(envid_t envid, void *va)
{
  80f649:	55                   	push   %ebp
  80f64a:	89 e5                	mov    %esp,%ebp
  80f64c:	57                   	push   %edi
  80f64d:	56                   	push   %esi
  80f64e:	53                   	push   %ebx
  80f64f:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f652:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f657:	8b 55 08             	mov    0x8(%ebp),%edx
  80f65a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f65d:	b8 13 00 00 00       	mov    $0x13,%eax
  80f662:	89 df                	mov    %ebx,%edi
  80f664:	89 de                	mov    %ebx,%esi
  80f666:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f668:	85 c0                	test   %eax,%eax
  80f66a:	7f 08                	jg     80f674 <sys_clear_access_bit+0x2b>
	return syscall(SYS_clear_access_bit, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f66c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f66f:	5b                   	pop    %ebx
  80f670:	5e                   	pop    %esi
  80f671:	5f                   	pop    %edi
  80f672:	5d                   	pop    %ebp
  80f673:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f674:	83 ec 0c             	sub    $0xc,%esp
  80f677:	50                   	push   %eax
  80f678:	6a 13                	push   $0x13
  80f67a:	68 a8 3d 81 00       	push   $0x813da8
  80f67f:	6a 43                	push   $0x43
  80f681:	68 c5 3d 81 00       	push   $0x813dc5
  80f686:	e8 e4 f0 ff ff       	call   80e76f <_panic>

0080f68b <sys_get_mac_addr>:

void
sys_get_mac_addr(uint64_t *mac_addr_store)
{
  80f68b:	55                   	push   %ebp
  80f68c:	89 e5                	mov    %esp,%ebp
  80f68e:	57                   	push   %edi
  80f68f:	56                   	push   %esi
  80f690:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f691:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f696:	8b 55 08             	mov    0x8(%ebp),%edx
  80f699:	b8 14 00 00 00       	mov    $0x14,%eax
  80f69e:	89 cb                	mov    %ecx,%ebx
  80f6a0:	89 cf                	mov    %ecx,%edi
  80f6a2:	89 ce                	mov    %ecx,%esi
  80f6a4:	cd 30                	int    $0x30
    syscall(SYS_get_mac_addr, 0, (uint32_t) mac_addr_store, 0, 0, 0, 0);
  80f6a6:	5b                   	pop    %ebx
  80f6a7:	5e                   	pop    %esi
  80f6a8:	5f                   	pop    %edi
  80f6a9:	5d                   	pop    %ebp
  80f6aa:	c3                   	ret    

0080f6ab <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  80f6ab:	55                   	push   %ebp
  80f6ac:	89 e5                	mov    %esp,%ebp
  80f6ae:	53                   	push   %ebx
  80f6af:	83 ec 04             	sub    $0x4,%esp
	int r;
	//lab5 bug?
	if((uvpt[pn]) & PTE_SHARE){
  80f6b2:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f6b9:	f6 c5 04             	test   $0x4,%ch
  80f6bc:	75 45                	jne    80f703 <duppage+0x58>
							uvpt[pn] & PTE_SYSCALL);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_W)) == (PTE_P | PTE_U | PTE_W)){
  80f6be:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f6c5:	83 e1 07             	and    $0x7,%ecx
  80f6c8:	83 f9 07             	cmp    $0x7,%ecx
  80f6cb:	74 6f                	je     80f73c <duppage+0x91>
						 PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_COW)) == (PTE_P | PTE_U | PTE_COW)){
  80f6cd:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f6d4:	81 e1 05 08 00 00    	and    $0x805,%ecx
  80f6da:	81 f9 05 08 00 00    	cmp    $0x805,%ecx
  80f6e0:	0f 84 b6 00 00 00    	je     80f79c <duppage+0xf1>
						PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U)) == (PTE_P | PTE_U)){
  80f6e6:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f6ed:	83 e1 05             	and    $0x5,%ecx
  80f6f0:	83 f9 05             	cmp    $0x5,%ecx
  80f6f3:	0f 84 d7 00 00 00    	je     80f7d0 <duppage+0x125>
	}

	// LAB 4: Your code here.
	// panic("duppage not implemented");
	return 0;
}
  80f6f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80f6fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f701:	c9                   	leave  
  80f702:	c3                   	ret    
							uvpt[pn] & PTE_SYSCALL);
  80f703:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f70a:	c1 e2 0c             	shl    $0xc,%edx
  80f70d:	83 ec 0c             	sub    $0xc,%esp
  80f710:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  80f716:	51                   	push   %ecx
  80f717:	52                   	push   %edx
  80f718:	50                   	push   %eax
  80f719:	52                   	push   %edx
  80f71a:	6a 00                	push   $0x0
  80f71c:	e8 d8 fc ff ff       	call   80f3f9 <sys_page_map>
		if(r < 0)
  80f721:	83 c4 20             	add    $0x20,%esp
  80f724:	85 c0                	test   %eax,%eax
  80f726:	79 d1                	jns    80f6f9 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f728:	83 ec 04             	sub    $0x4,%esp
  80f72b:	68 d3 3d 81 00       	push   $0x813dd3
  80f730:	6a 54                	push   $0x54
  80f732:	68 e9 3d 81 00       	push   $0x813de9
  80f737:	e8 33 f0 ff ff       	call   80e76f <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f73c:	89 d3                	mov    %edx,%ebx
  80f73e:	c1 e3 0c             	shl    $0xc,%ebx
  80f741:	83 ec 0c             	sub    $0xc,%esp
  80f744:	68 05 08 00 00       	push   $0x805
  80f749:	53                   	push   %ebx
  80f74a:	50                   	push   %eax
  80f74b:	53                   	push   %ebx
  80f74c:	6a 00                	push   $0x0
  80f74e:	e8 a6 fc ff ff       	call   80f3f9 <sys_page_map>
		if(r < 0)
  80f753:	83 c4 20             	add    $0x20,%esp
  80f756:	85 c0                	test   %eax,%eax
  80f758:	78 2e                	js     80f788 <duppage+0xdd>
		r = sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE),
  80f75a:	83 ec 0c             	sub    $0xc,%esp
  80f75d:	68 05 08 00 00       	push   $0x805
  80f762:	53                   	push   %ebx
  80f763:	6a 00                	push   $0x0
  80f765:	53                   	push   %ebx
  80f766:	6a 00                	push   $0x0
  80f768:	e8 8c fc ff ff       	call   80f3f9 <sys_page_map>
		if(r < 0)
  80f76d:	83 c4 20             	add    $0x20,%esp
  80f770:	85 c0                	test   %eax,%eax
  80f772:	79 85                	jns    80f6f9 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f774:	83 ec 04             	sub    $0x4,%esp
  80f777:	68 d3 3d 81 00       	push   $0x813dd3
  80f77c:	6a 5f                	push   $0x5f
  80f77e:	68 e9 3d 81 00       	push   $0x813de9
  80f783:	e8 e7 ef ff ff       	call   80e76f <_panic>
			panic("sys_page_map() panic\n");
  80f788:	83 ec 04             	sub    $0x4,%esp
  80f78b:	68 d3 3d 81 00       	push   $0x813dd3
  80f790:	6a 5b                	push   $0x5b
  80f792:	68 e9 3d 81 00       	push   $0x813de9
  80f797:	e8 d3 ef ff ff       	call   80e76f <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f79c:	c1 e2 0c             	shl    $0xc,%edx
  80f79f:	83 ec 0c             	sub    $0xc,%esp
  80f7a2:	68 05 08 00 00       	push   $0x805
  80f7a7:	52                   	push   %edx
  80f7a8:	50                   	push   %eax
  80f7a9:	52                   	push   %edx
  80f7aa:	6a 00                	push   $0x0
  80f7ac:	e8 48 fc ff ff       	call   80f3f9 <sys_page_map>
		if(r < 0)
  80f7b1:	83 c4 20             	add    $0x20,%esp
  80f7b4:	85 c0                	test   %eax,%eax
  80f7b6:	0f 89 3d ff ff ff    	jns    80f6f9 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f7bc:	83 ec 04             	sub    $0x4,%esp
  80f7bf:	68 d3 3d 81 00       	push   $0x813dd3
  80f7c4:	6a 66                	push   $0x66
  80f7c6:	68 e9 3d 81 00       	push   $0x813de9
  80f7cb:	e8 9f ef ff ff       	call   80e76f <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f7d0:	c1 e2 0c             	shl    $0xc,%edx
  80f7d3:	83 ec 0c             	sub    $0xc,%esp
  80f7d6:	6a 05                	push   $0x5
  80f7d8:	52                   	push   %edx
  80f7d9:	50                   	push   %eax
  80f7da:	52                   	push   %edx
  80f7db:	6a 00                	push   $0x0
  80f7dd:	e8 17 fc ff ff       	call   80f3f9 <sys_page_map>
		if(r < 0)
  80f7e2:	83 c4 20             	add    $0x20,%esp
  80f7e5:	85 c0                	test   %eax,%eax
  80f7e7:	0f 89 0c ff ff ff    	jns    80f6f9 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f7ed:	83 ec 04             	sub    $0x4,%esp
  80f7f0:	68 d3 3d 81 00       	push   $0x813dd3
  80f7f5:	6a 6d                	push   $0x6d
  80f7f7:	68 e9 3d 81 00       	push   $0x813de9
  80f7fc:	e8 6e ef ff ff       	call   80e76f <_panic>

0080f801 <pgfault>:
{
  80f801:	55                   	push   %ebp
  80f802:	89 e5                	mov    %esp,%ebp
  80f804:	53                   	push   %ebx
  80f805:	83 ec 04             	sub    $0x4,%esp
  80f808:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80f80b:	8b 02                	mov    (%edx),%eax
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f80d:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80f811:	0f 84 99 00 00 00    	je     80f8b0 <pgfault+0xaf>
  80f817:	89 c2                	mov    %eax,%edx
  80f819:	c1 ea 16             	shr    $0x16,%edx
  80f81c:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f823:	f6 c2 01             	test   $0x1,%dl
  80f826:	0f 84 84 00 00 00    	je     80f8b0 <pgfault+0xaf>
		((uvpt[PGNUM(addr)] & (PTE_P | PTE_COW)) 
  80f82c:	89 c2                	mov    %eax,%edx
  80f82e:	c1 ea 0c             	shr    $0xc,%edx
  80f831:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f838:	81 e2 01 08 00 00    	and    $0x801,%edx
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f83e:	81 fa 01 08 00 00    	cmp    $0x801,%edx
  80f844:	75 6a                	jne    80f8b0 <pgfault+0xaf>
	addr = ROUNDDOWN(addr, PGSIZE);
  80f846:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f84b:	89 c3                	mov    %eax,%ebx
	ret = sys_page_alloc(0, (void *)PFTEMP, PTE_P | PTE_U | PTE_W);
  80f84d:	83 ec 04             	sub    $0x4,%esp
  80f850:	6a 07                	push   $0x7
  80f852:	68 00 f0 7f 00       	push   $0x7ff000
  80f857:	6a 00                	push   $0x0
  80f859:	e8 58 fb ff ff       	call   80f3b6 <sys_page_alloc>
	if(ret < 0)
  80f85e:	83 c4 10             	add    $0x10,%esp
  80f861:	85 c0                	test   %eax,%eax
  80f863:	78 5f                	js     80f8c4 <pgfault+0xc3>
	memcpy((void *)PFTEMP, (void *)addr, PGSIZE);
  80f865:	83 ec 04             	sub    $0x4,%esp
  80f868:	68 00 10 00 00       	push   $0x1000
  80f86d:	53                   	push   %ebx
  80f86e:	68 00 f0 7f 00       	push   $0x7ff000
  80f873:	e8 3c f9 ff ff       	call   80f1b4 <memcpy>
	ret = sys_page_map(0, PFTEMP, 0, addr,  PTE_P | PTE_U | PTE_W);
  80f878:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f87f:	53                   	push   %ebx
  80f880:	6a 00                	push   $0x0
  80f882:	68 00 f0 7f 00       	push   $0x7ff000
  80f887:	6a 00                	push   $0x0
  80f889:	e8 6b fb ff ff       	call   80f3f9 <sys_page_map>
	if(ret < 0)
  80f88e:	83 c4 20             	add    $0x20,%esp
  80f891:	85 c0                	test   %eax,%eax
  80f893:	78 43                	js     80f8d8 <pgfault+0xd7>
	ret = sys_page_unmap(0, (void *)PFTEMP);
  80f895:	83 ec 08             	sub    $0x8,%esp
  80f898:	68 00 f0 7f 00       	push   $0x7ff000
  80f89d:	6a 00                	push   $0x0
  80f89f:	e8 97 fb ff ff       	call   80f43b <sys_page_unmap>
	if(ret < 0)
  80f8a4:	83 c4 10             	add    $0x10,%esp
  80f8a7:	85 c0                	test   %eax,%eax
  80f8a9:	78 41                	js     80f8ec <pgfault+0xeb>
}
  80f8ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f8ae:	c9                   	leave  
  80f8af:	c3                   	ret    
		panic("panic at pgfault()\n");
  80f8b0:	83 ec 04             	sub    $0x4,%esp
  80f8b3:	68 f4 3d 81 00       	push   $0x813df4
  80f8b8:	6a 26                	push   $0x26
  80f8ba:	68 e9 3d 81 00       	push   $0x813de9
  80f8bf:	e8 ab ee ff ff       	call   80e76f <_panic>
		panic("panic in sys_page_alloc()\n");
  80f8c4:	83 ec 04             	sub    $0x4,%esp
  80f8c7:	68 08 3e 81 00       	push   $0x813e08
  80f8cc:	6a 31                	push   $0x31
  80f8ce:	68 e9 3d 81 00       	push   $0x813de9
  80f8d3:	e8 97 ee ff ff       	call   80e76f <_panic>
		panic("panic in sys_page_map()\n");
  80f8d8:	83 ec 04             	sub    $0x4,%esp
  80f8db:	68 23 3e 81 00       	push   $0x813e23
  80f8e0:	6a 36                	push   $0x36
  80f8e2:	68 e9 3d 81 00       	push   $0x813de9
  80f8e7:	e8 83 ee ff ff       	call   80e76f <_panic>
		panic("panic in sys_page_unmap()\n");
  80f8ec:	83 ec 04             	sub    $0x4,%esp
  80f8ef:	68 3c 3e 81 00       	push   $0x813e3c
  80f8f4:	6a 39                	push   $0x39
  80f8f6:	68 e9 3d 81 00       	push   $0x813de9
  80f8fb:	e8 6f ee ff ff       	call   80e76f <_panic>

0080f900 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f900:	55                   	push   %ebp
  80f901:	89 e5                	mov    %esp,%ebp
  80f903:	57                   	push   %edi
  80f904:	56                   	push   %esi
  80f905:	53                   	push   %ebx
  80f906:	83 ec 18             	sub    $0x18,%esp
	int ret;
	set_pgfault_handler(pgfault);
  80f909:	68 01 f8 80 00       	push   $0x80f801
  80f90e:	e8 6a 17 00 00       	call   81107d <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f913:	b8 07 00 00 00       	mov    $0x7,%eax
  80f918:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f91a:	83 c4 10             	add    $0x10,%esp
  80f91d:	85 c0                	test   %eax,%eax
  80f91f:	78 27                	js     80f948 <fork+0x48>
  80f921:	89 c6                	mov    %eax,%esi
  80f923:	89 c7                	mov    %eax,%edi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f925:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f92a:	75 48                	jne    80f974 <fork+0x74>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f92c:	e8 47 fa ff ff       	call   80f378 <sys_getenvid>
  80f931:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f936:	c1 e0 07             	shl    $0x7,%eax
  80f939:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f93e:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
		return 0;
  80f943:	e9 90 00 00 00       	jmp    80f9d8 <fork+0xd8>
		panic("the fork panic! at sys_exofork()\n");
  80f948:	83 ec 04             	sub    $0x4,%esp
  80f94b:	68 58 3e 81 00       	push   $0x813e58
  80f950:	68 8c 00 00 00       	push   $0x8c
  80f955:	68 e9 3d 81 00       	push   $0x813de9
  80f95a:	e8 10 ee ff ff       	call   80e76f <_panic>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
			duppage(child_envid, PGNUM(i));
  80f95f:	89 f8                	mov    %edi,%eax
  80f961:	e8 45 fd ff ff       	call   80f6ab <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f966:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f96c:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f972:	74 26                	je     80f99a <fork+0x9a>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
  80f974:	89 d8                	mov    %ebx,%eax
  80f976:	c1 e8 16             	shr    $0x16,%eax
  80f979:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f980:	a8 01                	test   $0x1,%al
  80f982:	74 e2                	je     80f966 <fork+0x66>
  80f984:	89 da                	mov    %ebx,%edx
  80f986:	c1 ea 0c             	shr    $0xc,%edx
  80f989:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f990:	83 e0 05             	and    $0x5,%eax
  80f993:	83 f8 05             	cmp    $0x5,%eax
  80f996:	75 ce                	jne    80f966 <fork+0x66>
  80f998:	eb c5                	jmp    80f95f <fork+0x5f>
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80f99a:	83 ec 04             	sub    $0x4,%esp
  80f99d:	6a 07                	push   $0x7
  80f99f:	68 00 f0 bf ee       	push   $0xeebff000
  80f9a4:	56                   	push   %esi
  80f9a5:	e8 0c fa ff ff       	call   80f3b6 <sys_page_alloc>
	if(ret < 0)
  80f9aa:	83 c4 10             	add    $0x10,%esp
  80f9ad:	85 c0                	test   %eax,%eax
  80f9af:	78 31                	js     80f9e2 <fork+0xe2>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80f9b1:	83 ec 08             	sub    $0x8,%esp
  80f9b4:	68 ec 10 81 00       	push   $0x8110ec
  80f9b9:	56                   	push   %esi
  80f9ba:	e8 42 fb ff ff       	call   80f501 <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80f9bf:	83 c4 10             	add    $0x10,%esp
  80f9c2:	85 c0                	test   %eax,%eax
  80f9c4:	78 33                	js     80f9f9 <fork+0xf9>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80f9c6:	83 ec 08             	sub    $0x8,%esp
  80f9c9:	6a 02                	push   $0x2
  80f9cb:	56                   	push   %esi
  80f9cc:	e8 ac fa ff ff       	call   80f47d <sys_env_set_status>
	if(ret < 0)
  80f9d1:	83 c4 10             	add    $0x10,%esp
  80f9d4:	85 c0                	test   %eax,%eax
  80f9d6:	78 38                	js     80fa10 <fork+0x110>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
	// LAB 4: Your code here.
	// panic("fork not implemented");
}
  80f9d8:	89 f0                	mov    %esi,%eax
  80f9da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f9dd:	5b                   	pop    %ebx
  80f9de:	5e                   	pop    %esi
  80f9df:	5f                   	pop    %edi
  80f9e0:	5d                   	pop    %ebp
  80f9e1:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80f9e2:	83 ec 04             	sub    $0x4,%esp
  80f9e5:	68 08 3e 81 00       	push   $0x813e08
  80f9ea:	68 98 00 00 00       	push   $0x98
  80f9ef:	68 e9 3d 81 00       	push   $0x813de9
  80f9f4:	e8 76 ed ff ff       	call   80e76f <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80f9f9:	83 ec 04             	sub    $0x4,%esp
  80f9fc:	68 7c 3e 81 00       	push   $0x813e7c
  80fa01:	68 9b 00 00 00       	push   $0x9b
  80fa06:	68 e9 3d 81 00       	push   $0x813de9
  80fa0b:	e8 5f ed ff ff       	call   80e76f <_panic>
		panic("panic in sys_env_set_status()\n");
  80fa10:	83 ec 04             	sub    $0x4,%esp
  80fa13:	68 a4 3e 81 00       	push   $0x813ea4
  80fa18:	68 9e 00 00 00       	push   $0x9e
  80fa1d:	68 e9 3d 81 00       	push   $0x813de9
  80fa22:	e8 48 ed ff ff       	call   80e76f <_panic>

0080fa27 <sfork>:

// Challenge!
int
sfork(void)
{
  80fa27:	55                   	push   %ebp
  80fa28:	89 e5                	mov    %esp,%ebp
  80fa2a:	57                   	push   %edi
  80fa2b:	56                   	push   %esi
  80fa2c:	53                   	push   %ebx
  80fa2d:	83 ec 18             	sub    $0x18,%esp
	// panic("sfork not implemented");
	// envid_t child_envid = sys_exofork();
	// return -E_INVAL;
	int ret;
	set_pgfault_handler(pgfault);
  80fa30:	68 01 f8 80 00       	push   $0x80f801
  80fa35:	e8 43 16 00 00       	call   81107d <set_pgfault_handler>
  80fa3a:	b8 07 00 00 00       	mov    $0x7,%eax
  80fa3f:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80fa41:	83 c4 10             	add    $0x10,%esp
  80fa44:	85 c0                	test   %eax,%eax
  80fa46:	78 27                	js     80fa6f <sfork+0x48>
  80fa48:	89 c7                	mov    %eax,%edi
  80fa4a:	89 c6                	mov    %eax,%esi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80fa4c:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80fa51:	75 55                	jne    80faa8 <sfork+0x81>
		thisenv = &envs[ENVX(sys_getenvid())];
  80fa53:	e8 20 f9 ff ff       	call   80f378 <sys_getenvid>
  80fa58:	25 ff 03 00 00       	and    $0x3ff,%eax
  80fa5d:	c1 e0 07             	shl    $0x7,%eax
  80fa60:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fa65:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
		return 0;
  80fa6a:	e9 d4 00 00 00       	jmp    80fb43 <sfork+0x11c>
		panic("the fork panic! at sys_exofork()\n");
  80fa6f:	83 ec 04             	sub    $0x4,%esp
  80fa72:	68 58 3e 81 00       	push   $0x813e58
  80fa77:	68 af 00 00 00       	push   $0xaf
  80fa7c:	68 e9 3d 81 00       	push   $0x813de9
  80fa81:	e8 e9 ec ff ff       	call   80e76f <_panic>
		if(i == (USTACKTOP - PGSIZE))
			duppage(child_envid, PGNUM(i));
  80fa86:	ba fd eb 0e 00       	mov    $0xeebfd,%edx
  80fa8b:	89 f0                	mov    %esi,%eax
  80fa8d:	e8 19 fc ff ff       	call   80f6ab <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80fa92:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80fa98:	81 fb ff df bf ee    	cmp    $0xeebfdfff,%ebx
  80fa9e:	77 65                	ja     80fb05 <sfork+0xde>
		if(i == (USTACKTOP - PGSIZE))
  80faa0:	81 fb 00 d0 bf ee    	cmp    $0xeebfd000,%ebx
  80faa6:	74 de                	je     80fa86 <sfork+0x5f>
		else if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U))){
  80faa8:	89 d8                	mov    %ebx,%eax
  80faaa:	c1 e8 16             	shr    $0x16,%eax
  80faad:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fab4:	a8 01                	test   $0x1,%al
  80fab6:	74 da                	je     80fa92 <sfork+0x6b>
  80fab8:	89 da                	mov    %ebx,%edx
  80faba:	c1 ea 0c             	shr    $0xc,%edx
  80fabd:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80fac4:	83 e0 05             	and    $0x5,%eax
  80fac7:	83 f8 05             	cmp    $0x5,%eax
  80faca:	75 c6                	jne    80fa92 <sfork+0x6b>
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
						((uvpt[PGNUM(i)] & (PTE_P | PTE_U | PTE_W)))))
  80facc:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
  80fad3:	c1 e2 0c             	shl    $0xc,%edx
  80fad6:	83 ec 0c             	sub    $0xc,%esp
  80fad9:	83 e0 07             	and    $0x7,%eax
  80fadc:	50                   	push   %eax
  80fadd:	52                   	push   %edx
  80fade:	56                   	push   %esi
  80fadf:	52                   	push   %edx
  80fae0:	6a 00                	push   $0x0
  80fae2:	e8 12 f9 ff ff       	call   80f3f9 <sys_page_map>
  80fae7:	83 c4 20             	add    $0x20,%esp
  80faea:	85 c0                	test   %eax,%eax
  80faec:	74 a4                	je     80fa92 <sfork+0x6b>
				panic("sys_page_map() panic\n");
  80faee:	83 ec 04             	sub    $0x4,%esp
  80faf1:	68 d3 3d 81 00       	push   $0x813dd3
  80faf6:	68 ba 00 00 00       	push   $0xba
  80fafb:	68 e9 3d 81 00       	push   $0x813de9
  80fb00:	e8 6a ec ff ff       	call   80e76f <_panic>
		}
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80fb05:	83 ec 04             	sub    $0x4,%esp
  80fb08:	6a 07                	push   $0x7
  80fb0a:	68 00 f0 bf ee       	push   $0xeebff000
  80fb0f:	57                   	push   %edi
  80fb10:	e8 a1 f8 ff ff       	call   80f3b6 <sys_page_alloc>
	if(ret < 0)
  80fb15:	83 c4 10             	add    $0x10,%esp
  80fb18:	85 c0                	test   %eax,%eax
  80fb1a:	78 31                	js     80fb4d <sfork+0x126>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80fb1c:	83 ec 08             	sub    $0x8,%esp
  80fb1f:	68 ec 10 81 00       	push   $0x8110ec
  80fb24:	57                   	push   %edi
  80fb25:	e8 d7 f9 ff ff       	call   80f501 <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80fb2a:	83 c4 10             	add    $0x10,%esp
  80fb2d:	85 c0                	test   %eax,%eax
  80fb2f:	78 33                	js     80fb64 <sfork+0x13d>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80fb31:	83 ec 08             	sub    $0x8,%esp
  80fb34:	6a 02                	push   $0x2
  80fb36:	57                   	push   %edi
  80fb37:	e8 41 f9 ff ff       	call   80f47d <sys_env_set_status>
	if(ret < 0)
  80fb3c:	83 c4 10             	add    $0x10,%esp
  80fb3f:	85 c0                	test   %eax,%eax
  80fb41:	78 38                	js     80fb7b <sfork+0x154>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
  80fb43:	89 f8                	mov    %edi,%eax
  80fb45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fb48:	5b                   	pop    %ebx
  80fb49:	5e                   	pop    %esi
  80fb4a:	5f                   	pop    %edi
  80fb4b:	5d                   	pop    %ebp
  80fb4c:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80fb4d:	83 ec 04             	sub    $0x4,%esp
  80fb50:	68 08 3e 81 00       	push   $0x813e08
  80fb55:	68 c0 00 00 00       	push   $0xc0
  80fb5a:	68 e9 3d 81 00       	push   $0x813de9
  80fb5f:	e8 0b ec ff ff       	call   80e76f <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80fb64:	83 ec 04             	sub    $0x4,%esp
  80fb67:	68 7c 3e 81 00       	push   $0x813e7c
  80fb6c:	68 c3 00 00 00       	push   $0xc3
  80fb71:	68 e9 3d 81 00       	push   $0x813de9
  80fb76:	e8 f4 eb ff ff       	call   80e76f <_panic>
		panic("panic in sys_env_set_status()\n");
  80fb7b:	83 ec 04             	sub    $0x4,%esp
  80fb7e:	68 a4 3e 81 00       	push   $0x813ea4
  80fb83:	68 c6 00 00 00       	push   $0xc6
  80fb88:	68 e9 3d 81 00       	push   $0x813de9
  80fb8d:	e8 dd eb ff ff       	call   80e76f <_panic>

0080fb92 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80fb92:	55                   	push   %ebp
  80fb93:	89 e5                	mov    %esp,%ebp
  80fb95:	56                   	push   %esi
  80fb96:	53                   	push   %ebx
  80fb97:	8b 75 08             	mov    0x8(%ebp),%esi
  80fb9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fb9d:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");
	int ret;
	if(!pg)
  80fba0:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80fba2:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80fba7:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  80fbaa:	83 ec 0c             	sub    $0xc,%esp
  80fbad:	50                   	push   %eax
  80fbae:	e8 b3 f9 ff ff       	call   80f566 <sys_ipc_recv>
	if(ret < 0){
  80fbb3:	83 c4 10             	add    $0x10,%esp
  80fbb6:	85 c0                	test   %eax,%eax
  80fbb8:	78 2b                	js     80fbe5 <ipc_recv+0x53>
			*from_env_store = 0;
		if(perm_store)
			*perm_store = 0;
		return ret;
	}
	if(from_env_store){
  80fbba:	85 f6                	test   %esi,%esi
  80fbbc:	74 0a                	je     80fbc8 <ipc_recv+0x36>
		*from_env_store = thisenv->env_ipc_from;
  80fbbe:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fbc3:	8b 40 74             	mov    0x74(%eax),%eax
  80fbc6:	89 06                	mov    %eax,(%esi)
	}
	if(perm_store){
  80fbc8:	85 db                	test   %ebx,%ebx
  80fbca:	74 0a                	je     80fbd6 <ipc_recv+0x44>
		*perm_store = thisenv->env_ipc_perm;
  80fbcc:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fbd1:	8b 40 78             	mov    0x78(%eax),%eax
  80fbd4:	89 03                	mov    %eax,(%ebx)
	}
	return thisenv->env_ipc_value;
  80fbd6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fbdb:	8b 40 70             	mov    0x70(%eax),%eax
}
  80fbde:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fbe1:	5b                   	pop    %ebx
  80fbe2:	5e                   	pop    %esi
  80fbe3:	5d                   	pop    %ebp
  80fbe4:	c3                   	ret    
		if(from_env_store)
  80fbe5:	85 f6                	test   %esi,%esi
  80fbe7:	74 06                	je     80fbef <ipc_recv+0x5d>
			*from_env_store = 0;
  80fbe9:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store)
  80fbef:	85 db                	test   %ebx,%ebx
  80fbf1:	74 eb                	je     80fbde <ipc_recv+0x4c>
			*perm_store = 0;
  80fbf3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80fbf9:	eb e3                	jmp    80fbde <ipc_recv+0x4c>

0080fbfb <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{	
  80fbfb:	55                   	push   %ebp
  80fbfc:	89 e5                	mov    %esp,%ebp
  80fbfe:	57                   	push   %edi
  80fbff:	56                   	push   %esi
  80fc00:	53                   	push   %ebx
  80fc01:	83 ec 0c             	sub    $0xc,%esp
  80fc04:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fc07:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fc0a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// cprintf("%d: in %s to_env is %d\n", thisenv->env_id, __FUNCTION__, to_env);
	int ret;
	if(!pg)
		pg = (void *)UTOP;
  80fc0d:	85 db                	test   %ebx,%ebx
  80fc0f:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80fc14:	0f 44 d8             	cmove  %eax,%ebx
  80fc17:	eb 05                	jmp    80fc1e <ipc_send+0x23>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
			panic("panic at ipc_send()\n");
		}
		sys_yield();
  80fc19:	e8 79 f7 ff ff       	call   80f397 <sys_yield>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
  80fc1e:	ff 75 14             	pushl  0x14(%ebp)
  80fc21:	53                   	push   %ebx
  80fc22:	56                   	push   %esi
  80fc23:	57                   	push   %edi
  80fc24:	e8 1a f9 ff ff       	call   80f543 <sys_ipc_try_send>
  80fc29:	83 c4 10             	add    $0x10,%esp
  80fc2c:	85 c0                	test   %eax,%eax
  80fc2e:	74 1b                	je     80fc4b <ipc_send+0x50>
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
  80fc30:	79 e7                	jns    80fc19 <ipc_send+0x1e>
  80fc32:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80fc35:	74 e2                	je     80fc19 <ipc_send+0x1e>
			panic("panic at ipc_send()\n");
  80fc37:	83 ec 04             	sub    $0x4,%esp
  80fc3a:	68 c3 3e 81 00       	push   $0x813ec3
  80fc3f:	6a 46                	push   $0x46
  80fc41:	68 d8 3e 81 00       	push   $0x813ed8
  80fc46:	e8 24 eb ff ff       	call   80e76f <_panic>
	}
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");
}
  80fc4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fc4e:	5b                   	pop    %ebx
  80fc4f:	5e                   	pop    %esi
  80fc50:	5f                   	pop    %edi
  80fc51:	5d                   	pop    %ebp
  80fc52:	c3                   	ret    

0080fc53 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80fc53:	55                   	push   %ebp
  80fc54:	89 e5                	mov    %esp,%ebp
  80fc56:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80fc59:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80fc5e:	89 c2                	mov    %eax,%edx
  80fc60:	c1 e2 07             	shl    $0x7,%edx
  80fc63:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80fc69:	8b 52 50             	mov    0x50(%edx),%edx
  80fc6c:	39 ca                	cmp    %ecx,%edx
  80fc6e:	74 11                	je     80fc81 <ipc_find_env+0x2e>
	for (i = 0; i < NENV; i++)
  80fc70:	83 c0 01             	add    $0x1,%eax
  80fc73:	3d 00 04 00 00       	cmp    $0x400,%eax
  80fc78:	75 e4                	jne    80fc5e <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80fc7a:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc7f:	eb 0b                	jmp    80fc8c <ipc_find_env+0x39>
			return envs[i].env_id;
  80fc81:	c1 e0 07             	shl    $0x7,%eax
  80fc84:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fc89:	8b 40 48             	mov    0x48(%eax),%eax
}
  80fc8c:	5d                   	pop    %ebp
  80fc8d:	c3                   	ret    

0080fc8e <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80fc8e:	55                   	push   %ebp
  80fc8f:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fc91:	8b 45 08             	mov    0x8(%ebp),%eax
  80fc94:	05 00 00 00 30       	add    $0x30000000,%eax
  80fc99:	c1 e8 0c             	shr    $0xc,%eax
}
  80fc9c:	5d                   	pop    %ebp
  80fc9d:	c3                   	ret    

0080fc9e <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80fc9e:	55                   	push   %ebp
  80fc9f:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fca1:	8b 45 08             	mov    0x8(%ebp),%eax
  80fca4:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fca9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fcae:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fcb3:	5d                   	pop    %ebp
  80fcb4:	c3                   	ret    

0080fcb5 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fcb5:	55                   	push   %ebp
  80fcb6:	89 e5                	mov    %esp,%ebp
  80fcb8:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80fcbd:	89 c2                	mov    %eax,%edx
  80fcbf:	c1 ea 16             	shr    $0x16,%edx
  80fcc2:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80fcc9:	f6 c2 01             	test   $0x1,%dl
  80fccc:	74 2d                	je     80fcfb <fd_alloc+0x46>
  80fcce:	89 c2                	mov    %eax,%edx
  80fcd0:	c1 ea 0c             	shr    $0xc,%edx
  80fcd3:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fcda:	f6 c2 01             	test   $0x1,%dl
  80fcdd:	74 1c                	je     80fcfb <fd_alloc+0x46>
  80fcdf:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fce4:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fce9:	75 d2                	jne    80fcbd <fd_alloc+0x8>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fceb:	8b 45 08             	mov    0x8(%ebp),%eax
  80fcee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fcf4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fcf9:	eb 0a                	jmp    80fd05 <fd_alloc+0x50>
			*fd_store = fd;
  80fcfb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fcfe:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fd00:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fd05:	5d                   	pop    %ebp
  80fd06:	c3                   	ret    

0080fd07 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fd07:	55                   	push   %ebp
  80fd08:	89 e5                	mov    %esp,%ebp
  80fd0a:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fd0d:	83 f8 1f             	cmp    $0x1f,%eax
  80fd10:	77 30                	ja     80fd42 <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fd12:	c1 e0 0c             	shl    $0xc,%eax
  80fd15:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fd1a:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fd20:	f6 c2 01             	test   $0x1,%dl
  80fd23:	74 24                	je     80fd49 <fd_lookup+0x42>
  80fd25:	89 c2                	mov    %eax,%edx
  80fd27:	c1 ea 0c             	shr    $0xc,%edx
  80fd2a:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fd31:	f6 c2 01             	test   $0x1,%dl
  80fd34:	74 1a                	je     80fd50 <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fd36:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fd39:	89 02                	mov    %eax,(%edx)
	return 0;
  80fd3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fd40:	5d                   	pop    %ebp
  80fd41:	c3                   	ret    
		return -E_INVAL;
  80fd42:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fd47:	eb f7                	jmp    80fd40 <fd_lookup+0x39>
		return -E_INVAL;
  80fd49:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fd4e:	eb f0                	jmp    80fd40 <fd_lookup+0x39>
  80fd50:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fd55:	eb e9                	jmp    80fd40 <fd_lookup+0x39>

0080fd57 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fd57:	55                   	push   %ebp
  80fd58:	89 e5                	mov    %esp,%ebp
  80fd5a:	83 ec 08             	sub    $0x8,%esp
  80fd5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fd60:	ba 00 00 00 00       	mov    $0x0,%edx
  80fd65:	b8 ec 52 81 00       	mov    $0x8152ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fd6a:	39 08                	cmp    %ecx,(%eax)
  80fd6c:	74 38                	je     80fda6 <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80fd6e:	83 c2 01             	add    $0x1,%edx
  80fd71:	8b 04 95 60 3f 81 00 	mov    0x813f60(,%edx,4),%eax
  80fd78:	85 c0                	test   %eax,%eax
  80fd7a:	75 ee                	jne    80fd6a <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fd7c:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fd81:	8b 40 48             	mov    0x48(%eax),%eax
  80fd84:	83 ec 04             	sub    $0x4,%esp
  80fd87:	51                   	push   %ecx
  80fd88:	50                   	push   %eax
  80fd89:	68 e4 3e 81 00       	push   $0x813ee4
  80fd8e:	e8 d2 ea ff ff       	call   80e865 <cprintf>
	*dev = 0;
  80fd93:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fd96:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fd9c:	83 c4 10             	add    $0x10,%esp
  80fd9f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fda4:	c9                   	leave  
  80fda5:	c3                   	ret    
			*dev = devtab[i];
  80fda6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fda9:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fdab:	b8 00 00 00 00       	mov    $0x0,%eax
  80fdb0:	eb f2                	jmp    80fda4 <dev_lookup+0x4d>

0080fdb2 <fd_close>:
{
  80fdb2:	55                   	push   %ebp
  80fdb3:	89 e5                	mov    %esp,%ebp
  80fdb5:	57                   	push   %edi
  80fdb6:	56                   	push   %esi
  80fdb7:	53                   	push   %ebx
  80fdb8:	83 ec 24             	sub    $0x24,%esp
  80fdbb:	8b 75 08             	mov    0x8(%ebp),%esi
  80fdbe:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fdc1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fdc4:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fdc5:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fdcb:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fdce:	50                   	push   %eax
  80fdcf:	e8 33 ff ff ff       	call   80fd07 <fd_lookup>
  80fdd4:	89 c3                	mov    %eax,%ebx
  80fdd6:	83 c4 10             	add    $0x10,%esp
  80fdd9:	85 c0                	test   %eax,%eax
  80fddb:	78 05                	js     80fde2 <fd_close+0x30>
	    || fd != fd2)
  80fddd:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fde0:	74 16                	je     80fdf8 <fd_close+0x46>
		return (must_exist ? r : 0);
  80fde2:	89 f8                	mov    %edi,%eax
  80fde4:	84 c0                	test   %al,%al
  80fde6:	b8 00 00 00 00       	mov    $0x0,%eax
  80fdeb:	0f 44 d8             	cmove  %eax,%ebx
}
  80fdee:	89 d8                	mov    %ebx,%eax
  80fdf0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fdf3:	5b                   	pop    %ebx
  80fdf4:	5e                   	pop    %esi
  80fdf5:	5f                   	pop    %edi
  80fdf6:	5d                   	pop    %ebp
  80fdf7:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fdf8:	83 ec 08             	sub    $0x8,%esp
  80fdfb:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fdfe:	50                   	push   %eax
  80fdff:	ff 36                	pushl  (%esi)
  80fe01:	e8 51 ff ff ff       	call   80fd57 <dev_lookup>
  80fe06:	89 c3                	mov    %eax,%ebx
  80fe08:	83 c4 10             	add    $0x10,%esp
  80fe0b:	85 c0                	test   %eax,%eax
  80fe0d:	78 1a                	js     80fe29 <fd_close+0x77>
		if (dev->dev_close)
  80fe0f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fe12:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fe15:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fe1a:	85 c0                	test   %eax,%eax
  80fe1c:	74 0b                	je     80fe29 <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80fe1e:	83 ec 0c             	sub    $0xc,%esp
  80fe21:	56                   	push   %esi
  80fe22:	ff d0                	call   *%eax
  80fe24:	89 c3                	mov    %eax,%ebx
  80fe26:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fe29:	83 ec 08             	sub    $0x8,%esp
  80fe2c:	56                   	push   %esi
  80fe2d:	6a 00                	push   $0x0
  80fe2f:	e8 07 f6 ff ff       	call   80f43b <sys_page_unmap>
	return r;
  80fe34:	83 c4 10             	add    $0x10,%esp
  80fe37:	eb b5                	jmp    80fdee <fd_close+0x3c>

0080fe39 <close>:

int
close(int fdnum)
{
  80fe39:	55                   	push   %ebp
  80fe3a:	89 e5                	mov    %esp,%ebp
  80fe3c:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fe3f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe42:	50                   	push   %eax
  80fe43:	ff 75 08             	pushl  0x8(%ebp)
  80fe46:	e8 bc fe ff ff       	call   80fd07 <fd_lookup>
  80fe4b:	83 c4 10             	add    $0x10,%esp
  80fe4e:	85 c0                	test   %eax,%eax
  80fe50:	79 02                	jns    80fe54 <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80fe52:	c9                   	leave  
  80fe53:	c3                   	ret    
		return fd_close(fd, 1);
  80fe54:	83 ec 08             	sub    $0x8,%esp
  80fe57:	6a 01                	push   $0x1
  80fe59:	ff 75 f4             	pushl  -0xc(%ebp)
  80fe5c:	e8 51 ff ff ff       	call   80fdb2 <fd_close>
  80fe61:	83 c4 10             	add    $0x10,%esp
  80fe64:	eb ec                	jmp    80fe52 <close+0x19>

0080fe66 <close_all>:

void
close_all(void)
{
  80fe66:	55                   	push   %ebp
  80fe67:	89 e5                	mov    %esp,%ebp
  80fe69:	53                   	push   %ebx
  80fe6a:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fe6d:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fe72:	83 ec 0c             	sub    $0xc,%esp
  80fe75:	53                   	push   %ebx
  80fe76:	e8 be ff ff ff       	call   80fe39 <close>
	for (i = 0; i < MAXFD; i++)
  80fe7b:	83 c3 01             	add    $0x1,%ebx
  80fe7e:	83 c4 10             	add    $0x10,%esp
  80fe81:	83 fb 20             	cmp    $0x20,%ebx
  80fe84:	75 ec                	jne    80fe72 <close_all+0xc>
}
  80fe86:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe89:	c9                   	leave  
  80fe8a:	c3                   	ret    

0080fe8b <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fe8b:	55                   	push   %ebp
  80fe8c:	89 e5                	mov    %esp,%ebp
  80fe8e:	57                   	push   %edi
  80fe8f:	56                   	push   %esi
  80fe90:	53                   	push   %ebx
  80fe91:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fe94:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fe97:	50                   	push   %eax
  80fe98:	ff 75 08             	pushl  0x8(%ebp)
  80fe9b:	e8 67 fe ff ff       	call   80fd07 <fd_lookup>
  80fea0:	89 c3                	mov    %eax,%ebx
  80fea2:	83 c4 10             	add    $0x10,%esp
  80fea5:	85 c0                	test   %eax,%eax
  80fea7:	0f 88 81 00 00 00    	js     80ff2e <dup+0xa3>
		return r;
	close(newfdnum);
  80fead:	83 ec 0c             	sub    $0xc,%esp
  80feb0:	ff 75 0c             	pushl  0xc(%ebp)
  80feb3:	e8 81 ff ff ff       	call   80fe39 <close>

	newfd = INDEX2FD(newfdnum);
  80feb8:	8b 75 0c             	mov    0xc(%ebp),%esi
  80febb:	c1 e6 0c             	shl    $0xc,%esi
  80febe:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fec4:	83 c4 04             	add    $0x4,%esp
  80fec7:	ff 75 e4             	pushl  -0x1c(%ebp)
  80feca:	e8 cf fd ff ff       	call   80fc9e <fd2data>
  80fecf:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fed1:	89 34 24             	mov    %esi,(%esp)
  80fed4:	e8 c5 fd ff ff       	call   80fc9e <fd2data>
  80fed9:	83 c4 10             	add    $0x10,%esp
  80fedc:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fede:	89 d8                	mov    %ebx,%eax
  80fee0:	c1 e8 16             	shr    $0x16,%eax
  80fee3:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80feea:	a8 01                	test   $0x1,%al
  80feec:	74 11                	je     80feff <dup+0x74>
  80feee:	89 d8                	mov    %ebx,%eax
  80fef0:	c1 e8 0c             	shr    $0xc,%eax
  80fef3:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fefa:	f6 c2 01             	test   $0x1,%dl
  80fefd:	75 39                	jne    80ff38 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80feff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ff02:	89 d0                	mov    %edx,%eax
  80ff04:	c1 e8 0c             	shr    $0xc,%eax
  80ff07:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ff0e:	83 ec 0c             	sub    $0xc,%esp
  80ff11:	25 07 0e 00 00       	and    $0xe07,%eax
  80ff16:	50                   	push   %eax
  80ff17:	56                   	push   %esi
  80ff18:	6a 00                	push   $0x0
  80ff1a:	52                   	push   %edx
  80ff1b:	6a 00                	push   $0x0
  80ff1d:	e8 d7 f4 ff ff       	call   80f3f9 <sys_page_map>
  80ff22:	89 c3                	mov    %eax,%ebx
  80ff24:	83 c4 20             	add    $0x20,%esp
  80ff27:	85 c0                	test   %eax,%eax
  80ff29:	78 31                	js     80ff5c <dup+0xd1>
		goto err;

	return newfdnum;
  80ff2b:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80ff2e:	89 d8                	mov    %ebx,%eax
  80ff30:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ff33:	5b                   	pop    %ebx
  80ff34:	5e                   	pop    %esi
  80ff35:	5f                   	pop    %edi
  80ff36:	5d                   	pop    %ebp
  80ff37:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80ff38:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ff3f:	83 ec 0c             	sub    $0xc,%esp
  80ff42:	25 07 0e 00 00       	and    $0xe07,%eax
  80ff47:	50                   	push   %eax
  80ff48:	57                   	push   %edi
  80ff49:	6a 00                	push   $0x0
  80ff4b:	53                   	push   %ebx
  80ff4c:	6a 00                	push   $0x0
  80ff4e:	e8 a6 f4 ff ff       	call   80f3f9 <sys_page_map>
  80ff53:	89 c3                	mov    %eax,%ebx
  80ff55:	83 c4 20             	add    $0x20,%esp
  80ff58:	85 c0                	test   %eax,%eax
  80ff5a:	79 a3                	jns    80feff <dup+0x74>
	sys_page_unmap(0, newfd);
  80ff5c:	83 ec 08             	sub    $0x8,%esp
  80ff5f:	56                   	push   %esi
  80ff60:	6a 00                	push   $0x0
  80ff62:	e8 d4 f4 ff ff       	call   80f43b <sys_page_unmap>
	sys_page_unmap(0, nva);
  80ff67:	83 c4 08             	add    $0x8,%esp
  80ff6a:	57                   	push   %edi
  80ff6b:	6a 00                	push   $0x0
  80ff6d:	e8 c9 f4 ff ff       	call   80f43b <sys_page_unmap>
	return r;
  80ff72:	83 c4 10             	add    $0x10,%esp
  80ff75:	eb b7                	jmp    80ff2e <dup+0xa3>

0080ff77 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80ff77:	55                   	push   %ebp
  80ff78:	89 e5                	mov    %esp,%ebp
  80ff7a:	53                   	push   %ebx
  80ff7b:	83 ec 1c             	sub    $0x1c,%esp
  80ff7e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ff81:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ff84:	50                   	push   %eax
  80ff85:	53                   	push   %ebx
  80ff86:	e8 7c fd ff ff       	call   80fd07 <fd_lookup>
  80ff8b:	83 c4 10             	add    $0x10,%esp
  80ff8e:	85 c0                	test   %eax,%eax
  80ff90:	78 3f                	js     80ffd1 <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ff92:	83 ec 08             	sub    $0x8,%esp
  80ff95:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ff98:	50                   	push   %eax
  80ff99:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff9c:	ff 30                	pushl  (%eax)
  80ff9e:	e8 b4 fd ff ff       	call   80fd57 <dev_lookup>
  80ffa3:	83 c4 10             	add    $0x10,%esp
  80ffa6:	85 c0                	test   %eax,%eax
  80ffa8:	78 27                	js     80ffd1 <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80ffaa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80ffad:	8b 42 08             	mov    0x8(%edx),%eax
  80ffb0:	83 e0 03             	and    $0x3,%eax
  80ffb3:	83 f8 01             	cmp    $0x1,%eax
  80ffb6:	74 1e                	je     80ffd6 <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80ffb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ffbb:	8b 40 08             	mov    0x8(%eax),%eax
  80ffbe:	85 c0                	test   %eax,%eax
  80ffc0:	74 35                	je     80fff7 <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80ffc2:	83 ec 04             	sub    $0x4,%esp
  80ffc5:	ff 75 10             	pushl  0x10(%ebp)
  80ffc8:	ff 75 0c             	pushl  0xc(%ebp)
  80ffcb:	52                   	push   %edx
  80ffcc:	ff d0                	call   *%eax
  80ffce:	83 c4 10             	add    $0x10,%esp
}
  80ffd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ffd4:	c9                   	leave  
  80ffd5:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80ffd6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80ffdb:	8b 40 48             	mov    0x48(%eax),%eax
  80ffde:	83 ec 04             	sub    $0x4,%esp
  80ffe1:	53                   	push   %ebx
  80ffe2:	50                   	push   %eax
  80ffe3:	68 25 3f 81 00       	push   $0x813f25
  80ffe8:	e8 78 e8 ff ff       	call   80e865 <cprintf>
		return -E_INVAL;
  80ffed:	83 c4 10             	add    $0x10,%esp
  80fff0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fff5:	eb da                	jmp    80ffd1 <read+0x5a>
		return -E_NOT_SUPP;
  80fff7:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fffc:	eb d3                	jmp    80ffd1 <read+0x5a>

0080fffe <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fffe:	55                   	push   %ebp
  80ffff:	89 e5                	mov    %esp,%ebp
  810001:	57                   	push   %edi
  810002:	56                   	push   %esi
  810003:	53                   	push   %ebx
  810004:	83 ec 0c             	sub    $0xc,%esp
  810007:	8b 7d 08             	mov    0x8(%ebp),%edi
  81000a:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  81000d:	bb 00 00 00 00       	mov    $0x0,%ebx
  810012:	39 f3                	cmp    %esi,%ebx
  810014:	73 23                	jae    810039 <readn+0x3b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810016:	83 ec 04             	sub    $0x4,%esp
  810019:	89 f0                	mov    %esi,%eax
  81001b:	29 d8                	sub    %ebx,%eax
  81001d:	50                   	push   %eax
  81001e:	89 d8                	mov    %ebx,%eax
  810020:	03 45 0c             	add    0xc(%ebp),%eax
  810023:	50                   	push   %eax
  810024:	57                   	push   %edi
  810025:	e8 4d ff ff ff       	call   80ff77 <read>
		if (m < 0)
  81002a:	83 c4 10             	add    $0x10,%esp
  81002d:	85 c0                	test   %eax,%eax
  81002f:	78 06                	js     810037 <readn+0x39>
			return m;
		if (m == 0)
  810031:	74 06                	je     810039 <readn+0x3b>
	for (tot = 0; tot < n; tot += m) {
  810033:	01 c3                	add    %eax,%ebx
  810035:	eb db                	jmp    810012 <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810037:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  810039:	89 d8                	mov    %ebx,%eax
  81003b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  81003e:	5b                   	pop    %ebx
  81003f:	5e                   	pop    %esi
  810040:	5f                   	pop    %edi
  810041:	5d                   	pop    %ebp
  810042:	c3                   	ret    

00810043 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  810043:	55                   	push   %ebp
  810044:	89 e5                	mov    %esp,%ebp
  810046:	53                   	push   %ebx
  810047:	83 ec 1c             	sub    $0x1c,%esp
  81004a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  81004d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810050:	50                   	push   %eax
  810051:	53                   	push   %ebx
  810052:	e8 b0 fc ff ff       	call   80fd07 <fd_lookup>
  810057:	83 c4 10             	add    $0x10,%esp
  81005a:	85 c0                	test   %eax,%eax
  81005c:	78 3a                	js     810098 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81005e:	83 ec 08             	sub    $0x8,%esp
  810061:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810064:	50                   	push   %eax
  810065:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810068:	ff 30                	pushl  (%eax)
  81006a:	e8 e8 fc ff ff       	call   80fd57 <dev_lookup>
  81006f:	83 c4 10             	add    $0x10,%esp
  810072:	85 c0                	test   %eax,%eax
  810074:	78 22                	js     810098 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  810076:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810079:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  81007d:	74 1e                	je     81009d <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  81007f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810082:	8b 52 0c             	mov    0xc(%edx),%edx
  810085:	85 d2                	test   %edx,%edx
  810087:	74 35                	je     8100be <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  810089:	83 ec 04             	sub    $0x4,%esp
  81008c:	ff 75 10             	pushl  0x10(%ebp)
  81008f:	ff 75 0c             	pushl  0xc(%ebp)
  810092:	50                   	push   %eax
  810093:	ff d2                	call   *%edx
  810095:	83 c4 10             	add    $0x10,%esp
}
  810098:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81009b:	c9                   	leave  
  81009c:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  81009d:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  8100a2:	8b 40 48             	mov    0x48(%eax),%eax
  8100a5:	83 ec 04             	sub    $0x4,%esp
  8100a8:	53                   	push   %ebx
  8100a9:	50                   	push   %eax
  8100aa:	68 41 3f 81 00       	push   $0x813f41
  8100af:	e8 b1 e7 ff ff       	call   80e865 <cprintf>
		return -E_INVAL;
  8100b4:	83 c4 10             	add    $0x10,%esp
  8100b7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8100bc:	eb da                	jmp    810098 <write+0x55>
		return -E_NOT_SUPP;
  8100be:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8100c3:	eb d3                	jmp    810098 <write+0x55>

008100c5 <seek>:

int
seek(int fdnum, off_t offset)
{
  8100c5:	55                   	push   %ebp
  8100c6:	89 e5                	mov    %esp,%ebp
  8100c8:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8100cb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8100ce:	50                   	push   %eax
  8100cf:	ff 75 08             	pushl  0x8(%ebp)
  8100d2:	e8 30 fc ff ff       	call   80fd07 <fd_lookup>
  8100d7:	83 c4 10             	add    $0x10,%esp
  8100da:	85 c0                	test   %eax,%eax
  8100dc:	78 0e                	js     8100ec <seek+0x27>
		return r;
	fd->fd_offset = offset;
  8100de:	8b 55 0c             	mov    0xc(%ebp),%edx
  8100e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8100e4:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  8100e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8100ec:	c9                   	leave  
  8100ed:	c3                   	ret    

008100ee <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  8100ee:	55                   	push   %ebp
  8100ef:	89 e5                	mov    %esp,%ebp
  8100f1:	53                   	push   %ebx
  8100f2:	83 ec 1c             	sub    $0x1c,%esp
  8100f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8100f8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8100fb:	50                   	push   %eax
  8100fc:	53                   	push   %ebx
  8100fd:	e8 05 fc ff ff       	call   80fd07 <fd_lookup>
  810102:	83 c4 10             	add    $0x10,%esp
  810105:	85 c0                	test   %eax,%eax
  810107:	78 37                	js     810140 <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810109:	83 ec 08             	sub    $0x8,%esp
  81010c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81010f:	50                   	push   %eax
  810110:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810113:	ff 30                	pushl  (%eax)
  810115:	e8 3d fc ff ff       	call   80fd57 <dev_lookup>
  81011a:	83 c4 10             	add    $0x10,%esp
  81011d:	85 c0                	test   %eax,%eax
  81011f:	78 1f                	js     810140 <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  810121:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810124:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810128:	74 1b                	je     810145 <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  81012a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81012d:	8b 52 18             	mov    0x18(%edx),%edx
  810130:	85 d2                	test   %edx,%edx
  810132:	74 32                	je     810166 <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  810134:	83 ec 08             	sub    $0x8,%esp
  810137:	ff 75 0c             	pushl  0xc(%ebp)
  81013a:	50                   	push   %eax
  81013b:	ff d2                	call   *%edx
  81013d:	83 c4 10             	add    $0x10,%esp
}
  810140:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810143:	c9                   	leave  
  810144:	c3                   	ret    
			thisenv->env_id, fdnum);
  810145:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  81014a:	8b 40 48             	mov    0x48(%eax),%eax
  81014d:	83 ec 04             	sub    $0x4,%esp
  810150:	53                   	push   %ebx
  810151:	50                   	push   %eax
  810152:	68 04 3f 81 00       	push   $0x813f04
  810157:	e8 09 e7 ff ff       	call   80e865 <cprintf>
		return -E_INVAL;
  81015c:	83 c4 10             	add    $0x10,%esp
  81015f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810164:	eb da                	jmp    810140 <ftruncate+0x52>
		return -E_NOT_SUPP;
  810166:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81016b:	eb d3                	jmp    810140 <ftruncate+0x52>

0081016d <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  81016d:	55                   	push   %ebp
  81016e:	89 e5                	mov    %esp,%ebp
  810170:	53                   	push   %ebx
  810171:	83 ec 1c             	sub    $0x1c,%esp
  810174:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810177:	8d 45 f0             	lea    -0x10(%ebp),%eax
  81017a:	50                   	push   %eax
  81017b:	ff 75 08             	pushl  0x8(%ebp)
  81017e:	e8 84 fb ff ff       	call   80fd07 <fd_lookup>
  810183:	83 c4 10             	add    $0x10,%esp
  810186:	85 c0                	test   %eax,%eax
  810188:	78 4b                	js     8101d5 <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81018a:	83 ec 08             	sub    $0x8,%esp
  81018d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810190:	50                   	push   %eax
  810191:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810194:	ff 30                	pushl  (%eax)
  810196:	e8 bc fb ff ff       	call   80fd57 <dev_lookup>
  81019b:	83 c4 10             	add    $0x10,%esp
  81019e:	85 c0                	test   %eax,%eax
  8101a0:	78 33                	js     8101d5 <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  8101a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8101a5:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  8101a9:	74 2f                	je     8101da <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8101ab:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  8101ae:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8101b5:	00 00 00 
	stat->st_isdir = 0;
  8101b8:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8101bf:	00 00 00 
	stat->st_dev = dev;
  8101c2:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8101c8:	83 ec 08             	sub    $0x8,%esp
  8101cb:	53                   	push   %ebx
  8101cc:	ff 75 f0             	pushl  -0x10(%ebp)
  8101cf:	ff 50 14             	call   *0x14(%eax)
  8101d2:	83 c4 10             	add    $0x10,%esp
}
  8101d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8101d8:	c9                   	leave  
  8101d9:	c3                   	ret    
		return -E_NOT_SUPP;
  8101da:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8101df:	eb f4                	jmp    8101d5 <fstat+0x68>

008101e1 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8101e1:	55                   	push   %ebp
  8101e2:	89 e5                	mov    %esp,%ebp
  8101e4:	56                   	push   %esi
  8101e5:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8101e6:	83 ec 08             	sub    $0x8,%esp
  8101e9:	6a 00                	push   $0x0
  8101eb:	ff 75 08             	pushl  0x8(%ebp)
  8101ee:	e8 22 02 00 00       	call   810415 <open>
  8101f3:	89 c3                	mov    %eax,%ebx
  8101f5:	83 c4 10             	add    $0x10,%esp
  8101f8:	85 c0                	test   %eax,%eax
  8101fa:	78 1b                	js     810217 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  8101fc:	83 ec 08             	sub    $0x8,%esp
  8101ff:	ff 75 0c             	pushl  0xc(%ebp)
  810202:	50                   	push   %eax
  810203:	e8 65 ff ff ff       	call   81016d <fstat>
  810208:	89 c6                	mov    %eax,%esi
	close(fd);
  81020a:	89 1c 24             	mov    %ebx,(%esp)
  81020d:	e8 27 fc ff ff       	call   80fe39 <close>
	return r;
  810212:	83 c4 10             	add    $0x10,%esp
  810215:	89 f3                	mov    %esi,%ebx
}
  810217:	89 d8                	mov    %ebx,%eax
  810219:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81021c:	5b                   	pop    %ebx
  81021d:	5e                   	pop    %esi
  81021e:	5d                   	pop    %ebp
  81021f:	c3                   	ret    

00810220 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  810220:	55                   	push   %ebp
  810221:	89 e5                	mov    %esp,%ebp
  810223:	56                   	push   %esi
  810224:	53                   	push   %ebx
  810225:	89 c6                	mov    %eax,%esi
  810227:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  810229:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  810230:	74 27                	je     810259 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  810232:	6a 07                	push   $0x7
  810234:	68 00 d0 b3 00       	push   $0xb3d000
  810239:	56                   	push   %esi
  81023a:	ff 35 cc c1 b3 00    	pushl  0xb3c1cc
  810240:	e8 b6 f9 ff ff       	call   80fbfb <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  810245:	83 c4 0c             	add    $0xc,%esp
  810248:	6a 00                	push   $0x0
  81024a:	53                   	push   %ebx
  81024b:	6a 00                	push   $0x0
  81024d:	e8 40 f9 ff ff       	call   80fb92 <ipc_recv>
}
  810252:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810255:	5b                   	pop    %ebx
  810256:	5e                   	pop    %esi
  810257:	5d                   	pop    %ebp
  810258:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810259:	83 ec 0c             	sub    $0xc,%esp
  81025c:	6a 01                	push   $0x1
  81025e:	e8 f0 f9 ff ff       	call   80fc53 <ipc_find_env>
  810263:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
  810268:	83 c4 10             	add    $0x10,%esp
  81026b:	eb c5                	jmp    810232 <fsipc+0x12>

0081026d <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  81026d:	55                   	push   %ebp
  81026e:	89 e5                	mov    %esp,%ebp
  810270:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810273:	8b 45 08             	mov    0x8(%ebp),%eax
  810276:	8b 40 0c             	mov    0xc(%eax),%eax
  810279:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  81027e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810281:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810286:	ba 00 00 00 00       	mov    $0x0,%edx
  81028b:	b8 02 00 00 00       	mov    $0x2,%eax
  810290:	e8 8b ff ff ff       	call   810220 <fsipc>
}
  810295:	c9                   	leave  
  810296:	c3                   	ret    

00810297 <devfile_flush>:
{
  810297:	55                   	push   %ebp
  810298:	89 e5                	mov    %esp,%ebp
  81029a:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  81029d:	8b 45 08             	mov    0x8(%ebp),%eax
  8102a0:	8b 40 0c             	mov    0xc(%eax),%eax
  8102a3:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  8102a8:	ba 00 00 00 00       	mov    $0x0,%edx
  8102ad:	b8 06 00 00 00       	mov    $0x6,%eax
  8102b2:	e8 69 ff ff ff       	call   810220 <fsipc>
}
  8102b7:	c9                   	leave  
  8102b8:	c3                   	ret    

008102b9 <devfile_stat>:
{
  8102b9:	55                   	push   %ebp
  8102ba:	89 e5                	mov    %esp,%ebp
  8102bc:	53                   	push   %ebx
  8102bd:	83 ec 04             	sub    $0x4,%esp
  8102c0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8102c3:	8b 45 08             	mov    0x8(%ebp),%eax
  8102c6:	8b 40 0c             	mov    0xc(%eax),%eax
  8102c9:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8102ce:	ba 00 00 00 00       	mov    $0x0,%edx
  8102d3:	b8 05 00 00 00       	mov    $0x5,%eax
  8102d8:	e8 43 ff ff ff       	call   810220 <fsipc>
  8102dd:	85 c0                	test   %eax,%eax
  8102df:	78 2c                	js     81030d <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8102e1:	83 ec 08             	sub    $0x8,%esp
  8102e4:	68 00 d0 b3 00       	push   $0xb3d000
  8102e9:	53                   	push   %ebx
  8102ea:	e8 d5 ec ff ff       	call   80efc4 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8102ef:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  8102f4:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8102fa:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  8102ff:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  810305:	83 c4 10             	add    $0x10,%esp
  810308:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81030d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810310:	c9                   	leave  
  810311:	c3                   	ret    

00810312 <devfile_write>:
{
  810312:	55                   	push   %ebp
  810313:	89 e5                	mov    %esp,%ebp
  810315:	53                   	push   %ebx
  810316:	83 ec 08             	sub    $0x8,%esp
  810319:	8b 5d 10             	mov    0x10(%ebp),%ebx
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  81031c:	8b 45 08             	mov    0x8(%ebp),%eax
  81031f:	8b 40 0c             	mov    0xc(%eax),%eax
  810322:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.write.req_n = n;
  810327:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	memcpy(fsipcbuf.write.req_buf, buf, n);
  81032d:	53                   	push   %ebx
  81032e:	ff 75 0c             	pushl  0xc(%ebp)
  810331:	68 08 d0 b3 00       	push   $0xb3d008
  810336:	e8 79 ee ff ff       	call   80f1b4 <memcpy>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  81033b:	ba 00 00 00 00       	mov    $0x0,%edx
  810340:	b8 04 00 00 00       	mov    $0x4,%eax
  810345:	e8 d6 fe ff ff       	call   810220 <fsipc>
  81034a:	83 c4 10             	add    $0x10,%esp
  81034d:	85 c0                	test   %eax,%eax
  81034f:	78 0b                	js     81035c <devfile_write+0x4a>
	assert(r <= n);
  810351:	39 d8                	cmp    %ebx,%eax
  810353:	77 0c                	ja     810361 <devfile_write+0x4f>
	assert(r <= PGSIZE);
  810355:	3d 00 10 00 00       	cmp    $0x1000,%eax
  81035a:	7f 1e                	jg     81037a <devfile_write+0x68>
}
  81035c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81035f:	c9                   	leave  
  810360:	c3                   	ret    
	assert(r <= n);
  810361:	68 74 3f 81 00       	push   $0x813f74
  810366:	68 6b 2b 81 00       	push   $0x812b6b
  81036b:	68 98 00 00 00       	push   $0x98
  810370:	68 7b 3f 81 00       	push   $0x813f7b
  810375:	e8 f5 e3 ff ff       	call   80e76f <_panic>
	assert(r <= PGSIZE);
  81037a:	68 86 3f 81 00       	push   $0x813f86
  81037f:	68 6b 2b 81 00       	push   $0x812b6b
  810384:	68 99 00 00 00       	push   $0x99
  810389:	68 7b 3f 81 00       	push   $0x813f7b
  81038e:	e8 dc e3 ff ff       	call   80e76f <_panic>

00810393 <devfile_read>:
{
  810393:	55                   	push   %ebp
  810394:	89 e5                	mov    %esp,%ebp
  810396:	56                   	push   %esi
  810397:	53                   	push   %ebx
  810398:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  81039b:	8b 45 08             	mov    0x8(%ebp),%eax
  81039e:	8b 40 0c             	mov    0xc(%eax),%eax
  8103a1:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  8103a6:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  8103ac:	ba 00 00 00 00       	mov    $0x0,%edx
  8103b1:	b8 03 00 00 00       	mov    $0x3,%eax
  8103b6:	e8 65 fe ff ff       	call   810220 <fsipc>
  8103bb:	89 c3                	mov    %eax,%ebx
  8103bd:	85 c0                	test   %eax,%eax
  8103bf:	78 1f                	js     8103e0 <devfile_read+0x4d>
	assert(r <= n);
  8103c1:	39 f0                	cmp    %esi,%eax
  8103c3:	77 24                	ja     8103e9 <devfile_read+0x56>
	assert(r <= PGSIZE);
  8103c5:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8103ca:	7f 33                	jg     8103ff <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  8103cc:	83 ec 04             	sub    $0x4,%esp
  8103cf:	50                   	push   %eax
  8103d0:	68 00 d0 b3 00       	push   $0xb3d000
  8103d5:	ff 75 0c             	pushl  0xc(%ebp)
  8103d8:	e8 75 ed ff ff       	call   80f152 <memmove>
	return r;
  8103dd:	83 c4 10             	add    $0x10,%esp
}
  8103e0:	89 d8                	mov    %ebx,%eax
  8103e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8103e5:	5b                   	pop    %ebx
  8103e6:	5e                   	pop    %esi
  8103e7:	5d                   	pop    %ebp
  8103e8:	c3                   	ret    
	assert(r <= n);
  8103e9:	68 74 3f 81 00       	push   $0x813f74
  8103ee:	68 6b 2b 81 00       	push   $0x812b6b
  8103f3:	6a 7c                	push   $0x7c
  8103f5:	68 7b 3f 81 00       	push   $0x813f7b
  8103fa:	e8 70 e3 ff ff       	call   80e76f <_panic>
	assert(r <= PGSIZE);
  8103ff:	68 86 3f 81 00       	push   $0x813f86
  810404:	68 6b 2b 81 00       	push   $0x812b6b
  810409:	6a 7d                	push   $0x7d
  81040b:	68 7b 3f 81 00       	push   $0x813f7b
  810410:	e8 5a e3 ff ff       	call   80e76f <_panic>

00810415 <open>:
{
  810415:	55                   	push   %ebp
  810416:	89 e5                	mov    %esp,%ebp
  810418:	56                   	push   %esi
  810419:	53                   	push   %ebx
  81041a:	83 ec 1c             	sub    $0x1c,%esp
  81041d:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  810420:	56                   	push   %esi
  810421:	e8 65 eb ff ff       	call   80ef8b <strlen>
  810426:	83 c4 10             	add    $0x10,%esp
  810429:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  81042e:	7f 6c                	jg     81049c <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  810430:	83 ec 0c             	sub    $0xc,%esp
  810433:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810436:	50                   	push   %eax
  810437:	e8 79 f8 ff ff       	call   80fcb5 <fd_alloc>
  81043c:	89 c3                	mov    %eax,%ebx
  81043e:	83 c4 10             	add    $0x10,%esp
  810441:	85 c0                	test   %eax,%eax
  810443:	78 3c                	js     810481 <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  810445:	83 ec 08             	sub    $0x8,%esp
  810448:	56                   	push   %esi
  810449:	68 00 d0 b3 00       	push   $0xb3d000
  81044e:	e8 71 eb ff ff       	call   80efc4 <strcpy>
	fsipcbuf.open.req_omode = mode;
  810453:	8b 45 0c             	mov    0xc(%ebp),%eax
  810456:	a3 00 d4 b3 00       	mov    %eax,0xb3d400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  81045b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81045e:	b8 01 00 00 00       	mov    $0x1,%eax
  810463:	e8 b8 fd ff ff       	call   810220 <fsipc>
  810468:	89 c3                	mov    %eax,%ebx
  81046a:	83 c4 10             	add    $0x10,%esp
  81046d:	85 c0                	test   %eax,%eax
  81046f:	78 19                	js     81048a <open+0x75>
	return fd2num(fd);
  810471:	83 ec 0c             	sub    $0xc,%esp
  810474:	ff 75 f4             	pushl  -0xc(%ebp)
  810477:	e8 12 f8 ff ff       	call   80fc8e <fd2num>
  81047c:	89 c3                	mov    %eax,%ebx
  81047e:	83 c4 10             	add    $0x10,%esp
}
  810481:	89 d8                	mov    %ebx,%eax
  810483:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810486:	5b                   	pop    %ebx
  810487:	5e                   	pop    %esi
  810488:	5d                   	pop    %ebp
  810489:	c3                   	ret    
		fd_close(fd, 0);
  81048a:	83 ec 08             	sub    $0x8,%esp
  81048d:	6a 00                	push   $0x0
  81048f:	ff 75 f4             	pushl  -0xc(%ebp)
  810492:	e8 1b f9 ff ff       	call   80fdb2 <fd_close>
		return r;
  810497:	83 c4 10             	add    $0x10,%esp
  81049a:	eb e5                	jmp    810481 <open+0x6c>
		return -E_BAD_PATH;
  81049c:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  8104a1:	eb de                	jmp    810481 <open+0x6c>

008104a3 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  8104a3:	55                   	push   %ebp
  8104a4:	89 e5                	mov    %esp,%ebp
  8104a6:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  8104a9:	ba 00 00 00 00       	mov    $0x0,%edx
  8104ae:	b8 08 00 00 00       	mov    $0x8,%eax
  8104b3:	e8 68 fd ff ff       	call   810220 <fsipc>
}
  8104b8:	c9                   	leave  
  8104b9:	c3                   	ret    

008104ba <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8104ba:	55                   	push   %ebp
  8104bb:	89 e5                	mov    %esp,%ebp
  8104bd:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  8104c0:	68 92 3f 81 00       	push   $0x813f92
  8104c5:	ff 75 0c             	pushl  0xc(%ebp)
  8104c8:	e8 f7 ea ff ff       	call   80efc4 <strcpy>
	return 0;
}
  8104cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8104d2:	c9                   	leave  
  8104d3:	c3                   	ret    

008104d4 <devsock_close>:
{
  8104d4:	55                   	push   %ebp
  8104d5:	89 e5                	mov    %esp,%ebp
  8104d7:	53                   	push   %ebx
  8104d8:	83 ec 10             	sub    $0x10,%esp
  8104db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8104de:	53                   	push   %ebx
  8104df:	e8 2e 0c 00 00       	call   811112 <pageref>
  8104e4:	83 c4 10             	add    $0x10,%esp
		return 0;
  8104e7:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  8104ec:	83 f8 01             	cmp    $0x1,%eax
  8104ef:	74 07                	je     8104f8 <devsock_close+0x24>
}
  8104f1:	89 d0                	mov    %edx,%eax
  8104f3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8104f6:	c9                   	leave  
  8104f7:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  8104f8:	83 ec 0c             	sub    $0xc,%esp
  8104fb:	ff 73 0c             	pushl  0xc(%ebx)
  8104fe:	e8 b9 02 00 00       	call   8107bc <nsipc_close>
  810503:	89 c2                	mov    %eax,%edx
  810505:	83 c4 10             	add    $0x10,%esp
  810508:	eb e7                	jmp    8104f1 <devsock_close+0x1d>

0081050a <devsock_write>:
{
  81050a:	55                   	push   %ebp
  81050b:	89 e5                	mov    %esp,%ebp
  81050d:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  810510:	6a 00                	push   $0x0
  810512:	ff 75 10             	pushl  0x10(%ebp)
  810515:	ff 75 0c             	pushl  0xc(%ebp)
  810518:	8b 45 08             	mov    0x8(%ebp),%eax
  81051b:	ff 70 0c             	pushl  0xc(%eax)
  81051e:	e8 76 03 00 00       	call   810899 <nsipc_send>
}
  810523:	c9                   	leave  
  810524:	c3                   	ret    

00810525 <devsock_read>:
{
  810525:	55                   	push   %ebp
  810526:	89 e5                	mov    %esp,%ebp
  810528:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  81052b:	6a 00                	push   $0x0
  81052d:	ff 75 10             	pushl  0x10(%ebp)
  810530:	ff 75 0c             	pushl  0xc(%ebp)
  810533:	8b 45 08             	mov    0x8(%ebp),%eax
  810536:	ff 70 0c             	pushl  0xc(%eax)
  810539:	e8 ef 02 00 00       	call   81082d <nsipc_recv>
}
  81053e:	c9                   	leave  
  81053f:	c3                   	ret    

00810540 <fd2sockid>:
{
  810540:	55                   	push   %ebp
  810541:	89 e5                	mov    %esp,%ebp
  810543:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  810546:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810549:	52                   	push   %edx
  81054a:	50                   	push   %eax
  81054b:	e8 b7 f7 ff ff       	call   80fd07 <fd_lookup>
  810550:	83 c4 10             	add    $0x10,%esp
  810553:	85 c0                	test   %eax,%eax
  810555:	78 10                	js     810567 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  810557:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81055a:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
  810560:	39 08                	cmp    %ecx,(%eax)
  810562:	75 05                	jne    810569 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  810564:	8b 40 0c             	mov    0xc(%eax),%eax
}
  810567:	c9                   	leave  
  810568:	c3                   	ret    
		return -E_NOT_SUPP;
  810569:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81056e:	eb f7                	jmp    810567 <fd2sockid+0x27>

00810570 <alloc_sockfd>:
{
  810570:	55                   	push   %ebp
  810571:	89 e5                	mov    %esp,%ebp
  810573:	56                   	push   %esi
  810574:	53                   	push   %ebx
  810575:	83 ec 1c             	sub    $0x1c,%esp
  810578:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  81057a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81057d:	50                   	push   %eax
  81057e:	e8 32 f7 ff ff       	call   80fcb5 <fd_alloc>
  810583:	89 c3                	mov    %eax,%ebx
  810585:	83 c4 10             	add    $0x10,%esp
  810588:	85 c0                	test   %eax,%eax
  81058a:	78 43                	js     8105cf <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  81058c:	83 ec 04             	sub    $0x4,%esp
  81058f:	68 07 04 00 00       	push   $0x407
  810594:	ff 75 f4             	pushl  -0xc(%ebp)
  810597:	6a 00                	push   $0x0
  810599:	e8 18 ee ff ff       	call   80f3b6 <sys_page_alloc>
  81059e:	89 c3                	mov    %eax,%ebx
  8105a0:	83 c4 10             	add    $0x10,%esp
  8105a3:	85 c0                	test   %eax,%eax
  8105a5:	78 28                	js     8105cf <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  8105a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8105aa:	8b 15 08 53 81 00    	mov    0x815308,%edx
  8105b0:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8105b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8105b5:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8105bc:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8105bf:	83 ec 0c             	sub    $0xc,%esp
  8105c2:	50                   	push   %eax
  8105c3:	e8 c6 f6 ff ff       	call   80fc8e <fd2num>
  8105c8:	89 c3                	mov    %eax,%ebx
  8105ca:	83 c4 10             	add    $0x10,%esp
  8105cd:	eb 0c                	jmp    8105db <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  8105cf:	83 ec 0c             	sub    $0xc,%esp
  8105d2:	56                   	push   %esi
  8105d3:	e8 e4 01 00 00       	call   8107bc <nsipc_close>
		return r;
  8105d8:	83 c4 10             	add    $0x10,%esp
}
  8105db:	89 d8                	mov    %ebx,%eax
  8105dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8105e0:	5b                   	pop    %ebx
  8105e1:	5e                   	pop    %esi
  8105e2:	5d                   	pop    %ebp
  8105e3:	c3                   	ret    

008105e4 <accept>:
{
  8105e4:	55                   	push   %ebp
  8105e5:	89 e5                	mov    %esp,%ebp
  8105e7:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8105ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8105ed:	e8 4e ff ff ff       	call   810540 <fd2sockid>
  8105f2:	85 c0                	test   %eax,%eax
  8105f4:	78 1b                	js     810611 <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8105f6:	83 ec 04             	sub    $0x4,%esp
  8105f9:	ff 75 10             	pushl  0x10(%ebp)
  8105fc:	ff 75 0c             	pushl  0xc(%ebp)
  8105ff:	50                   	push   %eax
  810600:	e8 0e 01 00 00       	call   810713 <nsipc_accept>
  810605:	83 c4 10             	add    $0x10,%esp
  810608:	85 c0                	test   %eax,%eax
  81060a:	78 05                	js     810611 <accept+0x2d>
	return alloc_sockfd(r);
  81060c:	e8 5f ff ff ff       	call   810570 <alloc_sockfd>
}
  810611:	c9                   	leave  
  810612:	c3                   	ret    

00810613 <bind>:
{
  810613:	55                   	push   %ebp
  810614:	89 e5                	mov    %esp,%ebp
  810616:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810619:	8b 45 08             	mov    0x8(%ebp),%eax
  81061c:	e8 1f ff ff ff       	call   810540 <fd2sockid>
  810621:	85 c0                	test   %eax,%eax
  810623:	78 12                	js     810637 <bind+0x24>
	return nsipc_bind(r, name, namelen);
  810625:	83 ec 04             	sub    $0x4,%esp
  810628:	ff 75 10             	pushl  0x10(%ebp)
  81062b:	ff 75 0c             	pushl  0xc(%ebp)
  81062e:	50                   	push   %eax
  81062f:	e8 31 01 00 00       	call   810765 <nsipc_bind>
  810634:	83 c4 10             	add    $0x10,%esp
}
  810637:	c9                   	leave  
  810638:	c3                   	ret    

00810639 <shutdown>:
{
  810639:	55                   	push   %ebp
  81063a:	89 e5                	mov    %esp,%ebp
  81063c:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81063f:	8b 45 08             	mov    0x8(%ebp),%eax
  810642:	e8 f9 fe ff ff       	call   810540 <fd2sockid>
  810647:	85 c0                	test   %eax,%eax
  810649:	78 0f                	js     81065a <shutdown+0x21>
	return nsipc_shutdown(r, how);
  81064b:	83 ec 08             	sub    $0x8,%esp
  81064e:	ff 75 0c             	pushl  0xc(%ebp)
  810651:	50                   	push   %eax
  810652:	e8 43 01 00 00       	call   81079a <nsipc_shutdown>
  810657:	83 c4 10             	add    $0x10,%esp
}
  81065a:	c9                   	leave  
  81065b:	c3                   	ret    

0081065c <connect>:
{
  81065c:	55                   	push   %ebp
  81065d:	89 e5                	mov    %esp,%ebp
  81065f:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810662:	8b 45 08             	mov    0x8(%ebp),%eax
  810665:	e8 d6 fe ff ff       	call   810540 <fd2sockid>
  81066a:	85 c0                	test   %eax,%eax
  81066c:	78 12                	js     810680 <connect+0x24>
	return nsipc_connect(r, name, namelen);
  81066e:	83 ec 04             	sub    $0x4,%esp
  810671:	ff 75 10             	pushl  0x10(%ebp)
  810674:	ff 75 0c             	pushl  0xc(%ebp)
  810677:	50                   	push   %eax
  810678:	e8 59 01 00 00       	call   8107d6 <nsipc_connect>
  81067d:	83 c4 10             	add    $0x10,%esp
}
  810680:	c9                   	leave  
  810681:	c3                   	ret    

00810682 <listen>:
{
  810682:	55                   	push   %ebp
  810683:	89 e5                	mov    %esp,%ebp
  810685:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810688:	8b 45 08             	mov    0x8(%ebp),%eax
  81068b:	e8 b0 fe ff ff       	call   810540 <fd2sockid>
  810690:	85 c0                	test   %eax,%eax
  810692:	78 0f                	js     8106a3 <listen+0x21>
	return nsipc_listen(r, backlog);
  810694:	83 ec 08             	sub    $0x8,%esp
  810697:	ff 75 0c             	pushl  0xc(%ebp)
  81069a:	50                   	push   %eax
  81069b:	e8 6b 01 00 00       	call   81080b <nsipc_listen>
  8106a0:	83 c4 10             	add    $0x10,%esp
}
  8106a3:	c9                   	leave  
  8106a4:	c3                   	ret    

008106a5 <socket>:

int
socket(int domain, int type, int protocol)
{
  8106a5:	55                   	push   %ebp
  8106a6:	89 e5                	mov    %esp,%ebp
  8106a8:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8106ab:	ff 75 10             	pushl  0x10(%ebp)
  8106ae:	ff 75 0c             	pushl  0xc(%ebp)
  8106b1:	ff 75 08             	pushl  0x8(%ebp)
  8106b4:	e8 3e 02 00 00       	call   8108f7 <nsipc_socket>
  8106b9:	83 c4 10             	add    $0x10,%esp
  8106bc:	85 c0                	test   %eax,%eax
  8106be:	78 05                	js     8106c5 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  8106c0:	e8 ab fe ff ff       	call   810570 <alloc_sockfd>
}
  8106c5:	c9                   	leave  
  8106c6:	c3                   	ret    

008106c7 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8106c7:	55                   	push   %ebp
  8106c8:	89 e5                	mov    %esp,%ebp
  8106ca:	53                   	push   %ebx
  8106cb:	83 ec 04             	sub    $0x4,%esp
  8106ce:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8106d0:	83 3d d0 c1 b3 00 00 	cmpl   $0x0,0xb3c1d0
  8106d7:	74 26                	je     8106ff <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8106d9:	6a 07                	push   $0x7
  8106db:	68 00 e0 b3 00       	push   $0xb3e000
  8106e0:	53                   	push   %ebx
  8106e1:	ff 35 d0 c1 b3 00    	pushl  0xb3c1d0
  8106e7:	e8 0f f5 ff ff       	call   80fbfb <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  8106ec:	83 c4 0c             	add    $0xc,%esp
  8106ef:	6a 00                	push   $0x0
  8106f1:	6a 00                	push   $0x0
  8106f3:	6a 00                	push   $0x0
  8106f5:	e8 98 f4 ff ff       	call   80fb92 <ipc_recv>
}
  8106fa:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8106fd:	c9                   	leave  
  8106fe:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8106ff:	83 ec 0c             	sub    $0xc,%esp
  810702:	6a 02                	push   $0x2
  810704:	e8 4a f5 ff ff       	call   80fc53 <ipc_find_env>
  810709:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
  81070e:	83 c4 10             	add    $0x10,%esp
  810711:	eb c6                	jmp    8106d9 <nsipc+0x12>

00810713 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810713:	55                   	push   %ebp
  810714:	89 e5                	mov    %esp,%ebp
  810716:	56                   	push   %esi
  810717:	53                   	push   %ebx
  810718:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  81071b:	8b 45 08             	mov    0x8(%ebp),%eax
  81071e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810723:	8b 06                	mov    (%esi),%eax
  810725:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  81072a:	b8 01 00 00 00       	mov    $0x1,%eax
  81072f:	e8 93 ff ff ff       	call   8106c7 <nsipc>
  810734:	89 c3                	mov    %eax,%ebx
  810736:	85 c0                	test   %eax,%eax
  810738:	79 09                	jns    810743 <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  81073a:	89 d8                	mov    %ebx,%eax
  81073c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81073f:	5b                   	pop    %ebx
  810740:	5e                   	pop    %esi
  810741:	5d                   	pop    %ebp
  810742:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  810743:	83 ec 04             	sub    $0x4,%esp
  810746:	ff 35 10 e0 b3 00    	pushl  0xb3e010
  81074c:	68 00 e0 b3 00       	push   $0xb3e000
  810751:	ff 75 0c             	pushl  0xc(%ebp)
  810754:	e8 f9 e9 ff ff       	call   80f152 <memmove>
		*addrlen = ret->ret_addrlen;
  810759:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  81075e:	89 06                	mov    %eax,(%esi)
  810760:	83 c4 10             	add    $0x10,%esp
	return r;
  810763:	eb d5                	jmp    81073a <nsipc_accept+0x27>

00810765 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810765:	55                   	push   %ebp
  810766:	89 e5                	mov    %esp,%ebp
  810768:	53                   	push   %ebx
  810769:	83 ec 08             	sub    $0x8,%esp
  81076c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  81076f:	8b 45 08             	mov    0x8(%ebp),%eax
  810772:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810777:	53                   	push   %ebx
  810778:	ff 75 0c             	pushl  0xc(%ebp)
  81077b:	68 04 e0 b3 00       	push   $0xb3e004
  810780:	e8 cd e9 ff ff       	call   80f152 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  810785:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  81078b:	b8 02 00 00 00       	mov    $0x2,%eax
  810790:	e8 32 ff ff ff       	call   8106c7 <nsipc>
}
  810795:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810798:	c9                   	leave  
  810799:	c3                   	ret    

0081079a <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81079a:	55                   	push   %ebp
  81079b:	89 e5                	mov    %esp,%ebp
  81079d:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  8107a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8107a3:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  8107a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8107ab:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  8107b0:	b8 03 00 00 00       	mov    $0x3,%eax
  8107b5:	e8 0d ff ff ff       	call   8106c7 <nsipc>
}
  8107ba:	c9                   	leave  
  8107bb:	c3                   	ret    

008107bc <nsipc_close>:

int
nsipc_close(int s)
{
  8107bc:	55                   	push   %ebp
  8107bd:	89 e5                	mov    %esp,%ebp
  8107bf:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  8107c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8107c5:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  8107ca:	b8 04 00 00 00       	mov    $0x4,%eax
  8107cf:	e8 f3 fe ff ff       	call   8106c7 <nsipc>
}
  8107d4:	c9                   	leave  
  8107d5:	c3                   	ret    

008107d6 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8107d6:	55                   	push   %ebp
  8107d7:	89 e5                	mov    %esp,%ebp
  8107d9:	53                   	push   %ebx
  8107da:	83 ec 08             	sub    $0x8,%esp
  8107dd:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  8107e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8107e3:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8107e8:	53                   	push   %ebx
  8107e9:	ff 75 0c             	pushl  0xc(%ebp)
  8107ec:	68 04 e0 b3 00       	push   $0xb3e004
  8107f1:	e8 5c e9 ff ff       	call   80f152 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8107f6:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  8107fc:	b8 05 00 00 00       	mov    $0x5,%eax
  810801:	e8 c1 fe ff ff       	call   8106c7 <nsipc>
}
  810806:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810809:	c9                   	leave  
  81080a:	c3                   	ret    

0081080b <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  81080b:	55                   	push   %ebp
  81080c:	89 e5                	mov    %esp,%ebp
  81080e:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  810811:	8b 45 08             	mov    0x8(%ebp),%eax
  810814:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  810819:	8b 45 0c             	mov    0xc(%ebp),%eax
  81081c:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  810821:	b8 06 00 00 00       	mov    $0x6,%eax
  810826:	e8 9c fe ff ff       	call   8106c7 <nsipc>
}
  81082b:	c9                   	leave  
  81082c:	c3                   	ret    

0081082d <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  81082d:	55                   	push   %ebp
  81082e:	89 e5                	mov    %esp,%ebp
  810830:	56                   	push   %esi
  810831:	53                   	push   %ebx
  810832:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810835:	8b 45 08             	mov    0x8(%ebp),%eax
  810838:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  81083d:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  810843:	8b 45 14             	mov    0x14(%ebp),%eax
  810846:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  81084b:	b8 07 00 00 00       	mov    $0x7,%eax
  810850:	e8 72 fe ff ff       	call   8106c7 <nsipc>
  810855:	89 c3                	mov    %eax,%ebx
  810857:	85 c0                	test   %eax,%eax
  810859:	78 1f                	js     81087a <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  81085b:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  810860:	7f 21                	jg     810883 <nsipc_recv+0x56>
  810862:	39 c6                	cmp    %eax,%esi
  810864:	7c 1d                	jl     810883 <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810866:	83 ec 04             	sub    $0x4,%esp
  810869:	50                   	push   %eax
  81086a:	68 00 e0 b3 00       	push   $0xb3e000
  81086f:	ff 75 0c             	pushl  0xc(%ebp)
  810872:	e8 db e8 ff ff       	call   80f152 <memmove>
  810877:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  81087a:	89 d8                	mov    %ebx,%eax
  81087c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81087f:	5b                   	pop    %ebx
  810880:	5e                   	pop    %esi
  810881:	5d                   	pop    %ebp
  810882:	c3                   	ret    
		assert(r < 1600 && r <= len);
  810883:	68 9e 3f 81 00       	push   $0x813f9e
  810888:	68 6b 2b 81 00       	push   $0x812b6b
  81088d:	6a 62                	push   $0x62
  81088f:	68 b3 3f 81 00       	push   $0x813fb3
  810894:	e8 d6 de ff ff       	call   80e76f <_panic>

00810899 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810899:	55                   	push   %ebp
  81089a:	89 e5                	mov    %esp,%ebp
  81089c:	53                   	push   %ebx
  81089d:	83 ec 04             	sub    $0x4,%esp
  8108a0:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8108a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8108a6:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  8108ab:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8108b1:	7f 2e                	jg     8108e1 <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8108b3:	83 ec 04             	sub    $0x4,%esp
  8108b6:	53                   	push   %ebx
  8108b7:	ff 75 0c             	pushl  0xc(%ebp)
  8108ba:	68 0c e0 b3 00       	push   $0xb3e00c
  8108bf:	e8 8e e8 ff ff       	call   80f152 <memmove>
	nsipcbuf.send.req_size = size;
  8108c4:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  8108ca:	8b 45 14             	mov    0x14(%ebp),%eax
  8108cd:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  8108d2:	b8 08 00 00 00       	mov    $0x8,%eax
  8108d7:	e8 eb fd ff ff       	call   8106c7 <nsipc>
}
  8108dc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8108df:	c9                   	leave  
  8108e0:	c3                   	ret    
	assert(size < 1600);
  8108e1:	68 bf 3f 81 00       	push   $0x813fbf
  8108e6:	68 6b 2b 81 00       	push   $0x812b6b
  8108eb:	6a 6d                	push   $0x6d
  8108ed:	68 b3 3f 81 00       	push   $0x813fb3
  8108f2:	e8 78 de ff ff       	call   80e76f <_panic>

008108f7 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8108f7:	55                   	push   %ebp
  8108f8:	89 e5                	mov    %esp,%ebp
  8108fa:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  8108fd:	8b 45 08             	mov    0x8(%ebp),%eax
  810900:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  810905:	8b 45 0c             	mov    0xc(%ebp),%eax
  810908:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  81090d:	8b 45 10             	mov    0x10(%ebp),%eax
  810910:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  810915:	b8 09 00 00 00       	mov    $0x9,%eax
  81091a:	e8 a8 fd ff ff       	call   8106c7 <nsipc>
}
  81091f:	c9                   	leave  
  810920:	c3                   	ret    

00810921 <free>:
	return v;
}

void
free(void *v)
{
  810921:	55                   	push   %ebp
  810922:	89 e5                	mov    %esp,%ebp
  810924:	53                   	push   %ebx
  810925:	83 ec 04             	sub    $0x4,%esp
  810928:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  81092b:	85 db                	test   %ebx,%ebx
  81092d:	0f 84 85 00 00 00    	je     8109b8 <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810933:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810939:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  81093e:	77 51                	ja     810991 <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  810940:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810946:	89 d8                	mov    %ebx,%eax
  810948:	c1 e8 0c             	shr    $0xc,%eax
  81094b:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  810952:	f6 c4 02             	test   $0x2,%ah
  810955:	74 50                	je     8109a7 <free+0x86>
		sys_page_unmap(0, c);
  810957:	83 ec 08             	sub    $0x8,%esp
  81095a:	53                   	push   %ebx
  81095b:	6a 00                	push   $0x0
  81095d:	e8 d9 ea ff ff       	call   80f43b <sys_page_unmap>
		c += PGSIZE;
  810962:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810968:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81096e:	83 c4 10             	add    $0x10,%esp
  810971:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810976:	76 ce                	jbe    810946 <free+0x25>
  810978:	68 07 40 81 00       	push   $0x814007
  81097d:	68 6b 2b 81 00       	push   $0x812b6b
  810982:	68 81 00 00 00       	push   $0x81
  810987:	68 fa 3f 81 00       	push   $0x813ffa
  81098c:	e8 de dd ff ff       	call   80e76f <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810991:	68 cc 3f 81 00       	push   $0x813fcc
  810996:	68 6b 2b 81 00       	push   $0x812b6b
  81099b:	6a 7a                	push   $0x7a
  81099d:	68 fa 3f 81 00       	push   $0x813ffa
  8109a2:	e8 c8 dd ff ff       	call   80e76f <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8109a7:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8109ad:	83 e8 01             	sub    $0x1,%eax
  8109b0:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8109b6:	74 05                	je     8109bd <free+0x9c>
		sys_page_unmap(0, c);
}
  8109b8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8109bb:	c9                   	leave  
  8109bc:	c3                   	ret    
		sys_page_unmap(0, c);
  8109bd:	83 ec 08             	sub    $0x8,%esp
  8109c0:	53                   	push   %ebx
  8109c1:	6a 00                	push   $0x0
  8109c3:	e8 73 ea ff ff       	call   80f43b <sys_page_unmap>
  8109c8:	83 c4 10             	add    $0x10,%esp
  8109cb:	eb eb                	jmp    8109b8 <free+0x97>

008109cd <malloc>:
{
  8109cd:	55                   	push   %ebp
  8109ce:	89 e5                	mov    %esp,%ebp
  8109d0:	57                   	push   %edi
  8109d1:	56                   	push   %esi
  8109d2:	53                   	push   %ebx
  8109d3:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  8109d6:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
  8109db:	85 c0                	test   %eax,%eax
  8109dd:	74 74                	je     810a53 <malloc+0x86>
	n = ROUNDUP(n, 4);
  8109df:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8109e2:	8d 51 03             	lea    0x3(%ecx),%edx
  8109e5:	83 e2 fc             	and    $0xfffffffc,%edx
  8109e8:	89 d6                	mov    %edx,%esi
  8109ea:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8109ed:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8109f3:	0f 87 55 01 00 00    	ja     810b4e <malloc+0x181>
	if ((uintptr_t) mptr % PGSIZE){
  8109f9:	89 c1                	mov    %eax,%ecx
  8109fb:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810a00:	74 30                	je     810a32 <malloc+0x65>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  810a02:	89 c3                	mov    %eax,%ebx
  810a04:	c1 eb 0c             	shr    $0xc,%ebx
  810a07:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810a0b:	c1 ea 0c             	shr    $0xc,%edx
  810a0e:	39 d3                	cmp    %edx,%ebx
  810a10:	74 64                	je     810a76 <malloc+0xa9>
		free(mptr);	/* drop reference to this page */
  810a12:	83 ec 0c             	sub    $0xc,%esp
  810a15:	50                   	push   %eax
  810a16:	e8 06 ff ff ff       	call   810921 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810a1b:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
  810a20:	05 00 10 00 00       	add    $0x1000,%eax
  810a25:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810a2a:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
  810a2f:	83 c4 10             	add    $0x10,%esp
  810a32:	8b 15 d4 c1 b3 00    	mov    0xb3c1d4,%edx
{
  810a38:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810a3f:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  810a44:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810a47:	8d 78 04             	lea    0x4(%eax),%edi
  810a4a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810a4e:	e9 86 00 00 00       	jmp    810ad9 <malloc+0x10c>
		mptr = mbegin;
  810a53:	c7 05 d4 c1 b3 00 00 	movl   $0x8000000,0xb3c1d4
  810a5a:	00 00 08 
	n = ROUNDUP(n, 4);
  810a5d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810a60:	8d 51 03             	lea    0x3(%ecx),%edx
  810a63:	83 e2 fc             	and    $0xfffffffc,%edx
  810a66:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810a69:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810a6f:	76 c1                	jbe    810a32 <malloc+0x65>
  810a71:	e9 fd 00 00 00       	jmp    810b73 <malloc+0x1a6>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810a76:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  810a7c:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  810a82:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  810a86:	89 f2                	mov    %esi,%edx
  810a88:	01 c2                	add    %eax,%edx
  810a8a:	89 15 d4 c1 b3 00    	mov    %edx,0xb3c1d4
			return v;
  810a90:	e9 de 00 00 00       	jmp    810b73 <malloc+0x1a6>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810a95:	05 00 10 00 00       	add    $0x1000,%eax
  810a9a:	39 c8                	cmp    %ecx,%eax
  810a9c:	73 66                	jae    810b04 <malloc+0x137>
		if (va >= (uintptr_t) mend
  810a9e:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810aa3:	77 22                	ja     810ac7 <malloc+0xfa>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810aa5:	89 c3                	mov    %eax,%ebx
  810aa7:	c1 eb 16             	shr    $0x16,%ebx
  810aaa:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  810ab1:	f6 c3 01             	test   $0x1,%bl
  810ab4:	74 df                	je     810a95 <malloc+0xc8>
  810ab6:	89 c3                	mov    %eax,%ebx
  810ab8:	c1 eb 0c             	shr    $0xc,%ebx
  810abb:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  810ac2:	f6 c3 01             	test   $0x1,%bl
  810ac5:	74 ce                	je     810a95 <malloc+0xc8>
  810ac7:	81 c2 00 10 00 00    	add    $0x1000,%edx
  810acd:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  810ad1:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  810ad7:	74 0a                	je     810ae3 <malloc+0x116>
  810ad9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810adc:	89 d0                	mov    %edx,%eax
  810ade:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  810ae1:	eb b7                	jmp    810a9a <malloc+0xcd>
			mptr = mbegin;
  810ae3:	ba 00 00 00 08       	mov    $0x8000000,%edx
  810ae8:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  810aed:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  810af1:	75 e6                	jne    810ad9 <malloc+0x10c>
  810af3:	c7 05 d4 c1 b3 00 00 	movl   $0x8000000,0xb3c1d4
  810afa:	00 00 08 
				return 0;	/* out of address space */
  810afd:	b8 00 00 00 00       	mov    $0x0,%eax
  810b02:	eb 6f                	jmp    810b73 <malloc+0x1a6>
  810b04:	89 f0                	mov    %esi,%eax
  810b06:	84 c0                	test   %al,%al
  810b08:	74 08                	je     810b12 <malloc+0x145>
  810b0a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810b0d:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  810b12:	bb 00 00 00 00       	mov    $0x0,%ebx
  810b17:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810b1a:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  810b20:	39 f7                	cmp    %esi,%edi
  810b22:	76 57                	jbe    810b7b <malloc+0x1ae>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810b24:	83 ec 04             	sub    $0x4,%esp
  810b27:	68 07 02 00 00       	push   $0x207
  810b2c:	89 d8                	mov    %ebx,%eax
  810b2e:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810b34:	50                   	push   %eax
  810b35:	6a 00                	push   $0x0
  810b37:	e8 7a e8 ff ff       	call   80f3b6 <sys_page_alloc>
  810b3c:	83 c4 10             	add    $0x10,%esp
  810b3f:	85 c0                	test   %eax,%eax
  810b41:	78 55                	js     810b98 <malloc+0x1cb>
	for (i = 0; i < n + 4; i += PGSIZE){
  810b43:	89 f3                	mov    %esi,%ebx
  810b45:	eb d0                	jmp    810b17 <malloc+0x14a>
			return 0;	/* out of physical memory */
  810b47:	b8 00 00 00 00       	mov    $0x0,%eax
  810b4c:	eb 25                	jmp    810b73 <malloc+0x1a6>
		return 0;
  810b4e:	b8 00 00 00 00       	mov    $0x0,%eax
  810b53:	eb 1e                	jmp    810b73 <malloc+0x1a6>
	ref = (uint32_t*) (mptr + i - 4);
  810b55:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810b5a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810b5d:	c7 84 08 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%ecx,1)
  810b64:	02 00 00 00 
	mptr += n;
  810b68:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810b6b:	01 c2                	add    %eax,%edx
  810b6d:	89 15 d4 c1 b3 00    	mov    %edx,0xb3c1d4
}
  810b73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b76:	5b                   	pop    %ebx
  810b77:	5e                   	pop    %esi
  810b78:	5f                   	pop    %edi
  810b79:	5d                   	pop    %ebp
  810b7a:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810b7b:	83 ec 04             	sub    $0x4,%esp
  810b7e:	6a 07                	push   $0x7
  810b80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810b83:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810b89:	50                   	push   %eax
  810b8a:	6a 00                	push   $0x0
  810b8c:	e8 25 e8 ff ff       	call   80f3b6 <sys_page_alloc>
  810b91:	83 c4 10             	add    $0x10,%esp
  810b94:	85 c0                	test   %eax,%eax
  810b96:	79 bd                	jns    810b55 <malloc+0x188>
			for (; i >= 0; i -= PGSIZE)
  810b98:	85 db                	test   %ebx,%ebx
  810b9a:	78 ab                	js     810b47 <malloc+0x17a>
				sys_page_unmap(0, mptr + i);
  810b9c:	83 ec 08             	sub    $0x8,%esp
  810b9f:	89 d8                	mov    %ebx,%eax
  810ba1:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810ba7:	50                   	push   %eax
  810ba8:	6a 00                	push   $0x0
  810baa:	e8 8c e8 ff ff       	call   80f43b <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810baf:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810bb5:	83 c4 10             	add    $0x10,%esp
  810bb8:	eb de                	jmp    810b98 <malloc+0x1cb>

00810bba <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810bba:	55                   	push   %ebp
  810bbb:	89 e5                	mov    %esp,%ebp
  810bbd:	56                   	push   %esi
  810bbe:	53                   	push   %ebx
  810bbf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810bc2:	83 ec 0c             	sub    $0xc,%esp
  810bc5:	ff 75 08             	pushl  0x8(%ebp)
  810bc8:	e8 d1 f0 ff ff       	call   80fc9e <fd2data>
  810bcd:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810bcf:	83 c4 08             	add    $0x8,%esp
  810bd2:	68 1f 40 81 00       	push   $0x81401f
  810bd7:	53                   	push   %ebx
  810bd8:	e8 e7 e3 ff ff       	call   80efc4 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810bdd:	8b 46 04             	mov    0x4(%esi),%eax
  810be0:	2b 06                	sub    (%esi),%eax
  810be2:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810be8:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810bef:	00 00 00 
	stat->st_dev = &devpipe;
  810bf2:	c7 83 88 00 00 00 24 	movl   $0x815324,0x88(%ebx)
  810bf9:	53 81 00 
	return 0;
}
  810bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  810c01:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810c04:	5b                   	pop    %ebx
  810c05:	5e                   	pop    %esi
  810c06:	5d                   	pop    %ebp
  810c07:	c3                   	ret    

00810c08 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810c08:	55                   	push   %ebp
  810c09:	89 e5                	mov    %esp,%ebp
  810c0b:	53                   	push   %ebx
  810c0c:	83 ec 0c             	sub    $0xc,%esp
  810c0f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810c12:	53                   	push   %ebx
  810c13:	6a 00                	push   $0x0
  810c15:	e8 21 e8 ff ff       	call   80f43b <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810c1a:	89 1c 24             	mov    %ebx,(%esp)
  810c1d:	e8 7c f0 ff ff       	call   80fc9e <fd2data>
  810c22:	83 c4 08             	add    $0x8,%esp
  810c25:	50                   	push   %eax
  810c26:	6a 00                	push   $0x0
  810c28:	e8 0e e8 ff ff       	call   80f43b <sys_page_unmap>
}
  810c2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810c30:	c9                   	leave  
  810c31:	c3                   	ret    

00810c32 <_pipeisclosed>:
{
  810c32:	55                   	push   %ebp
  810c33:	89 e5                	mov    %esp,%ebp
  810c35:	57                   	push   %edi
  810c36:	56                   	push   %esi
  810c37:	53                   	push   %ebx
  810c38:	83 ec 1c             	sub    $0x1c,%esp
  810c3b:	89 c7                	mov    %eax,%edi
  810c3d:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810c3f:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  810c44:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810c47:	83 ec 0c             	sub    $0xc,%esp
  810c4a:	57                   	push   %edi
  810c4b:	e8 c2 04 00 00       	call   811112 <pageref>
  810c50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810c53:	89 34 24             	mov    %esi,(%esp)
  810c56:	e8 b7 04 00 00       	call   811112 <pageref>
		nn = thisenv->env_runs;
  810c5b:	8b 15 5c c2 b3 00    	mov    0xb3c25c,%edx
  810c61:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810c64:	83 c4 10             	add    $0x10,%esp
  810c67:	39 cb                	cmp    %ecx,%ebx
  810c69:	74 1b                	je     810c86 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810c6b:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810c6e:	75 cf                	jne    810c3f <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810c70:	8b 42 58             	mov    0x58(%edx),%eax
  810c73:	6a 01                	push   $0x1
  810c75:	50                   	push   %eax
  810c76:	53                   	push   %ebx
  810c77:	68 26 40 81 00       	push   $0x814026
  810c7c:	e8 e4 db ff ff       	call   80e865 <cprintf>
  810c81:	83 c4 10             	add    $0x10,%esp
  810c84:	eb b9                	jmp    810c3f <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810c86:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810c89:	0f 94 c0             	sete   %al
  810c8c:	0f b6 c0             	movzbl %al,%eax
}
  810c8f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810c92:	5b                   	pop    %ebx
  810c93:	5e                   	pop    %esi
  810c94:	5f                   	pop    %edi
  810c95:	5d                   	pop    %ebp
  810c96:	c3                   	ret    

00810c97 <devpipe_write>:
{
  810c97:	55                   	push   %ebp
  810c98:	89 e5                	mov    %esp,%ebp
  810c9a:	57                   	push   %edi
  810c9b:	56                   	push   %esi
  810c9c:	53                   	push   %ebx
  810c9d:	83 ec 28             	sub    $0x28,%esp
  810ca0:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810ca3:	56                   	push   %esi
  810ca4:	e8 f5 ef ff ff       	call   80fc9e <fd2data>
  810ca9:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810cab:	83 c4 10             	add    $0x10,%esp
  810cae:	bf 00 00 00 00       	mov    $0x0,%edi
  810cb3:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810cb6:	74 4f                	je     810d07 <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810cb8:	8b 43 04             	mov    0x4(%ebx),%eax
  810cbb:	8b 0b                	mov    (%ebx),%ecx
  810cbd:	8d 51 20             	lea    0x20(%ecx),%edx
  810cc0:	39 d0                	cmp    %edx,%eax
  810cc2:	72 14                	jb     810cd8 <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810cc4:	89 da                	mov    %ebx,%edx
  810cc6:	89 f0                	mov    %esi,%eax
  810cc8:	e8 65 ff ff ff       	call   810c32 <_pipeisclosed>
  810ccd:	85 c0                	test   %eax,%eax
  810ccf:	75 3b                	jne    810d0c <devpipe_write+0x75>
			sys_yield();
  810cd1:	e8 c1 e6 ff ff       	call   80f397 <sys_yield>
  810cd6:	eb e0                	jmp    810cb8 <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810cd8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810cdb:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810cdf:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810ce2:	89 c2                	mov    %eax,%edx
  810ce4:	c1 fa 1f             	sar    $0x1f,%edx
  810ce7:	89 d1                	mov    %edx,%ecx
  810ce9:	c1 e9 1b             	shr    $0x1b,%ecx
  810cec:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810cef:	83 e2 1f             	and    $0x1f,%edx
  810cf2:	29 ca                	sub    %ecx,%edx
  810cf4:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810cf8:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810cfc:	83 c0 01             	add    $0x1,%eax
  810cff:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810d02:	83 c7 01             	add    $0x1,%edi
  810d05:	eb ac                	jmp    810cb3 <devpipe_write+0x1c>
	return i;
  810d07:	8b 45 10             	mov    0x10(%ebp),%eax
  810d0a:	eb 05                	jmp    810d11 <devpipe_write+0x7a>
				return 0;
  810d0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810d11:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d14:	5b                   	pop    %ebx
  810d15:	5e                   	pop    %esi
  810d16:	5f                   	pop    %edi
  810d17:	5d                   	pop    %ebp
  810d18:	c3                   	ret    

00810d19 <devpipe_read>:
{
  810d19:	55                   	push   %ebp
  810d1a:	89 e5                	mov    %esp,%ebp
  810d1c:	57                   	push   %edi
  810d1d:	56                   	push   %esi
  810d1e:	53                   	push   %ebx
  810d1f:	83 ec 18             	sub    $0x18,%esp
  810d22:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810d25:	57                   	push   %edi
  810d26:	e8 73 ef ff ff       	call   80fc9e <fd2data>
  810d2b:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810d2d:	83 c4 10             	add    $0x10,%esp
  810d30:	be 00 00 00 00       	mov    $0x0,%esi
  810d35:	3b 75 10             	cmp    0x10(%ebp),%esi
  810d38:	75 14                	jne    810d4e <devpipe_read+0x35>
	return i;
  810d3a:	8b 45 10             	mov    0x10(%ebp),%eax
  810d3d:	eb 02                	jmp    810d41 <devpipe_read+0x28>
				return i;
  810d3f:	89 f0                	mov    %esi,%eax
}
  810d41:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d44:	5b                   	pop    %ebx
  810d45:	5e                   	pop    %esi
  810d46:	5f                   	pop    %edi
  810d47:	5d                   	pop    %ebp
  810d48:	c3                   	ret    
			sys_yield();
  810d49:	e8 49 e6 ff ff       	call   80f397 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810d4e:	8b 03                	mov    (%ebx),%eax
  810d50:	3b 43 04             	cmp    0x4(%ebx),%eax
  810d53:	75 18                	jne    810d6d <devpipe_read+0x54>
			if (i > 0)
  810d55:	85 f6                	test   %esi,%esi
  810d57:	75 e6                	jne    810d3f <devpipe_read+0x26>
			if (_pipeisclosed(fd, p))
  810d59:	89 da                	mov    %ebx,%edx
  810d5b:	89 f8                	mov    %edi,%eax
  810d5d:	e8 d0 fe ff ff       	call   810c32 <_pipeisclosed>
  810d62:	85 c0                	test   %eax,%eax
  810d64:	74 e3                	je     810d49 <devpipe_read+0x30>
				return 0;
  810d66:	b8 00 00 00 00       	mov    $0x0,%eax
  810d6b:	eb d4                	jmp    810d41 <devpipe_read+0x28>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810d6d:	99                   	cltd   
  810d6e:	c1 ea 1b             	shr    $0x1b,%edx
  810d71:	01 d0                	add    %edx,%eax
  810d73:	83 e0 1f             	and    $0x1f,%eax
  810d76:	29 d0                	sub    %edx,%eax
  810d78:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810d7d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810d80:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810d83:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810d86:	83 c6 01             	add    $0x1,%esi
  810d89:	eb aa                	jmp    810d35 <devpipe_read+0x1c>

00810d8b <pipe>:
{
  810d8b:	55                   	push   %ebp
  810d8c:	89 e5                	mov    %esp,%ebp
  810d8e:	56                   	push   %esi
  810d8f:	53                   	push   %ebx
  810d90:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810d93:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810d96:	50                   	push   %eax
  810d97:	e8 19 ef ff ff       	call   80fcb5 <fd_alloc>
  810d9c:	89 c3                	mov    %eax,%ebx
  810d9e:	83 c4 10             	add    $0x10,%esp
  810da1:	85 c0                	test   %eax,%eax
  810da3:	0f 88 23 01 00 00    	js     810ecc <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810da9:	83 ec 04             	sub    $0x4,%esp
  810dac:	68 07 04 00 00       	push   $0x407
  810db1:	ff 75 f4             	pushl  -0xc(%ebp)
  810db4:	6a 00                	push   $0x0
  810db6:	e8 fb e5 ff ff       	call   80f3b6 <sys_page_alloc>
  810dbb:	89 c3                	mov    %eax,%ebx
  810dbd:	83 c4 10             	add    $0x10,%esp
  810dc0:	85 c0                	test   %eax,%eax
  810dc2:	0f 88 04 01 00 00    	js     810ecc <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  810dc8:	83 ec 0c             	sub    $0xc,%esp
  810dcb:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810dce:	50                   	push   %eax
  810dcf:	e8 e1 ee ff ff       	call   80fcb5 <fd_alloc>
  810dd4:	89 c3                	mov    %eax,%ebx
  810dd6:	83 c4 10             	add    $0x10,%esp
  810dd9:	85 c0                	test   %eax,%eax
  810ddb:	0f 88 db 00 00 00    	js     810ebc <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810de1:	83 ec 04             	sub    $0x4,%esp
  810de4:	68 07 04 00 00       	push   $0x407
  810de9:	ff 75 f0             	pushl  -0x10(%ebp)
  810dec:	6a 00                	push   $0x0
  810dee:	e8 c3 e5 ff ff       	call   80f3b6 <sys_page_alloc>
  810df3:	89 c3                	mov    %eax,%ebx
  810df5:	83 c4 10             	add    $0x10,%esp
  810df8:	85 c0                	test   %eax,%eax
  810dfa:	0f 88 bc 00 00 00    	js     810ebc <pipe+0x131>
	va = fd2data(fd0);
  810e00:	83 ec 0c             	sub    $0xc,%esp
  810e03:	ff 75 f4             	pushl  -0xc(%ebp)
  810e06:	e8 93 ee ff ff       	call   80fc9e <fd2data>
  810e0b:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810e0d:	83 c4 0c             	add    $0xc,%esp
  810e10:	68 07 04 00 00       	push   $0x407
  810e15:	50                   	push   %eax
  810e16:	6a 00                	push   $0x0
  810e18:	e8 99 e5 ff ff       	call   80f3b6 <sys_page_alloc>
  810e1d:	89 c3                	mov    %eax,%ebx
  810e1f:	83 c4 10             	add    $0x10,%esp
  810e22:	85 c0                	test   %eax,%eax
  810e24:	0f 88 82 00 00 00    	js     810eac <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810e2a:	83 ec 0c             	sub    $0xc,%esp
  810e2d:	ff 75 f0             	pushl  -0x10(%ebp)
  810e30:	e8 69 ee ff ff       	call   80fc9e <fd2data>
  810e35:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810e3c:	50                   	push   %eax
  810e3d:	6a 00                	push   $0x0
  810e3f:	56                   	push   %esi
  810e40:	6a 00                	push   $0x0
  810e42:	e8 b2 e5 ff ff       	call   80f3f9 <sys_page_map>
  810e47:	89 c3                	mov    %eax,%ebx
  810e49:	83 c4 20             	add    $0x20,%esp
  810e4c:	85 c0                	test   %eax,%eax
  810e4e:	78 4e                	js     810e9e <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  810e50:	a1 24 53 81 00       	mov    0x815324,%eax
  810e55:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810e58:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810e5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810e5d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810e64:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810e67:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810e69:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810e6c:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810e73:	83 ec 0c             	sub    $0xc,%esp
  810e76:	ff 75 f4             	pushl  -0xc(%ebp)
  810e79:	e8 10 ee ff ff       	call   80fc8e <fd2num>
  810e7e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810e81:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810e83:	83 c4 04             	add    $0x4,%esp
  810e86:	ff 75 f0             	pushl  -0x10(%ebp)
  810e89:	e8 00 ee ff ff       	call   80fc8e <fd2num>
  810e8e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810e91:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810e94:	83 c4 10             	add    $0x10,%esp
  810e97:	bb 00 00 00 00       	mov    $0x0,%ebx
  810e9c:	eb 2e                	jmp    810ecc <pipe+0x141>
	sys_page_unmap(0, va);
  810e9e:	83 ec 08             	sub    $0x8,%esp
  810ea1:	56                   	push   %esi
  810ea2:	6a 00                	push   $0x0
  810ea4:	e8 92 e5 ff ff       	call   80f43b <sys_page_unmap>
  810ea9:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810eac:	83 ec 08             	sub    $0x8,%esp
  810eaf:	ff 75 f0             	pushl  -0x10(%ebp)
  810eb2:	6a 00                	push   $0x0
  810eb4:	e8 82 e5 ff ff       	call   80f43b <sys_page_unmap>
  810eb9:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810ebc:	83 ec 08             	sub    $0x8,%esp
  810ebf:	ff 75 f4             	pushl  -0xc(%ebp)
  810ec2:	6a 00                	push   $0x0
  810ec4:	e8 72 e5 ff ff       	call   80f43b <sys_page_unmap>
  810ec9:	83 c4 10             	add    $0x10,%esp
}
  810ecc:	89 d8                	mov    %ebx,%eax
  810ece:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810ed1:	5b                   	pop    %ebx
  810ed2:	5e                   	pop    %esi
  810ed3:	5d                   	pop    %ebp
  810ed4:	c3                   	ret    

00810ed5 <pipeisclosed>:
{
  810ed5:	55                   	push   %ebp
  810ed6:	89 e5                	mov    %esp,%ebp
  810ed8:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810edb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810ede:	50                   	push   %eax
  810edf:	ff 75 08             	pushl  0x8(%ebp)
  810ee2:	e8 20 ee ff ff       	call   80fd07 <fd_lookup>
  810ee7:	83 c4 10             	add    $0x10,%esp
  810eea:	85 c0                	test   %eax,%eax
  810eec:	78 18                	js     810f06 <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810eee:	83 ec 0c             	sub    $0xc,%esp
  810ef1:	ff 75 f4             	pushl  -0xc(%ebp)
  810ef4:	e8 a5 ed ff ff       	call   80fc9e <fd2data>
	return _pipeisclosed(fd, p);
  810ef9:	89 c2                	mov    %eax,%edx
  810efb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810efe:	e8 2f fd ff ff       	call   810c32 <_pipeisclosed>
  810f03:	83 c4 10             	add    $0x10,%esp
}
  810f06:	c9                   	leave  
  810f07:	c3                   	ret    

00810f08 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810f08:	b8 00 00 00 00       	mov    $0x0,%eax
  810f0d:	c3                   	ret    

00810f0e <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810f0e:	55                   	push   %ebp
  810f0f:	89 e5                	mov    %esp,%ebp
  810f11:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810f14:	68 3e 40 81 00       	push   $0x81403e
  810f19:	ff 75 0c             	pushl  0xc(%ebp)
  810f1c:	e8 a3 e0 ff ff       	call   80efc4 <strcpy>
	return 0;
}
  810f21:	b8 00 00 00 00       	mov    $0x0,%eax
  810f26:	c9                   	leave  
  810f27:	c3                   	ret    

00810f28 <devcons_write>:
{
  810f28:	55                   	push   %ebp
  810f29:	89 e5                	mov    %esp,%ebp
  810f2b:	57                   	push   %edi
  810f2c:	56                   	push   %esi
  810f2d:	53                   	push   %ebx
  810f2e:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810f34:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810f39:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810f3f:	3b 75 10             	cmp    0x10(%ebp),%esi
  810f42:	73 31                	jae    810f75 <devcons_write+0x4d>
		m = n - tot;
  810f44:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810f47:	29 f3                	sub    %esi,%ebx
  810f49:	83 fb 7f             	cmp    $0x7f,%ebx
  810f4c:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810f51:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810f54:	83 ec 04             	sub    $0x4,%esp
  810f57:	53                   	push   %ebx
  810f58:	89 f0                	mov    %esi,%eax
  810f5a:	03 45 0c             	add    0xc(%ebp),%eax
  810f5d:	50                   	push   %eax
  810f5e:	57                   	push   %edi
  810f5f:	e8 ee e1 ff ff       	call   80f152 <memmove>
		sys_cputs(buf, m);
  810f64:	83 c4 08             	add    $0x8,%esp
  810f67:	53                   	push   %ebx
  810f68:	57                   	push   %edi
  810f69:	e8 8c e3 ff ff       	call   80f2fa <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810f6e:	01 de                	add    %ebx,%esi
  810f70:	83 c4 10             	add    $0x10,%esp
  810f73:	eb ca                	jmp    810f3f <devcons_write+0x17>
}
  810f75:	89 f0                	mov    %esi,%eax
  810f77:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810f7a:	5b                   	pop    %ebx
  810f7b:	5e                   	pop    %esi
  810f7c:	5f                   	pop    %edi
  810f7d:	5d                   	pop    %ebp
  810f7e:	c3                   	ret    

00810f7f <devcons_read>:
{
  810f7f:	55                   	push   %ebp
  810f80:	89 e5                	mov    %esp,%ebp
  810f82:	83 ec 08             	sub    $0x8,%esp
  810f85:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810f8a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810f8e:	74 21                	je     810fb1 <devcons_read+0x32>
	while ((c = sys_cgetc()) == 0)
  810f90:	e8 83 e3 ff ff       	call   80f318 <sys_cgetc>
  810f95:	85 c0                	test   %eax,%eax
  810f97:	75 07                	jne    810fa0 <devcons_read+0x21>
		sys_yield();
  810f99:	e8 f9 e3 ff ff       	call   80f397 <sys_yield>
  810f9e:	eb f0                	jmp    810f90 <devcons_read+0x11>
	if (c < 0)
  810fa0:	78 0f                	js     810fb1 <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  810fa2:	83 f8 04             	cmp    $0x4,%eax
  810fa5:	74 0c                	je     810fb3 <devcons_read+0x34>
	*(char*)vbuf = c;
  810fa7:	8b 55 0c             	mov    0xc(%ebp),%edx
  810faa:	88 02                	mov    %al,(%edx)
	return 1;
  810fac:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810fb1:	c9                   	leave  
  810fb2:	c3                   	ret    
		return 0;
  810fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  810fb8:	eb f7                	jmp    810fb1 <devcons_read+0x32>

00810fba <cputchar>:
{
  810fba:	55                   	push   %ebp
  810fbb:	89 e5                	mov    %esp,%ebp
  810fbd:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810fc0:	8b 45 08             	mov    0x8(%ebp),%eax
  810fc3:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810fc6:	6a 01                	push   $0x1
  810fc8:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810fcb:	50                   	push   %eax
  810fcc:	e8 29 e3 ff ff       	call   80f2fa <sys_cputs>
}
  810fd1:	83 c4 10             	add    $0x10,%esp
  810fd4:	c9                   	leave  
  810fd5:	c3                   	ret    

00810fd6 <getchar>:
{
  810fd6:	55                   	push   %ebp
  810fd7:	89 e5                	mov    %esp,%ebp
  810fd9:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810fdc:	6a 01                	push   $0x1
  810fde:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810fe1:	50                   	push   %eax
  810fe2:	6a 00                	push   $0x0
  810fe4:	e8 8e ef ff ff       	call   80ff77 <read>
	if (r < 0)
  810fe9:	83 c4 10             	add    $0x10,%esp
  810fec:	85 c0                	test   %eax,%eax
  810fee:	78 06                	js     810ff6 <getchar+0x20>
	if (r < 1)
  810ff0:	74 06                	je     810ff8 <getchar+0x22>
	return c;
  810ff2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810ff6:	c9                   	leave  
  810ff7:	c3                   	ret    
		return -E_EOF;
  810ff8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810ffd:	eb f7                	jmp    810ff6 <getchar+0x20>

00810fff <iscons>:
{
  810fff:	55                   	push   %ebp
  811000:	89 e5                	mov    %esp,%ebp
  811002:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811005:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811008:	50                   	push   %eax
  811009:	ff 75 08             	pushl  0x8(%ebp)
  81100c:	e8 f6 ec ff ff       	call   80fd07 <fd_lookup>
  811011:	83 c4 10             	add    $0x10,%esp
  811014:	85 c0                	test   %eax,%eax
  811016:	78 11                	js     811029 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  811018:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81101b:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811021:	39 10                	cmp    %edx,(%eax)
  811023:	0f 94 c0             	sete   %al
  811026:	0f b6 c0             	movzbl %al,%eax
}
  811029:	c9                   	leave  
  81102a:	c3                   	ret    

0081102b <opencons>:
{
  81102b:	55                   	push   %ebp
  81102c:	89 e5                	mov    %esp,%ebp
  81102e:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  811031:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811034:	50                   	push   %eax
  811035:	e8 7b ec ff ff       	call   80fcb5 <fd_alloc>
  81103a:	83 c4 10             	add    $0x10,%esp
  81103d:	85 c0                	test   %eax,%eax
  81103f:	78 3a                	js     81107b <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  811041:	83 ec 04             	sub    $0x4,%esp
  811044:	68 07 04 00 00       	push   $0x407
  811049:	ff 75 f4             	pushl  -0xc(%ebp)
  81104c:	6a 00                	push   $0x0
  81104e:	e8 63 e3 ff ff       	call   80f3b6 <sys_page_alloc>
  811053:	83 c4 10             	add    $0x10,%esp
  811056:	85 c0                	test   %eax,%eax
  811058:	78 21                	js     81107b <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  81105a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81105d:	8b 15 40 53 81 00    	mov    0x815340,%edx
  811063:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  811065:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811068:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  81106f:	83 ec 0c             	sub    $0xc,%esp
  811072:	50                   	push   %eax
  811073:	e8 16 ec ff ff       	call   80fc8e <fd2num>
  811078:	83 c4 10             	add    $0x10,%esp
}
  81107b:	c9                   	leave  
  81107c:	c3                   	ret    

0081107d <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  81107d:	55                   	push   %ebp
  81107e:	89 e5                	mov    %esp,%ebp
  811080:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  811083:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  81108a:	74 0a                	je     811096 <set_pgfault_handler+0x19>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
		// panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  81108c:	8b 45 08             	mov    0x8(%ebp),%eax
  81108f:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  811094:	c9                   	leave  
  811095:	c3                   	ret    
		r = sys_page_alloc((envid_t)0, (void*)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P);
  811096:	83 ec 04             	sub    $0x4,%esp
  811099:	6a 07                	push   $0x7
  81109b:	68 00 f0 bf ee       	push   $0xeebff000
  8110a0:	6a 00                	push   $0x0
  8110a2:	e8 0f e3 ff ff       	call   80f3b6 <sys_page_alloc>
		if(r < 0)
  8110a7:	83 c4 10             	add    $0x10,%esp
  8110aa:	85 c0                	test   %eax,%eax
  8110ac:	78 2a                	js     8110d8 <set_pgfault_handler+0x5b>
		r = sys_env_set_pgfault_upcall((envid_t)0, _pgfault_upcall);
  8110ae:	83 ec 08             	sub    $0x8,%esp
  8110b1:	68 ec 10 81 00       	push   $0x8110ec
  8110b6:	6a 00                	push   $0x0
  8110b8:	e8 44 e4 ff ff       	call   80f501 <sys_env_set_pgfault_upcall>
		if(r < 0)
  8110bd:	83 c4 10             	add    $0x10,%esp
  8110c0:	85 c0                	test   %eax,%eax
  8110c2:	79 c8                	jns    81108c <set_pgfault_handler+0xf>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
  8110c4:	83 ec 04             	sub    $0x4,%esp
  8110c7:	68 7c 40 81 00       	push   $0x81407c
  8110cc:	6a 25                	push   $0x25
  8110ce:	68 b8 40 81 00       	push   $0x8140b8
  8110d3:	e8 97 d6 ff ff       	call   80e76f <_panic>
			panic("the sys_page_alloc() return value is wrong!\n");
  8110d8:	83 ec 04             	sub    $0x4,%esp
  8110db:	68 4c 40 81 00       	push   $0x81404c
  8110e0:	6a 22                	push   $0x22
  8110e2:	68 b8 40 81 00       	push   $0x8140b8
  8110e7:	e8 83 d6 ff ff       	call   80e76f <_panic>

008110ec <_pgfault_upcall>:
_pgfault_upcall:
	//movl testxixi, %eax 
	//call *%eax 

	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  8110ec:	54                   	push   %esp
	movl _pgfault_handler, %eax
  8110ed:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  8110f2:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  8110f4:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %ebx 
  8110f7:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl 0x30(%esp), %eax 
  8110fb:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax 
  8110ff:	83 e8 04             	sub    $0x4,%eax
	movl %ebx, (%eax)
  811102:	89 18                	mov    %ebx,(%eax)
	movl %eax, 0x30(%esp)
  811104:	89 44 24 30          	mov    %eax,0x30(%esp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp 
  811108:	83 c4 08             	add    $0x8,%esp
	popal
  81110b:	61                   	popa   
	
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp
  81110c:	83 c4 04             	add    $0x4,%esp
	popfl
  81110f:	9d                   	popf   
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  811110:	5c                   	pop    %esp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
  811111:	c3                   	ret    

00811112 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  811112:	55                   	push   %ebp
  811113:	89 e5                	mov    %esp,%ebp
  811115:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811118:	89 d0                	mov    %edx,%eax
  81111a:	c1 e8 16             	shr    $0x16,%eax
  81111d:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  811124:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  811129:	f6 c1 01             	test   $0x1,%cl
  81112c:	74 1d                	je     81114b <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  81112e:	c1 ea 0c             	shr    $0xc,%edx
  811131:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  811138:	f6 c2 01             	test   $0x1,%dl
  81113b:	74 0e                	je     81114b <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  81113d:	c1 ea 0c             	shr    $0xc,%edx
  811140:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  811147:	ef 
  811148:	0f b7 c0             	movzwl %ax,%eax
}
  81114b:	5d                   	pop    %ebp
  81114c:	c3                   	ret    
  81114d:	66 90                	xchg   %ax,%ax
  81114f:	90                   	nop

00811150 <__udivdi3>:
  811150:	55                   	push   %ebp
  811151:	57                   	push   %edi
  811152:	56                   	push   %esi
  811153:	53                   	push   %ebx
  811154:	83 ec 1c             	sub    $0x1c,%esp
  811157:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  81115b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  81115f:	8b 74 24 34          	mov    0x34(%esp),%esi
  811163:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  811167:	85 d2                	test   %edx,%edx
  811169:	75 4d                	jne    8111b8 <__udivdi3+0x68>
  81116b:	39 f3                	cmp    %esi,%ebx
  81116d:	76 19                	jbe    811188 <__udivdi3+0x38>
  81116f:	31 ff                	xor    %edi,%edi
  811171:	89 e8                	mov    %ebp,%eax
  811173:	89 f2                	mov    %esi,%edx
  811175:	f7 f3                	div    %ebx
  811177:	89 fa                	mov    %edi,%edx
  811179:	83 c4 1c             	add    $0x1c,%esp
  81117c:	5b                   	pop    %ebx
  81117d:	5e                   	pop    %esi
  81117e:	5f                   	pop    %edi
  81117f:	5d                   	pop    %ebp
  811180:	c3                   	ret    
  811181:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811188:	89 d9                	mov    %ebx,%ecx
  81118a:	85 db                	test   %ebx,%ebx
  81118c:	75 0b                	jne    811199 <__udivdi3+0x49>
  81118e:	b8 01 00 00 00       	mov    $0x1,%eax
  811193:	31 d2                	xor    %edx,%edx
  811195:	f7 f3                	div    %ebx
  811197:	89 c1                	mov    %eax,%ecx
  811199:	31 d2                	xor    %edx,%edx
  81119b:	89 f0                	mov    %esi,%eax
  81119d:	f7 f1                	div    %ecx
  81119f:	89 c6                	mov    %eax,%esi
  8111a1:	89 e8                	mov    %ebp,%eax
  8111a3:	89 f7                	mov    %esi,%edi
  8111a5:	f7 f1                	div    %ecx
  8111a7:	89 fa                	mov    %edi,%edx
  8111a9:	83 c4 1c             	add    $0x1c,%esp
  8111ac:	5b                   	pop    %ebx
  8111ad:	5e                   	pop    %esi
  8111ae:	5f                   	pop    %edi
  8111af:	5d                   	pop    %ebp
  8111b0:	c3                   	ret    
  8111b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111b8:	39 f2                	cmp    %esi,%edx
  8111ba:	77 1c                	ja     8111d8 <__udivdi3+0x88>
  8111bc:	0f bd fa             	bsr    %edx,%edi
  8111bf:	83 f7 1f             	xor    $0x1f,%edi
  8111c2:	75 2c                	jne    8111f0 <__udivdi3+0xa0>
  8111c4:	39 f2                	cmp    %esi,%edx
  8111c6:	72 06                	jb     8111ce <__udivdi3+0x7e>
  8111c8:	31 c0                	xor    %eax,%eax
  8111ca:	39 eb                	cmp    %ebp,%ebx
  8111cc:	77 a9                	ja     811177 <__udivdi3+0x27>
  8111ce:	b8 01 00 00 00       	mov    $0x1,%eax
  8111d3:	eb a2                	jmp    811177 <__udivdi3+0x27>
  8111d5:	8d 76 00             	lea    0x0(%esi),%esi
  8111d8:	31 ff                	xor    %edi,%edi
  8111da:	31 c0                	xor    %eax,%eax
  8111dc:	89 fa                	mov    %edi,%edx
  8111de:	83 c4 1c             	add    $0x1c,%esp
  8111e1:	5b                   	pop    %ebx
  8111e2:	5e                   	pop    %esi
  8111e3:	5f                   	pop    %edi
  8111e4:	5d                   	pop    %ebp
  8111e5:	c3                   	ret    
  8111e6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111ed:	8d 76 00             	lea    0x0(%esi),%esi
  8111f0:	89 f9                	mov    %edi,%ecx
  8111f2:	b8 20 00 00 00       	mov    $0x20,%eax
  8111f7:	29 f8                	sub    %edi,%eax
  8111f9:	d3 e2                	shl    %cl,%edx
  8111fb:	89 54 24 08          	mov    %edx,0x8(%esp)
  8111ff:	89 c1                	mov    %eax,%ecx
  811201:	89 da                	mov    %ebx,%edx
  811203:	d3 ea                	shr    %cl,%edx
  811205:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811209:	09 d1                	or     %edx,%ecx
  81120b:	89 f2                	mov    %esi,%edx
  81120d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811211:	89 f9                	mov    %edi,%ecx
  811213:	d3 e3                	shl    %cl,%ebx
  811215:	89 c1                	mov    %eax,%ecx
  811217:	d3 ea                	shr    %cl,%edx
  811219:	89 f9                	mov    %edi,%ecx
  81121b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81121f:	89 eb                	mov    %ebp,%ebx
  811221:	d3 e6                	shl    %cl,%esi
  811223:	89 c1                	mov    %eax,%ecx
  811225:	d3 eb                	shr    %cl,%ebx
  811227:	09 de                	or     %ebx,%esi
  811229:	89 f0                	mov    %esi,%eax
  81122b:	f7 74 24 08          	divl   0x8(%esp)
  81122f:	89 d6                	mov    %edx,%esi
  811231:	89 c3                	mov    %eax,%ebx
  811233:	f7 64 24 0c          	mull   0xc(%esp)
  811237:	39 d6                	cmp    %edx,%esi
  811239:	72 15                	jb     811250 <__udivdi3+0x100>
  81123b:	89 f9                	mov    %edi,%ecx
  81123d:	d3 e5                	shl    %cl,%ebp
  81123f:	39 c5                	cmp    %eax,%ebp
  811241:	73 04                	jae    811247 <__udivdi3+0xf7>
  811243:	39 d6                	cmp    %edx,%esi
  811245:	74 09                	je     811250 <__udivdi3+0x100>
  811247:	89 d8                	mov    %ebx,%eax
  811249:	31 ff                	xor    %edi,%edi
  81124b:	e9 27 ff ff ff       	jmp    811177 <__udivdi3+0x27>
  811250:	8d 43 ff             	lea    -0x1(%ebx),%eax
  811253:	31 ff                	xor    %edi,%edi
  811255:	e9 1d ff ff ff       	jmp    811177 <__udivdi3+0x27>
  81125a:	66 90                	xchg   %ax,%ax
  81125c:	66 90                	xchg   %ax,%ax
  81125e:	66 90                	xchg   %ax,%ax

00811260 <__umoddi3>:
  811260:	55                   	push   %ebp
  811261:	57                   	push   %edi
  811262:	56                   	push   %esi
  811263:	53                   	push   %ebx
  811264:	83 ec 1c             	sub    $0x1c,%esp
  811267:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  81126b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  81126f:	8b 74 24 30          	mov    0x30(%esp),%esi
  811273:	8b 7c 24 38          	mov    0x38(%esp),%edi
  811277:	89 da                	mov    %ebx,%edx
  811279:	85 c0                	test   %eax,%eax
  81127b:	75 43                	jne    8112c0 <__umoddi3+0x60>
  81127d:	39 df                	cmp    %ebx,%edi
  81127f:	76 17                	jbe    811298 <__umoddi3+0x38>
  811281:	89 f0                	mov    %esi,%eax
  811283:	f7 f7                	div    %edi
  811285:	89 d0                	mov    %edx,%eax
  811287:	31 d2                	xor    %edx,%edx
  811289:	83 c4 1c             	add    $0x1c,%esp
  81128c:	5b                   	pop    %ebx
  81128d:	5e                   	pop    %esi
  81128e:	5f                   	pop    %edi
  81128f:	5d                   	pop    %ebp
  811290:	c3                   	ret    
  811291:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811298:	89 fd                	mov    %edi,%ebp
  81129a:	85 ff                	test   %edi,%edi
  81129c:	75 0b                	jne    8112a9 <__umoddi3+0x49>
  81129e:	b8 01 00 00 00       	mov    $0x1,%eax
  8112a3:	31 d2                	xor    %edx,%edx
  8112a5:	f7 f7                	div    %edi
  8112a7:	89 c5                	mov    %eax,%ebp
  8112a9:	89 d8                	mov    %ebx,%eax
  8112ab:	31 d2                	xor    %edx,%edx
  8112ad:	f7 f5                	div    %ebp
  8112af:	89 f0                	mov    %esi,%eax
  8112b1:	f7 f5                	div    %ebp
  8112b3:	89 d0                	mov    %edx,%eax
  8112b5:	eb d0                	jmp    811287 <__umoddi3+0x27>
  8112b7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8112be:	66 90                	xchg   %ax,%ax
  8112c0:	89 f1                	mov    %esi,%ecx
  8112c2:	39 d8                	cmp    %ebx,%eax
  8112c4:	76 0a                	jbe    8112d0 <__umoddi3+0x70>
  8112c6:	89 f0                	mov    %esi,%eax
  8112c8:	83 c4 1c             	add    $0x1c,%esp
  8112cb:	5b                   	pop    %ebx
  8112cc:	5e                   	pop    %esi
  8112cd:	5f                   	pop    %edi
  8112ce:	5d                   	pop    %ebp
  8112cf:	c3                   	ret    
  8112d0:	0f bd e8             	bsr    %eax,%ebp
  8112d3:	83 f5 1f             	xor    $0x1f,%ebp
  8112d6:	75 20                	jne    8112f8 <__umoddi3+0x98>
  8112d8:	39 d8                	cmp    %ebx,%eax
  8112da:	0f 82 b0 00 00 00    	jb     811390 <__umoddi3+0x130>
  8112e0:	39 f7                	cmp    %esi,%edi
  8112e2:	0f 86 a8 00 00 00    	jbe    811390 <__umoddi3+0x130>
  8112e8:	89 c8                	mov    %ecx,%eax
  8112ea:	83 c4 1c             	add    $0x1c,%esp
  8112ed:	5b                   	pop    %ebx
  8112ee:	5e                   	pop    %esi
  8112ef:	5f                   	pop    %edi
  8112f0:	5d                   	pop    %ebp
  8112f1:	c3                   	ret    
  8112f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8112f8:	89 e9                	mov    %ebp,%ecx
  8112fa:	ba 20 00 00 00       	mov    $0x20,%edx
  8112ff:	29 ea                	sub    %ebp,%edx
  811301:	d3 e0                	shl    %cl,%eax
  811303:	89 44 24 08          	mov    %eax,0x8(%esp)
  811307:	89 d1                	mov    %edx,%ecx
  811309:	89 f8                	mov    %edi,%eax
  81130b:	d3 e8                	shr    %cl,%eax
  81130d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811311:	89 54 24 04          	mov    %edx,0x4(%esp)
  811315:	8b 54 24 04          	mov    0x4(%esp),%edx
  811319:	09 c1                	or     %eax,%ecx
  81131b:	89 d8                	mov    %ebx,%eax
  81131d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811321:	89 e9                	mov    %ebp,%ecx
  811323:	d3 e7                	shl    %cl,%edi
  811325:	89 d1                	mov    %edx,%ecx
  811327:	d3 e8                	shr    %cl,%eax
  811329:	89 e9                	mov    %ebp,%ecx
  81132b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81132f:	d3 e3                	shl    %cl,%ebx
  811331:	89 c7                	mov    %eax,%edi
  811333:	89 d1                	mov    %edx,%ecx
  811335:	89 f0                	mov    %esi,%eax
  811337:	d3 e8                	shr    %cl,%eax
  811339:	89 e9                	mov    %ebp,%ecx
  81133b:	89 fa                	mov    %edi,%edx
  81133d:	d3 e6                	shl    %cl,%esi
  81133f:	09 d8                	or     %ebx,%eax
  811341:	f7 74 24 08          	divl   0x8(%esp)
  811345:	89 d1                	mov    %edx,%ecx
  811347:	89 f3                	mov    %esi,%ebx
  811349:	f7 64 24 0c          	mull   0xc(%esp)
  81134d:	89 c6                	mov    %eax,%esi
  81134f:	89 d7                	mov    %edx,%edi
  811351:	39 d1                	cmp    %edx,%ecx
  811353:	72 06                	jb     81135b <__umoddi3+0xfb>
  811355:	75 10                	jne    811367 <__umoddi3+0x107>
  811357:	39 c3                	cmp    %eax,%ebx
  811359:	73 0c                	jae    811367 <__umoddi3+0x107>
  81135b:	2b 44 24 0c          	sub    0xc(%esp),%eax
  81135f:	1b 54 24 08          	sbb    0x8(%esp),%edx
  811363:	89 d7                	mov    %edx,%edi
  811365:	89 c6                	mov    %eax,%esi
  811367:	89 ca                	mov    %ecx,%edx
  811369:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  81136e:	29 f3                	sub    %esi,%ebx
  811370:	19 fa                	sbb    %edi,%edx
  811372:	89 d0                	mov    %edx,%eax
  811374:	d3 e0                	shl    %cl,%eax
  811376:	89 e9                	mov    %ebp,%ecx
  811378:	d3 eb                	shr    %cl,%ebx
  81137a:	d3 ea                	shr    %cl,%edx
  81137c:	09 d8                	or     %ebx,%eax
  81137e:	83 c4 1c             	add    $0x1c,%esp
  811381:	5b                   	pop    %ebx
  811382:	5e                   	pop    %esi
  811383:	5f                   	pop    %edi
  811384:	5d                   	pop    %ebp
  811385:	c3                   	ret    
  811386:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81138d:	8d 76 00             	lea    0x0(%esi),%esi
  811390:	89 da                	mov    %ebx,%edx
  811392:	29 fe                	sub    %edi,%esi
  811394:	19 c2                	sbb    %eax,%edx
  811396:	89 f1                	mov    %esi,%ecx
  811398:	89 c8                	mov    %ecx,%eax
  81139a:	e9 4b ff ff ff       	jmp    8112ea <__umoddi3+0x8a>
