
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 bb e4 00 00       	call   80e4ec <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 1a a5 00 00       	call   80a562 <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 5f a5 00 00       	call   80a5cc <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 87 a8 00 00       	call   80a909 <e2s>
  800082:	50                   	push   %eax
  800083:	68 e0 11 81 00       	push   $0x8111e0
  800088:	6a 7a                	push   $0x7a
  80008a:	68 15 13 81 00       	push   $0x811315
  80008f:	e8 14 e5 00 00       	call   80e5a8 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 80 f3 00 00       	call   80f421 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 91 a4 00 00       	call   80a539 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 8a a4 00 00       	call   80a53a <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 b9 a6 00 00       	call   80a778 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 c0 13 81 00 	jmp    *0x8113c0(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 0c 0d 00 00       	call   800e09 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 7d ee 00 00       	call   80ef8b <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 33 f1 00 00       	call   80f274 <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 05 06 01 00       	call   81074e <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 76 14             	pushl  0x14(%esi)
  80015a:	8d 46 04             	lea    0x4(%esi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 36                	pushl  (%esi)
  800160:	e8 56 0e 00 00       	call   800fbb <lwip_bind>
  800165:	89 c7                	mov    %eax,%edi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 76 04             	pushl  0x4(%esi)
  800172:	ff 36                	pushl  (%esi)
  800174:	e8 9d 19 00 00       	call   801b16 <lwip_shutdown>
  800179:	89 c7                	mov    %eax,%edi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 36                	pushl  (%esi)
  800185:	e8 e7 0e 00 00       	call   801071 <lwip_close>
  80018a:	89 c7                	mov    %eax,%edi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 76 14             	pushl  0x14(%esi)
  800197:	8d 46 04             	lea    0x4(%esi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 36                	pushl  (%esi)
  80019d:	e8 58 0f 00 00       	call   8010fa <lwip_connect>
  8001a2:	89 c7                	mov    %eax,%edi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 76 04             	pushl  0x4(%esi)
  8001b2:	ff 36                	pushl  (%esi)
  8001b4:	e8 f7 0f 00 00       	call   8011b0 <lwip_listen>
  8001b9:	89 c7                	mov    %eax,%edi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 76 08             	pushl  0x8(%esi)
  8001c6:	ff 76 04             	pushl  0x4(%esi)
  8001c9:	56                   	push   %esi
  8001ca:	ff 36                	pushl  (%esi)
  8001cc:	e8 ca 12 00 00       	call   80149b <lwip_recv>
  8001d1:	89 c7                	mov    %eax,%edi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 76 08             	pushl  0x8(%esi)
  8001de:	ff 76 04             	pushl  0x4(%esi)
  8001e1:	8d 46 0c             	lea    0xc(%esi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 36                	pushl  (%esi)
  8001e7:	e8 41 14 00 00       	call   80162d <lwip_send>
  8001ec:	89 c7                	mov    %eax,%edi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 76 08             	pushl  0x8(%esi)
  8001fc:	ff 76 04             	pushl  0x4(%esi)
  8001ff:	ff 36                	pushl  (%esi)
  800201:	e8 b8 14 00 00       	call   8016be <lwip_socket>
  800206:	89 c7                	mov    %eax,%edi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	56                   	push   %esi
  800214:	68 00 b2 b3 00       	push   $0xb3b200
  800219:	e8 da a7 00 00       	call   80a9f8 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	bf 00 00 00 00       	mov    $0x0,%edi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	56                   	push   %esi
  80022f:	ff 73 04             	pushl  0x4(%ebx)
  800232:	68 00 12 81 00       	push   $0x811200
  800237:	e8 62 e4 00 00       	call   80e69e <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	pushl  (%ebx)
  80024b:	68 20 13 81 00       	push   $0x811320
  800250:	6a 64                	push   $0x64
  800252:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800255:	56                   	push   %esi
  800256:	e8 4f eb 00 00       	call   80edaa <snprintf>
		perror(buf);
  80025b:	89 34 24             	mov    %esi,(%esp)
  80025e:	e8 82 a6 00 00       	call   80a8e5 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	57                   	push   %edi
  800270:	ff 73 04             	pushl  0x4(%ebx)
  800273:	e8 b0 f7 00 00       	call   80fa28 <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 a9 a2 00 00       	call   80a539 <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 01 21 00 00       	call   8023a9 <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 8d a2 00 00       	call   80a53a <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 be a4 00 00       	call   80a778 <thread_wait>
	lwip_core_lock();
  8002ba:	e8 7a a2 00 00       	call   80a539 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 fa 64 80 00       	push   $0x8064fa
  8002d6:	68 e3 aa 80 00       	push   $0x80aae3
  8002db:	68 14 50 81 00       	push   $0x815014
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 b2 b3 00       	push   $0xb3b200
  8002f1:	e8 09 43 00 00       	call   8045ff <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 b2 b3 00       	push   $0xb3b200
  800309:	e8 a3 43 00 00       	call   8046b1 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800315:	e8 a4 43 00 00       	call   8046be <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 2f 13 81 00       	mov    $0x81132f,%ecx
  800326:	ba bc 94 80 00       	mov    $0x8094bc,%edx
  80032b:	b8 34 50 81 00       	mov    $0x815034,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 39 13 81 00       	mov    $0x811339,%ecx
  800341:	ba 86 56 80 00       	mov    $0x805686,%edx
  800346:	b8 28 50 81 00       	mov    $0x815028,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 45 13 81 00       	mov    $0x811345,%ecx
  80035c:	ba 3f 5c 80 00       	mov    $0x805c3f,%edx
  800361:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 aa 72 00 00       	call   80761d <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 44 12 81 00       	push   $0x811244
  8003a9:	e8 f0 e2 00 00       	call   80e69e <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 84 a1 00 00       	call   80a53a <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 51 13 81 00       	push   $0x811351
  8003be:	e8 db e2 00 00       	call   80e69e <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 24 12 81 00       	push   $0x811224
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 15 13 81 00       	push   $0x811315
  8003dc:	e8 c7 e1 00 00       	call   80e5a8 <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 9d 00 00 00       	jmp    80048f <serve+0xae>
		perm = 0;
  8003f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f9:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003fe:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800405:	74 1c                	je     800423 <serve+0x42>
	for (i = 0; i < QUEUE_SIZE; i++)
  800407:	83 c0 01             	add    $0x1,%eax
  80040a:	83 f8 14             	cmp    $0x14,%eax
  80040d:	75 ef                	jne    8003fe <serve+0x1d>
		panic("NS: buffer overflow");
  80040f:	83 ec 04             	sub    $0x4,%esp
  800412:	68 6a 13 81 00       	push   $0x81136a
  800417:	6a 3f                	push   $0x3f
  800419:	68 15 13 81 00       	push   $0x811315
  80041e:	e8 85 e1 00 00       	call   80e5a8 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800423:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  800429:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042c:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800433:	83 ec 04             	sub    $0x4,%esp
  800436:	57                   	push   %edi
  800437:	53                   	push   %ebx
  800438:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043b:	50                   	push   %eax
  80043c:	e8 7e f5 00 00       	call   80f9bf <ipc_recv>
  800441:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800443:	83 c4 10             	add    $0x10,%esp
  800446:	83 f8 0c             	cmp    $0xc,%eax
  800449:	74 69                	je     8004b4 <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80044b:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80044f:	0f 84 ba 00 00 00    	je     80050f <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800455:	83 ec 0c             	sub    $0xc,%esp
  800458:	6a 0c                	push   $0xc
  80045a:	e8 9b 03 01 00       	call   8107fa <malloc>
		if (!args)
  80045f:	83 c4 10             	add    $0x10,%esp
  800462:	85 c0                	test   %eax,%eax
  800464:	0f 84 bd 00 00 00    	je     800527 <serve+0x146>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80046a:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  80046c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80046f:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800472:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  800475:	50                   	push   %eax
  800476:	68 c4 00 80 00       	push   $0x8000c4
  80047b:	68 7e 13 81 00       	push   $0x81137e
  800480:	6a 00                	push   $0x0
  800482:	e8 45 a1 00 00       	call   80a5cc <thread_create>
		thread_yield(); // let the thread created run
  800487:	e8 69 a2 00 00       	call   80a6f5 <thread_yield>
  80048c:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  800494:	e8 ea a0 00 00       	call   80a583 <thread_wakeups_pending>
  800499:	85 c0                	test   %eax,%eax
  80049b:	0f 84 51 ff ff ff    	je     8003f2 <serve+0x11>
  8004a1:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a4:	0f 8f 48 ff ff ff    	jg     8003f2 <serve+0x11>
			thread_yield();
  8004aa:	e8 46 a2 00 00       	call   80a6f5 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004af:	83 c3 01             	add    $0x1,%ebx
  8004b2:	eb e0                	jmp    800494 <serve+0xb3>
			process_timer(whom);
  8004b4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b7:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004bd:	74 23                	je     8004e2 <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004bf:	83 ec 08             	sub    $0x8,%esp
  8004c2:	56                   	push   %esi
  8004c3:	68 80 12 81 00       	push   $0x811280
  8004c8:	e8 d1 e1 00 00       	call   80e69e <cprintf>
  8004cd:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004d0:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d6:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d9:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
  8004e0:	eb ad                	jmp    80048f <serve+0xae>
	start = sys_time_msec();
  8004e2:	e8 3a ef 00 00       	call   80f421 <sys_time_msec>
  8004e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ea:	e8 06 a2 00 00       	call   80a6f5 <thread_yield>
	now = sys_time_msec();
  8004ef:	e8 2d ef 00 00       	call   80f421 <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004f4:	6a 00                	push   $0x0
  8004f6:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004fb:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800501:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800503:	52                   	push   %edx
  800504:	56                   	push   %esi
  800505:	e8 1e f5 00 00       	call   80fa28 <ipc_send>
  80050a:	83 c4 10             	add    $0x10,%esp
  80050d:	eb c1                	jmp    8004d0 <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050f:	83 ec 08             	sub    $0x8,%esp
  800512:	ff 75 e4             	pushl  -0x1c(%ebp)
  800515:	68 bc 12 81 00       	push   $0x8112bc
  80051a:	e8 7f e1 00 00       	call   80e69e <cprintf>
			continue; // just leave it hanging...
  80051f:	83 c4 10             	add    $0x10,%esp
  800522:	e9 68 ff ff ff       	jmp    80048f <serve+0xae>
			panic("could not allocate thread args structure");
  800527:	83 ec 04             	sub    $0x4,%esp
  80052a:	68 ec 12 81 00       	push   $0x8112ec
  80052f:	68 27 01 00 00       	push   $0x127
  800534:	68 15 13 81 00       	push   $0x811315
  800539:	e8 6a e0 00 00       	call   80e5a8 <_panic>

0080053e <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80053e:	55                   	push   %ebp
  80053f:	89 e5                	mov    %esp,%ebp
  800541:	56                   	push   %esi
  800542:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800543:	83 ec 0c             	sub    $0xc,%esp
  800546:	68 8b 13 81 00       	push   $0x81138b
  80054b:	e8 7c 73 00 00       	call   8078cc <inet_addr>
  800550:	89 c6                	mov    %eax,%esi
  800552:	c7 04 24 94 13 81 00 	movl   $0x811394,(%esp)
  800559:	e8 6e 73 00 00       	call   8078cc <inet_addr>
  80055e:	89 c3                	mov    %eax,%ebx
  800560:	c7 04 24 a2 13 81 00 	movl   $0x8113a2,(%esp)
  800567:	e8 60 73 00 00       	call   8078cc <inet_addr>
  80056c:	83 c4 0c             	add    $0xc,%esp
  80056f:	56                   	push   %esi
  800570:	53                   	push   %ebx
  800571:	50                   	push   %eax
  800572:	e8 09 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800577:	e8 65 fe ff ff       	call   8003e1 <serve>

0080057c <umain>:
}

void
umain(int argc, char **argv)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	53                   	push   %ebx
  800580:	83 ec 04             	sub    $0x4,%esp
	envid_t ns_envid = sys_getenvid();
  800583:	e8 29 ec 00 00       	call   80f1b1 <sys_getenvid>
  800588:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80058a:	c7 05 e8 42 81 00 eb 	movl   $0x813deb,0x8142e8
  800591:	3d 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800594:	e8 94 f1 00 00       	call   80f72d <fork>
  800599:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  80059e:	85 c0                	test   %eax,%eax
  8005a0:	78 43                	js     8005e5 <umain+0x69>
		panic("error forking");
	else if (timer_envid == 0) {
  8005a2:	74 58                	je     8005fc <umain+0x80>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005a4:	e8 84 f1 00 00       	call   80f72d <fork>
	if (input_envid < 0)
  8005a9:	85 c0                	test   %eax,%eax
  8005ab:	78 65                	js     800612 <umain+0x96>
		panic("error forking");
	else if (input_envid == 0) {
  8005ad:	74 7a                	je     800629 <umain+0xad>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005af:	e8 79 f1 00 00       	call   80f72d <fork>
  8005b4:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005b9:	85 c0                	test   %eax,%eax
  8005bb:	78 7a                	js     800637 <umain+0xbb>
		panic("error forking");
	else if (output_envid == 0) {
  8005bd:	0f 84 8b 00 00 00    	je     80064e <umain+0xd2>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005c3:	e8 73 9f 00 00       	call   80a53b <thread_init>
	thread_create(0, "main", tmain, 0);
  8005c8:	6a 00                	push   $0x0
  8005ca:	68 3e 05 80 00       	push   $0x80053e
  8005cf:	68 ba 13 81 00       	push   $0x8113ba
  8005d4:	6a 00                	push   $0x0
  8005d6:	e8 f1 9f 00 00       	call   80a5cc <thread_create>
	thread_yield();
  8005db:	e8 15 a1 00 00       	call   80a6f5 <thread_yield>
  8005e0:	83 c4 10             	add    $0x10,%esp
  8005e3:	eb 28                	jmp    80060d <umain+0x91>
		panic("error forking");
  8005e5:	83 ec 04             	sub    $0x4,%esp
  8005e8:	68 ac 13 81 00       	push   $0x8113ac
  8005ed:	68 44 01 00 00       	push   $0x144
  8005f2:	68 15 13 81 00       	push   $0x811315
  8005f7:	e8 ac df 00 00       	call   80e5a8 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  8005fc:	83 ec 08             	sub    $0x8,%esp
  8005ff:	68 fa 00 00 00       	push   $0xfa
  800604:	53                   	push   %ebx
  800605:	e8 52 00 00 00       	call   80065c <timer>
		return;
  80060a:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  80060d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800610:	c9                   	leave  
  800611:	c3                   	ret    
		panic("error forking");
  800612:	83 ec 04             	sub    $0x4,%esp
  800615:	68 ac 13 81 00       	push   $0x8113ac
  80061a:	68 4e 01 00 00       	push   $0x14e
  80061f:	68 15 13 81 00       	push   $0x811315
  800624:	e8 7f df 00 00       	call   80e5a8 <_panic>
		input(ns_envid);
  800629:	83 ec 0c             	sub    $0xc,%esp
  80062c:	53                   	push   %ebx
  80062d:	e8 bd 00 00 00       	call   8006ef <input>
		return;
  800632:	83 c4 10             	add    $0x10,%esp
  800635:	eb d6                	jmp    80060d <umain+0x91>
		panic("error forking");
  800637:	83 ec 04             	sub    $0x4,%esp
  80063a:	68 ac 13 81 00       	push   $0x8113ac
  80063f:	68 58 01 00 00       	push   $0x158
  800644:	68 15 13 81 00       	push   $0x811315
  800649:	e8 5a df 00 00       	call   80e5a8 <_panic>
		output(ns_envid);
  80064e:	83 ec 0c             	sub    $0xc,%esp
  800651:	53                   	push   %ebx
  800652:	e8 a3 00 00 00       	call   8006fa <output>
		return;
  800657:	83 c4 10             	add    $0x10,%esp
  80065a:	eb b1                	jmp    80060d <umain+0x91>

0080065c <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  80065c:	55                   	push   %ebp
  80065d:	89 e5                	mov    %esp,%ebp
  80065f:	57                   	push   %edi
  800660:	56                   	push   %esi
  800661:	53                   	push   %ebx
  800662:	83 ec 1c             	sub    $0x1c,%esp
  800665:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800668:	e8 b4 ed 00 00       	call   80f421 <sys_time_msec>
  80066d:	03 45 0c             	add    0xc(%ebp),%eax
  800670:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  800672:	c7 05 e8 42 81 00 ec 	movl   $0x8113ec,0x8142e8
  800679:	13 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80067c:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  80067f:	eb 33                	jmp    8006b4 <timer+0x58>
		if (r < 0)
  800681:	85 c0                	test   %eax,%eax
  800683:	78 45                	js     8006ca <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800685:	6a 00                	push   $0x0
  800687:	6a 00                	push   $0x0
  800689:	6a 0c                	push   $0xc
  80068b:	56                   	push   %esi
  80068c:	e8 97 f3 00 00       	call   80fa28 <ipc_send>
  800691:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800694:	83 ec 04             	sub    $0x4,%esp
  800697:	6a 00                	push   $0x0
  800699:	6a 00                	push   $0x0
  80069b:	57                   	push   %edi
  80069c:	e8 1e f3 00 00       	call   80f9bf <ipc_recv>
  8006a1:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006a6:	83 c4 10             	add    $0x10,%esp
  8006a9:	39 f0                	cmp    %esi,%eax
  8006ab:	75 2f                	jne    8006dc <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006ad:	e8 6f ed 00 00       	call   80f421 <sys_time_msec>
  8006b2:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006b4:	e8 68 ed 00 00       	call   80f421 <sys_time_msec>
  8006b9:	89 c2                	mov    %eax,%edx
  8006bb:	85 c0                	test   %eax,%eax
  8006bd:	78 c2                	js     800681 <timer+0x25>
  8006bf:	39 d8                	cmp    %ebx,%eax
  8006c1:	73 be                	jae    800681 <timer+0x25>
			sys_yield();
  8006c3:	e8 08 eb 00 00       	call   80f1d0 <sys_yield>
  8006c8:	eb ea                	jmp    8006b4 <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006ca:	52                   	push   %edx
  8006cb:	68 f5 13 81 00       	push   $0x8113f5
  8006d0:	6a 0f                	push   $0xf
  8006d2:	68 07 14 81 00       	push   $0x811407
  8006d7:	e8 cc de 00 00       	call   80e5a8 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8006dc:	83 ec 08             	sub    $0x8,%esp
  8006df:	50                   	push   %eax
  8006e0:	68 14 14 81 00       	push   $0x811414
  8006e5:	e8 b4 df 00 00       	call   80e69e <cprintf>
				continue;
  8006ea:	83 c4 10             	add    $0x10,%esp
  8006ed:	eb a5                	jmp    800694 <timer+0x38>

008006ef <input>:
extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
	binaryname = "ns_input";
  8006ef:	c7 05 e8 42 81 00 4f 	movl   $0x81144f,0x8142e8
  8006f6:	14 81 00 
	//	- send it to the network server (using ipc_send with NSREQ_INPUT as value)
	//	do the above things in a loop
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  8006f9:	c3                   	ret    

008006fa <output>:
extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
	binaryname = "ns_output";
  8006fa:	c7 05 e8 42 81 00 58 	movl   $0x811458,0x8142e8
  800701:	14 81 00 

	// LAB 6: Your code here:
	// 	- read a packet request (using ipc_recv)
	//	- send the packet to the device driver (using sys_net_send)
	//	do the above things in a loop
}
  800704:	c3                   	ret    

00800705 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800705:	89 c2                	mov    %eax,%edx
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800707:	83 f8 1f             	cmp    $0x1f,%eax
  80070a:	77 19                	ja     800725 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  80070c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80070f:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax

  if (!sock->conn) {
  800716:	8d 14 92             	lea    (%edx,%edx,4),%edx
  800719:	8b 14 95 60 50 81 00 	mov    0x815060(,%edx,4),%edx
  800720:	85 d2                	test   %edx,%edx
  800722:	74 11                	je     800735 <get_socket+0x30>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  800724:	c3                   	ret    
    set_errno(EBADF);
  800725:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80072c:	00 00 00 
    return NULL;
  80072f:	b8 00 00 00 00       	mov    $0x0,%eax
  800734:	c3                   	ret    
    set_errno(EBADF);
  800735:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  80073c:	00 00 00 
    return NULL;
  80073f:	89 d0                	mov    %edx,%eax
  800741:	eb e1                	jmp    800724 <get_socket+0x1f>

00800743 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800743:	55                   	push   %ebp
  800744:	89 e5                	mov    %esp,%ebp
  800746:	57                   	push   %edi
  800747:	56                   	push   %esi
  800748:	53                   	push   %ebx
  800749:	83 ec 40             	sub    $0x40,%esp
  80074c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80074f:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800752:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800755:	6a 04                	push   $0x4
  800757:	6a 00                	push   $0x0
  800759:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80075c:	50                   	push   %eax
  80075d:	e8 e1 e7 00 00       	call   80ef43 <memset>
  FD_ZERO(&lwriteset);
  800762:	83 c4 0c             	add    $0xc,%esp
  800765:	6a 04                	push   $0x4
  800767:	6a 00                	push   $0x0
  800769:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80076c:	50                   	push   %eax
  80076d:	e8 d1 e7 00 00       	call   80ef43 <memset>
  FD_ZERO(&lexceptset);
  800772:	83 c4 0c             	add    $0xc,%esp
  800775:	6a 04                	push   $0x4
  800777:	6a 00                	push   $0x0
  800779:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80077c:	50                   	push   %eax
  80077d:	e8 c1 e7 00 00       	call   80ef43 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800782:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  800785:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  80078c:	bf 00 00 00 00       	mov    $0x0,%edi
  800791:	eb 33                	jmp    8007c6 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800793:	89 f8                	mov    %edi,%eax
  800795:	e8 6b ff ff ff       	call   800705 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  80079a:	85 c0                	test   %eax,%eax
  80079c:	74 4c                	je     8007ea <lwip_selscan+0xa7>
  80079e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8007a2:	74 16                	je     8007ba <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8007a4:	b8 01 00 00 00       	mov    $0x1,%eax
  8007a9:	89 f1                	mov    %esi,%ecx
  8007ab:	d3 e0                	shl    %cl,%eax
  8007ad:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8007b0:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8007b4:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8007b8:	eb 30                	jmp    8007ea <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8007ba:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8007bf:	74 29                	je     8007ea <lwip_selscan+0xa7>
  8007c1:	eb e1                	jmp    8007a4 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8007c3:	83 c7 01             	add    $0x1,%edi
  8007c6:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8007c9:	7d 53                	jge    80081e <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8007cb:	8d 5f 07             	lea    0x7(%edi),%ebx
  8007ce:	85 ff                	test   %edi,%edi
  8007d0:	0f 49 df             	cmovns %edi,%ebx
  8007d3:	c1 fb 03             	sar    $0x3,%ebx
  8007d6:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8007d9:	89 fe                	mov    %edi,%esi
  8007db:	83 e6 07             	and    $0x7,%esi
  8007de:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8007e1:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007e5:	0f a3 f0             	bt     %esi,%eax
  8007e8:	72 a9                	jb     800793 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  8007ea:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8007ed:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8007f1:	0f a3 f0             	bt     %esi,%eax
  8007f4:	73 cd                	jae    8007c3 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  8007f6:	89 f8                	mov    %edi,%eax
  8007f8:	e8 08 ff ff ff       	call   800705 <get_socket>
      if (p_sock && p_sock->sendevent) {
  8007fd:	85 c0                	test   %eax,%eax
  8007ff:	74 c2                	je     8007c3 <lwip_selscan+0x80>
  800801:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800806:	74 bb                	je     8007c3 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800808:	b8 01 00 00 00       	mov    $0x1,%eax
  80080d:	89 f1                	mov    %esi,%ecx
  80080f:	d3 e0                	shl    %cl,%eax
  800811:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800814:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800818:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  80081c:	eb a5                	jmp    8007c3 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  80081e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800821:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800824:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800826:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800829:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80082c:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  80082e:	83 ec 04             	sub    $0x4,%esp
  800831:	6a 04                	push   $0x4
  800833:	6a 00                	push   $0x0
  800835:	ff 75 08             	pushl  0x8(%ebp)
  800838:	e8 06 e7 00 00       	call   80ef43 <memset>
  
  return nready;
}
  80083d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800840:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800843:	5b                   	pop    %ebx
  800844:	5e                   	pop    %esi
  800845:	5f                   	pop    %edi
  800846:	5d                   	pop    %ebp
  800847:	c3                   	ret    

00800848 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800848:	55                   	push   %ebp
  800849:	89 e5                	mov    %esp,%ebp
  80084b:	57                   	push   %edi
  80084c:	56                   	push   %esi
  80084d:	53                   	push   %ebx
  80084e:	83 ec 3c             	sub    $0x3c,%esp
  800851:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800854:	89 cf                	mov    %ecx,%edi
  800856:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800859:	e8 a7 fe ff ff       	call   800705 <get_socket>
  if (!sock)
  80085e:	85 c0                	test   %eax,%eax
  800860:	0f 84 86 00 00 00    	je     8008ec <lwip_getaddrname+0xa4>
  800866:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800868:	83 ec 04             	sub    $0x4,%esp
  80086b:	6a 10                	push   $0x10
  80086d:	6a 00                	push   $0x0
  80086f:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800872:	50                   	push   %eax
  800873:	e8 cb e6 00 00       	call   80ef43 <memset>
  sin.sin_len = sizeof(sin);
  800878:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  80087c:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800880:	89 f0                	mov    %esi,%eax
  800882:	0f b6 f0             	movzbl %al,%esi
  800885:	56                   	push   %esi
  800886:	8d 45 da             	lea    -0x26(%ebp),%eax
  800889:	50                   	push   %eax
  80088a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80088d:	50                   	push   %eax
  80088e:	ff 33                	pushl  (%ebx)
  800890:	e8 3d a4 00 00       	call   80acd2 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800895:	83 c4 14             	add    $0x14,%esp
  800898:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80089c:	50                   	push   %eax
  80089d:	e8 1b 6e 00 00       	call   8076bd <htons>
  8008a2:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8008a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8008a9:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  8008ac:	83 c4 10             	add    $0x10,%esp
  8008af:	83 3f 10             	cmpl   $0x10,(%edi)
  8008b2:	76 06                	jbe    8008ba <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  8008b4:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  8008ba:	83 ec 04             	sub    $0x4,%esp
  8008bd:	ff 37                	pushl  (%edi)
  8008bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8008c2:	50                   	push   %eax
  8008c3:	ff 75 c4             	pushl  -0x3c(%ebp)
  8008c6:	e8 22 e7 00 00       	call   80efed <memcpy>
  sock_set_errno(sock, 0);
  8008cb:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8008d2:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8008d9:	00 00 00 
  return 0;
  8008dc:	83 c4 10             	add    $0x10,%esp
  8008df:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8008e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8008e7:	5b                   	pop    %ebx
  8008e8:	5e                   	pop    %esi
  8008e9:	5f                   	pop    %edi
  8008ea:	5d                   	pop    %ebp
  8008eb:	c3                   	ret    
    return -1;
  8008ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8008f1:	eb f1                	jmp    8008e4 <lwip_getaddrname+0x9c>

008008f3 <event_callback>:
{
  8008f3:	55                   	push   %ebp
  8008f4:	89 e5                	mov    %esp,%ebp
  8008f6:	57                   	push   %edi
  8008f7:	56                   	push   %esi
  8008f8:	53                   	push   %ebx
  8008f9:	83 ec 1c             	sub    $0x1c,%esp
  8008fc:	8b 7d 08             	mov    0x8(%ebp),%edi
  8008ff:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800902:	85 ff                	test   %edi,%edi
  800904:	0f 84 8b 01 00 00    	je     800a95 <event_callback+0x1a2>
    s = conn->socket;
  80090a:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  80090d:	85 db                	test   %ebx,%ebx
  80090f:	78 4d                	js     80095e <event_callback+0x6b>
    sock = get_socket(s);
  800911:	89 d8                	mov    %ebx,%eax
  800913:	e8 ed fd ff ff       	call   800705 <get_socket>
  800918:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  80091b:	85 c0                	test   %eax,%eax
  80091d:	0f 84 72 01 00 00    	je     800a95 <event_callback+0x1a2>
  sys_sem_wait(selectsem);
  800923:	83 ec 0c             	sub    $0xc,%esp
  800926:	ff 35 40 50 81 00    	pushl  0x815040
  80092c:	e8 90 47 00 00       	call   8050c1 <sys_sem_wait>
  switch (evt) {
  800931:	83 c4 10             	add    $0x10,%esp
  800934:	83 fe 01             	cmp    $0x1,%esi
  800937:	0f 84 a1 00 00 00    	je     8009de <event_callback+0xeb>
  80093d:	85 f6                	test   %esi,%esi
  80093f:	74 68                	je     8009a9 <event_callback+0xb6>
  800941:	83 fe 02             	cmp    $0x2,%esi
  800944:	0f 84 9e 00 00 00    	je     8009e8 <event_callback+0xf5>
  80094a:	83 fe 03             	cmp    $0x3,%esi
  80094d:	0f 85 a0 00 00 00    	jne    8009f3 <event_callback+0x100>
      sock->sendevent = 0;
  800953:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800956:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  80095c:	eb 53                	jmp    8009b1 <event_callback+0xbe>
      sys_sem_wait(socksem);
  80095e:	83 ec 0c             	sub    $0xc,%esp
  800961:	ff 35 44 50 81 00    	pushl  0x815044
  800967:	e8 55 47 00 00       	call   8050c1 <sys_sem_wait>
      if (conn->socket < 0) {
  80096c:	8b 47 1c             	mov    0x1c(%edi),%eax
  80096f:	83 c4 10             	add    $0x10,%esp
  800972:	85 c0                	test   %eax,%eax
  800974:	78 13                	js     800989 <event_callback+0x96>
      sys_sem_signal(socksem);
  800976:	83 ec 0c             	sub    $0xc,%esp
  800979:	ff 35 44 50 81 00    	pushl  0x815044
  80097f:	e8 cf 96 00 00       	call   80a053 <sys_sem_signal>
  800984:	83 c4 10             	add    $0x10,%esp
  800987:	eb 88                	jmp    800911 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800989:	85 f6                	test   %esi,%esi
  80098b:	75 06                	jne    800993 <event_callback+0xa0>
          conn->socket--;
  80098d:	83 e8 01             	sub    $0x1,%eax
  800990:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800993:	83 ec 0c             	sub    $0xc,%esp
  800996:	ff 35 44 50 81 00    	pushl  0x815044
  80099c:	e8 b2 96 00 00       	call   80a053 <sys_sem_signal>
        return;
  8009a1:	83 c4 10             	add    $0x10,%esp
  8009a4:	e9 ec 00 00 00       	jmp    800a95 <event_callback+0x1a2>
      sock->rcvevent++;
  8009a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009ac:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  8009b1:	83 ec 0c             	sub    $0xc,%esp
  8009b4:	ff 35 40 50 81 00    	pushl  0x815040
  8009ba:	e8 94 96 00 00       	call   80a053 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  8009bf:	8d 73 07             	lea    0x7(%ebx),%esi
  8009c2:	83 c4 10             	add    $0x10,%esp
  8009c5:	85 db                	test   %ebx,%ebx
  8009c7:	0f 49 f3             	cmovns %ebx,%esi
  8009ca:	c1 fe 03             	sar    $0x3,%esi
  8009cd:	89 d9                	mov    %ebx,%ecx
  8009cf:	83 e1 07             	and    $0x7,%ecx
  8009d2:	bf 01 00 00 00       	mov    $0x1,%edi
  8009d7:	d3 e7                	shl    %cl,%edi
  8009d9:	e9 8d 00 00 00       	jmp    800a6b <event_callback+0x178>
      sock->rcvevent--;
  8009de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009e1:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  8009e6:	eb c9                	jmp    8009b1 <event_callback+0xbe>
      sock->sendevent = 1;
  8009e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009eb:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  8009f1:	eb be                	jmp    8009b1 <event_callback+0xbe>
      LWIP_ASSERT("unknown event", 0);
  8009f3:	83 ec 04             	sub    $0x4,%esp
  8009f6:	68 62 14 81 00       	push   $0x811462
  8009fb:	68 17 04 00 00       	push   $0x417
  800a00:	68 70 14 81 00       	push   $0x811470
  800a05:	e8 9e db 00 00       	call   80e5a8 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a0a:	8b 1b                	mov    (%ebx),%ebx
  800a0c:	85 db                	test   %ebx,%ebx
  800a0e:	74 74                	je     800a84 <event_callback+0x191>
      if (scb->sem_signalled == 0) {
  800a10:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800a14:	75 f4                	jne    800a0a <event_callback+0x117>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a16:	8b 43 04             	mov    0x4(%ebx),%eax
  800a19:	85 c0                	test   %eax,%eax
  800a1b:	74 12                	je     800a2f <event_callback+0x13c>
  800a1d:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a21:	85 f8                	test   %edi,%eax
  800a23:	74 0a                	je     800a2f <event_callback+0x13c>
          if (sock->rcvevent)
  800a25:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a28:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a2d:	75 19                	jne    800a48 <event_callback+0x155>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800a2f:	8b 43 08             	mov    0x8(%ebx),%eax
  800a32:	85 c0                	test   %eax,%eax
  800a34:	74 d4                	je     800a0a <event_callback+0x117>
  800a36:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800a3a:	85 f8                	test   %edi,%eax
  800a3c:	74 cc                	je     800a0a <event_callback+0x117>
          if (sock->sendevent)
  800a3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a41:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a46:	74 c2                	je     800a0a <event_callback+0x117>
      scb->sem_signalled = 1;
  800a48:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800a4f:	83 ec 0c             	sub    $0xc,%esp
  800a52:	ff 35 40 50 81 00    	pushl  0x815040
  800a58:	e8 f6 95 00 00       	call   80a053 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800a5d:	83 c4 04             	add    $0x4,%esp
  800a60:	ff 73 14             	pushl  0x14(%ebx)
  800a63:	e8 eb 95 00 00       	call   80a053 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800a68:	83 c4 10             	add    $0x10,%esp
  800a6b:	83 ec 0c             	sub    $0xc,%esp
  800a6e:	ff 35 40 50 81 00    	pushl  0x815040
  800a74:	e8 48 46 00 00       	call   8050c1 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800a79:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800a7f:	83 c4 10             	add    $0x10,%esp
  800a82:	eb 88                	jmp    800a0c <event_callback+0x119>
      sys_sem_signal(selectsem);
  800a84:	83 ec 0c             	sub    $0xc,%esp
  800a87:	ff 35 40 50 81 00    	pushl  0x815040
  800a8d:	e8 c1 95 00 00       	call   80a053 <sys_sem_signal>
      break;
  800a92:	83 c4 10             	add    $0x10,%esp
}
  800a95:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a98:	5b                   	pop    %ebx
  800a99:	5e                   	pop    %esi
  800a9a:	5f                   	pop    %edi
  800a9b:	5d                   	pop    %ebp
  800a9c:	c3                   	ret    

00800a9d <alloc_socket>:
{
  800a9d:	55                   	push   %ebp
  800a9e:	89 e5                	mov    %esp,%ebp
  800aa0:	56                   	push   %esi
  800aa1:	53                   	push   %ebx
  800aa2:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800aa4:	83 ec 0c             	sub    $0xc,%esp
  800aa7:	ff 35 44 50 81 00    	pushl  0x815044
  800aad:	e8 0f 46 00 00       	call   8050c1 <sys_sem_wait>
  800ab2:	b8 60 50 81 00       	mov    $0x815060,%eax
  800ab7:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800aba:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800abf:	83 38 00             	cmpl   $0x0,(%eax)
  800ac2:	74 23                	je     800ae7 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ac4:	83 c3 01             	add    $0x1,%ebx
  800ac7:	83 c0 14             	add    $0x14,%eax
  800aca:	83 fb 20             	cmp    $0x20,%ebx
  800acd:	75 f0                	jne    800abf <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800acf:	83 ec 0c             	sub    $0xc,%esp
  800ad2:	ff 35 44 50 81 00    	pushl  0x815044
  800ad8:	e8 76 95 00 00       	call   80a053 <sys_sem_signal>
  return -1;
  800add:	83 c4 10             	add    $0x10,%esp
  800ae0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800ae5:	eb 55                	jmp    800b3c <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800ae7:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800aea:	c1 e2 02             	shl    $0x2,%edx
  800aed:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800af3:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800afa:	00 00 00 
      sockets[i].lastoffset = 0;
  800afd:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800b04:	00 00 
      sockets[i].rcvevent   = 0;
  800b06:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800b0d:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800b0f:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800b16:	01 00 
      sockets[i].flags      = 0;
  800b18:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800b1f:	00 00 
      sockets[i].err        = 0;
  800b21:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800b28:	00 00 00 
      sys_sem_signal(socksem);
  800b2b:	83 ec 0c             	sub    $0xc,%esp
  800b2e:	ff 35 44 50 81 00    	pushl  0x815044
  800b34:	e8 1a 95 00 00       	call   80a053 <sys_sem_signal>
      return i;
  800b39:	83 c4 10             	add    $0x10,%esp
}
  800b3c:	89 d8                	mov    %ebx,%eax
  800b3e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800b41:	5b                   	pop    %ebx
  800b42:	5e                   	pop    %esi
  800b43:	5d                   	pop    %ebp
  800b44:	c3                   	ret    

00800b45 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800b45:	55                   	push   %ebp
  800b46:	89 e5                	mov    %esp,%ebp
  800b48:	53                   	push   %ebx
  800b49:	83 ec 04             	sub    $0x4,%esp
  800b4c:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b4f:	85 c0                	test   %eax,%eax
  800b51:	74 39                	je     800b8c <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800b53:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800b55:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800b58:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800b5b:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800b5e:	83 fa 06             	cmp    $0x6,%edx
  800b61:	0f 84 37 01 00 00    	je     800c9e <lwip_getsockopt_internal+0x159>
  800b67:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800b6d:	74 34                	je     800ba3 <lwip_getsockopt_internal+0x5e>
  800b6f:	85 d2                	test   %edx,%edx
  800b71:	0f 84 f9 00 00 00    	je     800c70 <lwip_getsockopt_internal+0x12b>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800b77:	83 ec 0c             	sub    $0xc,%esp
  800b7a:	8b 03                	mov    (%ebx),%eax
  800b7c:	ff 70 10             	pushl  0x10(%eax)
  800b7f:	e8 cf 94 00 00       	call   80a053 <sys_sem_signal>
}
  800b84:	83 c4 10             	add    $0x10,%esp
  800b87:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800b8a:	c9                   	leave  
  800b8b:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800b8c:	83 ec 04             	sub    $0x4,%esp
  800b8f:	68 87 14 81 00       	push   $0x811487
  800b94:	68 38 05 00 00       	push   $0x538
  800b99:	68 70 14 81 00       	push   $0x811470
  800b9e:	e8 05 da 00 00       	call   80e5a8 <_panic>
  800ba3:	83 f9 20             	cmp    $0x20,%ecx
  800ba6:	74 65                	je     800c0d <lwip_getsockopt_internal+0xc8>
  800ba8:	7e 55                	jle    800bff <lwip_getsockopt_internal+0xba>
  800baa:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800bb0:	74 6d                	je     800c1f <lwip_getsockopt_internal+0xda>
  800bb2:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800bb8:	0f 84 9f 00 00 00    	je     800c5d <lwip_getsockopt_internal+0x118>
  800bbe:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800bc4:	75 b1                	jne    800b77 <lwip_getsockopt_internal+0x32>
      if (sock->err == 0) {
  800bc6:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800bca:	75 22                	jne    800bee <lwip_getsockopt_internal+0xa9>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800bcc:	8b 13                	mov    (%ebx),%edx
  800bce:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800bd2:	f7 da                	neg    %edx
  800bd4:	b9 05 00 00 00       	mov    $0x5,%ecx
  800bd9:	83 fa 0e             	cmp    $0xe,%edx
  800bdc:	77 07                	ja     800be5 <lwip_getsockopt_internal+0xa0>
  800bde:	8b 0c 95 40 15 81 00 	mov    0x811540(,%edx,4),%ecx
  800be5:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800be8:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
      *(int *)optval = sock->err;
  800bee:	8b 53 10             	mov    0x10(%ebx),%edx
  800bf1:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800bf3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800bfa:	e9 78 ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
  800bff:	83 f9 02             	cmp    $0x2,%ecx
  800c02:	74 09                	je     800c0d <lwip_getsockopt_internal+0xc8>
  800c04:	83 f9 08             	cmp    $0x8,%ecx
  800c07:	0f 85 6a ff ff ff    	jne    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800c0d:	8b 13                	mov    (%ebx),%edx
  800c0f:	8b 52 08             	mov    0x8(%edx),%edx
  800c12:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800c16:	21 d1                	and    %edx,%ecx
  800c18:	89 08                	mov    %ecx,(%eax)
      break;
  800c1a:	e9 58 ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800c1f:	8b 13                	mov    (%ebx),%edx
  800c21:	8b 12                	mov    (%edx),%edx
  800c23:	89 d1                	mov    %edx,%ecx
  800c25:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800c2b:	83 f9 20             	cmp    $0x20,%ecx
  800c2e:	74 22                	je     800c52 <lwip_getsockopt_internal+0x10d>
  800c30:	83 f9 40             	cmp    $0x40,%ecx
  800c33:	74 12                	je     800c47 <lwip_getsockopt_internal+0x102>
        *(int*)optval = sock->conn->type;
  800c35:	83 f9 10             	cmp    $0x10,%ecx
  800c38:	b9 01 00 00 00       	mov    $0x1,%ecx
  800c3d:	0f 44 d1             	cmove  %ecx,%edx
  800c40:	89 10                	mov    %edx,(%eax)
  800c42:	e9 30 ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_RAW;
  800c47:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800c4d:	e9 25 ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_DGRAM;
  800c52:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800c58:	e9 1a ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800c5d:	8b 13                	mov    (%ebx),%edx
  800c5f:	8b 52 08             	mov    0x8(%edx),%edx
  800c62:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800c66:	83 e2 01             	and    $0x1,%edx
  800c69:	89 10                	mov    %edx,(%eax)
      break;
  800c6b:	e9 07 ff ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
  800c70:	83 f9 01             	cmp    $0x1,%ecx
  800c73:	74 19                	je     800c8e <lwip_getsockopt_internal+0x149>
  800c75:	83 f9 02             	cmp    $0x2,%ecx
  800c78:	0f 85 f9 fe ff ff    	jne    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800c7e:	8b 13                	mov    (%ebx),%edx
  800c80:	8b 52 08             	mov    0x8(%edx),%edx
  800c83:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800c87:	89 10                	mov    %edx,(%eax)
      break;
  800c89:	e9 e9 fe ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800c8e:	8b 13                	mov    (%ebx),%edx
  800c90:	8b 52 08             	mov    0x8(%edx),%edx
  800c93:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800c97:	89 10                	mov    %edx,(%eax)
      break;
  800c99:	e9 d9 fe ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
  800c9e:	83 f9 01             	cmp    $0x1,%ecx
  800ca1:	74 1b                	je     800cbe <lwip_getsockopt_internal+0x179>
  800ca3:	83 f9 02             	cmp    $0x2,%ecx
  800ca6:	0f 85 cb fe ff ff    	jne    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800cac:	8b 13                	mov    (%ebx),%edx
  800cae:	8b 52 08             	mov    0x8(%edx),%edx
  800cb1:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800cb7:	89 10                	mov    %edx,(%eax)
      break;
  800cb9:	e9 b9 fe ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800cbe:	8b 13                	mov    (%ebx),%edx
  800cc0:	8b 52 08             	mov    0x8(%edx),%edx
  800cc3:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800cc7:	83 e2 40             	and    $0x40,%edx
  800cca:	0f b6 d2             	movzbl %dl,%edx
  800ccd:	89 10                	mov    %edx,(%eax)
      break;
  800ccf:	e9 a3 fe ff ff       	jmp    800b77 <lwip_getsockopt_internal+0x32>

00800cd4 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800cd4:	55                   	push   %ebp
  800cd5:	89 e5                	mov    %esp,%ebp
  800cd7:	53                   	push   %ebx
  800cd8:	83 ec 04             	sub    $0x4,%esp
  800cdb:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800cde:	85 c0                	test   %eax,%eax
  800ce0:	74 35                	je     800d17 <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800ce2:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800ce4:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800ce7:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800cea:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800ced:	83 fa 06             	cmp    $0x6,%edx
  800cf0:	0f 84 aa 00 00 00    	je     800da0 <lwip_setsockopt_internal+0xcc>
  800cf6:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800cfc:	74 30                	je     800d2e <lwip_setsockopt_internal+0x5a>
  800cfe:	85 d2                	test   %edx,%edx
  800d00:	74 76                	je     800d78 <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d02:	83 ec 0c             	sub    $0xc,%esp
  800d05:	8b 03                	mov    (%ebx),%eax
  800d07:	ff 70 10             	pushl  0x10(%eax)
  800d0a:	e8 44 93 00 00       	call   80a053 <sys_sem_signal>
}
  800d0f:	83 c4 10             	add    $0x10,%esp
  800d12:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d15:	c9                   	leave  
  800d16:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d17:	83 ec 04             	sub    $0x4,%esp
  800d1a:	68 87 14 81 00       	push   $0x811487
  800d1f:	68 ae 06 00 00       	push   $0x6ae
  800d24:	68 70 14 81 00       	push   $0x811470
  800d29:	e8 7a d8 00 00       	call   80e5a8 <_panic>
  800d2e:	83 f9 20             	cmp    $0x20,%ecx
  800d31:	74 0d                	je     800d40 <lwip_setsockopt_internal+0x6c>
  800d33:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800d39:	74 22                	je     800d5d <lwip_setsockopt_internal+0x89>
  800d3b:	83 f9 08             	cmp    $0x8,%ecx
  800d3e:	75 c2                	jne    800d02 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800d40:	83 38 00             	cmpl   $0x0,(%eax)
  800d43:	74 0b                	je     800d50 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800d45:	8b 03                	mov    (%ebx),%eax
  800d47:	8b 40 08             	mov    0x8(%eax),%eax
  800d4a:	66 09 48 08          	or     %cx,0x8(%eax)
  800d4e:	eb b2                	jmp    800d02 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800d50:	8b 03                	mov    (%ebx),%eax
  800d52:	8b 40 08             	mov    0x8(%eax),%eax
  800d55:	f7 d1                	not    %ecx
  800d57:	66 21 48 08          	and    %cx,0x8(%eax)
  800d5b:	eb a5                	jmp    800d02 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800d5d:	83 38 00             	cmpl   $0x0,(%eax)
  800d60:	74 0b                	je     800d6d <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800d62:	8b 03                	mov    (%ebx),%eax
  800d64:	8b 40 08             	mov    0x8(%eax),%eax
  800d67:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800d6b:	eb 95                	jmp    800d02 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800d6d:	8b 03                	mov    (%ebx),%eax
  800d6f:	8b 40 08             	mov    0x8(%eax),%eax
  800d72:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800d76:	eb 8a                	jmp    800d02 <lwip_setsockopt_internal+0x2e>
  800d78:	83 f9 01             	cmp    $0x1,%ecx
  800d7b:	74 14                	je     800d91 <lwip_setsockopt_internal+0xbd>
  800d7d:	83 f9 02             	cmp    $0x2,%ecx
  800d80:	75 80                	jne    800d02 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800d82:	8b 13                	mov    (%ebx),%edx
  800d84:	8b 52 08             	mov    0x8(%edx),%edx
  800d87:	8b 00                	mov    (%eax),%eax
  800d89:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800d8c:	e9 71 ff ff ff       	jmp    800d02 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800d91:	8b 13                	mov    (%ebx),%edx
  800d93:	8b 52 08             	mov    0x8(%edx),%edx
  800d96:	8b 00                	mov    (%eax),%eax
  800d98:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800d9b:	e9 62 ff ff ff       	jmp    800d02 <lwip_setsockopt_internal+0x2e>
  800da0:	83 f9 01             	cmp    $0x1,%ecx
  800da3:	74 1b                	je     800dc0 <lwip_setsockopt_internal+0xec>
  800da5:	83 f9 02             	cmp    $0x2,%ecx
  800da8:	0f 85 54 ff ff ff    	jne    800d02 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800dae:	8b 13                	mov    (%ebx),%edx
  800db0:	8b 52 08             	mov    0x8(%edx),%edx
  800db3:	8b 00                	mov    (%eax),%eax
  800db5:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800dbb:	e9 42 ff ff ff       	jmp    800d02 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800dc0:	83 38 00             	cmpl   $0x0,(%eax)
  800dc3:	74 0e                	je     800dd3 <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800dc5:	8b 03                	mov    (%ebx),%eax
  800dc7:	8b 40 08             	mov    0x8(%eax),%eax
  800dca:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800dce:	e9 2f ff ff ff       	jmp    800d02 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800dd3:	8b 03                	mov    (%ebx),%eax
  800dd5:	8b 40 08             	mov    0x8(%eax),%eax
  800dd8:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800ddc:	e9 21 ff ff ff       	jmp    800d02 <lwip_setsockopt_internal+0x2e>

00800de1 <lwip_socket_init>:
{
  800de1:	55                   	push   %ebp
  800de2:	89 e5                	mov    %esp,%ebp
  800de4:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800de7:	6a 01                	push   $0x1
  800de9:	e8 a8 8f 00 00       	call   809d96 <sys_sem_new>
  800dee:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800df3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800dfa:	e8 97 8f 00 00       	call   809d96 <sys_sem_new>
  800dff:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800e04:	83 c4 10             	add    $0x10,%esp
  800e07:	c9                   	leave  
  800e08:	c3                   	ret    

00800e09 <lwip_accept>:
{
  800e09:	55                   	push   %ebp
  800e0a:	89 e5                	mov    %esp,%ebp
  800e0c:	57                   	push   %edi
  800e0d:	56                   	push   %esi
  800e0e:	53                   	push   %ebx
  800e0f:	83 ec 3c             	sub    $0x3c,%esp
  800e12:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800e15:	8b 45 08             	mov    0x8(%ebp),%eax
  800e18:	e8 e8 f8 ff ff       	call   800705 <get_socket>
  if (!sock)
  800e1d:	85 c0                	test   %eax,%eax
  800e1f:	0f 84 8c 01 00 00    	je     800fb1 <lwip_accept+0x1a8>
  800e25:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800e27:	83 ec 0c             	sub    $0xc,%esp
  800e2a:	ff 30                	pushl  (%eax)
  800e2c:	e8 57 a0 00 00       	call   80ae88 <netconn_accept>
  800e31:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800e33:	83 c4 10             	add    $0x10,%esp
  800e36:	85 c0                	test   %eax,%eax
  800e38:	0f 84 de 00 00 00    	je     800f1c <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  800e3e:	6a 00                	push   $0x0
  800e40:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800e43:	50                   	push   %eax
  800e44:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800e47:	50                   	push   %eax
  800e48:	53                   	push   %ebx
  800e49:	e8 84 9e 00 00       	call   80acd2 <netconn_getaddr>
  800e4e:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800e51:	83 c4 10             	add    $0x10,%esp
  800e54:	84 c0                	test   %al,%al
  800e56:	0f 85 e9 00 00 00    	jne    800f45 <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  800e5c:	83 ec 04             	sub    $0x4,%esp
  800e5f:	6a 10                	push   $0x10
  800e61:	6a 00                	push   $0x0
  800e63:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800e66:	50                   	push   %eax
  800e67:	e8 d7 e0 00 00       	call   80ef43 <memset>
  sin.sin_len = sizeof(sin);
  800e6c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800e70:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800e74:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800e78:	89 04 24             	mov    %eax,(%esp)
  800e7b:	e8 3d 68 00 00       	call   8076bd <htons>
  800e80:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800e84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800e87:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800e8a:	83 c4 10             	add    $0x10,%esp
  800e8d:	83 3f 10             	cmpl   $0x10,(%edi)
  800e90:	76 06                	jbe    800e98 <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800e92:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800e98:	83 ec 04             	sub    $0x4,%esp
  800e9b:	ff 37                	pushl  (%edi)
  800e9d:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800ea0:	50                   	push   %eax
  800ea1:	ff 75 0c             	pushl  0xc(%ebp)
  800ea4:	e8 44 e1 00 00       	call   80efed <memcpy>
  newsock = alloc_socket(newconn);
  800ea9:	89 d8                	mov    %ebx,%eax
  800eab:	e8 ed fb ff ff       	call   800a9d <alloc_socket>
  800eb0:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800eb2:	83 c4 10             	add    $0x10,%esp
  800eb5:	83 f8 ff             	cmp    $0xffffffff,%eax
  800eb8:	0f 84 ba 00 00 00    	je     800f78 <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800ebe:	83 f8 1f             	cmp    $0x1f,%eax
  800ec1:	0f 87 d3 00 00 00    	ja     800f9a <lwip_accept+0x191>
  newconn->callback = event_callback;
  800ec7:	c7 43 2c f3 08 80 00 	movl   $0x8008f3,0x2c(%ebx)
  sys_sem_wait(socksem);
  800ece:	83 ec 0c             	sub    $0xc,%esp
  800ed1:	ff 35 44 50 81 00    	pushl  0x815044
  800ed7:	e8 e5 41 00 00       	call   8050c1 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800edc:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800edf:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  800ee3:	f7 d2                	not    %edx
  800ee5:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  800eec:	00 
  newconn->socket = newsock;
  800eed:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800ef0:	83 c4 04             	add    $0x4,%esp
  800ef3:	ff 35 44 50 81 00    	pushl  0x815044
  800ef9:	e8 55 91 00 00       	call   80a053 <sys_sem_signal>
  sock_set_errno(sock, 0);
  800efe:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800f05:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800f0c:	00 00 00 
  return newsock;
  800f0f:	83 c4 10             	add    $0x10,%esp
}
  800f12:	89 f8                	mov    %edi,%eax
  800f14:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800f17:	5b                   	pop    %ebx
  800f18:	5e                   	pop    %esi
  800f19:	5f                   	pop    %edi
  800f1a:	5d                   	pop    %ebp
  800f1b:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800f1c:	8b 06                	mov    (%esi),%eax
  800f1e:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800f22:	f7 d8                	neg    %eax
  800f24:	ba 05 00 00 00       	mov    $0x5,%edx
  800f29:	83 f8 0e             	cmp    $0xe,%eax
  800f2c:	77 07                	ja     800f35 <lwip_accept+0x12c>
  800f2e:	8b 14 85 40 15 81 00 	mov    0x811540(,%eax,4),%edx
  800f35:	89 56 10             	mov    %edx,0x10(%esi)
  800f38:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f3e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f43:	eb cd                	jmp    800f12 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f45:	83 ec 0c             	sub    $0xc,%esp
  800f48:	53                   	push   %ebx
  800f49:	e8 1c 9d 00 00       	call   80ac6a <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800f4e:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800f52:	f7 d8                	neg    %eax
  800f54:	83 c4 10             	add    $0x10,%esp
  800f57:	ba 05 00 00 00       	mov    $0x5,%edx
  800f5c:	83 f8 0e             	cmp    $0xe,%eax
  800f5f:	77 07                	ja     800f68 <lwip_accept+0x15f>
  800f61:	8b 14 85 40 15 81 00 	mov    0x811540(,%eax,4),%edx
  800f68:	89 56 10             	mov    %edx,0x10(%esi)
  800f6b:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800f71:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800f76:	eb 9a                	jmp    800f12 <lwip_accept+0x109>
    netconn_delete(newconn);
  800f78:	83 ec 0c             	sub    $0xc,%esp
  800f7b:	53                   	push   %ebx
  800f7c:	e8 e9 9c 00 00       	call   80ac6a <netconn_delete>
    sock_set_errno(sock, ENFILE);
  800f81:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  800f88:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  800f8f:	00 00 00 
    return -1;
  800f92:	83 c4 10             	add    $0x10,%esp
  800f95:	e9 78 ff ff ff       	jmp    800f12 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f9a:	83 ec 04             	sub    $0x4,%esp
  800f9d:	68 93 14 81 00       	push   $0x811493
  800fa2:	68 25 01 00 00       	push   $0x125
  800fa7:	68 70 14 81 00       	push   $0x811470
  800fac:	e8 f7 d5 00 00       	call   80e5a8 <_panic>
    return -1;
  800fb1:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800fb6:	e9 57 ff ff ff       	jmp    800f12 <lwip_accept+0x109>

00800fbb <lwip_bind>:
{
  800fbb:	55                   	push   %ebp
  800fbc:	89 e5                	mov    %esp,%ebp
  800fbe:	56                   	push   %esi
  800fbf:	53                   	push   %ebx
  800fc0:	83 ec 10             	sub    $0x10,%esp
  800fc3:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  800fc6:	8b 45 08             	mov    0x8(%ebp),%eax
  800fc9:	e8 37 f7 ff ff       	call   800705 <get_socket>
  if (!sock)
  800fce:	85 c0                	test   %eax,%eax
  800fd0:	0f 84 94 00 00 00    	je     80106a <lwip_bind+0xaf>
  800fd6:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  800fd8:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  800fdc:	75 4f                	jne    80102d <lwip_bind+0x72>
  800fde:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  800fe2:	75 49                	jne    80102d <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  800fe4:	8b 46 04             	mov    0x4(%esi),%eax
  800fe7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  800fea:	83 ec 0c             	sub    $0xc,%esp
  800fed:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  800ff1:	50                   	push   %eax
  800ff2:	e8 d3 66 00 00       	call   8076ca <ntohs>
  800ff7:	83 c4 0c             	add    $0xc,%esp
  800ffa:	0f b7 c0             	movzwl %ax,%eax
  800ffd:	50                   	push   %eax
  800ffe:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801001:	50                   	push   %eax
  801002:	ff 33                	pushl  (%ebx)
  801004:	e8 55 9d 00 00       	call   80ad5e <netconn_bind>
  if (err != ERR_OK) {
  801009:	83 c4 10             	add    $0x10,%esp
  80100c:	84 c0                	test   %al,%al
  80100e:	75 34                	jne    801044 <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  801010:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801017:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80101e:	00 00 00 
  return 0;
  801021:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801026:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801029:	5b                   	pop    %ebx
  80102a:	5e                   	pop    %esi
  80102b:	5d                   	pop    %ebp
  80102c:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80102d:	83 ec 04             	sub    $0x4,%esp
  801030:	68 a8 14 81 00       	push   $0x8114a8
  801035:	68 4a 01 00 00       	push   $0x14a
  80103a:	68 70 14 81 00       	push   $0x811470
  80103f:	e8 64 d5 00 00       	call   80e5a8 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801044:	0f be c0             	movsbl %al,%eax
  801047:	f7 d8                	neg    %eax
  801049:	ba 05 00 00 00       	mov    $0x5,%edx
  80104e:	83 f8 0e             	cmp    $0xe,%eax
  801051:	77 07                	ja     80105a <lwip_bind+0x9f>
  801053:	8b 14 85 40 15 81 00 	mov    0x811540(,%eax,4),%edx
  80105a:	89 53 10             	mov    %edx,0x10(%ebx)
  80105d:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801063:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801068:	eb bc                	jmp    801026 <lwip_bind+0x6b>
    return -1;
  80106a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80106f:	eb b5                	jmp    801026 <lwip_bind+0x6b>

00801071 <lwip_close>:
{
  801071:	55                   	push   %ebp
  801072:	89 e5                	mov    %esp,%ebp
  801074:	53                   	push   %ebx
  801075:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  801078:	8b 45 08             	mov    0x8(%ebp),%eax
  80107b:	e8 85 f6 ff ff       	call   800705 <get_socket>
  if (!sock) {
  801080:	85 c0                	test   %eax,%eax
  801082:	74 6f                	je     8010f3 <lwip_close+0x82>
  801084:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  801086:	83 ec 0c             	sub    $0xc,%esp
  801089:	ff 30                	pushl  (%eax)
  80108b:	e8 da 9b 00 00       	call   80ac6a <netconn_delete>
  sys_sem_wait(socksem);
  801090:	83 c4 04             	add    $0x4,%esp
  801093:	ff 35 44 50 81 00    	pushl  0x815044
  801099:	e8 23 40 00 00       	call   8050c1 <sys_sem_wait>
  if (sock->lastdata) {
  80109e:	8b 43 04             	mov    0x4(%ebx),%eax
  8010a1:	83 c4 10             	add    $0x10,%esp
  8010a4:	85 c0                	test   %eax,%eax
  8010a6:	74 0c                	je     8010b4 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8010a8:	83 ec 0c             	sub    $0xc,%esp
  8010ab:	50                   	push   %eax
  8010ac:	e8 99 13 00 00       	call   80244a <netbuf_delete>
  8010b1:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8010b4:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8010bb:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8010c1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8010c7:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010ce:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010d5:	00 00 00 
  sys_sem_signal(socksem);
  8010d8:	83 ec 0c             	sub    $0xc,%esp
  8010db:	ff 35 44 50 81 00    	pushl  0x815044
  8010e1:	e8 6d 8f 00 00       	call   80a053 <sys_sem_signal>
  return 0;
  8010e6:	83 c4 10             	add    $0x10,%esp
  8010e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8010ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8010f1:	c9                   	leave  
  8010f2:	c3                   	ret    
    return -1;
  8010f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010f8:	eb f4                	jmp    8010ee <lwip_close+0x7d>

008010fa <lwip_connect>:
{
  8010fa:	55                   	push   %ebp
  8010fb:	89 e5                	mov    %esp,%ebp
  8010fd:	56                   	push   %esi
  8010fe:	53                   	push   %ebx
  8010ff:	83 ec 10             	sub    $0x10,%esp
  801102:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801105:	8b 45 08             	mov    0x8(%ebp),%eax
  801108:	e8 f8 f5 ff ff       	call   800705 <get_socket>
  if (!sock)
  80110d:	85 c0                	test   %eax,%eax
  80110f:	0f 84 94 00 00 00    	je     8011a9 <lwip_connect+0xaf>
  801115:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801117:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80111b:	75 4f                	jne    80116c <lwip_connect+0x72>
  80111d:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801121:	75 49                	jne    80116c <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801123:	8b 46 04             	mov    0x4(%esi),%eax
  801126:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  801129:	83 ec 0c             	sub    $0xc,%esp
  80112c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801130:	50                   	push   %eax
  801131:	e8 94 65 00 00       	call   8076ca <ntohs>
  801136:	83 c4 0c             	add    $0xc,%esp
  801139:	0f b7 c0             	movzwl %ax,%eax
  80113c:	50                   	push   %eax
  80113d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801140:	50                   	push   %eax
  801141:	ff 33                	pushl  (%ebx)
  801143:	e8 67 9c 00 00       	call   80adaf <netconn_connect>
  if (err != ERR_OK) {
  801148:	83 c4 10             	add    $0x10,%esp
  80114b:	84 c0                	test   %al,%al
  80114d:	75 34                	jne    801183 <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  80114f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801156:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80115d:	00 00 00 
  return 0;
  801160:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801165:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801168:	5b                   	pop    %ebx
  801169:	5e                   	pop    %esi
  80116a:	5d                   	pop    %ebp
  80116b:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80116c:	83 ec 04             	sub    $0x4,%esp
  80116f:	68 c3 14 81 00       	push   $0x8114c3
  801174:	68 86 01 00 00       	push   $0x186
  801179:	68 70 14 81 00       	push   $0x811470
  80117e:	e8 25 d4 00 00       	call   80e5a8 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801183:	0f be c0             	movsbl %al,%eax
  801186:	f7 d8                	neg    %eax
  801188:	ba 05 00 00 00       	mov    $0x5,%edx
  80118d:	83 f8 0e             	cmp    $0xe,%eax
  801190:	77 07                	ja     801199 <lwip_connect+0x9f>
  801192:	8b 14 85 40 15 81 00 	mov    0x811540(,%eax,4),%edx
  801199:	89 53 10             	mov    %edx,0x10(%ebx)
  80119c:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8011a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011a7:	eb bc                	jmp    801165 <lwip_connect+0x6b>
    return -1;
  8011a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011ae:	eb b5                	jmp    801165 <lwip_connect+0x6b>

008011b0 <lwip_listen>:
{
  8011b0:	55                   	push   %ebp
  8011b1:	89 e5                	mov    %esp,%ebp
  8011b3:	56                   	push   %esi
  8011b4:	53                   	push   %ebx
  8011b5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8011b8:	8b 45 08             	mov    0x8(%ebp),%eax
  8011bb:	e8 45 f5 ff ff       	call   800705 <get_socket>
  if (!sock)
  8011c0:	85 c0                	test   %eax,%eax
  8011c2:	74 6f                	je     801233 <lwip_listen+0x83>
  8011c4:	89 c6                	mov    %eax,%esi
  8011c6:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8011cc:	b8 ff 00 00 00       	mov    $0xff,%eax
  8011d1:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  8011d4:	83 ec 08             	sub    $0x8,%esp
  8011d7:	85 db                	test   %ebx,%ebx
  8011d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8011de:	0f 48 d8             	cmovs  %eax,%ebx
  8011e1:	53                   	push   %ebx
  8011e2:	ff 36                	pushl  (%esi)
  8011e4:	e8 5b 9c 00 00       	call   80ae44 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  8011e9:	83 c4 10             	add    $0x10,%esp
  8011ec:	84 c0                	test   %al,%al
  8011ee:	75 1d                	jne    80120d <lwip_listen+0x5d>
  sock_set_errno(sock, 0);
  8011f0:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8011f7:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8011fe:	00 00 00 
  return 0;
  801201:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801206:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801209:	5b                   	pop    %ebx
  80120a:	5e                   	pop    %esi
  80120b:	5d                   	pop    %ebp
  80120c:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  80120d:	0f be c0             	movsbl %al,%eax
  801210:	f7 d8                	neg    %eax
  801212:	ba 05 00 00 00       	mov    $0x5,%edx
  801217:	83 f8 0e             	cmp    $0xe,%eax
  80121a:	77 07                	ja     801223 <lwip_listen+0x73>
  80121c:	8b 14 85 40 15 81 00 	mov    0x811540(,%eax,4),%edx
  801223:	89 56 10             	mov    %edx,0x10(%esi)
  801226:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80122c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801231:	eb d3                	jmp    801206 <lwip_listen+0x56>
    return -1;
  801233:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801238:	eb cc                	jmp    801206 <lwip_listen+0x56>

0080123a <lwip_recvfrom>:
{
  80123a:	55                   	push   %ebp
  80123b:	89 e5                	mov    %esp,%ebp
  80123d:	57                   	push   %edi
  80123e:	56                   	push   %esi
  80123f:	53                   	push   %ebx
  801240:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  801243:	8b 45 08             	mov    0x8(%ebp),%eax
  801246:	e8 ba f4 ff ff       	call   800705 <get_socket>
  if (!sock)
  80124b:	85 c0                	test   %eax,%eax
  80124d:	0f 84 22 02 00 00    	je     801475 <lwip_recvfrom+0x23b>
  801253:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801255:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80125b:	8b 45 14             	mov    0x14(%ebp),%eax
  80125e:	83 e0 08             	and    $0x8,%eax
  801261:	89 45 b8             	mov    %eax,-0x48(%ebp)
  801264:	e9 a7 00 00 00       	jmp    801310 <lwip_recvfrom+0xd6>
  801269:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80126d:	75 06                	jne    801275 <lwip_recvfrom+0x3b>
  80126f:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801273:	74 07                	je     80127c <lwip_recvfrom+0x42>
  801275:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80127a:	74 56                	je     8012d2 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  80127c:	83 ec 0c             	sub    $0xc,%esp
  80127f:	ff 37                	pushl  (%edi)
  801281:	e8 74 9c 00 00       	call   80aefa <netconn_recv>
  801286:	89 c6                	mov    %eax,%esi
  801288:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  80128b:	83 c4 10             	add    $0x10,%esp
  80128e:	85 c0                	test   %eax,%eax
  801290:	0f 85 85 00 00 00    	jne    80131b <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801296:	8b 17                	mov    (%edi),%edx
  801298:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80129c:	74 0b                	je     8012a9 <lwip_recvfrom+0x6f>
  80129e:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8012a3:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8012a7:	74 17                	je     8012c0 <lwip_recvfrom+0x86>
  8012a9:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8012ad:	f7 da                	neg    %edx
  8012af:	b8 05 00 00 00       	mov    $0x5,%eax
  8012b4:	83 fa 0e             	cmp    $0xe,%edx
  8012b7:	77 07                	ja     8012c0 <lwip_recvfrom+0x86>
  8012b9:	8b 04 95 40 15 81 00 	mov    0x811540(,%edx,4),%eax
  8012c0:	89 47 10             	mov    %eax,0x10(%edi)
  8012c3:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  8012c8:	b8 00 00 00 00       	mov    $0x0,%eax
  8012cd:	e9 0b 01 00 00       	jmp    8013dd <lwip_recvfrom+0x1a3>
        sock_set_errno(sock, EWOULDBLOCK);
  8012d2:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8012d9:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  8012e0:	00 00 00 
        return -1;
  8012e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012e8:	e9 f0 00 00 00       	jmp    8013dd <lwip_recvfrom+0x1a3>
        sock->lastdata = NULL;
  8012ed:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  8012f4:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  8012fa:	83 ec 0c             	sub    $0xc,%esp
  8012fd:	56                   	push   %esi
  8012fe:	e8 47 11 00 00       	call   80244a <netbuf_delete>
  801303:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801306:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80130a:	0f 85 ac 00 00 00    	jne    8013bc <lwip_recvfrom+0x182>
    if (sock->lastdata) {
  801310:	8b 77 04             	mov    0x4(%edi),%esi
  801313:	85 f6                	test   %esi,%esi
  801315:	0f 84 4e ff ff ff    	je     801269 <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  80131b:	8b 16                	mov    (%esi),%edx
  80131d:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801321:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801325:	89 cb                	mov    %ecx,%ebx
  801327:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  801329:	0f b7 db             	movzwl %bx,%ebx
  80132c:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  80132f:	29 c1                	sub    %eax,%ecx
  801331:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  801334:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  801339:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80133b:	0f b7 c9             	movzwl %cx,%ecx
  80133e:	0f b7 c0             	movzwl %ax,%eax
  801341:	50                   	push   %eax
  801342:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801345:	51                   	push   %ecx
  801346:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80134a:	03 45 0c             	add    0xc(%ebp),%eax
  80134d:	50                   	push   %eax
  80134e:	52                   	push   %edx
  80134f:	e8 0b 3c 00 00       	call   804f5f <pbuf_copy_partial>
    off += copylen;
  801354:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801358:	83 c4 04             	add    $0x4,%esp
  80135b:	ff 37                	pushl  (%edi)
  80135d:	e8 48 99 00 00       	call   80acaa <netconn_type>
  801362:	83 c4 10             	add    $0x10,%esp
      done = 1;
  801365:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801369:	83 f8 10             	cmp    $0x10,%eax
  80136c:	75 23                	jne    801391 <lwip_recvfrom+0x157>
      len -= copylen;
  80136e:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801371:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801374:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801378:	7e 17                	jle    801391 <lwip_recvfrom+0x157>
  80137a:	8b 06                	mov    (%esi),%eax
  80137c:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  801380:	83 e0 01             	and    $0x1,%eax
  801383:	88 45 c7             	mov    %al,-0x39(%ebp)
  801386:	75 09                	jne    801391 <lwip_recvfrom+0x157>
  801388:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80138d:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  801391:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  801395:	75 25                	jne    8013bc <lwip_recvfrom+0x182>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  801397:	8b 07                	mov    (%edi),%eax
  801399:	83 38 10             	cmpl   $0x10,(%eax)
  80139c:	0f 85 4b ff ff ff    	jne    8012ed <lwip_recvfrom+0xb3>
  8013a2:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8013a5:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8013a8:	85 c0                	test   %eax,%eax
  8013aa:	0f 8e 3d ff ff ff    	jle    8012ed <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  8013b0:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8013b3:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8013b7:	e9 4a ff ff ff       	jmp    801306 <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  8013bc:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8013c0:	74 06                	je     8013c8 <lwip_recvfrom+0x18e>
  8013c2:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8013c6:	75 1d                	jne    8013e5 <lwip_recvfrom+0x1ab>
  sock_set_errno(sock, 0);
  8013c8:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8013cf:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8013d6:	00 00 00 
  return off;
  8013d9:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  8013dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8013e0:	5b                   	pop    %ebx
  8013e1:	5e                   	pop    %esi
  8013e2:	5f                   	pop    %edi
  8013e3:	5d                   	pop    %ebp
  8013e4:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013e5:	83 ec 0c             	sub    $0xc,%esp
  8013e8:	ff 37                	pushl  (%edi)
  8013ea:	e8 bb 98 00 00       	call   80acaa <netconn_type>
  8013ef:	83 c4 10             	add    $0x10,%esp
  8013f2:	83 f8 10             	cmp    $0x10,%eax
  8013f5:	74 65                	je     80145c <lwip_recvfrom+0x222>
      addr = netbuf_fromaddr(buf);
  8013f7:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8013fa:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8013fe:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  801402:	83 ec 04             	sub    $0x4,%esp
  801405:	6a 10                	push   $0x10
  801407:	6a 00                	push   $0x0
  801409:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80140c:	50                   	push   %eax
  80140d:	e8 31 db 00 00       	call   80ef43 <memset>
    sin.sin_len = sizeof(sin);
  801412:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801416:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80141a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80141e:	89 04 24             	mov    %eax,(%esp)
  801421:	e8 97 62 00 00       	call   8076bd <htons>
  801426:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80142a:	8b 03                	mov    (%ebx),%eax
  80142c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  80142f:	83 c4 10             	add    $0x10,%esp
  801432:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801435:	83 38 10             	cmpl   $0x10,(%eax)
  801438:	76 06                	jbe    801440 <lwip_recvfrom+0x206>
      *fromlen = sizeof(sin);
  80143a:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801440:	83 ec 04             	sub    $0x4,%esp
  801443:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801446:	ff 30                	pushl  (%eax)
  801448:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80144b:	50                   	push   %eax
  80144c:	ff 75 18             	pushl  0x18(%ebp)
  80144f:	e8 99 db 00 00       	call   80efed <memcpy>
  801454:	83 c4 10             	add    $0x10,%esp
  801457:	e9 6c ff ff ff       	jmp    8013c8 <lwip_recvfrom+0x18e>
      netconn_getaddr(sock->conn, addr, &port, 0);
  80145c:	6a 00                	push   $0x0
  80145e:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801461:	50                   	push   %eax
  801462:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801465:	50                   	push   %eax
  801466:	ff 37                	pushl  (%edi)
  801468:	e8 65 98 00 00       	call   80acd2 <netconn_getaddr>
  80146d:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801470:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801473:	eb 8d                	jmp    801402 <lwip_recvfrom+0x1c8>
    return -1;
  801475:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80147a:	e9 5e ff ff ff       	jmp    8013dd <lwip_recvfrom+0x1a3>

0080147f <lwip_read>:
{
  80147f:	55                   	push   %ebp
  801480:	89 e5                	mov    %esp,%ebp
  801482:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801485:	6a 00                	push   $0x0
  801487:	6a 00                	push   $0x0
  801489:	6a 00                	push   $0x0
  80148b:	ff 75 10             	pushl  0x10(%ebp)
  80148e:	ff 75 0c             	pushl  0xc(%ebp)
  801491:	ff 75 08             	pushl  0x8(%ebp)
  801494:	e8 a1 fd ff ff       	call   80123a <lwip_recvfrom>
}
  801499:	c9                   	leave  
  80149a:	c3                   	ret    

0080149b <lwip_recv>:
{
  80149b:	55                   	push   %ebp
  80149c:	89 e5                	mov    %esp,%ebp
  80149e:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8014a1:	6a 00                	push   $0x0
  8014a3:	6a 00                	push   $0x0
  8014a5:	ff 75 14             	pushl  0x14(%ebp)
  8014a8:	ff 75 10             	pushl  0x10(%ebp)
  8014ab:	ff 75 0c             	pushl  0xc(%ebp)
  8014ae:	ff 75 08             	pushl  0x8(%ebp)
  8014b1:	e8 84 fd ff ff       	call   80123a <lwip_recvfrom>
}
  8014b6:	c9                   	leave  
  8014b7:	c3                   	ret    

008014b8 <lwip_sendto>:
{
  8014b8:	55                   	push   %ebp
  8014b9:	89 e5                	mov    %esp,%ebp
  8014bb:	57                   	push   %edi
  8014bc:	56                   	push   %esi
  8014bd:	53                   	push   %ebx
  8014be:	83 ec 2c             	sub    $0x2c,%esp
  8014c1:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8014c4:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  8014c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8014ca:	e8 36 f2 ff ff       	call   800705 <get_socket>
  if (!sock)
  8014cf:	85 c0                	test   %eax,%eax
  8014d1:	0f 84 28 01 00 00    	je     8015ff <lwip_sendto+0x147>
  8014d7:	89 c6                	mov    %eax,%esi
  if (sock->conn->type==NETCONN_TCP) {
  8014d9:	8b 00                	mov    (%eax),%eax
  8014db:	83 38 10             	cmpl   $0x10,(%eax)
  8014de:	0f 84 be 00 00 00    	je     8015a2 <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8014e4:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8014ea:	0f 87 c8 00 00 00    	ja     8015b8 <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8014f0:	89 f8                	mov    %edi,%eax
  8014f2:	0b 45 1c             	or     0x1c(%ebp),%eax
  8014f5:	0f 84 0b 01 00 00    	je     801606 <lwip_sendto+0x14e>
  8014fb:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8014ff:	0f 85 ca 00 00 00    	jne    8015cf <lwip_sendto+0x117>
  801505:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  801509:	0f 85 c0 00 00 00    	jne    8015cf <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  80150f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801516:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80151d:	8b 47 04             	mov    0x4(%edi),%eax
  801520:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801523:	83 ec 0c             	sub    $0xc,%esp
  801526:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80152a:	50                   	push   %eax
  80152b:	e8 9a 61 00 00       	call   8076ca <ntohs>
    buf.addr         = &remote_addr;
  801530:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801533:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801536:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80153a:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80153d:	83 ec 04             	sub    $0x4,%esp
  801540:	0f b7 c3             	movzwl %bx,%eax
  801543:	50                   	push   %eax
  801544:	ff 75 0c             	pushl  0xc(%ebp)
  801547:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80154a:	50                   	push   %eax
  80154b:	e8 f5 0f 00 00       	call   802545 <netbuf_ref>
  801550:	0f be f8             	movsbl %al,%edi
  801553:	83 c4 10             	add    $0x10,%esp
  801556:	85 ff                	test   %edi,%edi
  801558:	0f 84 88 00 00 00    	je     8015e6 <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  80155e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801561:	85 c0                	test   %eax,%eax
  801563:	74 0c                	je     801571 <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  801565:	83 ec 0c             	sub    $0xc,%esp
  801568:	50                   	push   %eax
  801569:	e8 75 32 00 00       	call   8047e3 <pbuf_free>
  80156e:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801571:	89 fa                	mov    %edi,%edx
  801573:	f7 da                	neg    %edx
  801575:	b8 05 00 00 00       	mov    $0x5,%eax
  80157a:	83 fa 0e             	cmp    $0xe,%edx
  80157d:	77 07                	ja     801586 <lwip_sendto+0xce>
  80157f:	8b 04 95 40 15 81 00 	mov    0x811540(,%edx,4),%eax
  801586:	89 46 10             	mov    %eax,0x10(%esi)
  801589:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  80158e:	85 ff                	test   %edi,%edi
  801590:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801595:	0f 45 d8             	cmovne %eax,%ebx
}
  801598:	89 d8                	mov    %ebx,%eax
  80159a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80159d:	5b                   	pop    %ebx
  80159e:	5e                   	pop    %esi
  80159f:	5f                   	pop    %edi
  8015a0:	5d                   	pop    %ebp
  8015a1:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8015a2:	ff 75 14             	pushl  0x14(%ebp)
  8015a5:	53                   	push   %ebx
  8015a6:	ff 75 0c             	pushl  0xc(%ebp)
  8015a9:	ff 75 08             	pushl  0x8(%ebp)
  8015ac:	e8 7c 00 00 00       	call   80162d <lwip_send>
  8015b1:	89 c3                	mov    %eax,%ebx
  8015b3:	83 c4 10             	add    $0x10,%esp
  8015b6:	eb e0                	jmp    801598 <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8015b8:	83 ec 04             	sub    $0x4,%esp
  8015bb:	68 00 15 81 00       	push   $0x811500
  8015c0:	68 97 02 00 00       	push   $0x297
  8015c5:	68 70 14 81 00       	push   $0x811470
  8015ca:	e8 d9 cf 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8015cf:	83 ec 04             	sub    $0x4,%esp
  8015d2:	68 e1 14 81 00       	push   $0x8114e1
  8015d7:	68 9b 02 00 00       	push   $0x29b
  8015dc:	68 70 14 81 00       	push   $0x811470
  8015e1:	e8 c2 cf 00 00       	call   80e5a8 <_panic>
    err = netconn_send(sock->conn, &buf);
  8015e6:	83 ec 08             	sub    $0x8,%esp
  8015e9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8015ec:	50                   	push   %eax
  8015ed:	ff 36                	pushl  (%esi)
  8015ef:	e8 9b 9a 00 00       	call   80b08f <netconn_send>
  8015f4:	0f be f8             	movsbl %al,%edi
  8015f7:	83 c4 10             	add    $0x10,%esp
  8015fa:	e9 5f ff ff ff       	jmp    80155e <lwip_sendto+0xa6>
    return -1;
  8015ff:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801604:	eb 92                	jmp    801598 <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  801606:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80160d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801614:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  80161b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801622:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  801628:	e9 10 ff ff ff       	jmp    80153d <lwip_sendto+0x85>

0080162d <lwip_send>:
{
  80162d:	55                   	push   %ebp
  80162e:	89 e5                	mov    %esp,%ebp
  801630:	57                   	push   %edi
  801631:	56                   	push   %esi
  801632:	53                   	push   %ebx
  801633:	83 ec 0c             	sub    $0xc,%esp
  801636:	8b 7d 08             	mov    0x8(%ebp),%edi
  801639:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  80163c:	89 f8                	mov    %edi,%eax
  80163e:	e8 c2 f0 ff ff       	call   800705 <get_socket>
  if (!sock)
  801643:	85 c0                	test   %eax,%eax
  801645:	74 70                	je     8016b7 <lwip_send+0x8a>
  801647:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  801649:	8b 00                	mov    (%eax),%eax
  80164b:	83 38 10             	cmpl   $0x10,(%eax)
  80164e:	74 1f                	je     80166f <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801650:	83 ec 08             	sub    $0x8,%esp
  801653:	6a 00                	push   $0x0
  801655:	6a 00                	push   $0x0
  801657:	ff 75 14             	pushl  0x14(%ebp)
  80165a:	53                   	push   %ebx
  80165b:	ff 75 0c             	pushl  0xc(%ebp)
  80165e:	57                   	push   %edi
  80165f:	e8 54 fe ff ff       	call   8014b8 <lwip_sendto>
  801664:	83 c4 20             	add    $0x20,%esp
}
  801667:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80166a:	5b                   	pop    %ebx
  80166b:	5e                   	pop    %esi
  80166c:	5f                   	pop    %edi
  80166d:	5d                   	pop    %ebp
  80166e:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  80166f:	8b 55 14             	mov    0x14(%ebp),%edx
  801672:	c1 ea 03             	shr    $0x3,%edx
  801675:	83 e2 02             	and    $0x2,%edx
  801678:	83 ca 01             	or     $0x1,%edx
  80167b:	0f b6 d2             	movzbl %dl,%edx
  80167e:	52                   	push   %edx
  80167f:	53                   	push   %ebx
  801680:	ff 75 0c             	pushl  0xc(%ebp)
  801683:	50                   	push   %eax
  801684:	e8 82 9a 00 00       	call   80b10b <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  801689:	0f be d0             	movsbl %al,%edx
  80168c:	f7 da                	neg    %edx
  80168e:	83 c4 10             	add    $0x10,%esp
  801691:	b9 05 00 00 00       	mov    $0x5,%ecx
  801696:	83 fa 0e             	cmp    $0xe,%edx
  801699:	77 07                	ja     8016a2 <lwip_send+0x75>
  80169b:	8b 0c 95 40 15 81 00 	mov    0x811540(,%edx,4),%ecx
  8016a2:	89 4e 10             	mov    %ecx,0x10(%esi)
  8016a5:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  8016ab:	84 c0                	test   %al,%al
  8016ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016b2:	0f 44 c3             	cmove  %ebx,%eax
  8016b5:	eb b0                	jmp    801667 <lwip_send+0x3a>
    return -1;
  8016b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8016bc:	eb a9                	jmp    801667 <lwip_send+0x3a>

008016be <lwip_socket>:
{
  8016be:	55                   	push   %ebp
  8016bf:	89 e5                	mov    %esp,%ebp
  8016c1:	56                   	push   %esi
  8016c2:	53                   	push   %ebx
  8016c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  8016c6:	83 f8 02             	cmp    $0x2,%eax
  8016c9:	74 5c                	je     801727 <lwip_socket+0x69>
  8016cb:	83 f8 03             	cmp    $0x3,%eax
  8016ce:	74 16                	je     8016e6 <lwip_socket+0x28>
  8016d0:	83 f8 01             	cmp    $0x1,%eax
  8016d3:	74 79                	je     80174e <lwip_socket+0x90>
    set_errno(EINVAL);
  8016d5:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  8016dc:	00 00 00 
    return -1;
  8016df:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8016e4:	eb 38                	jmp    80171e <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8016e6:	83 ec 04             	sub    $0x4,%esp
  8016e9:	68 f3 08 80 00       	push   $0x8008f3
  8016ee:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  8016f2:	50                   	push   %eax
  8016f3:	6a 40                	push   $0x40
  8016f5:	e8 95 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  8016fa:	89 c6                	mov    %eax,%esi
    break;
  8016fc:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  8016ff:	85 f6                	test   %esi,%esi
  801701:	74 63                	je     801766 <lwip_socket+0xa8>
  i = alloc_socket(conn);
  801703:	89 f0                	mov    %esi,%eax
  801705:	e8 93 f3 ff ff       	call   800a9d <alloc_socket>
  80170a:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  80170c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80170f:	74 66                	je     801777 <lwip_socket+0xb9>
  conn->socket = i;
  801711:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801714:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80171b:	00 00 00 
}
  80171e:	89 d8                	mov    %ebx,%eax
  801720:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801723:	5b                   	pop    %ebx
  801724:	5e                   	pop    %esi
  801725:	5d                   	pop    %ebp
  801726:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801727:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80172e:	0f 94 c0             	sete   %al
  801731:	0f b6 c0             	movzbl %al,%eax
  801734:	83 c0 20             	add    $0x20,%eax
  801737:	83 ec 04             	sub    $0x4,%esp
  80173a:	68 f3 08 80 00       	push   $0x8008f3
  80173f:	6a 00                	push   $0x0
  801741:	50                   	push   %eax
  801742:	e8 48 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  801747:	89 c6                	mov    %eax,%esi
    break;
  801749:	83 c4 10             	add    $0x10,%esp
  80174c:	eb b1                	jmp    8016ff <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80174e:	83 ec 04             	sub    $0x4,%esp
  801751:	68 f3 08 80 00       	push   $0x8008f3
  801756:	6a 00                	push   $0x0
  801758:	6a 10                	push   $0x10
  80175a:	e8 30 94 00 00       	call   80ab8f <netconn_new_with_proto_and_callback>
  80175f:	89 c6                	mov    %eax,%esi
    break;
  801761:	83 c4 10             	add    $0x10,%esp
  801764:	eb 99                	jmp    8016ff <lwip_socket+0x41>
    set_errno(ENOBUFS);
  801766:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  80176d:	00 00 00 
    return -1;
  801770:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801775:	eb a7                	jmp    80171e <lwip_socket+0x60>
    netconn_delete(conn);
  801777:	83 ec 0c             	sub    $0xc,%esp
  80177a:	56                   	push   %esi
  80177b:	e8 ea 94 00 00       	call   80ac6a <netconn_delete>
    set_errno(ENFILE);
  801780:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801787:	00 00 00 
    return -1;
  80178a:	83 c4 10             	add    $0x10,%esp
  80178d:	eb 8f                	jmp    80171e <lwip_socket+0x60>

0080178f <lwip_write>:
{
  80178f:	55                   	push   %ebp
  801790:	89 e5                	mov    %esp,%ebp
  801792:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  801795:	6a 00                	push   $0x0
  801797:	ff 75 10             	pushl  0x10(%ebp)
  80179a:	ff 75 0c             	pushl  0xc(%ebp)
  80179d:	ff 75 08             	pushl  0x8(%ebp)
  8017a0:	e8 88 fe ff ff       	call   80162d <lwip_send>
}
  8017a5:	c9                   	leave  
  8017a6:	c3                   	ret    

008017a7 <lwip_select>:
{
  8017a7:	55                   	push   %ebp
  8017a8:	89 e5                	mov    %esp,%ebp
  8017aa:	57                   	push   %edi
  8017ab:	56                   	push   %esi
  8017ac:	53                   	push   %ebx
  8017ad:	83 ec 58             	sub    $0x58,%esp
  8017b0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8017b3:	8b 75 10             	mov    0x10(%ebp),%esi
  8017b6:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  8017b9:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8017c0:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  8017c3:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8017c6:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8017c9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  8017d0:	ff 35 40 50 81 00    	pushl  0x815040
  8017d6:	e8 e6 38 00 00       	call   8050c1 <sys_sem_wait>
  if (readset)
  8017db:	83 c4 10             	add    $0x10,%esp
  8017de:	85 db                	test   %ebx,%ebx
  8017e0:	0f 84 0b 01 00 00    	je     8018f1 <lwip_select+0x14a>
    lreadset = *readset;
  8017e6:	8b 03                	mov    (%ebx),%eax
  8017e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  8017eb:	85 f6                	test   %esi,%esi
  8017ed:	0f 84 16 01 00 00    	je     801909 <lwip_select+0x162>
    lwriteset = *writeset;
  8017f3:	8b 06                	mov    (%esi),%eax
  8017f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  8017f8:	85 ff                	test   %edi,%edi
  8017fa:	0f 84 21 01 00 00    	je     801921 <lwip_select+0x17a>
    lexceptset = *exceptset;
  801800:	8b 07                	mov    (%edi),%eax
  801802:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801805:	83 ec 0c             	sub    $0xc,%esp
  801808:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80180b:	50                   	push   %eax
  80180c:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  80180f:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801812:	8b 45 08             	mov    0x8(%ebp),%eax
  801815:	e8 29 ef ff ff       	call   800743 <lwip_selscan>
  80181a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  80181d:	83 c4 10             	add    $0x10,%esp
  801820:	85 c0                	test   %eax,%eax
  801822:	0f 85 a0 02 00 00    	jne    801ac8 <lwip_select+0x321>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801828:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80182c:	0f 84 ac 02 00 00    	je     801ade <lwip_select+0x337>
  801832:	8b 45 18             	mov    0x18(%ebp),%eax
  801835:	83 38 00             	cmpl   $0x0,(%eax)
  801838:	75 0e                	jne    801848 <lwip_select+0xa1>
  80183a:	8b 40 04             	mov    0x4(%eax),%eax
  80183d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801840:	85 c0                	test   %eax,%eax
  801842:	0f 84 f1 00 00 00    	je     801939 <lwip_select+0x192>
    select_cb.sem = sys_sem_new(0);
  801848:	83 ec 0c             	sub    $0xc,%esp
  80184b:	6a 00                	push   $0x0
  80184d:	e8 44 85 00 00       	call   809d96 <sys_sem_new>
  801852:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801855:	a1 48 50 81 00       	mov    0x815048,%eax
  80185a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  80185d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801860:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801865:	83 c4 04             	add    $0x4,%esp
  801868:	ff 35 40 50 81 00    	pushl  0x815040
  80186e:	e8 e0 87 00 00       	call   80a053 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801873:	8b 45 18             	mov    0x18(%ebp),%eax
  801876:	8b 40 04             	mov    0x4(%eax),%eax
  801879:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  80187c:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801882:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801887:	89 c8                	mov    %ecx,%eax
  801889:	f7 ea                	imul   %edx
  80188b:	c1 fa 06             	sar    $0x6,%edx
  80188e:	c1 f9 1f             	sar    $0x1f,%ecx
  801891:	29 ca                	sub    %ecx,%edx
  801893:	8b 45 18             	mov    0x18(%ebp),%eax
  801896:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  80189c:	83 c4 10             	add    $0x10,%esp
  80189f:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  8018a1:	ba 01 00 00 00       	mov    $0x1,%edx
  8018a6:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  8018a9:	83 ec 08             	sub    $0x8,%esp
  8018ac:	50                   	push   %eax
  8018ad:	ff 75 d8             	pushl  -0x28(%ebp)
  8018b0:	e8 dc 39 00 00       	call   805291 <sys_sem_wait_timeout>
  8018b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  8018b8:	83 c4 04             	add    $0x4,%esp
  8018bb:	ff 35 40 50 81 00    	pushl  0x815040
  8018c1:	e8 fb 37 00 00       	call   8050c1 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  8018c6:	a1 48 50 81 00       	mov    0x815048,%eax
  8018cb:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  8018ce:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  8018d1:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  8018d3:	39 d0                	cmp    %edx,%eax
  8018d5:	0f 84 ba 00 00 00    	je     801995 <lwip_select+0x1ee>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018db:	85 c0                	test   %eax,%eax
  8018dd:	0f 84 c1 00 00 00    	je     8019a4 <lwip_select+0x1fd>
        if (p_selcb->next == &select_cb) {
  8018e3:	8b 10                	mov    (%eax),%edx
  8018e5:	39 ca                	cmp    %ecx,%edx
  8018e7:	0f 84 b2 00 00 00    	je     80199f <lwip_select+0x1f8>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8018ed:	89 d0                	mov    %edx,%eax
  8018ef:	eb ea                	jmp    8018db <lwip_select+0x134>
    FD_ZERO(&lreadset);
  8018f1:	83 ec 04             	sub    $0x4,%esp
  8018f4:	6a 04                	push   $0x4
  8018f6:	6a 00                	push   $0x0
  8018f8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8018fb:	50                   	push   %eax
  8018fc:	e8 42 d6 00 00       	call   80ef43 <memset>
  801901:	83 c4 10             	add    $0x10,%esp
  801904:	e9 e2 fe ff ff       	jmp    8017eb <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  801909:	83 ec 04             	sub    $0x4,%esp
  80190c:	6a 04                	push   $0x4
  80190e:	6a 00                	push   $0x0
  801910:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801913:	50                   	push   %eax
  801914:	e8 2a d6 00 00       	call   80ef43 <memset>
  801919:	83 c4 10             	add    $0x10,%esp
  80191c:	e9 d7 fe ff ff       	jmp    8017f8 <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  801921:	83 ec 04             	sub    $0x4,%esp
  801924:	6a 04                	push   $0x4
  801926:	6a 00                	push   $0x0
  801928:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80192b:	50                   	push   %eax
  80192c:	e8 12 d6 00 00       	call   80ef43 <memset>
  801931:	83 c4 10             	add    $0x10,%esp
  801934:	e9 cc fe ff ff       	jmp    801805 <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  801939:	83 ec 0c             	sub    $0xc,%esp
  80193c:	ff 35 40 50 81 00    	pushl  0x815040
  801942:	e8 0c 87 00 00       	call   80a053 <sys_sem_signal>
      if (readset)
  801947:	83 c4 10             	add    $0x10,%esp
  80194a:	85 db                	test   %ebx,%ebx
  80194c:	74 10                	je     80195e <lwip_select+0x1b7>
        FD_ZERO(readset);
  80194e:	83 ec 04             	sub    $0x4,%esp
  801951:	6a 04                	push   $0x4
  801953:	6a 00                	push   $0x0
  801955:	53                   	push   %ebx
  801956:	e8 e8 d5 00 00       	call   80ef43 <memset>
  80195b:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  80195e:	85 f6                	test   %esi,%esi
  801960:	74 10                	je     801972 <lwip_select+0x1cb>
        FD_ZERO(writeset);
  801962:	83 ec 04             	sub    $0x4,%esp
  801965:	6a 04                	push   $0x4
  801967:	6a 00                	push   $0x0
  801969:	56                   	push   %esi
  80196a:	e8 d4 d5 00 00       	call   80ef43 <memset>
  80196f:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801972:	85 ff                	test   %edi,%edi
  801974:	74 10                	je     801986 <lwip_select+0x1df>
        FD_ZERO(exceptset);
  801976:	83 ec 04             	sub    $0x4,%esp
  801979:	6a 04                	push   $0x4
  80197b:	6a 00                	push   $0x0
  80197d:	57                   	push   %edi
  80197e:	e8 c0 d5 00 00       	call   80ef43 <memset>
  801983:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801986:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80198d:	00 00 00 
      return 0;
  801990:	e9 98 00 00 00       	jmp    801a2d <lwip_select+0x286>
      select_cb_list = select_cb.next;
  801995:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801998:	a3 48 50 81 00       	mov    %eax,0x815048
  80199d:	eb 05                	jmp    8019a4 <lwip_select+0x1fd>
          p_selcb->next = select_cb.next;
  80199f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  8019a2:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  8019a4:	83 ec 0c             	sub    $0xc,%esp
  8019a7:	ff 35 40 50 81 00    	pushl  0x815040
  8019ad:	e8 a1 86 00 00       	call   80a053 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  8019b2:	83 c4 04             	add    $0x4,%esp
  8019b5:	ff 75 d8             	pushl  -0x28(%ebp)
  8019b8:	e8 5a 84 00 00       	call   809e17 <sys_sem_free>
    if (i == 0)  {
  8019bd:	83 c4 10             	add    $0x10,%esp
  8019c0:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8019c4:	74 72                	je     801a38 <lwip_select+0x291>
    if (readset)
  8019c6:	85 db                	test   %ebx,%ebx
  8019c8:	0f 84 b2 00 00 00    	je     801a80 <lwip_select+0x2d9>
      lreadset = *readset;
  8019ce:	8b 03                	mov    (%ebx),%eax
  8019d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  8019d3:	85 f6                	test   %esi,%esi
  8019d5:	0f 84 bd 00 00 00    	je     801a98 <lwip_select+0x2f1>
      lwriteset = *writeset;
  8019db:	8b 06                	mov    (%esi),%eax
  8019dd:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  8019e0:	85 ff                	test   %edi,%edi
  8019e2:	0f 84 c8 00 00 00    	je     801ab0 <lwip_select+0x309>
      lexceptset = *exceptset;
  8019e8:	8b 07                	mov    (%edi),%eax
  8019ea:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8019ed:	83 ec 0c             	sub    $0xc,%esp
  8019f0:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019f3:	50                   	push   %eax
  8019f4:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8019f7:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8019fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8019fd:	e8 41 ed ff ff       	call   800743 <lwip_selscan>
  801a02:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a05:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801a08:	85 db                	test   %ebx,%ebx
  801a0a:	74 05                	je     801a11 <lwip_select+0x26a>
    *readset = lreadset;
  801a0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a0f:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801a11:	85 f6                	test   %esi,%esi
  801a13:	74 05                	je     801a1a <lwip_select+0x273>
    *writeset = lwriteset;
  801a15:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a18:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801a1a:	85 ff                	test   %edi,%edi
  801a1c:	74 05                	je     801a23 <lwip_select+0x27c>
    *exceptset = lexceptset;
  801a1e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a21:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801a23:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a2a:	00 00 00 
}
  801a2d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801a30:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801a33:	5b                   	pop    %ebx
  801a34:	5e                   	pop    %esi
  801a35:	5f                   	pop    %edi
  801a36:	5d                   	pop    %ebp
  801a37:	c3                   	ret    
      if (readset)
  801a38:	85 db                	test   %ebx,%ebx
  801a3a:	74 10                	je     801a4c <lwip_select+0x2a5>
        FD_ZERO(readset);
  801a3c:	83 ec 04             	sub    $0x4,%esp
  801a3f:	6a 04                	push   $0x4
  801a41:	6a 00                	push   $0x0
  801a43:	53                   	push   %ebx
  801a44:	e8 fa d4 00 00       	call   80ef43 <memset>
  801a49:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801a4c:	85 f6                	test   %esi,%esi
  801a4e:	74 10                	je     801a60 <lwip_select+0x2b9>
        FD_ZERO(writeset);
  801a50:	83 ec 04             	sub    $0x4,%esp
  801a53:	6a 04                	push   $0x4
  801a55:	6a 00                	push   $0x0
  801a57:	56                   	push   %esi
  801a58:	e8 e6 d4 00 00       	call   80ef43 <memset>
  801a5d:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a60:	85 ff                	test   %edi,%edi
  801a62:	74 10                	je     801a74 <lwip_select+0x2cd>
        FD_ZERO(exceptset);
  801a64:	83 ec 04             	sub    $0x4,%esp
  801a67:	6a 04                	push   $0x4
  801a69:	6a 00                	push   $0x0
  801a6b:	57                   	push   %edi
  801a6c:	e8 d2 d4 00 00       	call   80ef43 <memset>
  801a71:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801a74:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a7b:	00 00 00 
      return 0;
  801a7e:	eb ad                	jmp    801a2d <lwip_select+0x286>
      FD_ZERO(&lreadset);
  801a80:	83 ec 04             	sub    $0x4,%esp
  801a83:	6a 04                	push   $0x4
  801a85:	6a 00                	push   $0x0
  801a87:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801a8a:	50                   	push   %eax
  801a8b:	e8 b3 d4 00 00       	call   80ef43 <memset>
  801a90:	83 c4 10             	add    $0x10,%esp
  801a93:	e9 3b ff ff ff       	jmp    8019d3 <lwip_select+0x22c>
      FD_ZERO(&lwriteset);
  801a98:	83 ec 04             	sub    $0x4,%esp
  801a9b:	6a 04                	push   $0x4
  801a9d:	6a 00                	push   $0x0
  801a9f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801aa2:	50                   	push   %eax
  801aa3:	e8 9b d4 00 00       	call   80ef43 <memset>
  801aa8:	83 c4 10             	add    $0x10,%esp
  801aab:	e9 30 ff ff ff       	jmp    8019e0 <lwip_select+0x239>
      FD_ZERO(&lexceptset);
  801ab0:	83 ec 04             	sub    $0x4,%esp
  801ab3:	6a 04                	push   $0x4
  801ab5:	6a 00                	push   $0x0
  801ab7:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801aba:	50                   	push   %eax
  801abb:	e8 83 d4 00 00       	call   80ef43 <memset>
  801ac0:	83 c4 10             	add    $0x10,%esp
  801ac3:	e9 25 ff ff ff       	jmp    8019ed <lwip_select+0x246>
    sys_sem_signal(selectsem);
  801ac8:	83 ec 0c             	sub    $0xc,%esp
  801acb:	ff 35 40 50 81 00    	pushl  0x815040
  801ad1:	e8 7d 85 00 00       	call   80a053 <sys_sem_signal>
  801ad6:	83 c4 10             	add    $0x10,%esp
  801ad9:	e9 2a ff ff ff       	jmp    801a08 <lwip_select+0x261>
    select_cb.sem = sys_sem_new(0);
  801ade:	83 ec 0c             	sub    $0xc,%esp
  801ae1:	6a 00                	push   $0x0
  801ae3:	e8 ae 82 00 00       	call   809d96 <sys_sem_new>
  801ae8:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801aeb:	a1 48 50 81 00       	mov    0x815048,%eax
  801af0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801af3:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801af6:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801afb:	83 c4 04             	add    $0x4,%esp
  801afe:	ff 35 40 50 81 00    	pushl  0x815040
  801b04:	e8 4a 85 00 00       	call   80a053 <sys_sem_signal>
  801b09:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801b0c:	b8 00 00 00 00       	mov    $0x0,%eax
  801b11:	e9 93 fd ff ff       	jmp    8018a9 <lwip_select+0x102>

00801b16 <lwip_shutdown>:
{
  801b16:	55                   	push   %ebp
  801b17:	89 e5                	mov    %esp,%ebp
  801b19:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801b1c:	ff 75 08             	pushl  0x8(%ebp)
  801b1f:	e8 4d f5 ff ff       	call   801071 <lwip_close>
}
  801b24:	c9                   	leave  
  801b25:	c3                   	ret    

00801b26 <lwip_getpeername>:
{
  801b26:	55                   	push   %ebp
  801b27:	89 e5                	mov    %esp,%ebp
  801b29:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801b2c:	6a 00                	push   $0x0
  801b2e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b31:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b34:	8b 45 08             	mov    0x8(%ebp),%eax
  801b37:	e8 0c ed ff ff       	call   800848 <lwip_getaddrname>
}
  801b3c:	c9                   	leave  
  801b3d:	c3                   	ret    

00801b3e <lwip_getsockname>:
{
  801b3e:	55                   	push   %ebp
  801b3f:	89 e5                	mov    %esp,%ebp
  801b41:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801b44:	6a 01                	push   $0x1
  801b46:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801b49:	8b 55 0c             	mov    0xc(%ebp),%edx
  801b4c:	8b 45 08             	mov    0x8(%ebp),%eax
  801b4f:	e8 f4 ec ff ff       	call   800848 <lwip_getaddrname>
}
  801b54:	c9                   	leave  
  801b55:	c3                   	ret    

00801b56 <lwip_getsockopt>:
{
  801b56:	55                   	push   %ebp
  801b57:	89 e5                	mov    %esp,%ebp
  801b59:	57                   	push   %edi
  801b5a:	56                   	push   %esi
  801b5b:	53                   	push   %ebx
  801b5c:	83 ec 2c             	sub    $0x2c,%esp
  801b5f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801b62:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801b65:	8b 45 08             	mov    0x8(%ebp),%eax
  801b68:	e8 98 eb ff ff       	call   800705 <get_socket>
  if (!sock)
  801b6d:	85 c0                	test   %eax,%eax
  801b6f:	0f 84 af 01 00 00    	je     801d24 <lwip_getsockopt+0x1ce>
  801b75:	89 c6                	mov    %eax,%esi
  if ((NULL == optval) || (NULL == optlen)) {
  801b77:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801b7b:	74 39                	je     801bb6 <lwip_getsockopt+0x60>
  801b7d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b81:	74 33                	je     801bb6 <lwip_getsockopt+0x60>
  switch (level) {
  801b83:	83 fb 06             	cmp    $0x6,%ebx
  801b86:	0f 84 36 01 00 00    	je     801cc2 <lwip_getsockopt+0x16c>
  801b8c:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801b92:	74 3d                	je     801bd1 <lwip_getsockopt+0x7b>
      err = ENOPROTOOPT;
  801b94:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801b99:	85 db                	test   %ebx,%ebx
  801b9b:	0f 84 a9 00 00 00    	je     801c4a <lwip_getsockopt+0xf4>
    sock_set_errno(sock, err);
  801ba1:	0f be c0             	movsbl %al,%eax
  801ba4:	89 46 10             	mov    %eax,0x10(%esi)
  801ba7:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801bac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bb1:	e9 04 01 00 00       	jmp    801cba <lwip_getsockopt+0x164>
    sock_set_errno(sock, EFAULT);
  801bb6:	c7 46 10 0e 00 00 00 	movl   $0xe,0x10(%esi)
  801bbd:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801bc4:	00 00 00 
    return -1;
  801bc7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801bcc:	e9 e9 00 00 00       	jmp    801cba <lwip_getsockopt+0x164>
  801bd1:	83 ff 20             	cmp    $0x20,%edi
  801bd4:	74 62                	je     801c38 <lwip_getsockopt+0xe2>
  801bd6:	7e 4d                	jle    801c25 <lwip_getsockopt+0xcf>
  801bd8:	81 ff 07 10 00 00    	cmp    $0x1007,%edi
  801bde:	0f 8c 04 01 00 00    	jl     801ce8 <lwip_getsockopt+0x192>
  801be4:	81 ff 08 10 00 00    	cmp    $0x1008,%edi
  801bea:	7e 4c                	jle    801c38 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801bec:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801bf1:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  801bf7:	75 a8                	jne    801ba1 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801bf9:	8b 45 18             	mov    0x18(%ebp),%eax
  801bfc:	83 38 04             	cmpl   $0x4,(%eax)
  801bff:	19 c0                	sbb    %eax,%eax
  801c01:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801c04:	8b 16                	mov    (%esi),%edx
  801c06:	83 3a 20             	cmpl   $0x20,(%edx)
  801c09:	0f 85 e3 00 00 00    	jne    801cf2 <lwip_getsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801c0f:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801c12:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801c16:	0f 85 e0 00 00 00    	jne    801cfc <lwip_getsockopt+0x1a6>
  if (err != ERR_OK) {
  801c1c:	84 c0                	test   %al,%al
  801c1e:	74 42                	je     801c62 <lwip_getsockopt+0x10c>
  801c20:	e9 7c ff ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
  801c25:	83 ff 02             	cmp    $0x2,%edi
  801c28:	74 0e                	je     801c38 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801c2a:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c2f:	83 ff 08             	cmp    $0x8,%edi
  801c32:	0f 85 69 ff ff ff    	jne    801ba1 <lwip_getsockopt+0x4b>
      if (*optlen < sizeof(int)) {
  801c38:	8b 45 18             	mov    0x18(%ebp),%eax
  801c3b:	83 38 03             	cmpl   $0x3,(%eax)
  801c3e:	77 22                	ja     801c62 <lwip_getsockopt+0x10c>
        err = EINVAL;
  801c40:	b8 16 00 00 00       	mov    $0x16,%eax
  801c45:	e9 57 ff ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
  801c4a:	8d 47 ff             	lea    -0x1(%edi),%eax
  801c4d:	83 f8 01             	cmp    $0x1,%eax
  801c50:	0f 87 b0 00 00 00    	ja     801d06 <lwip_getsockopt+0x1b0>
      if (*optlen < sizeof(int)) {
  801c56:	8b 45 18             	mov    0x18(%ebp),%eax
  801c59:	83 38 03             	cmpl   $0x3,(%eax)
  801c5c:	0f 86 ae 00 00 00    	jbe    801d10 <lwip_getsockopt+0x1ba>
  data.sock = sock;
  801c62:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801c65:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801c68:	89 7d d8             	mov    %edi,-0x28(%ebp)
  data.optval = optval;
  801c6b:	8b 45 14             	mov    0x14(%ebp),%eax
  801c6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801c71:	8b 45 18             	mov    0x18(%ebp),%eax
  801c74:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801c77:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801c7b:	83 ec 04             	sub    $0x4,%esp
  801c7e:	6a 01                	push   $0x1
  801c80:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801c83:	50                   	push   %eax
  801c84:	68 45 0b 80 00       	push   $0x800b45
  801c89:	e8 dc 05 00 00       	call   80226a <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801c8e:	83 c4 08             	add    $0x8,%esp
  801c91:	6a 00                	push   $0x0
  801c93:	8b 06                	mov    (%esi),%eax
  801c95:	ff 70 10             	pushl  0x10(%eax)
  801c98:	e8 26 84 00 00       	call   80a0c3 <sys_arch_sem_wait>
  err = data.err;
  801c9d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801ca1:	0f be d0             	movsbl %al,%edx
  801ca4:	89 56 10             	mov    %edx,0x10(%esi)
  801ca7:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801cad:	83 c4 10             	add    $0x10,%esp
  801cb0:	84 c0                	test   %al,%al
  801cb2:	0f 95 c0             	setne  %al
  801cb5:	0f b6 c0             	movzbl %al,%eax
  801cb8:	f7 d8                	neg    %eax
}
  801cba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801cbd:	5b                   	pop    %ebx
  801cbe:	5e                   	pop    %esi
  801cbf:	5f                   	pop    %edi
  801cc0:	5d                   	pop    %ebp
  801cc1:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801cc2:	8b 45 18             	mov    0x18(%ebp),%eax
  801cc5:	83 38 03             	cmpl   $0x3,(%eax)
  801cc8:	76 50                	jbe    801d1a <lwip_getsockopt+0x1c4>
    if (sock->conn->type != NETCONN_TCP)
  801cca:	8b 16                	mov    (%esi),%edx
      return 0;
  801ccc:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801cd1:	83 3a 10             	cmpl   $0x10,(%edx)
  801cd4:	75 e4                	jne    801cba <lwip_getsockopt+0x164>
  801cd6:	8d 47 ff             	lea    -0x1(%edi),%eax
  801cd9:	83 f8 01             	cmp    $0x1,%eax
  801cdc:	76 84                	jbe    801c62 <lwip_getsockopt+0x10c>
      err = ENOPROTOOPT;
  801cde:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ce3:	e9 b9 fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801ce8:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ced:	e9 af fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
        err = EAFNOSUPPORT;
  801cf2:	b8 61 00 00 00       	mov    $0x61,%eax
  801cf7:	e9 a5 fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
  801cfc:	b8 61 00 00 00       	mov    $0x61,%eax
  801d01:	e9 9b fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801d06:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d0b:	e9 91 fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801d10:	b8 16 00 00 00       	mov    $0x16,%eax
  801d15:	e9 87 fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
      err = EINVAL;
  801d1a:	b8 16 00 00 00       	mov    $0x16,%eax
  801d1f:	e9 7d fe ff ff       	jmp    801ba1 <lwip_getsockopt+0x4b>
    return -1;
  801d24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d29:	eb 8f                	jmp    801cba <lwip_getsockopt+0x164>

00801d2b <lwip_setsockopt>:
{
  801d2b:	55                   	push   %ebp
  801d2c:	89 e5                	mov    %esp,%ebp
  801d2e:	57                   	push   %edi
  801d2f:	56                   	push   %esi
  801d30:	53                   	push   %ebx
  801d31:	83 ec 2c             	sub    $0x2c,%esp
  801d34:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801d37:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d3a:	8b 45 08             	mov    0x8(%ebp),%eax
  801d3d:	e8 c3 e9 ff ff       	call   800705 <get_socket>
  if (!sock)
  801d42:	85 c0                	test   %eax,%eax
  801d44:	0f 84 69 01 00 00    	je     801eb3 <lwip_setsockopt+0x188>
  801d4a:	89 c6                	mov    %eax,%esi
  if (NULL == optval) {
  801d4c:	85 ff                	test   %edi,%edi
  801d4e:	74 2c                	je     801d7c <lwip_setsockopt+0x51>
  switch (level) {
  801d50:	83 fb 06             	cmp    $0x6,%ebx
  801d53:	0f 84 01 01 00 00    	je     801e5a <lwip_setsockopt+0x12f>
  801d59:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801d5f:	74 36                	je     801d97 <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801d61:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801d66:	85 db                	test   %ebx,%ebx
  801d68:	74 7b                	je     801de5 <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801d6a:	89 46 10             	mov    %eax,0x10(%esi)
  801d6d:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801d72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d77:	e9 d6 00 00 00       	jmp    801e52 <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801d7c:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801d83:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801d8a:	00 00 00 
    return -1;
  801d8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801d92:	e9 bb 00 00 00       	jmp    801e52 <lwip_setsockopt+0x127>
  801d97:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801d9b:	74 14                	je     801db1 <lwip_setsockopt+0x86>
  801d9d:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801da4:	74 18                	je     801dbe <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801da6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801dab:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801daf:	75 b9                	jne    801d6a <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801db1:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801db5:	77 47                	ja     801dfe <lwip_setsockopt+0xd3>
        err = EINVAL;
  801db7:	b8 16 00 00 00       	mov    $0x16,%eax
  801dbc:	eb ac                	jmp    801d6a <lwip_setsockopt+0x3f>
        err = EINVAL;
  801dbe:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801dc2:	19 c0                	sbb    %eax,%eax
  801dc4:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801dc7:	8b 16                	mov    (%esi),%edx
  801dc9:	83 3a 20             	cmpl   $0x20,(%edx)
  801dcc:	0f 85 af 00 00 00    	jne    801e81 <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801dd2:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801dd5:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801dd9:	0f 85 ac 00 00 00    	jne    801e8b <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801ddf:	85 c0                	test   %eax,%eax
  801de1:	74 1b                	je     801dfe <lwip_setsockopt+0xd3>
  801de3:	eb 85                	jmp    801d6a <lwip_setsockopt+0x3f>
  801de5:	8b 45 10             	mov    0x10(%ebp),%eax
  801de8:	83 e8 01             	sub    $0x1,%eax
  801deb:	83 f8 01             	cmp    $0x1,%eax
  801dee:	0f 87 a1 00 00 00    	ja     801e95 <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  801df4:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801df8:	0f 86 a1 00 00 00    	jbe    801e9f <lwip_setsockopt+0x174>
  data.sock = sock;
  801dfe:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801e01:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801e04:	8b 45 10             	mov    0x10(%ebp),%eax
  801e07:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801e0a:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801e0d:	8d 45 18             	lea    0x18(%ebp),%eax
  801e10:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e13:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801e17:	83 ec 04             	sub    $0x4,%esp
  801e1a:	6a 01                	push   $0x1
  801e1c:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e1f:	50                   	push   %eax
  801e20:	68 d4 0c 80 00       	push   $0x800cd4
  801e25:	e8 40 04 00 00       	call   80226a <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801e2a:	83 c4 08             	add    $0x8,%esp
  801e2d:	6a 00                	push   $0x0
  801e2f:	8b 06                	mov    (%esi),%eax
  801e31:	ff 70 10             	pushl  0x10(%eax)
  801e34:	e8 8a 82 00 00       	call   80a0c3 <sys_arch_sem_wait>
  err = data.err;
  801e39:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801e3d:	89 46 10             	mov    %eax,0x10(%esi)
  801e40:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801e45:	83 c4 10             	add    $0x10,%esp
  801e48:	85 c0                	test   %eax,%eax
  801e4a:	0f 95 c0             	setne  %al
  801e4d:	0f b6 c0             	movzbl %al,%eax
  801e50:	f7 d8                	neg    %eax
}
  801e52:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801e55:	5b                   	pop    %ebx
  801e56:	5e                   	pop    %esi
  801e57:	5f                   	pop    %edi
  801e58:	5d                   	pop    %ebp
  801e59:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801e5a:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e5e:	76 49                	jbe    801ea9 <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  801e60:	8b 10                	mov    (%eax),%edx
      return 0;
  801e62:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801e67:	83 3a 10             	cmpl   $0x10,(%edx)
  801e6a:	75 e6                	jne    801e52 <lwip_setsockopt+0x127>
  801e6c:	8b 45 10             	mov    0x10(%ebp),%eax
  801e6f:	83 e8 01             	sub    $0x1,%eax
  801e72:	83 f8 01             	cmp    $0x1,%eax
  801e75:	76 87                	jbe    801dfe <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801e77:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e7c:	e9 e9 fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
        err = EAFNOSUPPORT;
  801e81:	b8 61 00 00 00       	mov    $0x61,%eax
  801e86:	e9 df fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
  801e8b:	b8 61 00 00 00       	mov    $0x61,%eax
  801e90:	e9 d5 fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801e95:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e9a:	e9 cb fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
        err = EINVAL;
  801e9f:	b8 16 00 00 00       	mov    $0x16,%eax
  801ea4:	e9 c1 fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
      err = EINVAL;
  801ea9:	b8 16 00 00 00       	mov    $0x16,%eax
  801eae:	e9 b7 fe ff ff       	jmp    801d6a <lwip_setsockopt+0x3f>
    return -1;
  801eb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801eb8:	eb 98                	jmp    801e52 <lwip_setsockopt+0x127>

00801eba <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801eba:	55                   	push   %ebp
  801ebb:	89 e5                	mov    %esp,%ebp
  801ebd:	56                   	push   %esi
  801ebe:	53                   	push   %ebx
  801ebf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801ec2:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801ec5:	8b 45 08             	mov    0x8(%ebp),%eax
  801ec8:	e8 38 e8 ff ff       	call   800705 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801ecd:	85 c0                	test   %eax,%eax
  801ecf:	0f 84 b4 00 00 00    	je     801f89 <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  801ed5:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801edb:	74 5d                	je     801f3a <lwip_ioctl+0x80>
  801edd:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801ee3:	0f 85 88 00 00 00    	jne    801f71 <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  801ee9:	85 f6                	test   %esi,%esi
  801eeb:	74 35                	je     801f22 <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801eed:	8b 10                	mov    (%eax),%edx
  801eef:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801ef3:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801ef6:	8b 48 04             	mov    0x4(%eax),%ecx
  801ef9:	85 c9                	test   %ecx,%ecx
  801efb:	74 0d                	je     801f0a <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  801efd:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801eff:	66 2b 50 08          	sub    0x8(%eax),%dx
  801f03:	66 03 51 08          	add    0x8(%ecx),%dx
  801f07:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801f0a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f11:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f18:	00 00 00 
    return 0;
  801f1b:	b8 00 00 00 00       	mov    $0x0,%eax
  801f20:	eb 4b                	jmp    801f6d <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  801f22:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801f29:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801f30:	00 00 00 
      return -1;
  801f33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f38:	eb 33                	jmp    801f6d <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801f3a:	85 f6                	test   %esi,%esi
  801f3c:	74 0e                	je     801f4c <lwip_ioctl+0x92>
  801f3e:	83 3e 00             	cmpl   $0x0,(%esi)
  801f41:	74 09                	je     801f4c <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  801f43:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801f47:	80 ce 08             	or     $0x8,%dh
  801f4a:	eb 07                	jmp    801f53 <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  801f4c:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801f50:	80 e6 f7             	and    $0xf7,%dh
  801f53:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801f57:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801f5e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801f65:	00 00 00 
    return 0;
  801f68:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  801f6d:	5b                   	pop    %ebx
  801f6e:	5e                   	pop    %esi
  801f6f:	5d                   	pop    %ebp
  801f70:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  801f71:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  801f78:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  801f7f:	00 00 00 
    return -1;
  801f82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f87:	eb e4                	jmp    801f6d <lwip_ioctl+0xb3>
    return -1;
  801f89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f8e:	eb dd                	jmp    801f6d <lwip_ioctl+0xb3>

00801f90 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  801f90:	55                   	push   %ebp
  801f91:	89 e5                	mov    %esp,%ebp
  801f93:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  801f96:	e8 1e 41 00 00       	call   8060b9 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801f9b:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  801fa2:	74 19                	je     801fbd <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  801fa4:	83 ec 04             	sub    $0x4,%esp
  801fa7:	6a 00                	push   $0x0
  801fa9:	68 90 1f 80 00       	push   $0x801f90
  801fae:	68 fa 00 00 00       	push   $0xfa
  801fb3:	e8 96 31 00 00       	call   80514e <sys_timeout>
  801fb8:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  801fbb:	c9                   	leave  
  801fbc:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  801fbd:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  801fc4:	75 de                	jne    801fa4 <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  801fc6:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  801fcd:	00 00 00 
}
  801fd0:	eb e9                	jmp    801fbb <tcpip_tcp_timer+0x2b>

00801fd2 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  801fd2:	55                   	push   %ebp
  801fd3:	89 e5                	mov    %esp,%ebp
  801fd5:	53                   	push   %ebx
  801fd6:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  801fd9:	6a 00                	push   $0x0
  801fdb:	68 82 21 80 00       	push   $0x802182
  801fe0:	68 e8 03 00 00       	push   $0x3e8
  801fe5:	e8 64 31 00 00       	call   80514e <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  801fea:	83 c4 0c             	add    $0xc,%esp
  801fed:	6a 00                	push   $0x0
  801fef:	68 5e 21 80 00       	push   $0x80215e
  801ff4:	68 88 13 00 00       	push   $0x1388
  801ff9:	e8 50 31 00 00       	call   80514e <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  801ffe:	83 c4 0c             	add    $0xc,%esp
  802001:	6a 00                	push   $0x0
  802003:	68 3a 21 80 00       	push   $0x80213a
  802008:	68 60 ea 00 00       	push   $0xea60
  80200d:	e8 3c 31 00 00       	call   80514e <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802012:	83 c4 0c             	add    $0xc,%esp
  802015:	6a 00                	push   $0x0
  802017:	68 16 21 80 00       	push   $0x802116
  80201c:	68 f4 01 00 00       	push   $0x1f4
  802021:	e8 28 31 00 00       	call   80514e <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  802026:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  80202b:	83 c4 10             	add    $0x10,%esp
  80202e:	85 c0                	test   %eax,%eax
  802030:	74 0e                	je     802040 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  802032:	83 ec 0c             	sub    $0xc,%esp
  802035:	ff 35 e4 52 81 00    	pushl  0x8152e4
  80203b:	ff d0                	call   *%eax
  80203d:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802040:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802043:	eb 0f                	jmp    802054 <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802045:	8b 42 08             	mov    0x8(%edx),%eax
  802048:	83 ec 0c             	sub    $0xc,%esp
  80204b:	8d 50 04             	lea    0x4(%eax),%edx
  80204e:	52                   	push   %edx
  80204f:	ff 10                	call   *(%eax)
      break;
  802051:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802054:	83 ec 08             	sub    $0x8,%esp
  802057:	53                   	push   %ebx
  802058:	ff 35 00 40 81 00    	pushl  0x814000
  80205e:	e8 cb 2f 00 00       	call   80502e <sys_mbox_fetch>
    switch (msg->type) {
  802063:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802066:	8b 02                	mov    (%edx),%eax
  802068:	83 c4 10             	add    $0x10,%esp
  80206b:	83 f8 01             	cmp    $0x1,%eax
  80206e:	74 3a                	je     8020aa <tcpip_thread+0xd8>
  802070:	85 c0                	test   %eax,%eax
  802072:	74 d1                	je     802045 <tcpip_thread+0x73>
  802074:	83 f8 02             	cmp    $0x2,%eax
  802077:	74 6c                	je     8020e5 <tcpip_thread+0x113>
  802079:	83 f8 03             	cmp    $0x3,%eax
  80207c:	75 d6                	jne    802054 <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80207e:	8b 42 08             	mov    0x8(%edx),%eax
  802081:	83 f8 ff             	cmp    $0xffffffff,%eax
  802084:	74 7d                	je     802103 <tcpip_thread+0x131>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802086:	83 ec 04             	sub    $0x4,%esp
  802089:	ff 72 10             	pushl  0x10(%edx)
  80208c:	ff 72 0c             	pushl  0xc(%edx)
  80208f:	50                   	push   %eax
  802090:	e8 b9 30 00 00       	call   80514e <sys_timeout>
  802095:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802098:	83 ec 08             	sub    $0x8,%esp
  80209b:	ff 75 f4             	pushl  -0xc(%ebp)
  80209e:	6a 08                	push   $0x8
  8020a0:	e8 f1 23 00 00       	call   804496 <memp_free>
      break;
  8020a5:	83 c4 10             	add    $0x10,%esp
  8020a8:	eb aa                	jmp    802054 <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8020aa:	8b 42 0c             	mov    0xc(%edx),%eax
  8020ad:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8020b1:	74 21                	je     8020d4 <tcpip_thread+0x102>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020b3:	83 ec 08             	sub    $0x8,%esp
  8020b6:	50                   	push   %eax
  8020b7:	ff 72 08             	pushl  0x8(%edx)
  8020ba:	e8 2d 7b 00 00       	call   809bec <ethernet_input>
  8020bf:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8020c2:	83 ec 08             	sub    $0x8,%esp
  8020c5:	ff 75 f4             	pushl  -0xc(%ebp)
  8020c8:	6a 09                	push   $0x9
  8020ca:	e8 c7 23 00 00       	call   804496 <memp_free>
      break;
  8020cf:	83 c4 10             	add    $0x10,%esp
  8020d2:	eb 80                	jmp    802054 <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8020d4:	83 ec 08             	sub    $0x8,%esp
  8020d7:	50                   	push   %eax
  8020d8:	ff 72 08             	pushl  0x8(%edx)
  8020db:	e8 1a 44 00 00       	call   8064fa <ip_input>
  8020e0:	83 c4 10             	add    $0x10,%esp
  8020e3:	eb dd                	jmp    8020c2 <tcpip_thread+0xf0>
      msg->msg.cb.f(msg->msg.cb.ctx);
  8020e5:	83 ec 0c             	sub    $0xc,%esp
  8020e8:	ff 72 0c             	pushl  0xc(%edx)
  8020eb:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8020ee:	83 c4 08             	add    $0x8,%esp
  8020f1:	ff 75 f4             	pushl  -0xc(%ebp)
  8020f4:	6a 08                	push   $0x8
  8020f6:	e8 9b 23 00 00       	call   804496 <memp_free>
      break;
  8020fb:	83 c4 10             	add    $0x10,%esp
  8020fe:	e9 51 ff ff ff       	jmp    802054 <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802103:	83 ec 08             	sub    $0x8,%esp
  802106:	ff 72 10             	pushl  0x10(%edx)
  802109:	ff 72 0c             	pushl  0xc(%edx)
  80210c:	e8 00 31 00 00       	call   805211 <sys_untimeout>
  802111:	83 c4 10             	add    $0x10,%esp
  802114:	eb 82                	jmp    802098 <tcpip_thread+0xc6>

00802116 <dhcp_timer_fine>:
{
  802116:	55                   	push   %ebp
  802117:	89 e5                	mov    %esp,%ebp
  802119:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  80211c:	e8 45 1b 00 00       	call   803c66 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802121:	83 ec 04             	sub    $0x4,%esp
  802124:	6a 00                	push   $0x0
  802126:	68 16 21 80 00       	push   $0x802116
  80212b:	68 f4 01 00 00       	push   $0x1f4
  802130:	e8 19 30 00 00       	call   80514e <sys_timeout>
}
  802135:	83 c4 10             	add    $0x10,%esp
  802138:	c9                   	leave  
  802139:	c3                   	ret    

0080213a <dhcp_timer_coarse>:
{
  80213a:	55                   	push   %ebp
  80213b:	89 e5                	mov    %esp,%ebp
  80213d:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  802140:	e8 55 19 00 00       	call   803a9a <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802145:	83 ec 04             	sub    $0x4,%esp
  802148:	6a 00                	push   $0x0
  80214a:	68 3a 21 80 00       	push   $0x80213a
  80214f:	68 60 ea 00 00       	push   $0xea60
  802154:	e8 f5 2f 00 00       	call   80514e <sys_timeout>
}
  802159:	83 c4 10             	add    $0x10,%esp
  80215c:	c9                   	leave  
  80215d:	c3                   	ret    

0080215e <arp_timer>:
{
  80215e:	55                   	push   %ebp
  80215f:	89 e5                	mov    %esp,%ebp
  802161:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  802164:	e8 53 73 00 00       	call   8094bc <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802169:	83 ec 04             	sub    $0x4,%esp
  80216c:	6a 00                	push   $0x0
  80216e:	68 5e 21 80 00       	push   $0x80215e
  802173:	68 88 13 00 00       	push   $0x1388
  802178:	e8 d1 2f 00 00       	call   80514e <sys_timeout>
}
  80217d:	83 c4 10             	add    $0x10,%esp
  802180:	c9                   	leave  
  802181:	c3                   	ret    

00802182 <ip_reass_timer>:
{
  802182:	55                   	push   %ebp
  802183:	89 e5                	mov    %esp,%ebp
  802185:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802188:	e8 68 4a 00 00       	call   806bf5 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80218d:	83 ec 04             	sub    $0x4,%esp
  802190:	6a 00                	push   $0x0
  802192:	68 82 21 80 00       	push   $0x802182
  802197:	68 e8 03 00 00       	push   $0x3e8
  80219c:	e8 ad 2f 00 00       	call   80514e <sys_timeout>
}
  8021a1:	83 c4 10             	add    $0x10,%esp
  8021a4:	c9                   	leave  
  8021a5:	c3                   	ret    

008021a6 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8021a6:	55                   	push   %ebp
  8021a7:	89 e5                	mov    %esp,%ebp
  8021a9:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8021ac:	ff 75 08             	pushl  0x8(%ebp)
  8021af:	e8 2f 26 00 00       	call   8047e3 <pbuf_free>
}
  8021b4:	83 c4 10             	add    $0x10,%esp
  8021b7:	c9                   	leave  
  8021b8:	c3                   	ret    

008021b9 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021b9:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  8021c0:	75 38                	jne    8021fa <tcp_timer_needed+0x41>
  8021c2:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  8021c9:	74 26                	je     8021f1 <tcp_timer_needed+0x38>
{
  8021cb:	55                   	push   %ebp
  8021cc:	89 e5                	mov    %esp,%ebp
  8021ce:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  8021d1:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  8021d8:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8021db:	6a 00                	push   $0x0
  8021dd:	68 90 1f 80 00       	push   $0x801f90
  8021e2:	68 fa 00 00 00       	push   $0xfa
  8021e7:	e8 62 2f 00 00       	call   80514e <sys_timeout>
  8021ec:	83 c4 10             	add    $0x10,%esp
}
  8021ef:	c9                   	leave  
  8021f0:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8021f1:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  8021f8:	75 d1                	jne    8021cb <tcp_timer_needed+0x12>
  8021fa:	c3                   	ret    

008021fb <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  8021fb:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802202:	74 59                	je     80225d <tcpip_input+0x62>
{
  802204:	55                   	push   %ebp
  802205:	89 e5                	mov    %esp,%ebp
  802207:	53                   	push   %ebx
  802208:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80220b:	6a 09                	push   $0x9
  80220d:	e8 2e 22 00 00       	call   804440 <memp_malloc>
  802212:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802214:	83 c4 10             	add    $0x10,%esp
  802217:	85 c0                	test   %eax,%eax
  802219:	74 48                	je     802263 <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  80221b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802221:	8b 45 08             	mov    0x8(%ebp),%eax
  802224:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802227:	8b 45 0c             	mov    0xc(%ebp),%eax
  80222a:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80222d:	83 ec 08             	sub    $0x8,%esp
  802230:	53                   	push   %ebx
  802231:	ff 35 00 40 81 00    	pushl  0x814000
  802237:	e8 97 7f 00 00       	call   80a1d3 <sys_mbox_trypost>
  80223c:	83 c4 10             	add    $0x10,%esp
  80223f:	84 c0                	test   %al,%al
  802241:	75 05                	jne    802248 <tcpip_input+0x4d>
}
  802243:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802246:	c9                   	leave  
  802247:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802248:	83 ec 08             	sub    $0x8,%esp
  80224b:	53                   	push   %ebx
  80224c:	6a 09                	push   $0x9
  80224e:	e8 43 22 00 00       	call   804496 <memp_free>
      return ERR_MEM;
  802253:	83 c4 10             	add    $0x10,%esp
  802256:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80225b:	eb e6                	jmp    802243 <tcpip_input+0x48>
  return ERR_VAL;
  80225d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802262:	c3                   	ret    
      return ERR_MEM;
  802263:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802268:	eb d9                	jmp    802243 <tcpip_input+0x48>

0080226a <tcpip_callback_with_block>:
{
  80226a:	55                   	push   %ebp
  80226b:	89 e5                	mov    %esp,%ebp
  80226d:	56                   	push   %esi
  80226e:	53                   	push   %ebx
  80226f:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802272:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802279:	74 76                	je     8022f1 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80227b:	83 ec 0c             	sub    $0xc,%esp
  80227e:	6a 08                	push   $0x8
  802280:	e8 bb 21 00 00       	call   804440 <memp_malloc>
  802285:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802287:	83 c4 10             	add    $0x10,%esp
  80228a:	85 c0                	test   %eax,%eax
  80228c:	74 6a                	je     8022f8 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  80228e:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  802294:	8b 45 08             	mov    0x8(%ebp),%eax
  802297:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  80229a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80229d:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  8022a0:	89 f0                	mov    %esi,%eax
  8022a2:	84 c0                	test   %al,%al
  8022a4:	75 1d                	jne    8022c3 <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022a6:	83 ec 08             	sub    $0x8,%esp
  8022a9:	53                   	push   %ebx
  8022aa:	ff 35 00 40 81 00    	pushl  0x814000
  8022b0:	e8 1e 7f 00 00       	call   80a1d3 <sys_mbox_trypost>
  8022b5:	83 c4 10             	add    $0x10,%esp
  8022b8:	84 c0                	test   %al,%al
  8022ba:	75 20                	jne    8022dc <tcpip_callback_with_block+0x72>
}
  8022bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8022bf:	5b                   	pop    %ebx
  8022c0:	5e                   	pop    %esi
  8022c1:	5d                   	pop    %ebp
  8022c2:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  8022c3:	83 ec 08             	sub    $0x8,%esp
  8022c6:	53                   	push   %ebx
  8022c7:	ff 35 00 40 81 00    	pushl  0x814000
  8022cd:	e8 c6 7f 00 00       	call   80a298 <sys_mbox_post>
  8022d2:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  8022d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8022da:	eb e0                	jmp    8022bc <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8022dc:	83 ec 08             	sub    $0x8,%esp
  8022df:	53                   	push   %ebx
  8022e0:	6a 08                	push   $0x8
  8022e2:	e8 af 21 00 00       	call   804496 <memp_free>
        return ERR_MEM;
  8022e7:	83 c4 10             	add    $0x10,%esp
  8022ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022ef:	eb cb                	jmp    8022bc <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  8022f1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8022f6:	eb c4                	jmp    8022bc <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  8022f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8022fd:	eb bd                	jmp    8022bc <tcpip_callback_with_block+0x52>

008022ff <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  8022ff:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802306:	74 45                	je     80234d <tcpip_timeout+0x4e>
{
  802308:	55                   	push   %ebp
  802309:	89 e5                	mov    %esp,%ebp
  80230b:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80230e:	6a 08                	push   $0x8
  802310:	e8 2b 21 00 00       	call   804440 <memp_malloc>
    if (msg == NULL) {
  802315:	83 c4 10             	add    $0x10,%esp
  802318:	85 c0                	test   %eax,%eax
  80231a:	74 37                	je     802353 <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  80231c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802322:	8b 55 08             	mov    0x8(%ebp),%edx
  802325:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802328:	8b 55 0c             	mov    0xc(%ebp),%edx
  80232b:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  80232e:	8b 55 10             	mov    0x10(%ebp),%edx
  802331:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802334:	83 ec 08             	sub    $0x8,%esp
  802337:	50                   	push   %eax
  802338:	ff 35 00 40 81 00    	pushl  0x814000
  80233e:	e8 55 7f 00 00       	call   80a298 <sys_mbox_post>
    return ERR_OK;
  802343:	83 c4 10             	add    $0x10,%esp
  802346:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80234b:	c9                   	leave  
  80234c:	c3                   	ret    
  return ERR_VAL;
  80234d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802352:	c3                   	ret    
      return ERR_MEM;
  802353:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802358:	eb f1                	jmp    80234b <tcpip_timeout+0x4c>

0080235a <tcpip_apimsg>:
{
  80235a:	55                   	push   %ebp
  80235b:	89 e5                	mov    %esp,%ebp
  80235d:	53                   	push   %ebx
  80235e:	83 ec 24             	sub    $0x24,%esp
  802361:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802364:	a1 00 40 81 00       	mov    0x814000,%eax
  802369:	83 f8 ff             	cmp    $0xffffffff,%eax
  80236c:	74 34                	je     8023a2 <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  80236e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802375:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802378:	83 ec 08             	sub    $0x8,%esp
  80237b:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80237e:	52                   	push   %edx
  80237f:	50                   	push   %eax
  802380:	e8 13 7f 00 00       	call   80a298 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802385:	83 c4 08             	add    $0x8,%esp
  802388:	6a 00                	push   $0x0
  80238a:	8b 43 04             	mov    0x4(%ebx),%eax
  80238d:	ff 70 10             	pushl  0x10(%eax)
  802390:	e8 2e 7d 00 00       	call   80a0c3 <sys_arch_sem_wait>
    return ERR_OK;
  802395:	83 c4 10             	add    $0x10,%esp
  802398:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80239d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8023a0:	c9                   	leave  
  8023a1:	c3                   	ret    
  return ERR_VAL;
  8023a2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8023a7:	eb f4                	jmp    80239d <tcpip_apimsg+0x43>

008023a9 <tcpip_init>:
{
  8023a9:	55                   	push   %ebp
  8023aa:	89 e5                	mov    %esp,%ebp
  8023ac:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  8023af:	e8 6a 03 00 00       	call   80271e <lwip_init>
  tcpip_init_done = initfunc;
  8023b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8023b7:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  8023bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023bf:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8023c4:	83 ec 0c             	sub    $0xc,%esp
  8023c7:	6a 00                	push   $0x0
  8023c9:	e8 71 7b 00 00       	call   809f3f <sys_mbox_new>
  8023ce:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8023d3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8023da:	6a 00                	push   $0x0
  8023dc:	6a 00                	push   $0x0
  8023de:	68 d2 1f 80 00       	push   $0x801fd2
  8023e3:	68 7c 15 81 00       	push   $0x81157c
  8023e8:	e8 de 7f 00 00       	call   80a3cb <sys_thread_new>
}
  8023ed:	83 c4 20             	add    $0x20,%esp
  8023f0:	c9                   	leave  
  8023f1:	c3                   	ret    

008023f2 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8023f2:	55                   	push   %ebp
  8023f3:	89 e5                	mov    %esp,%ebp
  8023f5:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8023f8:	6a 00                	push   $0x0
  8023fa:	ff 75 08             	pushl  0x8(%ebp)
  8023fd:	68 a6 21 80 00       	push   $0x8021a6
  802402:	e8 63 fe ff ff       	call   80226a <tcpip_callback_with_block>
}
  802407:	c9                   	leave  
  802408:	c3                   	ret    

00802409 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  802409:	55                   	push   %ebp
  80240a:	89 e5                	mov    %esp,%ebp
  80240c:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  80240f:	6a 00                	push   $0x0
  802411:	ff 75 08             	pushl  0x8(%ebp)
  802414:	68 fd 3e 80 00       	push   $0x803efd
  802419:	e8 4c fe ff ff       	call   80226a <tcpip_callback_with_block>
}
  80241e:	c9                   	leave  
  80241f:	c3                   	ret    

00802420 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802420:	55                   	push   %ebp
  802421:	89 e5                	mov    %esp,%ebp
  802423:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802426:	6a 06                	push   $0x6
  802428:	e8 13 20 00 00       	call   804440 <memp_malloc>
  if (buf != NULL) {
  80242d:	83 c4 10             	add    $0x10,%esp
  802430:	85 c0                	test   %eax,%eax
  802432:	74 14                	je     802448 <netbuf_new+0x28>
    buf->p = NULL;
  802434:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80243a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802441:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802448:	c9                   	leave  
  802449:	c3                   	ret    

0080244a <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80244a:	55                   	push   %ebp
  80244b:	89 e5                	mov    %esp,%ebp
  80244d:	53                   	push   %ebx
  80244e:	83 ec 04             	sub    $0x4,%esp
  802451:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802454:	85 db                	test   %ebx,%ebx
  802456:	74 2d                	je     802485 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802458:	8b 03                	mov    (%ebx),%eax
  80245a:	85 c0                	test   %eax,%eax
  80245c:	74 19                	je     802477 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  80245e:	83 ec 0c             	sub    $0xc,%esp
  802461:	50                   	push   %eax
  802462:	e8 7c 23 00 00       	call   8047e3 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802467:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80246e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802474:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802477:	83 ec 08             	sub    $0x8,%esp
  80247a:	53                   	push   %ebx
  80247b:	6a 06                	push   $0x6
  80247d:	e8 14 20 00 00       	call   804496 <memp_free>
  802482:	83 c4 10             	add    $0x10,%esp
  }
}
  802485:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802488:	c9                   	leave  
  802489:	c3                   	ret    

0080248a <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80248a:	55                   	push   %ebp
  80248b:	89 e5                	mov    %esp,%ebp
  80248d:	56                   	push   %esi
  80248e:	53                   	push   %ebx
  80248f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802492:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  802495:	85 db                	test   %ebx,%ebx
  802497:	74 3e                	je     8024d7 <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802499:	8b 03                	mov    (%ebx),%eax
  80249b:	85 c0                	test   %eax,%eax
  80249d:	74 0c                	je     8024ab <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  80249f:	83 ec 0c             	sub    $0xc,%esp
  8024a2:	50                   	push   %eax
  8024a3:	e8 3b 23 00 00       	call   8047e3 <pbuf_free>
  8024a8:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8024ab:	83 ec 04             	sub    $0x4,%esp
  8024ae:	6a 00                	push   $0x0
  8024b0:	0f b7 c6             	movzwl %si,%eax
  8024b3:	50                   	push   %eax
  8024b4:	6a 00                	push   $0x0
  8024b6:	e8 ee 23 00 00       	call   8048a9 <pbuf_alloc>
  8024bb:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8024bd:	83 c4 10             	add    $0x10,%esp
  8024c0:	85 c0                	test   %eax,%eax
  8024c2:	74 0c                	je     8024d0 <netbuf_alloc+0x46>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8024c4:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8024c8:	72 21                	jb     8024eb <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8024ca:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8024cd:	8b 40 04             	mov    0x4(%eax),%eax
}
  8024d0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024d3:	5b                   	pop    %ebx
  8024d4:	5e                   	pop    %esi
  8024d5:	5d                   	pop    %ebp
  8024d6:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8024d7:	83 ec 04             	sub    $0x4,%esp
  8024da:	68 89 15 81 00       	push   $0x811589
  8024df:	6a 63                	push   $0x63
  8024e1:	68 a3 15 81 00       	push   $0x8115a3
  8024e6:	e8 bd c0 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8024eb:	83 ec 04             	sub    $0x4,%esp
  8024ee:	68 70 16 81 00       	push   $0x811670
  8024f3:	6a 6e                	push   $0x6e
  8024f5:	68 a3 15 81 00       	push   $0x8115a3
  8024fa:	e8 a9 c0 00 00       	call   80e5a8 <_panic>

008024ff <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8024ff:	55                   	push   %ebp
  802500:	89 e5                	mov    %esp,%ebp
  802502:	53                   	push   %ebx
  802503:	83 ec 04             	sub    $0x4,%esp
  802506:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802509:	85 db                	test   %ebx,%ebx
  80250b:	74 24                	je     802531 <netbuf_free+0x32>
  if (buf->p != NULL) {
  80250d:	8b 03                	mov    (%ebx),%eax
  80250f:	85 c0                	test   %eax,%eax
  802511:	74 0c                	je     80251f <netbuf_free+0x20>
    pbuf_free(buf->p);
  802513:	83 ec 0c             	sub    $0xc,%esp
  802516:	50                   	push   %eax
  802517:	e8 c7 22 00 00       	call   8047e3 <pbuf_free>
  80251c:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  80251f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802526:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  80252c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80252f:	c9                   	leave  
  802530:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802531:	83 ec 04             	sub    $0x4,%esp
  802534:	68 b9 15 81 00       	push   $0x8115b9
  802539:	6a 7b                	push   $0x7b
  80253b:	68 a3 15 81 00       	push   $0x8115a3
  802540:	e8 63 c0 00 00       	call   80e5a8 <_panic>

00802545 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802545:	55                   	push   %ebp
  802546:	89 e5                	mov    %esp,%ebp
  802548:	56                   	push   %esi
  802549:	53                   	push   %ebx
  80254a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80254d:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802550:	85 db                	test   %ebx,%ebx
  802552:	74 4c                	je     8025a0 <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  802554:	8b 03                	mov    (%ebx),%eax
  802556:	85 c0                	test   %eax,%eax
  802558:	74 0c                	je     802566 <netbuf_ref+0x21>
    pbuf_free(buf->p);
  80255a:	83 ec 0c             	sub    $0xc,%esp
  80255d:	50                   	push   %eax
  80255e:	e8 80 22 00 00       	call   8047e3 <pbuf_free>
  802563:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802566:	83 ec 04             	sub    $0x4,%esp
  802569:	6a 02                	push   $0x2
  80256b:	6a 00                	push   $0x0
  80256d:	6a 00                	push   $0x0
  80256f:	e8 35 23 00 00       	call   8048a9 <pbuf_alloc>
  802574:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802576:	83 c4 10             	add    $0x10,%esp
  802579:	85 c0                	test   %eax,%eax
  80257b:	74 3a                	je     8025b7 <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80257d:	8b 55 0c             	mov    0xc(%ebp),%edx
  802580:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802583:	8b 03                	mov    (%ebx),%eax
  802585:	66 89 70 08          	mov    %si,0x8(%eax)
  802589:	8b 03                	mov    (%ebx),%eax
  80258b:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80258f:	8b 03                	mov    (%ebx),%eax
  802591:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802594:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802599:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80259c:	5b                   	pop    %ebx
  80259d:	5e                   	pop    %esi
  80259e:	5d                   	pop    %ebp
  80259f:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8025a0:	83 ec 04             	sub    $0x4,%esp
  8025a3:	68 d2 15 81 00       	push   $0x8115d2
  8025a8:	68 8e 00 00 00       	push   $0x8e
  8025ad:	68 a3 15 81 00       	push   $0x8115a3
  8025b2:	e8 f1 bf 00 00       	call   80e5a8 <_panic>
    buf->ptr = NULL;
  8025b7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8025be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8025c3:	eb d4                	jmp    802599 <netbuf_ref+0x54>

008025c5 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8025c5:	55                   	push   %ebp
  8025c6:	89 e5                	mov    %esp,%ebp
  8025c8:	56                   	push   %esi
  8025c9:	53                   	push   %ebx
  8025ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025cd:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025d0:	85 db                	test   %ebx,%ebx
  8025d2:	74 2a                	je     8025fe <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8025d4:	85 f6                	test   %esi,%esi
  8025d6:	74 3d                	je     802615 <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  8025d8:	83 ec 08             	sub    $0x8,%esp
  8025db:	ff 36                	pushl  (%esi)
  8025dd:	ff 33                	pushl  (%ebx)
  8025df:	e8 e0 26 00 00       	call   804cc4 <pbuf_chain>
  head->ptr = head->p;
  8025e4:	8b 03                	mov    (%ebx),%eax
  8025e6:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8025e9:	83 c4 08             	add    $0x8,%esp
  8025ec:	56                   	push   %esi
  8025ed:	6a 06                	push   $0x6
  8025ef:	e8 a2 1e 00 00       	call   804496 <memp_free>
  8025f4:	83 c4 10             	add    $0x10,%esp
}
  8025f7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8025fa:	5b                   	pop    %ebx
  8025fb:	5e                   	pop    %esi
  8025fc:	5d                   	pop    %ebp
  8025fd:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8025fe:	83 ec 04             	sub    $0x4,%esp
  802601:	68 ea 15 81 00       	push   $0x8115ea
  802606:	68 a6 00 00 00       	push   $0xa6
  80260b:	68 a3 15 81 00       	push   $0x8115a3
  802610:	e8 93 bf 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802615:	83 ec 04             	sub    $0x4,%esp
  802618:	68 03 16 81 00       	push   $0x811603
  80261d:	68 a7 00 00 00       	push   $0xa7
  802622:	68 a3 15 81 00       	push   $0x8115a3
  802627:	e8 7c bf 00 00       	call   80e5a8 <_panic>

0080262c <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80262c:	55                   	push   %ebp
  80262d:	89 e5                	mov    %esp,%ebp
  80262f:	53                   	push   %ebx
  802630:	83 ec 04             	sub    $0x4,%esp
  802633:	8b 45 08             	mov    0x8(%ebp),%eax
  802636:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802639:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80263c:	85 c0                	test   %eax,%eax
  80263e:	74 28                	je     802668 <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802640:	85 c9                	test   %ecx,%ecx
  802642:	74 3b                	je     80267f <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802644:	85 d2                	test   %edx,%edx
  802646:	74 4e                	je     802696 <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  802648:	8b 58 04             	mov    0x4(%eax),%ebx
  80264b:	85 db                	test   %ebx,%ebx
  80264d:	74 5e                	je     8026ad <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  80264f:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802652:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802654:	8b 40 04             	mov    0x4(%eax),%eax
  802657:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80265b:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  80265e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802663:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802666:	c9                   	leave  
  802667:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802668:	83 ec 04             	sub    $0x4,%esp
  80266b:	68 1e 16 81 00       	push   $0x81161e
  802670:	68 b9 00 00 00       	push   $0xb9
  802675:	68 a3 15 81 00       	push   $0x8115a3
  80267a:	e8 29 bf 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80267f:	83 ec 04             	sub    $0x4,%esp
  802682:	68 37 16 81 00       	push   $0x811637
  802687:	68 ba 00 00 00       	push   $0xba
  80268c:	68 a3 15 81 00       	push   $0x8115a3
  802691:	e8 12 bf 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802696:	83 ec 04             	sub    $0x4,%esp
  802699:	68 54 16 81 00       	push   $0x811654
  80269e:	68 bb 00 00 00       	push   $0xbb
  8026a3:	68 a3 15 81 00       	push   $0x8115a3
  8026a8:	e8 fb be 00 00       	call   80e5a8 <_panic>
    return ERR_BUF;
  8026ad:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8026b2:	eb af                	jmp    802663 <netbuf_data+0x37>

008026b4 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8026b4:	55                   	push   %ebp
  8026b5:	89 e5                	mov    %esp,%ebp
  8026b7:	83 ec 08             	sub    $0x8,%esp
  8026ba:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026bd:	85 c0                	test   %eax,%eax
  8026bf:	74 14                	je     8026d5 <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  8026c1:	8b 50 04             	mov    0x4(%eax),%edx
  8026c4:	8b 12                	mov    (%edx),%edx
  8026c6:	85 d2                	test   %edx,%edx
  8026c8:	74 22                	je     8026ec <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8026ca:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8026cd:	83 3a 00             	cmpl   $0x0,(%edx)
  8026d0:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8026d3:	c9                   	leave  
  8026d4:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8026d5:	83 ec 04             	sub    $0x4,%esp
  8026d8:	68 b9 15 81 00       	push   $0x8115b9
  8026dd:	68 d2 00 00 00       	push   $0xd2
  8026e2:	68 a3 15 81 00       	push   $0x8115a3
  8026e7:	e8 bc be 00 00       	call   80e5a8 <_panic>
    return -1;
  8026ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026f1:	eb e0                	jmp    8026d3 <netbuf_next+0x1f>

008026f3 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8026f3:	55                   	push   %ebp
  8026f4:	89 e5                	mov    %esp,%ebp
  8026f6:	83 ec 08             	sub    $0x8,%esp
  8026f9:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8026fc:	85 c0                	test   %eax,%eax
  8026fe:	74 07                	je     802707 <netbuf_first+0x14>
  buf->ptr = buf->p;
  802700:	8b 10                	mov    (%eax),%edx
  802702:	89 50 04             	mov    %edx,0x4(%eax)
}
  802705:	c9                   	leave  
  802706:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802707:	83 ec 04             	sub    $0x4,%esp
  80270a:	68 b9 15 81 00       	push   $0x8115b9
  80270f:	68 e7 00 00 00       	push   $0xe7
  802714:	68 a3 15 81 00       	push   $0x8115a3
  802719:	e8 8a be 00 00       	call   80e5a8 <_panic>

0080271e <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  80271e:	55                   	push   %ebp
  80271f:	89 e5                	mov    %esp,%ebp
  802721:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802724:	e8 d0 75 00 00       	call   809cf9 <sys_init>
  mem_init();
  802729:	e8 69 17 00 00       	call   803e97 <mem_init>
  memp_init();
  80272e:	e8 b1 1c 00 00       	call   8043e4 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802733:	e8 a9 e6 ff ff       	call   800de1 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802738:	c9                   	leave  
  802739:	c3                   	ret    

0080273a <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  80273a:	38 10                	cmp    %dl,(%eax)
  80273c:	74 06                	je     802744 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  80273e:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802740:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802744:	c3                   	ret    

00802745 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802745:	55                   	push   %ebp
  802746:	89 e5                	mov    %esp,%ebp
  802748:	57                   	push   %edi
  802749:	56                   	push   %esi
  80274a:	53                   	push   %ebx
  80274b:	83 ec 0c             	sub    $0xc,%esp
  80274e:	89 c7                	mov    %eax,%edi
  802750:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802753:	8b 40 14             	mov    0x14(%eax),%eax
  802756:	85 c0                	test   %eax,%eax
  802758:	74 19                	je     802773 <dhcp_get_option_ptr+0x2e>
  80275a:	89 d6                	mov    %edx,%esi
  80275c:	0f b7 7f 18          	movzwl 0x18(%edi),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802760:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  802765:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802769:	66 85 ff             	test   %di,%di
  80276c:	75 2d                	jne    80279b <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80276e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802773:	83 c4 0c             	add    $0xc,%esp
  802776:	5b                   	pop    %ebx
  802777:	5e                   	pop    %esi
  802778:	5f                   	pop    %edi
  802779:	5d                   	pop    %ebp
  80277a:	c3                   	ret    
        offset += 2;
  80277b:	8d 51 02             	lea    0x2(%ecx),%edx
        overload = options[offset++];
  80277e:	83 c1 03             	add    $0x3,%ecx
  802781:	0f b7 d2             	movzwl %dx,%edx
  802784:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
  802788:	88 5d ef             	mov    %bl,-0x11(%ebp)
  80278b:	eb 0e                	jmp    80279b <dhcp_get_option_ptr+0x56>
        offset++;
  80278d:	8d 51 01             	lea    0x1(%ecx),%edx
        offset += 1 + options[offset];
  802790:	0f b7 d2             	movzwl %dx,%edx
  802793:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  802797:	8d 4c 0a 02          	lea    0x2(%edx,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80279b:	66 39 cf             	cmp    %cx,%di
  80279e:	76 22                	jbe    8027c2 <dhcp_get_option_ptr+0x7d>
  8027a0:	0f b7 d9             	movzwl %cx,%ebx
  8027a3:	01 c3                	add    %eax,%ebx
  8027a5:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  8027a8:	0f b6 13             	movzbl (%ebx),%edx
  8027ab:	80 fa ff             	cmp    $0xff,%dl
  8027ae:	74 12                	je     8027c2 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8027b0:	80 fa 34             	cmp    $0x34,%dl
  8027b3:	74 c6                	je     80277b <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  8027b5:	89 f3                	mov    %esi,%ebx
  8027b7:	38 da                	cmp    %bl,%dl
  8027b9:	75 d2                	jne    80278d <dhcp_get_option_ptr+0x48>
  8027bb:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8027be:	89 d8                	mov    %ebx,%eax
  8027c0:	eb b1                	jmp    802773 <dhcp_get_option_ptr+0x2e>
  return NULL;
  8027c2:	b8 00 00 00 00       	mov    $0x0,%eax
    if (overload != DHCP_OVERLOAD_NONE) {
  8027c7:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  8027cb:	84 c9                	test   %cl,%cl
  8027cd:	74 a4                	je     802773 <dhcp_get_option_ptr+0x2e>
      if (overload == DHCP_OVERLOAD_FILE) {
  8027cf:	80 f9 01             	cmp    $0x1,%cl
  8027d2:	74 55                	je     802829 <dhcp_get_option_ptr+0xe4>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8027d4:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8027d8:	74 5f                	je     802839 <dhcp_get_option_ptr+0xf4>
        options = (u8_t *)&dhcp->msg_in->sname;
  8027da:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8027dd:	8b 48 10             	mov    0x10(%eax),%ecx
  8027e0:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8027e3:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  8027e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8027ed:	89 f0                	mov    %esi,%eax
  8027ef:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8027f2:	0f b7 c2             	movzwl %dx,%eax
  8027f5:	01 c8                	add    %ecx,%eax
  8027f7:	0f b6 30             	movzbl (%eax),%esi
  8027fa:	89 f3                	mov    %esi,%ebx
  8027fc:	80 fb ff             	cmp    $0xff,%bl
  8027ff:	74 48                	je     802849 <dhcp_get_option_ptr+0x104>
        if (options[offset] == option_type) {
  802801:	89 f3                	mov    %esi,%ebx
  802803:	3a 5d f0             	cmp    -0x10(%ebp),%bl
  802806:	0f 84 67 ff ff ff    	je     802773 <dhcp_get_option_ptr+0x2e>
          offset++;
  80280c:	8d 42 01             	lea    0x1(%edx),%eax
          offset += 1 + options[offset];
  80280f:	0f b7 c0             	movzwl %ax,%eax
  802812:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  802816:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80281a:	66 39 d7             	cmp    %dx,%di
  80281d:	77 d3                	ja     8027f2 <dhcp_get_option_ptr+0xad>
  return NULL;
  80281f:	b8 00 00 00 00       	mov    $0x0,%eax
  802824:	e9 4a ff ff ff       	jmp    802773 <dhcp_get_option_ptr+0x2e>
        options = (u8_t *)&dhcp->msg_in->file;
  802829:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80282c:	8b 48 10             	mov    0x10(%eax),%ecx
  80282f:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  802832:	bf 80 00 00 00       	mov    $0x80,%edi
  802837:	eb af                	jmp    8027e8 <dhcp_get_option_ptr+0xa3>
        options = (u8_t *)&dhcp->msg_in->sname;
  802839:	8b 45 e8             	mov    -0x18(%ebp),%eax
  80283c:	8b 48 10             	mov    0x10(%eax),%ecx
  80283f:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  802842:	bf 40 00 00 00       	mov    $0x40,%edi
  802847:	eb 9f                	jmp    8027e8 <dhcp_get_option_ptr+0xa3>
  return NULL;
  802849:	b8 00 00 00 00       	mov    $0x0,%eax
  80284e:	e9 20 ff ff ff       	jmp    802773 <dhcp_get_option_ptr+0x2e>

00802853 <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802853:	0f b6 10             	movzbl (%eax),%edx
  802856:	89 d1                	mov    %edx,%ecx
  802858:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  80285b:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80285f:	c1 e2 10             	shl    $0x10,%edx
  802862:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802864:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802868:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  80286a:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  80286e:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  802871:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802873:	c3                   	ret    

00802874 <dhcp_option_byte>:
{
  802874:	55                   	push   %ebp
  802875:	89 e5                	mov    %esp,%ebp
  802877:	56                   	push   %esi
  802878:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802879:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80287d:	66 83 f9 43          	cmp    $0x43,%cx
  802881:	77 1b                	ja     80289e <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802883:	8b 58 20             	mov    0x20(%eax),%ebx
  802886:	8d 71 01             	lea    0x1(%ecx),%esi
  802889:	66 89 70 24          	mov    %si,0x24(%eax)
  80288d:	0f b7 c9             	movzwl %cx,%ecx
  802890:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802897:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80289a:	5b                   	pop    %ebx
  80289b:	5e                   	pop    %esi
  80289c:	5d                   	pop    %ebp
  80289d:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80289e:	83 ec 04             	sub    $0x4,%esp
  8028a1:	68 94 16 81 00       	push   $0x811694
  8028a6:	68 65 04 00 00       	push   $0x465
  8028ab:	68 e2 19 81 00       	push   $0x8119e2
  8028b0:	e8 f3 bc 00 00       	call   80e5a8 <_panic>

008028b5 <dhcp_option>:
{
  8028b5:	55                   	push   %ebp
  8028b6:	89 e5                	mov    %esp,%ebp
  8028b8:	57                   	push   %edi
  8028b9:	56                   	push   %esi
  8028ba:	53                   	push   %ebx
  8028bb:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8028be:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8028c2:	0f b6 f9             	movzbl %cl,%edi
  8028c5:	0f b7 f3             	movzwl %bx,%esi
  8028c8:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8028cc:	83 fe 44             	cmp    $0x44,%esi
  8028cf:	77 34                	ja     802905 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8028d1:	8b 70 20             	mov    0x20(%eax),%esi
  8028d4:	8d 7b 01             	lea    0x1(%ebx),%edi
  8028d7:	66 89 78 24          	mov    %di,0x24(%eax)
  8028db:	0f b7 db             	movzwl %bx,%ebx
  8028de:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8028e5:	8b 58 20             	mov    0x20(%eax),%ebx
  8028e8:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8028ec:	8d 72 01             	lea    0x1(%edx),%esi
  8028ef:	66 89 70 24          	mov    %si,0x24(%eax)
  8028f3:	0f b7 d2             	movzwl %dx,%edx
  8028f6:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8028fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802900:	5b                   	pop    %ebx
  802901:	5e                   	pop    %esi
  802902:	5f                   	pop    %edi
  802903:	5d                   	pop    %ebp
  802904:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802905:	83 ec 04             	sub    $0x4,%esp
  802908:	68 d0 16 81 00       	push   $0x8116d0
  80290d:	68 5a 04 00 00       	push   $0x45a
  802912:	68 e2 19 81 00       	push   $0x8119e2
  802917:	e8 8c bc 00 00       	call   80e5a8 <_panic>

0080291c <dhcp_option_short>:
{
  80291c:	55                   	push   %ebp
  80291d:	89 e5                	mov    %esp,%ebp
  80291f:	56                   	push   %esi
  802920:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802921:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802925:	0f b7 d9             	movzwl %cx,%ebx
  802928:	83 c3 02             	add    $0x2,%ebx
  80292b:	83 fb 44             	cmp    $0x44,%ebx
  80292e:	77 33                	ja     802963 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802930:	8b 58 20             	mov    0x20(%eax),%ebx
  802933:	8d 71 01             	lea    0x1(%ecx),%esi
  802936:	66 89 70 24          	mov    %si,0x24(%eax)
  80293a:	0f b7 c9             	movzwl %cx,%ecx
  80293d:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802944:	8b 58 20             	mov    0x20(%eax),%ebx
  802947:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80294b:	8d 71 01             	lea    0x1(%ecx),%esi
  80294e:	66 89 70 24          	mov    %si,0x24(%eax)
  802952:	0f b7 c9             	movzwl %cx,%ecx
  802955:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  80295c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80295f:	5b                   	pop    %ebx
  802960:	5e                   	pop    %esi
  802961:	5d                   	pop    %ebp
  802962:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802963:	83 ec 04             	sub    $0x4,%esp
  802966:	68 18 17 81 00       	push   $0x811718
  80296b:	68 6c 04 00 00       	push   $0x46c
  802970:	68 e2 19 81 00       	push   $0x8119e2
  802975:	e8 2e bc 00 00       	call   80e5a8 <_panic>

0080297a <dhcp_option_trailer>:
{
  80297a:	55                   	push   %ebp
  80297b:	89 e5                	mov    %esp,%ebp
  80297d:	53                   	push   %ebx
  80297e:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802981:	85 c0                	test   %eax,%eax
  802983:	74 25                	je     8029aa <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802985:	8b 48 20             	mov    0x20(%eax),%ecx
  802988:	85 c9                	test   %ecx,%ecx
  80298a:	74 35                	je     8029c1 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80298c:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802990:	66 83 fa 43          	cmp    $0x43,%dx
  802994:	77 42                	ja     8029d8 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802996:	8d 5a 01             	lea    0x1(%edx),%ebx
  802999:	66 89 58 24          	mov    %bx,0x24(%eax)
  80299d:	0f b7 d2             	movzwl %dx,%edx
  8029a0:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  8029a7:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8029a8:	eb 5a                	jmp    802a04 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  8029aa:	83 ec 04             	sub    $0x4,%esp
  8029ad:	68 5c 17 81 00       	push   $0x81175c
  8029b2:	68 80 05 00 00       	push   $0x580
  8029b7:	68 e2 19 81 00       	push   $0x8119e2
  8029bc:	e8 e7 bb 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  8029c1:	83 ec 04             	sub    $0x4,%esp
  8029c4:	68 80 17 81 00       	push   $0x811780
  8029c9:	68 81 05 00 00       	push   $0x581
  8029ce:	68 e2 19 81 00       	push   $0x8119e2
  8029d3:	e8 d0 bb 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8029d8:	83 ec 04             	sub    $0x4,%esp
  8029db:	68 ac 17 81 00       	push   $0x8117ac
  8029e0:	68 82 05 00 00       	push   $0x582
  8029e5:	68 e2 19 81 00       	push   $0x8119e2
  8029ea:	e8 b9 bb 00 00       	call   80e5a8 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8029ef:	8b 48 20             	mov    0x20(%eax),%ecx
  8029f2:	8d 5a 01             	lea    0x1(%edx),%ebx
  8029f5:	66 89 58 24          	mov    %bx,0x24(%eax)
  8029f9:	0f b7 d2             	movzwl %dx,%edx
  8029fc:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802a03:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a04:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a08:	66 83 fa 43          	cmp    $0x43,%dx
  802a0c:	76 e1                	jbe    8029ef <dhcp_option_trailer+0x75>
  802a0e:	f6 c2 03             	test   $0x3,%dl
  802a11:	74 17                	je     802a2a <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a13:	83 ec 04             	sub    $0x4,%esp
  802a16:	68 ac 17 81 00       	push   $0x8117ac
  802a1b:	68 87 05 00 00       	push   $0x587
  802a20:	68 e2 19 81 00       	push   $0x8119e2
  802a25:	e8 7e bb 00 00       	call   80e5a8 <_panic>
}
  802a2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802a2d:	c9                   	leave  
  802a2e:	c3                   	ret    

00802a2f <dhcp_option_long>:
{
  802a2f:	55                   	push   %ebp
  802a30:	89 e5                	mov    %esp,%ebp
  802a32:	56                   	push   %esi
  802a33:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802a34:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a38:	0f b7 d9             	movzwl %cx,%ebx
  802a3b:	83 c3 04             	add    $0x4,%ebx
  802a3e:	83 fb 44             	cmp    $0x44,%ebx
  802a41:	77 6d                	ja     802ab0 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802a43:	8d 71 01             	lea    0x1(%ecx),%esi
  802a46:	66 89 70 24          	mov    %si,0x24(%eax)
  802a4a:	0f b7 c9             	movzwl %cx,%ecx
  802a4d:	89 d3                	mov    %edx,%ebx
  802a4f:	c1 eb 18             	shr    $0x18,%ebx
  802a52:	8b 70 20             	mov    0x20(%eax),%esi
  802a55:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802a5c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a60:	8d 71 01             	lea    0x1(%ecx),%esi
  802a63:	66 89 70 24          	mov    %si,0x24(%eax)
  802a67:	0f b7 c9             	movzwl %cx,%ecx
  802a6a:	89 d3                	mov    %edx,%ebx
  802a6c:	c1 eb 10             	shr    $0x10,%ebx
  802a6f:	8b 70 20             	mov    0x20(%eax),%esi
  802a72:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802a79:	8b 58 20             	mov    0x20(%eax),%ebx
  802a7c:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a80:	8d 71 01             	lea    0x1(%ecx),%esi
  802a83:	66 89 70 24          	mov    %si,0x24(%eax)
  802a87:	0f b7 c9             	movzwl %cx,%ecx
  802a8a:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802a91:	8b 58 20             	mov    0x20(%eax),%ebx
  802a94:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a98:	8d 71 01             	lea    0x1(%ecx),%esi
  802a9b:	66 89 70 24          	mov    %si,0x24(%eax)
  802a9f:	0f b7 c9             	movzwl %cx,%ecx
  802aa2:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802aa9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802aac:	5b                   	pop    %ebx
  802aad:	5e                   	pop    %esi
  802aae:	5d                   	pop    %ebp
  802aaf:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ab0:	83 ec 04             	sub    $0x4,%esp
  802ab3:	68 ec 17 81 00       	push   $0x8117ec
  802ab8:	68 74 04 00 00       	push   $0x474
  802abd:	68 e2 19 81 00       	push   $0x8119e2
  802ac2:	e8 e1 ba 00 00       	call   80e5a8 <_panic>

00802ac7 <dhcp_create_request>:
{
  802ac7:	55                   	push   %ebp
  802ac8:	89 e5                	mov    %esp,%ebp
  802aca:	57                   	push   %edi
  802acb:	56                   	push   %esi
  802acc:	53                   	push   %ebx
  802acd:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802ad0:	85 c0                	test   %eax,%eax
  802ad2:	0f 84 d8 00 00 00    	je     802bb0 <dhcp_create_request+0xe9>
  802ad8:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802ada:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802add:	85 db                	test   %ebx,%ebx
  802adf:	0f 84 e2 00 00 00    	je     802bc7 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802ae5:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802ae9:	0f 85 ef 00 00 00    	jne    802bde <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802aef:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802af3:	0f 85 fc 00 00 00    	jne    802bf5 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802af9:	83 ec 04             	sub    $0x4,%esp
  802afc:	6a 00                	push   $0x0
  802afe:	68 34 01 00 00       	push   $0x134
  802b03:	6a 00                	push   $0x0
  802b05:	e8 9f 1d 00 00       	call   8048a9 <pbuf_alloc>
  802b0a:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802b0d:	83 c4 10             	add    $0x10,%esp
  802b10:	85 c0                	test   %eax,%eax
  802b12:	0f 84 9b 01 00 00    	je     802cb3 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802b18:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802b1e:	0f 86 e8 00 00 00    	jbe    802c0c <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802b24:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802b2a:	8d 4a 01             	lea    0x1(%edx),%ecx
  802b2d:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802b33:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802b36:	8b 40 04             	mov    0x4(%eax),%eax
  802b39:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802b3c:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802b3f:	8b 43 20             	mov    0x20(%ebx),%eax
  802b42:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802b46:	8b 43 20             	mov    0x20(%ebx),%eax
  802b49:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802b4d:	8b 43 20             	mov    0x20(%ebx),%eax
  802b50:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802b54:	8b 7b 20             	mov    0x20(%ebx),%edi
  802b57:	83 ec 0c             	sub    $0xc,%esp
  802b5a:	ff 73 04             	pushl  0x4(%ebx)
  802b5d:	e8 75 4b 00 00       	call   8076d7 <htonl>
  802b62:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802b65:	8b 43 20             	mov    0x20(%ebx),%eax
  802b68:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802b6e:	8b 43 20             	mov    0x20(%ebx),%eax
  802b71:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802b77:	8b 43 20             	mov    0x20(%ebx),%eax
  802b7a:	8b 56 04             	mov    0x4(%esi),%edx
  802b7d:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802b80:	8b 43 20             	mov    0x20(%ebx),%eax
  802b83:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802b8a:	8b 43 20             	mov    0x20(%ebx),%eax
  802b8d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802b94:	8b 43 20             	mov    0x20(%ebx),%eax
  802b97:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802b9e:	83 c4 10             	add    $0x10,%esp
  802ba1:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802ba6:	bf 00 00 00 00       	mov    $0x0,%edi
  802bab:	e9 82 00 00 00       	jmp    802c32 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802bb0:	83 ec 04             	sub    $0x4,%esp
  802bb3:	68 2c 18 81 00       	push   $0x81182c
  802bb8:	68 2d 05 00 00       	push   $0x52d
  802bbd:	68 e2 19 81 00       	push   $0x8119e2
  802bc2:	e8 e1 b9 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802bc7:	83 ec 04             	sub    $0x4,%esp
  802bca:	68 50 18 81 00       	push   $0x811850
  802bcf:	68 2f 05 00 00       	push   $0x52f
  802bd4:	68 e2 19 81 00       	push   $0x8119e2
  802bd9:	e8 ca b9 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802bde:	83 ec 04             	sub    $0x4,%esp
  802be1:	68 74 18 81 00       	push   $0x811874
  802be6:	68 30 05 00 00       	push   $0x530
  802beb:	68 e2 19 81 00       	push   $0x8119e2
  802bf0:	e8 b3 b9 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802bf5:	83 ec 04             	sub    $0x4,%esp
  802bf8:	68 a0 18 81 00       	push   $0x8118a0
  802bfd:	68 31 05 00 00       	push   $0x531
  802c02:	68 e2 19 81 00       	push   $0x8119e2
  802c07:	e8 9c b9 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802c0c:	83 ec 04             	sub    $0x4,%esp
  802c0f:	68 cc 18 81 00       	push   $0x8118cc
  802c14:	68 38 05 00 00       	push   $0x538
  802c19:	68 e2 19 81 00       	push   $0x8119e2
  802c1e:	e8 85 b9 00 00       	call   80e5a8 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c23:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802c26:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802c2a:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802c2d:	83 f8 10             	cmp    $0x10,%eax
  802c30:	74 12                	je     802c44 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c32:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802c36:	89 fa                	mov    %edi,%edx
  802c38:	66 39 c1             	cmp    %ax,%cx
  802c3b:	76 e6                	jbe    802c23 <dhcp_create_request+0x15c>
  802c3d:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802c42:	eb df                	jmp    802c23 <dhcp_create_request+0x15c>
  802c44:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802c49:	8b 53 20             	mov    0x20(%ebx),%edx
  802c4c:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802c51:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802c54:	83 f8 40             	cmp    $0x40,%eax
  802c57:	75 f0                	jne    802c49 <dhcp_create_request+0x182>
  802c59:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802c5e:	8b 53 20             	mov    0x20(%ebx),%edx
  802c61:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802c66:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802c69:	3d 80 00 00 00       	cmp    $0x80,%eax
  802c6e:	75 ee                	jne    802c5e <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802c70:	8b 73 20             	mov    0x20(%ebx),%esi
  802c73:	83 ec 0c             	sub    $0xc,%esp
  802c76:	68 63 53 82 63       	push   $0x63825363
  802c7b:	e8 57 4a 00 00       	call   8076d7 <htonl>
  802c80:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802c86:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802c8c:	83 c4 10             	add    $0x10,%esp
  802c8f:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802c94:	8b 53 20             	mov    0x20(%ebx),%edx
  802c97:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802c9e:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802ca1:	83 f8 44             	cmp    $0x44,%eax
  802ca4:	75 ee                	jne    802c94 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802ca6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802cab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802cae:	5b                   	pop    %ebx
  802caf:	5e                   	pop    %esi
  802cb0:	5f                   	pop    %edi
  802cb1:	5d                   	pop    %ebp
  802cb2:	c3                   	ret    
    return ERR_MEM;
  802cb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802cb8:	eb f1                	jmp    802cab <dhcp_create_request+0x1e4>

00802cba <dhcp_delete_request>:
{
  802cba:	55                   	push   %ebp
  802cbb:	89 e5                	mov    %esp,%ebp
  802cbd:	53                   	push   %ebx
  802cbe:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802cc1:	85 c0                	test   %eax,%eax
  802cc3:	74 33                	je     802cf8 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802cc5:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802cc8:	85 db                	test   %ebx,%ebx
  802cca:	74 43                	je     802d0f <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802ccc:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802ccf:	85 c0                	test   %eax,%eax
  802cd1:	74 53                	je     802d26 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802cd3:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802cd7:	74 64                	je     802d3d <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802cd9:	83 ec 0c             	sub    $0xc,%esp
  802cdc:	50                   	push   %eax
  802cdd:	e8 01 1b 00 00       	call   8047e3 <pbuf_free>
  dhcp->p_out = NULL;
  802ce2:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802ce9:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802cf0:	83 c4 10             	add    $0x10,%esp
}
  802cf3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802cf6:	c9                   	leave  
  802cf7:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802cf8:	83 ec 04             	sub    $0x4,%esp
  802cfb:	68 10 19 81 00       	push   $0x811910
  802d00:	68 69 05 00 00       	push   $0x569
  802d05:	68 e2 19 81 00       	push   $0x8119e2
  802d0a:	e8 99 b8 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d0f:	83 ec 04             	sub    $0x4,%esp
  802d12:	68 34 19 81 00       	push   $0x811934
  802d17:	68 6b 05 00 00       	push   $0x56b
  802d1c:	68 e2 19 81 00       	push   $0x8119e2
  802d21:	e8 82 b8 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d26:	83 ec 04             	sub    $0x4,%esp
  802d29:	68 58 19 81 00       	push   $0x811958
  802d2e:	68 6c 05 00 00       	push   $0x56c
  802d33:	68 e2 19 81 00       	push   $0x8119e2
  802d38:	e8 6b b8 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d3d:	83 ec 04             	sub    $0x4,%esp
  802d40:	68 84 19 81 00       	push   $0x811984
  802d45:	68 6d 05 00 00       	push   $0x56d
  802d4a:	68 e2 19 81 00       	push   $0x8119e2
  802d4f:	e8 54 b8 00 00       	call   80e5a8 <_panic>

00802d54 <dhcp_rebind>:
{
  802d54:	55                   	push   %ebp
  802d55:	89 e5                	mov    %esp,%ebp
  802d57:	57                   	push   %edi
  802d58:	56                   	push   %esi
  802d59:	53                   	push   %ebx
  802d5a:	83 ec 0c             	sub    $0xc,%esp
  802d5d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802d5f:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802d62:	ba 04 00 00 00       	mov    $0x4,%edx
  802d67:	89 d8                	mov    %ebx,%eax
  802d69:	e8 cc f9 ff ff       	call   80273a <dhcp_set_state>
  result = dhcp_create_request(netif);
  802d6e:	89 f8                	mov    %edi,%eax
  802d70:	e8 52 fd ff ff       	call   802ac7 <dhcp_create_request>
  802d75:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802d77:	84 c0                	test   %al,%al
  802d79:	74 3e                	je     802db9 <dhcp_rebind+0x65>
  dhcp->tries++;
  802d7b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802d7f:	83 c0 01             	add    $0x1,%eax
  802d82:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802d85:	ba 10 27 00 00       	mov    $0x2710,%edx
  802d8a:	3c 09                	cmp    $0x9,%al
  802d8c:	77 08                	ja     802d96 <dhcp_rebind+0x42>
  802d8e:	0f b6 d0             	movzbl %al,%edx
  802d91:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802d96:	0f b7 d2             	movzwl %dx,%edx
  802d99:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802d9f:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802da4:	89 d0                	mov    %edx,%eax
  802da6:	f7 e9                	imul   %ecx
  802da8:	c1 fa 05             	sar    $0x5,%edx
  802dab:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802daf:	89 f0                	mov    %esi,%eax
  802db1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802db4:	5b                   	pop    %ebx
  802db5:	5e                   	pop    %esi
  802db6:	5f                   	pop    %edi
  802db7:	5d                   	pop    %ebp
  802db8:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802db9:	b9 01 00 00 00       	mov    $0x1,%ecx
  802dbe:	ba 35 00 00 00       	mov    $0x35,%edx
  802dc3:	89 d8                	mov    %ebx,%eax
  802dc5:	e8 eb fa ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802dca:	ba 03 00 00 00       	mov    $0x3,%edx
  802dcf:	89 d8                	mov    %ebx,%eax
  802dd1:	e8 9e fa ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802dd6:	b9 02 00 00 00       	mov    $0x2,%ecx
  802ddb:	ba 39 00 00 00       	mov    $0x39,%edx
  802de0:	89 d8                	mov    %ebx,%eax
  802de2:	e8 ce fa ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802de7:	ba 40 02 00 00       	mov    $0x240,%edx
  802dec:	89 d8                	mov    %ebx,%eax
  802dee:	e8 29 fb ff ff       	call   80291c <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802df3:	89 d8                	mov    %ebx,%eax
  802df5:	e8 80 fb ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802dfa:	83 ec 08             	sub    $0x8,%esp
  802dfd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802e01:	66 05 f0 00          	add    $0xf0,%ax
  802e05:	0f b7 c0             	movzwl %ax,%eax
  802e08:	50                   	push   %eax
  802e09:	ff 73 1c             	pushl  0x1c(%ebx)
  802e0c:	e8 0a 1d 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802e11:	83 c4 0c             	add    $0xc,%esp
  802e14:	6a 43                	push   $0x43
  802e16:	68 88 22 81 00       	push   $0x812288
  802e1b:	ff 73 08             	pushl  0x8(%ebx)
  802e1e:	e8 ad 60 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802e23:	89 3c 24             	mov    %edi,(%esp)
  802e26:	6a 43                	push   $0x43
  802e28:	68 84 22 81 00       	push   $0x812284
  802e2d:	ff 73 1c             	pushl  0x1c(%ebx)
  802e30:	ff 73 08             	pushl  0x8(%ebx)
  802e33:	e8 a3 5e 00 00       	call   808cdb <udp_sendto_if>
    dhcp_delete_request(netif);
  802e38:	83 c4 20             	add    $0x20,%esp
  802e3b:	89 f8                	mov    %edi,%eax
  802e3d:	e8 78 fe ff ff       	call   802cba <dhcp_delete_request>
  802e42:	e9 34 ff ff ff       	jmp    802d7b <dhcp_rebind+0x27>

00802e47 <dhcp_discover>:
{
  802e47:	55                   	push   %ebp
  802e48:	89 e5                	mov    %esp,%ebp
  802e4a:	57                   	push   %edi
  802e4b:	56                   	push   %esi
  802e4c:	53                   	push   %ebx
  802e4d:	83 ec 0c             	sub    $0xc,%esp
  802e50:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e52:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802e55:	a1 88 22 81 00       	mov    0x812288,%eax
  802e5a:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802e5d:	89 f8                	mov    %edi,%eax
  802e5f:	e8 63 fc ff ff       	call   802ac7 <dhcp_create_request>
  802e64:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e66:	84 c0                	test   %al,%al
  802e68:	74 41                	je     802eab <dhcp_discover+0x64>
  dhcp->tries++;
  802e6a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e6e:	83 c0 01             	add    $0x1,%eax
  802e71:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802e74:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e79:	3c 03                	cmp    $0x3,%al
  802e7b:	77 0b                	ja     802e88 <dhcp_discover+0x41>
  802e7d:	0f b6 d0             	movzbl %al,%edx
  802e80:	83 c2 01             	add    $0x1,%edx
  802e83:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e88:	0f b7 d2             	movzwl %dx,%edx
  802e8b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802e91:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802e96:	89 d0                	mov    %edx,%eax
  802e98:	f7 e9                	imul   %ecx
  802e9a:	c1 fa 05             	sar    $0x5,%edx
  802e9d:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802ea1:	89 f0                	mov    %esi,%eax
  802ea3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ea6:	5b                   	pop    %ebx
  802ea7:	5e                   	pop    %esi
  802ea8:	5f                   	pop    %edi
  802ea9:	5d                   	pop    %ebp
  802eaa:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802eab:	b9 01 00 00 00       	mov    $0x1,%ecx
  802eb0:	ba 35 00 00 00       	mov    $0x35,%edx
  802eb5:	89 d8                	mov    %ebx,%eax
  802eb7:	e8 f9 f9 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802ebc:	ba 01 00 00 00       	mov    $0x1,%edx
  802ec1:	89 d8                	mov    %ebx,%eax
  802ec3:	e8 ac f9 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ec8:	b9 02 00 00 00       	mov    $0x2,%ecx
  802ecd:	ba 39 00 00 00       	mov    $0x39,%edx
  802ed2:	89 d8                	mov    %ebx,%eax
  802ed4:	e8 dc f9 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ed9:	ba 40 02 00 00       	mov    $0x240,%edx
  802ede:	89 d8                	mov    %ebx,%eax
  802ee0:	e8 37 fa ff ff       	call   80291c <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802ee5:	b9 04 00 00 00       	mov    $0x4,%ecx
  802eea:	ba 37 00 00 00       	mov    $0x37,%edx
  802eef:	89 d8                	mov    %ebx,%eax
  802ef1:	e8 bf f9 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802ef6:	ba 01 00 00 00       	mov    $0x1,%edx
  802efb:	89 d8                	mov    %ebx,%eax
  802efd:	e8 72 f9 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802f02:	ba 03 00 00 00       	mov    $0x3,%edx
  802f07:	89 d8                	mov    %ebx,%eax
  802f09:	e8 66 f9 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802f0e:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802f13:	89 d8                	mov    %ebx,%eax
  802f15:	e8 5a f9 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802f1a:	ba 06 00 00 00       	mov    $0x6,%edx
  802f1f:	89 d8                	mov    %ebx,%eax
  802f21:	e8 4e f9 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  802f26:	89 d8                	mov    %ebx,%eax
  802f28:	e8 4d fa ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802f2d:	83 ec 08             	sub    $0x8,%esp
  802f30:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802f34:	66 05 f0 00          	add    $0xf0,%ax
  802f38:	0f b7 c0             	movzwl %ax,%eax
  802f3b:	50                   	push   %eax
  802f3c:	ff 73 1c             	pushl  0x1c(%ebx)
  802f3f:	e8 d7 1b 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802f44:	83 c4 0c             	add    $0xc,%esp
  802f47:	6a 43                	push   $0x43
  802f49:	68 88 22 81 00       	push   $0x812288
  802f4e:	ff 73 08             	pushl  0x8(%ebx)
  802f51:	e8 7a 5f 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802f56:	89 3c 24             	mov    %edi,(%esp)
  802f59:	6a 43                	push   $0x43
  802f5b:	68 84 22 81 00       	push   $0x812284
  802f60:	ff 73 1c             	pushl  0x1c(%ebx)
  802f63:	ff 73 08             	pushl  0x8(%ebx)
  802f66:	e8 70 5d 00 00       	call   808cdb <udp_sendto_if>
    dhcp_delete_request(netif);
  802f6b:	83 c4 20             	add    $0x20,%esp
  802f6e:	89 f8                	mov    %edi,%eax
  802f70:	e8 45 fd ff ff       	call   802cba <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  802f75:	ba 06 00 00 00       	mov    $0x6,%edx
  802f7a:	89 d8                	mov    %ebx,%eax
  802f7c:	e8 b9 f7 ff ff       	call   80273a <dhcp_set_state>
  802f81:	e9 e4 fe ff ff       	jmp    802e6a <dhcp_discover+0x23>

00802f86 <dhcp_select>:
{
  802f86:	55                   	push   %ebp
  802f87:	89 e5                	mov    %esp,%ebp
  802f89:	57                   	push   %edi
  802f8a:	56                   	push   %esi
  802f8b:	53                   	push   %ebx
  802f8c:	83 ec 0c             	sub    $0xc,%esp
  802f8f:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f91:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  802f94:	e8 2e fb ff ff       	call   802ac7 <dhcp_create_request>
  802f99:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f9b:	84 c0                	test   %al,%al
  802f9d:	74 3e                	je     802fdd <dhcp_select+0x57>
  dhcp->tries++;
  802f9f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802fa3:	83 c0 01             	add    $0x1,%eax
  802fa6:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  802fa9:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  802fae:	3c 03                	cmp    $0x3,%al
  802fb0:	77 08                	ja     802fba <dhcp_select+0x34>
  802fb2:	0f b6 d0             	movzbl %al,%edx
  802fb5:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fba:	0f b7 d2             	movzwl %dx,%edx
  802fbd:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802fc3:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802fc8:	89 d0                	mov    %edx,%eax
  802fca:	f7 e9                	imul   %ecx
  802fcc:	c1 fa 05             	sar    $0x5,%edx
  802fcf:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802fd3:	89 f0                	mov    %esi,%eax
  802fd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802fd8:	5b                   	pop    %ebx
  802fd9:	5e                   	pop    %esi
  802fda:	5f                   	pop    %edi
  802fdb:	5d                   	pop    %ebp
  802fdc:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802fdd:	b9 01 00 00 00       	mov    $0x1,%ecx
  802fe2:	ba 35 00 00 00       	mov    $0x35,%edx
  802fe7:	89 d8                	mov    %ebx,%eax
  802fe9:	e8 c7 f8 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802fee:	ba 03 00 00 00       	mov    $0x3,%edx
  802ff3:	89 d8                	mov    %ebx,%eax
  802ff5:	e8 7a f8 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802ffa:	b9 02 00 00 00       	mov    $0x2,%ecx
  802fff:	ba 39 00 00 00       	mov    $0x39,%edx
  803004:	89 d8                	mov    %ebx,%eax
  803006:	e8 aa f8 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80300b:	ba 40 02 00 00       	mov    $0x240,%edx
  803010:	89 d8                	mov    %ebx,%eax
  803012:	e8 05 f9 ff ff       	call   80291c <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803017:	b9 04 00 00 00       	mov    $0x4,%ecx
  80301c:	ba 32 00 00 00       	mov    $0x32,%edx
  803021:	89 d8                	mov    %ebx,%eax
  803023:	e8 8d f8 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803028:	83 ec 0c             	sub    $0xc,%esp
  80302b:	ff 73 30             	pushl  0x30(%ebx)
  80302e:	e8 bb 48 00 00       	call   8078ee <ntohl>
  803033:	89 c2                	mov    %eax,%edx
  803035:	89 d8                	mov    %ebx,%eax
  803037:	e8 f3 f9 ff ff       	call   802a2f <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80303c:	b9 04 00 00 00       	mov    $0x4,%ecx
  803041:	ba 36 00 00 00       	mov    $0x36,%edx
  803046:	89 d8                	mov    %ebx,%eax
  803048:	e8 68 f8 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80304d:	83 c4 04             	add    $0x4,%esp
  803050:	ff 73 2c             	pushl  0x2c(%ebx)
  803053:	e8 96 48 00 00       	call   8078ee <ntohl>
  803058:	89 c2                	mov    %eax,%edx
  80305a:	89 d8                	mov    %ebx,%eax
  80305c:	e8 ce f9 ff ff       	call   802a2f <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803061:	b9 04 00 00 00       	mov    $0x4,%ecx
  803066:	ba 37 00 00 00       	mov    $0x37,%edx
  80306b:	89 d8                	mov    %ebx,%eax
  80306d:	e8 43 f8 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803072:	ba 01 00 00 00       	mov    $0x1,%edx
  803077:	89 d8                	mov    %ebx,%eax
  803079:	e8 f6 f7 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80307e:	ba 03 00 00 00       	mov    $0x3,%edx
  803083:	89 d8                	mov    %ebx,%eax
  803085:	e8 ea f7 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80308a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80308f:	89 d8                	mov    %ebx,%eax
  803091:	e8 de f7 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803096:	ba 06 00 00 00       	mov    $0x6,%edx
  80309b:	89 d8                	mov    %ebx,%eax
  80309d:	e8 d2 f7 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  8030a2:	89 d8                	mov    %ebx,%eax
  8030a4:	e8 d1 f8 ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8030a9:	83 c4 08             	add    $0x8,%esp
  8030ac:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8030b0:	66 05 f0 00          	add    $0xf0,%ax
  8030b4:	0f b7 c0             	movzwl %ax,%eax
  8030b7:	50                   	push   %eax
  8030b8:	ff 73 1c             	pushl  0x1c(%ebx)
  8030bb:	e8 5b 1a 00 00       	call   804b1b <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8030c0:	89 3c 24             	mov    %edi,(%esp)
  8030c3:	6a 43                	push   $0x43
  8030c5:	68 84 22 81 00       	push   $0x812284
  8030ca:	ff 73 1c             	pushl  0x1c(%ebx)
  8030cd:	ff 73 08             	pushl  0x8(%ebx)
  8030d0:	e8 06 5c 00 00       	call   808cdb <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8030d5:	83 c4 1c             	add    $0x1c,%esp
  8030d8:	6a 43                	push   $0x43
  8030da:	68 88 22 81 00       	push   $0x812288
  8030df:	ff 73 08             	pushl  0x8(%ebx)
  8030e2:	e8 e9 5d 00 00       	call   808ed0 <udp_connect>
    dhcp_delete_request(netif);
  8030e7:	89 f8                	mov    %edi,%eax
  8030e9:	e8 cc fb ff ff       	call   802cba <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8030ee:	ba 01 00 00 00       	mov    $0x1,%edx
  8030f3:	89 d8                	mov    %ebx,%eax
  8030f5:	e8 40 f6 ff ff       	call   80273a <dhcp_set_state>
  8030fa:	83 c4 10             	add    $0x10,%esp
  8030fd:	e9 9d fe ff ff       	jmp    802f9f <dhcp_select+0x19>

00803102 <dhcp_check>:
{
  803102:	55                   	push   %ebp
  803103:	89 e5                	mov    %esp,%ebp
  803105:	53                   	push   %ebx
  803106:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  803109:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80310c:	6a 00                	push   $0x0
  80310e:	8d 53 30             	lea    0x30(%ebx),%edx
  803111:	52                   	push   %edx
  803112:	50                   	push   %eax
  803113:	e8 ac 67 00 00       	call   8098c4 <etharp_query>
  dhcp->tries++;
  803118:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80311c:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803122:	ba 08 00 00 00       	mov    $0x8,%edx
  803127:	89 d8                	mov    %ebx,%eax
  803129:	e8 0c f6 ff ff       	call   80273a <dhcp_set_state>
}
  80312e:	83 c4 10             	add    $0x10,%esp
  803131:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803134:	c9                   	leave  
  803135:	c3                   	ret    

00803136 <dhcp_bind>:
{
  803136:	55                   	push   %ebp
  803137:	89 e5                	mov    %esp,%ebp
  803139:	56                   	push   %esi
  80313a:	53                   	push   %ebx
  80313b:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80313e:	85 c0                	test   %eax,%eax
  803140:	0f 84 cf 00 00 00    	je     803215 <dhcp_bind+0xdf>
  803146:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803148:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80314b:	85 db                	test   %ebx,%ebx
  80314d:	0f 84 d9 00 00 00    	je     80322c <dhcp_bind+0xf6>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803153:	8b 53 50             	mov    0x50(%ebx),%edx
  803156:	83 fa ff             	cmp    $0xffffffff,%edx
  803159:	74 2a                	je     803185 <dhcp_bind+0x4f>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80315b:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80315e:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803164:	0f 87 74 01 00 00    	ja     8032de <dhcp_bind+0x1a8>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80316a:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  80316f:	89 d0                	mov    %edx,%eax
  803171:	f7 e1                	mul    %ecx
  803173:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t1_timeout == 0) {
  803176:	66 85 d2             	test   %dx,%dx
  803179:	0f 85 c4 00 00 00    	jne    803243 <dhcp_bind+0x10d>
      dhcp->t1_timeout = 1;
  80317f:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803185:	8b 53 54             	mov    0x54(%ebx),%edx
  803188:	83 fa ff             	cmp    $0xffffffff,%edx
  80318b:	74 2a                	je     8031b7 <dhcp_bind+0x81>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80318d:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803190:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803196:	0f 87 37 01 00 00    	ja     8032d3 <dhcp_bind+0x19d>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80319c:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8031a1:	89 d0                	mov    %edx,%eax
  8031a3:	f7 e1                	mul    %ecx
  8031a5:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t2_timeout == 0) {
  8031a8:	66 85 d2             	test   %dx,%dx
  8031ab:	0f 85 9b 00 00 00    	jne    80324c <dhcp_bind+0x116>
      dhcp->t2_timeout = 1;
  8031b1:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8031b7:	8b 43 34             	mov    0x34(%ebx),%eax
  8031ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8031bd:	85 c0                	test   %eax,%eax
  8031bf:	0f 84 90 00 00 00    	je     803255 <dhcp_bind+0x11f>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8031c5:	8b 43 38             	mov    0x38(%ebx),%eax
  8031c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8031cb:	85 c0                	test   %eax,%eax
  8031cd:	0f 84 e2 00 00 00    	je     8032b5 <dhcp_bind+0x17f>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8031d3:	83 ec 08             	sub    $0x8,%esp
  8031d6:	8d 43 30             	lea    0x30(%ebx),%eax
  8031d9:	50                   	push   %eax
  8031da:	56                   	push   %esi
  8031db:	e8 73 13 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8031e0:	83 c4 08             	add    $0x8,%esp
  8031e3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8031e6:	50                   	push   %eax
  8031e7:	56                   	push   %esi
  8031e8:	e8 ab 14 00 00       	call   804698 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8031ed:	83 c4 08             	add    $0x8,%esp
  8031f0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8031f3:	50                   	push   %eax
  8031f4:	56                   	push   %esi
  8031f5:	e8 85 14 00 00       	call   80467f <netif_set_gw>
  netif_set_up(netif);
  8031fa:	89 34 24             	mov    %esi,(%esp)
  8031fd:	e8 bc 14 00 00       	call   8046be <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  803202:	ba 0a 00 00 00       	mov    $0xa,%edx
  803207:	89 d8                	mov    %ebx,%eax
  803209:	e8 2c f5 ff ff       	call   80273a <dhcp_set_state>
}
  80320e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803211:	5b                   	pop    %ebx
  803212:	5e                   	pop    %esi
  803213:	5d                   	pop    %ebp
  803214:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803215:	83 ec 04             	sub    $0x4,%esp
  803218:	68 f7 19 81 00       	push   $0x8119f7
  80321d:	68 3d 03 00 00       	push   $0x33d
  803222:	68 e2 19 81 00       	push   $0x8119e2
  803227:	e8 7c b3 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80322c:	83 ec 04             	sub    $0x4,%esp
  80322f:	68 10 1a 81 00       	push   $0x811a10
  803234:	68 3f 03 00 00       	push   $0x33f
  803239:	68 e2 19 81 00       	push   $0x8119e2
  80323e:	e8 65 b3 00 00       	call   80e5a8 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803243:	66 89 53 28          	mov    %dx,0x28(%ebx)
  803247:	e9 39 ff ff ff       	jmp    803185 <dhcp_bind+0x4f>
    dhcp->t2_timeout = (u16_t)timeout;
  80324c:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  803250:	e9 62 ff ff ff       	jmp    8031b7 <dhcp_bind+0x81>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803255:	83 ec 0c             	sub    $0xc,%esp
  803258:	6a 00                	push   $0x0
  80325a:	e8 8f 46 00 00       	call   8078ee <ntohl>
  80325f:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803262:	83 c4 10             	add    $0x10,%esp
  803265:	84 c0                	test   %al,%al
  803267:	79 1c                	jns    803285 <dhcp_bind+0x14f>
    } else if (first_octet >= 192) {
  803269:	3c bf                	cmp    $0xbf,%al
  80326b:	76 30                	jbe    80329d <dhcp_bind+0x167>
      sn_mask.addr = htonl(0xffffff00);
  80326d:	83 ec 0c             	sub    $0xc,%esp
  803270:	68 00 ff ff ff       	push   $0xffffff00
  803275:	e8 5d 44 00 00       	call   8076d7 <htonl>
  80327a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80327d:	83 c4 10             	add    $0x10,%esp
  803280:	e9 40 ff ff ff       	jmp    8031c5 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xff000000);
  803285:	83 ec 0c             	sub    $0xc,%esp
  803288:	68 00 00 00 ff       	push   $0xff000000
  80328d:	e8 45 44 00 00       	call   8076d7 <htonl>
  803292:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803295:	83 c4 10             	add    $0x10,%esp
  803298:	e9 28 ff ff ff       	jmp    8031c5 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xffff0000);
  80329d:	83 ec 0c             	sub    $0xc,%esp
  8032a0:	68 00 00 ff ff       	push   $0xffff0000
  8032a5:	e8 2d 44 00 00       	call   8076d7 <htonl>
  8032aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8032ad:	83 c4 10             	add    $0x10,%esp
  8032b0:	e9 10 ff ff ff       	jmp    8031c5 <dhcp_bind+0x8f>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8032b5:	8b 43 30             	mov    0x30(%ebx),%eax
  8032b8:	23 45 f4             	and    -0xc(%ebp),%eax
  8032bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8032be:	83 ec 0c             	sub    $0xc,%esp
  8032c1:	6a 01                	push   $0x1
  8032c3:	e8 0f 44 00 00       	call   8076d7 <htonl>
  8032c8:	09 45 f0             	or     %eax,-0x10(%ebp)
  8032cb:	83 c4 10             	add    $0x10,%esp
  8032ce:	e9 00 ff ff ff       	jmp    8031d3 <dhcp_bind+0x9d>
    dhcp->t2_timeout = (u16_t)timeout;
  8032d3:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8032d9:	e9 d9 fe ff ff       	jmp    8031b7 <dhcp_bind+0x81>
    dhcp->t1_timeout = (u16_t)timeout;
  8032de:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8032e4:	e9 9c fe ff ff       	jmp    803185 <dhcp_bind+0x4f>

008032e9 <dhcp_free_reply>:
{
  8032e9:	55                   	push   %ebp
  8032ea:	89 e5                	mov    %esp,%ebp
  8032ec:	53                   	push   %ebx
  8032ed:	83 ec 04             	sub    $0x4,%esp
  8032f0:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  8032f2:	8b 40 10             	mov    0x10(%eax),%eax
  8032f5:	85 c0                	test   %eax,%eax
  8032f7:	74 13                	je     80330c <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8032f9:	83 ec 0c             	sub    $0xc,%esp
  8032fc:	50                   	push   %eax
  8032fd:	e8 fb 0b 00 00       	call   803efd <mem_free>
    dhcp->msg_in = NULL;
  803302:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803309:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  80330c:	8b 43 14             	mov    0x14(%ebx),%eax
  80330f:	85 c0                	test   %eax,%eax
  803311:	74 19                	je     80332c <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803313:	83 ec 0c             	sub    $0xc,%esp
  803316:	50                   	push   %eax
  803317:	e8 e1 0b 00 00       	call   803efd <mem_free>
    dhcp->options_in = NULL;
  80331c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803323:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  803329:	83 c4 10             	add    $0x10,%esp
}
  80332c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80332f:	c9                   	leave  
  803330:	c3                   	ret    

00803331 <dhcp_recv>:
{
  803331:	55                   	push   %ebp
  803332:	89 e5                	mov    %esp,%ebp
  803334:	57                   	push   %edi
  803335:	56                   	push   %esi
  803336:	53                   	push   %ebx
  803337:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  80333a:	8b 45 08             	mov    0x8(%ebp),%eax
  80333d:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803340:	8b 45 10             	mov    0x10(%ebp),%eax
  803343:	8b 70 04             	mov    0x4(%eax),%esi
  803346:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  803349:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80334c:	80 3e 02             	cmpb   $0x2,(%esi)
  80334f:	75 26                	jne    803377 <dhcp_recv+0x46>
  803351:	8b 45 08             	mov    0x8(%ebp),%eax
  803354:	83 c0 25             	add    $0x25,%eax
  803357:	8d 56 1c             	lea    0x1c(%esi),%edx
  80335a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80335d:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803361:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803363:	39 f0                	cmp    %esi,%eax
  803365:	74 2a                	je     803391 <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803367:	0f b6 18             	movzbl (%eax),%ebx
  80336a:	0f b6 0a             	movzbl (%edx),%ecx
  80336d:	83 c0 01             	add    $0x1,%eax
  803370:	83 c2 01             	add    $0x1,%edx
  803373:	38 cb                	cmp    %cl,%bl
  803375:	74 ec                	je     803363 <dhcp_recv+0x32>
  pbuf_free(p);
  803377:	83 ec 0c             	sub    $0xc,%esp
  80337a:	ff 75 10             	pushl  0x10(%ebp)
  80337d:	e8 61 14 00 00       	call   8047e3 <pbuf_free>
  dhcp->p = NULL;
  803382:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  803389:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80338c:	5b                   	pop    %ebx
  80338d:	5e                   	pop    %esi
  80338e:	5f                   	pop    %edi
  80338f:	5d                   	pop    %ebp
  803390:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803391:	83 ec 0c             	sub    $0xc,%esp
  803394:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803397:	ff 70 04             	pushl  0x4(%eax)
  80339a:	e8 4f 45 00 00       	call   8078ee <ntohl>
  80339f:	83 c4 10             	add    $0x10,%esp
  8033a2:	3b 47 04             	cmp    0x4(%edi),%eax
  8033a5:	75 d0                	jne    803377 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8033a7:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  8033ab:	0f 84 20 01 00 00    	je     8034d1 <dhcp_recv+0x1a0>
  dhcp_free_reply(dhcp);
  8033b1:	89 f8                	mov    %edi,%eax
  8033b3:	e8 31 ff ff ff       	call   8032e9 <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8033b8:	8b 47 0c             	mov    0xc(%edi),%eax
  8033bb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8033bf:	66 3d f0 00          	cmp    $0xf0,%ax
  8033c3:	76 1e                	jbe    8033e3 <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033c5:	66 2d f0 00          	sub    $0xf0,%ax
  8033c9:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8033cd:	83 ec 0c             	sub    $0xc,%esp
  8033d0:	0f b7 c0             	movzwl %ax,%eax
  8033d3:	50                   	push   %eax
  8033d4:	e8 13 0e 00 00       	call   8041ec <mem_malloc>
  8033d9:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8033dc:	83 c4 10             	add    $0x10,%esp
  8033df:	85 c0                	test   %eax,%eax
  8033e1:	74 94                	je     803377 <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8033e3:	83 ec 0c             	sub    $0xc,%esp
  8033e6:	68 f0 00 00 00       	push   $0xf0
  8033eb:	e8 fc 0d 00 00       	call   8041ec <mem_malloc>
  8033f0:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  8033f3:	83 c4 10             	add    $0x10,%esp
  8033f6:	85 c0                	test   %eax,%eax
  8033f8:	0f 84 ea 00 00 00    	je     8034e8 <dhcp_recv+0x1b7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8033fe:	6a 00                	push   $0x0
  803400:	68 f0 00 00 00       	push   $0xf0
  803405:	50                   	push   %eax
  803406:	ff 77 0c             	pushl  0xc(%edi)
  803409:	e8 51 1b 00 00       	call   804f5f <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80340e:	83 c4 10             	add    $0x10,%esp
  803411:	66 3d f0 00          	cmp    $0xf0,%ax
  803415:	0f 85 e7 00 00 00    	jne    803502 <dhcp_recv+0x1d1>
  if (dhcp->options_in != NULL) {
  80341b:	8b 47 14             	mov    0x14(%edi),%eax
  80341e:	85 c0                	test   %eax,%eax
  803420:	74 20                	je     803442 <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803422:	68 f0 00 00 00       	push   $0xf0
  803427:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  80342b:	52                   	push   %edx
  80342c:	50                   	push   %eax
  80342d:	ff 77 0c             	pushl  0xc(%edi)
  803430:	e8 2a 1b 00 00       	call   804f5f <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803435:	83 c4 10             	add    $0x10,%esp
  803438:	66 3b 47 18          	cmp    0x18(%edi),%ax
  80343c:	0f 85 d7 00 00 00    	jne    803519 <dhcp_recv+0x1e8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803442:	ba 35 00 00 00       	mov    $0x35,%edx
  803447:	89 f8                	mov    %edi,%eax
  803449:	e8 f7 f2 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80344e:	85 c0                	test   %eax,%eax
  803450:	0f 84 21 ff ff ff    	je     803377 <dhcp_recv+0x46>
  return *ptr;
  803456:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  80345a:	3c 05                	cmp    $0x5,%al
  80345c:	0f 84 ce 00 00 00    	je     803530 <dhcp_recv+0x1ff>
  else if ((msg_type == DHCP_NAK) &&
  803462:	3c 06                	cmp    $0x6,%al
  803464:	0f 84 6e 02 00 00    	je     8036d8 <dhcp_recv+0x3a7>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80346a:	3c 02                	cmp    $0x2,%al
  80346c:	0f 85 05 ff ff ff    	jne    803377 <dhcp_recv+0x46>
  803472:	80 3f 06             	cmpb   $0x6,(%edi)
  803475:	0f 85 fc fe ff ff    	jne    803377 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  80347b:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803481:	8b 45 08             	mov    0x8(%ebp),%eax
  803484:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803487:	ba 36 00 00 00       	mov    $0x36,%edx
  80348c:	89 d8                	mov    %ebx,%eax
  80348e:	e8 b2 f2 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803493:	85 c0                	test   %eax,%eax
  803495:	0f 84 dc fe ff ff    	je     803377 <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80349b:	83 c0 02             	add    $0x2,%eax
  80349e:	e8 b0 f3 ff ff       	call   802853 <dhcp_get_option_long>
  8034a3:	83 ec 0c             	sub    $0xc,%esp
  8034a6:	50                   	push   %eax
  8034a7:	e8 2b 42 00 00       	call   8076d7 <htonl>
  8034ac:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8034af:	8b 43 10             	mov    0x10(%ebx),%eax
  8034b2:	83 c4 10             	add    $0x10,%esp
  8034b5:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8034b8:	0f 84 8e 02 00 00    	je     80374c <dhcp_recv+0x41b>
  8034be:	8b 40 10             	mov    0x10(%eax),%eax
  8034c1:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8034c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8034c7:	e8 ba fa ff ff       	call   802f86 <dhcp_select>
  8034cc:	e9 a6 fe ff ff       	jmp    803377 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8034d1:	83 ec 04             	sub    $0x4,%esp
  8034d4:	68 28 1a 81 00       	push   $0x811a28
  8034d9:	68 8a 04 00 00       	push   $0x48a
  8034de:	68 e2 19 81 00       	push   $0x8119e2
  8034e3:	e8 c0 b0 00 00       	call   80e5a8 <_panic>
    mem_free((void *)dhcp->options_in);
  8034e8:	83 ec 0c             	sub    $0xc,%esp
  8034eb:	ff 77 14             	pushl  0x14(%edi)
  8034ee:	e8 0a 0a 00 00       	call   803efd <mem_free>
    dhcp->options_in = NULL;
  8034f3:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
  8034fa:	83 c4 10             	add    $0x10,%esp
  8034fd:	e9 75 fe ff ff       	jmp    803377 <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803502:	83 ec 04             	sub    $0x4,%esp
  803505:	68 b0 19 81 00       	push   $0x8119b0
  80350a:	68 a0 04 00 00       	push   $0x4a0
  80350f:	68 e2 19 81 00       	push   $0x8119e2
  803514:	e8 8f b0 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803519:	83 ec 04             	sub    $0x4,%esp
  80351c:	68 38 1a 81 00       	push   $0x811a38
  803521:	68 a7 04 00 00       	push   $0x4a7
  803526:	68 e2 19 81 00       	push   $0x8119e2
  80352b:	e8 78 b0 00 00       	call   80e5a8 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803530:	0f b6 07             	movzbl (%edi),%eax
  803533:	3c 01                	cmp    $0x1,%al
  803535:	74 1e                	je     803555 <dhcp_recv+0x224>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803537:	83 e8 03             	sub    $0x3,%eax
  80353a:	3c 02                	cmp    $0x2,%al
  80353c:	0f 87 35 fe ff ff    	ja     803377 <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  803542:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803548:	8b 45 08             	mov    0x8(%ebp),%eax
  80354b:	e8 e6 fb ff ff       	call   803136 <dhcp_bind>
  803550:	e9 22 fe ff ff       	jmp    803377 <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  803555:	8b 45 08             	mov    0x8(%ebp),%eax
  803558:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  80355b:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803562:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803569:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803570:	ba 33 00 00 00       	mov    $0x33,%edx
  803575:	89 f0                	mov    %esi,%eax
  803577:	e8 c9 f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80357c:	85 c0                	test   %eax,%eax
  80357e:	74 0b                	je     80358b <dhcp_recv+0x25a>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803580:	83 c0 02             	add    $0x2,%eax
  803583:	e8 cb f2 ff ff       	call   802853 <dhcp_get_option_long>
  803588:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80358b:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803590:	89 f0                	mov    %esi,%eax
  803592:	e8 ae f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803597:	85 c0                	test   %eax,%eax
  803599:	0f 84 e7 00 00 00    	je     803686 <dhcp_recv+0x355>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80359f:	83 c0 02             	add    $0x2,%eax
  8035a2:	e8 ac f2 ff ff       	call   802853 <dhcp_get_option_long>
  8035a7:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8035aa:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8035af:	89 f0                	mov    %esi,%eax
  8035b1:	e8 8f f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035b6:	85 c0                	test   %eax,%eax
  8035b8:	0f 84 d2 00 00 00    	je     803690 <dhcp_recv+0x35f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8035be:	83 c0 02             	add    $0x2,%eax
  8035c1:	e8 8d f2 ff ff       	call   802853 <dhcp_get_option_long>
  8035c6:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8035c9:	8b 56 10             	mov    0x10(%esi),%edx
  8035cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8035d1:	83 fa f0             	cmp    $0xfffffff0,%edx
  8035d4:	74 03                	je     8035d9 <dhcp_recv+0x2a8>
  8035d6:	8b 42 10             	mov    0x10(%edx),%eax
  8035d9:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8035dc:	ba 01 00 00 00       	mov    $0x1,%edx
  8035e1:	89 f0                	mov    %esi,%eax
  8035e3:	e8 5d f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8035e8:	85 c0                	test   %eax,%eax
  8035ea:	74 17                	je     803603 <dhcp_recv+0x2d2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8035ec:	83 c0 02             	add    $0x2,%eax
  8035ef:	e8 5f f2 ff ff       	call   802853 <dhcp_get_option_long>
  8035f4:	83 ec 0c             	sub    $0xc,%esp
  8035f7:	50                   	push   %eax
  8035f8:	e8 da 40 00 00       	call   8076d7 <htonl>
  8035fd:	89 46 34             	mov    %eax,0x34(%esi)
  803600:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803603:	ba 03 00 00 00       	mov    $0x3,%edx
  803608:	89 f0                	mov    %esi,%eax
  80360a:	e8 36 f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80360f:	85 c0                	test   %eax,%eax
  803611:	74 17                	je     80362a <dhcp_recv+0x2f9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803613:	83 c0 02             	add    $0x2,%eax
  803616:	e8 38 f2 ff ff       	call   802853 <dhcp_get_option_long>
  80361b:	83 ec 0c             	sub    $0xc,%esp
  80361e:	50                   	push   %eax
  80361f:	e8 b3 40 00 00       	call   8076d7 <htonl>
  803624:	89 46 38             	mov    %eax,0x38(%esi)
  803627:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80362a:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80362f:	89 f0                	mov    %esi,%eax
  803631:	e8 0f f1 ff ff       	call   802745 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803636:	85 c0                	test   %eax,%eax
  803638:	74 17                	je     803651 <dhcp_recv+0x320>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80363a:	83 c0 02             	add    $0x2,%eax
  80363d:	e8 11 f2 ff ff       	call   802853 <dhcp_get_option_long>
  803642:	83 ec 0c             	sub    $0xc,%esp
  803645:	50                   	push   %eax
  803646:	e8 8c 40 00 00       	call   8076d7 <htonl>
  80364b:	89 46 3c             	mov    %eax,0x3c(%esi)
  80364e:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803651:	ba 06 00 00 00       	mov    $0x6,%edx
  803656:	89 f0                	mov    %esi,%eax
  803658:	e8 e8 f0 ff ff       	call   802745 <dhcp_get_option_ptr>
  80365d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803660:	85 c0                	test   %eax,%eax
  803662:	74 61                	je     8036c5 <dhcp_recv+0x394>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803664:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803668:	c0 e8 02             	shr    $0x2,%al
  80366b:	0f b6 c0             	movzbl %al,%eax
  80366e:	83 f8 02             	cmp    $0x2,%eax
  803671:	ba 02 00 00 00       	mov    $0x2,%edx
  803676:	0f 47 c2             	cmova  %edx,%eax
  803679:	89 46 40             	mov    %eax,0x40(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80367c:	bb 00 00 00 00       	mov    $0x0,%ebx
  803681:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803684:	eb 34                	jmp    8036ba <dhcp_recv+0x389>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803686:	8b 46 4c             	mov    0x4c(%esi),%eax
  803689:	d1 e8                	shr    %eax
  80368b:	e9 17 ff ff ff       	jmp    8035a7 <dhcp_recv+0x276>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803690:	8b 46 4c             	mov    0x4c(%esi),%eax
  803693:	e9 2e ff ff ff       	jmp    8035c6 <dhcp_recv+0x295>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803698:	0f b6 fb             	movzbl %bl,%edi
  80369b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80369e:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  8036a2:	e8 ac f1 ff ff       	call   802853 <dhcp_get_option_long>
  8036a7:	83 ec 0c             	sub    $0xc,%esp
  8036aa:	50                   	push   %eax
  8036ab:	e8 27 40 00 00       	call   8076d7 <htonl>
  8036b0:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  8036b4:	83 c3 01             	add    $0x1,%ebx
  8036b7:	83 c4 10             	add    $0x10,%esp
  8036ba:	0f b6 c3             	movzbl %bl,%eax
  8036bd:	3b 46 40             	cmp    0x40(%esi),%eax
  8036c0:	72 d6                	jb     803698 <dhcp_recv+0x367>
  8036c2:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  8036c5:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8036cb:	8b 45 08             	mov    0x8(%ebp),%eax
  8036ce:	e8 2f fa ff ff       	call   803102 <dhcp_check>
  8036d3:	e9 9f fc ff ff       	jmp    803377 <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8036d8:	0f b6 07             	movzbl (%edi),%eax
  8036db:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8036de:	80 fa 02             	cmp    $0x2,%dl
  8036e1:	76 08                	jbe    8036eb <dhcp_recv+0x3ba>
  8036e3:	3c 01                	cmp    $0x1,%al
  8036e5:	0f 85 8c fc ff ff    	jne    803377 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  8036eb:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  8036f1:	8b 45 08             	mov    0x8(%ebp),%eax
  8036f4:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  8036f7:	83 ec 0c             	sub    $0xc,%esp
  8036fa:	50                   	push   %eax
  8036fb:	e8 f1 0f 00 00       	call   8046f1 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803700:	83 c4 08             	add    $0x8,%esp
  803703:	68 88 22 81 00       	push   $0x812288
  803708:	ff 75 08             	pushl  0x8(%ebp)
  80370b:	e8 43 0e 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803710:	83 c4 08             	add    $0x8,%esp
  803713:	68 88 22 81 00       	push   $0x812288
  803718:	ff 75 08             	pushl  0x8(%ebp)
  80371b:	e8 5f 0f 00 00       	call   80467f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803720:	83 c4 08             	add    $0x8,%esp
  803723:	68 88 22 81 00       	push   $0x812288
  803728:	ff 75 08             	pushl  0x8(%ebp)
  80372b:	e8 68 0f 00 00       	call   804698 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803730:	ba 0c 00 00 00       	mov    $0xc,%edx
  803735:	89 d8                	mov    %ebx,%eax
  803737:	e8 fe ef ff ff       	call   80273a <dhcp_set_state>
  dhcp_discover(netif);
  80373c:	8b 45 08             	mov    0x8(%ebp),%eax
  80373f:	e8 03 f7 ff ff       	call   802e47 <dhcp_discover>
  803744:	83 c4 10             	add    $0x10,%esp
  803747:	e9 2b fc ff ff       	jmp    803377 <dhcp_recv+0x46>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80374c:	b8 00 00 00 00       	mov    $0x0,%eax
  803751:	e9 6b fd ff ff       	jmp    8034c1 <dhcp_recv+0x190>

00803756 <dhcp_inform>:
{
  803756:	55                   	push   %ebp
  803757:	89 e5                	mov    %esp,%ebp
  803759:	57                   	push   %edi
  80375a:	56                   	push   %esi
  80375b:	53                   	push   %ebx
  80375c:	83 ec 18             	sub    $0x18,%esp
  80375f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803762:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803765:	6a 58                	push   $0x58
  803767:	e8 80 0a 00 00       	call   8041ec <mem_malloc>
  if (dhcp == NULL) {
  80376c:	83 c4 10             	add    $0x10,%esp
  80376f:	85 c0                	test   %eax,%eax
  803771:	74 55                	je     8037c8 <dhcp_inform+0x72>
  803773:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803775:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803778:	83 ec 04             	sub    $0x4,%esp
  80377b:	6a 58                	push   $0x58
  80377d:	6a 00                	push   $0x0
  80377f:	50                   	push   %eax
  803780:	e8 be b7 00 00       	call   80ef43 <memset>
  dhcp->pcb = udp_new();
  803785:	e8 2a 58 00 00       	call   808fb4 <udp_new>
  80378a:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  80378d:	83 c4 10             	add    $0x10,%esp
  803790:	85 c0                	test   %eax,%eax
  803792:	74 3c                	je     8037d0 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  803794:	89 f0                	mov    %esi,%eax
  803796:	e8 2c f3 ff ff       	call   802ac7 <dhcp_create_request>
  if (result == ERR_OK) {
  80379b:	84 c0                	test   %al,%al
  80379d:	74 3f                	je     8037de <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  80379f:	8b 43 08             	mov    0x8(%ebx),%eax
  8037a2:	85 c0                	test   %eax,%eax
  8037a4:	74 0c                	je     8037b2 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  8037a6:	83 ec 0c             	sub    $0xc,%esp
  8037a9:	50                   	push   %eax
  8037aa:	e8 c1 57 00 00       	call   808f70 <udp_remove>
  8037af:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  8037b2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8037b9:	83 ec 0c             	sub    $0xc,%esp
  8037bc:	53                   	push   %ebx
  8037bd:	e8 3b 07 00 00       	call   803efd <mem_free>
    netif->dhcp = old_dhcp;
  8037c2:	89 7e 20             	mov    %edi,0x20(%esi)
  8037c5:	83 c4 10             	add    $0x10,%esp
}
  8037c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8037cb:	5b                   	pop    %ebx
  8037cc:	5e                   	pop    %esi
  8037cd:	5f                   	pop    %edi
  8037ce:	5d                   	pop    %ebp
  8037cf:	c3                   	ret    
    mem_free((void *)dhcp);
  8037d0:	83 ec 0c             	sub    $0xc,%esp
  8037d3:	53                   	push   %ebx
  8037d4:	e8 24 07 00 00       	call   803efd <mem_free>
    return;
  8037d9:	83 c4 10             	add    $0x10,%esp
  8037dc:	eb ea                	jmp    8037c8 <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8037de:	b9 01 00 00 00       	mov    $0x1,%ecx
  8037e3:	ba 35 00 00 00       	mov    $0x35,%edx
  8037e8:	89 d8                	mov    %ebx,%eax
  8037ea:	e8 c6 f0 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  8037ef:	ba 08 00 00 00       	mov    $0x8,%edx
  8037f4:	89 d8                	mov    %ebx,%eax
  8037f6:	e8 79 f0 ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8037fb:	b9 02 00 00 00       	mov    $0x2,%ecx
  803800:	ba 39 00 00 00       	mov    $0x39,%edx
  803805:	89 d8                	mov    %ebx,%eax
  803807:	e8 a9 f0 ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80380c:	ba 40 02 00 00       	mov    $0x240,%edx
  803811:	89 d8                	mov    %ebx,%eax
  803813:	e8 04 f1 ff ff       	call   80291c <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803818:	89 d8                	mov    %ebx,%eax
  80381a:	e8 5b f1 ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80381f:	83 ec 08             	sub    $0x8,%esp
  803822:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803826:	66 05 f0 00          	add    $0xf0,%ax
  80382a:	0f b7 c0             	movzwl %ax,%eax
  80382d:	50                   	push   %eax
  80382e:	ff 73 1c             	pushl  0x1c(%ebx)
  803831:	e8 e5 12 00 00       	call   804b1b <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803836:	83 c4 0c             	add    $0xc,%esp
  803839:	6a 44                	push   $0x44
  80383b:	68 88 22 81 00       	push   $0x812288
  803840:	ff 73 08             	pushl  0x8(%ebx)
  803843:	e8 d8 53 00 00       	call   808c20 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803848:	83 c4 0c             	add    $0xc,%esp
  80384b:	6a 43                	push   $0x43
  80384d:	68 84 22 81 00       	push   $0x812284
  803852:	ff 73 08             	pushl  0x8(%ebx)
  803855:	e8 76 56 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80385a:	89 34 24             	mov    %esi,(%esp)
  80385d:	6a 43                	push   $0x43
  80385f:	68 84 22 81 00       	push   $0x812284
  803864:	ff 73 1c             	pushl  0x1c(%ebx)
  803867:	ff 73 08             	pushl  0x8(%ebx)
  80386a:	e8 6c 54 00 00       	call   808cdb <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80386f:	83 c4 1c             	add    $0x1c,%esp
  803872:	6a 43                	push   $0x43
  803874:	68 88 22 81 00       	push   $0x812288
  803879:	ff 73 08             	pushl  0x8(%ebx)
  80387c:	e8 4f 56 00 00       	call   808ed0 <udp_connect>
    dhcp_delete_request(netif);
  803881:	89 f0                	mov    %esi,%eax
  803883:	e8 32 f4 ff ff       	call   802cba <dhcp_delete_request>
  803888:	83 c4 10             	add    $0x10,%esp
  80388b:	e9 0f ff ff ff       	jmp    80379f <dhcp_inform+0x49>

00803890 <dhcp_arp_reply>:
{
  803890:	55                   	push   %ebp
  803891:	89 e5                	mov    %esp,%ebp
  803893:	56                   	push   %esi
  803894:	53                   	push   %ebx
  803895:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803898:	85 f6                	test   %esi,%esi
  80389a:	74 13                	je     8038af <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80389c:	8b 5e 20             	mov    0x20(%esi),%ebx
  80389f:	85 db                	test   %ebx,%ebx
  8038a1:	74 05                	je     8038a8 <dhcp_arp_reply+0x18>
  8038a3:	80 3b 08             	cmpb   $0x8,(%ebx)
  8038a6:	74 1e                	je     8038c6 <dhcp_arp_reply+0x36>
}
  8038a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8038ab:	5b                   	pop    %ebx
  8038ac:	5e                   	pop    %esi
  8038ad:	5d                   	pop    %ebp
  8038ae:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8038af:	83 ec 04             	sub    $0x4,%esp
  8038b2:	68 02 1a 81 00       	push   $0x811a02
  8038b7:	68 b5 02 00 00       	push   $0x2b5
  8038bc:	68 e2 19 81 00       	push   $0x8119e2
  8038c1:	e8 e2 ac 00 00       	call   80e5a8 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  8038c6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8038c9:	8b 4b 30             	mov    0x30(%ebx),%ecx
  8038cc:	39 08                	cmp    %ecx,(%eax)
  8038ce:	75 d8                	jne    8038a8 <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8038d0:	ba 0c 00 00 00       	mov    $0xc,%edx
  8038d5:	89 d8                	mov    %ebx,%eax
  8038d7:	e8 5e ee ff ff       	call   80273a <dhcp_set_state>
  result = dhcp_create_request(netif);
  8038dc:	89 f0                	mov    %esi,%eax
  8038de:	e8 e4 f1 ff ff       	call   802ac7 <dhcp_create_request>
  if (result == ERR_OK) {
  8038e3:	84 c0                	test   %al,%al
  8038e5:	74 0c                	je     8038f3 <dhcp_arp_reply+0x63>
  dhcp->tries++;
  8038e7:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8038eb:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  8038f1:	eb b5                	jmp    8038a8 <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8038f3:	b9 01 00 00 00       	mov    $0x1,%ecx
  8038f8:	ba 35 00 00 00       	mov    $0x35,%edx
  8038fd:	89 d8                	mov    %ebx,%eax
  8038ff:	e8 b1 ef ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803904:	ba 04 00 00 00       	mov    $0x4,%edx
  803909:	89 d8                	mov    %ebx,%eax
  80390b:	e8 64 ef ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803910:	b9 02 00 00 00       	mov    $0x2,%ecx
  803915:	ba 39 00 00 00       	mov    $0x39,%edx
  80391a:	89 d8                	mov    %ebx,%eax
  80391c:	e8 94 ef ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803921:	ba 40 02 00 00       	mov    $0x240,%edx
  803926:	89 d8                	mov    %ebx,%eax
  803928:	e8 ef ef ff ff       	call   80291c <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80392d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803932:	ba 32 00 00 00       	mov    $0x32,%edx
  803937:	89 d8                	mov    %ebx,%eax
  803939:	e8 77 ef ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80393e:	83 ec 0c             	sub    $0xc,%esp
  803941:	ff 73 30             	pushl  0x30(%ebx)
  803944:	e8 a5 3f 00 00       	call   8078ee <ntohl>
  803949:	89 c2                	mov    %eax,%edx
  80394b:	89 d8                	mov    %ebx,%eax
  80394d:	e8 dd f0 ff ff       	call   802a2f <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803952:	89 d8                	mov    %ebx,%eax
  803954:	e8 21 f0 ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803959:	83 c4 08             	add    $0x8,%esp
  80395c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803960:	66 05 f0 00          	add    $0xf0,%ax
  803964:	0f b7 c0             	movzwl %ax,%eax
  803967:	50                   	push   %eax
  803968:	ff 73 1c             	pushl  0x1c(%ebx)
  80396b:	e8 ab 11 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803970:	83 c4 0c             	add    $0xc,%esp
  803973:	6a 43                	push   $0x43
  803975:	68 88 22 81 00       	push   $0x812288
  80397a:	ff 73 08             	pushl  0x8(%ebx)
  80397d:	e8 4e 55 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803982:	89 34 24             	mov    %esi,(%esp)
  803985:	6a 43                	push   $0x43
  803987:	68 84 22 81 00       	push   $0x812284
  80398c:	ff 73 1c             	pushl  0x1c(%ebx)
  80398f:	ff 73 08             	pushl  0x8(%ebx)
  803992:	e8 44 53 00 00       	call   808cdb <udp_sendto_if>
    dhcp_delete_request(netif);
  803997:	83 c4 20             	add    $0x20,%esp
  80399a:	89 f0                	mov    %esi,%eax
  80399c:	e8 19 f3 ff ff       	call   802cba <dhcp_delete_request>
  8039a1:	e9 41 ff ff ff       	jmp    8038e7 <dhcp_arp_reply+0x57>

008039a6 <dhcp_renew>:
{
  8039a6:	55                   	push   %ebp
  8039a7:	89 e5                	mov    %esp,%ebp
  8039a9:	57                   	push   %edi
  8039aa:	56                   	push   %esi
  8039ab:	53                   	push   %ebx
  8039ac:	83 ec 1c             	sub    $0x1c,%esp
  8039af:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8039b2:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  8039b5:	ba 05 00 00 00       	mov    $0x5,%edx
  8039ba:	89 d8                	mov    %ebx,%eax
  8039bc:	e8 79 ed ff ff       	call   80273a <dhcp_set_state>
  result = dhcp_create_request(netif);
  8039c1:	89 f0                	mov    %esi,%eax
  8039c3:	e8 ff f0 ff ff       	call   802ac7 <dhcp_create_request>
  8039c8:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  8039ca:	84 c0                	test   %al,%al
  8039cc:	74 3e                	je     803a0c <dhcp_renew+0x66>
  dhcp->tries++;
  8039ce:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8039d2:	83 c0 01             	add    $0x1,%eax
  8039d5:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8039d8:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  8039dd:	3c 09                	cmp    $0x9,%al
  8039df:	77 08                	ja     8039e9 <dhcp_renew+0x43>
  8039e1:	0f b6 d0             	movzbl %al,%edx
  8039e4:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8039e9:	0f b7 d2             	movzwl %dx,%edx
  8039ec:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8039f2:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8039f7:	89 d0                	mov    %edx,%eax
  8039f9:	f7 e9                	imul   %ecx
  8039fb:	c1 fa 05             	sar    $0x5,%edx
  8039fe:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803a02:	89 f8                	mov    %edi,%eax
  803a04:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803a07:	5b                   	pop    %ebx
  803a08:	5e                   	pop    %esi
  803a09:	5f                   	pop    %edi
  803a0a:	5d                   	pop    %ebp
  803a0b:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803a0c:	b9 01 00 00 00       	mov    $0x1,%ecx
  803a11:	ba 35 00 00 00       	mov    $0x35,%edx
  803a16:	89 d8                	mov    %ebx,%eax
  803a18:	e8 98 ee ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803a1d:	ba 03 00 00 00       	mov    $0x3,%edx
  803a22:	89 d8                	mov    %ebx,%eax
  803a24:	e8 4b ee ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a29:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a2e:	ba 39 00 00 00       	mov    $0x39,%edx
  803a33:	89 d8                	mov    %ebx,%eax
  803a35:	e8 7b ee ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803a3a:	ba 40 02 00 00       	mov    $0x240,%edx
  803a3f:	89 d8                	mov    %ebx,%eax
  803a41:	e8 d6 ee ff ff       	call   80291c <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803a46:	89 d8                	mov    %ebx,%eax
  803a48:	e8 2d ef ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a4d:	83 ec 08             	sub    $0x8,%esp
  803a50:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a54:	66 05 f0 00          	add    $0xf0,%ax
  803a58:	0f b7 c0             	movzwl %ax,%eax
  803a5b:	50                   	push   %eax
  803a5c:	ff 73 1c             	pushl  0x1c(%ebx)
  803a5f:	e8 b7 10 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803a64:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803a67:	83 c4 0c             	add    $0xc,%esp
  803a6a:	6a 43                	push   $0x43
  803a6c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803a6f:	50                   	push   %eax
  803a70:	ff 73 08             	pushl  0x8(%ebx)
  803a73:	e8 58 54 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803a78:	89 34 24             	mov    %esi,(%esp)
  803a7b:	6a 43                	push   $0x43
  803a7d:	ff 75 e4             	pushl  -0x1c(%ebp)
  803a80:	ff 73 1c             	pushl  0x1c(%ebx)
  803a83:	ff 73 08             	pushl  0x8(%ebx)
  803a86:	e8 50 52 00 00       	call   808cdb <udp_sendto_if>
    dhcp_delete_request(netif);
  803a8b:	83 c4 20             	add    $0x20,%esp
  803a8e:	89 f0                	mov    %esi,%eax
  803a90:	e8 25 f2 ff ff       	call   802cba <dhcp_delete_request>
  803a95:	e9 34 ff ff ff       	jmp    8039ce <dhcp_renew+0x28>

00803a9a <dhcp_coarse_tmr>:
{
  803a9a:	55                   	push   %ebp
  803a9b:	89 e5                	mov    %esp,%ebp
  803a9d:	53                   	push   %ebx
  803a9e:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803aa1:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803aa7:	eb 1d                	jmp    803ac6 <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803aa9:	8b 43 20             	mov    0x20(%ebx),%eax
  803aac:	0f b6 00             	movzbl (%eax),%eax
  803aaf:	89 c2                	mov    %eax,%edx
  803ab1:	83 e2 fb             	and    $0xfffffffb,%edx
  803ab4:	80 fa 01             	cmp    $0x1,%dl
  803ab7:	74 04                	je     803abd <dhcp_coarse_tmr+0x23>
  803ab9:	3c 0a                	cmp    $0xa,%al
  803abb:	75 07                	jne    803ac4 <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803abd:	89 d8                	mov    %ebx,%eax
  803abf:	e8 90 f2 ff ff       	call   802d54 <dhcp_rebind>
    netif = netif->next;
  803ac4:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803ac6:	85 db                	test   %ebx,%ebx
  803ac8:	74 4e                	je     803b18 <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803aca:	8b 43 20             	mov    0x20(%ebx),%eax
  803acd:	85 c0                	test   %eax,%eax
  803acf:	74 f3                	je     803ac4 <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803ad1:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803ad5:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803ad8:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803adc:	66 83 fa 01          	cmp    $0x1,%dx
  803ae0:	74 c7                	je     803aa9 <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803ae2:	8b 53 20             	mov    0x20(%ebx),%edx
  803ae5:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803ae9:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803aec:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803af0:	66 83 f8 01          	cmp    $0x1,%ax
  803af4:	75 ce                	jne    803ac4 <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803af6:	8b 43 20             	mov    0x20(%ebx),%eax
  803af9:	0f b6 00             	movzbl (%eax),%eax
  803afc:	89 c2                	mov    %eax,%edx
  803afe:	83 e2 fb             	and    $0xfffffffb,%edx
  803b01:	80 fa 01             	cmp    $0x1,%dl
  803b04:	74 04                	je     803b0a <dhcp_coarse_tmr+0x70>
  803b06:	3c 0a                	cmp    $0xa,%al
  803b08:	75 ba                	jne    803ac4 <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803b0a:	83 ec 0c             	sub    $0xc,%esp
  803b0d:	53                   	push   %ebx
  803b0e:	e8 93 fe ff ff       	call   8039a6 <dhcp_renew>
  803b13:	83 c4 10             	add    $0x10,%esp
  803b16:	eb ac                	jmp    803ac4 <dhcp_coarse_tmr+0x2a>
}
  803b18:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803b1b:	c9                   	leave  
  803b1c:	c3                   	ret    

00803b1d <dhcp_release>:
{
  803b1d:	55                   	push   %ebp
  803b1e:	89 e5                	mov    %esp,%ebp
  803b20:	57                   	push   %edi
  803b21:	56                   	push   %esi
  803b22:	53                   	push   %ebx
  803b23:	83 ec 1c             	sub    $0x1c,%esp
  803b26:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803b29:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803b2c:	ba 0d 00 00 00       	mov    $0xd,%edx
  803b31:	89 d8                	mov    %ebx,%eax
  803b33:	e8 02 ec ff ff       	call   80273a <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803b38:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803b3f:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803b46:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803b4d:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803b54:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803b5b:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803b62:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803b69:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803b70:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803b77:	89 f0                	mov    %esi,%eax
  803b79:	e8 49 ef ff ff       	call   802ac7 <dhcp_create_request>
  803b7e:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803b80:	84 c0                	test   %al,%al
  803b82:	74 71                	je     803bf5 <dhcp_release+0xd8>
  dhcp->tries++;
  803b84:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803b88:	83 c0 01             	add    $0x1,%eax
  803b8b:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803b8e:	ba 10 27 00 00       	mov    $0x2710,%edx
  803b93:	3c 09                	cmp    $0x9,%al
  803b95:	77 08                	ja     803b9f <dhcp_release+0x82>
  803b97:	0f b6 d0             	movzbl %al,%edx
  803b9a:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803b9f:	0f b7 d2             	movzwl %dx,%edx
  803ba2:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803ba8:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803bad:	89 d0                	mov    %edx,%eax
  803baf:	f7 e9                	imul   %ecx
  803bb1:	c1 fa 05             	sar    $0x5,%edx
  803bb4:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803bb8:	83 ec 0c             	sub    $0xc,%esp
  803bbb:	56                   	push   %esi
  803bbc:	e8 30 0b 00 00       	call   8046f1 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803bc1:	83 c4 08             	add    $0x8,%esp
  803bc4:	68 88 22 81 00       	push   $0x812288
  803bc9:	56                   	push   %esi
  803bca:	e8 84 09 00 00       	call   804553 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803bcf:	83 c4 08             	add    $0x8,%esp
  803bd2:	68 88 22 81 00       	push   $0x812288
  803bd7:	56                   	push   %esi
  803bd8:	e8 a2 0a 00 00       	call   80467f <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803bdd:	83 c4 08             	add    $0x8,%esp
  803be0:	68 88 22 81 00       	push   $0x812288
  803be5:	56                   	push   %esi
  803be6:	e8 ad 0a 00 00       	call   804698 <netif_set_netmask>
}
  803beb:	89 f8                	mov    %edi,%eax
  803bed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803bf0:	5b                   	pop    %ebx
  803bf1:	5e                   	pop    %esi
  803bf2:	5f                   	pop    %edi
  803bf3:	5d                   	pop    %ebp
  803bf4:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803bf5:	b9 01 00 00 00       	mov    $0x1,%ecx
  803bfa:	ba 35 00 00 00       	mov    $0x35,%edx
  803bff:	89 d8                	mov    %ebx,%eax
  803c01:	e8 af ec ff ff       	call   8028b5 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803c06:	ba 07 00 00 00       	mov    $0x7,%edx
  803c0b:	89 d8                	mov    %ebx,%eax
  803c0d:	e8 62 ec ff ff       	call   802874 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803c12:	89 d8                	mov    %ebx,%eax
  803c14:	e8 61 ed ff ff       	call   80297a <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c19:	83 ec 08             	sub    $0x8,%esp
  803c1c:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c20:	66 05 f0 00          	add    $0xf0,%ax
  803c24:	0f b7 c0             	movzwl %ax,%eax
  803c27:	50                   	push   %eax
  803c28:	ff 73 1c             	pushl  0x1c(%ebx)
  803c2b:	e8 eb 0e 00 00       	call   804b1b <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c30:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c33:	83 c4 0c             	add    $0xc,%esp
  803c36:	6a 43                	push   $0x43
  803c38:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c3b:	50                   	push   %eax
  803c3c:	ff 73 08             	pushl  0x8(%ebx)
  803c3f:	e8 8c 52 00 00       	call   808ed0 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c44:	89 34 24             	mov    %esi,(%esp)
  803c47:	6a 43                	push   $0x43
  803c49:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c4c:	ff 73 1c             	pushl  0x1c(%ebx)
  803c4f:	ff 73 08             	pushl  0x8(%ebx)
  803c52:	e8 84 50 00 00       	call   808cdb <udp_sendto_if>
    dhcp_delete_request(netif);
  803c57:	83 c4 20             	add    $0x20,%esp
  803c5a:	89 f0                	mov    %esi,%eax
  803c5c:	e8 59 f0 ff ff       	call   802cba <dhcp_delete_request>
  803c61:	e9 1e ff ff ff       	jmp    803b84 <dhcp_release+0x67>

00803c66 <dhcp_fine_tmr>:
{
  803c66:	55                   	push   %ebp
  803c67:	89 e5                	mov    %esp,%ebp
  803c69:	53                   	push   %ebx
  803c6a:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803c6d:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803c73:	eb 04                	jmp    803c79 <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803c75:	74 24                	je     803c9b <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803c77:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803c79:	85 db                	test   %ebx,%ebx
  803c7b:	0f 84 c4 00 00 00    	je     803d45 <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803c81:	8b 43 20             	mov    0x20(%ebx),%eax
  803c84:	85 c0                	test   %eax,%eax
  803c86:	74 ef                	je     803c77 <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803c88:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803c8c:	66 83 fa 01          	cmp    $0x1,%dx
  803c90:	76 e3                	jbe    803c75 <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803c92:	83 ea 01             	sub    $0x1,%edx
  803c95:	66 89 50 26          	mov    %dx,0x26(%eax)
  803c99:	eb dc                	jmp    803c77 <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803c9b:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803ca1:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803ca4:	0f b6 02             	movzbl (%edx),%eax
  803ca7:	3c 0c                	cmp    $0xc,%al
  803ca9:	74 23                	je     803cce <dhcp_fine_tmr+0x68>
  803cab:	3c 06                	cmp    $0x6,%al
  803cad:	74 1f                	je     803cce <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803caf:	3c 01                	cmp    $0x1,%al
  803cb1:	74 24                	je     803cd7 <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803cb3:	3c 08                	cmp    $0x8,%al
  803cb5:	74 47                	je     803cfe <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803cb7:	3c 05                	cmp    $0x5,%al
  803cb9:	74 61                	je     803d1c <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803cbb:	3c 04                	cmp    $0x4,%al
  803cbd:	75 b8                	jne    803c77 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803cbf:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803cc3:	77 68                	ja     803d2d <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803cc5:	89 d8                	mov    %ebx,%eax
  803cc7:	e8 88 f0 ff ff       	call   802d54 <dhcp_rebind>
  803ccc:	eb a9                	jmp    803c77 <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803cce:	89 d8                	mov    %ebx,%eax
  803cd0:	e8 72 f1 ff ff       	call   802e47 <dhcp_discover>
  803cd5:	eb a0                	jmp    803c77 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803cd7:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803cdb:	77 09                	ja     803ce6 <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803cdd:	89 d8                	mov    %ebx,%eax
  803cdf:	e8 a2 f2 ff ff       	call   802f86 <dhcp_select>
  803ce4:	eb 91                	jmp    803c77 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803ce6:	83 ec 0c             	sub    $0xc,%esp
  803ce9:	53                   	push   %ebx
  803cea:	e8 2e fe ff ff       	call   803b1d <dhcp_release>
      dhcp_discover(netif);
  803cef:	89 d8                	mov    %ebx,%eax
  803cf1:	e8 51 f1 ff ff       	call   802e47 <dhcp_discover>
  803cf6:	83 c4 10             	add    $0x10,%esp
  803cf9:	e9 79 ff ff ff       	jmp    803c77 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803cfe:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803d02:	76 0c                	jbe    803d10 <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803d04:	89 d8                	mov    %ebx,%eax
  803d06:	e8 2b f4 ff ff       	call   803136 <dhcp_bind>
  803d0b:	e9 67 ff ff ff       	jmp    803c77 <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803d10:	89 d8                	mov    %ebx,%eax
  803d12:	e8 eb f3 ff ff       	call   803102 <dhcp_check>
  803d17:	e9 5b ff ff ff       	jmp    803c77 <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803d1c:	83 ec 0c             	sub    $0xc,%esp
  803d1f:	53                   	push   %ebx
  803d20:	e8 81 fc ff ff       	call   8039a6 <dhcp_renew>
  803d25:	83 c4 10             	add    $0x10,%esp
  803d28:	e9 4a ff ff ff       	jmp    803c77 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803d2d:	83 ec 0c             	sub    $0xc,%esp
  803d30:	53                   	push   %ebx
  803d31:	e8 e7 fd ff ff       	call   803b1d <dhcp_release>
      dhcp_discover(netif);
  803d36:	89 d8                	mov    %ebx,%eax
  803d38:	e8 0a f1 ff ff       	call   802e47 <dhcp_discover>
  803d3d:	83 c4 10             	add    $0x10,%esp
  803d40:	e9 32 ff ff ff       	jmp    803c77 <dhcp_fine_tmr+0x11>
}
  803d45:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803d48:	c9                   	leave  
  803d49:	c3                   	ret    

00803d4a <dhcp_stop>:
{
  803d4a:	55                   	push   %ebp
  803d4b:	89 e5                	mov    %esp,%ebp
  803d4d:	56                   	push   %esi
  803d4e:	53                   	push   %ebx
  803d4f:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d52:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803d55:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803d59:	85 db                	test   %ebx,%ebx
  803d5b:	74 4e                	je     803dab <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803d5d:	8b 43 08             	mov    0x8(%ebx),%eax
  803d60:	85 c0                	test   %eax,%eax
  803d62:	74 13                	je     803d77 <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803d64:	83 ec 0c             	sub    $0xc,%esp
  803d67:	50                   	push   %eax
  803d68:	e8 03 52 00 00       	call   808f70 <udp_remove>
      dhcp->pcb = NULL;
  803d6d:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803d74:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803d77:	8b 43 0c             	mov    0xc(%ebx),%eax
  803d7a:	85 c0                	test   %eax,%eax
  803d7c:	74 13                	je     803d91 <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803d7e:	83 ec 0c             	sub    $0xc,%esp
  803d81:	50                   	push   %eax
  803d82:	e8 5c 0a 00 00       	call   8047e3 <pbuf_free>
      dhcp->p = NULL;
  803d87:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803d8e:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803d91:	89 d8                	mov    %ebx,%eax
  803d93:	e8 51 f5 ff ff       	call   8032e9 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803d98:	83 ec 0c             	sub    $0xc,%esp
  803d9b:	53                   	push   %ebx
  803d9c:	e8 5c 01 00 00       	call   803efd <mem_free>
    netif->dhcp = NULL;
  803da1:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803da8:	83 c4 10             	add    $0x10,%esp
}
  803dab:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803dae:	5b                   	pop    %ebx
  803daf:	5e                   	pop    %esi
  803db0:	5d                   	pop    %ebp
  803db1:	c3                   	ret    

00803db2 <dhcp_start>:
{
  803db2:	55                   	push   %ebp
  803db3:	89 e5                	mov    %esp,%ebp
  803db5:	56                   	push   %esi
  803db6:	53                   	push   %ebx
  803db7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803dba:	85 db                	test   %ebx,%ebx
  803dbc:	74 73                	je     803e31 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803dbe:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803dc1:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803dc5:	85 f6                	test   %esi,%esi
  803dc7:	74 7f                	je     803e48 <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803dc9:	83 ec 04             	sub    $0x4,%esp
  803dcc:	6a 58                	push   $0x58
  803dce:	6a 00                	push   $0x0
  803dd0:	56                   	push   %esi
  803dd1:	e8 6d b1 00 00       	call   80ef43 <memset>
  dhcp->pcb = udp_new();
  803dd6:	e8 d9 51 00 00       	call   808fb4 <udp_new>
  803ddb:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803dde:	83 c4 10             	add    $0x10,%esp
  803de1:	85 c0                	test   %eax,%eax
  803de3:	74 7e                	je     803e63 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803de5:	83 ec 04             	sub    $0x4,%esp
  803de8:	6a 44                	push   $0x44
  803dea:	68 88 22 81 00       	push   $0x812288
  803def:	50                   	push   %eax
  803df0:	e8 2b 4e 00 00       	call   808c20 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803df5:	83 c4 0c             	add    $0xc,%esp
  803df8:	6a 43                	push   $0x43
  803dfa:	68 88 22 81 00       	push   $0x812288
  803dff:	ff 76 08             	pushl  0x8(%esi)
  803e02:	e8 c9 50 00 00       	call   808ed0 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803e07:	83 c4 0c             	add    $0xc,%esp
  803e0a:	53                   	push   %ebx
  803e0b:	68 31 33 80 00       	push   $0x803331
  803e10:	ff 76 08             	pushl  0x8(%esi)
  803e13:	e8 44 51 00 00       	call   808f5c <udp_recv>
  result = dhcp_discover(netif);
  803e18:	89 d8                	mov    %ebx,%eax
  803e1a:	e8 28 f0 ff ff       	call   802e47 <dhcp_discover>
  if (result != ERR_OK) {
  803e1f:	83 c4 10             	add    $0x10,%esp
  803e22:	84 c0                	test   %al,%al
  803e24:	75 57                	jne    803e7d <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803e26:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803e2a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e2d:	5b                   	pop    %ebx
  803e2e:	5e                   	pop    %esi
  803e2f:	5d                   	pop    %ebp
  803e30:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e31:	83 ec 04             	sub    $0x4,%esp
  803e34:	68 02 1a 81 00       	push   $0x811a02
  803e39:	68 38 02 00 00       	push   $0x238
  803e3e:	68 e2 19 81 00       	push   $0x8119e2
  803e43:	e8 60 a7 00 00       	call   80e5a8 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803e48:	83 ec 0c             	sub    $0xc,%esp
  803e4b:	6a 58                	push   $0x58
  803e4d:	e8 9a 03 00 00       	call   8041ec <mem_malloc>
  803e52:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803e54:	83 c4 10             	add    $0x10,%esp
  803e57:	85 c0                	test   %eax,%eax
  803e59:	74 35                	je     803e90 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803e5b:	89 43 20             	mov    %eax,0x20(%ebx)
  803e5e:	e9 66 ff ff ff       	jmp    803dc9 <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803e63:	83 ec 0c             	sub    $0xc,%esp
  803e66:	56                   	push   %esi
  803e67:	e8 91 00 00 00       	call   803efd <mem_free>
    netif->dhcp = dhcp = NULL;
  803e6c:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803e73:	83 c4 10             	add    $0x10,%esp
  803e76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e7b:	eb ad                	jmp    803e2a <dhcp_start+0x78>
    dhcp_stop(netif);
  803e7d:	83 ec 0c             	sub    $0xc,%esp
  803e80:	53                   	push   %ebx
  803e81:	e8 c4 fe ff ff       	call   803d4a <dhcp_stop>
    return ERR_MEM;
  803e86:	83 c4 10             	add    $0x10,%esp
  803e89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e8e:	eb 9a                	jmp    803e2a <dhcp_start+0x78>
      return ERR_MEM;
  803e90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e95:	eb 93                	jmp    803e2a <dhcp_start+0x78>

00803e97 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803e97:	55                   	push   %ebp
  803e98:	89 e5                	mov    %esp,%ebp
  803e9a:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803e9d:	b8 23 53 81 00       	mov    $0x815323,%eax
  803ea2:	83 e0 fc             	and    $0xfffffffc,%eax
  803ea5:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803eaa:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803eb0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803eb7:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803ebb:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803ec1:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803ec7:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803ece:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803ed5:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803ed8:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803edf:	00 22 00 

  mem_sem = sys_sem_new(1);
  803ee2:	6a 01                	push   $0x1
  803ee4:	e8 ad 5e 00 00       	call   809d96 <sys_sem_new>
  803ee9:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803eee:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803ef3:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803ef8:	83 c4 10             	add    $0x10,%esp
  803efb:	c9                   	leave  
  803efc:	c3                   	ret    

00803efd <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803efd:	55                   	push   %ebp
  803efe:	89 e5                	mov    %esp,%ebp
  803f00:	56                   	push   %esi
  803f01:	53                   	push   %ebx
  803f02:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803f05:	85 db                	test   %ebx,%ebx
  803f07:	0f 84 e1 00 00 00    	je     803fee <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803f0d:	f6 c3 03             	test   $0x3,%bl
  803f10:	0f 85 df 00 00 00    	jne    803ff5 <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803f16:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  803f1c:	0f 87 ea 00 00 00    	ja     80400c <mem_free+0x10f>
  803f22:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  803f28:	0f 86 de 00 00 00    	jbe    80400c <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803f2e:	83 ec 08             	sub    $0x8,%esp
  803f31:	6a 00                	push   $0x0
  803f33:	ff 35 00 53 81 00    	pushl  0x815300
  803f39:	e8 85 61 00 00       	call   80a0c3 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803f3e:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803f41:	83 c4 10             	add    $0x10,%esp
  803f44:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803f48:	0f 84 d5 00 00 00    	je     804023 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  803f4e:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803f52:	39 05 04 53 81 00    	cmp    %eax,0x815304
  803f58:	76 05                	jbe    803f5f <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  803f5a:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  803f5f:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  803f65:	39 c8                	cmp    %ecx,%eax
  803f67:	0f 82 cd 00 00 00    	jb     80403a <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  803f6d:	8b 35 08 53 81 00    	mov    0x815308,%esi
  803f73:	39 f0                	cmp    %esi,%eax
  803f75:	0f 83 d6 00 00 00    	jae    804051 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  803f7b:	8b 53 f4             	mov    -0xc(%ebx),%edx
  803f7e:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  803f84:	0f 87 de 00 00 00    	ja     804068 <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  803f8a:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  803f8c:	39 d0                	cmp    %edx,%eax
  803f8e:	74 25                	je     803fb5 <mem_free+0xb8>
  803f90:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803f94:	75 1f                	jne    803fb5 <mem_free+0xb8>
  803f96:	39 d6                	cmp    %edx,%esi
  803f98:	74 1b                	je     803fb5 <mem_free+0xb8>
    if (lfree == nmem) {
  803f9a:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  803fa0:	0f 84 d9 00 00 00    	je     80407f <mem_free+0x182>
    mem->next = nmem->next;
  803fa6:	8b 32                	mov    (%edx),%esi
  803fa8:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  803fab:	8b 12                	mov    (%edx),%edx
  803fad:	89 c6                	mov    %eax,%esi
  803faf:	29 ce                	sub    %ecx,%esi
  803fb1:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  803fb5:	8b 73 f8             	mov    -0x8(%ebx),%esi
  803fb8:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  803fbb:	39 d0                	cmp    %edx,%eax
  803fbd:	74 1e                	je     803fdd <mem_free+0xe0>
  803fbf:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  803fc3:	75 18                	jne    803fdd <mem_free+0xe0>
    if (lfree == mem) {
  803fc5:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  803fcb:	0f 84 b8 00 00 00    	je     804089 <mem_free+0x18c>
    pmem->next = mem->next;
  803fd1:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fd4:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  803fd6:	8b 43 f4             	mov    -0xc(%ebx),%eax
  803fd9:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  803fdd:	83 ec 0c             	sub    $0xc,%esp
  803fe0:	ff 35 00 53 81 00    	pushl  0x815300
  803fe6:	e8 68 60 00 00       	call   80a053 <sys_sem_signal>
  803feb:	83 c4 10             	add    $0x10,%esp
}
  803fee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803ff1:	5b                   	pop    %ebx
  803ff2:	5e                   	pop    %esi
  803ff3:	5d                   	pop    %ebp
  803ff4:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803ff5:	83 ec 04             	sub    $0x4,%esp
  803ff8:	68 54 1a 81 00       	push   $0x811a54
  803ffd:	68 30 01 00 00       	push   $0x130
  804002:	68 4b 1b 81 00       	push   $0x811b4b
  804007:	e8 9c a5 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80400c:	83 ec 04             	sub    $0x4,%esp
  80400f:	68 5f 1b 81 00       	push   $0x811b5f
  804014:	68 33 01 00 00       	push   $0x133
  804019:	68 4b 1b 81 00       	push   $0x811b4b
  80401e:	e8 85 a5 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804023:	83 ec 04             	sub    $0x4,%esp
  804026:	68 76 1b 81 00       	push   $0x811b76
  80402b:	68 43 01 00 00       	push   $0x143
  804030:	68 4b 1b 81 00       	push   $0x811b4b
  804035:	e8 6e a5 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80403a:	83 ec 04             	sub    $0x4,%esp
  80403d:	68 8a 1b 81 00       	push   $0x811b8a
  804042:	68 e3 00 00 00       	push   $0xe3
  804047:	68 4b 1b 81 00       	push   $0x811b4b
  80404c:	e8 57 a5 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804051:	83 ec 04             	sub    $0x4,%esp
  804054:	68 a1 1b 81 00       	push   $0x811ba1
  804059:	68 e4 00 00 00       	push   $0xe4
  80405e:	68 4b 1b 81 00       	push   $0x811b4b
  804063:	e8 40 a5 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804068:	83 ec 04             	sub    $0x4,%esp
  80406b:	68 78 1a 81 00       	push   $0x811a78
  804070:	68 e8 00 00 00       	push   $0xe8
  804075:	68 4b 1b 81 00       	push   $0x811b4b
  80407a:	e8 29 a5 00 00       	call   80e5a8 <_panic>
      lfree = mem;
  80407f:	a3 04 53 81 00       	mov    %eax,0x815304
  804084:	e9 1d ff ff ff       	jmp    803fa6 <mem_free+0xa9>
      lfree = pmem;
  804089:	89 15 04 53 81 00    	mov    %edx,0x815304
  80408f:	e9 3d ff ff ff       	jmp    803fd1 <mem_free+0xd4>

00804094 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  804094:	55                   	push   %ebp
  804095:	89 e5                	mov    %esp,%ebp
  804097:	57                   	push   %edi
  804098:	56                   	push   %esi
  804099:	53                   	push   %ebx
  80409a:	83 ec 1c             	sub    $0x1c,%esp
  80409d:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8040a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8040a3:	8d 58 03             	lea    0x3(%eax),%ebx
  8040a6:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8040a9:	83 fb 0b             	cmp    $0xb,%ebx
  8040ac:	76 12                	jbe    8040c0 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8040ae:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8040b4:	76 0f                	jbe    8040c5 <mem_realloc+0x31>
    return NULL;
  8040b6:	be 00 00 00 00       	mov    $0x0,%esi
  8040bb:	e9 a1 00 00 00       	jmp    804161 <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  8040c0:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8040c5:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8040ca:	39 f0                	cmp    %esi,%eax
  8040cc:	0f 87 99 00 00 00    	ja     80416b <mem_realloc+0xd7>
  8040d2:	39 35 08 53 81 00    	cmp    %esi,0x815308
  8040d8:	0f 86 8d 00 00 00    	jbe    80416b <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8040de:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8040e1:	29 c2                	sub    %eax,%edx
  8040e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8040e6:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8040e9:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8040ec:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8040ee:	39 df                	cmp    %ebx,%edi
  8040f0:	0f 82 8c 00 00 00    	jb     804182 <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  8040f6:	74 69                	je     804161 <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8040f8:	83 ec 08             	sub    $0x8,%esp
  8040fb:	6a 00                	push   $0x0
  8040fd:	ff 35 00 53 81 00    	pushl  0x815300
  804103:	e8 bb 5f 00 00       	call   80a0c3 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804108:	a1 0c 53 81 00       	mov    0x81530c,%eax
  80410d:	89 c2                	mov    %eax,%edx
  80410f:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804112:	83 c4 10             	add    $0x10,%esp
  804115:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804119:	0f 85 85 00 00 00    	jne    8041a4 <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80411f:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804121:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804124:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804128:	39 15 04 53 81 00    	cmp    %edx,0x815304
  80412e:	74 69                	je     804199 <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804130:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804133:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804137:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804139:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80413c:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80413f:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804142:	8b 12                	mov    (%edx),%edx
  804144:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80414a:	74 04                	je     804150 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80414c:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804150:	83 ec 0c             	sub    $0xc,%esp
  804153:	ff 35 00 53 81 00    	pushl  0x815300
  804159:	e8 f5 5e 00 00       	call   80a053 <sys_sem_signal>
  return rmem;
  80415e:	83 c4 10             	add    $0x10,%esp
}
  804161:	89 f0                	mov    %esi,%eax
  804163:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804166:	5b                   	pop    %ebx
  804167:	5e                   	pop    %esi
  804168:	5f                   	pop    %edi
  804169:	5d                   	pop    %ebp
  80416a:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80416b:	83 ec 04             	sub    $0x4,%esp
  80416e:	68 bb 1b 81 00       	push   $0x811bbb
  804173:	68 79 01 00 00       	push   $0x179
  804178:	68 4b 1b 81 00       	push   $0x811b4b
  80417d:	e8 26 a4 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804182:	83 ec 04             	sub    $0x4,%esp
  804185:	68 a4 1a 81 00       	push   $0x811aa4
  80418a:	68 8a 01 00 00       	push   $0x18a
  80418f:	68 4b 1b 81 00       	push   $0x811b4b
  804194:	e8 0f a4 00 00       	call   80e5a8 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  804199:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  80419c:	89 15 04 53 81 00    	mov    %edx,0x815304
  8041a2:	eb 8c                	jmp    804130 <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8041a4:	8d 53 18             	lea    0x18(%ebx),%edx
  8041a7:	39 fa                	cmp    %edi,%edx
  8041a9:	77 a5                	ja     804150 <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041ab:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041ae:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8041b2:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8041b5:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8041bb:	76 06                	jbe    8041c3 <mem_realloc+0x12f>
      lfree = mem2;
  8041bd:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  8041c3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8041c7:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8041ca:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8041cc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041cf:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8041d2:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041d5:	8b 12                	mov    (%edx),%edx
  8041d7:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041dd:	0f 84 6d ff ff ff    	je     804150 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041e3:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8041e7:	e9 64 ff ff ff       	jmp    804150 <mem_realloc+0xbc>

008041ec <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8041ec:	55                   	push   %ebp
  8041ed:	89 e5                	mov    %esp,%ebp
  8041ef:	57                   	push   %edi
  8041f0:	56                   	push   %esi
  8041f1:	53                   	push   %ebx
  8041f2:	83 ec 1c             	sub    $0x1c,%esp
  8041f5:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8041f8:	85 c0                	test   %eax,%eax
  8041fa:	0f 84 a0 01 00 00    	je     8043a0 <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804200:	83 c0 03             	add    $0x3,%eax
  804203:	83 e0 fc             	and    $0xfffffffc,%eax
  804206:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  804208:	83 f8 0b             	cmp    $0xb,%eax
  80420b:	76 3a                	jbe    804247 <mem_malloc+0x5b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80420d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804212:	0f 87 8f 01 00 00    	ja     8043a7 <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804218:	83 ec 08             	sub    $0x8,%esp
  80421b:	6a 00                	push   $0x0
  80421d:	ff 35 00 53 81 00    	pushl  0x815300
  804223:	e8 9b 5e 00 00       	call   80a0c3 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804228:	a1 04 53 81 00       	mov    0x815304,%eax
  80422d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804230:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  804236:	29 f0                	sub    %esi,%eax
  804238:	83 c4 10             	add    $0x10,%esp
  80423b:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804240:	29 f9                	sub    %edi,%ecx
  804242:	e9 e2 00 00 00       	jmp    804329 <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  804247:	bf 0c 00 00 00       	mov    $0xc,%edi
  80424c:	eb ca                	jmp    804218 <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80424e:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804252:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804255:	74 4c                	je     8042a3 <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804257:	83 ec 0c             	sub    $0xc,%esp
  80425a:	ff 35 00 53 81 00    	pushl  0x815300
  804260:	e8 ee 5d 00 00       	call   80a053 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804265:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  804269:	83 c4 10             	add    $0x10,%esp
  80426c:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804272:	0f 82 81 00 00 00    	jb     8042f9 <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804278:	8d 43 0c             	lea    0xc(%ebx),%eax
  80427b:	a8 03                	test   $0x3,%al
  80427d:	0f 85 8d 00 00 00    	jne    804310 <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804283:	f6 c3 03             	test   $0x3,%bl
  804286:	0f 84 0c 01 00 00    	je     804398 <mem_malloc+0x1ac>
  80428c:	83 ec 04             	sub    $0x4,%esp
  80428f:	68 28 1b 81 00       	push   $0x811b28
  804294:	68 4f 02 00 00       	push   $0x24f
  804299:	68 4b 1b 81 00       	push   $0x811b4b
  80429e:	e8 05 a3 00 00       	call   80e5a8 <_panic>
          while (lfree->used && lfree != ram_end) {
  8042a3:	8b 15 08 53 81 00    	mov    0x815308,%edx
  8042a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8042ae:	b9 01 00 00 00       	mov    $0x1,%ecx
  8042b3:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8042b6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8042b9:	eb 08                	jmp    8042c3 <mem_malloc+0xd7>
            lfree = (struct mem *)&ram[lfree->next];
  8042bb:	89 f0                	mov    %esi,%eax
  8042bd:	03 07                	add    (%edi),%eax
  8042bf:	89 c7                	mov    %eax,%edi
  8042c1:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8042c3:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8042c7:	74 18                	je     8042e1 <mem_malloc+0xf5>
  8042c9:	39 fa                	cmp    %edi,%edx
  8042cb:	75 ee                	jne    8042bb <mem_malloc+0xcf>
  8042cd:	89 fe                	mov    %edi,%esi
  8042cf:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8042d2:	84 c0                	test   %al,%al
  8042d4:	74 81                	je     804257 <mem_malloc+0x6b>
  8042d6:	89 35 04 53 81 00    	mov    %esi,0x815304
  8042dc:	e9 76 ff ff ff       	jmp    804257 <mem_malloc+0x6b>
  8042e1:	89 fe                	mov    %edi,%esi
  8042e3:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8042e6:	84 c0                	test   %al,%al
  8042e8:	0f 84 69 ff ff ff    	je     804257 <mem_malloc+0x6b>
  8042ee:	89 35 04 53 81 00    	mov    %esi,0x815304
  8042f4:	e9 5e ff ff ff       	jmp    804257 <mem_malloc+0x6b>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8042f9:	83 ec 04             	sub    $0x4,%esp
  8042fc:	68 c8 1a 81 00       	push   $0x811ac8
  804301:	68 4b 02 00 00       	push   $0x24b
  804306:	68 4b 1b 81 00       	push   $0x811b4b
  80430b:	e8 98 a2 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804310:	83 ec 04             	sub    $0x4,%esp
  804313:	68 f8 1a 81 00       	push   $0x811af8
  804318:	68 4d 02 00 00       	push   $0x24d
  80431d:	68 4b 1b 81 00       	push   $0x811b4b
  804322:	e8 81 a2 00 00       	call   80e5a8 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804327:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804329:	39 c1                	cmp    %eax,%ecx
  80432b:	76 55                	jbe    804382 <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  80432d:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  804330:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804334:	75 f1                	jne    804327 <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804336:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  80433b:	29 c2                	sub    %eax,%edx
  80433d:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  80433f:	39 fa                	cmp    %edi,%edx
  804341:	72 e4                	jb     804327 <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804343:	8d 4f 18             	lea    0x18(%edi),%ecx
  804346:	39 ca                	cmp    %ecx,%edx
  804348:	0f 82 00 ff ff ff    	jb     80424e <mem_malloc+0x62>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80434e:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  804352:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804355:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804358:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80435c:	8b 0b                	mov    (%ebx),%ecx
  80435e:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804360:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804363:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804366:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  804368:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  80436c:	8b 02                	mov    (%edx),%eax
  80436e:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804373:	0f 84 d9 fe ff ff    	je     804252 <mem_malloc+0x66>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804379:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  80437d:	e9 d0 fe ff ff       	jmp    804252 <mem_malloc+0x66>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804382:	83 ec 0c             	sub    $0xc,%esp
  804385:	ff 35 00 53 81 00    	pushl  0x815300
  80438b:	e8 c3 5c 00 00       	call   80a053 <sys_sem_signal>
  return NULL;
  804390:	83 c4 10             	add    $0x10,%esp
  804393:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804398:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80439b:	5b                   	pop    %ebx
  80439c:	5e                   	pop    %esi
  80439d:	5f                   	pop    %edi
  80439e:	5d                   	pop    %ebp
  80439f:	c3                   	ret    
    return NULL;
  8043a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8043a5:	eb f1                	jmp    804398 <mem_malloc+0x1ac>
    return NULL;
  8043a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8043ac:	eb ea                	jmp    804398 <mem_malloc+0x1ac>

008043ae <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8043ae:	55                   	push   %ebp
  8043af:	89 e5                	mov    %esp,%ebp
  8043b1:	56                   	push   %esi
  8043b2:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8043b3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8043b6:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8043ba:	83 ec 0c             	sub    $0xc,%esp
  8043bd:	53                   	push   %ebx
  8043be:	e8 29 fe ff ff       	call   8041ec <mem_malloc>
  8043c3:	89 c6                	mov    %eax,%esi
  if (p) {
  8043c5:	83 c4 10             	add    $0x10,%esp
  8043c8:	85 c0                	test   %eax,%eax
  8043ca:	74 0f                	je     8043db <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8043cc:	83 ec 04             	sub    $0x4,%esp
  8043cf:	53                   	push   %ebx
  8043d0:	6a 00                	push   $0x0
  8043d2:	50                   	push   %eax
  8043d3:	e8 6b ab 00 00       	call   80ef43 <memset>
  8043d8:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8043db:	89 f0                	mov    %esi,%eax
  8043dd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8043e0:	5b                   	pop    %ebx
  8043e1:	5e                   	pop    %esi
  8043e2:	5d                   	pop    %ebp
  8043e3:	c3                   	ret    

008043e4 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8043e4:	55                   	push   %ebp
  8043e5:	89 e5                	mov    %esp,%ebp
  8043e7:	56                   	push   %esi
  8043e8:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8043e9:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  8043ee:	83 e0 fc             	and    $0xfffffffc,%eax
  8043f1:	ba 00 00 00 00       	mov    $0x0,%edx
  8043f6:	eb 08                	jmp    804400 <memp_init+0x1c>
  8043f8:	83 c2 01             	add    $0x1,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8043fb:	83 fa 0e             	cmp    $0xe,%edx
  8043fe:	74 3c                	je     80443c <memp_init+0x58>
    memp_tab[i] = NULL;
  804400:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  804407:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80440b:	0f b7 b4 12 4c 1c 81 	movzwl 0x811c4c(%edx,%edx,1),%esi
  804412:	00 
  804413:	b9 00 00 00 00       	mov    $0x0,%ecx
  804418:	66 39 ce             	cmp    %cx,%si
  80441b:	74 db                	je     8043f8 <memp_init+0x14>
      memp->next = memp_tab[i];
  80441d:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  804424:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804426:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80442d:	0f b7 9c 12 68 1c 81 	movzwl 0x811c68(%edx,%edx,1),%ebx
  804434:	00 
  804435:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804437:	83 c1 01             	add    $0x1,%ecx
  80443a:	eb dc                	jmp    804418 <memp_init+0x34>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80443c:	5b                   	pop    %ebx
  80443d:	5e                   	pop    %esi
  80443e:	5d                   	pop    %ebp
  80443f:	c3                   	ret    

00804440 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804440:	55                   	push   %ebp
  804441:	89 e5                	mov    %esp,%ebp
  804443:	83 ec 08             	sub    $0x8,%esp
  804446:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804449:	83 fa 0d             	cmp    $0xd,%edx
  80444c:	77 1a                	ja     804468 <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80444e:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804455:	85 c0                	test   %eax,%eax
  804457:	74 0d                	je     804466 <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  804459:	8b 08                	mov    (%eax),%ecx
  80445b:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804462:	a8 03                	test   $0x3,%al
  804464:	75 19                	jne    80447f <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804466:	c9                   	leave  
  804467:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804468:	83 ec 04             	sub    $0x4,%esp
  80446b:	68 d5 1b 81 00       	push   $0x811bd5
  804470:	68 2d 01 00 00       	push   $0x12d
  804475:	68 f2 1b 81 00       	push   $0x811bf2
  80447a:	e8 29 a1 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80447f:	83 ec 04             	sub    $0x4,%esp
  804482:	68 08 1c 81 00       	push   $0x811c08
  804487:	68 3f 01 00 00       	push   $0x13f
  80448c:	68 f2 1b 81 00       	push   $0x811bf2
  804491:	e8 12 a1 00 00       	call   80e5a8 <_panic>

00804496 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804496:	55                   	push   %ebp
  804497:	89 e5                	mov    %esp,%ebp
  804499:	83 ec 08             	sub    $0x8,%esp
  80449c:	8b 55 08             	mov    0x8(%ebp),%edx
  80449f:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8044a2:	85 c0                	test   %eax,%eax
  8044a4:	74 14                	je     8044ba <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044a6:	a8 03                	test   $0x3,%al
  8044a8:	75 12                	jne    8044bc <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8044aa:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  8044b1:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8044b3:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8044ba:	c9                   	leave  
  8044bb:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8044bc:	83 ec 04             	sub    $0x4,%esp
  8044bf:	68 2c 1c 81 00       	push   $0x811c2c
  8044c4:	68 5b 01 00 00       	push   $0x15b
  8044c9:	68 f2 1b 81 00       	push   $0x811bf2
  8044ce:	e8 d5 a0 00 00       	call   80e5a8 <_panic>

008044d3 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8044d3:	55                   	push   %ebp
  8044d4:	89 e5                	mov    %esp,%ebp
  8044d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8044d9:	85 c9                	test   %ecx,%ecx
  8044db:	74 2c                	je     804509 <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8044dd:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8044e2:	39 c8                	cmp    %ecx,%eax
  8044e4:	74 0e                	je     8044f4 <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8044e6:	85 c0                	test   %eax,%eax
  8044e8:	74 1f                	je     804509 <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  8044ea:	8b 10                	mov    (%eax),%edx
  8044ec:	39 ca                	cmp    %ecx,%edx
  8044ee:	74 0d                	je     8044fd <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8044f0:	89 d0                	mov    %edx,%eax
  8044f2:	eb f2                	jmp    8044e6 <netif_remove+0x13>
    netif_list = netif->next;
  8044f4:	8b 01                	mov    (%ecx),%eax
  8044f6:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  8044fb:	eb 04                	jmp    804501 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  8044fd:	8b 11                	mov    (%ecx),%edx
  8044ff:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804501:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  804507:	74 02                	je     80450b <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804509:	5d                   	pop    %ebp
  80450a:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80450b:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  804512:	00 00 00 
  804515:	eb f2                	jmp    804509 <netif_remove+0x36>

00804517 <netif_find>:
{
  804517:	55                   	push   %ebp
  804518:	89 e5                	mov    %esp,%ebp
  80451a:	53                   	push   %ebx
  80451b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  80451e:	85 c9                	test   %ecx,%ecx
  804520:	74 2d                	je     80454f <netif_find+0x38>
  num = name[2] - '0';
  804522:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804526:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804529:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  80452e:	eb 02                	jmp    804532 <netif_find+0x1b>
  804530:	8b 00                	mov    (%eax),%eax
  804532:	85 c0                	test   %eax,%eax
  804534:	74 16                	je     80454c <netif_find+0x35>
    if (num == netif->num &&
  804536:	38 50 31             	cmp    %dl,0x31(%eax)
  804539:	75 f5                	jne    804530 <netif_find+0x19>
  80453b:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  80453f:	38 19                	cmp    %bl,(%ecx)
  804541:	75 ed                	jne    804530 <netif_find+0x19>
       name[0] == netif->name[0] &&
  804543:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804547:	38 59 01             	cmp    %bl,0x1(%ecx)
  80454a:	75 e4                	jne    804530 <netif_find+0x19>
}
  80454c:	5b                   	pop    %ebx
  80454d:	5d                   	pop    %ebp
  80454e:	c3                   	ret    
    return NULL;
  80454f:	89 c8                	mov    %ecx,%eax
  804551:	eb f9                	jmp    80454c <netif_find+0x35>

00804553 <netif_set_ipaddr>:
{
  804553:	55                   	push   %ebp
  804554:	89 e5                	mov    %esp,%ebp
  804556:	57                   	push   %edi
  804557:	56                   	push   %esi
  804558:	53                   	push   %ebx
  804559:	83 ec 0c             	sub    $0xc,%esp
  80455c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80455f:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804562:	8b 43 04             	mov    0x4(%ebx),%eax
  804565:	39 06                	cmp    %eax,(%esi)
  804567:	74 47                	je     8045b0 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  804569:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  80456e:	eb 11                	jmp    804581 <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  804570:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804573:	83 ec 0c             	sub    $0xc,%esp
  804576:	50                   	push   %eax
  804577:	e8 cd 15 00 00       	call   805b49 <tcp_abort>
  80457c:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  80457f:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804581:	85 c0                	test   %eax,%eax
  804583:	74 0c                	je     804591 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804585:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804588:	39 08                	cmp    %ecx,(%eax)
  80458a:	74 e4                	je     804570 <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  80458c:	8b 40 0c             	mov    0xc(%eax),%eax
  80458f:	eb f0                	jmp    804581 <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804591:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  804596:	eb 03                	jmp    80459b <netif_set_ipaddr+0x48>
  804598:	8b 40 0c             	mov    0xc(%eax),%eax
  80459b:	85 c0                	test   %eax,%eax
  80459d:	74 11                	je     8045b0 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80459f:	8b 10                	mov    (%eax),%edx
  8045a1:	85 d2                	test   %edx,%edx
  8045a3:	74 f3                	je     804598 <netif_set_ipaddr+0x45>
  8045a5:	3b 53 04             	cmp    0x4(%ebx),%edx
  8045a8:	75 ee                	jne    804598 <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8045aa:	8b 16                	mov    (%esi),%edx
  8045ac:	89 10                	mov    %edx,(%eax)
  8045ae:	eb e8                	jmp    804598 <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8045b0:	8b 06                	mov    (%esi),%eax
  8045b2:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8045b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045b8:	5b                   	pop    %ebx
  8045b9:	5e                   	pop    %esi
  8045ba:	5f                   	pop    %edi
  8045bb:	5d                   	pop    %ebp
  8045bc:	c3                   	ret    

008045bd <netif_set_addr>:
{
  8045bd:	55                   	push   %ebp
  8045be:	89 e5                	mov    %esp,%ebp
  8045c0:	57                   	push   %edi
  8045c1:	56                   	push   %esi
  8045c2:	53                   	push   %ebx
  8045c3:	83 ec 14             	sub    $0x14,%esp
  8045c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8045c9:	8b 7d 10             	mov    0x10(%ebp),%edi
  8045cc:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8045cf:	ff 75 0c             	pushl  0xc(%ebp)
  8045d2:	53                   	push   %ebx
  8045d3:	e8 7b ff ff ff       	call   804553 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8045d8:	83 c4 10             	add    $0x10,%esp
  8045db:	b8 00 00 00 00       	mov    $0x0,%eax
  8045e0:	85 ff                	test   %edi,%edi
  8045e2:	74 02                	je     8045e6 <netif_set_addr+0x29>
  8045e4:	8b 07                	mov    (%edi),%eax
  8045e6:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  8045e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8045ee:	85 f6                	test   %esi,%esi
  8045f0:	74 02                	je     8045f4 <netif_set_addr+0x37>
  8045f2:	8b 06                	mov    (%esi),%eax
  8045f4:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  8045f7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045fa:	5b                   	pop    %ebx
  8045fb:	5e                   	pop    %esi
  8045fc:	5f                   	pop    %edi
  8045fd:	5d                   	pop    %ebp
  8045fe:	c3                   	ret    

008045ff <netif_add>:
{
  8045ff:	55                   	push   %ebp
  804600:	89 e5                	mov    %esp,%ebp
  804602:	53                   	push   %ebx
  804603:	83 ec 04             	sub    $0x4,%esp
  804606:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  804609:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804610:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804617:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80461e:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804622:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  804629:	8b 45 18             	mov    0x18(%ebp),%eax
  80462c:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  80462f:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  804636:	8d 50 01             	lea    0x1(%eax),%edx
  804639:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  80463f:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804642:	8b 45 20             	mov    0x20(%ebp),%eax
  804645:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804648:	ff 75 14             	pushl  0x14(%ebp)
  80464b:	ff 75 10             	pushl  0x10(%ebp)
  80464e:	ff 75 0c             	pushl  0xc(%ebp)
  804651:	53                   	push   %ebx
  804652:	e8 66 ff ff ff       	call   8045bd <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804657:	89 1c 24             	mov    %ebx,(%esp)
  80465a:	ff 55 1c             	call   *0x1c(%ebp)
  80465d:	83 c4 10             	add    $0x10,%esp
  804660:	84 c0                	test   %al,%al
  804662:	75 14                	jne    804678 <netif_add+0x79>
  netif->next = netif_list;
  804664:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804669:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80466b:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  804671:	89 d8                	mov    %ebx,%eax
}
  804673:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804676:	c9                   	leave  
  804677:	c3                   	ret    
    return NULL;
  804678:	b8 00 00 00 00       	mov    $0x0,%eax
  80467d:	eb f4                	jmp    804673 <netif_add+0x74>

0080467f <netif_set_gw>:
{
  80467f:	55                   	push   %ebp
  804680:	89 e5                	mov    %esp,%ebp
  804682:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  804685:	b8 00 00 00 00       	mov    $0x0,%eax
  80468a:	85 d2                	test   %edx,%edx
  80468c:	74 02                	je     804690 <netif_set_gw+0x11>
  80468e:	8b 02                	mov    (%edx),%eax
  804690:	8b 55 08             	mov    0x8(%ebp),%edx
  804693:	89 42 0c             	mov    %eax,0xc(%edx)
}
  804696:	5d                   	pop    %ebp
  804697:	c3                   	ret    

00804698 <netif_set_netmask>:
{
  804698:	55                   	push   %ebp
  804699:	89 e5                	mov    %esp,%ebp
  80469b:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  80469e:	b8 00 00 00 00       	mov    $0x0,%eax
  8046a3:	85 d2                	test   %edx,%edx
  8046a5:	74 02                	je     8046a9 <netif_set_netmask+0x11>
  8046a7:	8b 02                	mov    (%edx),%eax
  8046a9:	8b 55 08             	mov    0x8(%ebp),%edx
  8046ac:	89 42 08             	mov    %eax,0x8(%edx)
}
  8046af:	5d                   	pop    %ebp
  8046b0:	c3                   	ret    

008046b1 <netif_set_default>:
{
  8046b1:	55                   	push   %ebp
  8046b2:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8046b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8046b7:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8046bc:	5d                   	pop    %ebp
  8046bd:	c3                   	ret    

008046be <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8046be:	55                   	push   %ebp
  8046bf:	89 e5                	mov    %esp,%ebp
  8046c1:	83 ec 08             	sub    $0x8,%esp
  8046c4:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8046c7:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8046cb:	a8 01                	test   $0x1,%al
  8046cd:	75 0c                	jne    8046db <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  8046cf:	89 c1                	mov    %eax,%ecx
  8046d1:	83 c9 01             	or     $0x1,%ecx
  8046d4:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8046d7:	a8 20                	test   $0x20,%al
  8046d9:	75 02                	jne    8046dd <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  8046db:	c9                   	leave  
  8046dc:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  8046dd:	83 ec 04             	sub    $0x4,%esp
  8046e0:	6a 00                	push   $0x0
  8046e2:	8d 42 04             	lea    0x4(%edx),%eax
  8046e5:	50                   	push   %eax
  8046e6:	52                   	push   %edx
  8046e7:	e8 d8 51 00 00       	call   8098c4 <etharp_query>
  8046ec:	83 c4 10             	add    $0x10,%esp
}
  8046ef:	eb ea                	jmp    8046db <netif_set_up+0x1d>

008046f1 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  8046f1:	55                   	push   %ebp
  8046f2:	89 e5                	mov    %esp,%ebp
  8046f4:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  8046f7:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8046fb:	a8 01                	test   $0x1,%al
  8046fd:	74 06                	je     804705 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  8046ff:	83 e0 fe             	and    $0xfffffffe,%eax
  804702:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804705:	5d                   	pop    %ebp
  804706:	c3                   	ret    

00804707 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804707:	55                   	push   %ebp
  804708:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80470a:	8b 45 08             	mov    0x8(%ebp),%eax
  80470d:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804711:	83 e0 01             	and    $0x1,%eax
}
  804714:	5d                   	pop    %ebp
  804715:	c3                   	ret    

00804716 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804716:	55                   	push   %ebp
  804717:	89 e5                	mov    %esp,%ebp
  804719:	56                   	push   %esi
  80471a:	53                   	push   %ebx
  80471b:	8b 55 08             	mov    0x8(%ebp),%edx
  80471e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804721:	85 d2                	test   %edx,%edx
  804723:	74 42                	je     804767 <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  804725:	66 85 c9             	test   %cx,%cx
  804728:	0f 84 ae 00 00 00    	je     8047dc <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80472e:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  804730:	78 4c                	js     80477e <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804732:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804736:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804739:	66 85 c0             	test   %ax,%ax
  80473c:	74 5f                	je     80479d <pbuf_header+0x87>
  80473e:	66 83 f8 03          	cmp    $0x3,%ax
  804742:	74 59                	je     80479d <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804744:	83 e8 01             	sub    $0x1,%eax
  804747:	66 83 f8 01          	cmp    $0x1,%ax
  80474b:	77 78                	ja     8047c5 <pbuf_header+0xaf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80474d:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804752:	66 85 c9             	test   %cx,%cx
  804755:	79 67                	jns    8047be <pbuf_header+0xa8>
  804757:	66 39 72 0a          	cmp    %si,0xa(%edx)
  80475b:	72 61                	jb     8047be <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  80475d:	0f bf c1             	movswl %cx,%eax
  804760:	29 c3                	sub    %eax,%ebx
  804762:	89 5a 04             	mov    %ebx,0x4(%edx)
  804765:	eb 4a                	jmp    8047b1 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  804767:	83 ec 04             	sub    $0x4,%esp
  80476a:	68 48 1d 81 00       	push   $0x811d48
  80476f:	68 64 01 00 00       	push   $0x164
  804774:	68 84 1c 81 00       	push   $0x811c84
  804779:	e8 2a 9e 00 00       	call   80e5a8 <_panic>
    increment_magnitude = -header_size_increment;
  80477e:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804780:	66 39 72 0a          	cmp    %si,0xa(%edx)
  804784:	73 ac                	jae    804732 <pbuf_header+0x1c>
  804786:	83 ec 04             	sub    $0x4,%esp
  804789:	68 99 1c 81 00       	push   $0x811c99
  80478e:	68 6b 01 00 00       	push   $0x16b
  804793:	68 84 1c 81 00       	push   $0x811c84
  804798:	e8 0b 9e 00 00       	call   80e5a8 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  80479d:	0f bf c1             	movswl %cx,%eax
  8047a0:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047a2:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  8047a5:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8047aa:	39 f3                	cmp    %esi,%ebx
  8047ac:	72 10                	jb     8047be <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8047ae:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8047b1:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8047b5:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8047b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8047be:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8047c1:	5b                   	pop    %ebx
  8047c2:	5e                   	pop    %esi
  8047c3:	5d                   	pop    %ebp
  8047c4:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  8047c5:	83 ec 04             	sub    $0x4,%esp
  8047c8:	68 b7 1c 81 00       	push   $0x811cb7
  8047cd:	68 9a 01 00 00       	push   $0x19a
  8047d2:	68 84 1c 81 00       	push   $0x811c84
  8047d7:	e8 cc 9d 00 00       	call   80e5a8 <_panic>
    return 0;
  8047dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8047e1:	eb db                	jmp    8047be <pbuf_header+0xa8>

008047e3 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  8047e3:	55                   	push   %ebp
  8047e4:	89 e5                	mov    %esp,%ebp
  8047e6:	56                   	push   %esi
  8047e7:	53                   	push   %ebx
  8047e8:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  8047eb:	85 c0                	test   %eax,%eax
  8047ed:	74 0d                	je     8047fc <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  8047ef:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  8047f3:	77 1e                	ja     804813 <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  8047f5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8047fa:	eb 6c                	jmp    804868 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  8047fc:	83 ec 04             	sub    $0x4,%esp
  8047ff:	68 48 1d 81 00       	push   $0x811d48
  804804:	68 d0 01 00 00       	push   $0x1d0
  804809:	68 84 1c 81 00       	push   $0x811c84
  80480e:	e8 95 9d 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804813:	83 ec 04             	sub    $0x4,%esp
  804816:	68 c5 1c 81 00       	push   $0x811cc5
  80481b:	68 db 01 00 00       	push   $0x1db
  804820:	68 84 1c 81 00       	push   $0x811c84
  804825:	e8 7e 9d 00 00       	call   80e5a8 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80482a:	83 ec 04             	sub    $0x4,%esp
  80482d:	68 da 1c 81 00       	push   $0x811cda
  804832:	68 e8 01 00 00       	push   $0x1e8
  804837:	68 84 1c 81 00       	push   $0x811c84
  80483c:	e8 67 9d 00 00       	call   80e5a8 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804841:	83 ec 08             	sub    $0x8,%esp
  804844:	50                   	push   %eax
  804845:	6a 0d                	push   $0xd
  804847:	e8 4a fc ff ff       	call   804496 <memp_free>
  80484c:	83 c4 10             	add    $0x10,%esp
  80484f:	eb 0e                	jmp    80485f <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804851:	83 ec 08             	sub    $0x8,%esp
  804854:	50                   	push   %eax
  804855:	6a 0c                	push   $0xc
  804857:	e8 3a fc ff ff       	call   804496 <memp_free>
  80485c:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  80485f:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  804862:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  804864:	85 f6                	test   %esi,%esi
  804866:	74 38                	je     8048a0 <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804868:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  80486c:	66 85 d2             	test   %dx,%dx
  80486f:	74 b9                	je     80482a <pbuf_free+0x47>
    ref = --(p->ref);
  804871:	83 ea 01             	sub    $0x1,%edx
  804874:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804878:	66 85 d2             	test   %dx,%dx
  80487b:	75 23                	jne    8048a0 <pbuf_free+0xbd>
      q = p->next;
  80487d:	8b 30                	mov    (%eax),%esi
      type = p->type;
  80487f:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  804883:	66 83 fa 03          	cmp    $0x3,%dx
  804887:	74 b8                	je     804841 <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804889:	83 ea 01             	sub    $0x1,%edx
  80488c:	66 83 fa 01          	cmp    $0x1,%dx
  804890:	76 bf                	jbe    804851 <pbuf_free+0x6e>
        mem_free(p);
  804892:	83 ec 0c             	sub    $0xc,%esp
  804895:	50                   	push   %eax
  804896:	e8 62 f6 ff ff       	call   803efd <mem_free>
  80489b:	83 c4 10             	add    $0x10,%esp
  80489e:	eb bf                	jmp    80485f <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8048a0:	89 d8                	mov    %ebx,%eax
  8048a2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8048a5:	5b                   	pop    %ebx
  8048a6:	5e                   	pop    %esi
  8048a7:	5d                   	pop    %ebp
  8048a8:	c3                   	ret    

008048a9 <pbuf_alloc>:
{
  8048a9:	55                   	push   %ebp
  8048aa:	89 e5                	mov    %esp,%ebp
  8048ac:	57                   	push   %edi
  8048ad:	56                   	push   %esi
  8048ae:	53                   	push   %ebx
  8048af:	83 ec 1c             	sub    $0x1c,%esp
  8048b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8048b5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8048b8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  8048bb:	83 f8 01             	cmp    $0x1,%eax
  8048be:	0f 84 8a 00 00 00    	je     80494e <pbuf_alloc+0xa5>
  8048c4:	85 c0                	test   %eax,%eax
  8048c6:	0f 84 89 00 00 00    	je     804955 <pbuf_alloc+0xac>
  8048cc:	83 f8 02             	cmp    $0x2,%eax
  8048cf:	0f 84 94 00 00 00    	je     804969 <pbuf_alloc+0xc0>
  8048d5:	83 f8 03             	cmp    $0x3,%eax
  8048d8:	0f 85 92 00 00 00    	jne    804970 <pbuf_alloc+0xc7>
  offset = 0;
  8048de:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  8048e4:	83 fb 02             	cmp    $0x2,%ebx
  8048e7:	0f 87 9a 00 00 00    	ja     804987 <pbuf_alloc+0xde>
  8048ed:	85 db                	test   %ebx,%ebx
  8048ef:	0f 85 db 01 00 00    	jne    804ad0 <pbuf_alloc+0x227>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8048f5:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  8048f9:	83 ec 0c             	sub    $0xc,%esp
  8048fc:	8d 43 13             	lea    0x13(%ebx),%eax
  8048ff:	83 e0 fc             	and    $0xfffffffc,%eax
  804902:	89 c2                	mov    %eax,%edx
  804904:	0f b7 c6             	movzwl %si,%eax
  804907:	83 c0 03             	add    $0x3,%eax
  80490a:	83 e0 fc             	and    $0xfffffffc,%eax
  80490d:	01 d0                	add    %edx,%eax
  80490f:	50                   	push   %eax
  804910:	e8 d7 f8 ff ff       	call   8041ec <mem_malloc>
  804915:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804917:	83 c4 10             	add    $0x10,%esp
  80491a:	85 c0                	test   %eax,%eax
  80491c:	74 26                	je     804944 <pbuf_alloc+0x9b>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80491e:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804922:	83 e0 fc             	and    $0xfffffffc,%eax
  804925:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804928:	66 89 77 08          	mov    %si,0x8(%edi)
  80492c:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804930:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804936:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  80493a:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804940:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804944:	89 f8                	mov    %edi,%eax
  804946:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804949:	5b                   	pop    %ebx
  80494a:	5e                   	pop    %esi
  80494b:	5f                   	pop    %edi
  80494c:	5d                   	pop    %ebp
  80494d:	c3                   	ret    
  offset = 0;
  80494e:	bf 00 00 00 00       	mov    $0x0,%edi
  804953:	eb 05                	jmp    80495a <pbuf_alloc+0xb1>
    offset += PBUF_TRANSPORT_HLEN;
  804955:	bf 14 00 00 00       	mov    $0x14,%edi
    offset += PBUF_IP_HLEN;
  80495a:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  80495d:	8d 47 0e             	lea    0xe(%edi),%eax
  804960:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804964:	e9 7b ff ff ff       	jmp    8048e4 <pbuf_alloc+0x3b>
  offset = 0;
  804969:	bf 00 00 00 00       	mov    $0x0,%edi
  80496e:	eb ed                	jmp    80495d <pbuf_alloc+0xb4>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804970:	83 ec 04             	sub    $0x4,%esp
  804973:	68 f0 1c 81 00       	push   $0x811cf0
  804978:	68 8a 00 00 00       	push   $0x8a
  80497d:	68 84 1c 81 00       	push   $0x811c84
  804982:	e8 21 9c 00 00       	call   80e5a8 <_panic>
  switch (type) {
  804987:	83 fb 03             	cmp    $0x3,%ebx
  80498a:	0f 85 74 01 00 00    	jne    804b04 <pbuf_alloc+0x25b>
      p = memp_malloc(MEMP_PBUF_POOL);
  804990:	83 ec 0c             	sub    $0xc,%esp
  804993:	6a 0d                	push   $0xd
  804995:	e8 a6 fa ff ff       	call   804440 <memp_malloc>
  80499a:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80499c:	83 c4 10             	add    $0x10,%esp
  80499f:	85 c0                	test   %eax,%eax
  8049a1:	74 a1                	je     804944 <pbuf_alloc+0x9b>
    p->type = type;
  8049a3:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8049a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8049ad:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8049b1:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  8049b5:	83 e2 fc             	and    $0xfffffffc,%edx
  8049b8:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  8049bb:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8049bf:	0f b7 f6             	movzwl %si,%esi
  8049c2:	83 c0 03             	add    $0x3,%eax
  8049c5:	83 e0 fc             	and    $0xfffffffc,%eax
  8049c8:	89 c1                	mov    %eax,%ecx
  8049ca:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8049cf:	29 c8                	sub    %ecx,%eax
  8049d1:	39 f0                	cmp    %esi,%eax
  8049d3:	0f 4f c6             	cmovg  %esi,%eax
  8049d6:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8049da:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  8049e0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8049e3:	01 c2                	add    %eax,%edx
  8049e5:	39 d3                	cmp    %edx,%ebx
  8049e7:	72 76                	jb     804a5f <pbuf_alloc+0x1b6>
    p->ref = 1;
  8049e9:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  8049ef:	29 c6                	sub    %eax,%esi
    r = p;
  8049f1:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  8049f3:	85 f6                	test   %esi,%esi
  8049f5:	0f 8e 3f ff ff ff    	jle    80493a <pbuf_alloc+0x91>
      q = memp_malloc(MEMP_PBUF_POOL);
  8049fb:	83 ec 0c             	sub    $0xc,%esp
  8049fe:	6a 0d                	push   $0xd
  804a00:	e8 3b fa ff ff       	call   804440 <memp_malloc>
      if (q == NULL) {
  804a05:	83 c4 10             	add    $0x10,%esp
  804a08:	85 c0                	test   %eax,%eax
  804a0a:	74 6a                	je     804a76 <pbuf_alloc+0x1cd>
      q->type = type;
  804a0c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804a10:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804a14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804a1a:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a1c:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804a22:	7f 67                	jg     804a8b <pbuf_alloc+0x1e2>
      q->tot_len = (u16_t)rem_len;
  804a24:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804a28:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804a2d:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804a32:	0f 46 d6             	cmovbe %esi,%edx
  804a35:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804a39:	8d 48 10             	lea    0x10(%eax),%ecx
  804a3c:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804a3f:	f6 c1 03             	test   $0x3,%cl
  804a42:	75 5e                	jne    804aa2 <pbuf_alloc+0x1f9>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a44:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804a48:	03 4f 04             	add    0x4(%edi),%ecx
  804a4b:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804a4e:	72 69                	jb     804ab9 <pbuf_alloc+0x210>
      q->ref = 1;
  804a50:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804a56:	0f b7 d2             	movzwl %dx,%edx
  804a59:	29 d6                	sub    %edx,%esi
      r = q;
  804a5b:	89 c3                	mov    %eax,%ebx
  804a5d:	eb 94                	jmp    8049f3 <pbuf_alloc+0x14a>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a5f:	83 ec 04             	sub    $0x4,%esp
  804a62:	68 08 1e 81 00       	push   $0x811e08
  804a67:	68 a3 00 00 00       	push   $0xa3
  804a6c:	68 84 1c 81 00       	push   $0x811c84
  804a71:	e8 32 9b 00 00       	call   80e5a8 <_panic>
  804a76:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804a78:	83 ec 0c             	sub    $0xc,%esp
  804a7b:	57                   	push   %edi
  804a7c:	e8 62 fd ff ff       	call   8047e3 <pbuf_free>
        return NULL;
  804a81:	83 c4 10             	add    $0x10,%esp
  804a84:	89 df                	mov    %ebx,%edi
  804a86:	e9 b9 fe ff ff       	jmp    804944 <pbuf_alloc+0x9b>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804a8b:	83 ec 04             	sub    $0x4,%esp
  804a8e:	68 0b 1d 81 00       	push   $0x811d0b
  804a93:	68 bc 00 00 00       	push   $0xbc
  804a98:	68 84 1c 81 00       	push   $0x811c84
  804a9d:	e8 06 9b 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804aa2:	83 ec 04             	sub    $0x4,%esp
  804aa5:	68 3c 1e 81 00       	push   $0x811e3c
  804aaa:	68 c2 00 00 00       	push   $0xc2
  804aaf:	68 84 1c 81 00       	push   $0x811c84
  804ab4:	e8 ef 9a 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804ab9:	83 ec 04             	sub    $0x4,%esp
  804abc:	68 08 1e 81 00       	push   $0x811e08
  804ac1:	68 c5 00 00 00       	push   $0xc5
  804ac6:	68 84 1c 81 00       	push   $0x811c84
  804acb:	e8 d8 9a 00 00       	call   80e5a8 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804ad0:	83 ec 0c             	sub    $0xc,%esp
  804ad3:	6a 0c                	push   $0xc
  804ad5:	e8 66 f9 ff ff       	call   804440 <memp_malloc>
  804ada:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804adc:	83 c4 10             	add    $0x10,%esp
  804adf:	85 c0                	test   %eax,%eax
  804ae1:	0f 84 5d fe ff ff    	je     804944 <pbuf_alloc+0x9b>
    p->payload = NULL;
  804ae7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804aee:	66 89 70 08          	mov    %si,0x8(%eax)
  804af2:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804af6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804afc:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804aff:	e9 36 fe ff ff       	jmp    80493a <pbuf_alloc+0x91>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804b04:	83 ec 04             	sub    $0x4,%esp
  804b07:	68 1f 1d 81 00       	push   $0x811d1f
  804b0c:	68 f1 00 00 00       	push   $0xf1
  804b11:	68 84 1c 81 00       	push   $0x811c84
  804b16:	e8 8d 9a 00 00       	call   80e5a8 <_panic>

00804b1b <pbuf_realloc>:
{
  804b1b:	55                   	push   %ebp
  804b1c:	89 e5                	mov    %esp,%ebp
  804b1e:	57                   	push   %edi
  804b1f:	56                   	push   %esi
  804b20:	53                   	push   %ebx
  804b21:	83 ec 0c             	sub    $0xc,%esp
  804b24:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b27:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b2a:	85 db                	test   %ebx,%ebx
  804b2c:	74 53                	je     804b81 <pbuf_realloc+0x66>
  804b2e:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b30:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804b34:	77 62                	ja     804b98 <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804b36:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804b3a:	66 39 f0             	cmp    %si,%ax
  804b3d:	0f 86 ae 00 00 00    	jbe    804bf1 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804b43:	0f b7 ce             	movzwl %si,%ecx
  804b46:	0f b7 f8             	movzwl %ax,%edi
  804b49:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804b4b:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804b4d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804b51:	66 39 f0             	cmp    %si,%ax
  804b54:	73 70                	jae    804bc6 <pbuf_realloc+0xab>
    rem_len -= q->len;
  804b56:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804b58:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804b5e:	7f 4f                	jg     804baf <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804b60:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804b64:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804b66:	85 db                	test   %ebx,%ebx
  804b68:	75 e3                	jne    804b4d <pbuf_realloc+0x32>
  804b6a:	83 ec 04             	sub    $0x4,%esp
  804b6d:	68 7e 1d 81 00       	push   $0x811d7e
  804b72:	68 2f 01 00 00       	push   $0x12f
  804b77:	68 84 1c 81 00       	push   $0x811c84
  804b7c:	e8 27 9a 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804b81:	83 ec 04             	sub    $0x4,%esp
  804b84:	68 3a 1d 81 00       	push   $0x811d3a
  804b89:	68 13 01 00 00       	push   $0x113
  804b8e:	68 84 1c 81 00       	push   $0x811c84
  804b93:	e8 10 9a 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804b98:	83 ec 04             	sub    $0x4,%esp
  804b9b:	68 52 1d 81 00       	push   $0x811d52
  804ba0:	68 17 01 00 00       	push   $0x117
  804ba5:	68 84 1c 81 00       	push   $0x811c84
  804baa:	e8 f9 99 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804baf:	83 ec 04             	sub    $0x4,%esp
  804bb2:	68 6d 1d 81 00       	push   $0x811d6d
  804bb7:	68 2b 01 00 00       	push   $0x12b
  804bbc:	68 84 1c 81 00       	push   $0x811c84
  804bc1:	e8 e2 99 00 00       	call   80e5a8 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804bc6:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804bca:	75 05                	jne    804bd1 <pbuf_realloc+0xb6>
  804bcc:	66 39 f0             	cmp    %si,%ax
  804bcf:	75 28                	jne    804bf9 <pbuf_realloc+0xde>
  q->len = rem_len;
  804bd1:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804bd5:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804bd9:	8b 03                	mov    (%ebx),%eax
  804bdb:	85 c0                	test   %eax,%eax
  804bdd:	74 0c                	je     804beb <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804bdf:	83 ec 0c             	sub    $0xc,%esp
  804be2:	50                   	push   %eax
  804be3:	e8 fb fb ff ff       	call   8047e3 <pbuf_free>
  804be8:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804beb:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804bf1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804bf4:	5b                   	pop    %ebx
  804bf5:	5e                   	pop    %esi
  804bf6:	5f                   	pop    %edi
  804bf7:	5d                   	pop    %ebp
  804bf8:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804bf9:	8b 43 04             	mov    0x4(%ebx),%eax
  804bfc:	29 d8                	sub    %ebx,%eax
  804bfe:	0f b7 d6             	movzwl %si,%edx
  804c01:	01 d0                	add    %edx,%eax
  804c03:	83 ec 08             	sub    $0x8,%esp
  804c06:	50                   	push   %eax
  804c07:	53                   	push   %ebx
  804c08:	e8 87 f4 ff ff       	call   804094 <mem_realloc>
  804c0d:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804c0f:	83 c4 10             	add    $0x10,%esp
  804c12:	85 c0                	test   %eax,%eax
  804c14:	75 bb                	jne    804bd1 <pbuf_realloc+0xb6>
  804c16:	83 ec 04             	sub    $0x4,%esp
  804c19:	68 96 1d 81 00       	push   $0x811d96
  804c1e:	68 39 01 00 00       	push   $0x139
  804c23:	68 84 1c 81 00       	push   $0x811c84
  804c28:	e8 7b 99 00 00       	call   80e5a8 <_panic>

00804c2d <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804c2d:	55                   	push   %ebp
  804c2e:	89 e5                	mov    %esp,%ebp
  804c30:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804c33:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804c38:	85 d2                	test   %edx,%edx
  804c3a:	74 07                	je     804c43 <pbuf_clen+0x16>
    ++len;
  804c3c:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804c3f:	8b 12                	mov    (%edx),%edx
  804c41:	eb f5                	jmp    804c38 <pbuf_clen+0xb>
  }
  return len;
}
  804c43:	5d                   	pop    %ebp
  804c44:	c3                   	ret    

00804c45 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804c45:	55                   	push   %ebp
  804c46:	89 e5                	mov    %esp,%ebp
  804c48:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804c4b:	85 c0                	test   %eax,%eax
  804c4d:	74 05                	je     804c54 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804c4f:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804c54:	5d                   	pop    %ebp
  804c55:	c3                   	ret    

00804c56 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804c56:	55                   	push   %ebp
  804c57:	89 e5                	mov    %esp,%ebp
  804c59:	53                   	push   %ebx
  804c5a:	83 ec 04             	sub    $0x4,%esp
  804c5d:	8b 45 08             	mov    0x8(%ebp),%eax
  804c60:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804c63:	85 c0                	test   %eax,%eax
  804c65:	74 16                	je     804c7d <pbuf_cat+0x27>
  804c67:	85 db                	test   %ebx,%ebx
  804c69:	74 12                	je     804c7d <pbuf_cat+0x27>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804c6b:	8b 10                	mov    (%eax),%edx
  804c6d:	85 d2                	test   %edx,%edx
  804c6f:	74 23                	je     804c94 <pbuf_cat+0x3e>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804c71:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804c75:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804c79:	89 d0                	mov    %edx,%eax
  804c7b:	eb ee                	jmp    804c6b <pbuf_cat+0x15>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804c7d:	83 ec 04             	sub    $0x4,%esp
  804c80:	68 6c 1e 81 00       	push   $0x811e6c
  804c85:	68 42 02 00 00       	push   $0x242
  804c8a:	68 84 1c 81 00       	push   $0x811c84
  804c8f:	e8 14 99 00 00       	call   80e5a8 <_panic>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804c94:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804c98:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804c9c:	75 0f                	jne    804cad <pbuf_cat+0x57>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804c9e:	66 03 53 08          	add    0x8(%ebx),%dx
  804ca2:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804ca6:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804ca8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804cab:	c9                   	leave  
  804cac:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804cad:	83 ec 04             	sub    $0x4,%esp
  804cb0:	68 a4 1e 81 00       	push   $0x811ea4
  804cb5:	68 4a 02 00 00       	push   $0x24a
  804cba:	68 84 1c 81 00       	push   $0x811c84
  804cbf:	e8 e4 98 00 00       	call   80e5a8 <_panic>

00804cc4 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804cc4:	55                   	push   %ebp
  804cc5:	89 e5                	mov    %esp,%ebp
  804cc7:	53                   	push   %ebx
  804cc8:	83 ec 0c             	sub    $0xc,%esp
  804ccb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804cce:	53                   	push   %ebx
  804ccf:	ff 75 08             	pushl  0x8(%ebp)
  804cd2:	e8 7f ff ff ff       	call   804c56 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804cd7:	89 1c 24             	mov    %ebx,(%esp)
  804cda:	e8 66 ff ff ff       	call   804c45 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804cdf:	83 c4 10             	add    $0x10,%esp
  804ce2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804ce5:	c9                   	leave  
  804ce6:	c3                   	ret    

00804ce7 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804ce7:	55                   	push   %ebp
  804ce8:	89 e5                	mov    %esp,%ebp
  804cea:	57                   	push   %edi
  804ceb:	56                   	push   %esi
  804cec:	53                   	push   %ebx
  804ced:	83 ec 1c             	sub    $0x1c,%esp
  804cf0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804cf3:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804cf5:	85 f6                	test   %esi,%esi
  804cf7:	74 71                	je     804d6a <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804cf9:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804cfd:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d01:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804d05:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804d08:	0f b7 d0             	movzwl %ax,%edx
  804d0b:	0f b7 f9             	movzwl %cx,%edi
  804d0e:	29 fa                	sub    %edi,%edx
  804d10:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804d13:	75 3e                	jne    804d53 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804d15:	29 c8                	sub    %ecx,%eax
  804d17:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804d1b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804d21:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d25:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804d29:	83 ec 0c             	sub    $0xc,%esp
  804d2c:	56                   	push   %esi
  804d2d:	e8 b1 fa ff ff       	call   8047e3 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d32:	83 c4 10             	add    $0x10,%esp
  804d35:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804d39:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804d3d:	75 35                	jne    804d74 <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804d3f:	84 c0                	test   %al,%al
  804d41:	b8 00 00 00 00       	mov    $0x0,%eax
  804d46:	0f 45 f0             	cmovne %eax,%esi
}
  804d49:	89 f0                	mov    %esi,%eax
  804d4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804d4e:	5b                   	pop    %ebx
  804d4f:	5e                   	pop    %esi
  804d50:	5f                   	pop    %edi
  804d51:	5d                   	pop    %ebp
  804d52:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804d53:	83 ec 04             	sub    $0x4,%esp
  804d56:	68 d4 1e 81 00       	push   $0x811ed4
  804d5b:	68 80 02 00 00       	push   $0x280
  804d60:	68 84 1c 81 00       	push   $0x811c84
  804d65:	e8 3e 98 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804d6a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d6e:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804d72:	74 d5                	je     804d49 <pbuf_dechain+0x62>
  804d74:	83 ec 04             	sub    $0x4,%esp
  804d77:	68 b1 1d 81 00       	push   $0x811db1
  804d7c:	68 91 02 00 00       	push   $0x291
  804d81:	68 84 1c 81 00       	push   $0x811c84
  804d86:	e8 1d 98 00 00       	call   80e5a8 <_panic>

00804d8b <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804d8b:	55                   	push   %ebp
  804d8c:	89 e5                	mov    %esp,%ebp
  804d8e:	57                   	push   %edi
  804d8f:	56                   	push   %esi
  804d90:	53                   	push   %ebx
  804d91:	83 ec 1c             	sub    $0x1c,%esp
  804d94:	8b 7d 08             	mov    0x8(%ebp),%edi
  804d97:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804d9a:	85 ff                	test   %edi,%edi
  804d9c:	74 22                	je     804dc0 <pbuf_copy+0x35>
  804d9e:	85 db                	test   %ebx,%ebx
  804da0:	74 1e                	je     804dc0 <pbuf_copy+0x35>
  804da2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804da6:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804daa:	72 14                	jb     804dc0 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804dac:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804db2:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804db8:	89 7d 08             	mov    %edi,0x8(%ebp)
  804dbb:	e9 92 00 00 00       	jmp    804e52 <pbuf_copy+0xc7>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804dc0:	83 ec 04             	sub    $0x4,%esp
  804dc3:	68 f8 1e 81 00       	push   $0x811ef8
  804dc8:	68 b1 02 00 00       	push   $0x2b1
  804dcd:	68 84 1c 81 00       	push   $0x811c84
  804dd2:	e8 d1 97 00 00       	call   80e5a8 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804dd7:	83 ec 04             	sub    $0x4,%esp
  804dda:	68 c6 1d 81 00       	push   $0x811dc6
  804ddf:	68 c2 02 00 00       	push   $0x2c2
  804de4:	68 84 1c 81 00       	push   $0x811c84
  804de9:	e8 ba 97 00 00       	call   80e5a8 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804dee:	8b 45 08             	mov    0x8(%ebp),%eax
  804df1:	8b 00                	mov    (%eax),%eax
  804df3:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804df6:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804dfc:	e9 c7 00 00 00       	jmp    804ec8 <pbuf_copy+0x13d>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804e01:	83 ec 04             	sub    $0x4,%esp
  804e04:	68 dd 1d 81 00       	push   $0x811ddd
  804e09:	68 c8 02 00 00       	push   $0x2c8
  804e0e:	68 84 1c 81 00       	push   $0x811c84
  804e13:	e8 90 97 00 00       	call   80e5a8 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804e18:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804e1e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e22:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804e26:	0f 84 cf 00 00 00    	je     804efb <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804e2c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804e30:	0f 84 05 01 00 00    	je     804f3b <pbuf_copy+0x1b0>
  804e36:	8b 45 08             	mov    0x8(%ebp),%eax
  804e39:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804e3d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804e40:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804e44:	0f 84 d1 00 00 00    	je     804f1b <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804e4a:	85 db                	test   %ebx,%ebx
  804e4c:	0f 84 00 01 00 00    	je     804f52 <pbuf_copy+0x1c7>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804e52:	8b 45 08             	mov    0x8(%ebp),%eax
  804e55:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804e59:	0f b7 ce             	movzwl %si,%ecx
  804e5c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804e60:	29 c1                	sub    %eax,%ecx
  804e62:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804e66:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e6a:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804e6c:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804e70:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  804e74:	89 f8                	mov    %edi,%eax
  804e76:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804e7a:	29 fe                	sub    %edi,%esi
  804e7c:	39 d1                	cmp    %edx,%ecx
  804e7e:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804e81:	83 ec 04             	sub    $0x4,%esp
  804e84:	0f b7 c6             	movzwl %si,%eax
  804e87:	50                   	push   %eax
  804e88:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804e8c:	03 43 04             	add    0x4(%ebx),%eax
  804e8f:	50                   	push   %eax
  804e90:	0f b7 c7             	movzwl %di,%eax
  804e93:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804e96:	03 41 04             	add    0x4(%ecx),%eax
  804e99:	50                   	push   %eax
  804e9a:	e8 4e a1 00 00       	call   80efed <memcpy>
    offset_to += len;
  804e9f:	89 fa                	mov    %edi,%edx
  804ea1:	01 f2                	add    %esi,%edx
  804ea3:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804ea7:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804eab:	8b 45 08             	mov    0x8(%ebp),%eax
  804eae:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804eb2:	83 c4 10             	add    $0x10,%esp
  804eb5:	66 39 d0             	cmp    %dx,%ax
  804eb8:	0f 82 19 ff ff ff    	jb     804dd7 <pbuf_copy+0x4c>
    if (offset_to == p_to->len) {
  804ebe:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  804ec2:	0f 84 26 ff ff ff    	je     804dee <pbuf_copy+0x63>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804ec8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804ecc:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804ed0:	0f 82 2b ff ff ff    	jb     804e01 <pbuf_copy+0x76>
    if (offset_from >= p_from->len) {
  804ed6:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804eda:	0f 85 3e ff ff ff    	jne    804e1e <pbuf_copy+0x93>
      p_from = p_from->next;
  804ee0:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804ee2:	85 db                	test   %ebx,%ebx
  804ee4:	0f 85 2e ff ff ff    	jne    804e18 <pbuf_copy+0x8d>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804eea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804eee:	74 62                	je     804f52 <pbuf_copy+0x1c7>
      offset_from = 0;
  804ef0:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804ef6:	e9 3b ff ff ff       	jmp    804e36 <pbuf_copy+0xab>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804efb:	83 3b 00             	cmpl   $0x0,(%ebx)
  804efe:	0f 84 28 ff ff ff    	je     804e2c <pbuf_copy+0xa1>
  804f04:	83 ec 04             	sub    $0x4,%esp
  804f07:	68 28 1f 81 00       	push   $0x811f28
  804f0c:	68 d2 02 00 00       	push   $0x2d2
  804f11:	68 84 1c 81 00       	push   $0x811c84
  804f16:	e8 8d 96 00 00       	call   80e5a8 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804f1b:	83 39 00             	cmpl   $0x0,(%ecx)
  804f1e:	0f 84 26 ff ff ff    	je     804e4a <pbuf_copy+0xbf>
  804f24:	83 ec 04             	sub    $0x4,%esp
  804f27:	68 28 1f 81 00       	push   $0x811f28
  804f2c:	68 d7 02 00 00       	push   $0x2d7
  804f31:	68 84 1c 81 00       	push   $0x811c84
  804f36:	e8 6d 96 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804f3b:	83 ec 04             	sub    $0x4,%esp
  804f3e:	68 f8 1d 81 00       	push   $0x811df8
  804f43:	68 b6 02 00 00       	push   $0x2b6
  804f48:	68 84 1c 81 00       	push   $0x811c84
  804f4d:	e8 56 96 00 00       	call   80e5a8 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804f52:	b8 00 00 00 00       	mov    $0x0,%eax
  804f57:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f5a:	5b                   	pop    %ebx
  804f5b:	5e                   	pop    %esi
  804f5c:	5f                   	pop    %edi
  804f5d:	5d                   	pop    %ebp
  804f5e:	c3                   	ret    

00804f5f <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  804f5f:	55                   	push   %ebp
  804f60:	89 e5                	mov    %esp,%ebp
  804f62:	57                   	push   %edi
  804f63:	56                   	push   %esi
  804f64:	53                   	push   %ebx
  804f65:	83 ec 1c             	sub    $0x1c,%esp
  804f68:	8b 75 08             	mov    0x8(%ebp),%esi
  804f6b:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  804f6f:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f73:	85 f6                	test   %esi,%esi
  804f75:	74 0e                	je     804f85 <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804f77:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  804f7b:	74 1f                	je     804f9c <pbuf_copy_partial+0x3d>

  left = 0;
  804f7d:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f83:	eb 65                	jmp    804fea <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  804f85:	83 ec 04             	sub    $0x4,%esp
  804f88:	68 54 1f 81 00       	push   $0x811f54
  804f8d:	68 ef 02 00 00       	push   $0x2ef
  804f92:	68 84 1c 81 00       	push   $0x811c84
  804f97:	e8 0c 96 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  804f9c:	83 ec 04             	sub    $0x4,%esp
  804f9f:	68 78 1f 81 00       	push   $0x811f78
  804fa4:	68 f0 02 00 00       	push   $0x2f0
  804fa9:	68 84 1c 81 00       	push   $0x811c84
  804fae:	e8 f5 95 00 00       	call   80e5a8 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  804fb3:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  804fb7:	29 c3                	sub    %eax,%ebx
  804fb9:	66 39 df             	cmp    %bx,%di
  804fbc:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  804fbf:	83 ec 04             	sub    $0x4,%esp
  804fc2:	0f b7 d3             	movzwl %bx,%edx
  804fc5:	52                   	push   %edx
  804fc6:	0f b7 c0             	movzwl %ax,%eax
  804fc9:	03 46 04             	add    0x4(%esi),%eax
  804fcc:	50                   	push   %eax
  804fcd:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804fd1:	03 45 0c             	add    0xc(%ebp),%eax
  804fd4:	50                   	push   %eax
  804fd5:	e8 13 a0 00 00       	call   80efed <memcpy>
      copied_total += buf_copy_len;
  804fda:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  804fde:	29 df                	sub    %ebx,%edi
  804fe0:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  804fe3:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  804fe8:	8b 36                	mov    (%esi),%esi
  804fea:	66 85 ff             	test   %di,%di
  804fed:	74 16                	je     805005 <pbuf_copy_partial+0xa6>
  804fef:	85 f6                	test   %esi,%esi
  804ff1:	74 12                	je     805005 <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  804ff3:	66 85 c0             	test   %ax,%ax
  804ff6:	74 bb                	je     804fb3 <pbuf_copy_partial+0x54>
  804ff8:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  804ffc:	66 39 c2             	cmp    %ax,%dx
  804fff:	77 b2                	ja     804fb3 <pbuf_copy_partial+0x54>
      offset -= p->len;
  805001:	29 d0                	sub    %edx,%eax
  805003:	eb e3                	jmp    804fe8 <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  805005:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805009:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80500c:	5b                   	pop    %ebx
  80500d:	5e                   	pop    %esi
  80500e:	5f                   	pop    %edi
  80500f:	5d                   	pop    %ebp
  805010:	c3                   	ret    

00805011 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805011:	55                   	push   %ebp
  805012:	89 e5                	mov    %esp,%ebp
  805014:	83 ec 14             	sub    $0x14,%esp
  805017:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80501a:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  80501f:	8b 40 04             	mov    0x4(%eax),%eax
  805022:	ff 30                	pushl  (%eax)
  805024:	e8 2a 50 00 00       	call   80a053 <sys_sem_signal>
}
  805029:	83 c4 10             	add    $0x10,%esp
  80502c:	c9                   	leave  
  80502d:	c3                   	ret    

0080502e <sys_mbox_fetch>:
{
  80502e:	55                   	push   %ebp
  80502f:	89 e5                	mov    %esp,%ebp
  805031:	57                   	push   %edi
  805032:	56                   	push   %esi
  805033:	53                   	push   %ebx
  805034:	83 ec 0c             	sub    $0xc,%esp
  805037:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80503a:	eb 40                	jmp    80507c <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80503c:	83 ec 04             	sub    $0x4,%esp
  80503f:	6a 00                	push   $0x0
  805041:	57                   	push   %edi
  805042:	ff 75 08             	pushl  0x8(%ebp)
  805045:	e8 7e 52 00 00       	call   80a2c8 <sys_arch_mbox_fetch>
  80504a:	83 c4 10             	add    $0x10,%esp
}
  80504d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805050:	5b                   	pop    %ebx
  805051:	5e                   	pop    %esi
  805052:	5f                   	pop    %edi
  805053:	5d                   	pop    %ebp
  805054:	c3                   	ret    
      tmptimeout = timeouts->next;
  805055:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805057:	8b 10                	mov    (%eax),%edx
  805059:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  80505b:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80505e:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805061:	83 ec 08             	sub    $0x8,%esp
  805064:	50                   	push   %eax
  805065:	6a 0b                	push   $0xb
  805067:	e8 2a f4 ff ff       	call   804496 <memp_free>
      if (h != NULL) {
  80506c:	83 c4 10             	add    $0x10,%esp
  80506f:	85 db                	test   %ebx,%ebx
  805071:	74 09                	je     80507c <sys_mbox_fetch+0x4e>
        h(arg);
  805073:	83 ec 0c             	sub    $0xc,%esp
  805076:	56                   	push   %esi
  805077:	ff d3                	call   *%ebx
  805079:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80507c:	e8 dc 53 00 00       	call   80a45d <sys_arch_timeouts>
  805081:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805083:	85 c0                	test   %eax,%eax
  805085:	74 b5                	je     80503c <sys_mbox_fetch+0xe>
  805087:	8b 00                	mov    (%eax),%eax
  805089:	85 c0                	test   %eax,%eax
  80508b:	74 af                	je     80503c <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  80508d:	8b 40 04             	mov    0x4(%eax),%eax
  805090:	85 c0                	test   %eax,%eax
  805092:	74 c1                	je     805055 <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  805094:	83 ec 04             	sub    $0x4,%esp
  805097:	50                   	push   %eax
  805098:	57                   	push   %edi
  805099:	ff 75 08             	pushl  0x8(%ebp)
  80509c:	e8 27 52 00 00       	call   80a2c8 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8050a1:	83 c4 10             	add    $0x10,%esp
  8050a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8050a7:	74 ac                	je     805055 <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  8050a9:	8b 1b                	mov    (%ebx),%ebx
  8050ab:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8050ae:	89 ca                	mov    %ecx,%edx
  8050b0:	29 c2                	sub    %eax,%edx
  8050b2:	39 c1                	cmp    %eax,%ecx
  8050b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8050b9:	0f 46 d0             	cmovbe %eax,%edx
  8050bc:	89 53 04             	mov    %edx,0x4(%ebx)
  8050bf:	eb 8c                	jmp    80504d <sys_mbox_fetch+0x1f>

008050c1 <sys_sem_wait>:
{
  8050c1:	55                   	push   %ebp
  8050c2:	89 e5                	mov    %esp,%ebp
  8050c4:	57                   	push   %edi
  8050c5:	56                   	push   %esi
  8050c6:	53                   	push   %ebx
  8050c7:	83 ec 0c             	sub    $0xc,%esp
  8050ca:	8b 75 08             	mov    0x8(%ebp),%esi
  8050cd:	eb 3d                	jmp    80510c <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  8050cf:	83 ec 08             	sub    $0x8,%esp
  8050d2:	6a 00                	push   $0x0
  8050d4:	56                   	push   %esi
  8050d5:	e8 e9 4f 00 00       	call   80a0c3 <sys_arch_sem_wait>
  8050da:	83 c4 10             	add    $0x10,%esp
}
  8050dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050e0:	5b                   	pop    %ebx
  8050e1:	5e                   	pop    %esi
  8050e2:	5f                   	pop    %edi
  8050e3:	5d                   	pop    %ebp
  8050e4:	c3                   	ret    
      tmptimeout = timeouts->next;
  8050e5:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050e7:	8b 10                	mov    (%eax),%edx
  8050e9:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8050eb:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8050ee:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8050f1:	83 ec 08             	sub    $0x8,%esp
  8050f4:	50                   	push   %eax
  8050f5:	6a 0b                	push   $0xb
  8050f7:	e8 9a f3 ff ff       	call   804496 <memp_free>
      if (h != NULL) {
  8050fc:	83 c4 10             	add    $0x10,%esp
  8050ff:	85 db                	test   %ebx,%ebx
  805101:	74 09                	je     80510c <sys_sem_wait+0x4b>
        h(arg);
  805103:	83 ec 0c             	sub    $0xc,%esp
  805106:	57                   	push   %edi
  805107:	ff d3                	call   *%ebx
  805109:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80510c:	e8 4c 53 00 00       	call   80a45d <sys_arch_timeouts>
  805111:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805113:	85 c0                	test   %eax,%eax
  805115:	74 b8                	je     8050cf <sys_sem_wait+0xe>
  805117:	8b 00                	mov    (%eax),%eax
  805119:	85 c0                	test   %eax,%eax
  80511b:	74 b2                	je     8050cf <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  80511d:	8b 40 04             	mov    0x4(%eax),%eax
  805120:	85 c0                	test   %eax,%eax
  805122:	74 c1                	je     8050e5 <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805124:	83 ec 08             	sub    $0x8,%esp
  805127:	50                   	push   %eax
  805128:	56                   	push   %esi
  805129:	e8 95 4f 00 00       	call   80a0c3 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80512e:	83 c4 10             	add    $0x10,%esp
  805131:	83 f8 ff             	cmp    $0xffffffff,%eax
  805134:	74 af                	je     8050e5 <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  805136:	8b 1b                	mov    (%ebx),%ebx
  805138:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  80513b:	89 ca                	mov    %ecx,%edx
  80513d:	29 c2                	sub    %eax,%edx
  80513f:	39 c1                	cmp    %eax,%ecx
  805141:	b8 00 00 00 00       	mov    $0x0,%eax
  805146:	0f 46 d0             	cmovbe %eax,%edx
  805149:	89 53 04             	mov    %edx,0x4(%ebx)
  80514c:	eb 8f                	jmp    8050dd <sys_sem_wait+0x1c>

0080514e <sys_timeout>:
{
  80514e:	55                   	push   %ebp
  80514f:	89 e5                	mov    %esp,%ebp
  805151:	57                   	push   %edi
  805152:	56                   	push   %esi
  805153:	53                   	push   %ebx
  805154:	83 ec 28             	sub    $0x28,%esp
  805157:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80515a:	6a 0b                	push   $0xb
  80515c:	e8 df f2 ff ff       	call   804440 <memp_malloc>
  if (timeout == NULL) {
  805161:	83 c4 10             	add    $0x10,%esp
  805164:	85 c0                	test   %eax,%eax
  805166:	74 40                	je     8051a8 <sys_timeout+0x5a>
  805168:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  80516a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805170:	8b 45 0c             	mov    0xc(%ebp),%eax
  805173:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  805176:	8b 45 10             	mov    0x10(%ebp),%eax
  805179:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  80517c:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  80517f:	e8 d9 52 00 00       	call   80a45d <sys_arch_timeouts>
  if (timeouts == NULL) {
  805184:	85 c0                	test   %eax,%eax
  805186:	74 37                	je     8051bf <sys_timeout+0x71>
  if (timeouts->next == NULL) {
  805188:	8b 10                	mov    (%eax),%edx
  80518a:	85 d2                	test   %edx,%edx
  80518c:	74 48                	je     8051d6 <sys_timeout+0x88>
  if (timeouts->next->time > msecs) {
  80518e:	8b 4a 04             	mov    0x4(%edx),%ecx
  805191:	39 f1                	cmp    %esi,%ecx
  805193:	76 47                	jbe    8051dc <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  805195:	29 f1                	sub    %esi,%ecx
  805197:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  80519a:	8b 10                	mov    (%eax),%edx
  80519c:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  80519e:	89 18                	mov    %ebx,(%eax)
}
  8051a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8051a3:	5b                   	pop    %ebx
  8051a4:	5e                   	pop    %esi
  8051a5:	5f                   	pop    %edi
  8051a6:	5d                   	pop    %ebp
  8051a7:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8051a8:	83 ec 04             	sub    $0x4,%esp
  8051ab:	68 9d 1f 81 00       	push   $0x811f9d
  8051b0:	68 c3 00 00 00       	push   $0xc3
  8051b5:	68 ba 1f 81 00       	push   $0x811fba
  8051ba:	e8 e9 93 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8051bf:	83 ec 04             	sub    $0x4,%esp
  8051c2:	68 ce 1f 81 00       	push   $0x811fce
  8051c7:	68 d1 00 00 00       	push   $0xd1
  8051cc:	68 ba 1f 81 00       	push   $0x811fba
  8051d1:	e8 d2 93 00 00       	call   80e5a8 <_panic>
    timeouts->next = timeout;
  8051d6:	89 18                	mov    %ebx,(%eax)
    return;
  8051d8:	eb c6                	jmp    8051a0 <sys_timeout+0x52>
      if (t->next == NULL || t->next->time > timeout->time) {
  8051da:	89 c2                	mov    %eax,%edx
      timeout->time -= t->time;
  8051dc:	8b 7b 04             	mov    0x4(%ebx),%edi
  8051df:	8b 42 04             	mov    0x4(%edx),%eax
  8051e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8051e5:	89 f9                	mov    %edi,%ecx
  8051e7:	29 c1                	sub    %eax,%ecx
  8051e9:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8051ec:	8b 02                	mov    (%edx),%eax
  8051ee:	85 c0                	test   %eax,%eax
  8051f0:	74 17                	je     805209 <sys_timeout+0xbb>
  8051f2:	8b 70 04             	mov    0x4(%eax),%esi
  8051f5:	89 75 e0             	mov    %esi,-0x20(%ebp)
  8051f8:	39 f1                	cmp    %esi,%ecx
  8051fa:	73 de                	jae    8051da <sys_timeout+0x8c>
  8051fc:	8b 75 e4             	mov    -0x1c(%ebp),%esi
          t->next->time -= timeout->time;
  8051ff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  805202:	29 f9                	sub    %edi,%ecx
  805204:	01 ce                	add    %ecx,%esi
  805206:	89 70 04             	mov    %esi,0x4(%eax)
        timeout->next = t->next;
  805209:	8b 02                	mov    (%edx),%eax
  80520b:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80520d:	89 1a                	mov    %ebx,(%edx)
        break;
  80520f:	eb 8f                	jmp    8051a0 <sys_timeout+0x52>

00805211 <sys_untimeout>:
{
  805211:	55                   	push   %ebp
  805212:	89 e5                	mov    %esp,%ebp
  805214:	57                   	push   %edi
  805215:	56                   	push   %esi
  805216:	53                   	push   %ebx
  805217:	83 ec 0c             	sub    $0xc,%esp
  80521a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80521d:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805220:	e8 38 52 00 00       	call   80a45d <sys_arch_timeouts>
  if (timeouts == NULL) {
  805225:	85 c0                	test   %eax,%eax
  805227:	74 0d                	je     805236 <sys_untimeout+0x25>
  if (timeouts->next == NULL) {
  805229:	8b 10                	mov    (%eax),%edx
  80522b:	85 d2                	test   %edx,%edx
  80522d:	74 5a                	je     805289 <sys_untimeout+0x78>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80522f:	bf 00 00 00 00       	mov    $0x0,%edi
  805234:	eb 27                	jmp    80525d <sys_untimeout+0x4c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805236:	83 ec 04             	sub    $0x4,%esp
  805239:	68 ec 1f 81 00       	push   $0x811fec
  80523e:	68 00 01 00 00       	push   $0x100
  805243:	68 ba 1f 81 00       	push   $0x811fba
  805248:	e8 5b 93 00 00       	call   80e5a8 <_panic>
        timeouts->next = t->next;
  80524d:	8b 0a                	mov    (%edx),%ecx
  80524f:	89 08                	mov    %ecx,(%eax)
  805251:	eb 1c                	jmp    80526f <sys_untimeout+0x5e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805253:	8b 0a                	mov    (%edx),%ecx
  805255:	89 d7                	mov    %edx,%edi
  805257:	85 c9                	test   %ecx,%ecx
  805259:	74 2e                	je     805289 <sys_untimeout+0x78>
  80525b:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80525d:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805260:	75 f1                	jne    805253 <sys_untimeout+0x42>
  805262:	39 72 0c             	cmp    %esi,0xc(%edx)
  805265:	75 ec                	jne    805253 <sys_untimeout+0x42>
      if (prev_t == NULL)
  805267:	85 ff                	test   %edi,%edi
  805269:	74 e2                	je     80524d <sys_untimeout+0x3c>
        prev_t->next = t->next;
  80526b:	8b 02                	mov    (%edx),%eax
  80526d:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  80526f:	8b 02                	mov    (%edx),%eax
  805271:	85 c0                	test   %eax,%eax
  805273:	74 06                	je     80527b <sys_untimeout+0x6a>
        t->next->time += t->time;
  805275:	8b 4a 04             	mov    0x4(%edx),%ecx
  805278:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80527b:	83 ec 08             	sub    $0x8,%esp
  80527e:	52                   	push   %edx
  80527f:	6a 0b                	push   $0xb
  805281:	e8 10 f2 ff ff       	call   804496 <memp_free>
      return;
  805286:	83 c4 10             	add    $0x10,%esp
}
  805289:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80528c:	5b                   	pop    %ebx
  80528d:	5e                   	pop    %esi
  80528e:	5f                   	pop    %edi
  80528f:	5d                   	pop    %ebp
  805290:	c3                   	ret    

00805291 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805291:	55                   	push   %ebp
  805292:	89 e5                	mov    %esp,%ebp
  805294:	83 ec 18             	sub    $0x18,%esp
  805297:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80529a:	8d 4d 08             	lea    0x8(%ebp),%ecx
  80529d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8052a0:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8052a6:	85 c0                	test   %eax,%eax
  8052a8:	75 1c                	jne    8052c6 <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  8052aa:	83 ec 0c             	sub    $0xc,%esp
  8052ad:	ff 75 08             	pushl  0x8(%ebp)
  8052b0:	e8 0c fe ff ff       	call   8050c1 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8052b5:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8052b8:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  8052bd:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8052c2:	74 19                	je     8052dd <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8052c4:	c9                   	leave  
  8052c5:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8052c6:	83 ec 04             	sub    $0x4,%esp
  8052c9:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8052cc:	52                   	push   %edx
  8052cd:	68 11 50 80 00       	push   $0x805011
  8052d2:	50                   	push   %eax
  8052d3:	e8 76 fe ff ff       	call   80514e <sys_timeout>
  8052d8:	83 c4 10             	add    $0x10,%esp
  8052db:	eb cd                	jmp    8052aa <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  8052dd:	83 ec 08             	sub    $0x8,%esp
  8052e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8052e3:	50                   	push   %eax
  8052e4:	68 11 50 80 00       	push   $0x805011
  8052e9:	e8 23 ff ff ff       	call   805211 <sys_untimeout>
    return 1;
  8052ee:	83 c4 10             	add    $0x10,%esp
  8052f1:	b8 01 00 00 00       	mov    $0x1,%eax
  8052f6:	eb cc                	jmp    8052c4 <sys_sem_wait_timeout+0x33>

008052f8 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  8052f8:	55                   	push   %ebp
  8052f9:	89 e5                	mov    %esp,%ebp
  8052fb:	53                   	push   %ebx
  8052fc:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8052ff:	6a 00                	push   $0x0
  805301:	e8 90 4a 00 00       	call   809d96 <sys_sem_new>
  805306:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805308:	83 c4 08             	add    $0x8,%esp
  80530b:	ff 75 08             	pushl  0x8(%ebp)
  80530e:	50                   	push   %eax
  80530f:	e8 7d ff ff ff       	call   805291 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805314:	89 1c 24             	mov    %ebx,(%esp)
  805317:	e8 fb 4a 00 00       	call   809e17 <sys_sem_free>
}
  80531c:	83 c4 10             	add    $0x10,%esp
  80531f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805322:	c9                   	leave  
  805323:	c3                   	ret    

00805324 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805324:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  805329:	c3                   	ret    

0080532a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80532a:	55                   	push   %ebp
  80532b:	89 e5                	mov    %esp,%ebp
  80532d:	57                   	push   %edi
  80532e:	56                   	push   %esi
  80532f:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805330:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805336:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80533c:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  805342:	0f b7 05 0c 40 81 00 	movzwl 0x81400c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  805349:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80534e:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805352:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805355:	89 da                	mov    %ebx,%edx
  805357:	85 d2                	test   %edx,%edx
  805359:	74 0b                	je     805366 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  80535b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80535f:	74 ed                	je     80534e <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805361:	8b 52 0c             	mov    0xc(%edx),%edx
  805364:	eb f1                	jmp    805357 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805366:	89 f2                	mov    %esi,%edx
  805368:	85 d2                	test   %edx,%edx
  80536a:	74 0b                	je     805377 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  80536c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805370:	74 dc                	je     80534e <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805372:	8b 52 0c             	mov    0xc(%edx),%edx
  805375:	eb f1                	jmp    805368 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805377:	89 fa                	mov    %edi,%edx
  805379:	85 d2                	test   %edx,%edx
  80537b:	74 0b                	je     805388 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  80537d:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805381:	74 cb                	je     80534e <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805383:	8b 52 0c             	mov    0xc(%edx),%edx
  805386:	eb f1                	jmp    805379 <tcp_new_port+0x4f>
  805388:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
      goto again;
    }
  }
  return port;
}
  80538e:	5b                   	pop    %ebx
  80538f:	5e                   	pop    %esi
  805390:	5f                   	pop    %edi
  805391:	5d                   	pop    %ebp
  805392:	c3                   	ret    

00805393 <tcp_bind>:
{
  805393:	55                   	push   %ebp
  805394:	89 e5                	mov    %esp,%ebp
  805396:	57                   	push   %edi
  805397:	56                   	push   %esi
  805398:	53                   	push   %ebx
  805399:	83 ec 0c             	sub    $0xc,%esp
  80539c:	8b 75 08             	mov    0x8(%ebp),%esi
  80539f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8053a2:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053a5:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8053a9:	75 0f                	jne    8053ba <tcp_bind+0x27>
  8053ab:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  8053ad:	66 85 d2             	test   %dx,%dx
  8053b0:	74 1f                	je     8053d1 <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053b2:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  8053b8:	eb 21                	jmp    8053db <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8053ba:	83 ec 04             	sub    $0x4,%esp
  8053bd:	68 0c 20 81 00       	push   $0x81200c
  8053c2:	68 05 01 00 00       	push   $0x105
  8053c7:	68 ee 21 81 00       	push   $0x8121ee
  8053cc:	e8 d7 91 00 00       	call   80e5a8 <_panic>
    port = tcp_new_port();
  8053d1:	e8 54 ff ff ff       	call   80532a <tcp_new_port>
  8053d6:	eb da                	jmp    8053b2 <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  8053d8:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8053db:	85 d2                	test   %edx,%edx
  8053dd:	74 2c                	je     80540b <tcp_bind+0x78>
    if (cpcb->local_port == port) {
  8053df:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8053e3:	75 f3                	jne    8053d8 <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8053e5:	8b 0a                	mov    (%edx),%ecx
  8053e7:	85 db                	test   %ebx,%ebx
  8053e9:	0f 84 d4 00 00 00    	je     8054c3 <tcp_bind+0x130>
  8053ef:	85 c9                	test   %ecx,%ecx
  8053f1:	0f 84 cc 00 00 00    	je     8054c3 <tcp_bind+0x130>
          ip_addr_isany(ipaddr) ||
  8053f7:	8b 3b                	mov    (%ebx),%edi
  8053f9:	39 f9                	cmp    %edi,%ecx
  8053fb:	74 04                	je     805401 <tcp_bind+0x6e>
  8053fd:	85 ff                	test   %edi,%edi
  8053ff:	75 d7                	jne    8053d8 <tcp_bind+0x45>
        return ERR_USE;
  805401:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805406:	e9 bd 00 00 00       	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_active_pcbs;
  80540b:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  805411:	eb 03                	jmp    805416 <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  805413:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805416:	85 d2                	test   %edx,%edx
  805418:	74 2c                	je     805446 <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  80541a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80541e:	75 f3                	jne    805413 <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805420:	8b 0a                	mov    (%edx),%ecx
  805422:	85 db                	test   %ebx,%ebx
  805424:	0f 84 a6 00 00 00    	je     8054d0 <tcp_bind+0x13d>
  80542a:	85 c9                	test   %ecx,%ecx
  80542c:	0f 84 9e 00 00 00    	je     8054d0 <tcp_bind+0x13d>
          ip_addr_isany(ipaddr) ||
  805432:	8b 3b                	mov    (%ebx),%edi
  805434:	39 f9                	cmp    %edi,%ecx
  805436:	74 04                	je     80543c <tcp_bind+0xa9>
  805438:	85 ff                	test   %edi,%edi
  80543a:	75 d7                	jne    805413 <tcp_bind+0x80>
        return ERR_USE;
  80543c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805441:	e9 82 00 00 00       	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805446:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80544c:	eb 03                	jmp    805451 <tcp_bind+0xbe>
  80544e:	8b 52 0c             	mov    0xc(%edx),%edx
  805451:	85 d2                	test   %edx,%edx
  805453:	74 21                	je     805476 <tcp_bind+0xe3>
    if (cpcb->local_port == port) {
  805455:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805459:	75 f3                	jne    80544e <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80545b:	8b 0a                	mov    (%edx),%ecx
  80545d:	85 db                	test   %ebx,%ebx
  80545f:	74 76                	je     8054d7 <tcp_bind+0x144>
  805461:	85 c9                	test   %ecx,%ecx
  805463:	74 72                	je     8054d7 <tcp_bind+0x144>
          ip_addr_isany(ipaddr) ||
  805465:	8b 3b                	mov    (%ebx),%edi
  805467:	39 f9                	cmp    %edi,%ecx
  805469:	74 04                	je     80546f <tcp_bind+0xdc>
  80546b:	85 ff                	test   %edi,%edi
  80546d:	75 df                	jne    80544e <tcp_bind+0xbb>
        return ERR_USE;
  80546f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805474:	eb 52                	jmp    8054c8 <tcp_bind+0x135>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805476:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  80547c:	eb 03                	jmp    805481 <tcp_bind+0xee>
  80547e:	8b 52 0c             	mov    0xc(%edx),%edx
  805481:	85 d2                	test   %edx,%edx
  805483:	74 13                	je     805498 <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  805485:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805489:	75 f3                	jne    80547e <tcp_bind+0xeb>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80548b:	8b 3b                	mov    (%ebx),%edi
  80548d:	39 3a                	cmp    %edi,(%edx)
  80548f:	75 ed                	jne    80547e <tcp_bind+0xeb>
        return ERR_USE;
  805491:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805496:	eb 30                	jmp    8054c8 <tcp_bind+0x135>
  if (!ip_addr_isany(ipaddr)) {
  805498:	85 db                	test   %ebx,%ebx
  80549a:	74 09                	je     8054a5 <tcp_bind+0x112>
  80549c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80549f:	74 04                	je     8054a5 <tcp_bind+0x112>
    pcb->local_ip = *ipaddr;
  8054a1:	8b 13                	mov    (%ebx),%edx
  8054a3:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  8054a5:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8054a9:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  8054ae:	89 46 0c             	mov    %eax,0xc(%esi)
  8054b1:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  8054b7:	e8 fd cc ff ff       	call   8021b9 <tcp_timer_needed>
  return ERR_OK;
  8054bc:	b8 00 00 00 00       	mov    $0x0,%eax
  8054c1:	eb 05                	jmp    8054c8 <tcp_bind+0x135>
        return ERR_USE;
  8054c3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8054c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8054cb:	5b                   	pop    %ebx
  8054cc:	5e                   	pop    %esi
  8054cd:	5f                   	pop    %edi
  8054ce:	5d                   	pop    %ebp
  8054cf:	c3                   	ret    
        return ERR_USE;
  8054d0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054d5:	eb f1                	jmp    8054c8 <tcp_bind+0x135>
        return ERR_USE;
  8054d7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054dc:	eb ea                	jmp    8054c8 <tcp_bind+0x135>

008054de <tcp_listen_with_backlog>:
{
  8054de:	55                   	push   %ebp
  8054df:	89 e5                	mov    %esp,%ebp
  8054e1:	57                   	push   %edi
  8054e2:	56                   	push   %esi
  8054e3:	53                   	push   %ebx
  8054e4:	83 ec 1c             	sub    $0x1c,%esp
  8054e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8054ea:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8054ee:	0f 85 80 00 00 00    	jne    805574 <tcp_listen_with_backlog+0x96>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  8054f4:	83 ec 0c             	sub    $0xc,%esp
  8054f7:	6a 03                	push   $0x3
  8054f9:	e8 42 ef ff ff       	call   804440 <memp_malloc>
  8054fe:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805500:	83 c4 10             	add    $0x10,%esp
  805503:	85 c0                	test   %eax,%eax
  805505:	0f 84 b7 00 00 00    	je     8055c2 <tcp_listen_with_backlog+0xe4>
  lpcb->callback_arg = pcb->callback_arg;
  80550b:	8b 43 18             	mov    0x18(%ebx),%eax
  80550e:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805511:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805515:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805519:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  805520:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805524:	83 c8 02             	or     $0x2,%eax
  805527:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80552b:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80552f:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805532:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805536:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805539:	8b 03                	mov    (%ebx),%eax
  80553b:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80553d:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805543:	39 da                	cmp    %ebx,%edx
  805545:	74 44                	je     80558b <tcp_listen_with_backlog+0xad>
  805547:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80554d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805551:	89 df                	mov    %ebx,%edi
  805553:	85 d2                	test   %edx,%edx
  805555:	0f 84 87 00 00 00    	je     8055e2 <tcp_listen_with_backlog+0x104>
  80555b:	8b 42 0c             	mov    0xc(%edx),%eax
  80555e:	39 f8                	cmp    %edi,%eax
  805560:	0f 94 c3             	sete   %bl
  805563:	85 c0                	test   %eax,%eax
  805565:	0f 95 c1             	setne  %cl
  805568:	84 cb                	test   %cl,%bl
  80556a:	75 60                	jne    8055cc <tcp_listen_with_backlog+0xee>
  80556c:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805570:	89 c2                	mov    %eax,%edx
  805572:	eb df                	jmp    805553 <tcp_listen_with_backlog+0x75>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805574:	83 ec 04             	sub    $0x4,%esp
  805577:	68 38 20 81 00       	push   $0x812038
  80557c:	68 60 01 00 00       	push   $0x160
  805581:	68 ee 21 81 00       	push   $0x8121ee
  805586:	e8 1d 90 00 00       	call   80e5a8 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80558b:	8b 43 0c             	mov    0xc(%ebx),%eax
  80558e:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805593:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80559a:	83 ec 08             	sub    $0x8,%esp
  80559d:	53                   	push   %ebx
  80559e:	6a 02                	push   $0x2
  8055a0:	e8 f1 ee ff ff       	call   804496 <memp_free>
  lpcb->accept = tcp_accept_null;
  8055a5:	c7 46 20 24 53 80 00 	movl   $0x805324,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8055ac:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  8055b1:	89 46 0c             	mov    %eax,0xc(%esi)
  8055b4:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  8055ba:	e8 fa cb ff ff       	call   8021b9 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8055bf:	83 c4 10             	add    $0x10,%esp
}
  8055c2:	89 f0                	mov    %esi,%eax
  8055c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8055c7:	5b                   	pop    %ebx
  8055c8:	5e                   	pop    %esi
  8055c9:	5f                   	pop    %edi
  8055ca:	5d                   	pop    %ebp
  8055cb:	c3                   	ret    
  8055cc:	89 fb                	mov    %edi,%ebx
  8055ce:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8055d2:	74 06                	je     8055da <tcp_listen_with_backlog+0xfc>
  8055d4:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055da:	8b 43 0c             	mov    0xc(%ebx),%eax
  8055dd:	89 42 0c             	mov    %eax,0xc(%edx)
  8055e0:	eb b1                	jmp    805593 <tcp_listen_with_backlog+0xb5>
  8055e2:	89 fb                	mov    %edi,%ebx
  8055e4:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8055e8:	74 a9                	je     805593 <tcp_listen_with_backlog+0xb5>
  8055ea:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8055f1:	00 00 00 
  8055f4:	eb 9d                	jmp    805593 <tcp_listen_with_backlog+0xb5>

008055f6 <tcp_recved>:
{
  8055f6:	55                   	push   %ebp
  8055f7:	89 e5                	mov    %esp,%ebp
  8055f9:	56                   	push   %esi
  8055fa:	53                   	push   %ebx
  8055fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8055fe:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805601:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805605:	0f b7 ca             	movzwl %dx,%ecx
  805608:	0f b7 f3             	movzwl %bx,%esi
  80560b:	01 f1                	add    %esi,%ecx
  80560d:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805613:	76 27                	jbe    80563c <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  805615:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80561b:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805621:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805625:	f6 c2 03             	test   $0x3,%dl
  805628:	75 3b                	jne    805665 <tcp_recved+0x6f>
    tcp_ack(pcb);
  80562a:	f6 c2 01             	test   $0x1,%dl
  80562d:	75 1f                	jne    80564e <tcp_recved+0x58>
  80562f:	83 ca 01             	or     $0x1,%edx
  805632:	88 50 20             	mov    %dl,0x20(%eax)
}
  805635:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805638:	5b                   	pop    %ebx
  805639:	5e                   	pop    %esi
  80563a:	5d                   	pop    %ebp
  80563b:	c3                   	ret    
    pcb->rcv_wnd += len;
  80563c:	01 da                	add    %ebx,%edx
  80563e:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805642:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805646:	72 d9                	jb     805621 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805648:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  80564c:	eb d3                	jmp    805621 <tcp_recved+0x2b>
    tcp_ack(pcb);
  80564e:	83 e2 fe             	and    $0xfffffffe,%edx
  805651:	83 ca 02             	or     $0x2,%edx
  805654:	88 50 20             	mov    %dl,0x20(%eax)
  805657:	83 ec 0c             	sub    $0xc,%esp
  80565a:	50                   	push   %eax
  80565b:	e8 be 29 00 00       	call   80801e <tcp_output>
  805660:	83 c4 10             	add    $0x10,%esp
  805663:	eb d0                	jmp    805635 <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805665:	f6 c2 01             	test   $0x1,%dl
  805668:	74 cb                	je     805635 <tcp_recved+0x3f>
  80566a:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805670:	76 c3                	jbe    805635 <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805672:	83 ca 02             	or     $0x2,%edx
  805675:	88 50 20             	mov    %dl,0x20(%eax)
  805678:	83 ec 0c             	sub    $0xc,%esp
  80567b:	50                   	push   %eax
  80567c:	e8 9d 29 00 00       	call   80801e <tcp_output>
  805681:	83 c4 10             	add    $0x10,%esp
}
  805684:	eb af                	jmp    805635 <tcp_recved+0x3f>

00805686 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805686:	55                   	push   %ebp
  805687:	89 e5                	mov    %esp,%ebp
  805689:	53                   	push   %ebx
  80568a:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80568d:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  805693:	eb 21                	jmp    8056b6 <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805695:	83 ec 0c             	sub    $0xc,%esp
  805698:	50                   	push   %eax
  805699:	e8 45 f1 ff ff       	call   8047e3 <pbuf_free>
  80569e:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8056a1:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8056a8:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8056ab:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8056af:	a8 01                	test   $0x1,%al
  8056b1:	75 2d                	jne    8056e0 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8056b3:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8056b6:	85 db                	test   %ebx,%ebx
  8056b8:	74 3e                	je     8056f8 <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  8056ba:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8056c0:	85 c0                	test   %eax,%eax
  8056c2:	74 e7                	je     8056ab <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8056c4:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8056ca:	85 d2                	test   %edx,%edx
  8056cc:	74 c7                	je     805695 <tcp_fasttmr+0xf>
  8056ce:	6a 00                	push   $0x0
  8056d0:	50                   	push   %eax
  8056d1:	53                   	push   %ebx
  8056d2:	ff 73 18             	pushl  0x18(%ebx)
  8056d5:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8056d7:	83 c4 10             	add    $0x10,%esp
  8056da:	84 c0                	test   %al,%al
  8056dc:	74 c3                	je     8056a1 <tcp_fasttmr+0x1b>
  8056de:	eb cb                	jmp    8056ab <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8056e0:	83 c8 02             	or     $0x2,%eax
  8056e3:	88 43 20             	mov    %al,0x20(%ebx)
  8056e6:	83 ec 0c             	sub    $0xc,%esp
  8056e9:	53                   	push   %ebx
  8056ea:	e8 2f 29 00 00       	call   80801e <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8056ef:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  8056f3:	83 c4 10             	add    $0x10,%esp
  8056f6:	eb bb                	jmp    8056b3 <tcp_fasttmr+0x2d>
    }
  }
}
  8056f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8056fb:	c9                   	leave  
  8056fc:	c3                   	ret    

008056fd <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8056fd:	55                   	push   %ebp
  8056fe:	89 e5                	mov    %esp,%ebp
  805700:	56                   	push   %esi
  805701:	53                   	push   %ebx
  805702:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  805705:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  80570a:	85 db                	test   %ebx,%ebx
  80570c:	74 23                	je     805731 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  80570e:	8b 43 04             	mov    0x4(%ebx),%eax
  805711:	85 c0                	test   %eax,%eax
  805713:	74 0e                	je     805723 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805715:	83 ec 0c             	sub    $0xc,%esp
  805718:	50                   	push   %eax
  805719:	e8 c5 f0 ff ff       	call   8047e3 <pbuf_free>
  80571e:	89 c6                	mov    %eax,%esi
  805720:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805723:	83 ec 08             	sub    $0x8,%esp
  805726:	53                   	push   %ebx
  805727:	6a 04                	push   $0x4
  805729:	e8 68 ed ff ff       	call   804496 <memp_free>
  80572e:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  805731:	89 f0                	mov    %esi,%eax
  805733:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805736:	5b                   	pop    %ebx
  805737:	5e                   	pop    %esi
  805738:	5d                   	pop    %ebp
  805739:	c3                   	ret    

0080573a <tcp_segs_free>:
{
  80573a:	55                   	push   %ebp
  80573b:	89 e5                	mov    %esp,%ebp
  80573d:	56                   	push   %esi
  80573e:	53                   	push   %ebx
  80573f:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805742:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  805747:	85 c0                	test   %eax,%eax
  805749:	74 14                	je     80575f <tcp_segs_free+0x25>
    next = seg->next;
  80574b:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  80574d:	83 ec 0c             	sub    $0xc,%esp
  805750:	50                   	push   %eax
  805751:	e8 a7 ff ff ff       	call   8056fd <tcp_seg_free>
  805756:	01 c3                	add    %eax,%ebx
    seg = next;
  805758:	83 c4 10             	add    $0x10,%esp
  80575b:	89 f0                	mov    %esi,%eax
  80575d:	eb e8                	jmp    805747 <tcp_segs_free+0xd>
}
  80575f:	89 d8                	mov    %ebx,%eax
  805761:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805764:	5b                   	pop    %ebx
  805765:	5e                   	pop    %esi
  805766:	5d                   	pop    %ebp
  805767:	c3                   	ret    

00805768 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805768:	55                   	push   %ebp
  805769:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80576b:	8b 45 08             	mov    0x8(%ebp),%eax
  80576e:	8b 55 0c             	mov    0xc(%ebp),%edx
  805771:	88 50 14             	mov    %dl,0x14(%eax)
}
  805774:	5d                   	pop    %ebp
  805775:	c3                   	ret    

00805776 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805776:	55                   	push   %ebp
  805777:	89 e5                	mov    %esp,%ebp
  805779:	53                   	push   %ebx
  80577a:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80577d:	6a 04                	push   $0x4
  80577f:	e8 bc ec ff ff       	call   804440 <memp_malloc>
  805784:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805786:	83 c4 10             	add    $0x10,%esp
  805789:	85 c0                	test   %eax,%eax
  80578b:	74 1c                	je     8057a9 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80578d:	83 ec 04             	sub    $0x4,%esp
  805790:	6a 14                	push   $0x14
  805792:	ff 75 08             	pushl  0x8(%ebp)
  805795:	50                   	push   %eax
  805796:	e8 52 98 00 00       	call   80efed <memcpy>
  pbuf_ref(cseg->p);
  80579b:	83 c4 04             	add    $0x4,%esp
  80579e:	ff 73 04             	pushl  0x4(%ebx)
  8057a1:	e8 9f f4 ff ff       	call   804c45 <pbuf_ref>
  return cseg;
  8057a6:	83 c4 10             	add    $0x10,%esp
}
  8057a9:	89 d8                	mov    %ebx,%eax
  8057ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057ae:	c9                   	leave  
  8057af:	c3                   	ret    

008057b0 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8057b0:	55                   	push   %ebp
  8057b1:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8057b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8057b6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057b9:	89 50 18             	mov    %edx,0x18(%eax)
}
  8057bc:	5d                   	pop    %ebp
  8057bd:	c3                   	ret    

008057be <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8057be:	55                   	push   %ebp
  8057bf:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8057c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8057c4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057c7:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8057cd:	5d                   	pop    %ebp
  8057ce:	c3                   	ret    

008057cf <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8057cf:	55                   	push   %ebp
  8057d0:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  8057d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8057d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057d8:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  8057de:	5d                   	pop    %ebp
  8057df:	c3                   	ret    

008057e0 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8057e0:	55                   	push   %ebp
  8057e1:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  8057e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8057e6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057e9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  8057ef:	5d                   	pop    %ebp
  8057f0:	c3                   	ret    

008057f1 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  8057f1:	55                   	push   %ebp
  8057f2:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8057f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8057f7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8057fa:	89 50 20             	mov    %edx,0x20(%eax)
}
  8057fd:	5d                   	pop    %ebp
  8057fe:	c3                   	ret    

008057ff <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8057ff:	55                   	push   %ebp
  805800:	89 e5                	mov    %esp,%ebp
  805802:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805805:	8b 55 0c             	mov    0xc(%ebp),%edx
  805808:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  80580e:	8b 55 10             	mov    0x10(%ebp),%edx
  805811:	88 50 31             	mov    %dl,0x31(%eax)
}
  805814:	5d                   	pop    %ebp
  805815:	c3                   	ret    

00805816 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805816:	55                   	push   %ebp
  805817:	89 e5                	mov    %esp,%ebp
  805819:	53                   	push   %ebx
  80581a:	83 ec 04             	sub    $0x4,%esp
  80581d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805820:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805823:	83 f8 0a             	cmp    $0xa,%eax
  805826:	74 05                	je     80582d <tcp_pcb_purge+0x17>
  805828:	83 f8 01             	cmp    $0x1,%eax
  80582b:	77 05                	ja     805832 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  80582d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805830:	c9                   	leave  
  805831:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805832:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805838:	85 c0                	test   %eax,%eax
  80583a:	74 16                	je     805852 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  80583c:	83 ec 0c             	sub    $0xc,%esp
  80583f:	50                   	push   %eax
  805840:	e8 9e ef ff ff       	call   8047e3 <pbuf_free>
      pcb->refused_data = NULL;
  805845:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80584c:	00 00 00 
  80584f:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805852:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805858:	83 ec 0c             	sub    $0xc,%esp
  80585b:	ff 73 7c             	pushl  0x7c(%ebx)
  80585e:	e8 d7 fe ff ff       	call   80573a <tcp_segs_free>
    pcb->ooseq = NULL;
  805863:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  80586a:	83 c4 04             	add    $0x4,%esp
  80586d:	ff 73 74             	pushl  0x74(%ebx)
  805870:	e8 c5 fe ff ff       	call   80573a <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805875:	83 c4 04             	add    $0x4,%esp
  805878:	ff 73 78             	pushl  0x78(%ebx)
  80587b:	e8 ba fe ff ff       	call   80573a <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805880:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805887:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  80588e:	83 c4 10             	add    $0x10,%esp
}
  805891:	eb 9a                	jmp    80582d <tcp_pcb_purge+0x17>

00805893 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805893:	55                   	push   %ebp
  805894:	89 e5                	mov    %esp,%ebp
  805896:	57                   	push   %edi
  805897:	56                   	push   %esi
  805898:	53                   	push   %ebx
  805899:	83 ec 0c             	sub    $0xc,%esp
  80589c:	8b 45 08             	mov    0x8(%ebp),%eax
  80589f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8058a2:	8b 10                	mov    (%eax),%edx
  8058a4:	39 da                	cmp    %ebx,%edx
  8058a6:	74 2f                	je     8058d7 <tcp_pcb_remove+0x44>
  8058a8:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8058ae:	bf 00 00 00 00       	mov    $0x0,%edi
  8058b3:	89 de                	mov    %ebx,%esi
  8058b5:	85 d2                	test   %edx,%edx
  8058b7:	0f 84 82 00 00 00    	je     80593f <tcp_pcb_remove+0xac>
  8058bd:	8b 42 0c             	mov    0xc(%edx),%eax
  8058c0:	39 f0                	cmp    %esi,%eax
  8058c2:	0f 94 c3             	sete   %bl
  8058c5:	85 c0                	test   %eax,%eax
  8058c7:	0f 95 c1             	setne  %cl
  8058ca:	84 cb                	test   %cl,%bl
  8058cc:	75 5b                	jne    805929 <tcp_pcb_remove+0x96>
  8058ce:	bf 01 00 00 00       	mov    $0x1,%edi
  8058d3:	89 c2                	mov    %eax,%edx
  8058d5:	eb de                	jmp    8058b5 <tcp_pcb_remove+0x22>
  8058d7:	8b 53 0c             	mov    0xc(%ebx),%edx
  8058da:	89 10                	mov    %edx,(%eax)
  8058dc:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  8058e3:	83 ec 0c             	sub    $0xc,%esp
  8058e6:	53                   	push   %ebx
  8058e7:	e8 2a ff ff ff       	call   805816 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8058ec:	8b 43 10             	mov    0x10(%ebx),%eax
  8058ef:	83 c4 10             	add    $0x10,%esp
  8058f2:	83 f8 0a             	cmp    $0xa,%eax
  8058f5:	74 6e                	je     805965 <tcp_pcb_remove+0xd2>
  8058f7:	83 f8 01             	cmp    $0x1,%eax
  8058fa:	74 69                	je     805965 <tcp_pcb_remove+0xd2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8058fc:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805900:	a8 01                	test   $0x1,%al
  805902:	75 4f                	jne    805953 <tcp_pcb_remove+0xc0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805904:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805908:	75 63                	jne    80596d <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80590a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80590e:	75 74                	jne    805984 <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805910:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805914:	0f 85 81 00 00 00    	jne    80599b <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80591a:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805921:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805924:	5b                   	pop    %ebx
  805925:	5e                   	pop    %esi
  805926:	5f                   	pop    %edi
  805927:	5d                   	pop    %ebp
  805928:	c3                   	ret    
  805929:	89 f3                	mov    %esi,%ebx
  80592b:	89 f8                	mov    %edi,%eax
  80592d:	84 c0                	test   %al,%al
  80592f:	74 06                	je     805937 <tcp_pcb_remove+0xa4>
  805931:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(pcblist, pcb);
  805937:	8b 43 0c             	mov    0xc(%ebx),%eax
  80593a:	89 42 0c             	mov    %eax,0xc(%edx)
  80593d:	eb 9d                	jmp    8058dc <tcp_pcb_remove+0x49>
  80593f:	89 f3                	mov    %esi,%ebx
  805941:	89 f8                	mov    %edi,%eax
  805943:	84 c0                	test   %al,%al
  805945:	74 95                	je     8058dc <tcp_pcb_remove+0x49>
  805947:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80594e:	00 00 00 
  805951:	eb 89                	jmp    8058dc <tcp_pcb_remove+0x49>
    pcb->flags |= TF_ACK_NOW;
  805953:	83 c8 02             	or     $0x2,%eax
  805956:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805959:	83 ec 0c             	sub    $0xc,%esp
  80595c:	53                   	push   %ebx
  80595d:	e8 bc 26 00 00       	call   80801e <tcp_output>
  805962:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805965:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805969:	74 af                	je     80591a <tcp_pcb_remove+0x87>
  80596b:	eb 97                	jmp    805904 <tcp_pcb_remove+0x71>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80596d:	83 ec 04             	sub    $0x4,%esp
  805970:	68 02 22 81 00       	push   $0x812202
  805975:	68 b4 04 00 00       	push   $0x4b4
  80597a:	68 ee 21 81 00       	push   $0x8121ee
  80597f:	e8 24 8c 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805984:	83 ec 04             	sub    $0x4,%esp
  805987:	68 1a 22 81 00       	push   $0x81221a
  80598c:	68 b5 04 00 00       	push   $0x4b5
  805991:	68 ee 21 81 00       	push   $0x8121ee
  805996:	e8 0d 8c 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  80599b:	83 ec 04             	sub    $0x4,%esp
  80599e:	68 33 22 81 00       	push   $0x812233
  8059a3:	68 b7 04 00 00       	push   $0x4b7
  8059a8:	68 ee 21 81 00       	push   $0x8121ee
  8059ad:	e8 f6 8b 00 00       	call   80e5a8 <_panic>

008059b2 <tcp_close>:
{
  8059b2:	55                   	push   %ebp
  8059b3:	89 e5                	mov    %esp,%ebp
  8059b5:	57                   	push   %edi
  8059b6:	56                   	push   %esi
  8059b7:	53                   	push   %ebx
  8059b8:	83 ec 0c             	sub    $0xc,%esp
  8059bb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  8059be:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8059c2:	0f 87 3e 01 00 00    	ja     805b06 <tcp_close+0x154>
  8059c8:	8b 43 10             	mov    0x10(%ebx),%eax
  8059cb:	ff 24 85 4c 22 81 00 	jmp    *0x81224c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8059d2:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8059d8:	39 da                	cmp    %ebx,%edx
  8059da:	74 2b                	je     805a07 <tcp_close+0x55>
  8059dc:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8059e2:	bf 00 00 00 00       	mov    $0x0,%edi
  8059e7:	89 de                	mov    %ebx,%esi
  8059e9:	85 d2                	test   %edx,%edx
  8059eb:	74 57                	je     805a44 <tcp_close+0x92>
  8059ed:	8b 42 0c             	mov    0xc(%edx),%eax
  8059f0:	39 f0                	cmp    %esi,%eax
  8059f2:	0f 94 c3             	sete   %bl
  8059f5:	85 c0                	test   %eax,%eax
  8059f7:	0f 95 c1             	setne  %cl
  8059fa:	84 cb                	test   %cl,%bl
  8059fc:	75 30                	jne    805a2e <tcp_close+0x7c>
  8059fe:	bf 01 00 00 00       	mov    $0x1,%edi
  805a03:	89 c2                	mov    %eax,%edx
  805a05:	eb e2                	jmp    8059e9 <tcp_close+0x37>
  805a07:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a0a:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805a0f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805a16:	83 ec 08             	sub    $0x8,%esp
  805a19:	53                   	push   %ebx
  805a1a:	6a 02                	push   $0x2
  805a1c:	e8 75 ea ff ff       	call   804496 <memp_free>
    break;
  805a21:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a24:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a29:	e9 9a 00 00 00       	jmp    805ac8 <tcp_close+0x116>
  805a2e:	89 f3                	mov    %esi,%ebx
  805a30:	89 f8                	mov    %edi,%eax
  805a32:	84 c0                	test   %al,%al
  805a34:	74 06                	je     805a3c <tcp_close+0x8a>
  805a36:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a3c:	8b 43 0c             	mov    0xc(%ebx),%eax
  805a3f:	89 42 0c             	mov    %eax,0xc(%edx)
  805a42:	eb cb                	jmp    805a0f <tcp_close+0x5d>
  805a44:	89 f3                	mov    %esi,%ebx
  805a46:	89 f8                	mov    %edi,%eax
  805a48:	84 c0                	test   %al,%al
  805a4a:	74 c3                	je     805a0f <tcp_close+0x5d>
  805a4c:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805a53:	00 00 00 
  805a56:	eb b7                	jmp    805a0f <tcp_close+0x5d>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805a58:	83 ec 08             	sub    $0x8,%esp
  805a5b:	53                   	push   %ebx
  805a5c:	68 44 b2 b3 00       	push   $0xb3b244
  805a61:	e8 2d fe ff ff       	call   805893 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805a66:	83 c4 08             	add    $0x8,%esp
  805a69:	53                   	push   %ebx
  805a6a:	6a 03                	push   $0x3
  805a6c:	e8 25 ea ff ff       	call   804496 <memp_free>
    break;
  805a71:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a74:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a79:	eb 4d                	jmp    805ac8 <tcp_close+0x116>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805a7b:	83 ec 08             	sub    $0x8,%esp
  805a7e:	53                   	push   %ebx
  805a7f:	68 3c b2 b3 00       	push   $0xb3b23c
  805a84:	e8 0a fe ff ff       	call   805893 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805a89:	83 c4 08             	add    $0x8,%esp
  805a8c:	53                   	push   %ebx
  805a8d:	6a 02                	push   $0x2
  805a8f:	e8 02 ea ff ff       	call   804496 <memp_free>
    break;
  805a94:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805a97:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805a9c:	eb 2a                	jmp    805ac8 <tcp_close+0x116>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805a9e:	83 ec 08             	sub    $0x8,%esp
  805aa1:	6a 01                	push   $0x1
  805aa3:	53                   	push   %ebx
  805aa4:	e8 ff 24 00 00       	call   807fa8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805aa9:	83 c4 10             	add    $0x10,%esp
  805aac:	84 c0                	test   %al,%al
  805aae:	75 18                	jne    805ac8 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805ab0:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805ab7:	83 ec 0c             	sub    $0xc,%esp
  805aba:	53                   	push   %ebx
  805abb:	e8 5e 25 00 00       	call   80801e <tcp_output>
  805ac0:	83 c4 10             	add    $0x10,%esp
  805ac3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805ac8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805acb:	5b                   	pop    %ebx
  805acc:	5e                   	pop    %esi
  805acd:	5f                   	pop    %edi
  805ace:	5d                   	pop    %ebp
  805acf:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ad0:	83 ec 08             	sub    $0x8,%esp
  805ad3:	6a 01                	push   $0x1
  805ad5:	53                   	push   %ebx
  805ad6:	e8 cd 24 00 00       	call   807fa8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805adb:	83 c4 10             	add    $0x10,%esp
  805ade:	84 c0                	test   %al,%al
  805ae0:	75 e6                	jne    805ac8 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805ae2:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805ae9:	eb cc                	jmp    805ab7 <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805aeb:	83 ec 08             	sub    $0x8,%esp
  805aee:	6a 01                	push   $0x1
  805af0:	53                   	push   %ebx
  805af1:	e8 b2 24 00 00       	call   807fa8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805af6:	83 c4 10             	add    $0x10,%esp
  805af9:	84 c0                	test   %al,%al
  805afb:	75 cb                	jne    805ac8 <tcp_close+0x116>
      pcb->state = LAST_ACK;
  805afd:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805b04:	eb b1                	jmp    805ab7 <tcp_close+0x105>
    err = ERR_OK;
  805b06:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805b0b:	eb bb                	jmp    805ac8 <tcp_close+0x116>

00805b0d <tcp_recv_null>:
{
  805b0d:	55                   	push   %ebp
  805b0e:	89 e5                	mov    %esp,%ebp
  805b10:	83 ec 08             	sub    $0x8,%esp
  805b13:	8b 45 10             	mov    0x10(%ebp),%eax
  805b16:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805b19:	85 c0                	test   %eax,%eax
  805b1b:	74 13                	je     805b30 <tcp_recv_null+0x23>
    pbuf_free(p);
  805b1d:	83 ec 0c             	sub    $0xc,%esp
  805b20:	50                   	push   %eax
  805b21:	e8 bd ec ff ff       	call   8047e3 <pbuf_free>
  805b26:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805b29:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b2e:	c9                   	leave  
  805b2f:	c3                   	ret    
  return ERR_OK;
  805b30:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805b35:	84 d2                	test   %dl,%dl
  805b37:	75 f5                	jne    805b2e <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805b39:	83 ec 0c             	sub    $0xc,%esp
  805b3c:	ff 75 0c             	pushl  0xc(%ebp)
  805b3f:	e8 6e fe ff ff       	call   8059b2 <tcp_close>
  805b44:	83 c4 10             	add    $0x10,%esp
  805b47:	eb e5                	jmp    805b2e <tcp_recv_null+0x21>

00805b49 <tcp_abort>:
{
  805b49:	55                   	push   %ebp
  805b4a:	89 e5                	mov    %esp,%ebp
  805b4c:	57                   	push   %edi
  805b4d:	56                   	push   %esi
  805b4e:	53                   	push   %ebx
  805b4f:	83 ec 2c             	sub    $0x2c,%esp
  805b52:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805b55:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805b59:	0f 84 c2 00 00 00    	je     805c21 <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805b5f:	8b 43 54             	mov    0x54(%ebx),%eax
  805b62:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805b65:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805b68:	8b 03                	mov    (%ebx),%eax
  805b6a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805b6d:	8b 43 04             	mov    0x4(%ebx),%eax
  805b70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805b73:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805b77:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805b7b:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805b7f:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805b83:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805b89:	8b 43 18             	mov    0x18(%ebx),%eax
  805b8c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b8f:	83 ec 08             	sub    $0x8,%esp
  805b92:	53                   	push   %ebx
  805b93:	68 3c b2 b3 00       	push   $0xb3b23c
  805b98:	e8 f6 fc ff ff       	call   805893 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805b9d:	8b 43 78             	mov    0x78(%ebx),%eax
  805ba0:	83 c4 10             	add    $0x10,%esp
  805ba3:	85 c0                	test   %eax,%eax
  805ba5:	74 0c                	je     805bb3 <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805ba7:	83 ec 0c             	sub    $0xc,%esp
  805baa:	50                   	push   %eax
  805bab:	e8 8a fb ff ff       	call   80573a <tcp_segs_free>
  805bb0:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805bb3:	8b 43 74             	mov    0x74(%ebx),%eax
  805bb6:	85 c0                	test   %eax,%eax
  805bb8:	74 0c                	je     805bc6 <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805bba:	83 ec 0c             	sub    $0xc,%esp
  805bbd:	50                   	push   %eax
  805bbe:	e8 77 fb ff ff       	call   80573a <tcp_segs_free>
  805bc3:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805bc6:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805bc9:	85 c0                	test   %eax,%eax
  805bcb:	74 0c                	je     805bd9 <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805bcd:	83 ec 0c             	sub    $0xc,%esp
  805bd0:	50                   	push   %eax
  805bd1:	e8 64 fb ff ff       	call   80573a <tcp_segs_free>
  805bd6:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805bd9:	83 ec 08             	sub    $0x8,%esp
  805bdc:	53                   	push   %ebx
  805bdd:	6a 02                	push   $0x2
  805bdf:	e8 b2 e8 ff ff       	call   804496 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805be4:	83 c4 10             	add    $0x10,%esp
  805be7:	85 f6                	test   %esi,%esi
  805be9:	74 0d                	je     805bf8 <tcp_abort+0xaf>
  805beb:	83 ec 08             	sub    $0x8,%esp
  805bee:	6a fb                	push   $0xfffffffb
  805bf0:	ff 75 cc             	pushl  -0x34(%ebp)
  805bf3:	ff d6                	call   *%esi
  805bf5:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805bf8:	83 ec 08             	sub    $0x8,%esp
  805bfb:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805bff:	50                   	push   %eax
  805c00:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805c04:	50                   	push   %eax
  805c05:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805c08:	50                   	push   %eax
  805c09:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805c0c:	50                   	push   %eax
  805c0d:	57                   	push   %edi
  805c0e:	ff 75 d4             	pushl  -0x2c(%ebp)
  805c11:	e8 a8 28 00 00       	call   8084be <tcp_rst>
  805c16:	83 c4 20             	add    $0x20,%esp
}
  805c19:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805c1c:	5b                   	pop    %ebx
  805c1d:	5e                   	pop    %esi
  805c1e:	5f                   	pop    %edi
  805c1f:	5d                   	pop    %ebp
  805c20:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805c21:	83 ec 08             	sub    $0x8,%esp
  805c24:	53                   	push   %ebx
  805c25:	68 50 b2 b3 00       	push   $0xb3b250
  805c2a:	e8 64 fc ff ff       	call   805893 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c2f:	83 c4 08             	add    $0x8,%esp
  805c32:	53                   	push   %ebx
  805c33:	6a 02                	push   $0x2
  805c35:	e8 5c e8 ff ff       	call   804496 <memp_free>
  805c3a:	83 c4 10             	add    $0x10,%esp
  805c3d:	eb da                	jmp    805c19 <tcp_abort+0xd0>

00805c3f <tcp_slowtmr>:
{
  805c3f:	55                   	push   %ebp
  805c40:	89 e5                	mov    %esp,%ebp
  805c42:	57                   	push   %edi
  805c43:	56                   	push   %esi
  805c44:	53                   	push   %ebx
  805c45:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805c48:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805c4f:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805c55:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805c59:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805c60:	e9 2a 02 00 00       	jmp    805e8f <tcp_slowtmr+0x250>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805c65:	83 ec 04             	sub    $0x4,%esp
  805c68:	68 5c 20 81 00       	push   $0x81205c
  805c6d:	68 36 02 00 00       	push   $0x236
  805c72:	68 ee 21 81 00       	push   $0x8121ee
  805c77:	e8 2c 89 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805c7c:	83 ec 04             	sub    $0x4,%esp
  805c7f:	68 88 20 81 00       	push   $0x812088
  805c84:	68 37 02 00 00       	push   $0x237
  805c89:	68 ee 21 81 00       	push   $0x8121ee
  805c8e:	e8 15 89 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805c93:	83 ec 04             	sub    $0x4,%esp
  805c96:	68 b4 20 81 00       	push   $0x8120b4
  805c9b:	68 38 02 00 00       	push   $0x238
  805ca0:	68 ee 21 81 00       	push   $0x8121ee
  805ca5:	e8 fe 88 00 00       	call   80e5a8 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805caa:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805cae:	80 fa 06             	cmp    $0x6,%dl
  805cb1:	0f 84 d0 00 00 00    	je     805d87 <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805cb7:	80 fa 0c             	cmp    $0xc,%dl
  805cba:	0f 85 0b 02 00 00    	jne    805ecb <tcp_slowtmr+0x28c>
  805cc0:	be 01 00 00 00       	mov    $0x1,%esi
  805cc5:	e9 c2 00 00 00       	jmp    805d8c <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805cca:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805cce:	66 85 c9             	test   %cx,%cx
  805cd1:	78 07                	js     805cda <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805cd3:	83 c1 01             	add    $0x1,%ecx
  805cd6:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805cda:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805cde:	0f 84 45 02 00 00    	je     805f29 <tcp_slowtmr+0x2ea>
  805ce4:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805ce8:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805cec:	0f 8c 37 02 00 00    	jl     805f29 <tcp_slowtmr+0x2ea>
          if (pcb->state != SYN_SENT) {
  805cf2:	83 f8 02             	cmp    $0x2,%eax
  805cf5:	74 1f                	je     805d16 <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805cf7:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805cfb:	66 c1 f8 03          	sar    $0x3,%ax
  805cff:	98                   	cwtl   
  805d00:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805d04:	01 c8                	add    %ecx,%eax
  805d06:	0f b6 d2             	movzbl %dl,%edx
  805d09:	0f b6 8a 74 22 81 00 	movzbl 0x812274(%edx),%ecx
  805d10:	d3 e0                	shl    %cl,%eax
  805d12:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805d16:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805d1c:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805d20:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805d24:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805d29:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805d2c:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805d30:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805d33:	66 39 d0             	cmp    %dx,%ax
  805d36:	0f 42 c1             	cmovb  %ecx,%eax
  805d39:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805d3d:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805d41:	83 ec 0c             	sub    $0xc,%esp
  805d44:	53                   	push   %ebx
  805d45:	e8 9d 28 00 00       	call   8085e7 <tcp_rexmit_rto>
  805d4a:	83 c4 10             	add    $0x10,%esp
  805d4d:	e9 d7 01 00 00       	jmp    805f29 <tcp_slowtmr+0x2ea>
    pcb_remove = 0;
  805d52:	be 00 00 00 00       	mov    $0x0,%esi
  805d57:	e9 cd 01 00 00       	jmp    805f29 <tcp_slowtmr+0x2ea>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805d5c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805d61:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805d64:	83 f8 29             	cmp    $0x29,%eax
  805d67:	89 f0                	mov    %esi,%eax
  805d69:	1c ff                	sbb    $0xff,%al
  805d6b:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805d6d:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d70:	85 c9                	test   %ecx,%ecx
  805d72:	75 1f                	jne    805d93 <tcp_slowtmr+0x154>
  805d74:	e9 d0 00 00 00       	jmp    805e49 <tcp_slowtmr+0x20a>
        tcp_abort(pcb);
  805d79:	83 ec 0c             	sub    $0xc,%esp
  805d7c:	53                   	push   %ebx
  805d7d:	e8 c7 fd ff ff       	call   805b49 <tcp_abort>
  805d82:	83 c4 10             	add    $0x10,%esp
  805d85:	eb 05                	jmp    805d8c <tcp_slowtmr+0x14d>
  805d87:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805d8c:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805d8f:	85 c9                	test   %ecx,%ecx
  805d91:	74 16                	je     805da9 <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805d93:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805d99:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805d9c:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805da0:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805da3:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805da5:	39 c2                	cmp    %eax,%edx
  805da7:	73 7b                	jae    805e24 <tcp_slowtmr+0x1e5>
    if (pcb->state == SYN_RCVD) {
  805da9:	8b 43 10             	mov    0x10(%ebx),%eax
  805dac:	83 f8 03             	cmp    $0x3,%eax
  805daf:	0f 84 87 00 00 00    	je     805e3c <tcp_slowtmr+0x1fd>
    if (pcb->state == LAST_ACK) {
  805db5:	83 f8 09             	cmp    $0x9,%eax
  805db8:	0f 85 8b 00 00 00    	jne    805e49 <tcp_slowtmr+0x20a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805dbe:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805dc3:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805dc6:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805dcb:	76 7c                	jbe    805e49 <tcp_slowtmr+0x20a>
      tcp_pcb_purge(pcb);      
  805dcd:	83 ec 0c             	sub    $0xc,%esp
  805dd0:	53                   	push   %ebx
  805dd1:	e8 40 fa ff ff       	call   805816 <tcp_pcb_purge>
      if (prev != NULL) {
  805dd6:	83 c4 10             	add    $0x10,%esp
  805dd9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805ddd:	0f 84 e1 01 00 00    	je     805fc4 <tcp_slowtmr+0x385>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805de3:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805de9:	0f 84 be 01 00 00    	je     805fad <tcp_slowtmr+0x36e>
        prev->next = pcb->next;
  805def:	8b 43 0c             	mov    0xc(%ebx),%eax
  805df2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805df5:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805df8:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805dfe:	85 c0                	test   %eax,%eax
  805e00:	74 0d                	je     805e0f <tcp_slowtmr+0x1d0>
  805e02:	83 ec 08             	sub    $0x8,%esp
  805e05:	6a fb                	push   $0xfffffffb
  805e07:	ff 73 18             	pushl  0x18(%ebx)
  805e0a:	ff d0                	call   *%eax
  805e0c:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  805e0f:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805e12:	83 ec 08             	sub    $0x8,%esp
  805e15:	53                   	push   %ebx
  805e16:	6a 02                	push   $0x2
  805e18:	e8 79 e6 ff ff       	call   804496 <memp_free>
  805e1d:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805e20:	89 f3                	mov    %esi,%ebx
  805e22:	eb 6b                	jmp    805e8f <tcp_slowtmr+0x250>
      tcp_segs_free(pcb->ooseq);
  805e24:	83 ec 0c             	sub    $0xc,%esp
  805e27:	51                   	push   %ecx
  805e28:	e8 0d f9 ff ff       	call   80573a <tcp_segs_free>
      pcb->ooseq = NULL;
  805e2d:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805e34:	83 c4 10             	add    $0x10,%esp
  805e37:	e9 6d ff ff ff       	jmp    805da9 <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e3c:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e41:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e44:	83 f8 28             	cmp    $0x28,%eax
  805e47:	77 84                	ja     805dcd <tcp_slowtmr+0x18e>
    if (pcb_remove) {
  805e49:	89 f0                	mov    %esi,%eax
  805e4b:	84 c0                	test   %al,%al
  805e4d:	0f 85 7a ff ff ff    	jne    805dcd <tcp_slowtmr+0x18e>
      ++pcb->polltmr;
  805e53:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805e57:	83 c0 01             	add    $0x1,%eax
  805e5a:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805e5d:	3a 43 31             	cmp    0x31(%ebx),%al
  805e60:	72 27                	jb     805e89 <tcp_slowtmr+0x24a>
        pcb->polltmr = 0;
  805e62:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805e66:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805e6c:	85 c0                	test   %eax,%eax
  805e6e:	74 0f                	je     805e7f <tcp_slowtmr+0x240>
  805e70:	83 ec 08             	sub    $0x8,%esp
  805e73:	53                   	push   %ebx
  805e74:	ff 73 18             	pushl  0x18(%ebx)
  805e77:	ff d0                	call   *%eax
  805e79:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805e7c:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805e7f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805e83:	0f 84 67 01 00 00    	je     805ff0 <tcp_slowtmr+0x3b1>
      prev = pcb;
  805e89:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  805e8c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805e8f:	85 db                	test   %ebx,%ebx
  805e91:	0f 84 6a 01 00 00    	je     806001 <tcp_slowtmr+0x3c2>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805e97:	8b 43 10             	mov    0x10(%ebx),%eax
  805e9a:	85 c0                	test   %eax,%eax
  805e9c:	0f 84 c3 fd ff ff    	je     805c65 <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805ea2:	83 f8 01             	cmp    $0x1,%eax
  805ea5:	0f 84 d1 fd ff ff    	je     805c7c <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805eab:	83 f8 0a             	cmp    $0xa,%eax
  805eae:	0f 84 df fd ff ff    	je     805c93 <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805eb4:	83 f8 02             	cmp    $0x2,%eax
  805eb7:	0f 84 ed fd ff ff    	je     805caa <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ebd:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805ec1:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ec6:	80 fa 0c             	cmp    $0xc,%dl
  805ec9:	74 5e                	je     805f29 <tcp_slowtmr+0x2ea>
      if (pcb->persist_backoff > 0) {
  805ecb:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805ed2:	89 f1                	mov    %esi,%ecx
  805ed4:	84 c9                	test   %cl,%cl
  805ed6:	0f 84 ee fd ff ff    	je     805cca <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  805edc:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805ee2:	83 c0 01             	add    $0x1,%eax
  805ee5:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805eeb:	0f b6 d1             	movzbl %cl,%edx
  805eee:	bf 6c 22 81 00       	mov    $0x81226c,%edi
  805ef3:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  805ef8:	39 d0                	cmp    %edx,%eax
  805efa:	0f 82 52 fe ff ff    	jb     805d52 <tcp_slowtmr+0x113>
          pcb->persist_cnt = 0;
  805f00:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805f07:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805f0a:	80 f9 06             	cmp    $0x6,%cl
  805f0d:	77 09                	ja     805f18 <tcp_slowtmr+0x2d9>
            pcb->persist_backoff++;
  805f0f:	8d 46 01             	lea    0x1(%esi),%eax
  805f12:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  805f18:	83 ec 0c             	sub    $0xc,%esp
  805f1b:	53                   	push   %ebx
  805f1c:	e8 92 28 00 00       	call   8087b3 <tcp_zero_window_probe>
  805f21:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  805f24:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805f29:	8b 43 10             	mov    0x10(%ebx),%eax
  805f2c:	83 f8 06             	cmp    $0x6,%eax
  805f2f:	0f 84 27 fe ff ff    	je     805d5c <tcp_slowtmr+0x11d>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805f35:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805f39:	0f 84 4d fe ff ff    	je     805d8c <tcp_slowtmr+0x14d>
  805f3f:	83 f8 04             	cmp    $0x4,%eax
  805f42:	74 09                	je     805f4d <tcp_slowtmr+0x30e>
  805f44:	83 f8 07             	cmp    $0x7,%eax
  805f47:	0f 85 3f fe ff ff    	jne    805d8c <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f4d:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  805f53:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805f56:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  805f5c:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  805f62:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f67:	f7 e2                	mul    %edx
  805f69:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f6c:	39 d1                	cmp    %edx,%ecx
  805f6e:	0f 87 05 fe ff ff    	ja     805d79 <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  805f74:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  805f7b:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  805f81:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  805f83:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  805f88:	f7 e2                	mul    %edx
  805f8a:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  805f8d:	39 d1                	cmp    %edx,%ecx
  805f8f:	0f 86 f7 fd ff ff    	jbe    805d8c <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  805f95:	83 ec 0c             	sub    $0xc,%esp
  805f98:	53                   	push   %ebx
  805f99:	e8 ef 26 00 00       	call   80868d <tcp_keepalive>
        pcb->keep_cnt_sent++;
  805f9e:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  805fa5:	83 c4 10             	add    $0x10,%esp
  805fa8:	e9 df fd ff ff       	jmp    805d8c <tcp_slowtmr+0x14d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805fad:	83 ec 04             	sub    $0x4,%esp
  805fb0:	68 e4 20 81 00       	push   $0x8120e4
  805fb5:	68 c1 02 00 00       	push   $0x2c1
  805fba:	68 ee 21 81 00       	push   $0x8121ee
  805fbf:	e8 e4 85 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fc4:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805fca:	75 0d                	jne    805fd9 <tcp_slowtmr+0x39a>
        tcp_active_pcbs = pcb->next;
  805fcc:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fcf:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  805fd4:	e9 1f fe ff ff       	jmp    805df8 <tcp_slowtmr+0x1b9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  805fd9:	83 ec 04             	sub    $0x4,%esp
  805fdc:	68 10 21 81 00       	push   $0x812110
  805fe1:	68 c5 02 00 00       	push   $0x2c5
  805fe6:	68 ee 21 81 00       	push   $0x8121ee
  805feb:	e8 b8 85 00 00       	call   80e5a8 <_panic>
          tcp_output(pcb);
  805ff0:	83 ec 0c             	sub    $0xc,%esp
  805ff3:	53                   	push   %ebx
  805ff4:	e8 25 20 00 00       	call   80801e <tcp_output>
  805ff9:	83 c4 10             	add    $0x10,%esp
  805ffc:	e9 88 fe ff ff       	jmp    805e89 <tcp_slowtmr+0x24a>
  pcb = tcp_tw_pcbs;
  806001:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  806007:	eb 48                	jmp    806051 <tcp_slowtmr+0x412>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806009:	83 ec 04             	sub    $0x4,%esp
  80600c:	68 3c 21 81 00       	push   $0x81213c
  806011:	68 e5 02 00 00       	push   $0x2e5
  806016:	68 ee 21 81 00       	push   $0x8121ee
  80601b:	e8 88 85 00 00       	call   80e5a8 <_panic>
      tcp_pcb_purge(pcb);      
  806020:	83 ec 0c             	sub    $0xc,%esp
  806023:	56                   	push   %esi
  806024:	e8 ed f7 ff ff       	call   805816 <tcp_pcb_purge>
      if (prev != NULL) {
  806029:	83 c4 10             	add    $0x10,%esp
  80602c:	85 db                	test   %ebx,%ebx
  80602e:	74 58                	je     806088 <tcp_slowtmr+0x449>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806030:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806036:	74 39                	je     806071 <tcp_slowtmr+0x432>
        prev->next = pcb->next;
  806038:	8b 46 0c             	mov    0xc(%esi),%eax
  80603b:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  80603e:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806041:	83 ec 08             	sub    $0x8,%esp
  806044:	56                   	push   %esi
  806045:	6a 02                	push   $0x2
  806047:	e8 4a e4 ff ff       	call   804496 <memp_free>
  80604c:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  80604f:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806051:	85 f6                	test   %esi,%esi
  806053:	74 5c                	je     8060b1 <tcp_slowtmr+0x472>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806055:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806059:	75 ae                	jne    806009 <tcp_slowtmr+0x3ca>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80605b:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806060:	2b 46 2c             	sub    0x2c(%esi),%eax
  806063:	3d f0 00 00 00       	cmp    $0xf0,%eax
  806068:	77 b6                	ja     806020 <tcp_slowtmr+0x3e1>
      prev = pcb;
  80606a:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80606c:	8b 76 0c             	mov    0xc(%esi),%esi
  80606f:	eb e0                	jmp    806051 <tcp_slowtmr+0x412>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806071:	83 ec 04             	sub    $0x4,%esp
  806074:	68 6c 21 81 00       	push   $0x81216c
  806079:	68 f4 02 00 00       	push   $0x2f4
  80607e:	68 ee 21 81 00       	push   $0x8121ee
  806083:	e8 20 85 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806088:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  80608e:	75 0a                	jne    80609a <tcp_slowtmr+0x45b>
        tcp_tw_pcbs = pcb->next;
  806090:	8b 46 0c             	mov    0xc(%esi),%eax
  806093:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  806098:	eb a4                	jmp    80603e <tcp_slowtmr+0x3ff>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80609a:	83 ec 04             	sub    $0x4,%esp
  80609d:	68 94 21 81 00       	push   $0x812194
  8060a2:	68 f8 02 00 00       	push   $0x2f8
  8060a7:	68 ee 21 81 00       	push   $0x8121ee
  8060ac:	e8 f7 84 00 00       	call   80e5a8 <_panic>
}
  8060b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8060b4:	5b                   	pop    %ebx
  8060b5:	5e                   	pop    %esi
  8060b6:	5f                   	pop    %edi
  8060b7:	5d                   	pop    %ebp
  8060b8:	c3                   	ret    

008060b9 <tcp_tmr>:
{
  8060b9:	55                   	push   %ebp
  8060ba:	89 e5                	mov    %esp,%ebp
  8060bc:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  8060bf:	e8 c2 f5 ff ff       	call   805686 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8060c4:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  8060cb:	83 c0 01             	add    $0x1,%eax
  8060ce:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  8060d3:	a8 01                	test   $0x1,%al
  8060d5:	75 02                	jne    8060d9 <tcp_tmr+0x20>
}
  8060d7:	c9                   	leave  
  8060d8:	c3                   	ret    
    tcp_slowtmr();
  8060d9:	e8 61 fb ff ff       	call   805c3f <tcp_slowtmr>
}
  8060de:	eb f7                	jmp    8060d7 <tcp_tmr+0x1e>

008060e0 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8060e0:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8060e5:	03 05 08 40 81 00    	add    0x814008,%eax
  8060eb:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  8060f0:	c3                   	ret    

008060f1 <tcp_alloc>:
{
  8060f1:	55                   	push   %ebp
  8060f2:	89 e5                	mov    %esp,%ebp
  8060f4:	57                   	push   %edi
  8060f5:	56                   	push   %esi
  8060f6:	53                   	push   %ebx
  8060f7:	83 ec 28             	sub    $0x28,%esp
  8060fa:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  8060fe:	6a 02                	push   $0x2
  806100:	e8 3b e3 ff ff       	call   804440 <memp_malloc>
  806105:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  806107:	83 c4 10             	add    $0x10,%esp
  80610a:	85 c0                	test   %eax,%eax
  80610c:	0f 84 a0 00 00 00    	je     8061b2 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806112:	83 ec 04             	sub    $0x4,%esp
  806115:	68 a8 00 00 00       	push   $0xa8
  80611a:	6a 00                	push   $0x0
  80611c:	53                   	push   %ebx
  80611d:	e8 21 8e 00 00       	call   80ef43 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806122:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  806126:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80612c:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806132:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  806138:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  80613e:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806142:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806146:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80614c:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806152:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  806158:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  80615e:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806164:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80616a:	e8 71 ff ff ff       	call   8060e0 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  80616f:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806172:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806175:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806178:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  80617b:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80617e:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806183:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  806186:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  80618a:	c7 83 88 00 00 00 0d 	movl   $0x805b0d,0x88(%ebx)
  806191:	5b 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  806194:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  80619b:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  80619e:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  8061a5:	83 c4 10             	add    $0x10,%esp
}
  8061a8:	89 d8                	mov    %ebx,%eax
  8061aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8061ad:	5b                   	pop    %ebx
  8061ae:	5e                   	pop    %esi
  8061af:	5f                   	pop    %edi
  8061b0:	5d                   	pop    %ebp
  8061b1:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061b2:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061b7:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  8061bd:	b9 00 00 00 00       	mov    $0x0,%ecx
  8061c2:	eb 03                	jmp    8061c7 <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8061c4:	8b 40 0c             	mov    0xc(%eax),%eax
  8061c7:	85 c0                	test   %eax,%eax
  8061c9:	74 0f                	je     8061da <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8061cb:	89 fa                	mov    %edi,%edx
  8061cd:	2b 50 2c             	sub    0x2c(%eax),%edx
  8061d0:	39 ca                	cmp    %ecx,%edx
  8061d2:	72 f0                	jb     8061c4 <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8061d4:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8061d6:	89 c3                	mov    %eax,%ebx
  8061d8:	eb ea                	jmp    8061c4 <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8061da:	85 db                	test   %ebx,%ebx
  8061dc:	74 0c                	je     8061ea <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8061de:	83 ec 0c             	sub    $0xc,%esp
  8061e1:	53                   	push   %ebx
  8061e2:	e8 62 f9 ff ff       	call   805b49 <tcp_abort>
  8061e7:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  8061ea:	83 ec 0c             	sub    $0xc,%esp
  8061ed:	6a 02                	push   $0x2
  8061ef:	e8 4c e2 ff ff       	call   804440 <memp_malloc>
  8061f4:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  8061f6:	83 c4 10             	add    $0x10,%esp
  8061f9:	85 c0                	test   %eax,%eax
  8061fb:	0f 85 11 ff ff ff    	jne    806112 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806201:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806206:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  80620c:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  80620f:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  806214:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80621b:	89 df                	mov    %ebx,%edi
  80621d:	89 f1                	mov    %esi,%ecx
  80621f:	88 4d e7             	mov    %cl,-0x19(%ebp)
  806222:	eb 03                	jmp    806227 <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806224:	8b 40 0c             	mov    0xc(%eax),%eax
  806227:	85 c0                	test   %eax,%eax
  806229:	74 29                	je     806254 <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  80622b:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  80622f:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  806233:	38 d3                	cmp    %dl,%bl
  806235:	89 d6                	mov    %edx,%esi
  806237:	0f 46 f3             	cmovbe %ebx,%esi
  80623a:	89 f3                	mov    %esi,%ebx
  80623c:	38 cb                	cmp    %cl,%bl
  80623e:	72 e4                	jb     806224 <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806240:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806243:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  806246:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  806249:	72 d9                	jb     806224 <tcp_alloc+0x133>
      mprio = pcb->prio;
  80624b:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  80624d:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806250:	89 c7                	mov    %eax,%edi
  806252:	eb d0                	jmp    806224 <tcp_alloc+0x133>
  if (inactive != NULL) {
  806254:	85 ff                	test   %edi,%edi
  806256:	74 0c                	je     806264 <tcp_alloc+0x173>
    tcp_abort(inactive);
  806258:	83 ec 0c             	sub    $0xc,%esp
  80625b:	57                   	push   %edi
  80625c:	e8 e8 f8 ff ff       	call   805b49 <tcp_abort>
  806261:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  806264:	83 ec 0c             	sub    $0xc,%esp
  806267:	6a 02                	push   $0x2
  806269:	e8 d2 e1 ff ff       	call   804440 <memp_malloc>
  80626e:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806270:	83 c4 10             	add    $0x10,%esp
  806273:	85 c0                	test   %eax,%eax
  806275:	0f 84 2d ff ff ff    	je     8061a8 <tcp_alloc+0xb7>
  80627b:	e9 92 fe ff ff       	jmp    806112 <tcp_alloc+0x21>

00806280 <tcp_new>:
{
  806280:	55                   	push   %ebp
  806281:	89 e5                	mov    %esp,%ebp
  806283:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806286:	6a 40                	push   $0x40
  806288:	e8 64 fe ff ff       	call   8060f1 <tcp_alloc>
}
  80628d:	c9                   	leave  
  80628e:	c3                   	ret    

0080628f <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80628f:	55                   	push   %ebp
  806290:	89 e5                	mov    %esp,%ebp
  806292:	56                   	push   %esi
  806293:	53                   	push   %ebx
  806294:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806297:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806299:	83 ec 0c             	sub    $0xc,%esp
  80629c:	ff 75 0c             	pushl  0xc(%ebp)
  80629f:	e8 f9 01 00 00       	call   80649d <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8062a4:	83 c4 10             	add    $0x10,%esp
  8062a7:	85 c0                	test   %eax,%eax
  8062a9:	74 14                	je     8062bf <tcp_eff_send_mss+0x30>
  8062ab:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8062af:	66 85 c0             	test   %ax,%ax
  8062b2:	74 0b                	je     8062bf <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8062b4:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8062b7:	66 39 c3             	cmp    %ax,%bx
  8062ba:	0f 46 c3             	cmovbe %ebx,%eax
  8062bd:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  8062bf:	89 f0                	mov    %esi,%eax
  8062c1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8062c4:	5b                   	pop    %ebx
  8062c5:	5e                   	pop    %esi
  8062c6:	5d                   	pop    %ebp
  8062c7:	c3                   	ret    

008062c8 <tcp_connect>:
{
  8062c8:	55                   	push   %ebp
  8062c9:	89 e5                	mov    %esp,%ebp
  8062cb:	57                   	push   %edi
  8062cc:	56                   	push   %esi
  8062cd:	53                   	push   %ebx
  8062ce:	83 ec 1c             	sub    $0x1c,%esp
  8062d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8062d4:	8b 75 0c             	mov    0xc(%ebp),%esi
  8062d7:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8062da:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8062de:	0f 85 bd 00 00 00    	jne    8063a1 <tcp_connect+0xd9>
  if (ipaddr != NULL) {
  8062e4:	85 f6                	test   %esi,%esi
  8062e6:	0f 84 67 01 00 00    	je     806453 <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  8062ec:	8b 16                	mov    (%esi),%edx
  8062ee:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  8062f1:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  8062f5:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  8062fa:	0f 84 b8 00 00 00    	je     8063b8 <tcp_connect+0xf0>
  iss = tcp_next_iss();
  806300:	e8 db fd ff ff       	call   8060e0 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806305:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80630c:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  80630f:	83 e8 01             	sub    $0x1,%eax
  806312:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806315:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  806318:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  80631e:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806324:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80632a:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806330:	83 ec 08             	sub    $0x8,%esp
  806333:	56                   	push   %esi
  806334:	68 18 02 00 00       	push   $0x218
  806339:	e8 51 ff ff ff       	call   80628f <tcp_eff_send_mss>
  80633e:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806342:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  806348:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80634b:	01 c0                	add    %eax,%eax
  80634d:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806351:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  806358:	8b 45 14             	mov    0x14(%ebp),%eax
  80635b:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806361:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  806367:	83 c4 10             	add    $0x10,%esp
  80636a:	39 da                	cmp    %ebx,%edx
  80636c:	74 58                	je     8063c6 <tcp_connect+0xfe>
  80636e:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  806374:	bf 00 00 00 00       	mov    $0x0,%edi
  806379:	89 de                	mov    %ebx,%esi
  80637b:	85 d2                	test   %edx,%edx
  80637d:	0f 84 ae 00 00 00    	je     806431 <tcp_connect+0x169>
  806383:	8b 42 0c             	mov    0xc(%edx),%eax
  806386:	39 f0                	cmp    %esi,%eax
  806388:	0f 94 c3             	sete   %bl
  80638b:	85 c0                	test   %eax,%eax
  80638d:	0f 95 c1             	setne  %cl
  806390:	84 cb                	test   %cl,%bl
  806392:	0f 85 83 00 00 00    	jne    80641b <tcp_connect+0x153>
  806398:	bf 01 00 00 00       	mov    $0x1,%edi
  80639d:	89 c2                	mov    %eax,%edx
  80639f:	eb da                	jmp    80637b <tcp_connect+0xb3>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8063a1:	83 ec 04             	sub    $0x4,%esp
  8063a4:	68 bc 21 81 00       	push   $0x8121bc
  8063a9:	68 ec 01 00 00       	push   $0x1ec
  8063ae:	68 ee 21 81 00       	push   $0x8121ee
  8063b3:	e8 f0 81 00 00       	call   80e5a8 <_panic>
    pcb->local_port = tcp_new_port();
  8063b8:	e8 6d ef ff ff       	call   80532a <tcp_new_port>
  8063bd:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8063c1:	e9 3a ff ff ff       	jmp    806300 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8063c6:	8b 43 0c             	mov    0xc(%ebx),%eax
  8063c9:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  8063ce:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  8063d3:	89 43 0c             	mov    %eax,0xc(%ebx)
  8063d6:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  8063dc:	e8 d8 bd ff ff       	call   8021b9 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  8063e1:	83 ec 0c             	sub    $0xc,%esp
  8063e4:	68 b4 05 04 02       	push   $0x20405b4
  8063e9:	e8 e9 12 00 00       	call   8076d7 <htonl>
  8063ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  8063f1:	83 c4 0c             	add    $0xc,%esp
  8063f4:	6a 04                	push   $0x4
  8063f6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8063f9:	50                   	push   %eax
  8063fa:	6a 00                	push   $0x0
  8063fc:	6a 02                	push   $0x2
  8063fe:	6a 00                	push   $0x0
  806400:	6a 00                	push   $0x0
  806402:	53                   	push   %ebx
  806403:	e8 f9 14 00 00       	call   807901 <tcp_enqueue>
  806408:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80640a:	83 c4 20             	add    $0x20,%esp
  80640d:	84 c0                	test   %al,%al
  80640f:	74 34                	je     806445 <tcp_connect+0x17d>
} 
  806411:	89 f0                	mov    %esi,%eax
  806413:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806416:	5b                   	pop    %ebx
  806417:	5e                   	pop    %esi
  806418:	5f                   	pop    %edi
  806419:	5d                   	pop    %ebp
  80641a:	c3                   	ret    
  80641b:	89 f3                	mov    %esi,%ebx
  80641d:	89 f8                	mov    %edi,%eax
  80641f:	84 c0                	test   %al,%al
  806421:	74 06                	je     806429 <tcp_connect+0x161>
  806423:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806429:	8b 43 0c             	mov    0xc(%ebx),%eax
  80642c:	89 42 0c             	mov    %eax,0xc(%edx)
  80642f:	eb 9d                	jmp    8063ce <tcp_connect+0x106>
  806431:	89 f3                	mov    %esi,%ebx
  806433:	89 f8                	mov    %edi,%eax
  806435:	84 c0                	test   %al,%al
  806437:	74 95                	je     8063ce <tcp_connect+0x106>
  806439:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  806440:	00 00 00 
  806443:	eb 89                	jmp    8063ce <tcp_connect+0x106>
    tcp_output(pcb);
  806445:	83 ec 0c             	sub    $0xc,%esp
  806448:	53                   	push   %ebx
  806449:	e8 d0 1b 00 00       	call   80801e <tcp_output>
  80644e:	83 c4 10             	add    $0x10,%esp
  806451:	eb be                	jmp    806411 <tcp_connect+0x149>
    return ERR_VAL;
  806453:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  806458:	eb b7                	jmp    806411 <tcp_connect+0x149>

0080645a <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80645a:	55                   	push   %ebp
  80645b:	89 e5                	mov    %esp,%ebp
  80645d:	53                   	push   %ebx
  80645e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806461:	8b 45 08             	mov    0x8(%ebp),%eax
  806464:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806466:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806469:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80646e:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806471:	77 27                	ja     80649a <ip_addr_isbroadcast+0x40>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806473:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806477:	83 e0 02             	and    $0x2,%eax
  80647a:	74 1e                	je     80649a <ip_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80647c:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  80647f:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  806484:	39 d3                	cmp    %edx,%ebx
  806486:	74 12                	je     80649a <ip_addr_isbroadcast+0x40>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806488:	8b 49 08             	mov    0x8(%ecx),%ecx
  80648b:	31 d3                	xor    %edx,%ebx
  80648d:	85 cb                	test   %ecx,%ebx
  80648f:	75 09                	jne    80649a <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806491:	f7 d1                	not    %ecx
  806493:	21 ca                	and    %ecx,%edx
  806495:	39 ca                	cmp    %ecx,%edx
  806497:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80649a:	5b                   	pop    %ebx
  80649b:	5d                   	pop    %ebp
  80649c:	c3                   	ret    

0080649d <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80649d:	55                   	push   %ebp
  80649e:	89 e5                	mov    %esp,%ebp
  8064a0:	56                   	push   %esi
  8064a1:	53                   	push   %ebx
  8064a2:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8064a5:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  8064ab:	eb 02                	jmp    8064af <ip_route+0x12>
  8064ad:	8b 1b                	mov    (%ebx),%ebx
  8064af:	85 db                	test   %ebx,%ebx
  8064b1:	74 1c                	je     8064cf <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8064b3:	83 ec 0c             	sub    $0xc,%esp
  8064b6:	53                   	push   %ebx
  8064b7:	e8 4b e2 ff ff       	call   804707 <netif_is_up>
  8064bc:	83 c4 10             	add    $0x10,%esp
  8064bf:	84 c0                	test   %al,%al
  8064c1:	74 ea                	je     8064ad <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8064c3:	8b 06                	mov    (%esi),%eax
  8064c5:	33 43 04             	xor    0x4(%ebx),%eax
  8064c8:	85 43 08             	test   %eax,0x8(%ebx)
  8064cb:	75 e0                	jne    8064ad <ip_route+0x10>
  8064cd:	eb 1e                	jmp    8064ed <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8064cf:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  8064d4:	85 c0                	test   %eax,%eax
  8064d6:	74 1e                	je     8064f6 <ip_route+0x59>
  8064d8:	83 ec 0c             	sub    $0xc,%esp
  8064db:	50                   	push   %eax
  8064dc:	e8 26 e2 ff ff       	call   804707 <netif_is_up>
  8064e1:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8064e4:	84 c0                	test   %al,%al
  8064e6:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  8064ed:	89 d8                	mov    %ebx,%eax
  8064ef:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064f2:	5b                   	pop    %ebx
  8064f3:	5e                   	pop    %esi
  8064f4:	5d                   	pop    %ebp
  8064f5:	c3                   	ret    
    return NULL;
  8064f6:	89 c3                	mov    %eax,%ebx
  8064f8:	eb f3                	jmp    8064ed <ip_route+0x50>

008064fa <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8064fa:	55                   	push   %ebp
  8064fb:	89 e5                	mov    %esp,%ebp
  8064fd:	57                   	push   %edi
  8064fe:	56                   	push   %esi
  8064ff:	53                   	push   %ebx
  806500:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806503:	8b 45 08             	mov    0x8(%ebp),%eax
  806506:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  806509:	0f b7 07             	movzwl (%edi),%eax
  80650c:	50                   	push   %eax
  80650d:	e8 b8 11 00 00       	call   8076ca <ntohs>
  806512:	66 c1 e8 0c          	shr    $0xc,%ax
  806516:	83 c4 10             	add    $0x10,%esp
  806519:	66 83 f8 04          	cmp    $0x4,%ax
  80651d:	74 1b                	je     80653a <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80651f:	83 ec 0c             	sub    $0xc,%esp
  806522:	ff 75 08             	pushl  0x8(%ebp)
  806525:	e8 b9 e2 ff ff       	call   8047e3 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80652a:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80652d:	b8 00 00 00 00       	mov    $0x0,%eax
  806532:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806535:	5b                   	pop    %ebx
  806536:	5e                   	pop    %esi
  806537:	5f                   	pop    %edi
  806538:	5d                   	pop    %ebp
  806539:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  80653a:	83 ec 0c             	sub    $0xc,%esp
  80653d:	0f b7 07             	movzwl (%edi),%eax
  806540:	50                   	push   %eax
  806541:	e8 84 11 00 00       	call   8076ca <ntohs>
  806546:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  80654a:	83 e0 3c             	and    $0x3c,%eax
  80654d:	89 c6                	mov    %eax,%esi
  80654f:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806553:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  806557:	89 04 24             	mov    %eax,(%esp)
  80655a:	e8 6b 11 00 00       	call   8076ca <ntohs>
  80655f:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806561:	83 c4 10             	add    $0x10,%esp
  806564:	8b 45 08             	mov    0x8(%ebp),%eax
  806567:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80656b:	72 06                	jb     806573 <ip_input+0x79>
  80656d:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806571:	73 10                	jae    806583 <ip_input+0x89>
    pbuf_free(p);
  806573:	83 ec 0c             	sub    $0xc,%esp
  806576:	ff 75 08             	pushl  0x8(%ebp)
  806579:	e8 65 e2 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  80657e:	83 c4 10             	add    $0x10,%esp
  806581:	eb aa                	jmp    80652d <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806583:	83 ec 08             	sub    $0x8,%esp
  806586:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80658a:	50                   	push   %eax
  80658b:	57                   	push   %edi
  80658c:	e8 fe 0f 00 00       	call   80758f <inet_chksum>
  806591:	83 c4 10             	add    $0x10,%esp
  806594:	66 85 c0             	test   %ax,%ax
  806597:	75 27                	jne    8065c0 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  806599:	83 ec 08             	sub    $0x8,%esp
  80659c:	0f b7 db             	movzwl %bx,%ebx
  80659f:	53                   	push   %ebx
  8065a0:	ff 75 08             	pushl  0x8(%ebp)
  8065a3:	e8 73 e5 ff ff       	call   804b1b <pbuf_realloc>
  8065a8:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  8065ab:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  8065ae:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8065b3:	8d 47 10             	lea    0x10(%edi),%eax
  8065b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8065b9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8065bc:	89 df                	mov    %ebx,%edi
  8065be:	eb 2e                	jmp    8065ee <ip_input+0xf4>
    pbuf_free(p);
  8065c0:	83 ec 0c             	sub    $0xc,%esp
  8065c3:	ff 75 08             	pushl  0x8(%ebp)
  8065c6:	e8 18 e2 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  8065cb:	83 c4 10             	add    $0x10,%esp
  8065ce:	e9 5a ff ff ff       	jmp    80652d <ip_input+0x33>
      if (first) {
  8065d3:	85 f6                	test   %esi,%esi
  8065d5:	74 56                	je     80662d <ip_input+0x133>
        netif = netif_list;
  8065d7:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  8065dd:	39 df                	cmp    %ebx,%edi
  8065df:	74 50                	je     806631 <ip_input+0x137>
  8065e1:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  8065e6:	85 db                	test   %ebx,%ebx
  8065e8:	0f 84 20 01 00 00    	je     80670e <ip_input+0x214>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8065ee:	83 ec 0c             	sub    $0xc,%esp
  8065f1:	53                   	push   %ebx
  8065f2:	e8 10 e1 ff ff       	call   804707 <netif_is_up>
  8065f7:	83 c4 10             	add    $0x10,%esp
  8065fa:	84 c0                	test   %al,%al
  8065fc:	74 d5                	je     8065d3 <ip_input+0xd9>
  8065fe:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806601:	74 d0                	je     8065d3 <ip_input+0xd9>
  806603:	8b 43 04             	mov    0x4(%ebx),%eax
  806606:	85 c0                	test   %eax,%eax
  806608:	74 c9                	je     8065d3 <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80660a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80660d:	3b 42 10             	cmp    0x10(%edx),%eax
  806610:	74 4a                	je     80665c <ip_input+0x162>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806612:	83 ec 08             	sub    $0x8,%esp
  806615:	53                   	push   %ebx
  806616:	ff 75 dc             	pushl  -0x24(%ebp)
  806619:	e8 3c fe ff ff       	call   80645a <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80661e:	83 c4 10             	add    $0x10,%esp
  806621:	84 c0                	test   %al,%al
  806623:	74 ae                	je     8065d3 <ip_input+0xd9>
  806625:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806628:	e9 fc 00 00 00       	jmp    806729 <ip_input+0x22f>
        netif = netif->next;
  80662d:	8b 1b                	mov    (%ebx),%ebx
  80662f:	eb ac                	jmp    8065dd <ip_input+0xe3>
        netif = netif->next;
  806631:	8b 1b                	mov    (%ebx),%ebx
  806633:	eb ac                	jmp    8065e1 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806635:	83 ec 0c             	sub    $0xc,%esp
  806638:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80663c:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  806641:	50                   	push   %eax
  806642:	e8 83 10 00 00       	call   8076ca <ntohs>
  806647:	83 c4 10             	add    $0x10,%esp
  80664a:	66 83 f8 44          	cmp    $0x44,%ax
  80664e:	0f 85 d5 00 00 00    	jne    806729 <ip_input+0x22f>
        netif = inp;
  806654:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806657:	e9 10 01 00 00       	jmp    80676c <ip_input+0x272>
  80665c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80665f:	e9 c5 00 00 00       	jmp    806729 <ip_input+0x22f>
      pbuf_free(p);
  806664:	83 ec 0c             	sub    $0xc,%esp
  806667:	ff 75 08             	pushl  0x8(%ebp)
  80666a:	e8 74 e1 ff ff       	call   8047e3 <pbuf_free>
      return ERR_OK;
  80666f:	83 c4 10             	add    $0x10,%esp
  806672:	e9 b6 fe ff ff       	jmp    80652d <ip_input+0x33>
    pbuf_free(p);
  806677:	83 ec 0c             	sub    $0xc,%esp
  80667a:	ff 75 08             	pushl  0x8(%ebp)
  80667d:	e8 61 e1 ff ff       	call   8047e3 <pbuf_free>
    return ERR_OK;
  806682:	83 c4 10             	add    $0x10,%esp
  806685:	e9 a3 fe ff ff       	jmp    80652d <ip_input+0x33>
      udp_input(p, inp);
  80668a:	83 ec 08             	sub    $0x8,%esp
  80668d:	ff 75 0c             	pushl  0xc(%ebp)
  806690:	ff 75 08             	pushl  0x8(%ebp)
  806693:	e8 6b 22 00 00       	call   808903 <udp_input>
      break;
  806698:	83 c4 10             	add    $0x10,%esp
  80669b:	e9 8d fe ff ff       	jmp    80652d <ip_input+0x33>
      tcp_input(p, inp);
  8066a0:	83 ec 08             	sub    $0x8,%esp
  8066a3:	ff 75 0c             	pushl  0xc(%ebp)
  8066a6:	ff 75 08             	pushl  0x8(%ebp)
  8066a9:	e8 5e 69 00 00       	call   80d00c <tcp_input>
      break;
  8066ae:	83 c4 10             	add    $0x10,%esp
  8066b1:	e9 77 fe ff ff       	jmp    80652d <ip_input+0x33>
      icmp_input(p, inp);
  8066b6:	83 ec 08             	sub    $0x8,%esp
  8066b9:	ff 75 0c             	pushl  0xc(%ebp)
  8066bc:	ff 75 08             	pushl  0x8(%ebp)
  8066bf:	e8 48 79 00 00       	call   80e00c <icmp_input>
      break;
  8066c4:	83 c4 10             	add    $0x10,%esp
  8066c7:	e9 61 fe ff ff       	jmp    80652d <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8066cc:	8b 5f 10             	mov    0x10(%edi),%ebx
  8066cf:	83 ec 0c             	sub    $0xc,%esp
  8066d2:	68 00 00 00 f0       	push   $0xf0000000
  8066d7:	e8 12 12 00 00       	call   8078ee <ntohl>
  8066dc:	21 c3                	and    %eax,%ebx
  8066de:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8066e5:	e8 04 12 00 00       	call   8078ee <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8066ea:	83 c4 10             	add    $0x10,%esp
  8066ed:	39 c3                	cmp    %eax,%ebx
  8066ef:	0f 84 18 01 00 00    	je     80680d <ip_input+0x313>
        p->payload = iphdr;
  8066f5:	8b 45 08             	mov    0x8(%ebp),%eax
  8066f8:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8066fb:	83 ec 08             	sub    $0x8,%esp
  8066fe:	6a 02                	push   $0x2
  806700:	50                   	push   %eax
  806701:	e8 20 7c 00 00       	call   80e326 <icmp_dest_unreach>
  806706:	83 c4 10             	add    $0x10,%esp
  806709:	e9 ff 00 00 00       	jmp    80680d <ip_input+0x313>
  80670e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806711:	83 ec 0c             	sub    $0xc,%esp
  806714:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806718:	50                   	push   %eax
  806719:	e8 ac 0f 00 00       	call   8076ca <ntohs>
  80671e:	83 c4 10             	add    $0x10,%esp
  806721:	3c 11                	cmp    $0x11,%al
  806723:	0f 84 0c ff ff ff    	je     806635 <ip_input+0x13b>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806729:	83 ec 08             	sub    $0x8,%esp
  80672c:	ff 75 0c             	pushl  0xc(%ebp)
  80672f:	8d 47 0c             	lea    0xc(%edi),%eax
  806732:	50                   	push   %eax
  806733:	e8 22 fd ff ff       	call   80645a <ip_addr_isbroadcast>
  806738:	83 c4 10             	add    $0x10,%esp
  80673b:	84 c0                	test   %al,%al
  80673d:	0f 85 21 ff ff ff    	jne    806664 <ip_input+0x16a>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806743:	8b 77 0c             	mov    0xc(%edi),%esi
  806746:	83 ec 0c             	sub    $0xc,%esp
  806749:	68 00 00 00 f0       	push   $0xf0000000
  80674e:	e8 9b 11 00 00       	call   8078ee <ntohl>
  806753:	21 c6                	and    %eax,%esi
  806755:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80675c:	e8 8d 11 00 00       	call   8078ee <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806761:	83 c4 10             	add    $0x10,%esp
  806764:	39 c6                	cmp    %eax,%esi
  806766:	0f 84 f8 fe ff ff    	je     806664 <ip_input+0x16a>
  if (netif == NULL) {
  80676c:	85 db                	test   %ebx,%ebx
  80676e:	0f 84 03 ff ff ff    	je     806677 <ip_input+0x17d>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806774:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806778:	83 ec 0c             	sub    $0xc,%esp
  80677b:	68 ff 3f 00 00       	push   $0x3fff
  806780:	e8 38 0f 00 00       	call   8076bd <htons>
  806785:	83 c4 10             	add    $0x10,%esp
  806788:	66 85 c3             	test   %ax,%bx
  80678b:	74 1c                	je     8067a9 <ip_input+0x2af>
    p = ip_reass(p);
  80678d:	83 ec 0c             	sub    $0xc,%esp
  806790:	ff 75 08             	pushl  0x8(%ebp)
  806793:	e8 95 04 00 00       	call   806c2d <ip_reass>
  806798:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  80679b:	83 c4 10             	add    $0x10,%esp
  80679e:	85 c0                	test   %eax,%eax
  8067a0:	0f 84 87 fd ff ff    	je     80652d <ip_input+0x33>
    iphdr = p->payload;
  8067a6:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  8067a9:	83 ec 08             	sub    $0x8,%esp
  8067ac:	ff 75 0c             	pushl  0xc(%ebp)
  8067af:	ff 75 08             	pushl  0x8(%ebp)
  8067b2:	e8 ac 75 00 00       	call   80dd63 <raw_input>
  8067b7:	83 c4 10             	add    $0x10,%esp
  8067ba:	84 c0                	test   %al,%al
  8067bc:	0f 85 6b fd ff ff    	jne    80652d <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  8067c2:	83 ec 0c             	sub    $0xc,%esp
  8067c5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8067c9:	50                   	push   %eax
  8067ca:	e8 fb 0e 00 00       	call   8076ca <ntohs>
  8067cf:	0f b6 c0             	movzbl %al,%eax
  8067d2:	83 c4 10             	add    $0x10,%esp
  8067d5:	66 83 f8 06          	cmp    $0x6,%ax
  8067d9:	0f 84 c1 fe ff ff    	je     8066a0 <ip_input+0x1a6>
  8067df:	66 83 f8 11          	cmp    $0x11,%ax
  8067e3:	0f 84 a1 fe ff ff    	je     80668a <ip_input+0x190>
  8067e9:	66 83 f8 01          	cmp    $0x1,%ax
  8067ed:	0f 84 c3 fe ff ff    	je     8066b6 <ip_input+0x1bc>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8067f3:	83 ec 08             	sub    $0x8,%esp
  8067f6:	ff 75 0c             	pushl  0xc(%ebp)
  8067f9:	8d 47 10             	lea    0x10(%edi),%eax
  8067fc:	50                   	push   %eax
  8067fd:	e8 58 fc ff ff       	call   80645a <ip_addr_isbroadcast>
  806802:	83 c4 10             	add    $0x10,%esp
  806805:	84 c0                	test   %al,%al
  806807:	0f 84 bf fe ff ff    	je     8066cc <ip_input+0x1d2>
      pbuf_free(p);
  80680d:	83 ec 0c             	sub    $0xc,%esp
  806810:	ff 75 08             	pushl  0x8(%ebp)
  806813:	e8 cb df ff ff       	call   8047e3 <pbuf_free>
  806818:	83 c4 10             	add    $0x10,%esp
  80681b:	e9 0d fd ff ff       	jmp    80652d <ip_input+0x33>

00806820 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806820:	55                   	push   %ebp
  806821:	89 e5                	mov    %esp,%ebp
  806823:	57                   	push   %edi
  806824:	56                   	push   %esi
  806825:	53                   	push   %ebx
  806826:	83 ec 1c             	sub    $0x1c,%esp
  806829:	8b 75 08             	mov    0x8(%ebp),%esi
  80682c:	8b 7d 14             	mov    0x14(%ebp),%edi
  80682f:	8b 45 18             	mov    0x18(%ebp),%eax
  806832:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806835:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806838:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80683b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80683f:	0f 84 42 01 00 00    	je     806987 <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806845:	83 ec 08             	sub    $0x8,%esp
  806848:	6a 14                	push   $0x14
  80684a:	56                   	push   %esi
  80684b:	e8 c6 de ff ff       	call   804716 <pbuf_header>
  806850:	83 c4 10             	add    $0x10,%esp
  806853:	84 c0                	test   %al,%al
  806855:	0f 85 4b 01 00 00    	jne    8069a6 <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80685b:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80685e:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806863:	0f 86 02 01 00 00    	jbe    80696b <ip_output_if+0x14b>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806869:	83 ec 0c             	sub    $0xc,%esp
  80686c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806870:	50                   	push   %eax
  806871:	e8 54 0e 00 00       	call   8076ca <ntohs>
  806876:	0f b6 c0             	movzbl %al,%eax
  806879:	c1 e7 08             	shl    $0x8,%edi
  80687c:	09 c7                	or     %eax,%edi
  80687e:	0f b7 ff             	movzwl %di,%edi
  806881:	89 3c 24             	mov    %edi,(%esp)
  806884:	e8 34 0e 00 00       	call   8076bd <htons>
  806889:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  80688d:	0f b7 c0             	movzwl %ax,%eax
  806890:	89 04 24             	mov    %eax,(%esp)
  806893:	e8 32 0e 00 00       	call   8076ca <ntohs>
  806898:	89 c2                	mov    %eax,%edx
  80689a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8068a0:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  8068a4:	09 d0                	or     %edx,%eax
  8068a6:	0f b7 c0             	movzwl %ax,%eax
  8068a9:	89 04 24             	mov    %eax,(%esp)
  8068ac:	e8 0c 0e 00 00       	call   8076bd <htons>
  8068b1:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  8068b5:	8b 45 10             	mov    0x10(%ebp),%eax
  8068b8:	8b 00                	mov    (%eax),%eax
  8068ba:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  8068bd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8068c1:	80 cc 45             	or     $0x45,%ah
  8068c4:	89 04 24             	mov    %eax,(%esp)
  8068c7:	e8 f1 0d 00 00       	call   8076bd <htons>
  8068cc:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8068cf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8068d3:	89 04 24             	mov    %eax,(%esp)
  8068d6:	e8 e2 0d 00 00       	call   8076bd <htons>
  8068db:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  8068df:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8068e5:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  8068ec:	89 04 24             	mov    %eax,(%esp)
  8068ef:	e8 c9 0d 00 00       	call   8076bd <htons>
  8068f4:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  8068f8:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  8068ff:	01 

    if (ip_addr_isany(src)) {
  806900:	83 c4 10             	add    $0x10,%esp
  806903:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806907:	74 09                	je     806912 <ip_output_if+0xf2>
  806909:	8b 45 0c             	mov    0xc(%ebp),%eax
  80690c:	8b 00                	mov    (%eax),%eax
  80690e:	85 c0                	test   %eax,%eax
  806910:	75 70                	jne    806982 <ip_output_if+0x162>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806912:	b8 00 00 00 00       	mov    $0x0,%eax
  806917:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  80691b:	74 06                	je     806923 <ip_output_if+0x103>
  80691d:	8b 45 20             	mov    0x20(%ebp),%eax
  806920:	8b 40 04             	mov    0x4(%eax),%eax
  806923:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806926:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80692c:	83 ec 08             	sub    $0x8,%esp
  80692f:	6a 14                	push   $0x14
  806931:	53                   	push   %ebx
  806932:	e8 58 0c 00 00       	call   80758f <inet_chksum>
  806937:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  80693b:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  80693e:	8b 45 20             	mov    0x20(%ebp),%eax
  806941:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806945:	66 85 c0             	test   %ax,%ax
  806948:	74 06                	je     806950 <ip_output_if+0x130>
  80694a:	66 3b 46 08          	cmp    0x8(%esi),%ax
  80694e:	72 42                	jb     806992 <ip_output_if+0x172>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806950:	83 ec 04             	sub    $0x4,%esp
  806953:	ff 75 10             	pushl  0x10(%ebp)
  806956:	56                   	push   %esi
  806957:	ff 75 20             	pushl  0x20(%ebp)
  80695a:	8b 45 20             	mov    0x20(%ebp),%eax
  80695d:	ff 50 14             	call   *0x14(%eax)
  806960:	83 c4 10             	add    $0x10,%esp
  }
}
  806963:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806966:	5b                   	pop    %ebx
  806967:	5e                   	pop    %esi
  806968:	5f                   	pop    %edi
  806969:	5d                   	pop    %ebp
  80696a:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80696b:	83 ec 04             	sub    $0x4,%esp
  80696e:	68 8c 22 81 00       	push   $0x81228c
  806973:	68 ee 01 00 00       	push   $0x1ee
  806978:	68 b9 22 81 00       	push   $0x8122b9
  80697d:	e8 26 7c 00 00       	call   80e5a8 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806982:	89 43 0c             	mov    %eax,0xc(%ebx)
  806985:	eb 9f                	jmp    806926 <ip_output_if+0x106>
    dest = &(iphdr->dest);
  806987:	8b 46 04             	mov    0x4(%esi),%eax
  80698a:	83 c0 10             	add    $0x10,%eax
  80698d:	89 45 10             	mov    %eax,0x10(%ebp)
  806990:	eb ac                	jmp    80693e <ip_output_if+0x11e>
    return ip_frag(p,netif,dest);
  806992:	83 ec 04             	sub    $0x4,%esp
  806995:	ff 75 10             	pushl  0x10(%ebp)
  806998:	ff 75 20             	pushl  0x20(%ebp)
  80699b:	56                   	push   %esi
  80699c:	e8 5e 07 00 00       	call   8070ff <ip_frag>
  8069a1:	83 c4 10             	add    $0x10,%esp
  8069a4:	eb bd                	jmp    806963 <ip_output_if+0x143>
      return ERR_BUF;
  8069a6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8069ab:	eb b6                	jmp    806963 <ip_output_if+0x143>

008069ad <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8069ad:	55                   	push   %ebp
  8069ae:	89 e5                	mov    %esp,%ebp
  8069b0:	57                   	push   %edi
  8069b1:	56                   	push   %esi
  8069b2:	53                   	push   %ebx
  8069b3:	83 ec 18             	sub    $0x18,%esp
  8069b6:	8b 5d 14             	mov    0x14(%ebp),%ebx
  8069b9:	8b 75 18             	mov    0x18(%ebp),%esi
  8069bc:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8069bf:	ff 75 10             	pushl  0x10(%ebp)
  8069c2:	e8 d6 fa ff ff       	call   80649d <ip_route>
  8069c7:	83 c4 10             	add    $0x10,%esp
  8069ca:	85 c0                	test   %eax,%eax
  8069cc:	74 2d                	je     8069fb <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8069ce:	83 ec 04             	sub    $0x4,%esp
  8069d1:	50                   	push   %eax
  8069d2:	89 f8                	mov    %edi,%eax
  8069d4:	0f b6 f8             	movzbl %al,%edi
  8069d7:	57                   	push   %edi
  8069d8:	89 f0                	mov    %esi,%eax
  8069da:	0f b6 f0             	movzbl %al,%esi
  8069dd:	56                   	push   %esi
  8069de:	0f b6 db             	movzbl %bl,%ebx
  8069e1:	53                   	push   %ebx
  8069e2:	ff 75 10             	pushl  0x10(%ebp)
  8069e5:	ff 75 0c             	pushl  0xc(%ebp)
  8069e8:	ff 75 08             	pushl  0x8(%ebp)
  8069eb:	e8 30 fe ff ff       	call   806820 <ip_output_if>
  8069f0:	83 c4 20             	add    $0x20,%esp
}
  8069f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8069f6:	5b                   	pop    %ebx
  8069f7:	5e                   	pop    %esi
  8069f8:	5f                   	pop    %edi
  8069f9:	5d                   	pop    %ebp
  8069fa:	c3                   	ret    
    return ERR_RTE;
  8069fb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806a00:	eb f1                	jmp    8069f3 <ip_output+0x46>

00806a02 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806a02:	55                   	push   %ebp
  806a03:	89 e5                	mov    %esp,%ebp
  806a05:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806a08:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806a0e:	74 18                	je     806a28 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a10:	85 d2                	test   %edx,%edx
  806a12:	74 1e                	je     806a32 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806a14:	8b 08                	mov    (%eax),%ecx
  806a16:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806a18:	83 ec 08             	sub    $0x8,%esp
  806a1b:	50                   	push   %eax
  806a1c:	6a 05                	push   $0x5
  806a1e:	e8 73 da ff ff       	call   804496 <memp_free>
}
  806a23:	83 c4 10             	add    $0x10,%esp
  806a26:	c9                   	leave  
  806a27:	c3                   	ret    
    reassdatagrams = ipr->next;
  806a28:	8b 10                	mov    (%eax),%edx
  806a2a:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806a30:	eb e6                	jmp    806a18 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806a32:	83 ec 04             	sub    $0x4,%esp
  806a35:	68 d1 22 81 00       	push   $0x8122d1
  806a3a:	68 29 01 00 00       	push   $0x129
  806a3f:	68 ea 22 81 00       	push   $0x8122ea
  806a44:	e8 5f 7b 00 00       	call   80e5a8 <_panic>

00806a49 <ip_reass_free_complete_datagram>:
{
  806a49:	55                   	push   %ebp
  806a4a:	89 e5                	mov    %esp,%ebp
  806a4c:	57                   	push   %edi
  806a4d:	56                   	push   %esi
  806a4e:	53                   	push   %ebx
  806a4f:	83 ec 1c             	sub    $0x1c,%esp
  806a52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806a55:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806a58:	39 c2                	cmp    %eax,%edx
  806a5a:	74 53                	je     806aaf <ip_reass_free_complete_datagram+0x66>
  if (prev != NULL) {
  806a5c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a5f:	85 c0                	test   %eax,%eax
  806a61:	74 07                	je     806a6a <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806a63:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a66:	39 10                	cmp    %edx,(%eax)
  806a68:	75 5c                	jne    806ac6 <ip_reass_free_complete_datagram+0x7d>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806a6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a6d:	8b 58 04             	mov    0x4(%eax),%ebx
  806a70:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806a73:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806a78:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806a7d:	74 5e                	je     806add <ip_reass_free_complete_datagram+0x94>
  p = ipr->p;
  806a7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806a82:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806a85:	85 db                	test   %ebx,%ebx
  806a87:	0f 84 8f 00 00 00    	je     806b1c <ip_reass_free_complete_datagram+0xd3>
    iprh = (struct ip_reass_helper *)p->payload;
  806a8d:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806a90:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806a92:	83 ec 0c             	sub    $0xc,%esp
  806a95:	53                   	push   %ebx
  806a96:	e8 92 e1 ff ff       	call   804c2d <pbuf_clen>
  806a9b:	0f b6 c0             	movzbl %al,%eax
  806a9e:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806aa0:	89 1c 24             	mov    %ebx,(%esp)
  806aa3:	e8 3b dd ff ff       	call   8047e3 <pbuf_free>
  806aa8:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806aab:	89 fb                	mov    %edi,%ebx
  806aad:	eb d6                	jmp    806a85 <ip_reass_free_complete_datagram+0x3c>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806aaf:	83 ec 04             	sub    $0x4,%esp
  806ab2:	68 07 23 81 00       	push   $0x812307
  806ab7:	68 99 00 00 00       	push   $0x99
  806abc:	68 ea 22 81 00       	push   $0x8122ea
  806ac1:	e8 e2 7a 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806ac6:	83 ec 04             	sub    $0x4,%esp
  806ac9:	68 13 23 81 00       	push   $0x812313
  806ace:	68 9b 00 00 00       	push   $0x9b
  806ad3:	68 ea 22 81 00       	push   $0x8122ea
  806ad8:	e8 cb 7a 00 00       	call   80e5a8 <_panic>
    ipr->p = iprh->next_pbuf;
  806add:	8b 00                	mov    (%eax),%eax
  806adf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806ae2:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806ae5:	83 ec 04             	sub    $0x4,%esp
  806ae8:	6a 14                	push   $0x14
  806aea:	8d 41 08             	lea    0x8(%ecx),%eax
  806aed:	50                   	push   %eax
  806aee:	ff 73 04             	pushl  0x4(%ebx)
  806af1:	e8 f7 84 00 00       	call   80efed <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806af6:	83 c4 08             	add    $0x8,%esp
  806af9:	6a 01                	push   $0x1
  806afb:	53                   	push   %ebx
  806afc:	e8 08 79 00 00       	call   80e409 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806b01:	89 1c 24             	mov    %ebx,(%esp)
  806b04:	e8 24 e1 ff ff       	call   804c2d <pbuf_clen>
  806b09:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806b0c:	89 1c 24             	mov    %ebx,(%esp)
  806b0f:	e8 cf dc ff ff       	call   8047e3 <pbuf_free>
  806b14:	83 c4 10             	add    $0x10,%esp
  806b17:	e9 63 ff ff ff       	jmp    806a7f <ip_reass_free_complete_datagram+0x36>
  ip_reass_dequeue_datagram(ipr, prev);
  806b1c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806b1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b22:	e8 db fe ff ff       	call   806a02 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b27:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806b2e:	0f b7 d0             	movzwl %ax,%edx
  806b31:	39 f2                	cmp    %esi,%edx
  806b33:	7c 12                	jl     806b47 <ip_reass_free_complete_datagram+0xfe>
  ip_reass_pbufcount -= pbufs_freed;
  806b35:	29 f0                	sub    %esi,%eax
  806b37:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806b3d:	89 f0                	mov    %esi,%eax
  806b3f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b42:	5b                   	pop    %ebx
  806b43:	5e                   	pop    %esi
  806b44:	5f                   	pop    %edi
  806b45:	5d                   	pop    %ebp
  806b46:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806b47:	83 ec 04             	sub    $0x4,%esp
  806b4a:	68 25 23 81 00       	push   $0x812325
  806b4f:	68 bc 00 00 00       	push   $0xbc
  806b54:	68 ea 22 81 00       	push   $0x8122ea
  806b59:	e8 4a 7a 00 00       	call   80e5a8 <_panic>

00806b5e <ip_reass_remove_oldest_datagram>:
{
  806b5e:	55                   	push   %ebp
  806b5f:	89 e5                	mov    %esp,%ebp
  806b61:	57                   	push   %edi
  806b62:	56                   	push   %esi
  806b63:	53                   	push   %ebx
  806b64:	83 ec 1c             	sub    $0x1c,%esp
  806b67:	89 c6                	mov    %eax,%esi
  806b69:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806b6c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806b73:	eb 5b                	jmp    806bd0 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806b75:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806b79:	85 c0                	test   %eax,%eax
  806b7b:	74 33                	je     806bb0 <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806b7d:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806b81:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806b84:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806b87:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806b89:	85 ff                	test   %edi,%edi
  806b8b:	0f 45 d1             	cmovne %ecx,%edx
  806b8e:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806b90:	85 c9                	test   %ecx,%ecx
  806b92:	74 20                	je     806bb4 <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806b94:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806b97:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806b9a:	75 d9                	jne    806b75 <ip_reass_remove_oldest_datagram+0x17>
  806b9c:	8b 7e 10             	mov    0x10(%esi),%edi
  806b9f:	39 79 18             	cmp    %edi,0x18(%ecx)
  806ba2:	75 d1                	jne    806b75 <ip_reass_remove_oldest_datagram+0x17>
  806ba4:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806ba8:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806bac:	75 c7                	jne    806b75 <ip_reass_remove_oldest_datagram+0x17>
  806bae:	eb d7                	jmp    806b87 <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806bb0:	89 c8                	mov    %ecx,%eax
  806bb2:	eb d3                	jmp    806b87 <ip_reass_remove_oldest_datagram+0x29>
  806bb4:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806bb7:	85 c0                	test   %eax,%eax
  806bb9:	74 08                	je     806bc3 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806bbb:	e8 89 fe ff ff       	call   806a49 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806bc0:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806bc3:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806bc6:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806bc9:	7d 1f                	jge    806bea <ip_reass_remove_oldest_datagram+0x8c>
  806bcb:	83 fb 01             	cmp    $0x1,%ebx
  806bce:	7e 1a                	jle    806bea <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806bd0:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
    other_datagrams = 0;
  806bd6:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806bdb:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806be0:	b8 00 00 00 00       	mov    $0x0,%eax
  806be5:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806be8:	eb a6                	jmp    806b90 <ip_reass_remove_oldest_datagram+0x32>
}
  806bea:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806bed:	83 c4 1c             	add    $0x1c,%esp
  806bf0:	5b                   	pop    %ebx
  806bf1:	5e                   	pop    %esi
  806bf2:	5f                   	pop    %edi
  806bf3:	5d                   	pop    %ebp
  806bf4:	c3                   	ret    

00806bf5 <ip_reass_tmr>:
{
  806bf5:	55                   	push   %ebp
  806bf6:	89 e5                	mov    %esp,%ebp
  806bf8:	56                   	push   %esi
  806bf9:	53                   	push   %ebx
  r = reassdatagrams;
  806bfa:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806bff:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806c04:	eb 0b                	jmp    806c11 <ip_reass_tmr+0x1c>
      r = r->next;
  806c06:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806c08:	89 da                	mov    %ebx,%edx
  806c0a:	e8 3a fe ff ff       	call   806a49 <ip_reass_free_complete_datagram>
      r = r->next;
  806c0f:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806c11:	85 c0                	test   %eax,%eax
  806c13:	74 14                	je     806c29 <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806c15:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806c19:	84 d2                	test   %dl,%dl
  806c1b:	74 e9                	je     806c06 <ip_reass_tmr+0x11>
      r->timer--;
  806c1d:	83 ea 01             	sub    $0x1,%edx
  806c20:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806c23:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806c25:	8b 00                	mov    (%eax),%eax
  806c27:	eb e8                	jmp    806c11 <ip_reass_tmr+0x1c>
}
  806c29:	5b                   	pop    %ebx
  806c2a:	5e                   	pop    %esi
  806c2b:	5d                   	pop    %ebp
  806c2c:	c3                   	ret    

00806c2d <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806c2d:	55                   	push   %ebp
  806c2e:	89 e5                	mov    %esp,%ebp
  806c30:	57                   	push   %edi
  806c31:	56                   	push   %esi
  806c32:	53                   	push   %ebx
  806c33:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806c36:	8b 45 08             	mov    0x8(%ebp),%eax
  806c39:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806c3c:	0f b7 03             	movzwl (%ebx),%eax
  806c3f:	50                   	push   %eax
  806c40:	e8 85 0a 00 00       	call   8076ca <ntohs>
  806c45:	66 c1 e8 08          	shr    $0x8,%ax
  806c49:	83 e0 0f             	and    $0xf,%eax
  806c4c:	83 c4 10             	add    $0x10,%esp
  806c4f:	83 f8 05             	cmp    $0x5,%eax
  806c52:	0f 85 dc 01 00 00    	jne    806e34 <ip_reass+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806c58:	83 ec 0c             	sub    $0xc,%esp
  806c5b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806c5f:	50                   	push   %eax
  806c60:	e8 65 0a 00 00       	call   8076ca <ntohs>
  806c65:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806c69:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806c6d:	89 04 24             	mov    %eax,(%esp)
  806c70:	e8 55 0a 00 00       	call   8076ca <ntohs>
  806c75:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806c79:	0f b7 03             	movzwl (%ebx),%eax
  806c7c:	89 04 24             	mov    %eax,(%esp)
  806c7f:	e8 46 0a 00 00       	call   8076ca <ntohs>
  806c84:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806c88:	83 c4 04             	add    $0x4,%esp
  806c8b:	ff 75 08             	pushl  0x8(%ebp)
  806c8e:	e8 9a df ff ff       	call   804c2d <pbuf_clen>
  806c93:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806c96:	0f b6 f0             	movzbl %al,%esi
  806c99:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806ca0:	01 f0                	add    %esi,%eax
  806ca2:	83 c4 10             	add    $0x10,%esp
  806ca5:	83 f8 0a             	cmp    $0xa,%eax
  806ca8:	7f 0d                	jg     806cb7 <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806caa:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806cb0:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cb5:	eb 28                	jmp    806cdf <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cb7:	89 f2                	mov    %esi,%edx
  806cb9:	89 d8                	mov    %ebx,%eax
  806cbb:	e8 9e fe ff ff       	call   806b5e <ip_reass_remove_oldest_datagram>
  806cc0:	85 c0                	test   %eax,%eax
  806cc2:	0f 84 6c 01 00 00    	je     806e34 <ip_reass+0x207>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806cc8:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806ccf:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806cd1:	83 f8 0a             	cmp    $0xa,%eax
  806cd4:	7e d4                	jle    806caa <ip_reass+0x7d>
  806cd6:	e9 59 01 00 00       	jmp    806e34 <ip_reass+0x207>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806cdb:	89 f8                	mov    %edi,%eax
  806cdd:	8b 3f                	mov    (%edi),%edi
  806cdf:	85 ff                	test   %edi,%edi
  806ce1:	0f 84 f5 00 00 00    	je     806ddc <ip_reass+0x1af>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806ce7:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806cea:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806ced:	75 ec                	jne    806cdb <ip_reass+0xae>
  806cef:	8b 53 10             	mov    0x10(%ebx),%edx
  806cf2:	39 57 18             	cmp    %edx,0x18(%edi)
  806cf5:	75 e4                	jne    806cdb <ip_reass+0xae>
  806cf7:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806cfb:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806cff:	75 da                	jne    806cdb <ip_reass+0xae>
  806d01:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806d04:	83 ec 0c             	sub    $0xc,%esp
  806d07:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d0b:	50                   	push   %eax
  806d0c:	e8 b9 09 00 00       	call   8076ca <ntohs>
  806d11:	83 c4 10             	add    $0x10,%esp
  806d14:	66 a9 ff 1f          	test   $0x1fff,%ax
  806d18:	0f 84 4b 01 00 00    	je     806e69 <ip_reass+0x23c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806d1e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806d22:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806d29:	83 ec 0c             	sub    $0xc,%esp
  806d2c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d30:	50                   	push   %eax
  806d31:	e8 94 09 00 00       	call   8076ca <ntohs>
  806d36:	83 c4 10             	add    $0x10,%esp
  806d39:	f6 c4 20             	test   $0x20,%ah
  806d3c:	75 20                	jne    806d5e <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806d3e:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806d42:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806d46:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806d4a:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d4d:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806d51:	66 c1 ea 06          	shr    $0x6,%dx
  806d55:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806d58:	29 d0                	sub    %edx,%eax
  806d5a:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806d5e:	8b 45 08             	mov    0x8(%ebp),%eax
  806d61:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d64:	83 ec 0c             	sub    $0xc,%esp
  806d67:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d6b:	50                   	push   %eax
  806d6c:	e8 59 09 00 00       	call   8076ca <ntohs>
  806d71:	89 c6                	mov    %eax,%esi
  806d73:	0f b7 03             	movzwl (%ebx),%eax
  806d76:	89 04 24             	mov    %eax,(%esp)
  806d79:	e8 4c 09 00 00       	call   8076ca <ntohs>
  806d7e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806d82:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d86:	89 04 24             	mov    %eax,(%esp)
  806d89:	e8 3c 09 00 00       	call   8076ca <ntohs>
  806d8e:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806d95:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806d98:	8b 51 04             	mov    0x4(%ecx),%edx
  806d9b:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806d9e:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806da4:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806da8:	01 de                	add    %ebx,%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806daa:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806dae:	66 c1 e8 06          	shr    $0x6,%ax
  806db2:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806db5:	29 c6                	sub    %eax,%esi
  806db7:	66 89 75 de          	mov    %si,-0x22(%ebp)
  806dbb:	66 89 72 06          	mov    %si,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806dbf:	8b 47 04             	mov    0x4(%edi),%eax
  806dc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806dc5:	83 c4 10             	add    $0x10,%esp
  int valid = 1;
  806dc8:	b9 01 00 00 00       	mov    $0x1,%ecx
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806dcd:	be 00 00 00 00       	mov    $0x0,%esi
  806dd2:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806dd5:	89 cf                	mov    %ecx,%edi
  806dd7:	e9 25 01 00 00       	jmp    806f01 <ip_reass+0x2d4>
  806ddc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806ddf:	83 ec 0c             	sub    $0xc,%esp
  806de2:	6a 05                	push   $0x5
  806de4:	e8 57 d6 ff ff       	call   804440 <memp_malloc>
  806de9:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806deb:	83 c4 10             	add    $0x10,%esp
  806dee:	85 c0                	test   %eax,%eax
  806df0:	74 35                	je     806e27 <ip_reass+0x1fa>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806df2:	83 ec 04             	sub    $0x4,%esp
  806df5:	6a 20                	push   $0x20
  806df7:	6a 00                	push   $0x0
  806df9:	57                   	push   %edi
  806dfa:	e8 44 81 00 00       	call   80ef43 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806dff:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806e03:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806e08:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806e0a:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806e10:	83 c4 0c             	add    $0xc,%esp
  806e13:	6a 14                	push   $0x14
  806e15:	53                   	push   %ebx
  806e16:	8d 47 08             	lea    0x8(%edi),%eax
  806e19:	50                   	push   %eax
  806e1a:	e8 ce 81 00 00       	call   80efed <memcpy>
  806e1f:	83 c4 10             	add    $0x10,%esp
  806e22:	e9 f7 fe ff ff       	jmp    806d1e <ip_reass+0xf1>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806e27:	89 f2                	mov    %esi,%edx
  806e29:	89 d8                	mov    %ebx,%eax
  806e2b:	e8 2e fd ff ff       	call   806b5e <ip_reass_remove_oldest_datagram>
  806e30:	39 c6                	cmp    %eax,%esi
  806e32:	7e 20                	jle    806e54 <ip_reass+0x227>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806e34:	83 ec 0c             	sub    $0xc,%esp
  806e37:	ff 75 08             	pushl  0x8(%ebp)
  806e3a:	e8 a4 d9 ff ff       	call   8047e3 <pbuf_free>
  return NULL;
  806e3f:	83 c4 10             	add    $0x10,%esp
  806e42:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806e49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806e4c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806e4f:	5b                   	pop    %ebx
  806e50:	5e                   	pop    %esi
  806e51:	5f                   	pop    %edi
  806e52:	5d                   	pop    %ebp
  806e53:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806e54:	83 ec 0c             	sub    $0xc,%esp
  806e57:	6a 05                	push   $0x5
  806e59:	e8 e2 d5 ff ff       	call   804440 <memp_malloc>
  806e5e:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806e60:	83 c4 10             	add    $0x10,%esp
  806e63:	85 c0                	test   %eax,%eax
  806e65:	75 8b                	jne    806df2 <ip_reass+0x1c5>
  806e67:	eb cb                	jmp    806e34 <ip_reass+0x207>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806e69:	83 ec 0c             	sub    $0xc,%esp
  806e6c:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806e70:	50                   	push   %eax
  806e71:	e8 54 08 00 00       	call   8076ca <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806e76:	83 c4 10             	add    $0x10,%esp
  806e79:	66 a9 ff 1f          	test   $0x1fff,%ax
  806e7d:	0f 84 9b fe ff ff    	je     806d1e <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806e83:	83 ec 04             	sub    $0x4,%esp
  806e86:	6a 14                	push   $0x14
  806e88:	53                   	push   %ebx
  806e89:	8d 47 08             	lea    0x8(%edi),%eax
  806e8c:	50                   	push   %eax
  806e8d:	e8 5b 81 00 00       	call   80efed <memcpy>
  806e92:	83 c4 10             	add    $0x10,%esp
  806e95:	e9 84 fe ff ff       	jmp    806d1e <ip_reass+0xf1>
  806e9a:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806e9d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  806ea0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806ea3:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806ea5:	85 f6                	test   %esi,%esi
  806ea7:	74 4c                	je     806ef5 <ip_reass+0x2c8>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806ea9:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806ead:	0f 82 c5 01 00 00    	jb     807078 <ip_reass+0x44b>
  806eb3:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  806eb7:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806ebb:	0f 87 b7 01 00 00    	ja     807078 <ip_reass+0x44b>
        iprh_prev->next_pbuf = new_p;
  806ec1:	8b 45 08             	mov    0x8(%ebp),%eax
  806ec4:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806ec6:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806eca:	0f 84 cb 01 00 00    	je     80709b <ip_reass+0x46e>
    if (valid) {
  806ed0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806ed4:	0f 84 c1 01 00 00    	je     80709b <ip_reass+0x46e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806eda:	8b 4f 04             	mov    0x4(%edi),%ecx
  806edd:	8b 59 04             	mov    0x4(%ecx),%ebx
  806ee0:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806ee5:	0f 85 b0 01 00 00    	jne    80709b <ip_reass+0x46e>
        q = iprh->next_pbuf;
  806eeb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806eee:	8b 16                	mov    (%esi),%edx
  806ef0:	e9 85 00 00 00       	jmp    806f7a <ip_reass+0x34d>
        ipr->p = new_p;
  806ef5:	8b 45 08             	mov    0x8(%ebp),%eax
  806ef8:	89 47 04             	mov    %eax,0x4(%edi)
  806efb:	eb c9                	jmp    806ec6 <ip_reass+0x299>
    q = iprh_tmp->next_pbuf;
  806efd:	8b 02                	mov    (%edx),%eax
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806eff:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  806f01:	85 c0                	test   %eax,%eax
  806f03:	0f 84 c8 01 00 00    	je     8070d1 <ip_reass+0x4a4>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806f09:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806f0c:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806f10:	66 39 cb             	cmp    %cx,%bx
  806f13:	72 85                	jb     806e9a <ip_reass+0x26d>
    } else if(iprh->start == iprh_tmp->start) {
  806f15:	0f 84 5d 01 00 00    	je     807078 <ip_reass+0x44b>
    } else if(iprh->start < iprh_tmp->end) {
  806f1b:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806f1f:	0f 82 53 01 00 00    	jb     807078 <ip_reass+0x44b>
      if (iprh_prev != NULL) {
  806f25:	85 f6                	test   %esi,%esi
  806f27:	74 d4                	je     806efd <ip_reass+0x2d0>
          valid = 0;
  806f29:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806f2d:	b8 00 00 00 00       	mov    $0x0,%eax
  806f32:	0f 45 f8             	cmovne %eax,%edi
  806f35:	eb c6                	jmp    806efd <ip_reass+0x2d0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806f37:	83 ec 04             	sub    $0x4,%esp
  806f3a:	68 40 23 81 00       	push   $0x812340
  806f3f:	68 83 01 00 00       	push   $0x183
  806f44:	68 ea 22 81 00       	push   $0x8122ea
  806f49:	e8 5a 76 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f4e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  806f52:	75 0b                	jne    806f5f <ip_reass+0x332>
      ipr->p = new_p;
  806f54:	8b 45 08             	mov    0x8(%ebp),%eax
  806f57:	89 47 04             	mov    %eax,0x4(%edi)
  806f5a:	e9 67 ff ff ff       	jmp    806ec6 <ip_reass+0x299>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806f5f:	83 ec 04             	sub    $0x4,%esp
  806f62:	68 6c 23 81 00       	push   $0x81236c
  806f67:	68 8c 01 00 00       	push   $0x18c
  806f6c:	68 ea 22 81 00       	push   $0x8122ea
  806f71:	e8 32 76 00 00       	call   80e5a8 <_panic>
          q = iprh->next_pbuf;
  806f76:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  806f78:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  806f7a:	85 d2                	test   %edx,%edx
  806f7c:	74 12                	je     806f90 <ip_reass+0x363>
          iprh = (struct ip_reass_helper*)q->payload;
  806f7e:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  806f81:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  806f85:	66 39 56 06          	cmp    %dx,0x6(%esi)
  806f89:	74 eb                	je     806f76 <ip_reass+0x349>
  806f8b:	e9 0b 01 00 00       	jmp    80709b <ip_reass+0x46e>
  806f90:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  806f93:	39 f3                	cmp    %esi,%ebx
  806f95:	0f 84 98 00 00 00    	je     807033 <ip_reass+0x406>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  806f9b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f9e:	83 38 00             	cmpl   $0x0,(%eax)
  806fa1:	0f 85 a3 00 00 00    	jne    80704a <ip_reass+0x41d>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  806fa7:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806fab:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806fae:	66 39 46 06          	cmp    %ax,0x6(%esi)
  806fb2:	0f 85 a9 00 00 00    	jne    807061 <ip_reass+0x434>
    ipr->datagram_len += IP_HLEN;
  806fb8:	83 c0 14             	add    $0x14,%eax
  806fbb:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  806fbf:	8b 71 04             	mov    0x4(%ecx),%esi
  806fc2:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  806fc4:	83 ec 04             	sub    $0x4,%esp
  806fc7:	6a 14                	push   $0x14
  806fc9:	8d 47 08             	lea    0x8(%edi),%eax
  806fcc:	50                   	push   %eax
  806fcd:	56                   	push   %esi
  806fce:	e8 1a 80 00 00       	call   80efed <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  806fd3:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  806fd7:	89 04 24             	mov    %eax,(%esp)
  806fda:	e8 de 06 00 00       	call   8076bd <htons>
  806fdf:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  806fe3:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  806fe9:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  806fef:	83 c4 08             	add    $0x8,%esp
  806ff2:	6a 14                	push   $0x14
  806ff4:	56                   	push   %esi
  806ff5:	e8 95 05 00 00       	call   80758f <inet_chksum>
  806ffa:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  806ffe:	8b 47 04             	mov    0x4(%edi),%eax
  807001:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807004:	83 c4 10             	add    $0x10,%esp
  807007:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80700a:	89 c7                	mov    %eax,%edi
  80700c:	85 db                	test   %ebx,%ebx
  80700e:	0f 84 93 00 00 00    	je     8070a7 <ip_reass+0x47a>
      iprh = (struct ip_reass_helper*)r->payload;
  807014:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  807017:	83 ec 08             	sub    $0x8,%esp
  80701a:	6a ec                	push   $0xffffffec
  80701c:	53                   	push   %ebx
  80701d:	e8 f4 d6 ff ff       	call   804716 <pbuf_header>
      pbuf_cat(p, r);
  807022:	83 c4 08             	add    $0x8,%esp
  807025:	53                   	push   %ebx
  807026:	57                   	push   %edi
  807027:	e8 2a dc ff ff       	call   804c56 <pbuf_cat>
      r = iprh->next_pbuf;
  80702c:	8b 1e                	mov    (%esi),%ebx
  80702e:	83 c4 10             	add    $0x10,%esp
  807031:	eb d9                	jmp    80700c <ip_reass+0x3df>
          LWIP_ASSERT("sanity check",
  807033:	83 ec 04             	sub    $0x4,%esp
  807036:	68 5e 23 81 00       	push   $0x81235e
  80703b:	68 ae 01 00 00       	push   $0x1ae
  807040:	68 ea 22 81 00       	push   $0x8122ea
  807045:	e8 5e 75 00 00       	call   80e5a8 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80704a:	83 ec 04             	sub    $0x4,%esp
  80704d:	68 a4 23 81 00       	push   $0x8123a4
  807052:	68 b0 01 00 00       	push   $0x1b0
  807057:	68 ea 22 81 00       	push   $0x8122ea
  80705c:	e8 47 75 00 00       	call   80e5a8 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807061:	83 ec 04             	sub    $0x4,%esp
  807064:	68 c8 23 81 00       	push   $0x8123c8
  807069:	68 b2 01 00 00       	push   $0x1b2
  80706e:	68 ea 22 81 00       	push   $0x8122ea
  807073:	e8 30 75 00 00       	call   80e5a8 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807078:	83 ec 0c             	sub    $0xc,%esp
  80707b:	ff 75 08             	pushl  0x8(%ebp)
  80707e:	e8 aa db ff ff       	call   804c2d <pbuf_clen>
  807083:	0f b6 c0             	movzbl %al,%eax
  807086:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  80708d:	83 c4 04             	add    $0x4,%esp
  807090:	ff 75 08             	pushl  0x8(%ebp)
  807093:	e8 4b d7 ff ff       	call   8047e3 <pbuf_free>
  807098:	83 c4 10             	add    $0x10,%esp
  return NULL;
  80709b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8070a2:	e9 a2 fd ff ff       	jmp    806e49 <ip_reass+0x21c>
  8070a7:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8070aa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8070ad:	89 f8                	mov    %edi,%eax
  8070af:	e8 4e f9 ff ff       	call   806a02 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  8070b4:	83 ec 0c             	sub    $0xc,%esp
  8070b7:	ff 75 e4             	pushl  -0x1c(%ebp)
  8070ba:	e8 6e db ff ff       	call   804c2d <pbuf_clen>
  8070bf:	0f b6 c0             	movzbl %al,%eax
  8070c2:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  8070c9:	83 c4 10             	add    $0x10,%esp
  8070cc:	e9 78 fd ff ff       	jmp    806e49 <ip_reass+0x21c>
  8070d1:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8070d4:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  8070d7:	85 f6                	test   %esi,%esi
  8070d9:	0f 84 6f fe ff ff    	je     806f4e <ip_reass+0x321>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8070df:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8070e3:	66 39 c3             	cmp    %ax,%bx
  8070e6:	0f 82 4b fe ff ff    	jb     806f37 <ip_reass+0x30a>
      iprh_prev->next_pbuf = new_p;
  8070ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8070ef:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  8070f1:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8070f4:	66 3b 46 04          	cmp    0x4(%esi),%ax
  8070f8:	75 a1                	jne    80709b <ip_reass+0x46e>
  8070fa:	e9 c7 fd ff ff       	jmp    806ec6 <ip_reass+0x299>

008070ff <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8070ff:	55                   	push   %ebp
  807100:	89 e5                	mov    %esp,%ebp
  807102:	57                   	push   %edi
  807103:	56                   	push   %esi
  807104:	53                   	push   %ebx
  807105:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807108:	8b 45 0c             	mov    0xc(%ebp),%eax
  80710b:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  80710f:	6a 02                	push   $0x2
  807111:	6a 00                	push   $0x0
  807113:	6a 02                	push   $0x2
  807115:	e8 8f d7 ff ff       	call   8048a9 <pbuf_alloc>
  80711a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  80711d:	83 c4 10             	add    $0x10,%esp
  807120:	85 c0                	test   %eax,%eax
  807122:	0f 84 c2 00 00 00    	je     8071ea <ip_frag+0xeb>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  807128:	66 89 70 0a          	mov    %si,0xa(%eax)
  80712c:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807130:	bb 03 44 b3 00       	mov    $0xb34403,%ebx
  807135:	83 e3 fc             	and    $0xfffffffc,%ebx
  807138:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80713b:	83 ec 04             	sub    $0x4,%esp
  80713e:	6a 14                	push   $0x14
  807140:	8b 45 08             	mov    0x8(%ebp),%eax
  807143:	ff 70 04             	pushl  0x4(%eax)
  807146:	53                   	push   %ebx
  807147:	e8 a1 7e 00 00       	call   80efed <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80714c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807150:	89 04 24             	mov    %eax,(%esp)
  807153:	e8 72 05 00 00       	call   8076ca <ntohs>
  ofo = tmp & IP_OFFMASK;
  807158:	89 c7                	mov    %eax,%edi
  80715a:	66 81 e7 ff 1f       	and    $0x1fff,%di
  80715f:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  807163:	66 25 00 20          	and    $0x2000,%ax
  807167:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  80716b:	8b 45 08             	mov    0x8(%ebp),%eax
  80716e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807172:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  807175:	0f b7 f6             	movzwl %si,%esi
  807178:	8d 46 f3             	lea    -0xd(%esi),%eax
  80717b:	83 c4 10             	add    $0x10,%esp
  80717e:	89 f2                	mov    %esi,%edx
  807180:	83 ea 14             	sub    $0x14,%edx
  807183:	0f 49 c2             	cmovns %edx,%eax
  807186:	c1 f8 03             	sar    $0x3,%eax
  807189:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80718d:	c1 e0 03             	shl    $0x3,%eax
  807190:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807194:	0f b7 c8             	movzwl %ax,%ecx
  807197:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80719a:	83 c0 14             	add    $0x14,%eax
  80719d:	0f b7 c0             	movzwl %ax,%eax
  8071a0:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  8071a3:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  8071a9:	8d 46 ed             	lea    -0x13(%esi),%eax
  8071ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071af:	8d 43 14             	lea    0x14(%ebx),%eax
  8071b2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  8071b5:	e9 e3 00 00 00       	jmp    80729d <ip_frag+0x19e>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8071ba:	83 ec 0c             	sub    $0xc,%esp
  8071bd:	ff 75 dc             	pushl  -0x24(%ebp)
  8071c0:	e8 1e d6 ff ff       	call   8047e3 <pbuf_free>
      return ERR_MEM;
  8071c5:	83 c4 10             	add    $0x10,%esp
  8071c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071cd:	eb 13                	jmp    8071e2 <ip_frag+0xe3>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8071cf:	83 ec 0c             	sub    $0xc,%esp
  8071d2:	ff 75 dc             	pushl  -0x24(%ebp)
  8071d5:	e8 09 d6 ff ff       	call   8047e3 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8071da:	83 c4 10             	add    $0x10,%esp
  8071dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8071e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8071e5:	5b                   	pop    %ebx
  8071e6:	5e                   	pop    %esi
  8071e7:	5f                   	pop    %edi
  8071e8:	5d                   	pop    %ebp
  8071e9:	c3                   	ret    
    return ERR_MEM;
  8071ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8071ef:	eb f1                	jmp    8071e2 <ip_frag+0xe3>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8071f1:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  8071f5:	52                   	push   %edx
  8071f6:	50                   	push   %eax
  8071f7:	ff 75 d4             	pushl  -0x2c(%ebp)
  8071fa:	ff 75 08             	pushl  0x8(%ebp)
  8071fd:	e8 5d dd ff ff       	call   804f5f <pbuf_copy_partial>
  807202:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807206:	0f b7 f6             	movzwl %si,%esi
  807209:	89 34 24             	mov    %esi,(%esp)
  80720c:	e8 ac 04 00 00       	call   8076bd <htons>
  807211:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807215:	8d 77 14             	lea    0x14(%edi),%esi
  807218:	0f b7 f6             	movzwl %si,%esi
  80721b:	89 34 24             	mov    %esi,(%esp)
  80721e:	e8 9a 04 00 00       	call   8076bd <htons>
  807223:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807227:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80722d:	83 c4 08             	add    $0x8,%esp
  807230:	6a 14                	push   $0x14
  807232:	53                   	push   %ebx
  807233:	e8 57 03 00 00       	call   80758f <inet_chksum>
  807238:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      pbuf_realloc(rambuf, left + IP_HLEN);
  80723c:	83 c4 08             	add    $0x8,%esp
  80723f:	56                   	push   %esi
  807240:	ff 75 dc             	pushl  -0x24(%ebp)
  807243:	e8 d3 d8 ff ff       	call   804b1b <pbuf_realloc>
  807248:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  80724b:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80724f:	83 ec 04             	sub    $0x4,%esp
  807252:	6a 00                	push   $0x0
  807254:	6a 00                	push   $0x0
  807256:	6a 02                	push   $0x2
  807258:	e8 4c d6 ff ff       	call   8048a9 <pbuf_alloc>
  80725d:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80725f:	83 c4 10             	add    $0x10,%esp
  807262:	85 c0                	test   %eax,%eax
  807264:	0f 84 50 ff ff ff    	je     8071ba <ip_frag+0xbb>
      pbuf_chain(header, rambuf);
  80726a:	83 ec 08             	sub    $0x8,%esp
  80726d:	ff 75 dc             	pushl  -0x24(%ebp)
  807270:	50                   	push   %eax
  807271:	e8 4e da ff ff       	call   804cc4 <pbuf_chain>
      netif->output(netif, header, dest);
  807276:	83 c4 0c             	add    $0xc,%esp
  807279:	ff 75 10             	pushl  0x10(%ebp)
  80727c:	56                   	push   %esi
  80727d:	ff 75 0c             	pushl  0xc(%ebp)
  807280:	8b 45 0c             	mov    0xc(%ebp),%eax
  807283:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  807286:	89 34 24             	mov    %esi,(%esp)
  807289:	e8 55 d5 ff ff       	call   8047e3 <pbuf_free>
    left -= cop;
  80728e:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  807292:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  807296:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  80729a:	83 c4 10             	add    $0x10,%esp
  while (left) {
  80729d:	66 85 ff             	test   %di,%di
  8072a0:	0f 84 29 ff ff ff    	je     8071cf <ip_frag+0xd0>
    last = (left <= mtu - IP_HLEN);
  8072a6:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  8072a9:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  8072ad:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8072b2:	66 0b 75 e0          	or     -0x20(%ebp),%si
    if (!last)
  8072b6:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8072b9:	0f 8f 32 ff ff ff    	jg     8071f1 <ip_frag+0xf2>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8072bf:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8072c3:	50                   	push   %eax
  8072c4:	ff 75 cc             	pushl  -0x34(%ebp)
  8072c7:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072ca:	ff 75 08             	pushl  0x8(%ebp)
  8072cd:	e8 8d dc ff ff       	call   804f5f <pbuf_copy_partial>
  8072d2:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  8072d6:	66 81 ce 00 20       	or     $0x2000,%si
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8072db:	0f b7 f6             	movzwl %si,%esi
  8072de:	89 34 24             	mov    %esi,(%esp)
  8072e1:	e8 d7 03 00 00       	call   8076bd <htons>
  8072e6:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072ea:	83 c4 04             	add    $0x4,%esp
  8072ed:	ff 75 c8             	pushl  -0x38(%ebp)
  8072f0:	e8 c8 03 00 00       	call   8076bd <htons>
  8072f5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  8072f9:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8072ff:	83 c4 08             	add    $0x8,%esp
  807302:	6a 14                	push   $0x14
  807304:	53                   	push   %ebx
  807305:	e8 85 02 00 00       	call   80758f <inet_chksum>
  80730a:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  80730e:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807311:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  807315:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  807319:	e9 31 ff ff ff       	jmp    80724f <ip_frag+0x150>

0080731e <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80731e:	55                   	push   %ebp
  80731f:	89 e5                	mov    %esp,%ebp
  807321:	57                   	push   %edi
  807322:	56                   	push   %esi
  807323:	53                   	push   %ebx
  807324:	83 ec 1c             	sub    $0x1c,%esp
  807327:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80732a:	89 d7                	mov    %edx,%edi
  80732c:	66 d1 ef             	shr    %di
  80732f:	0f b7 d7             	movzwl %di,%edx
  807332:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807335:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80733a:	39 f0                	cmp    %esi,%eax
  80733c:	74 18                	je     807356 <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80733e:	0f b6 10             	movzbl (%eax),%edx
  807341:	89 d1                	mov    %edx,%ecx
  807343:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807346:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80734a:	09 ca                	or     %ecx,%edx
  80734c:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  80734f:	0f b7 d2             	movzwl %dx,%edx
  807352:	01 d3                	add    %edx,%ebx
  807354:	eb e4                	jmp    80733a <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  807356:	01 ff                	add    %edi,%edi
  807358:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  80735c:	74 0b                	je     807369 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80735e:	0f b6 00             	movzbl (%eax),%eax
  807361:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807364:	0f b7 c0             	movzwl %ax,%eax
  807367:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807369:	89 d8                	mov    %ebx,%eax
  80736b:	c1 e8 10             	shr    $0x10,%eax
  80736e:	0f b7 db             	movzwl %bx,%ebx
  807371:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807373:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807379:	74 0a                	je     807385 <lwip_standard_chksum+0x67>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80737b:	89 d8                	mov    %ebx,%eax
  80737d:	c1 e8 10             	shr    $0x10,%eax
  807380:	0f b7 db             	movzwl %bx,%ebx
  807383:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807385:	83 ec 0c             	sub    $0xc,%esp
  807388:	0f b7 db             	movzwl %bx,%ebx
  80738b:	53                   	push   %ebx
  80738c:	e8 2c 03 00 00       	call   8076bd <htons>
}
  807391:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807394:	5b                   	pop    %ebx
  807395:	5e                   	pop    %esi
  807396:	5f                   	pop    %edi
  807397:	5d                   	pop    %ebp
  807398:	c3                   	ret    

00807399 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807399:	55                   	push   %ebp
  80739a:	89 e5                	mov    %esp,%ebp
  80739c:	57                   	push   %edi
  80739d:	56                   	push   %esi
  80739e:	53                   	push   %ebx
  80739f:	83 ec 1c             	sub    $0x1c,%esp
  8073a2:	8b 75 08             	mov    0x8(%ebp),%esi
  8073a5:	8b 45 14             	mov    0x14(%ebp),%eax
  8073a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8073ab:	8b 45 18             	mov    0x18(%ebp),%eax
  8073ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8073b1:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8073b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8073bb:	89 f8                	mov    %edi,%eax
  8073bd:	89 df                	mov    %ebx,%edi
  8073bf:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8073c1:	eb 02                	jmp    8073c5 <inet_chksum_pseudo+0x2c>
  8073c3:	8b 36                	mov    (%esi),%esi
  8073c5:	85 f6                	test   %esi,%esi
  8073c7:	74 3d                	je     807406 <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8073c9:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8073cd:	8b 46 04             	mov    0x4(%esi),%eax
  8073d0:	e8 49 ff ff ff       	call   80731e <lwip_standard_chksum>
  8073d5:	0f b7 c0             	movzwl %ax,%eax
  8073d8:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8073da:	89 c7                	mov    %eax,%edi
  8073dc:	c1 ef 10             	shr    $0x10,%edi
  8073df:	0f b7 c0             	movzwl %ax,%eax
  8073e2:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  8073e4:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8073e8:	74 d9                	je     8073c3 <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  8073ea:	b8 01 00 00 00       	mov    $0x1,%eax
  8073ef:	29 d8                	sub    %ebx,%eax
  8073f1:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  8073f3:	89 fa                	mov    %edi,%edx
  8073f5:	c1 e2 08             	shl    $0x8,%edx
  8073f8:	0f b7 d2             	movzwl %dx,%edx
  8073fb:	89 f8                	mov    %edi,%eax
  8073fd:	0f b6 c4             	movzbl %ah,%eax
  807400:	09 c2                	or     %eax,%edx
  807402:	89 d7                	mov    %edx,%edi
  807404:	eb bd                	jmp    8073c3 <inet_chksum_pseudo+0x2a>
  807406:	89 d8                	mov    %ebx,%eax
  807408:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80740a:	84 c0                	test   %al,%al
  80740c:	74 0d                	je     80741b <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  80740e:	89 f8                	mov    %edi,%eax
  807410:	c1 e0 08             	shl    $0x8,%eax
  807413:	0f b7 c0             	movzwl %ax,%eax
  807416:	0f b6 df             	movzbl %bh,%ebx
  807419:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80741b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80741e:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807420:	8b 55 10             	mov    0x10(%ebp),%edx
  807423:	8b 12                	mov    (%edx),%edx
  807425:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807428:	c1 ea 10             	shr    $0x10,%edx
  80742b:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  80742d:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807430:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807432:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807435:	01 d0                	add    %edx,%eax
  807437:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  807439:	83 ec 0c             	sub    $0xc,%esp
  80743c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807440:	50                   	push   %eax
  807441:	e8 77 02 00 00       	call   8076bd <htons>
  807446:	0f b7 c0             	movzwl %ax,%eax
  807449:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80744b:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80744f:	89 04 24             	mov    %eax,(%esp)
  807452:	e8 66 02 00 00       	call   8076bd <htons>
  807457:	0f b7 c0             	movzwl %ax,%eax
  80745a:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80745c:	89 d8                	mov    %ebx,%eax
  80745e:	c1 e8 10             	shr    $0x10,%eax
  807461:	0f b7 db             	movzwl %bx,%ebx
  807464:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807466:	89 d8                	mov    %ebx,%eax
  807468:	c1 e8 10             	shr    $0x10,%eax
  80746b:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80746d:	f7 d0                	not    %eax
}
  80746f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807472:	5b                   	pop    %ebx
  807473:	5e                   	pop    %esi
  807474:	5f                   	pop    %edi
  807475:	5d                   	pop    %ebp
  807476:	c3                   	ret    

00807477 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807477:	55                   	push   %ebp
  807478:	89 e5                	mov    %esp,%ebp
  80747a:	57                   	push   %edi
  80747b:	56                   	push   %esi
  80747c:	53                   	push   %ebx
  80747d:	83 ec 1c             	sub    $0x1c,%esp
  807480:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807483:	8b 45 14             	mov    0x14(%ebp),%eax
  807486:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807489:	8b 45 18             	mov    0x18(%ebp),%eax
  80748c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80748f:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807493:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  807497:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80749e:	eb 19                	jmp    8074b9 <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074a0:	83 ec 04             	sub    $0x4,%esp
  8074a3:	68 f5 23 81 00       	push   $0x8123f5
  8074a8:	68 60 01 00 00       	push   $0x160
  8074ad:	68 00 24 81 00       	push   $0x812400
  8074b2:	e8 f1 70 00 00       	call   80e5a8 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8074b7:	8b 1b                	mov    (%ebx),%ebx
  8074b9:	85 db                	test   %ebx,%ebx
  8074bb:	74 5c                	je     807519 <inet_chksum_pseudo_partial+0xa2>
  8074bd:	66 85 f6             	test   %si,%si
  8074c0:	74 57                	je     807519 <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  8074c2:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8074c6:	66 39 fe             	cmp    %di,%si
  8074c9:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  8074cc:	0f b7 d7             	movzwl %di,%edx
  8074cf:	8b 43 04             	mov    0x4(%ebx),%eax
  8074d2:	e8 47 fe ff ff       	call   80731e <lwip_standard_chksum>
  8074d7:	0f b7 c0             	movzwl %ax,%eax
  8074da:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8074dd:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8074df:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8074e4:	77 ba                	ja     8074a0 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8074e6:	89 c2                	mov    %eax,%edx
  8074e8:	c1 ea 10             	shr    $0x10,%edx
  8074eb:	0f b7 c0             	movzwl %ax,%eax
  8074ee:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  8074f1:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  8074f4:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  8074f8:	74 bd                	je     8074b7 <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  8074fa:	b8 01 00 00 00       	mov    $0x1,%eax
  8074ff:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807502:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807505:	89 fa                	mov    %edi,%edx
  807507:	c1 e2 08             	shl    $0x8,%edx
  80750a:	0f b7 d2             	movzwl %dx,%edx
  80750d:	89 f8                	mov    %edi,%eax
  80750f:	0f b6 c4             	movzbl %ah,%eax
  807512:	09 c2                	or     %eax,%edx
  807514:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807517:	eb 9e                	jmp    8074b7 <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807519:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80751d:	74 13                	je     807532 <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  80751f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807522:	89 c8                	mov    %ecx,%eax
  807524:	c1 e0 08             	shl    $0x8,%eax
  807527:	0f b7 c0             	movzwl %ax,%eax
  80752a:	0f b6 d5             	movzbl %ch,%edx
  80752d:	09 d0                	or     %edx,%eax
  80752f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807532:	8b 45 0c             	mov    0xc(%ebp),%eax
  807535:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807537:	8b 45 10             	mov    0x10(%ebp),%eax
  80753a:	8b 00                	mov    (%eax),%eax
  80753c:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80753f:	c1 e8 10             	shr    $0x10,%eax
  807542:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  807544:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807547:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  807549:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80754c:	01 c3                	add    %eax,%ebx
  80754e:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807551:	83 ec 0c             	sub    $0xc,%esp
  807554:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807558:	50                   	push   %eax
  807559:	e8 5f 01 00 00       	call   8076bd <htons>
  80755e:	0f b7 f0             	movzwl %ax,%esi
  807561:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  807563:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807567:	89 04 24             	mov    %eax,(%esp)
  80756a:	e8 4e 01 00 00       	call   8076bd <htons>
  80756f:	0f b7 d8             	movzwl %ax,%ebx
  807572:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807574:	89 d8                	mov    %ebx,%eax
  807576:	c1 e8 10             	shr    $0x10,%eax
  807579:	0f b7 db             	movzwl %bx,%ebx
  80757c:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80757e:	89 d8                	mov    %ebx,%eax
  807580:	c1 e8 10             	shr    $0x10,%eax
  807583:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807585:	f7 d0                	not    %eax
}
  807587:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80758a:	5b                   	pop    %ebx
  80758b:	5e                   	pop    %esi
  80758c:	5f                   	pop    %edi
  80758d:	5d                   	pop    %ebp
  80758e:	c3                   	ret    

0080758f <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80758f:	55                   	push   %ebp
  807590:	89 e5                	mov    %esp,%ebp
  807592:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807595:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807599:	8b 45 08             	mov    0x8(%ebp),%eax
  80759c:	e8 7d fd ff ff       	call   80731e <lwip_standard_chksum>
  8075a1:	f7 d0                	not    %eax
}
  8075a3:	c9                   	leave  
  8075a4:	c3                   	ret    

008075a5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8075a5:	55                   	push   %ebp
  8075a6:	89 e5                	mov    %esp,%ebp
  8075a8:	57                   	push   %edi
  8075a9:	56                   	push   %esi
  8075aa:	53                   	push   %ebx
  8075ab:	83 ec 0c             	sub    $0xc,%esp
  8075ae:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8075b1:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8075b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  8075bb:	eb 02                	jmp    8075bf <inet_chksum_pbuf+0x1a>
  8075bd:	8b 36                	mov    (%esi),%esi
  8075bf:	85 f6                	test   %esi,%esi
  8075c1:	74 3b                	je     8075fe <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8075c3:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8075c7:	8b 46 04             	mov    0x4(%esi),%eax
  8075ca:	e8 4f fd ff ff       	call   80731e <lwip_standard_chksum>
  8075cf:	0f b7 c0             	movzwl %ax,%eax
  8075d2:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8075d4:	89 d8                	mov    %ebx,%eax
  8075d6:	c1 e8 10             	shr    $0x10,%eax
  8075d9:	0f b7 db             	movzwl %bx,%ebx
  8075dc:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8075de:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8075e2:	74 d9                	je     8075bd <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  8075e4:	b8 01 00 00 00       	mov    $0x1,%eax
  8075e9:	89 f9                	mov    %edi,%ecx
  8075eb:	29 c8                	sub    %ecx,%eax
  8075ed:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  8075ef:	89 da                	mov    %ebx,%edx
  8075f1:	c1 e2 08             	shl    $0x8,%edx
  8075f4:	0f b7 d2             	movzwl %dx,%edx
  8075f7:	0f b6 df             	movzbl %bh,%ebx
  8075fa:	09 d3                	or     %edx,%ebx
  8075fc:	eb bf                	jmp    8075bd <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  8075fe:	89 f8                	mov    %edi,%eax
  807600:	84 c0                	test   %al,%al
  807602:	74 0d                	je     807611 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  807604:	89 da                	mov    %ebx,%edx
  807606:	c1 e2 08             	shl    $0x8,%edx
  807609:	0f b7 d2             	movzwl %dx,%edx
  80760c:	0f b6 df             	movzbl %bh,%ebx
  80760f:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807611:	89 d8                	mov    %ebx,%eax
  807613:	f7 d0                	not    %eax
}
  807615:	83 c4 0c             	add    $0xc,%esp
  807618:	5b                   	pop    %ebx
  807619:	5e                   	pop    %esi
  80761a:	5f                   	pop    %edi
  80761b:	5d                   	pop    %ebp
  80761c:	c3                   	ret    

0080761d <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80761d:	55                   	push   %ebp
  80761e:	89 e5                	mov    %esp,%ebp
  807620:	57                   	push   %edi
  807621:	56                   	push   %esi
  807622:	53                   	push   %ebx
  807623:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807626:	8b 45 08             	mov    0x8(%ebp),%eax
  807629:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80762c:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  807630:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  807633:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  807638:	eb 1a                	jmp    807654 <inet_ntoa+0x37>
  80763a:	0f b6 db             	movzbl %bl,%ebx
  80763d:	01 fb                	add    %edi,%ebx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  80763f:	8d 7b 01             	lea    0x1(%ebx),%edi
  807642:	c6 03 2e             	movb   $0x2e,(%ebx)
  807645:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  807648:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  80764c:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807650:	3c 04                	cmp    $0x4,%al
  807652:	74 59                	je     8076ad <inet_ntoa+0x90>
  rp = str;
  807654:	ba 00 00 00 00       	mov    $0x0,%edx
      rem = *ap % (u8_t)10;
  807659:	0f b6 0e             	movzbl (%esi),%ecx
      *ap /= (u8_t)10;
  80765c:	0f b6 d9             	movzbl %cl,%ebx
  80765f:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807662:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807665:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807668:	66 c1 e8 0b          	shr    $0xb,%ax
  80766c:	88 06                	mov    %al,(%esi)
      inv[i++] = '0' + rem;
  80766e:	8d 5a 01             	lea    0x1(%edx),%ebx
  807671:	0f b6 d2             	movzbl %dl,%edx
  807674:	89 55 e0             	mov    %edx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807677:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80767a:	01 c0                	add    %eax,%eax
  80767c:	89 ca                	mov    %ecx,%edx
  80767e:	29 c2                	sub    %eax,%edx
  807680:	89 d0                	mov    %edx,%eax
      inv[i++] = '0' + rem;
  807682:	83 c0 30             	add    $0x30,%eax
  807685:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807688:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  80768c:	89 da                	mov    %ebx,%edx
    } while(*ap);
  80768e:	80 f9 09             	cmp    $0x9,%cl
  807691:	77 c6                	ja     807659 <inet_ntoa+0x3c>
  807693:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  807695:	89 d8                	mov    %ebx,%eax
    while(i--)
  807697:	83 e8 01             	sub    $0x1,%eax
  80769a:	3c ff                	cmp    $0xff,%al
  80769c:	74 9c                	je     80763a <inet_ntoa+0x1d>
      *rp++ = inv[i];
  80769e:	0f b6 c8             	movzbl %al,%ecx
  8076a1:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8076a6:	88 0a                	mov    %cl,(%edx)
  8076a8:	83 c2 01             	add    $0x1,%edx
  8076ab:	eb ea                	jmp    807697 <inet_ntoa+0x7a>
    ap++;
  }
  *--rp = 0;
  8076ad:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  8076b0:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  8076b5:	83 c4 18             	add    $0x18,%esp
  8076b8:	5b                   	pop    %ebx
  8076b9:	5e                   	pop    %esi
  8076ba:	5f                   	pop    %edi
  8076bb:	5d                   	pop    %ebp
  8076bc:	c3                   	ret    

008076bd <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8076bd:	55                   	push   %ebp
  8076be:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076c0:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076c4:	66 c1 c0 08          	rol    $0x8,%ax
}
  8076c8:	5d                   	pop    %ebp
  8076c9:	c3                   	ret    

008076ca <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8076ca:	55                   	push   %ebp
  8076cb:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8076cd:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8076d1:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  8076d5:	5d                   	pop    %ebp
  8076d6:	c3                   	ret    

008076d7 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8076d7:	55                   	push   %ebp
  8076d8:	89 e5                	mov    %esp,%ebp
  8076da:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8076dd:	89 d0                	mov    %edx,%eax
  8076df:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  8076e2:	89 d1                	mov    %edx,%ecx
  8076e4:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076e7:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  8076e9:	89 d1                	mov    %edx,%ecx
  8076eb:	c1 e1 08             	shl    $0x8,%ecx
  8076ee:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  8076f4:	09 c8                	or     %ecx,%eax
  8076f6:	c1 ea 08             	shr    $0x8,%edx
  8076f9:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8076ff:	09 d0                	or     %edx,%eax
}
  807701:	5d                   	pop    %ebp
  807702:	c3                   	ret    

00807703 <inet_aton>:
{
  807703:	55                   	push   %ebp
  807704:	89 e5                	mov    %esp,%ebp
  807706:	57                   	push   %edi
  807707:	56                   	push   %esi
  807708:	53                   	push   %ebx
  807709:	83 ec 2c             	sub    $0x2c,%esp
  80770c:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  80770f:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  807712:	8d 75 d8             	lea    -0x28(%ebp),%esi
  807715:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807718:	e9 a7 00 00 00       	jmp    8077c4 <inet_aton+0xc1>
      c = *++cp;
  80771d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807721:	89 d1                	mov    %edx,%ecx
  807723:	83 e1 df             	and    $0xffffffdf,%ecx
  807726:	80 f9 58             	cmp    $0x58,%cl
  807729:	74 10                	je     80773b <inet_aton+0x38>
      c = *++cp;
  80772b:	83 c0 01             	add    $0x1,%eax
  80772e:	0f be d2             	movsbl %dl,%edx
        base = 8;
  807731:	be 08 00 00 00       	mov    $0x8,%esi
  807736:	e9 a3 00 00 00       	jmp    8077de <inet_aton+0xdb>
        c = *++cp;
  80773b:	0f be 50 02          	movsbl 0x2(%eax),%edx
  80773f:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  807742:	be 10 00 00 00       	mov    $0x10,%esi
  807747:	e9 92 00 00 00       	jmp    8077de <inet_aton+0xdb>
      } else if (base == 16 && isxdigit(c)) {
  80774c:	83 fe 10             	cmp    $0x10,%esi
  80774f:	75 4d                	jne    80779e <inet_aton+0x9b>
  807751:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  807754:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  807757:	89 d1                	mov    %edx,%ecx
  807759:	83 e1 df             	and    $0xffffffdf,%ecx
  80775c:	83 e9 41             	sub    $0x41,%ecx
  80775f:	80 f9 05             	cmp    $0x5,%cl
  807762:	77 3a                	ja     80779e <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807764:	c1 e3 04             	shl    $0x4,%ebx
  807767:	83 c2 0a             	add    $0xa,%edx
  80776a:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80776e:	19 c9                	sbb    %ecx,%ecx
  807770:	83 e1 20             	and    $0x20,%ecx
  807773:	83 c1 41             	add    $0x41,%ecx
  807776:	29 ca                	sub    %ecx,%edx
  807778:	09 d3                	or     %edx,%ebx
        c = *++cp;
  80777a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80777d:	0f be 57 01          	movsbl 0x1(%edi),%edx
  807781:	83 c0 01             	add    $0x1,%eax
  807784:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (isdigit(c)) {
  807787:	89 d7                	mov    %edx,%edi
  807789:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80778c:	80 f9 09             	cmp    $0x9,%cl
  80778f:	77 bb                	ja     80774c <inet_aton+0x49>
        val = (val * base) + (int)(c - '0');
  807791:	0f af de             	imul   %esi,%ebx
  807794:	8d 5c 1a d0          	lea    -0x30(%edx,%ebx,1),%ebx
        c = *++cp;
  807798:	0f be 50 01          	movsbl 0x1(%eax),%edx
  80779c:	eb e3                	jmp    807781 <inet_aton+0x7e>
    if (c == '.') {
  80779e:	83 fa 2e             	cmp    $0x2e,%edx
  8077a1:	75 42                	jne    8077e5 <inet_aton+0xe2>
      if (pp >= parts + 3)
  8077a3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8077a6:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8077a9:	39 c6                	cmp    %eax,%esi
  8077ab:	0f 84 0e 01 00 00    	je     8078bf <inet_aton+0x1bc>
      *pp++ = val;
  8077b1:	83 c6 04             	add    $0x4,%esi
  8077b4:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8077b7:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  8077ba:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8077bd:	8d 46 01             	lea    0x1(%esi),%eax
  8077c0:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  8077c4:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8077c7:	80 f9 09             	cmp    $0x9,%cl
  8077ca:	0f 87 e8 00 00 00    	ja     8078b8 <inet_aton+0x1b5>
    base = 10;
  8077d0:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  8077d5:	83 fa 30             	cmp    $0x30,%edx
  8077d8:	0f 84 3f ff ff ff    	je     80771d <inet_aton+0x1a>
    base = 10;
  8077de:	bb 00 00 00 00       	mov    $0x0,%ebx
  8077e3:	eb 9f                	jmp    807784 <inet_aton+0x81>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077e5:	85 d2                	test   %edx,%edx
  8077e7:	74 26                	je     80780f <inet_aton+0x10c>
    return (0);
  8077e9:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8077ee:	89 f9                	mov    %edi,%ecx
  8077f0:	80 f9 1f             	cmp    $0x1f,%cl
  8077f3:	0f 86 cb 00 00 00    	jbe    8078c4 <inet_aton+0x1c1>
  8077f9:	84 d2                	test   %dl,%dl
  8077fb:	0f 88 c3 00 00 00    	js     8078c4 <inet_aton+0x1c1>
  807801:	83 fa 20             	cmp    $0x20,%edx
  807804:	74 09                	je     80780f <inet_aton+0x10c>
  807806:	83 fa 0c             	cmp    $0xc,%edx
  807809:	0f 85 b5 00 00 00    	jne    8078c4 <inet_aton+0x1c1>
  n = pp - parts + 1;
  80780f:	8d 45 d8             	lea    -0x28(%ebp),%eax
  807812:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807815:	29 c6                	sub    %eax,%esi
  807817:	89 f0                	mov    %esi,%eax
  807819:	c1 f8 02             	sar    $0x2,%eax
  80781c:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  80781f:	83 f8 02             	cmp    $0x2,%eax
  807822:	74 5e                	je     807882 <inet_aton+0x17f>
  807824:	7e 35                	jle    80785b <inet_aton+0x158>
  807826:	83 f8 03             	cmp    $0x3,%eax
  807829:	74 6e                	je     807899 <inet_aton+0x196>
  80782b:	83 f8 04             	cmp    $0x4,%eax
  80782e:	75 2f                	jne    80785f <inet_aton+0x15c>
      return (0);
  807830:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  807835:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80783b:	0f 87 83 00 00 00    	ja     8078c4 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807841:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807844:	c1 e0 18             	shl    $0x18,%eax
  807847:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80784a:	c1 e2 10             	shl    $0x10,%edx
  80784d:	09 d0                	or     %edx,%eax
  80784f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807852:	c1 e2 08             	shl    $0x8,%edx
  807855:	09 d0                	or     %edx,%eax
  807857:	09 c3                	or     %eax,%ebx
    break;
  807859:	eb 04                	jmp    80785f <inet_aton+0x15c>
  switch (n) {
  80785b:	85 c0                	test   %eax,%eax
  80785d:	74 65                	je     8078c4 <inet_aton+0x1c1>
  return (1);
  80785f:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  807864:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807868:	74 5a                	je     8078c4 <inet_aton+0x1c1>
    addr->s_addr = htonl(val);
  80786a:	83 ec 0c             	sub    $0xc,%esp
  80786d:	53                   	push   %ebx
  80786e:	e8 64 fe ff ff       	call   8076d7 <htonl>
  807873:	83 c4 10             	add    $0x10,%esp
  807876:	8b 75 0c             	mov    0xc(%ebp),%esi
  807879:	89 06                	mov    %eax,(%esi)
  return (1);
  80787b:	b8 01 00 00 00       	mov    $0x1,%eax
  807880:	eb 42                	jmp    8078c4 <inet_aton+0x1c1>
      return (0);
  807882:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  807887:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  80788d:	77 35                	ja     8078c4 <inet_aton+0x1c1>
    val |= parts[0] << 24;
  80788f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807892:	c1 e0 18             	shl    $0x18,%eax
  807895:	09 c3                	or     %eax,%ebx
    break;
  807897:	eb c6                	jmp    80785f <inet_aton+0x15c>
      return (0);
  807899:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  80789e:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8078a4:	77 1e                	ja     8078c4 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16);
  8078a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8078a9:	c1 e0 18             	shl    $0x18,%eax
  8078ac:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8078af:	c1 e2 10             	shl    $0x10,%edx
  8078b2:	09 d0                	or     %edx,%eax
  8078b4:	09 c3                	or     %eax,%ebx
    break;
  8078b6:	eb a7                	jmp    80785f <inet_aton+0x15c>
      return (0);
  8078b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8078bd:	eb 05                	jmp    8078c4 <inet_aton+0x1c1>
        return (0);
  8078bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8078c4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8078c7:	5b                   	pop    %ebx
  8078c8:	5e                   	pop    %esi
  8078c9:	5f                   	pop    %edi
  8078ca:	5d                   	pop    %ebp
  8078cb:	c3                   	ret    

008078cc <inet_addr>:
{
  8078cc:	55                   	push   %ebp
  8078cd:	89 e5                	mov    %esp,%ebp
  8078cf:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  8078d2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8078d5:	50                   	push   %eax
  8078d6:	ff 75 08             	pushl  0x8(%ebp)
  8078d9:	e8 25 fe ff ff       	call   807703 <inet_aton>
  8078de:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  8078e1:	85 c0                	test   %eax,%eax
  8078e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8078e8:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  8078ec:	c9                   	leave  
  8078ed:	c3                   	ret    

008078ee <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  8078ee:	55                   	push   %ebp
  8078ef:	89 e5                	mov    %esp,%ebp
  8078f1:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  8078f4:	ff 75 08             	pushl  0x8(%ebp)
  8078f7:	e8 db fd ff ff       	call   8076d7 <htonl>
  8078fc:	83 c4 10             	add    $0x10,%esp
}
  8078ff:	c9                   	leave  
  807900:	c3                   	ret    

00807901 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807901:	55                   	push   %ebp
  807902:	89 e5                	mov    %esp,%ebp
  807904:	57                   	push   %edi
  807905:	56                   	push   %esi
  807906:	53                   	push   %ebx
  807907:	83 ec 3c             	sub    $0x3c,%esp
  80790a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80790d:	8b 75 10             	mov    0x10(%ebp),%esi
  807910:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807913:	8b 55 14             	mov    0x14(%ebp),%edx
  807916:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807919:	8b 5d 18             	mov    0x18(%ebp),%ebx
  80791c:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  80791f:	8b 45 20             	mov    0x20(%ebp),%eax
  807922:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807926:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807929:	89 da                	mov    %ebx,%edx
  80792b:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80792e:	66 85 f6             	test   %si,%si
  807931:	74 04                	je     807937 <tcp_enqueue+0x36>
  807933:	84 c0                	test   %al,%al
  807935:	75 54                	jne    80798b <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807937:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80793b:	74 06                	je     807943 <tcp_enqueue+0x42>
  80793d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807941:	75 5f                	jne    8079a2 <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807943:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807947:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  80794b:	72 6c                	jb     8079b9 <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80794d:	8b 4f 68             	mov    0x68(%edi),%ecx
  807950:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807953:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807957:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80795b:	66 83 f9 1f          	cmp    $0x1f,%cx
  80795f:	77 66                	ja     8079c7 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807961:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807966:	74 6d                	je     8079d5 <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807968:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80796c:	75 7b                	jne    8079e9 <tcp_enqueue+0xe8>
  80796e:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807972:	75 75                	jne    8079e9 <tcp_enqueue+0xe8>
  807974:	83 ec 04             	sub    $0x4,%esp
  807977:	68 ac 24 81 00       	push   $0x8124ac
  80797c:	68 ae 00 00 00       	push   $0xae
  807981:	68 c6 25 81 00       	push   $0x8125c6
  807986:	e8 1d 6c 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80798b:	83 ec 04             	sub    $0x4,%esp
  80798e:	68 24 24 81 00       	push   $0x812424
  807993:	68 90 00 00 00       	push   $0x90
  807998:	68 c6 25 81 00       	push   $0x8125c6
  80799d:	e8 06 6c 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8079a2:	83 ec 04             	sub    $0x4,%esp
  8079a5:	68 64 24 81 00       	push   $0x812464
  8079aa:	68 92 00 00 00       	push   $0x92
  8079af:	68 c6 25 81 00       	push   $0x8125c6
  8079b4:	e8 ef 6b 00 00       	call   80e5a8 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  8079b9:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079c2:	e9 a4 03 00 00       	jmp    807d6b <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  8079c7:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8079cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079d0:	e9 96 03 00 00       	jmp    807d6b <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  8079d5:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8079d9:	0f 85 05 02 00 00    	jne    807be4 <tcp_enqueue+0x2e3>
  8079df:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8079e3:	0f 85 fb 01 00 00    	jne    807be4 <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8079e9:	c0 e8 02             	shr    $0x2,%al
  8079ec:	c1 e0 0c             	shl    $0xc,%eax
  8079ef:	66 05 00 50          	add    $0x5000,%ax
  8079f3:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  8079f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8079fa:	89 45 d0             	mov    %eax,-0x30(%ebp)
  8079fd:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807a01:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807a05:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807a0a:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807a0e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807a15:	83 e2 01             	and    $0x1,%edx
  807a18:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a1b:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807a1f:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807a22:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807a26:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807a2a:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807a2f:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807a33:	83 ec 0c             	sub    $0xc,%esp
  807a36:	6a 04                	push   $0x4
  807a38:	e8 03 ca ff ff       	call   804440 <memp_malloc>
  807a3d:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807a3f:	83 c4 10             	add    $0x10,%esp
  807a42:	85 c0                	test   %eax,%eax
  807a44:	0f 84 e6 02 00 00    	je     807d30 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807a4a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807a50:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807a57:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807a5b:	0f 85 b1 01 00 00    	jne    807c12 <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807a61:	85 f6                	test   %esi,%esi
  807a63:	0f 84 92 01 00 00    	je     807bfb <tcp_enqueue+0x2fa>
      useg->next = seg;
  807a69:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807a6b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807a6f:	0f 84 bc 01 00 00    	je     807c31 <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807a75:	83 ec 04             	sub    $0x4,%esp
  807a78:	6a 00                	push   $0x0
  807a7a:	ff 75 cc             	pushl  -0x34(%ebp)
  807a7d:	6a 00                	push   $0x0
  807a7f:	e8 25 ce ff ff       	call   8048a9 <pbuf_alloc>
  807a84:	89 43 04             	mov    %eax,0x4(%ebx)
  807a87:	83 c4 10             	add    $0x10,%esp
  807a8a:	85 c0                	test   %eax,%eax
  807a8c:	0f 84 9e 02 00 00    	je     807d30 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807a92:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807a96:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807a9a:	0f 82 7a 01 00 00    	jb     807c1a <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807aa0:	83 ec 0c             	sub    $0xc,%esp
  807aa3:	50                   	push   %eax
  807aa4:	e8 84 d1 ff ff       	call   804c2d <pbuf_clen>
  807aa9:	0f b6 c0             	movzbl %al,%eax
  807aac:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807ab0:	8b 43 04             	mov    0x4(%ebx),%eax
  807ab3:	8b 40 04             	mov    0x4(%eax),%eax
  807ab6:	89 43 08             	mov    %eax,0x8(%ebx)
  807ab9:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807abc:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807ac1:	0f 87 69 02 00 00    	ja     807d30 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807ac7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807acb:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807acf:	83 ec 08             	sub    $0x8,%esp
  807ad2:	6a 14                	push   $0x14
  807ad4:	ff 73 04             	pushl  0x4(%ebx)
  807ad7:	e8 3a cc ff ff       	call   804716 <pbuf_header>
  807adc:	83 c4 10             	add    $0x10,%esp
  807adf:	84 c0                	test   %al,%al
  807ae1:	0f 85 49 02 00 00    	jne    807d30 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807ae7:	8b 43 04             	mov    0x4(%ebx),%eax
  807aea:	8b 70 04             	mov    0x4(%eax),%esi
  807aed:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807af0:	83 ec 0c             	sub    $0xc,%esp
  807af3:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807af7:	50                   	push   %eax
  807af8:	e8 c0 fb ff ff       	call   8076bd <htons>
  807afd:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807b00:	8b 73 10             	mov    0x10(%ebx),%esi
  807b03:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807b07:	89 04 24             	mov    %eax,(%esp)
  807b0a:	e8 ae fb ff ff       	call   8076bd <htons>
  807b0f:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807b13:	8b 73 10             	mov    0x10(%ebx),%esi
  807b16:	83 c4 04             	add    $0x4,%esp
  807b19:	ff 75 d8             	pushl  -0x28(%ebp)
  807b1c:	e8 b6 fb ff ff       	call   8076d7 <htonl>
  807b21:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807b24:	8b 43 10             	mov    0x10(%ebx),%eax
  807b27:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807b2d:	8b 43 10             	mov    0x10(%ebx),%eax
  807b30:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b34:	89 04 24             	mov    %eax,(%esp)
  807b37:	e8 8e fb ff ff       	call   8076ca <ntohs>
  807b3c:	8b 73 10             	mov    0x10(%ebx),%esi
  807b3f:	83 e0 c0             	and    $0xffffffc0,%eax
  807b42:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807b46:	09 d0                	or     %edx,%eax
  807b48:	0f b7 c0             	movzwl %ax,%eax
  807b4b:	89 04 24             	mov    %eax,(%esp)
  807b4e:	e8 6a fb ff ff       	call   8076bd <htons>
  807b53:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807b57:	83 c4 10             	add    $0x10,%esp
  807b5a:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b5e:	0f 84 0f 02 00 00    	je     807d73 <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807b64:	83 ec 0c             	sub    $0xc,%esp
  807b67:	8b 43 10             	mov    0x10(%ebx),%eax
  807b6a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807b6e:	50                   	push   %eax
  807b6f:	e8 56 fb ff ff       	call   8076ca <ntohs>
  807b74:	8b 73 10             	mov    0x10(%ebx),%esi
  807b77:	83 e0 3f             	and    $0x3f,%eax
  807b7a:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807b7e:	0f b7 c0             	movzwl %ax,%eax
  807b81:	89 04 24             	mov    %eax,(%esp)
  807b84:	e8 34 fb ff ff       	call   8076bd <htons>
  807b89:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807b8d:	83 c4 0c             	add    $0xc,%esp
  807b90:	ff 75 cc             	pushl  -0x34(%ebp)
  807b93:	ff 75 1c             	pushl  0x1c(%ebp)
  807b96:	ff 73 08             	pushl  0x8(%ebx)
  807b99:	e8 4f 74 00 00       	call   80efed <memcpy>
  807b9e:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807ba1:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807ba5:	0f b7 c1             	movzwl %cx,%eax
  807ba8:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807bab:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807bae:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807bb2:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807bb6:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807bba:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807bbc:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807bc0:	0f 85 5c fe ff ff    	jne    807a22 <tcp_enqueue+0x121>
  807bc6:	84 c0                	test   %al,%al
  807bc8:	0f 85 54 fe ff ff    	jne    807a22 <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807bce:	8b 47 74             	mov    0x74(%edi),%eax
  807bd1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807bd4:	85 c0                	test   %eax,%eax
  807bd6:	0f 84 c1 03 00 00    	je     807f9d <tcp_enqueue+0x69c>
  807bdc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807bdf:	e9 be 01 00 00       	jmp    807da2 <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807be4:	83 ec 04             	sub    $0x4,%esp
  807be7:	68 e8 24 81 00       	push   $0x8124e8
  807bec:	68 b1 00 00 00       	push   $0xb1
  807bf1:	68 c6 25 81 00       	push   $0x8125c6
  807bf6:	e8 ad 69 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807bfb:	83 ec 04             	sub    $0x4,%esp
  807bfe:	68 de 25 81 00       	push   $0x8125de
  807c03:	68 ce 00 00 00       	push   $0xce
  807c08:	68 c6 25 81 00       	push   $0x8125c6
  807c0d:	e8 96 69 00 00       	call   80e5a8 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807c12:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807c15:	e9 51 fe ff ff       	jmp    807a6b <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807c1a:	83 ec 04             	sub    $0x4,%esp
  807c1d:	68 1c 25 81 00       	push   $0x81251c
  807c22:	68 df 00 00 00       	push   $0xdf
  807c27:	68 c6 25 81 00       	push   $0x8125c6
  807c2c:	e8 77 69 00 00       	call   80e5a8 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807c31:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807c35:	74 7f                	je     807cb6 <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807c37:	83 ec 04             	sub    $0x4,%esp
  807c3a:	6a 00                	push   $0x0
  807c3c:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807c40:	0f b7 c6             	movzwl %si,%eax
  807c43:	50                   	push   %eax
  807c44:	6a 00                	push   $0x0
  807c46:	e8 5e cc ff ff       	call   8048a9 <pbuf_alloc>
  807c4b:	89 43 04             	mov    %eax,0x4(%ebx)
  807c4e:	83 c4 10             	add    $0x10,%esp
  807c51:	85 c0                	test   %eax,%eax
  807c53:	0f 84 d7 00 00 00    	je     807d30 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807c59:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807c5d:	72 40                	jb     807c9f <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807c5f:	83 ec 0c             	sub    $0xc,%esp
  807c62:	50                   	push   %eax
  807c63:	e8 c5 cf ff ff       	call   804c2d <pbuf_clen>
  807c68:	0f b6 c0             	movzbl %al,%eax
  807c6b:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807c6f:	83 c4 10             	add    $0x10,%esp
  807c72:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807c76:	74 19                	je     807c91 <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807c78:	83 ec 04             	sub    $0x4,%esp
  807c7b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807c7f:	50                   	push   %eax
  807c80:	ff 75 d0             	pushl  -0x30(%ebp)
  807c83:	8b 43 04             	mov    0x4(%ebx),%eax
  807c86:	ff 70 04             	pushl  0x4(%eax)
  807c89:	e8 5f 73 00 00       	call   80efed <memcpy>
  807c8e:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807c91:	8b 43 04             	mov    0x4(%ebx),%eax
  807c94:	8b 40 04             	mov    0x4(%eax),%eax
  807c97:	89 43 08             	mov    %eax,0x8(%ebx)
  807c9a:	e9 1d fe ff ff       	jmp    807abc <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807c9f:	83 ec 04             	sub    $0x4,%esp
  807ca2:	68 44 25 81 00       	push   $0x812544
  807ca7:	68 ea 00 00 00       	push   $0xea
  807cac:	68 c6 25 81 00       	push   $0x8125c6
  807cb1:	e8 f2 68 00 00       	call   80e5a8 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807cb6:	83 ec 04             	sub    $0x4,%esp
  807cb9:	6a 01                	push   $0x1
  807cbb:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807cbf:	50                   	push   %eax
  807cc0:	6a 00                	push   $0x0
  807cc2:	e8 e2 cb ff ff       	call   8048a9 <pbuf_alloc>
  807cc7:	89 c6                	mov    %eax,%esi
  807cc9:	83 c4 10             	add    $0x10,%esp
  807ccc:	85 c0                	test   %eax,%eax
  807cce:	74 60                	je     807d30 <tcp_enqueue+0x42f>
      ++queuelen;
  807cd0:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807cd4:	83 c0 01             	add    $0x1,%eax
  807cd7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807cdb:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807cde:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807ce1:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807ce4:	83 ec 04             	sub    $0x4,%esp
  807ce7:	6a 00                	push   $0x0
  807ce9:	6a 00                	push   $0x0
  807ceb:	6a 00                	push   $0x0
  807ced:	e8 b7 cb ff ff       	call   8048a9 <pbuf_alloc>
  807cf2:	89 43 04             	mov    %eax,0x4(%ebx)
  807cf5:	83 c4 10             	add    $0x10,%esp
  807cf8:	85 c0                	test   %eax,%eax
  807cfa:	74 28                	je     807d24 <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807cfc:	83 ec 0c             	sub    $0xc,%esp
  807cff:	50                   	push   %eax
  807d00:	e8 28 cf ff ff       	call   804c2d <pbuf_clen>
  807d05:	0f b6 c0             	movzbl %al,%eax
  807d08:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807d0c:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807d10:	83 c4 08             	add    $0x8,%esp
  807d13:	56                   	push   %esi
  807d14:	ff 73 04             	pushl  0x4(%ebx)
  807d17:	e8 3a cf ff ff       	call   804c56 <pbuf_cat>
  807d1c:	83 c4 10             	add    $0x10,%esp
  807d1f:	e9 98 fd ff ff       	jmp    807abc <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807d24:	83 ec 0c             	sub    $0xc,%esp
  807d27:	56                   	push   %esi
  807d28:	e8 b6 ca ff ff       	call   8047e3 <pbuf_free>
        goto memerr;
  807d2d:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807d30:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807d34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807d37:	85 c0                	test   %eax,%eax
  807d39:	74 0c                	je     807d47 <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807d3b:	83 ec 0c             	sub    $0xc,%esp
  807d3e:	50                   	push   %eax
  807d3f:	e8 f6 d9 ff ff       	call   80573a <tcp_segs_free>
  807d44:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807d47:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807d4c:	0f 84 37 02 00 00    	je     807f89 <tcp_enqueue+0x688>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807d52:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807d56:	0f 85 37 02 00 00    	jne    807f93 <tcp_enqueue+0x692>
  807d5c:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807d60:	0f 84 02 02 00 00    	je     807f68 <tcp_enqueue+0x667>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807d66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807d6b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807d6e:	5b                   	pop    %ebx
  807d6f:	5e                   	pop    %esi
  807d70:	5f                   	pop    %edi
  807d71:	5d                   	pop    %ebp
  807d72:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807d73:	83 ec 0c             	sub    $0xc,%esp
  807d76:	8b 43 10             	mov    0x10(%ebx),%eax
  807d79:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d7d:	50                   	push   %eax
  807d7e:	e8 47 f9 ff ff       	call   8076ca <ntohs>
  807d83:	8b 73 10             	mov    0x10(%ebx),%esi
  807d86:	83 e0 3f             	and    $0x3f,%eax
  807d89:	80 cc 50             	or     $0x50,%ah
  807d8c:	89 04 24             	mov    %eax,(%esp)
  807d8f:	e8 29 f9 ff ff       	call   8076bd <htons>
  807d94:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807d98:	83 c4 10             	add    $0x10,%esp
  807d9b:	e9 01 fe ff ff       	jmp    807ba1 <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807da0:	89 f0                	mov    %esi,%eax
  807da2:	8b 30                	mov    (%eax),%esi
  807da4:	85 f6                	test   %esi,%esi
  807da6:	75 f8                	jne    807da0 <tcp_enqueue+0x49f>
  807da8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  807dab:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807daf:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807db3:	83 ec 0c             	sub    $0xc,%esp
  807db6:	8b 40 10             	mov    0x10(%eax),%eax
  807db9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dbd:	50                   	push   %eax
  807dbe:	e8 07 f9 ff ff       	call   8076ca <ntohs>
  807dc3:	83 c4 10             	add    $0x10,%esp
  807dc6:	a8 01                	test   $0x1,%al
  807dc8:	0f 84 96 00 00 00    	je     807e64 <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dce:	83 ec 0c             	sub    $0xc,%esp
  807dd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807dd4:	8b 40 10             	mov    0x10(%eax),%eax
  807dd7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ddb:	50                   	push   %eax
  807ddc:	e8 e9 f8 ff ff       	call   8076ca <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807de1:	83 c4 10             	add    $0x10,%esp
  807de4:	a8 03                	test   $0x3,%al
  807de6:	0f 85 a0 00 00 00    	jne    807e8c <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807dec:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807df0:	0f 85 96 00 00 00    	jne    807e8c <tcp_enqueue+0x58b>
    useg->len + queue->len <= pcb->mss) {
  807df6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807df9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807dfd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e00:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807e04:	01 d0                	add    %edx,%eax
  807e06:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807e0a:	39 d0                	cmp    %edx,%eax
  807e0c:	7f 7e                	jg     807e8c <tcp_enqueue+0x58b>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807e0e:	83 ec 08             	sub    $0x8,%esp
  807e11:	6a ec                	push   $0xffffffec
  807e13:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807e16:	ff 70 04             	pushl  0x4(%eax)
  807e19:	e8 f8 c8 ff ff       	call   804716 <pbuf_header>
  807e1e:	83 c4 10             	add    $0x10,%esp
  807e21:	84 c0                	test   %al,%al
  807e23:	0f 85 0b 01 00 00    	jne    807f34 <tcp_enqueue+0x633>
    pbuf_cat(useg->p, queue->p);
  807e29:	83 ec 08             	sub    $0x8,%esp
  807e2c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e2f:	ff 72 04             	pushl  0x4(%edx)
  807e32:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e35:	ff 71 04             	pushl  0x4(%ecx)
  807e38:	e8 19 ce ff ff       	call   804c56 <pbuf_cat>
    useg->len += queue->len;
  807e3d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e40:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807e44:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e47:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807e4b:	8b 02                	mov    (%edx),%eax
  807e4d:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  807e4f:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807e52:	39 da                	cmp    %ebx,%edx
  807e54:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  807e57:	52                   	push   %edx
  807e58:	6a 04                	push   $0x4
  807e5a:	e8 37 c6 ff ff       	call   804496 <memp_free>
  807e5f:	83 c4 10             	add    $0x10,%esp
  807e62:	eb 49                	jmp    807ead <tcp_enqueue+0x5ac>
    TCP_TCPLEN(useg) != 0 &&
  807e64:	83 ec 0c             	sub    $0xc,%esp
  807e67:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e6a:	8b 40 10             	mov    0x10(%eax),%eax
  807e6d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e71:	50                   	push   %eax
  807e72:	e8 53 f8 ff ff       	call   8076ca <ntohs>
  807e77:	66 d1 e8             	shr    %ax
  807e7a:	83 e0 01             	and    $0x1,%eax
  807e7d:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  807e81:	83 c4 10             	add    $0x10,%esp
  807e84:	01 d0                	add    %edx,%eax
  807e86:	0f 85 42 ff ff ff    	jne    807dce <tcp_enqueue+0x4cd>
      useg->next = queue;
  807e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e8f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807e92:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807e94:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807e98:	83 e2 03             	and    $0x3,%edx
    ++len;
  807e9b:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807e9f:	83 c0 01             	add    $0x1,%eax
  807ea2:	84 d2                	test   %dl,%dl
  807ea4:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807ea9:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  807ead:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807eb1:	74 04                	je     807eb7 <tcp_enqueue+0x5b6>
    pcb->flags |= TF_FIN;
  807eb3:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807eb7:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807ebb:	0f b7 c2             	movzwl %dx,%eax
  807ebe:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807ec1:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807ec5:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807ec9:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807ecd:	66 85 c0             	test   %ax,%ax
  807ed0:	74 06                	je     807ed8 <tcp_enqueue+0x5d7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ed2:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807ed6:	74 73                	je     807f4b <tcp_enqueue+0x64a>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ed8:	85 db                	test   %ebx,%ebx
  807eda:	0f 84 9f 00 00 00    	je     807f7f <tcp_enqueue+0x67e>
  807ee0:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807ee5:	0f 84 94 00 00 00    	je     807f7f <tcp_enqueue+0x67e>
  807eeb:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  807eee:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807ef3:	85 d2                	test   %edx,%edx
  807ef5:	0f 84 70 fe ff ff    	je     807d6b <tcp_enqueue+0x46a>
  807efb:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807eff:	0f 85 66 fe ff ff    	jne    807d6b <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807f05:	83 ec 0c             	sub    $0xc,%esp
  807f08:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807f0c:	50                   	push   %eax
  807f0d:	e8 b8 f7 ff ff       	call   8076ca <ntohs>
  807f12:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807f15:	83 c8 08             	or     $0x8,%eax
  807f18:	0f b7 c0             	movzwl %ax,%eax
  807f1b:	89 04 24             	mov    %eax,(%esp)
  807f1e:	e8 9a f7 ff ff       	call   8076bd <htons>
  807f23:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807f27:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  807f2a:	b8 00 00 00 00       	mov    $0x0,%eax
  807f2f:	e9 37 fe ff ff       	jmp    807d6b <tcp_enqueue+0x46a>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807f34:	83 ec 04             	sub    $0x4,%esp
  807f37:	68 eb 25 81 00       	push   $0x8125eb
  807f3c:	68 52 01 00 00       	push   $0x152
  807f41:	68 c6 25 81 00       	push   $0x8125c6
  807f46:	e8 5d 66 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807f4b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f4f:	75 87                	jne    807ed8 <tcp_enqueue+0x5d7>
  807f51:	83 ec 04             	sub    $0x4,%esp
  807f54:	68 78 25 81 00       	push   $0x812578
  807f59:	68 7a 01 00 00       	push   $0x17a
  807f5e:	68 c6 25 81 00       	push   $0x8125c6
  807f63:	e8 40 66 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f68:	83 ec 04             	sub    $0x4,%esp
  807f6b:	68 78 25 81 00       	push   $0x812578
  807f70:	68 8d 01 00 00       	push   $0x18d
  807f75:	68 c6 25 81 00       	push   $0x8125c6
  807f7a:	e8 29 66 00 00       	call   80e5a8 <_panic>
  return ERR_OK;
  807f7f:	b8 00 00 00 00       	mov    $0x0,%eax
  807f84:	e9 e2 fd ff ff       	jmp    807d6b <tcp_enqueue+0x46a>
  return ERR_MEM;
  807f89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f8e:	e9 d8 fd ff ff       	jmp    807d6b <tcp_enqueue+0x46a>
  807f93:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807f98:	e9 ce fd ff ff       	jmp    807d6b <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  807f9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807fa0:	89 47 74             	mov    %eax,0x74(%edi)
  807fa3:	e9 ec fe ff ff       	jmp    807e94 <tcp_enqueue+0x593>

00807fa8 <tcp_send_ctrl>:
{
  807fa8:	55                   	push   %ebp
  807fa9:	89 e5                	mov    %esp,%ebp
  807fab:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  807fae:	6a 00                	push   $0x0
  807fb0:	6a 00                	push   $0x0
  807fb2:	6a 01                	push   $0x1
  807fb4:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  807fb8:	50                   	push   %eax
  807fb9:	6a 00                	push   $0x0
  807fbb:	6a 00                	push   $0x0
  807fbd:	ff 75 08             	pushl  0x8(%ebp)
  807fc0:	e8 3c f9 ff ff       	call   807901 <tcp_enqueue>
}
  807fc5:	c9                   	leave  
  807fc6:	c3                   	ret    

00807fc7 <tcp_write>:
{
  807fc7:	55                   	push   %ebp
  807fc8:	89 e5                	mov    %esp,%ebp
  807fca:	56                   	push   %esi
  807fcb:	53                   	push   %ebx
  807fcc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807fcf:	8b 55 10             	mov    0x10(%ebp),%edx
  807fd2:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  807fd5:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  807fd8:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  807fdb:	83 fb 02             	cmp    $0x2,%ebx
  807fde:	76 05                	jbe    807fe5 <tcp_write+0x1e>
  807fe0:	83 f8 07             	cmp    $0x7,%eax
  807fe3:	75 32                	jne    808017 <tcp_write+0x50>
    return ERR_OK;
  807fe5:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  807fea:	66 85 d2             	test   %dx,%dx
  807fed:	75 07                	jne    807ff6 <tcp_write+0x2f>
}
  807fef:	8d 65 f8             	lea    -0x8(%ebp),%esp
  807ff2:	5b                   	pop    %ebx
  807ff3:	5e                   	pop    %esi
  807ff4:	5d                   	pop    %ebp
  807ff5:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  807ff6:	83 ec 04             	sub    $0x4,%esp
  807ff9:	6a 00                	push   $0x0
  807ffb:	6a 00                	push   $0x0
  807ffd:	89 f0                	mov    %esi,%eax
  807fff:	0f b6 f0             	movzbl %al,%esi
  808002:	56                   	push   %esi
  808003:	6a 00                	push   $0x0
  808005:	0f b7 d2             	movzwl %dx,%edx
  808008:	52                   	push   %edx
  808009:	ff 75 0c             	pushl  0xc(%ebp)
  80800c:	51                   	push   %ecx
  80800d:	e8 ef f8 ff ff       	call   807901 <tcp_enqueue>
  808012:	83 c4 20             	add    $0x20,%esp
  808015:	eb d8                	jmp    807fef <tcp_write+0x28>
    return ERR_CONN;
  808017:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80801c:	eb d1                	jmp    807fef <tcp_write+0x28>

0080801e <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80801e:	55                   	push   %ebp
  80801f:	89 e5                	mov    %esp,%ebp
  808021:	57                   	push   %edi
  808022:	56                   	push   %esi
  808023:	53                   	push   %ebx
  808024:	83 ec 1c             	sub    $0x1c,%esp
  808027:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80802a:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  808030:	0f 84 60 04 00 00    	je     808496 <tcp_output+0x478>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808036:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80803a:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80803e:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808043:	0f b7 c0             	movzwl %ax,%eax
  808046:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  808049:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80804c:	8b 47 78             	mov    0x78(%edi),%eax
  80804f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  808052:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  808055:	85 c0                	test   %eax,%eax
  808057:	75 04                	jne    80805d <tcp_output+0x3f>
  808059:	eb 0b                	jmp    808066 <tcp_output+0x48>
    for (; useg->next != NULL; useg = useg->next);
  80805b:	89 c2                	mov    %eax,%edx
  80805d:	8b 02                	mov    (%edx),%eax
  80805f:	85 c0                	test   %eax,%eax
  808061:	75 f8                	jne    80805b <tcp_output+0x3d>
  808063:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808066:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80806a:	0f 84 e6 03 00 00    	je     808456 <tcp_output+0x438>
  808070:	85 db                	test   %ebx,%ebx
  808072:	74 23                	je     808097 <tcp_output+0x79>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808074:	83 ec 0c             	sub    $0xc,%esp
  808077:	8b 43 10             	mov    0x10(%ebx),%eax
  80807a:	ff 70 04             	pushl  0x4(%eax)
  80807d:	e8 6c f8 ff ff       	call   8078ee <ntohl>
  808082:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808086:	2b 57 48             	sub    0x48(%edi),%edx
  808089:	01 c2                	add    %eax,%edx
     (seg == NULL ||
  80808b:	83 c4 10             	add    $0x10,%esp
  80808e:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  808091:	0f 86 bf 03 00 00    	jbe    808456 <tcp_output+0x438>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808097:	83 ec 04             	sub    $0x4,%esp
  80809a:	6a 00                	push   $0x0
  80809c:	6a 14                	push   $0x14
  80809e:	6a 01                	push   $0x1
  8080a0:	e8 04 c8 ff ff       	call   8048a9 <pbuf_alloc>
  8080a5:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8080a7:	83 c4 10             	add    $0x10,%esp
  8080aa:	85 c0                	test   %eax,%eax
  8080ac:	0f 84 eb 03 00 00    	je     80849d <tcp_output+0x47f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8080b2:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  8080b6:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8080b9:	83 ec 0c             	sub    $0xc,%esp
  8080bc:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8080c0:	50                   	push   %eax
  8080c1:	e8 f7 f5 ff ff       	call   8076bd <htons>
  8080c6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8080c9:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8080cd:	89 04 24             	mov    %eax,(%esp)
  8080d0:	e8 e8 f5 ff ff       	call   8076bd <htons>
  8080d5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8080d9:	83 c4 04             	add    $0x4,%esp
  8080dc:	ff 77 54             	pushl  0x54(%edi)
  8080df:	e8 f3 f5 ff ff       	call   8076d7 <htonl>
  8080e4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8080e7:	83 c4 04             	add    $0x4,%esp
  8080ea:	ff 77 24             	pushl  0x24(%edi)
  8080ed:	e8 e5 f5 ff ff       	call   8076d7 <htonl>
  8080f2:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  8080f5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8080f9:	89 04 24             	mov    %eax,(%esp)
  8080fc:	e8 c9 f5 ff ff       	call   8076ca <ntohs>
  808101:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808106:	83 c8 10             	or     $0x10,%eax
  808109:	89 04 24             	mov    %eax,(%esp)
  80810c:	e8 ac f5 ff ff       	call   8076bd <htons>
  808111:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808115:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808119:	89 04 24             	mov    %eax,(%esp)
  80811c:	e8 9c f5 ff ff       	call   8076bd <htons>
  808121:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808125:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80812b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80812f:	89 04 24             	mov    %eax,(%esp)
  808132:	e8 93 f5 ff ff       	call   8076ca <ntohs>
  808137:	83 e0 3f             	and    $0x3f,%eax
  80813a:	80 cc 50             	or     $0x50,%ah
  80813d:	89 04 24             	mov    %eax,(%esp)
  808140:	e8 78 f5 ff ff       	call   8076bd <htons>
  808145:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  808149:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80814f:	8d 47 04             	lea    0x4(%edi),%eax
  808152:	89 c1                	mov    %eax,%ecx
  808154:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808158:	89 04 24             	mov    %eax,(%esp)
  80815b:	6a 06                	push   $0x6
  80815d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808160:	51                   	push   %ecx
  808161:	57                   	push   %edi
  808162:	56                   	push   %esi
  808163:	e8 31 f2 ff ff       	call   807399 <inet_chksum_pseudo>
  808168:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80816c:	83 c4 18             	add    $0x18,%esp
  80816f:	6a 06                	push   $0x6
  808171:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808175:	50                   	push   %eax
  808176:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80817a:	50                   	push   %eax
  80817b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80817e:	57                   	push   %edi
  80817f:	56                   	push   %esi
  808180:	e8 28 e8 ff ff       	call   8069ad <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808185:	83 c4 14             	add    $0x14,%esp
  808188:	56                   	push   %esi
  808189:	e8 55 c6 ff ff       	call   8047e3 <pbuf_free>

    return ERR_OK;
  80818e:	83 c4 10             	add    $0x10,%esp
  808191:	b8 00 00 00 00       	mov    $0x0,%eax
  808196:	e9 1b 03 00 00       	jmp    8084b6 <tcp_output+0x498>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80819b:	83 ec 04             	sub    $0x4,%esp
  80819e:	68 ff 25 81 00       	push   $0x8125ff
  8081a3:	68 05 02 00 00       	push   $0x205
  8081a8:	68 c6 25 81 00       	push   $0x8125c6
  8081ad:	e8 f6 63 00 00       	call   80e5a8 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8081b2:	83 ec 0c             	sub    $0xc,%esp
  8081b5:	8b 43 10             	mov    0x10(%ebx),%eax
  8081b8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8081bc:	50                   	push   %eax
  8081bd:	e8 08 f5 ff ff       	call   8076ca <ntohs>
  8081c2:	8b 73 10             	mov    0x10(%ebx),%esi
  8081c5:	83 c8 10             	or     $0x10,%eax
  8081c8:	0f b7 c0             	movzwl %ax,%eax
  8081cb:	89 04 24             	mov    %eax,(%esp)
  8081ce:	e8 ea f4 ff ff       	call   8076bd <htons>
  8081d3:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8081d7:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8081db:	83 c4 10             	add    $0x10,%esp
  8081de:	e9 06 01 00 00       	jmp    8082e9 <tcp_output+0x2cb>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8081e3:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8081e9:	e9 49 01 00 00       	jmp    808337 <tcp_output+0x319>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8081ee:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  8081f3:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8081f6:	83 ec 0c             	sub    $0xc,%esp
  8081f9:	8b 43 10             	mov    0x10(%ebx),%eax
  8081fc:	ff 70 04             	pushl  0x4(%eax)
  8081ff:	e8 ea f6 ff ff       	call   8078ee <ntohl>
  808204:	89 47 3c             	mov    %eax,0x3c(%edi)
  808207:	83 c4 10             	add    $0x10,%esp
  80820a:	e9 32 01 00 00       	jmp    808341 <tcp_output+0x323>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80820f:	83 ec 0c             	sub    $0xc,%esp
  808212:	8b 43 10             	mov    0x10(%ebx),%eax
  808215:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808219:	50                   	push   %eax
  80821a:	e8 ab f4 ff ff       	call   8076ca <ntohs>
  80821f:	66 d1 e8             	shr    %ax
  808222:	89 c2                	mov    %eax,%edx
  808224:	83 e2 01             	and    $0x1,%edx
  808227:	83 c4 10             	add    $0x10,%esp
  80822a:	e9 a5 01 00 00       	jmp    8083d4 <tcp_output+0x3b6>
      pcb->snd_max = pcb->snd_nxt;
  80822f:	89 77 58             	mov    %esi,0x58(%edi)
  808232:	e9 ae 01 00 00       	jmp    8083e5 <tcp_output+0x3c7>
    if (TCP_TCPLEN(seg) > 0) {
  808237:	83 ec 0c             	sub    $0xc,%esp
  80823a:	8b 43 10             	mov    0x10(%ebx),%eax
  80823d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808241:	50                   	push   %eax
  808242:	e8 83 f4 ff ff       	call   8076ca <ntohs>
  808247:	66 d1 e8             	shr    %ax
  80824a:	83 e0 01             	and    $0x1,%eax
  80824d:	0f b7 f6             	movzwl %si,%esi
  808250:	83 c4 10             	add    $0x10,%esp
  808253:	01 f0                	add    %esi,%eax
  808255:	0f 85 a9 01 00 00    	jne    808404 <tcp_output+0x3e6>
      tcp_seg_free(seg);
  80825b:	83 ec 0c             	sub    $0xc,%esp
  80825e:	53                   	push   %ebx
  80825f:	e8 99 d4 ff ff       	call   8056fd <tcp_seg_free>
  808264:	83 c4 10             	add    $0x10,%esp
  808267:	eb 06                	jmp    80826f <tcp_output+0x251>
        pcb->unacked = seg;
  808269:	89 5f 78             	mov    %ebx,0x78(%edi)
  80826c:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  80826f:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808272:	85 db                	test   %ebx,%ebx
  808274:	0f 84 33 02 00 00    	je     8084ad <tcp_output+0x48f>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80827a:	83 ec 0c             	sub    $0xc,%esp
  80827d:	8b 43 10             	mov    0x10(%ebx),%eax
  808280:	ff 70 04             	pushl  0x4(%eax)
  808283:	e8 66 f6 ff ff       	call   8078ee <ntohl>
  808288:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80828c:	2b 57 48             	sub    0x48(%edi),%edx
  80828f:	01 c2                	add    %eax,%edx
  while (seg != NULL &&
  808291:	83 c4 10             	add    $0x10,%esp
  808294:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  808297:	0f 87 07 02 00 00    	ja     8084a4 <tcp_output+0x486>
    LWIP_ASSERT("RST not expected here!", 
  80829d:	83 ec 0c             	sub    $0xc,%esp
  8082a0:	8b 43 10             	mov    0x10(%ebx),%eax
  8082a3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082a7:	50                   	push   %eax
  8082a8:	e8 1d f4 ff ff       	call   8076ca <ntohs>
  8082ad:	83 c4 10             	add    $0x10,%esp
  8082b0:	a8 04                	test   $0x4,%al
  8082b2:	0f 85 e3 fe ff ff    	jne    80819b <tcp_output+0x17d>
    if((tcp_do_output_nagle(pcb) == 0) &&
  8082b8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8082bc:	74 1c                	je     8082da <tcp_output+0x2bc>
  8082be:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8082c2:	a8 40                	test   $0x40,%al
  8082c4:	75 14                	jne    8082da <tcp_output+0x2bc>
  8082c6:	8b 57 74             	mov    0x74(%edi),%edx
  8082c9:	85 d2                	test   %edx,%edx
  8082cb:	74 05                	je     8082d2 <tcp_output+0x2b4>
  8082cd:	83 3a 00             	cmpl   $0x0,(%edx)
  8082d0:	75 08                	jne    8082da <tcp_output+0x2bc>
  8082d2:	a8 a0                	test   $0xa0,%al
  8082d4:	0f 84 ca 01 00 00    	je     8084a4 <tcp_output+0x486>
    pcb->unsent = seg->next;
  8082da:	8b 03                	mov    (%ebx),%eax
  8082dc:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8082df:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8082e3:	0f 85 c9 fe ff ff    	jne    8081b2 <tcp_output+0x194>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8082e9:	8b 73 10             	mov    0x10(%ebx),%esi
  8082ec:	83 ec 0c             	sub    $0xc,%esp
  8082ef:	ff 77 24             	pushl  0x24(%edi)
  8082f2:	e8 e0 f3 ff ff       	call   8076d7 <htonl>
  8082f7:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8082fa:	8b 73 10             	mov    0x10(%ebx),%esi
  8082fd:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808301:	89 04 24             	mov    %eax,(%esp)
  808304:	e8 b4 f3 ff ff       	call   8076bd <htons>
  808309:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  80830d:	83 c4 10             	add    $0x10,%esp
  808310:	83 3f 00             	cmpl   $0x0,(%edi)
  808313:	75 17                	jne    80832c <tcp_output+0x30e>
    netif = ip_route(&(pcb->remote_ip));
  808315:	83 ec 0c             	sub    $0xc,%esp
  808318:	ff 75 e4             	pushl  -0x1c(%ebp)
  80831b:	e8 7d e1 ff ff       	call   80649d <ip_route>
    if (netif == NULL) {
  808320:	83 c4 10             	add    $0x10,%esp
  808323:	85 c0                	test   %eax,%eax
  808325:	74 79                	je     8083a0 <tcp_output+0x382>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808327:	8b 40 04             	mov    0x4(%eax),%eax
  80832a:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  80832c:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808331:	0f 84 ac fe ff ff    	je     8081e3 <tcp_output+0x1c5>
  if (pcb->rttest == 0) {
  808337:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80833b:	0f 84 ad fe ff ff    	je     8081ee <tcp_output+0x1d0>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808341:	8b 53 04             	mov    0x4(%ebx),%edx
  808344:	8b 43 10             	mov    0x10(%ebx),%eax
  808347:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80834a:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80834e:	8b 53 04             	mov    0x4(%ebx),%edx
  808351:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808355:	8b 53 04             	mov    0x4(%ebx),%edx
  808358:	8b 43 10             	mov    0x10(%ebx),%eax
  80835b:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80835e:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808364:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808367:	8b 73 10             	mov    0x10(%ebx),%esi
  80836a:	83 ec 0c             	sub    $0xc,%esp
  80836d:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808371:	52                   	push   %edx
  808372:	6a 06                	push   $0x6
  808374:	ff 75 e4             	pushl  -0x1c(%ebp)
  808377:	57                   	push   %edi
  808378:	50                   	push   %eax
  808379:	e8 1b f0 ff ff       	call   807399 <inet_chksum_pseudo>
  80837e:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808382:	83 c4 18             	add    $0x18,%esp
  808385:	6a 06                	push   $0x6
  808387:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80838b:	50                   	push   %eax
  80838c:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808390:	50                   	push   %eax
  808391:	ff 75 e4             	pushl  -0x1c(%ebp)
  808394:	57                   	push   %edi
  808395:	ff 73 04             	pushl  0x4(%ebx)
  808398:	e8 10 e6 ff ff       	call   8069ad <ip_output>
  80839d:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8083a0:	83 ec 0c             	sub    $0xc,%esp
  8083a3:	8b 43 10             	mov    0x10(%ebx),%eax
  8083a6:	ff 70 04             	pushl  0x4(%eax)
  8083a9:	e8 40 f5 ff ff       	call   8078ee <ntohl>
  8083ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8083b1:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8083b5:	8b 43 10             	mov    0x10(%ebx),%eax
  8083b8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083bc:	89 04 24             	mov    %eax,(%esp)
  8083bf:	e8 06 f3 ff ff       	call   8076ca <ntohs>
  8083c4:	83 c4 10             	add    $0x10,%esp
  8083c7:	ba 01 00 00 00       	mov    $0x1,%edx
  8083cc:	a8 01                	test   $0x1,%al
  8083ce:	0f 84 3b fe ff ff    	je     80820f <tcp_output+0x1f1>
  8083d4:	01 d6                	add    %edx,%esi
  8083d6:	03 75 e0             	add    -0x20(%ebp),%esi
  8083d9:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8083dc:	39 77 58             	cmp    %esi,0x58(%edi)
  8083df:	0f 88 4a fe ff ff    	js     80822f <tcp_output+0x211>
    if (TCP_TCPLEN(seg) > 0) {
  8083e5:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8083e9:	83 ec 0c             	sub    $0xc,%esp
  8083ec:	8b 43 10             	mov    0x10(%ebx),%eax
  8083ef:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083f3:	50                   	push   %eax
  8083f4:	e8 d1 f2 ff ff       	call   8076ca <ntohs>
  8083f9:	83 c4 10             	add    $0x10,%esp
  8083fc:	a8 01                	test   $0x1,%al
  8083fe:	0f 84 33 fe ff ff    	je     808237 <tcp_output+0x219>
      seg->next = NULL;
  808404:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  80840a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80840e:	0f 84 55 fe ff ff    	je     808269 <tcp_output+0x24b>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808414:	83 ec 0c             	sub    $0xc,%esp
  808417:	8b 43 10             	mov    0x10(%ebx),%eax
  80841a:	ff 70 04             	pushl  0x4(%eax)
  80841d:	e8 cc f4 ff ff       	call   8078ee <ntohl>
  808422:	89 c6                	mov    %eax,%esi
  808424:	83 c4 04             	add    $0x4,%esp
  808427:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80842a:	8b 40 10             	mov    0x10(%eax),%eax
  80842d:	ff 70 04             	pushl  0x4(%eax)
  808430:	e8 b9 f4 ff ff       	call   8078ee <ntohl>
  808435:	83 c4 10             	add    $0x10,%esp
  808438:	39 c6                	cmp    %eax,%esi
  80843a:	78 0d                	js     808449 <tcp_output+0x42b>
          useg->next = seg;
  80843c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80843f:	89 18                	mov    %ebx,(%eax)
  808441:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808444:	e9 26 fe ff ff       	jmp    80826f <tcp_output+0x251>
          seg->next = pcb->unacked;
  808449:	8b 47 78             	mov    0x78(%edi),%eax
  80844c:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80844e:	89 5f 78             	mov    %ebx,0x78(%edi)
  808451:	e9 19 fe ff ff       	jmp    80826f <tcp_output+0x251>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808456:	8d 47 04             	lea    0x4(%edi),%eax
  808459:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80845c:	e9 11 fe ff ff       	jmp    808272 <tcp_output+0x254>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808461:	83 ec 0c             	sub    $0xc,%esp
  808464:	8b 43 10             	mov    0x10(%ebx),%eax
  808467:	ff 70 04             	pushl  0x4(%eax)
  80846a:	e8 7f f4 ff ff       	call   8078ee <ntohl>
  80846f:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808473:	2b 57 48             	sub    0x48(%edi),%edx
  808476:	01 c2                	add    %eax,%edx
  808478:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80847c:	83 c4 10             	add    $0x10,%esp
  80847f:	39 c2                	cmp    %eax,%edx
  808481:	76 2a                	jbe    8084ad <tcp_output+0x48f>
    pcb->persist_cnt = 0;
  808483:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80848a:	00 00 00 
    pcb->persist_backoff = 1;
  80848d:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  808494:	eb 17                	jmp    8084ad <tcp_output+0x48f>
    return ERR_OK;
  808496:	b8 00 00 00 00       	mov    $0x0,%eax
  80849b:	eb 19                	jmp    8084b6 <tcp_output+0x498>
      return ERR_BUF;
  80849d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8084a2:	eb 12                	jmp    8084b6 <tcp_output+0x498>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  8084a4:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8084ab:	74 b4                	je     808461 <tcp_output+0x443>
  pcb->flags &= ~TF_NAGLEMEMERR;
  8084ad:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8084b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8084b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8084b9:	5b                   	pop    %ebx
  8084ba:	5e                   	pop    %esi
  8084bb:	5f                   	pop    %edi
  8084bc:	5d                   	pop    %ebp
  8084bd:	c3                   	ret    

008084be <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8084be:	55                   	push   %ebp
  8084bf:	89 e5                	mov    %esp,%ebp
  8084c1:	57                   	push   %edi
  8084c2:	56                   	push   %esi
  8084c3:	53                   	push   %ebx
  8084c4:	83 ec 20             	sub    $0x20,%esp
  8084c7:	8b 7d 18             	mov    0x18(%ebp),%edi
  8084ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8084cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8084d0:	6a 00                	push   $0x0
  8084d2:	6a 14                	push   $0x14
  8084d4:	6a 01                	push   $0x1
  8084d6:	e8 ce c3 ff ff       	call   8048a9 <pbuf_alloc>
  if (p == NULL) {
  8084db:	83 c4 10             	add    $0x10,%esp
  8084de:	85 c0                	test   %eax,%eax
  8084e0:	0f 84 e2 00 00 00    	je     8085c8 <tcp_rst+0x10a>
  8084e6:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8084e8:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8084ed:	0f 86 dd 00 00 00    	jbe    8085d0 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8084f3:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  8084f6:	83 ec 0c             	sub    $0xc,%esp
  8084f9:	0f b7 ff             	movzwl %di,%edi
  8084fc:	57                   	push   %edi
  8084fd:	e8 bb f1 ff ff       	call   8076bd <htons>
  808502:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808505:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808509:	89 04 24             	mov    %eax,(%esp)
  80850c:	e8 ac f1 ff ff       	call   8076bd <htons>
  808511:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808515:	83 c4 04             	add    $0x4,%esp
  808518:	ff 75 08             	pushl  0x8(%ebp)
  80851b:	e8 b7 f1 ff ff       	call   8076d7 <htonl>
  808520:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808523:	83 c4 04             	add    $0x4,%esp
  808526:	ff 75 0c             	pushl  0xc(%ebp)
  808529:	e8 a9 f1 ff ff       	call   8076d7 <htonl>
  80852e:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808531:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808535:	89 04 24             	mov    %eax,(%esp)
  808538:	e8 8d f1 ff ff       	call   8076ca <ntohs>
  80853d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808542:	83 c8 14             	or     $0x14,%eax
  808545:	89 04 24             	mov    %eax,(%esp)
  808548:	e8 70 f1 ff ff       	call   8076bd <htons>
  80854d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808551:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808558:	e8 60 f1 ff ff       	call   8076bd <htons>
  80855d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808561:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808567:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80856b:	89 04 24             	mov    %eax,(%esp)
  80856e:	e8 57 f1 ff ff       	call   8076ca <ntohs>
  808573:	83 e0 3f             	and    $0x3f,%eax
  808576:	80 cc 50             	or     $0x50,%ah
  808579:	89 04 24             	mov    %eax,(%esp)
  80857c:	e8 3c f1 ff ff       	call   8076bd <htons>
  808581:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808585:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80858b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80858f:	89 04 24             	mov    %eax,(%esp)
  808592:	6a 06                	push   $0x6
  808594:	ff 75 14             	pushl  0x14(%ebp)
  808597:	ff 75 10             	pushl  0x10(%ebp)
  80859a:	56                   	push   %esi
  80859b:	e8 f9 ed ff ff       	call   807399 <inet_chksum_pseudo>
  8085a0:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8085a4:	83 c4 18             	add    $0x18,%esp
  8085a7:	6a 06                	push   $0x6
  8085a9:	6a 00                	push   $0x0
  8085ab:	68 ff 00 00 00       	push   $0xff
  8085b0:	ff 75 14             	pushl  0x14(%ebp)
  8085b3:	ff 75 10             	pushl  0x10(%ebp)
  8085b6:	56                   	push   %esi
  8085b7:	e8 f1 e3 ff ff       	call   8069ad <ip_output>
  pbuf_free(p);
  8085bc:	83 c4 14             	add    $0x14,%esp
  8085bf:	56                   	push   %esi
  8085c0:	e8 1e c2 ff ff       	call   8047e3 <pbuf_free>
  8085c5:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8085c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8085cb:	5b                   	pop    %ebx
  8085cc:	5e                   	pop    %esi
  8085cd:	5f                   	pop    %edi
  8085ce:	5d                   	pop    %ebp
  8085cf:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8085d0:	83 ec 04             	sub    $0x4,%esp
  8085d3:	68 98 25 81 00       	push   $0x812598
  8085d8:	68 be 02 00 00       	push   $0x2be
  8085dd:	68 c6 25 81 00       	push   $0x8125c6
  8085e2:	e8 c1 5f 00 00       	call   80e5a8 <_panic>

008085e7 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8085e7:	55                   	push   %ebp
  8085e8:	89 e5                	mov    %esp,%ebp
  8085ea:	53                   	push   %ebx
  8085eb:	83 ec 04             	sub    $0x4,%esp
  8085ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8085f1:	8b 53 78             	mov    0x78(%ebx),%edx
  8085f4:	85 d2                	test   %edx,%edx
  8085f6:	75 04                	jne    8085fc <tcp_rexmit_rto+0x15>
  8085f8:	eb 41                	jmp    80863b <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8085fa:	89 c2                	mov    %eax,%edx
  8085fc:	8b 02                	mov    (%edx),%eax
  8085fe:	85 c0                	test   %eax,%eax
  808600:	75 f8                	jne    8085fa <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808602:	8b 43 74             	mov    0x74(%ebx),%eax
  808605:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808607:	8b 43 78             	mov    0x78(%ebx),%eax
  80860a:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80860d:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808614:	83 ec 0c             	sub    $0xc,%esp
  808617:	8b 40 10             	mov    0x10(%eax),%eax
  80861a:	ff 70 04             	pushl  0x4(%eax)
  80861d:	e8 cc f2 ff ff       	call   8078ee <ntohl>
  808622:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808625:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808629:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808630:	89 1c 24             	mov    %ebx,(%esp)
  808633:	e8 e6 f9 ff ff       	call   80801e <tcp_output>
  808638:	83 c4 10             	add    $0x10,%esp
}
  80863b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80863e:	c9                   	leave  
  80863f:	c3                   	ret    

00808640 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808640:	55                   	push   %ebp
  808641:	89 e5                	mov    %esp,%ebp
  808643:	53                   	push   %ebx
  808644:	83 ec 04             	sub    $0x4,%esp
  808647:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80864a:	8b 43 78             	mov    0x78(%ebx),%eax
  80864d:	85 c0                	test   %eax,%eax
  80864f:	74 37                	je     808688 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808651:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808653:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808656:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808658:	8b 43 78             	mov    0x78(%ebx),%eax
  80865b:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80865e:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808661:	83 ec 0c             	sub    $0xc,%esp
  808664:	8b 40 10             	mov    0x10(%eax),%eax
  808667:	ff 70 04             	pushl  0x4(%eax)
  80866a:	e8 7f f2 ff ff       	call   8078ee <ntohl>
  80866f:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808672:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808676:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80867d:	89 1c 24             	mov    %ebx,(%esp)
  808680:	e8 99 f9 ff ff       	call   80801e <tcp_output>
  808685:	83 c4 10             	add    $0x10,%esp
}
  808688:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80868b:	c9                   	leave  
  80868c:	c3                   	ret    

0080868d <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80868d:	55                   	push   %ebp
  80868e:	89 e5                	mov    %esp,%ebp
  808690:	57                   	push   %edi
  808691:	56                   	push   %esi
  808692:	53                   	push   %ebx
  808693:	83 ec 20             	sub    $0x20,%esp
  808696:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808699:	6a 00                	push   $0x0
  80869b:	6a 14                	push   $0x14
  80869d:	6a 01                	push   $0x1
  80869f:	e8 05 c2 ff ff       	call   8048a9 <pbuf_alloc>
   
  if(p == NULL) {
  8086a4:	83 c4 10             	add    $0x10,%esp
  8086a7:	85 c0                	test   %eax,%eax
  8086a9:	0f 84 e5 00 00 00    	je     808794 <tcp_keepalive+0x107>
  8086af:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086b1:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086b6:	0f 86 e0 00 00 00    	jbe    80879c <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8086bc:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8086bf:	83 ec 0c             	sub    $0xc,%esp
  8086c2:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8086c6:	50                   	push   %eax
  8086c7:	e8 f1 ef ff ff       	call   8076bd <htons>
  8086cc:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8086cf:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8086d3:	89 04 24             	mov    %eax,(%esp)
  8086d6:	e8 e2 ef ff ff       	call   8076bd <htons>
  8086db:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8086df:	8b 46 54             	mov    0x54(%esi),%eax
  8086e2:	83 e8 01             	sub    $0x1,%eax
  8086e5:	89 04 24             	mov    %eax,(%esp)
  8086e8:	e8 ea ef ff ff       	call   8076d7 <htonl>
  8086ed:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8086f0:	83 c4 04             	add    $0x4,%esp
  8086f3:	ff 76 24             	pushl  0x24(%esi)
  8086f6:	e8 dc ef ff ff       	call   8076d7 <htonl>
  8086fb:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8086fe:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808702:	89 04 24             	mov    %eax,(%esp)
  808705:	e8 c0 ef ff ff       	call   8076ca <ntohs>
  80870a:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80870f:	89 04 24             	mov    %eax,(%esp)
  808712:	e8 a6 ef ff ff       	call   8076bd <htons>
  808717:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80871b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80871f:	89 04 24             	mov    %eax,(%esp)
  808722:	e8 96 ef ff ff       	call   8076bd <htons>
  808727:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80872b:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808731:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808735:	89 04 24             	mov    %eax,(%esp)
  808738:	e8 8d ef ff ff       	call   8076ca <ntohs>
  80873d:	83 e0 3f             	and    $0x3f,%eax
  808740:	80 cc 50             	or     $0x50,%ah
  808743:	89 04 24             	mov    %eax,(%esp)
  808746:	e8 72 ef ff ff       	call   8076bd <htons>
  80874b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80874f:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808755:	8d 46 04             	lea    0x4(%esi),%eax
  808758:	89 c2                	mov    %eax,%edx
  80875a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80875e:	89 04 24             	mov    %eax,(%esp)
  808761:	6a 06                	push   $0x6
  808763:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808766:	52                   	push   %edx
  808767:	56                   	push   %esi
  808768:	57                   	push   %edi
  808769:	e8 2b ec ff ff       	call   807399 <inet_chksum_pseudo>
  80876e:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808772:	83 c4 18             	add    $0x18,%esp
  808775:	6a 06                	push   $0x6
  808777:	6a 00                	push   $0x0
  808779:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80877d:	50                   	push   %eax
  80877e:	ff 75 e4             	pushl  -0x1c(%ebp)
  808781:	56                   	push   %esi
  808782:	57                   	push   %edi
  808783:	e8 25 e2 ff ff       	call   8069ad <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808788:	83 c4 14             	add    $0x14,%esp
  80878b:	57                   	push   %edi
  80878c:	e8 52 c0 ff ff       	call   8047e3 <pbuf_free>
  808791:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808794:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808797:	5b                   	pop    %ebx
  808798:	5e                   	pop    %esi
  808799:	5f                   	pop    %edi
  80879a:	5d                   	pop    %ebp
  80879b:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80879c:	83 ec 04             	sub    $0x4,%esp
  80879f:	68 98 25 81 00       	push   $0x812598
  8087a4:	68 3a 03 00 00       	push   $0x33a
  8087a9:	68 c6 25 81 00       	push   $0x8125c6
  8087ae:	e8 f5 5d 00 00       	call   80e5a8 <_panic>

008087b3 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8087b3:	55                   	push   %ebp
  8087b4:	89 e5                	mov    %esp,%ebp
  8087b6:	57                   	push   %edi
  8087b7:	56                   	push   %esi
  8087b8:	53                   	push   %ebx
  8087b9:	83 ec 1c             	sub    $0x1c,%esp
  8087bc:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8087bf:	8b 46 78             	mov    0x78(%esi),%eax
  8087c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8087c5:	85 c0                	test   %eax,%eax
  8087c7:	0f 84 10 01 00 00    	je     8088dd <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8087cd:	83 ec 04             	sub    $0x4,%esp
  8087d0:	6a 00                	push   $0x0
  8087d2:	6a 15                	push   $0x15
  8087d4:	6a 01                	push   $0x1
  8087d6:	e8 ce c0 ff ff       	call   8048a9 <pbuf_alloc>
  8087db:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8087dd:	83 c4 10             	add    $0x10,%esp
  8087e0:	85 c0                	test   %eax,%eax
  8087e2:	0f 84 ed 00 00 00    	je     8088d5 <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087e8:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8087ed:	0f 86 f9 00 00 00    	jbe    8088ec <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8087f3:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8087f6:	83 ec 0c             	sub    $0xc,%esp
  8087f9:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8087fd:	50                   	push   %eax
  8087fe:	e8 ba ee ff ff       	call   8076bd <htons>
  808803:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808806:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80880a:	89 04 24             	mov    %eax,(%esp)
  80880d:	e8 ab ee ff ff       	call   8076bd <htons>
  808812:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808816:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808819:	8b 40 10             	mov    0x10(%eax),%eax
  80881c:	8b 40 04             	mov    0x4(%eax),%eax
  80881f:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808822:	83 c4 04             	add    $0x4,%esp
  808825:	ff 76 24             	pushl  0x24(%esi)
  808828:	e8 aa ee ff ff       	call   8076d7 <htonl>
  80882d:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808830:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808834:	89 04 24             	mov    %eax,(%esp)
  808837:	e8 8e ee ff ff       	call   8076ca <ntohs>
  80883c:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808841:	89 04 24             	mov    %eax,(%esp)
  808844:	e8 74 ee ff ff       	call   8076bd <htons>
  808849:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80884d:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808851:	89 04 24             	mov    %eax,(%esp)
  808854:	e8 64 ee ff ff       	call   8076bd <htons>
  808859:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80885d:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808863:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808867:	89 04 24             	mov    %eax,(%esp)
  80886a:	e8 5b ee ff ff       	call   8076ca <ntohs>
  80886f:	83 e0 3f             	and    $0x3f,%eax
  808872:	80 cc 50             	or     $0x50,%ah
  808875:	89 04 24             	mov    %eax,(%esp)
  808878:	e8 40 ee ff ff       	call   8076bd <htons>
  80887d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808881:	8b 47 04             	mov    0x4(%edi),%eax
  808884:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808887:	8b 51 08             	mov    0x8(%ecx),%edx
  80888a:	0f b6 12             	movzbl (%edx),%edx
  80888d:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808890:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808896:	8d 46 04             	lea    0x4(%esi),%eax
  808899:	89 c1                	mov    %eax,%ecx
  80889b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80889f:	89 04 24             	mov    %eax,(%esp)
  8088a2:	6a 06                	push   $0x6
  8088a4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8088a7:	51                   	push   %ecx
  8088a8:	56                   	push   %esi
  8088a9:	57                   	push   %edi
  8088aa:	e8 ea ea ff ff       	call   807399 <inet_chksum_pseudo>
  8088af:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8088b3:	83 c4 18             	add    $0x18,%esp
  8088b6:	6a 06                	push   $0x6
  8088b8:	6a 00                	push   $0x0
  8088ba:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8088be:	50                   	push   %eax
  8088bf:	ff 75 e4             	pushl  -0x1c(%ebp)
  8088c2:	56                   	push   %esi
  8088c3:	57                   	push   %edi
  8088c4:	e8 e4 e0 ff ff       	call   8069ad <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8088c9:	83 c4 14             	add    $0x14,%esp
  8088cc:	57                   	push   %edi
  8088cd:	e8 11 bf ff ff       	call   8047e3 <pbuf_free>
  8088d2:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8088d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8088d8:	5b                   	pop    %ebx
  8088d9:	5e                   	pop    %esi
  8088da:	5f                   	pop    %edi
  8088db:	5d                   	pop    %ebp
  8088dc:	c3                   	ret    
    seg = pcb->unsent;
  8088dd:	8b 46 74             	mov    0x74(%esi),%eax
  8088e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  8088e3:	85 c0                	test   %eax,%eax
  8088e5:	74 ee                	je     8088d5 <tcp_zero_window_probe+0x122>
  8088e7:	e9 e1 fe ff ff       	jmp    8087cd <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088ec:	83 ec 04             	sub    $0x4,%esp
  8088ef:	68 98 25 81 00       	push   $0x812598
  8088f4:	68 8d 03 00 00       	push   $0x38d
  8088f9:	68 c6 25 81 00       	push   $0x8125c6
  8088fe:	e8 a5 5c 00 00       	call   80e5a8 <_panic>

00808903 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808903:	55                   	push   %ebp
  808904:	89 e5                	mov    %esp,%ebp
  808906:	57                   	push   %edi
  808907:	56                   	push   %esi
  808908:	53                   	push   %ebx
  808909:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80890c:	8b 45 08             	mov    0x8(%ebp),%eax
  80890f:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808912:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808916:	0f b7 07             	movzwl (%edi),%eax
  808919:	50                   	push   %eax
  80891a:	e8 ab ed ff ff       	call   8076ca <ntohs>
  80891f:	66 c1 e8 08          	shr    $0x8,%ax
  808923:	83 e0 0f             	and    $0xf,%eax
  808926:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80892d:	83 c4 10             	add    $0x10,%esp
  808930:	39 c3                	cmp    %eax,%ebx
  808932:	7c 29                	jl     80895d <udp_input+0x5a>
  808934:	83 ec 0c             	sub    $0xc,%esp
  808937:	0f b7 07             	movzwl (%edi),%eax
  80893a:	50                   	push   %eax
  80893b:	e8 8a ed ff ff       	call   8076ca <ntohs>
  808940:	83 c4 08             	add    $0x8,%esp
  808943:	66 c1 e8 06          	shr    $0x6,%ax
  808947:	83 e0 3c             	and    $0x3c,%eax
  80894a:	f7 d8                	neg    %eax
  80894c:	98                   	cwtl   
  80894d:	50                   	push   %eax
  80894e:	ff 75 08             	pushl  0x8(%ebp)
  808951:	e8 c0 bd ff ff       	call   804716 <pbuf_header>
  808956:	83 c4 10             	add    $0x10,%esp
  808959:	84 c0                	test   %al,%al
  80895b:	74 16                	je     808973 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80895d:	83 ec 0c             	sub    $0xc,%esp
  808960:	ff 75 08             	pushl  0x8(%ebp)
  808963:	e8 7b be ff ff       	call   8047e3 <pbuf_free>
    goto end;
  808968:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80896b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80896e:	5b                   	pop    %ebx
  80896f:	5e                   	pop    %esi
  808970:	5f                   	pop    %edi
  808971:	5d                   	pop    %ebp
  808972:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808973:	8b 45 08             	mov    0x8(%ebp),%eax
  808976:	8b 70 04             	mov    0x4(%eax),%esi
  808979:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  80897c:	83 ec 0c             	sub    $0xc,%esp
  80897f:	0f b7 06             	movzwl (%esi),%eax
  808982:	50                   	push   %eax
  808983:	e8 42 ed ff ff       	call   8076ca <ntohs>
  808988:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  80898c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808990:	89 04 24             	mov    %eax,(%esp)
  808993:	e8 32 ed ff ff       	call   8076ca <ntohs>
  808998:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  80899a:	83 c4 10             	add    $0x10,%esp
  80899d:	66 83 f8 44          	cmp    $0x44,%ax
  8089a1:	74 1f                	je     8089c2 <udp_input+0xbf>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089a3:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  8089a9:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  8089ae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8089b5:	8d 47 10             	lea    0x10(%edi),%eax
  8089b8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8089bb:	89 7d dc             	mov    %edi,-0x24(%ebp)
  8089be:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8089c0:	eb 51                	jmp    808a13 <udp_input+0x110>
    if (src == DHCP_SERVER_PORT) {
  8089c2:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  8089c7:	0f 85 c8 01 00 00    	jne    808b95 <udp_input+0x292>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  8089cd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8089d0:	8b 40 20             	mov    0x20(%eax),%eax
  8089d3:	85 c0                	test   %eax,%eax
  8089d5:	0f 84 ba 01 00 00    	je     808b95 <udp_input+0x292>
  8089db:	8b 58 08             	mov    0x8(%eax),%ebx
  8089de:	85 db                	test   %ebx,%ebx
  8089e0:	0f 84 af 01 00 00    	je     808b95 <udp_input+0x292>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  8089e6:	8b 43 04             	mov    0x4(%ebx),%eax
  8089e9:	85 c0                	test   %eax,%eax
  8089eb:	0f 84 b4 01 00 00    	je     808ba5 <udp_input+0x2a2>
  8089f1:	3b 47 0c             	cmp    0xc(%edi),%eax
  8089f4:	0f 85 9b 01 00 00    	jne    808b95 <udp_input+0x292>
  8089fa:	e9 a6 01 00 00       	jmp    808ba5 <udp_input+0x2a2>
        if ((uncon_pcb == NULL) && 
  8089ff:	85 ff                	test   %edi,%edi
  808a01:	74 43                	je     808a46 <udp_input+0x143>
      if ((local_match != 0) &&
  808a03:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808a07:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808a0b:	74 45                	je     808a52 <udp_input+0x14f>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808a0d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808a10:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808a13:	85 db                	test   %ebx,%ebx
  808a15:	0f 84 6d 01 00 00    	je     808b88 <udp_input+0x285>
      if ((pcb->local_port == dest) &&
  808a1b:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808a1f:	75 ec                	jne    808a0d <udp_input+0x10a>
          (ip_addr_isany(&pcb->local_ip) ||
  808a21:	8b 03                	mov    (%ebx),%eax
  808a23:	85 c0                	test   %eax,%eax
  808a25:	74 d8                	je     8089ff <udp_input+0xfc>
  808a27:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808a2a:	3b 41 10             	cmp    0x10(%ecx),%eax
  808a2d:	74 d0                	je     8089ff <udp_input+0xfc>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808a2f:	83 ec 08             	sub    $0x8,%esp
  808a32:	ff 75 0c             	pushl  0xc(%ebp)
  808a35:	ff 75 d4             	pushl  -0x2c(%ebp)
  808a38:	e8 1d da ff ff       	call   80645a <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808a3d:	83 c4 10             	add    $0x10,%esp
  808a40:	84 c0                	test   %al,%al
  808a42:	74 c9                	je     808a0d <udp_input+0x10a>
  808a44:	eb b9                	jmp    8089ff <udp_input+0xfc>
        if ((uncon_pcb == NULL) && 
  808a46:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808a4a:	83 e0 04             	and    $0x4,%eax
  808a4d:	0f 44 fb             	cmove  %ebx,%edi
  808a50:	eb b1                	jmp    808a03 <udp_input+0x100>
          (ip_addr_isany(&pcb->remote_ip) ||
  808a52:	8b 43 04             	mov    0x4(%ebx),%eax
  808a55:	85 c0                	test   %eax,%eax
  808a57:	74 08                	je     808a61 <udp_input+0x15e>
  808a59:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808a5c:	3b 42 0c             	cmp    0xc(%edx),%eax
  808a5f:	75 ac                	jne    808a0d <udp_input+0x10a>
  808a61:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808a64:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808a67:	85 d2                	test   %edx,%edx
  808a69:	0f 84 36 01 00 00    	je     808ba5 <udp_input+0x2a2>
          prev->next = pcb->next;
  808a6f:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a72:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808a75:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808a7a:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808a7d:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808a83:	e9 1d 01 00 00       	jmp    808ba5 <udp_input+0x2a2>
  808a88:	89 c3                	mov    %eax,%ebx
  808a8a:	e9 16 01 00 00       	jmp    808ba5 <udp_input+0x2a2>
          pbuf_free(p);
  808a8f:	83 ec 0c             	sub    $0xc,%esp
  808a92:	ff 75 08             	pushl  0x8(%ebp)
  808a95:	e8 49 bd ff ff       	call   8047e3 <pbuf_free>
          goto end;
  808a9a:	83 c4 10             	add    $0x10,%esp
  808a9d:	e9 c9 fe ff ff       	jmp    80896b <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808aa2:	83 ec 04             	sub    $0x4,%esp
  808aa5:	68 eb 25 81 00       	push   $0x8125eb
  808aaa:	68 0a 01 00 00       	push   $0x10a
  808aaf:	68 16 26 81 00       	push   $0x812616
  808ab4:	e8 ef 5a 00 00       	call   80e5a8 <_panic>
        pbuf_free(p);
  808ab9:	83 ec 0c             	sub    $0xc,%esp
  808abc:	ff 75 08             	pushl  0x8(%ebp)
  808abf:	e8 1f bd ff ff       	call   8047e3 <pbuf_free>
        goto end;
  808ac4:	83 c4 10             	add    $0x10,%esp
  808ac7:	e9 9f fe ff ff       	jmp    80896b <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808acc:	83 ec 08             	sub    $0x8,%esp
  808acf:	ff 75 0c             	pushl  0xc(%ebp)
  808ad2:	8d 47 10             	lea    0x10(%edi),%eax
  808ad5:	50                   	push   %eax
  808ad6:	e8 7f d9 ff ff       	call   80645a <ip_addr_isbroadcast>
  808adb:	83 c4 10             	add    $0x10,%esp
  808ade:	84 c0                	test   %al,%al
  808ae0:	75 25                	jne    808b07 <udp_input+0x204>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808ae2:	8b 5f 10             	mov    0x10(%edi),%ebx
  808ae5:	83 ec 0c             	sub    $0xc,%esp
  808ae8:	68 00 00 00 f0       	push   $0xf0000000
  808aed:	e8 fc ed ff ff       	call   8078ee <ntohl>
  808af2:	21 c3                	and    %eax,%ebx
  808af4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808afb:	e8 ee ed ff ff       	call   8078ee <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b00:	83 c4 10             	add    $0x10,%esp
  808b03:	39 c3                	cmp    %eax,%ebx
  808b05:	75 13                	jne    808b1a <udp_input+0x217>
      pbuf_free(p);
  808b07:	83 ec 0c             	sub    $0xc,%esp
  808b0a:	ff 75 08             	pushl  0x8(%ebp)
  808b0d:	e8 d1 bc ff ff       	call   8047e3 <pbuf_free>
  808b12:	83 c4 10             	add    $0x10,%esp
  808b15:	e9 51 fe ff ff       	jmp    80896b <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808b1a:	83 ec 0c             	sub    $0xc,%esp
  808b1d:	0f b7 07             	movzwl (%edi),%eax
  808b20:	50                   	push   %eax
  808b21:	e8 a4 eb ff ff       	call   8076ca <ntohs>
  808b26:	83 c4 08             	add    $0x8,%esp
  808b29:	66 c1 e8 08          	shr    $0x8,%ax
  808b2d:	83 e0 0f             	and    $0xf,%eax
  808b30:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b37:	98                   	cwtl   
  808b38:	50                   	push   %eax
  808b39:	ff 75 08             	pushl  0x8(%ebp)
  808b3c:	e8 d5 bb ff ff       	call   804716 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b41:	83 c4 10             	add    $0x10,%esp
  808b44:	8b 45 08             	mov    0x8(%ebp),%eax
  808b47:	3b 78 04             	cmp    0x4(%eax),%edi
  808b4a:	75 12                	jne    808b5e <udp_input+0x25b>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808b4c:	83 ec 08             	sub    $0x8,%esp
  808b4f:	6a 03                	push   $0x3
  808b51:	ff 75 08             	pushl  0x8(%ebp)
  808b54:	e8 cd 57 00 00       	call   80e326 <icmp_dest_unreach>
  808b59:	83 c4 10             	add    $0x10,%esp
  808b5c:	eb a9                	jmp    808b07 <udp_input+0x204>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808b5e:	83 ec 04             	sub    $0x4,%esp
  808b61:	68 2a 26 81 00       	push   $0x81262a
  808b66:	68 25 01 00 00       	push   $0x125
  808b6b:	68 16 26 81 00       	push   $0x812616
  808b70:	e8 33 5a 00 00       	call   80e5a8 <_panic>
    pbuf_free(p);
  808b75:	83 ec 0c             	sub    $0xc,%esp
  808b78:	ff 75 08             	pushl  0x8(%ebp)
  808b7b:	e8 63 bc ff ff       	call   8047e3 <pbuf_free>
  808b80:	83 c4 10             	add    $0x10,%esp
}
  808b83:	e9 e3 fd ff ff       	jmp    80896b <udp_input+0x68>
  808b88:	89 f8                	mov    %edi,%eax
  808b8a:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808b8d:	85 c0                	test   %eax,%eax
  808b8f:	0f 85 f3 fe ff ff    	jne    808a88 <udp_input+0x185>
  808b95:	8b 45 0c             	mov    0xc(%ebp),%eax
  808b98:	8b 57 10             	mov    0x10(%edi),%edx
  808b9b:	bb 00 00 00 00       	mov    $0x0,%ebx
  808ba0:	39 50 04             	cmp    %edx,0x4(%eax)
  808ba3:	75 d0                	jne    808b75 <udp_input+0x272>
      if (udphdr->chksum != 0) {
  808ba5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808ba8:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808bad:	74 29                	je     808bd8 <udp_input+0x2d5>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808baf:	83 ec 0c             	sub    $0xc,%esp
  808bb2:	8b 45 08             	mov    0x8(%ebp),%eax
  808bb5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808bb9:	50                   	push   %eax
  808bba:	6a 11                	push   $0x11
  808bbc:	8d 47 10             	lea    0x10(%edi),%eax
  808bbf:	50                   	push   %eax
  808bc0:	8d 47 0c             	lea    0xc(%edi),%eax
  808bc3:	50                   	push   %eax
  808bc4:	ff 75 08             	pushl  0x8(%ebp)
  808bc7:	e8 cd e7 ff ff       	call   807399 <inet_chksum_pseudo>
  808bcc:	83 c4 20             	add    $0x20,%esp
  808bcf:	66 85 c0             	test   %ax,%ax
  808bd2:	0f 85 b7 fe ff ff    	jne    808a8f <udp_input+0x18c>
    if(pbuf_header(p, -UDP_HLEN)) {
  808bd8:	83 ec 08             	sub    $0x8,%esp
  808bdb:	6a f8                	push   $0xfffffff8
  808bdd:	ff 75 08             	pushl  0x8(%ebp)
  808be0:	e8 31 bb ff ff       	call   804716 <pbuf_header>
  808be5:	83 c4 10             	add    $0x10,%esp
  808be8:	84 c0                	test   %al,%al
  808bea:	0f 85 b2 fe ff ff    	jne    808aa2 <udp_input+0x19f>
    if (pcb != NULL) {
  808bf0:	85 db                	test   %ebx,%ebx
  808bf2:	0f 84 d4 fe ff ff    	je     808acc <udp_input+0x1c9>
      if (pcb->recv != NULL) {
  808bf8:	8b 43 18             	mov    0x18(%ebx),%eax
  808bfb:	85 c0                	test   %eax,%eax
  808bfd:	0f 84 b6 fe ff ff    	je     808ab9 <udp_input+0x1b6>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808c03:	83 ec 0c             	sub    $0xc,%esp
  808c06:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808c0a:	52                   	push   %edx
  808c0b:	83 c7 0c             	add    $0xc,%edi
  808c0e:	57                   	push   %edi
  808c0f:	ff 75 08             	pushl  0x8(%ebp)
  808c12:	53                   	push   %ebx
  808c13:	ff 73 1c             	pushl  0x1c(%ebx)
  808c16:	ff d0                	call   *%eax
  808c18:	83 c4 20             	add    $0x20,%esp
  808c1b:	e9 4b fd ff ff       	jmp    80896b <udp_input+0x68>

00808c20 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808c20:	55                   	push   %ebp
  808c21:	89 e5                	mov    %esp,%ebp
  808c23:	57                   	push   %edi
  808c24:	56                   	push   %esi
  808c25:	53                   	push   %ebx
  808c26:	83 ec 0c             	sub    $0xc,%esp
  808c29:	8b 55 08             	mov    0x8(%ebp),%edx
  808c2c:	8b 7d 10             	mov    0x10(%ebp),%edi
  808c2f:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c31:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808c36:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808c3b:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c40:	eb 1a                	jmp    808c5c <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c42:	83 ec 04             	sub    $0x4,%esp
  808c45:	68 3e 26 81 00       	push   $0x81263e
  808c4a:	68 41 02 00 00       	push   $0x241
  808c4f:	68 16 26 81 00       	push   $0x812616
  808c54:	e8 4f 59 00 00       	call   80e5a8 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808c59:	8b 40 0c             	mov    0xc(%eax),%eax
  808c5c:	85 c0                	test   %eax,%eax
  808c5e:	74 0c                	je     808c6c <udp_bind+0x4c>
    if (pcb == ipcb) {
  808c60:	39 d0                	cmp    %edx,%eax
  808c62:	75 f5                	jne    808c59 <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808c64:	84 db                	test   %bl,%bl
  808c66:	75 da                	jne    808c42 <udp_bind+0x22>
      rebind = 1;
  808c68:	89 f3                	mov    %esi,%ebx
  808c6a:	eb ed                	jmp    808c59 <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808c6c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808c70:	74 05                	je     808c77 <udp_bind+0x57>
  808c72:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c75:	8b 00                	mov    (%eax),%eax
  808c77:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808c79:	66 85 ff             	test   %di,%di
  808c7c:	75 2e                	jne    808cac <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808c7e:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808c84:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808c86:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c8b:	eb 03                	jmp    808c90 <udp_bind+0x70>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808c8d:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808c90:	85 c0                	test   %eax,%eax
  808c92:	74 14                	je     808ca8 <udp_bind+0x88>
  808c94:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808c99:	74 0d                	je     808ca8 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808c9b:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808c9f:	75 ec                	jne    808c8d <udp_bind+0x6d>
        port++;
  808ca1:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808ca4:	89 f0                	mov    %esi,%eax
  808ca6:	eb e8                	jmp    808c90 <udp_bind+0x70>
    }
    if (ipcb != NULL) {
  808ca8:	85 c0                	test   %eax,%eax
  808caa:	75 28                	jne    808cd4 <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808cac:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808cb0:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808cb5:	84 db                	test   %bl,%bl
  808cb7:	75 13                	jne    808ccc <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808cb9:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808cbe:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808cc1:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808cc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808ccc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ccf:	5b                   	pop    %ebx
  808cd0:	5e                   	pop    %esi
  808cd1:	5f                   	pop    %edi
  808cd2:	5d                   	pop    %ebp
  808cd3:	c3                   	ret    
      return ERR_USE;
  808cd4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808cd9:	eb f1                	jmp    808ccc <udp_bind+0xac>

00808cdb <udp_sendto_if>:
{
  808cdb:	55                   	push   %ebp
  808cdc:	89 e5                	mov    %esp,%ebp
  808cde:	57                   	push   %edi
  808cdf:	56                   	push   %esi
  808ce0:	53                   	push   %ebx
  808ce1:	83 ec 1c             	sub    $0x1c,%esp
  808ce4:	8b 75 08             	mov    0x8(%ebp),%esi
  808ce7:	8b 45 14             	mov    0x14(%ebp),%eax
  808cea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808ced:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  808cf2:	75 19                	jne    808d0d <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808cf4:	83 ec 04             	sub    $0x4,%esp
  808cf7:	6a 00                	push   $0x0
  808cf9:	56                   	push   %esi
  808cfa:	56                   	push   %esi
  808cfb:	e8 20 ff ff ff       	call   808c20 <udp_bind>
  808d00:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808d02:	83 c4 10             	add    $0x10,%esp
  808d05:	84 c0                	test   %al,%al
  808d07:	0f 85 b7 00 00 00    	jne    808dc4 <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808d0d:	83 ec 08             	sub    $0x8,%esp
  808d10:	6a 08                	push   $0x8
  808d12:	ff 75 0c             	pushl  0xc(%ebp)
  808d15:	e8 fc b9 ff ff       	call   804716 <pbuf_header>
  808d1a:	83 c4 10             	add    $0x10,%esp
    q = p;
  808d1d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808d20:	84 c0                	test   %al,%al
  808d22:	0f 85 a6 00 00 00    	jne    808dce <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808d28:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808d2d:	0f 86 ca 00 00 00    	jbe    808dfd <udp_sendto_if+0x122>
  udphdr = q->payload;
  808d33:	8b 7b 04             	mov    0x4(%ebx),%edi
  udphdr->src = htons(pcb->local_port);
  808d36:	83 ec 0c             	sub    $0xc,%esp
  808d39:	0f b7 46 12          	movzwl 0x12(%esi),%eax
  808d3d:	50                   	push   %eax
  808d3e:	e8 7a e9 ff ff       	call   8076bd <htons>
  808d43:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808d46:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808d4a:	89 04 24             	mov    %eax,(%esp)
  808d4d:	e8 6b e9 ff ff       	call   8076bd <htons>
  808d52:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808d56:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808d5c:	8b 06                	mov    (%esi),%eax
  808d5e:	83 c4 10             	add    $0x10,%esp
  808d61:	85 c0                	test   %eax,%eax
  808d63:	0f 85 ab 00 00 00    	jne    808e14 <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808d69:	8b 45 18             	mov    0x18(%ebp),%eax
  808d6c:	83 c0 04             	add    $0x4,%eax
  808d6f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808d72:	83 ec 0c             	sub    $0xc,%esp
  808d75:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808d79:	50                   	push   %eax
  808d7a:	e8 3e e9 ff ff       	call   8076bd <htons>
  808d7f:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808d83:	83 c4 10             	add    $0x10,%esp
  808d86:	f6 46 10 01          	testb  $0x1,0x10(%esi)
  808d8a:	0f 84 ac 00 00 00    	je     808e3c <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808d90:	83 ec 04             	sub    $0x4,%esp
  808d93:	ff 75 18             	pushl  0x18(%ebp)
  808d96:	6a 11                	push   $0x11
  808d98:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808d9c:	50                   	push   %eax
  808d9d:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808da1:	50                   	push   %eax
  808da2:	ff 75 10             	pushl  0x10(%ebp)
  808da5:	ff 75 e4             	pushl  -0x1c(%ebp)
  808da8:	53                   	push   %ebx
  808da9:	e8 72 da ff ff       	call   806820 <ip_output_if>
  808dae:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808db0:	83 c4 20             	add    $0x20,%esp
  808db3:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808db6:	74 0c                	je     808dc4 <udp_sendto_if+0xe9>
    pbuf_free(q);
  808db8:	83 ec 0c             	sub    $0xc,%esp
  808dbb:	53                   	push   %ebx
  808dbc:	e8 22 ba ff ff       	call   8047e3 <pbuf_free>
  808dc1:	83 c4 10             	add    $0x10,%esp
}
  808dc4:	89 f8                	mov    %edi,%eax
  808dc6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808dc9:	5b                   	pop    %ebx
  808dca:	5e                   	pop    %esi
  808dcb:	5f                   	pop    %edi
  808dcc:	5d                   	pop    %ebp
  808dcd:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808dce:	83 ec 04             	sub    $0x4,%esp
  808dd1:	6a 00                	push   $0x0
  808dd3:	6a 08                	push   $0x8
  808dd5:	6a 01                	push   $0x1
  808dd7:	e8 cd ba ff ff       	call   8048a9 <pbuf_alloc>
  808ddc:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808dde:	83 c4 10             	add    $0x10,%esp
  808de1:	85 c0                	test   %eax,%eax
  808de3:	0f 84 80 00 00 00    	je     808e69 <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808de9:	83 ec 08             	sub    $0x8,%esp
  808dec:	ff 75 0c             	pushl  0xc(%ebp)
  808def:	50                   	push   %eax
  808df0:	e8 cf be ff ff       	call   804cc4 <pbuf_chain>
  808df5:	83 c4 10             	add    $0x10,%esp
  808df8:	e9 2b ff ff ff       	jmp    808d28 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808dfd:	83 ec 04             	sub    $0x4,%esp
  808e00:	68 4c 26 81 00       	push   $0x81264c
  808e05:	68 b2 01 00 00       	push   $0x1b2
  808e0a:	68 16 26 81 00       	push   $0x812616
  808e0f:	e8 94 57 00 00       	call   80e5a8 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808e14:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808e17:	3b 41 04             	cmp    0x4(%ecx),%eax
  808e1a:	75 08                	jne    808e24 <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  808e1c:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  808e1f:	e9 4e ff ff ff       	jmp    808d72 <udp_sendto_if+0x97>
      return ERR_VAL;
  808e24:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  808e29:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808e2c:	74 96                	je     808dc4 <udp_sendto_if+0xe9>
        pbuf_free(q);
  808e2e:	83 ec 0c             	sub    $0xc,%esp
  808e31:	53                   	push   %ebx
  808e32:	e8 ac b9 ff ff       	call   8047e3 <pbuf_free>
  808e37:	83 c4 10             	add    $0x10,%esp
  808e3a:	eb 88                	jmp    808dc4 <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e3c:	83 ec 0c             	sub    $0xc,%esp
  808e3f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808e43:	50                   	push   %eax
  808e44:	6a 11                	push   $0x11
  808e46:	ff 75 10             	pushl  0x10(%ebp)
  808e49:	ff 75 e4             	pushl  -0x1c(%ebp)
  808e4c:	53                   	push   %ebx
  808e4d:	e8 47 e5 ff ff       	call   807399 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808e52:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808e55:	66 85 c0             	test   %ax,%ax
  808e58:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808e5d:	0f 44 c2             	cmove  %edx,%eax
  808e60:	66 89 47 06          	mov    %ax,0x6(%edi)
  808e64:	e9 27 ff ff ff       	jmp    808d90 <udp_sendto_if+0xb5>
      return ERR_MEM;
  808e69:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  808e6e:	e9 51 ff ff ff       	jmp    808dc4 <udp_sendto_if+0xe9>

00808e73 <udp_sendto>:
{
  808e73:	55                   	push   %ebp
  808e74:	89 e5                	mov    %esp,%ebp
  808e76:	56                   	push   %esi
  808e77:	53                   	push   %ebx
  808e78:	8b 75 10             	mov    0x10(%ebp),%esi
  808e7b:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808e7e:	83 ec 0c             	sub    $0xc,%esp
  808e81:	56                   	push   %esi
  808e82:	e8 16 d6 ff ff       	call   80649d <ip_route>
  if (netif == NULL) {
  808e87:	83 c4 10             	add    $0x10,%esp
  808e8a:	85 c0                	test   %eax,%eax
  808e8c:	74 1e                	je     808eac <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808e8e:	83 ec 0c             	sub    $0xc,%esp
  808e91:	50                   	push   %eax
  808e92:	0f b7 db             	movzwl %bx,%ebx
  808e95:	53                   	push   %ebx
  808e96:	56                   	push   %esi
  808e97:	ff 75 0c             	pushl  0xc(%ebp)
  808e9a:	ff 75 08             	pushl  0x8(%ebp)
  808e9d:	e8 39 fe ff ff       	call   808cdb <udp_sendto_if>
  808ea2:	83 c4 20             	add    $0x20,%esp
}
  808ea5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808ea8:	5b                   	pop    %ebx
  808ea9:	5e                   	pop    %esi
  808eaa:	5d                   	pop    %ebp
  808eab:	c3                   	ret    
    return ERR_RTE;
  808eac:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808eb1:	eb f2                	jmp    808ea5 <udp_sendto+0x32>

00808eb3 <udp_send>:
{
  808eb3:	55                   	push   %ebp
  808eb4:	89 e5                	mov    %esp,%ebp
  808eb6:	83 ec 08             	sub    $0x8,%esp
  808eb9:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808ebc:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808ec0:	52                   	push   %edx
  808ec1:	8d 50 04             	lea    0x4(%eax),%edx
  808ec4:	52                   	push   %edx
  808ec5:	ff 75 0c             	pushl  0xc(%ebp)
  808ec8:	50                   	push   %eax
  808ec9:	e8 a5 ff ff ff       	call   808e73 <udp_sendto>
}
  808ece:	c9                   	leave  
  808ecf:	c3                   	ret    

00808ed0 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808ed0:	55                   	push   %ebp
  808ed1:	89 e5                	mov    %esp,%ebp
  808ed3:	57                   	push   %edi
  808ed4:	56                   	push   %esi
  808ed5:	53                   	push   %ebx
  808ed6:	83 ec 0c             	sub    $0xc,%esp
  808ed9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808edc:	8b 75 0c             	mov    0xc(%ebp),%esi
  808edf:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808ee2:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808ee7:	74 2b                	je     808f14 <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808ee9:	b8 00 00 00 00       	mov    $0x0,%eax
  808eee:	85 f6                	test   %esi,%esi
  808ef0:	74 02                	je     808ef4 <udp_connect+0x24>
  808ef2:	8b 06                	mov    (%esi),%eax
  808ef4:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808ef7:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808efb:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808eff:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808f05:	89 d0                	mov    %edx,%eax
  808f07:	85 c0                	test   %eax,%eax
  808f09:	74 1e                	je     808f29 <udp_connect+0x59>
    if (pcb == ipcb) {
  808f0b:	39 d8                	cmp    %ebx,%eax
  808f0d:	74 2b                	je     808f3a <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808f0f:	8b 40 0c             	mov    0xc(%eax),%eax
  808f12:	eb f3                	jmp    808f07 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808f14:	83 ec 04             	sub    $0x4,%esp
  808f17:	6a 00                	push   $0x0
  808f19:	53                   	push   %ebx
  808f1a:	53                   	push   %ebx
  808f1b:	e8 00 fd ff ff       	call   808c20 <udp_bind>
    if (err != ERR_OK)
  808f20:	83 c4 10             	add    $0x10,%esp
  808f23:	84 c0                	test   %al,%al
  808f25:	74 c2                	je     808ee9 <udp_connect+0x19>
  808f27:	eb 09                	jmp    808f32 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808f29:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808f2c:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  808f32:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808f35:	5b                   	pop    %ebx
  808f36:	5e                   	pop    %esi
  808f37:	5f                   	pop    %edi
  808f38:	5d                   	pop    %ebp
  808f39:	c3                   	ret    
      return ERR_OK;
  808f3a:	b8 00 00 00 00       	mov    $0x0,%eax
  808f3f:	eb f1                	jmp    808f32 <udp_connect+0x62>

00808f41 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808f41:	55                   	push   %ebp
  808f42:	89 e5                	mov    %esp,%ebp
  808f44:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808f47:	8b 15 88 22 81 00    	mov    0x812288,%edx
  808f4d:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808f50:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808f56:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  808f5a:	5d                   	pop    %ebp
  808f5b:	c3                   	ret    

00808f5c <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  808f5c:	55                   	push   %ebp
  808f5d:	89 e5                	mov    %esp,%ebp
  808f5f:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  808f62:	8b 55 0c             	mov    0xc(%ebp),%edx
  808f65:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  808f68:	8b 55 10             	mov    0x10(%ebp),%edx
  808f6b:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  808f6e:	5d                   	pop    %ebp
  808f6f:	c3                   	ret    

00808f70 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  808f70:	55                   	push   %ebp
  808f71:	89 e5                	mov    %esp,%ebp
  808f73:	83 ec 08             	sub    $0x8,%esp
  808f76:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  808f79:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808f7e:	39 c8                	cmp    %ecx,%eax
  808f80:	75 1b                	jne    808f9d <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  808f82:	8b 41 0c             	mov    0xc(%ecx),%eax
  808f85:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  808f8a:	83 ec 08             	sub    $0x8,%esp
  808f8d:	51                   	push   %ecx
  808f8e:	6a 01                	push   $0x1
  808f90:	e8 01 b5 ff ff       	call   804496 <memp_free>
}
  808f95:	83 c4 10             	add    $0x10,%esp
  808f98:	c9                   	leave  
  808f99:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  808f9a:	8b 40 0c             	mov    0xc(%eax),%eax
  808f9d:	85 c0                	test   %eax,%eax
  808f9f:	74 e9                	je     808f8a <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  808fa1:	8b 50 0c             	mov    0xc(%eax),%edx
  808fa4:	39 ca                	cmp    %ecx,%edx
  808fa6:	75 f2                	jne    808f9a <udp_remove+0x2a>
  808fa8:	85 d2                	test   %edx,%edx
  808faa:	74 ee                	je     808f9a <udp_remove+0x2a>
        pcb2->next = pcb->next;
  808fac:	8b 51 0c             	mov    0xc(%ecx),%edx
  808faf:	89 50 0c             	mov    %edx,0xc(%eax)
  808fb2:	eb e6                	jmp    808f9a <udp_remove+0x2a>

00808fb4 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  808fb4:	55                   	push   %ebp
  808fb5:	89 e5                	mov    %esp,%ebp
  808fb7:	53                   	push   %ebx
  808fb8:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  808fbb:	6a 01                	push   $0x1
  808fbd:	e8 7e b4 ff ff       	call   804440 <memp_malloc>
  808fc2:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  808fc4:	83 c4 10             	add    $0x10,%esp
  808fc7:	85 c0                	test   %eax,%eax
  808fc9:	74 14                	je     808fdf <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  808fcb:	83 ec 04             	sub    $0x4,%esp
  808fce:	6a 20                	push   $0x20
  808fd0:	6a 00                	push   $0x0
  808fd2:	50                   	push   %eax
  808fd3:	e8 6b 5f 00 00       	call   80ef43 <memset>
    pcb->ttl = UDP_TTL;
  808fd8:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  808fdc:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  808fdf:	89 d8                	mov    %ebx,%eax
  808fe1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808fe4:	c9                   	leave  
  808fe5:	c3                   	ret    

00808fe6 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  808fe6:	55                   	push   %ebp
  808fe7:	89 e5                	mov    %esp,%ebp
  808fe9:	56                   	push   %esi
  808fea:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  808feb:	85 c0                	test   %eax,%eax
  808fed:	74 35                	je     809024 <free_etharp_q+0x3e>
  808fef:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  808ff1:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  808ff5:	74 44                	je     80903b <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  808ff7:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  808ff9:	8b 43 04             	mov    0x4(%ebx),%eax
  808ffc:	85 c0                	test   %eax,%eax
  808ffe:	74 52                	je     809052 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  809000:	83 ec 0c             	sub    $0xc,%esp
  809003:	50                   	push   %eax
  809004:	e8 da b7 ff ff       	call   8047e3 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809009:	83 c4 08             	add    $0x8,%esp
  80900c:	53                   	push   %ebx
  80900d:	6a 0a                	push   $0xa
  80900f:	e8 82 b4 ff ff       	call   804496 <memp_free>
    q = q->next;
  809014:	89 f3                	mov    %esi,%ebx
  while (q) {
  809016:	83 c4 10             	add    $0x10,%esp
  809019:	85 f6                	test   %esi,%esi
  80901b:	75 da                	jne    808ff7 <free_etharp_q+0x11>
  }
}
  80901d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809020:	5b                   	pop    %ebx
  809021:	5e                   	pop    %esi
  809022:	5d                   	pop    %ebp
  809023:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809024:	83 ec 04             	sub    $0x4,%esp
  809027:	68 8c 1d 81 00       	push   $0x811d8c
  80902c:	68 93 00 00 00       	push   $0x93
  809031:	68 7a 26 81 00       	push   $0x81267a
  809036:	e8 6d 55 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80903b:	83 ec 04             	sub    $0x4,%esp
  80903e:	68 92 26 81 00       	push   $0x812692
  809043:	68 94 00 00 00       	push   $0x94
  809048:	68 7a 26 81 00       	push   $0x81267a
  80904d:	e8 56 55 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809052:	83 ec 04             	sub    $0x4,%esp
  809055:	68 9f 26 81 00       	push   $0x81269f
  80905a:	68 98 00 00 00       	push   $0x98
  80905f:	68 7a 26 81 00       	push   $0x81267a
  809064:	e8 3f 55 00 00       	call   80e5a8 <_panic>

00809069 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809069:	55                   	push   %ebp
  80906a:	89 e5                	mov    %esp,%ebp
  80906c:	57                   	push   %edi
  80906d:	56                   	push   %esi
  80906e:	53                   	push   %ebx
  80906f:	83 ec 1c             	sub    $0x1c,%esp
  809072:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809075:	85 c0                	test   %eax,%eax
  809077:	0f 84 e9 00 00 00    	je     809166 <find_entry+0xfd>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80907d:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  809084:	0f b6 ca             	movzbl %dl,%ecx
  809087:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  80908a:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  809091:	0f 84 9f 00 00 00    	je     809136 <find_entry+0xcd>
  809097:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80909b:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80909f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8090a3:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8090a7:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8090ab:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8090af:	ba 00 00 00 00       	mov    $0x0,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8090b4:	0f b6 ca             	movzbl %dl,%ecx
  8090b7:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8090ba:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  8090c1:	0f 85 c1 00 00 00    	jne    809188 <find_entry+0x11f>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8090c7:	89 d1                	mov    %edx,%ecx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8090c9:	83 c2 01             	add    $0x1,%edx
  8090cc:	80 fa 09             	cmp    $0x9,%dl
  8090cf:	0f 86 02 01 00 00    	jbe    8091d7 <find_entry+0x16e>
  8090d5:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8090d8:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8090da:	80 f9 0a             	cmp    $0xa,%cl
  8090dd:	0f 84 69 01 00 00    	je     80924c <find_entry+0x1e3>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8090e3:	f6 c2 02             	test   $0x2,%dl
  8090e6:	0f 85 ff 01 00 00    	jne    8092eb <find_entry+0x282>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8090ec:	89 ce                	mov    %ecx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8090ee:	80 f9 09             	cmp    $0x9,%cl
  8090f1:	0f 8f 67 01 00 00    	jg     80925e <find_entry+0x1f5>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8090f7:	89 f0                	mov    %esi,%eax
  8090f9:	3c 09                	cmp    $0x9,%al
  8090fb:	0f 87 c9 01 00 00    	ja     8092ca <find_entry+0x261>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809101:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809104:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809107:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  80910e:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809111:	85 db                	test   %ebx,%ebx
  809113:	74 08                	je     80911d <find_entry+0xb4>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809115:	8b 0b                	mov    (%ebx),%ecx
  809117:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  80911d:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809120:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809127:	89 f0                	mov    %esi,%eax
  809129:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80912e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809131:	5b                   	pop    %ebx
  809132:	5e                   	pop    %esi
  809133:	5f                   	pop    %edi
  809134:	5d                   	pop    %ebp
  809135:	c3                   	ret    
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809136:	8b bb 24 4a b3 00    	mov    0xb34a24(%ebx),%edi
  80913c:	39 38                	cmp    %edi,(%eax)
  80913e:	74 22                	je     809162 <find_entry+0xf9>
  809140:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809144:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809148:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80914c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809150:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809154:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809158:	ba 00 00 00 00       	mov    $0x0,%edx
  80915d:	e9 52 ff ff ff       	jmp    8090b4 <find_entry+0x4b>
        return etharp_cached_entry;
  809162:	89 d0                	mov    %edx,%eax
  809164:	eb c8                	jmp    80912e <find_entry+0xc5>
  809166:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80916a:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80916e:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809172:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809176:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80917a:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80917e:	ba 00 00 00 00       	mov    $0x0,%edx
  809183:	e9 2c ff ff ff       	jmp    8090b4 <find_entry+0x4b>
  809188:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80918d:	eb 48                	jmp    8091d7 <find_entry+0x16e>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80918f:	85 c0                	test   %eax,%eax
  809191:	74 0d                	je     8091a0 <find_entry+0x137>
  809193:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809196:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  80919c:	39 38                	cmp    %edi,(%eax)
  80919e:	74 79                	je     809219 <find_entry+0x1b0>
      } else if (arp_table[i].q != NULL) {
  8091a0:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091a3:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  8091aa:	74 7a                	je     809226 <find_entry+0x1bd>
        if (arp_table[i].ctime >= age_queue) {
  8091ac:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  8091b3:	89 cf                	mov    %ecx,%edi
  8091b5:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  8091b8:	72 06                	jb     8091c0 <find_entry+0x157>
          old_queue = i;
  8091ba:	88 55 e3             	mov    %dl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8091bd:	88 5d e7             	mov    %bl,-0x19(%ebp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8091c0:	83 c2 01             	add    $0x1,%edx
  8091c3:	80 fa 09             	cmp    $0x9,%dl
  8091c6:	0f 87 09 ff ff ff    	ja     8090d5 <find_entry+0x6c>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8091cc:	80 f9 0a             	cmp    $0xa,%cl
  8091cf:	0f 84 df fe ff ff    	je     8090b4 <find_entry+0x4b>
  8091d5:	89 f9                	mov    %edi,%ecx
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8091d7:	0f b6 da             	movzbl %dl,%ebx
  8091da:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091dd:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  8091e3:	83 fe 01             	cmp    $0x1,%esi
  8091e6:	74 a7                	je     80918f <find_entry+0x126>
  8091e8:	89 cf                	mov    %ecx,%edi
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8091ea:	83 fe 02             	cmp    $0x2,%esi
  8091ed:	75 d1                	jne    8091c0 <find_entry+0x157>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8091ef:	85 c0                	test   %eax,%eax
  8091f1:	74 0d                	je     809200 <find_entry+0x197>
  8091f3:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8091f6:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  8091fc:	39 38                	cmp    %edi,(%eax)
  8091fe:	74 3f                	je     80923f <find_entry+0x1d6>
      } else if (arp_table[i].ctime >= age_stable) {
  809200:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809203:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  80920a:	89 cf                	mov    %ecx,%edi
  80920c:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  80920f:	72 af                	jb     8091c0 <find_entry+0x157>
        old_stable = i;
  809211:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809214:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809217:	eb a7                	jmp    8091c0 <find_entry+0x157>
        etharp_cached_entry = i;
  809219:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  80921f:	89 d0                	mov    %edx,%eax
  809221:	e9 08 ff ff ff       	jmp    80912e <find_entry+0xc5>
        if (arp_table[i].ctime >= age_pending) {
  809226:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809229:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  809230:	89 cf                	mov    %ecx,%edi
  809232:	3a 5d e4             	cmp    -0x1c(%ebp),%bl
  809235:	72 89                	jb     8091c0 <find_entry+0x157>
          old_pending = i;
  809237:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  80923a:	88 5d e4             	mov    %bl,-0x1c(%ebp)
  80923d:	eb 81                	jmp    8091c0 <find_entry+0x157>
        etharp_cached_entry = i;
  80923f:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  809245:	89 d0                	mov    %edx,%eax
  809247:	e9 e2 fe ff ff       	jmp    80912e <find_entry+0xc5>
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80924c:	f6 c2 01             	test   $0x1,%dl
  80924f:	0f 84 8c 00 00 00    	je     8092e1 <find_entry+0x278>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809255:	f6 c2 02             	test   $0x2,%dl
  809258:	0f 85 a1 00 00 00    	jne    8092ff <find_entry+0x296>
  else if (old_stable < ARP_TABLE_SIZE) {
  80925e:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809262:	3c 09                	cmp    $0x9,%al
  809264:	7f 2c                	jg     809292 <find_entry+0x229>
    i = old_stable;
  809266:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809268:	0f b6 c0             	movzbl %al,%eax
  80926b:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80926e:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  809275:	0f 84 7c fe ff ff    	je     8090f7 <find_entry+0x8e>
  80927b:	83 ec 04             	sub    $0x4,%esp
  80927e:	68 ac 26 81 00       	push   $0x8126ac
  809283:	68 75 01 00 00       	push   $0x175
  809288:	68 7a 26 81 00       	push   $0x81267a
  80928d:	e8 16 53 00 00       	call   80e5a8 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809292:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    i = old_pending;
  809296:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  809298:	3c 09                	cmp    $0x9,%al
  80929a:	0f 8e 57 fe ff ff    	jle    8090f7 <find_entry+0x8e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  8092a0:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  8092a4:	3c 09                	cmp    $0x9,%al
  8092a6:	7f 4d                	jg     8092f5 <find_entry+0x28c>
    i = old_queue;
  8092a8:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  8092aa:	0f b6 f8             	movzbl %al,%edi
  8092ad:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8092b0:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  8092b6:	e8 2b fd ff ff       	call   808fe6 <free_etharp_q>
    arp_table[i].q = NULL;
  8092bb:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  8092c2:	00 00 00 
  8092c5:	e9 2d fe ff ff       	jmp    8090f7 <find_entry+0x8e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8092ca:	83 ec 04             	sub    $0x4,%esp
  8092cd:	68 c3 26 81 00       	push   $0x8126c3
  8092d2:	68 8b 01 00 00       	push   $0x18b
  8092d7:	68 7a 26 81 00       	push   $0x81267a
  8092dc:	e8 c7 52 00 00       	call   80e5a8 <_panic>
    return (s8_t)ERR_MEM;
  8092e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092e6:	e9 43 fe ff ff       	jmp    80912e <find_entry+0xc5>
  8092eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092f0:	e9 39 fe ff ff       	jmp    80912e <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  8092f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8092fa:	e9 2f fe ff ff       	jmp    80912e <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  8092ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809304:	e9 25 fe ff ff       	jmp    80912e <find_entry+0xc5>

00809309 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809309:	55                   	push   %ebp
  80930a:	89 e5                	mov    %esp,%ebp
  80930c:	57                   	push   %edi
  80930d:	56                   	push   %esi
  80930e:	53                   	push   %ebx
  80930f:	83 ec 1c             	sub    $0x1c,%esp
  809312:	89 d7                	mov    %edx,%edi
  809314:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  809317:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80931a:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80931e:	75 45                	jne    809365 <etharp_send_ip+0x5c>
  809320:	89 c6                	mov    %eax,%esi
  809322:	b8 05 00 00 00       	mov    $0x5,%eax
  809327:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  80932a:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  80932e:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809331:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809334:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809338:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  80933c:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  80933f:	83 f8 ff             	cmp    $0xffffffff,%eax
  809342:	75 e6                	jne    80932a <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809344:	83 ec 0c             	sub    $0xc,%esp
  809347:	68 00 08 00 00       	push   $0x800
  80934c:	e8 6c e3 ff ff       	call   8076bd <htons>
  809351:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809355:	83 c4 08             	add    $0x8,%esp
  809358:	57                   	push   %edi
  809359:	56                   	push   %esi
  80935a:	ff 56 18             	call   *0x18(%esi)
}
  80935d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809360:	5b                   	pop    %ebx
  809361:	5e                   	pop    %esi
  809362:	5f                   	pop    %edi
  809363:	5d                   	pop    %ebp
  809364:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809365:	83 ec 04             	sub    $0x4,%esp
  809368:	68 f0 26 81 00       	push   $0x8126f0
  80936d:	68 b3 01 00 00       	push   $0x1b3
  809372:	68 7a 26 81 00       	push   $0x81267a
  809377:	e8 2c 52 00 00       	call   80e5a8 <_panic>

0080937c <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80937c:	55                   	push   %ebp
  80937d:	89 e5                	mov    %esp,%ebp
  80937f:	57                   	push   %edi
  809380:	56                   	push   %esi
  809381:	53                   	push   %ebx
  809382:	83 ec 1c             	sub    $0x1c,%esp
  809385:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809388:	89 cb                	mov    %ecx,%ebx
  80938a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80938d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809390:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809394:	0f 85 e9 00 00 00    	jne    809483 <update_arp_entry+0x107>
  80939a:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80939c:	85 d2                	test   %edx,%edx
  80939e:	0f 84 f6 00 00 00    	je     80949a <update_arp_entry+0x11e>
  8093a4:	83 3a 00             	cmpl   $0x0,(%edx)
  8093a7:	0f 84 f4 00 00 00    	je     8094a1 <update_arp_entry+0x125>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8093ad:	83 ec 08             	sub    $0x8,%esp
  8093b0:	ff 75 e4             	pushl  -0x1c(%ebp)
  8093b3:	52                   	push   %edx
  8093b4:	e8 a1 d0 ff ff       	call   80645a <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  8093b9:	83 c4 10             	add    $0x10,%esp
  8093bc:	84 c0                	test   %al,%al
  8093be:	0f 85 ea 00 00 00    	jne    8094ae <update_arp_entry+0x132>
      ip_addr_ismulticast(ipaddr)) {
  8093c4:	8b 3e                	mov    (%esi),%edi
  8093c6:	83 ec 0c             	sub    $0xc,%esp
  8093c9:	68 00 00 00 f0       	push   $0xf0000000
  8093ce:	e8 1b e5 ff ff       	call   8078ee <ntohl>
  8093d3:	21 c7                	and    %eax,%edi
  8093d5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8093dc:	e8 0d e5 ff ff       	call   8078ee <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8093e1:	83 c4 10             	add    $0x10,%esp
  8093e4:	39 c7                	cmp    %eax,%edi
  8093e6:	0f 84 c9 00 00 00    	je     8094b5 <update_arp_entry+0x139>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8093ec:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  8093f0:	89 f0                	mov    %esi,%eax
  8093f2:	e8 72 fc ff ff       	call   809069 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  8093f7:	84 c0                	test   %al,%al
  8093f9:	0f 88 a7 00 00 00    	js     8094a6 <update_arp_entry+0x12a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8093ff:	0f be c0             	movsbl %al,%eax
  809402:	6b f0 1c             	imul   $0x1c,%eax,%esi
  809405:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  80940c:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80940f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809412:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  809418:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80941d:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  809422:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  809429:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  80942c:	83 fa fa             	cmp    $0xfffffffa,%edx
  80942f:	75 ec                	jne    80941d <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809431:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809434:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80943b:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80943d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809440:	83 c0 25             	add    $0x25,%eax
  809443:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809446:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  80944c:	85 c0                	test   %eax,%eax
  80944e:	74 56                	je     8094a6 <update_arp_entry+0x12a>
    arp_table[i].q = q->next;
  809450:	8b 10                	mov    (%eax),%edx
  809452:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  809458:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  80945b:	83 ec 08             	sub    $0x8,%esp
  80945e:	50                   	push   %eax
  80945f:	6a 0a                	push   $0xa
  809461:	e8 30 b0 ff ff       	call   804496 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809466:	89 1c 24             	mov    %ebx,(%esp)
  809469:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80946c:	89 fa                	mov    %edi,%edx
  80946e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809471:	e8 93 fe ff ff       	call   809309 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809476:	89 3c 24             	mov    %edi,(%esp)
  809479:	e8 65 b3 ff ff       	call   8047e3 <pbuf_free>
  80947e:	83 c4 10             	add    $0x10,%esp
  809481:	eb c3                	jmp    809446 <update_arp_entry+0xca>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809483:	83 ec 04             	sub    $0x4,%esp
  809486:	68 34 27 81 00       	push   $0x812734
  80948b:	68 d9 01 00 00       	push   $0x1d9
  809490:	68 7a 26 81 00       	push   $0x81267a
  809495:	e8 0e 51 00 00       	call   80e5a8 <_panic>
    return ERR_ARG;
  80949a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80949f:	eb 05                	jmp    8094a6 <update_arp_entry+0x12a>
  8094a1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  }
#endif
  return ERR_OK;
}
  8094a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8094a9:	5b                   	pop    %ebx
  8094aa:	5e                   	pop    %esi
  8094ab:	5f                   	pop    %edi
  8094ac:	5d                   	pop    %ebp
  8094ad:	c3                   	ret    
    return ERR_ARG;
  8094ae:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8094b3:	eb f1                	jmp    8094a6 <update_arp_entry+0x12a>
  8094b5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8094ba:	eb ea                	jmp    8094a6 <update_arp_entry+0x12a>

008094bc <etharp_tmr>:
{
  8094bc:	55                   	push   %ebp
  8094bd:	89 e5                	mov    %esp,%ebp
  8094bf:	57                   	push   %edi
  8094c0:	56                   	push   %esi
  8094c1:	53                   	push   %ebx
  8094c2:	83 ec 0c             	sub    $0xc,%esp
  8094c5:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  8094ca:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  8094cf:	eb 1f                	jmp    8094f0 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  8094d1:	8b 06                	mov    (%esi),%eax
  8094d3:	85 c0                	test   %eax,%eax
  8094d5:	74 0b                	je     8094e2 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  8094d7:	e8 0a fb ff ff       	call   808fe6 <free_etharp_q>
        arp_table[i].q = NULL;
  8094dc:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8094e2:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8094e9:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8094ec:	39 fb                	cmp    %edi,%ebx
  8094ee:	74 23                	je     809513 <etharp_tmr+0x57>
  8094f0:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  8094f2:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  8094f6:	83 c0 01             	add    $0x1,%eax
  8094f9:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8094fc:	8b 53 10             	mov    0x10(%ebx),%edx
  8094ff:	3c ef                	cmp    $0xef,%al
  809501:	76 05                	jbe    809508 <etharp_tmr+0x4c>
  809503:	83 fa 02             	cmp    $0x2,%edx
  809506:	74 c9                	je     8094d1 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809508:	3c 01                	cmp    $0x1,%al
  80950a:	76 dd                	jbe    8094e9 <etharp_tmr+0x2d>
  80950c:	83 fa 01             	cmp    $0x1,%edx
  80950f:	75 d8                	jne    8094e9 <etharp_tmr+0x2d>
  809511:	eb be                	jmp    8094d1 <etharp_tmr+0x15>
}
  809513:	83 c4 0c             	add    $0xc,%esp
  809516:	5b                   	pop    %ebx
  809517:	5e                   	pop    %esi
  809518:	5f                   	pop    %edi
  809519:	5d                   	pop    %ebp
  80951a:	c3                   	ret    

0080951b <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80951b:	55                   	push   %ebp
  80951c:	89 e5                	mov    %esp,%ebp
  80951e:	53                   	push   %ebx
  80951f:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809522:	ba 02 00 00 00       	mov    $0x2,%edx
  809527:	8b 45 0c             	mov    0xc(%ebp),%eax
  80952a:	e8 3a fb ff ff       	call   809069 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80952f:	84 c0                	test   %al,%al
  809531:	78 31                	js     809564 <etharp_find_addr+0x49>
  809533:	0f be d0             	movsbl %al,%edx
  809536:	6b d2 1c             	imul   $0x1c,%edx,%edx
  809539:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  809540:	75 29                	jne    80956b <etharp_find_addr+0x50>
  809542:	0f be d0             	movsbl %al,%edx
  809545:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809548:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  80954e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809551:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809553:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  809559:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80955c:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  80955e:	83 c4 04             	add    $0x4,%esp
  809561:	5b                   	pop    %ebx
  809562:	5d                   	pop    %ebp
  809563:	c3                   	ret    
  return -1;
  809564:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809569:	eb f3                	jmp    80955e <etharp_find_addr+0x43>
  80956b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809570:	eb ec                	jmp    80955e <etharp_find_addr+0x43>

00809572 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809572:	55                   	push   %ebp
  809573:	89 e5                	mov    %esp,%ebp
  809575:	83 ec 08             	sub    $0x8,%esp
  809578:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80957b:	85 c0                	test   %eax,%eax
  80957d:	74 13                	je     809592 <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80957f:	8b 55 0c             	mov    0xc(%ebp),%edx
  809582:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809585:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809588:	33 48 04             	xor    0x4(%eax),%ecx
  80958b:	85 48 08             	test   %ecx,0x8(%eax)
  80958e:	74 19                	je     8095a9 <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809590:	c9                   	leave  
  809591:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809592:	83 ec 04             	sub    $0x4,%esp
  809595:	68 02 1a 81 00       	push   $0x811a02
  80959a:	68 48 02 00 00       	push   $0x248
  80959f:	68 7a 26 81 00       	push   $0x81267a
  8095a4:	e8 ff 4f 00 00       	call   80e5a8 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8095a9:	8d 4a 06             	lea    0x6(%edx),%ecx
  8095ac:	83 c2 1c             	add    $0x1c,%edx
  8095af:	83 ec 0c             	sub    $0xc,%esp
  8095b2:	6a 00                	push   $0x0
  8095b4:	e8 c3 fd ff ff       	call   80937c <update_arp_entry>
  8095b9:	83 c4 10             	add    $0x10,%esp
  8095bc:	eb d2                	jmp    809590 <etharp_ip_input+0x1e>

008095be <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8095be:	55                   	push   %ebp
  8095bf:	89 e5                	mov    %esp,%ebp
  8095c1:	57                   	push   %edi
  8095c2:	56                   	push   %esi
  8095c3:	53                   	push   %ebx
  8095c4:	83 ec 1c             	sub    $0x1c,%esp
  8095c7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8095ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8095ce:	74 4d                	je     80961d <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8095d0:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8095d5:	76 5d                	jbe    809634 <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8095d7:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8095da:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8095de:	83 ec 0c             	sub    $0xc,%esp
  8095e1:	6a 01                	push   $0x1
  8095e3:	e8 d5 e0 ff ff       	call   8076bd <htons>
  8095e8:	83 c4 10             	add    $0x10,%esp
  8095eb:	66 39 c7             	cmp    %ax,%di
  8095ee:	75 19                	jne    809609 <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8095f0:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  8095f4:	83 ec 0c             	sub    $0xc,%esp
  8095f7:	68 04 06 00 00       	push   $0x604
  8095fc:	e8 bc e0 ff ff       	call   8076bd <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809601:	83 c4 10             	add    $0x10,%esp
  809604:	66 39 c7             	cmp    %ax,%di
  809607:	74 39                	je     809642 <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809609:	83 ec 0c             	sub    $0xc,%esp
  80960c:	53                   	push   %ebx
  80960d:	e8 d1 b1 ff ff       	call   8047e3 <pbuf_free>
    return;
  809612:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809615:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809618:	5b                   	pop    %ebx
  809619:	5e                   	pop    %esi
  80961a:	5f                   	pop    %edi
  80961b:	5d                   	pop    %ebp
  80961c:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80961d:	83 ec 04             	sub    $0x4,%esp
  809620:	68 02 1a 81 00       	push   $0x811a02
  809625:	68 75 02 00 00       	push   $0x275
  80962a:	68 7a 26 81 00       	push   $0x81267a
  80962f:	e8 74 4f 00 00       	call   80e5a8 <_panic>
    pbuf_free(p);
  809634:	83 ec 0c             	sub    $0xc,%esp
  809637:	53                   	push   %ebx
  809638:	e8 a6 b1 ff ff       	call   8047e3 <pbuf_free>
    return;
  80963d:	83 c4 10             	add    $0x10,%esp
  809640:	eb d3                	jmp    809615 <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809642:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809646:	83 ec 0c             	sub    $0xc,%esp
  809649:	68 00 08 00 00       	push   $0x800
  80964e:	e8 6a e0 ff ff       	call   8076bd <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809653:	83 c4 10             	add    $0x10,%esp
  809656:	66 39 c7             	cmp    %ax,%di
  809659:	75 ae                	jne    809609 <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80965b:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80965f:	83 ec 0c             	sub    $0xc,%esp
  809662:	68 06 08 00 00       	push   $0x806
  809667:	e8 51 e0 ff ff       	call   8076bd <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80966c:	83 c4 10             	add    $0x10,%esp
  80966f:	66 39 c7             	cmp    %ax,%di
  809672:	75 95                	jne    809609 <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809674:	83 ec 04             	sub    $0x4,%esp
  809677:	6a 04                	push   $0x4
  809679:	8d 46 1c             	lea    0x1c(%esi),%eax
  80967c:	50                   	push   %eax
  80967d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809680:	50                   	push   %eax
  809681:	e8 67 59 00 00       	call   80efed <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809686:	83 c4 0c             	add    $0xc,%esp
  809689:	6a 04                	push   $0x4
  80968b:	8d 46 26             	lea    0x26(%esi),%eax
  80968e:	50                   	push   %eax
  80968f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809692:	50                   	push   %eax
  809693:	e8 55 59 00 00       	call   80efed <memcpy>
  if (netif->ip_addr.addr == 0) {
  809698:	8b 45 08             	mov    0x8(%ebp),%eax
  80969b:	8b 40 04             	mov    0x4(%eax),%eax
  80969e:	83 c4 10             	add    $0x10,%esp
  8096a1:	85 c0                	test   %eax,%eax
  8096a3:	74 05                	je     8096aa <etharp_arp_input+0xec>
  if (for_us) {
  8096a5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8096a8:	74 39                	je     8096e3 <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8096aa:	8d 4e 16             	lea    0x16(%esi),%ecx
  8096ad:	83 ec 0c             	sub    $0xc,%esp
  8096b0:	6a 00                	push   $0x0
  8096b2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8096b5:	8b 45 08             	mov    0x8(%ebp),%eax
  8096b8:	e8 bf fc ff ff       	call   80937c <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8096bd:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8096c1:	89 04 24             	mov    %eax,(%esp)
  8096c4:	e8 f4 df ff ff       	call   8076bd <htons>
  8096c9:	83 c4 10             	add    $0x10,%esp
  8096cc:	66 83 f8 02          	cmp    $0x2,%ax
  8096d0:	74 3f                	je     809711 <etharp_arp_input+0x153>
  pbuf_free(p);
  8096d2:	83 ec 0c             	sub    $0xc,%esp
  8096d5:	53                   	push   %ebx
  8096d6:	e8 08 b1 ff ff       	call   8047e3 <pbuf_free>
  8096db:	83 c4 10             	add    $0x10,%esp
  8096de:	e9 32 ff ff ff       	jmp    809615 <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8096e3:	8d 4e 16             	lea    0x16(%esi),%ecx
  8096e6:	83 ec 0c             	sub    $0xc,%esp
  8096e9:	6a 01                	push   $0x1
  8096eb:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8096ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8096f1:	e8 86 fc ff ff       	call   80937c <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8096f6:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8096fa:	89 04 24             	mov    %eax,(%esp)
  8096fd:	e8 bb df ff ff       	call   8076bd <htons>
  809702:	83 c4 10             	add    $0x10,%esp
  809705:	66 83 f8 01          	cmp    $0x1,%ax
  809709:	74 1a                	je     809725 <etharp_arp_input+0x167>
  80970b:	66 83 f8 02          	cmp    $0x2,%ax
  80970f:	75 c1                	jne    8096d2 <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  809711:	83 ec 08             	sub    $0x8,%esp
  809714:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809717:	50                   	push   %eax
  809718:	ff 75 08             	pushl  0x8(%ebp)
  80971b:	e8 70 a1 ff ff       	call   803890 <dhcp_arp_reply>
    break;
  809720:	83 c4 10             	add    $0x10,%esp
  809723:	eb ad                	jmp    8096d2 <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  809725:	83 ec 0c             	sub    $0xc,%esp
  809728:	6a 02                	push   $0x2
  80972a:	e8 8e df ff ff       	call   8076bd <htons>
  80972f:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809733:	8b 46 1c             	mov    0x1c(%esi),%eax
  809736:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809739:	8b 45 08             	mov    0x8(%ebp),%eax
  80973c:	8b 40 04             	mov    0x4(%eax),%eax
  80973f:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809742:	83 c4 10             	add    $0x10,%esp
  809745:	8b 45 08             	mov    0x8(%ebp),%eax
  809748:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80974c:	75 0b                	jne    809759 <etharp_arp_input+0x19b>
  80974e:	8d 46 05             	lea    0x5(%esi),%eax
  809751:	8b 55 0c             	mov    0xc(%ebp),%edx
  809754:	83 c2 05             	add    $0x5,%edx
  809757:	eb 19                	jmp    809772 <etharp_arp_input+0x1b4>
  809759:	83 ec 04             	sub    $0x4,%esp
  80975c:	68 f0 26 81 00       	push   $0x8126f0
  809761:	68 c7 02 00 00       	push   $0x2c7
  809766:	68 7a 26 81 00       	push   $0x81267a
  80976b:	e8 38 4e 00 00       	call   80e5a8 <_panic>
  809770:	89 c8                	mov    %ecx,%eax
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809772:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809776:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809779:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80977b:	0f b6 0a             	movzbl (%edx),%ecx
  80977e:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809781:	88 48 06             	mov    %cl,0x6(%eax)
  809784:	8d 48 ff             	lea    -0x1(%eax),%ecx
  809787:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  80978a:	39 f0                	cmp    %esi,%eax
  80978c:	75 e2                	jne    809770 <etharp_arp_input+0x1b2>
      netif->linkoutput(netif, p);
  80978e:	83 ec 08             	sub    $0x8,%esp
  809791:	53                   	push   %ebx
  809792:	ff 75 08             	pushl  0x8(%ebp)
  809795:	8b 45 08             	mov    0x8(%ebp),%eax
  809798:	ff 50 18             	call   *0x18(%eax)
  80979b:	83 c4 10             	add    $0x10,%esp
  80979e:	e9 2f ff ff ff       	jmp    8096d2 <etharp_arp_input+0x114>

008097a3 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8097a3:	55                   	push   %ebp
  8097a4:	89 e5                	mov    %esp,%ebp
  8097a6:	57                   	push   %edi
  8097a7:	56                   	push   %esi
  8097a8:	53                   	push   %ebx
  8097a9:	83 ec 10             	sub    $0x10,%esp
  8097ac:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8097af:	6a 00                	push   $0x0
  8097b1:	6a 2a                	push   $0x2a
  8097b3:	6a 02                	push   $0x2
  8097b5:	e8 ef b0 ff ff       	call   8048a9 <pbuf_alloc>
  if (p == NULL) {
  8097ba:	83 c4 10             	add    $0x10,%esp
  8097bd:	85 c0                	test   %eax,%eax
  8097bf:	0f 84 f8 00 00 00    	je     8098bd <etharp_request+0x11a>
  8097c5:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8097c7:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8097cc:	0f 86 bd 00 00 00    	jbe    80988f <etharp_request+0xec>
  hdr = p->payload;
  8097d2:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8097d5:	83 ec 0c             	sub    $0xc,%esp
  8097d8:	6a 01                	push   $0x1
  8097da:	e8 de de ff ff       	call   8076bd <htons>
  8097df:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8097e3:	83 c4 10             	add    $0x10,%esp
  8097e6:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8097ea:	0f 85 b6 00 00 00    	jne    8098a6 <etharp_request+0x103>
  8097f0:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  8097f5:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8097fa:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8097fe:	0f b6 90 dc 27 81 00 	movzbl 0x8127dc(%eax),%edx
  809805:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809809:	0f b6 90 e4 27 81 00 	movzbl 0x8127e4(%eax),%edx
  809810:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809813:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809818:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  80981c:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  80981f:	83 f8 ff             	cmp    $0xffffffff,%eax
  809822:	75 d1                	jne    8097f5 <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809824:	8b 46 04             	mov    0x4(%esi),%eax
  809827:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80982a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80982d:	8b 00                	mov    (%eax),%eax
  80982f:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809832:	83 ec 0c             	sub    $0xc,%esp
  809835:	6a 01                	push   $0x1
  809837:	e8 81 de ff ff       	call   8076bd <htons>
  80983c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809840:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809847:	e8 71 de ff ff       	call   8076bd <htons>
  80984c:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809850:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809857:	e8 61 de ff ff       	call   8076bd <htons>
  80985c:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809860:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809867:	e8 51 de ff ff       	call   8076bd <htons>
  80986c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809870:	83 c4 08             	add    $0x8,%esp
  809873:	57                   	push   %edi
  809874:	56                   	push   %esi
  809875:	ff 56 18             	call   *0x18(%esi)
  809878:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  80987a:	89 3c 24             	mov    %edi,(%esp)
  80987d:	e8 61 af ff ff       	call   8047e3 <pbuf_free>
  809882:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809885:	89 d8                	mov    %ebx,%eax
  809887:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80988a:	5b                   	pop    %ebx
  80988b:	5e                   	pop    %esi
  80988c:	5f                   	pop    %edi
  80988d:	5d                   	pop    %ebp
  80988e:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80988f:	83 ec 04             	sub    $0x4,%esp
  809892:	68 5c 27 81 00       	push   $0x81275c
  809897:	68 1c 04 00 00       	push   $0x41c
  80989c:	68 7a 26 81 00       	push   $0x81267a
  8098a1:	e8 02 4d 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8098a6:	83 ec 04             	sub    $0x4,%esp
  8098a9:	68 f0 26 81 00       	push   $0x8126f0
  8098ae:	68 23 04 00 00       	push   $0x423
  8098b3:	68 7a 26 81 00       	push   $0x81267a
  8098b8:	e8 eb 4c 00 00       	call   80e5a8 <_panic>
    return ERR_MEM;
  8098bd:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  8098c2:	eb c1                	jmp    809885 <etharp_request+0xe2>

008098c4 <etharp_query>:
{
  8098c4:	55                   	push   %ebp
  8098c5:	89 e5                	mov    %esp,%ebp
  8098c7:	57                   	push   %edi
  8098c8:	56                   	push   %esi
  8098c9:	53                   	push   %ebx
  8098ca:	83 ec 14             	sub    $0x14,%esp
  8098cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8098d0:	ff 75 08             	pushl  0x8(%ebp)
  8098d3:	53                   	push   %ebx
  8098d4:	e8 81 cb ff ff       	call   80645a <ip_addr_isbroadcast>
  8098d9:	83 c4 10             	add    $0x10,%esp
  8098dc:	84 c0                	test   %al,%al
  8098de:	0f 85 a2 01 00 00    	jne    809a86 <etharp_query+0x1c2>
      ip_addr_ismulticast(ipaddr) ||
  8098e4:	8b 33                	mov    (%ebx),%esi
  8098e6:	83 ec 0c             	sub    $0xc,%esp
  8098e9:	68 00 00 00 f0       	push   $0xf0000000
  8098ee:	e8 fb df ff ff       	call   8078ee <ntohl>
  8098f3:	21 c6                	and    %eax,%esi
  8098f5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8098fc:	e8 ed df ff ff       	call   8078ee <ntohl>
  809901:	83 c4 10             	add    $0x10,%esp
  809904:	39 c6                	cmp    %eax,%esi
  809906:	0f 84 84 01 00 00    	je     809a90 <etharp_query+0x1cc>
      ip_addr_isany(ipaddr)) {
  80990c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80990f:	0f 84 85 01 00 00    	je     809a9a <etharp_query+0x1d6>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809915:	ba 01 00 00 00       	mov    $0x1,%edx
  80991a:	89 d8                	mov    %ebx,%eax
  80991c:	e8 48 f7 ff ff       	call   809069 <find_entry>
  809921:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  809923:	84 c0                	test   %al,%al
  809925:	0f 88 79 01 00 00    	js     809aa4 <etharp_query+0x1e0>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80992b:	0f be f8             	movsbl %al,%edi
  80992e:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809931:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809937:	85 c0                	test   %eax,%eax
  809939:	75 26                	jne    809961 <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80993b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80993e:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  809945:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809948:	83 ec 08             	sub    $0x8,%esp
  80994b:	53                   	push   %ebx
  80994c:	ff 75 08             	pushl  0x8(%ebp)
  80994f:	e8 4f fe ff ff       	call   8097a3 <etharp_request>
  809954:	89 c3                	mov    %eax,%ebx
  if (q != NULL) {
  809956:	83 c4 10             	add    $0x10,%esp
  809959:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80995d:	74 2d                	je     80998c <etharp_query+0xc8>
  80995f:	eb 18                	jmp    809979 <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809961:	8d 50 ff             	lea    -0x1(%eax),%edx
  809964:	83 fa 01             	cmp    $0x1,%edx
  809967:	77 2d                	ja     809996 <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809969:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80996d:	74 d9                	je     809948 <etharp_query+0x84>
  80996f:	83 f8 01             	cmp    $0x1,%eax
  809972:	74 d4                	je     809948 <etharp_query+0x84>
  err_t result = ERR_MEM;
  809974:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809979:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80997c:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809982:	83 f8 02             	cmp    $0x2,%eax
  809985:	74 26                	je     8099ad <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809987:	83 f8 01             	cmp    $0x1,%eax
  80998a:	74 4a                	je     8099d6 <etharp_query+0x112>
}
  80998c:	89 d8                	mov    %ebx,%eax
  80998e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809991:	5b                   	pop    %ebx
  809992:	5e                   	pop    %esi
  809993:	5f                   	pop    %edi
  809994:	5d                   	pop    %ebp
  809995:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809996:	83 ec 04             	sub    $0x4,%esp
  809999:	68 90 27 81 00       	push   $0x812790
  80999e:	68 92 03 00 00       	push   $0x392
  8099a3:	68 7a 26 81 00       	push   $0x81267a
  8099a8:	e8 fb 4b 00 00       	call   80e5a8 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  8099ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8099b0:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  8099b3:	83 ec 0c             	sub    $0xc,%esp
  8099b6:	89 f0                	mov    %esi,%eax
  8099b8:	0f be c0             	movsbl %al,%eax
  8099bb:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8099be:	05 28 4a b3 00       	add    $0xb34a28,%eax
  8099c3:	50                   	push   %eax
  8099c4:	8b 55 10             	mov    0x10(%ebp),%edx
  8099c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8099ca:	e8 3a f9 ff ff       	call   809309 <etharp_send_ip>
  8099cf:	89 c3                	mov    %eax,%ebx
  8099d1:	83 c4 10             	add    $0x10,%esp
  8099d4:	eb b6                	jmp    80998c <etharp_query+0xc8>
      p = q;
  8099d6:	8b 45 10             	mov    0x10(%ebp),%eax
  8099d9:	eb 27                	jmp    809a02 <etharp_query+0x13e>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  8099db:	83 ec 04             	sub    $0x4,%esp
  8099de:	68 d6 26 81 00       	push   $0x8126d6
  8099e3:	68 b1 03 00 00       	push   $0x3b1
  8099e8:	68 7a 26 81 00       	push   $0x81267a
  8099ed:	e8 b6 4b 00 00       	call   80e5a8 <_panic>
        if(p->type != PBUF_ROM) {
  8099f2:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  8099f6:	75 23                	jne    809a1b <etharp_query+0x157>
        p = p->next;
  8099f8:	8b 00                	mov    (%eax),%eax
      while (p) {
  8099fa:	85 c0                	test   %eax,%eax
  8099fc:	0f 84 a9 00 00 00    	je     809aab <etharp_query+0x1e7>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809a02:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809a06:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809a0a:	75 e6                	jne    8099f2 <etharp_query+0x12e>
  809a0c:	83 38 00             	cmpl   $0x0,(%eax)
  809a0f:	75 ca                	jne    8099db <etharp_query+0x117>
        if(p->type != PBUF_ROM) {
  809a11:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a15:	0f 84 90 00 00 00    	je     809aab <etharp_query+0x1e7>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a1b:	83 ec 04             	sub    $0x4,%esp
  809a1e:	6a 00                	push   $0x0
  809a20:	0f b7 d2             	movzwl %dx,%edx
  809a23:	52                   	push   %edx
  809a24:	6a 03                	push   $0x3
  809a26:	e8 7e ae ff ff       	call   8048a9 <pbuf_alloc>
  809a2b:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809a2d:	83 c4 10             	add    $0x10,%esp
  809a30:	85 c0                	test   %eax,%eax
  809a32:	0f 84 54 ff ff ff    	je     80998c <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  809a38:	83 ec 08             	sub    $0x8,%esp
  809a3b:	ff 75 10             	pushl  0x10(%ebp)
  809a3e:	56                   	push   %esi
  809a3f:	e8 47 b3 ff ff       	call   804d8b <pbuf_copy>
  809a44:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809a47:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809a4a:	84 c0                	test   %al,%al
  809a4c:	74 6b                	je     809ab9 <etharp_query+0x1f5>
            pbuf_free(p);
  809a4e:	83 ec 0c             	sub    $0xc,%esp
  809a51:	56                   	push   %esi
  809a52:	e8 8c ad ff ff       	call   8047e3 <pbuf_free>
  809a57:	83 c4 10             	add    $0x10,%esp
  809a5a:	e9 2d ff ff ff       	jmp    80998c <etharp_query+0xc8>
              r = r->next;
  809a5f:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809a61:	8b 11                	mov    (%ecx),%edx
  809a63:	85 d2                	test   %edx,%edx
  809a65:	75 f8                	jne    809a5f <etharp_query+0x19b>
            r->next = new_entry;
  809a67:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809a69:	bb 00 00 00 00       	mov    $0x0,%ebx
  809a6e:	e9 19 ff ff ff       	jmp    80998c <etharp_query+0xc8>
          pbuf_free(p);
  809a73:	83 ec 0c             	sub    $0xc,%esp
  809a76:	ff 75 10             	pushl  0x10(%ebp)
  809a79:	e8 65 ad ff ff       	call   8047e3 <pbuf_free>
  809a7e:	83 c4 10             	add    $0x10,%esp
  809a81:	e9 06 ff ff ff       	jmp    80998c <etharp_query+0xc8>
    return ERR_ARG;
  809a86:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809a8b:	e9 fc fe ff ff       	jmp    80998c <etharp_query+0xc8>
  809a90:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809a95:	e9 f2 fe ff ff       	jmp    80998c <etharp_query+0xc8>
  809a9a:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809a9f:	e9 e8 fe ff ff       	jmp    80998c <etharp_query+0xc8>
    return (err_t)i;
  809aa4:	89 c3                	mov    %eax,%ebx
  809aa6:	e9 e1 fe ff ff       	jmp    80998c <etharp_query+0xc8>
        pbuf_ref(p);
  809aab:	83 ec 0c             	sub    $0xc,%esp
  809aae:	ff 75 10             	pushl  0x10(%ebp)
  809ab1:	e8 8f b1 ff ff       	call   804c45 <pbuf_ref>
  809ab6:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809ab9:	83 ec 0c             	sub    $0xc,%esp
  809abc:	6a 0a                	push   $0xa
  809abe:	e8 7d a9 ff ff       	call   804440 <memp_malloc>
        if (new_entry != NULL) {
  809ac3:	83 c4 10             	add    $0x10,%esp
  809ac6:	85 c0                	test   %eax,%eax
  809ac8:	74 a9                	je     809a73 <etharp_query+0x1af>
          new_entry->next = 0;
  809aca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809ad0:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809ad3:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809ad6:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809ad9:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  809adf:	85 c9                	test   %ecx,%ecx
  809ae1:	0f 85 7a ff ff ff    	jne    809a61 <etharp_query+0x19d>
            arp_table[i].q = new_entry;
  809ae7:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809aea:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809af0:	bb 00 00 00 00       	mov    $0x0,%ebx
  809af5:	e9 92 fe ff ff       	jmp    80998c <etharp_query+0xc8>

00809afa <etharp_output>:
{
  809afa:	55                   	push   %ebp
  809afb:	89 e5                	mov    %esp,%ebp
  809afd:	57                   	push   %edi
  809afe:	56                   	push   %esi
  809aff:	53                   	push   %ebx
  809b00:	83 ec 24             	sub    $0x24,%esp
  809b03:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809b06:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809b09:	6a 0e                	push   $0xe
  809b0b:	ff 75 0c             	pushl  0xc(%ebp)
  809b0e:	e8 03 ac ff ff       	call   804716 <pbuf_header>
  809b13:	83 c4 10             	add    $0x10,%esp
  809b16:	84 c0                	test   %al,%al
  809b18:	0f 85 c0 00 00 00    	jne    809bde <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809b1e:	83 ec 08             	sub    $0x8,%esp
  809b21:	53                   	push   %ebx
  809b22:	56                   	push   %esi
  809b23:	e8 32 c9 ff ff       	call   80645a <ip_addr_isbroadcast>
  809b28:	83 c4 10             	add    $0x10,%esp
  809b2b:	84 c0                	test   %al,%al
  809b2d:	0f 85 8a 00 00 00    	jne    809bbd <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809b33:	8b 3e                	mov    (%esi),%edi
  809b35:	83 ec 0c             	sub    $0xc,%esp
  809b38:	68 00 00 00 f0       	push   $0xf0000000
  809b3d:	e8 ac dd ff ff       	call   8078ee <ntohl>
  809b42:	21 c7                	and    %eax,%edi
  809b44:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809b4b:	e8 9e dd ff ff       	call   8078ee <ntohl>
  809b50:	83 c4 10             	add    $0x10,%esp
  809b53:	39 c7                	cmp    %eax,%edi
  809b55:	74 25                	je     809b7c <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809b57:	8b 06                	mov    (%esi),%eax
  809b59:	33 43 04             	xor    0x4(%ebx),%eax
  809b5c:	85 43 08             	test   %eax,0x8(%ebx)
  809b5f:	74 09                	je     809b6a <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809b61:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809b65:	74 7e                	je     809be5 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809b67:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809b6a:	83 ec 04             	sub    $0x4,%esp
  809b6d:	ff 75 0c             	pushl  0xc(%ebp)
  809b70:	56                   	push   %esi
  809b71:	53                   	push   %ebx
  809b72:	e8 4d fd ff ff       	call   8098c4 <etharp_query>
  809b77:	83 c4 10             	add    $0x10,%esp
  809b7a:	eb 5a                	jmp    809bd6 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809b7c:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809b80:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809b84:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809b88:	83 ec 0c             	sub    $0xc,%esp
  809b8b:	ff 36                	pushl  (%esi)
  809b8d:	e8 5c dd ff ff       	call   8078ee <ntohl>
  809b92:	c1 e8 10             	shr    $0x10,%eax
  809b95:	83 e0 7f             	and    $0x7f,%eax
  809b98:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809b9b:	83 c4 04             	add    $0x4,%esp
  809b9e:	ff 36                	pushl  (%esi)
  809ba0:	e8 49 dd ff ff       	call   8078ee <ntohl>
  809ba5:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809ba8:	83 c4 04             	add    $0x4,%esp
  809bab:	ff 36                	pushl  (%esi)
  809bad:	e8 3c dd ff ff       	call   8078ee <ntohl>
  809bb2:	88 45 e7             	mov    %al,-0x19(%ebp)
  809bb5:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809bb8:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809bbb:	eb 05                	jmp    809bc2 <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809bbd:	b8 e4 27 81 00       	mov    $0x8127e4,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809bc2:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809bc5:	83 ec 0c             	sub    $0xc,%esp
  809bc8:	50                   	push   %eax
  809bc9:	8b 55 0c             	mov    0xc(%ebp),%edx
  809bcc:	89 d8                	mov    %ebx,%eax
  809bce:	e8 36 f7 ff ff       	call   809309 <etharp_send_ip>
  809bd3:	83 c4 10             	add    $0x10,%esp
}
  809bd6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809bd9:	5b                   	pop    %ebx
  809bda:	5e                   	pop    %esi
  809bdb:	5f                   	pop    %edi
  809bdc:	5d                   	pop    %ebp
  809bdd:	c3                   	ret    
    return ERR_BUF;
  809bde:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809be3:	eb f1                	jmp    809bd6 <etharp_output+0xdc>
        return ERR_RTE;
  809be5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809bea:	eb ea                	jmp    809bd6 <etharp_output+0xdc>

00809bec <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809bec:	55                   	push   %ebp
  809bed:	89 e5                	mov    %esp,%ebp
  809bef:	56                   	push   %esi
  809bf0:	53                   	push   %ebx
  809bf1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809bf4:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809bf7:	83 ec 0c             	sub    $0xc,%esp
  809bfa:	8b 43 04             	mov    0x4(%ebx),%eax
  809bfd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809c01:	50                   	push   %eax
  809c02:	e8 b6 da ff ff       	call   8076bd <htons>
  809c07:	83 c4 10             	add    $0x10,%esp
  809c0a:	66 3d 00 08          	cmp    $0x800,%ax
  809c0e:	74 14                	je     809c24 <ethernet_input+0x38>
  809c10:	66 3d 06 08          	cmp    $0x806,%ax
  809c14:	74 50                	je     809c66 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809c16:	83 ec 0c             	sub    $0xc,%esp
  809c19:	53                   	push   %ebx
  809c1a:	e8 c4 ab ff ff       	call   8047e3 <pbuf_free>
      p = NULL;
      break;
  809c1f:	83 c4 10             	add    $0x10,%esp
  809c22:	eb 53                	jmp    809c77 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809c24:	83 ec 08             	sub    $0x8,%esp
  809c27:	53                   	push   %ebx
  809c28:	56                   	push   %esi
  809c29:	e8 44 f9 ff ff       	call   809572 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809c2e:	83 c4 08             	add    $0x8,%esp
  809c31:	6a f2                	push   $0xfffffff2
  809c33:	53                   	push   %ebx
  809c34:	e8 dd aa ff ff       	call   804716 <pbuf_header>
  809c39:	83 c4 10             	add    $0x10,%esp
  809c3c:	84 c0                	test   %al,%al
  809c3e:	75 0f                	jne    809c4f <ethernet_input+0x63>
        ip_input(p, netif);
  809c40:	83 ec 08             	sub    $0x8,%esp
  809c43:	56                   	push   %esi
  809c44:	53                   	push   %ebx
  809c45:	e8 b0 c8 ff ff       	call   8064fa <ip_input>
      break;
  809c4a:	83 c4 10             	add    $0x10,%esp
  809c4d:	eb 28                	jmp    809c77 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809c4f:	83 ec 04             	sub    $0x4,%esp
  809c52:	68 b8 27 81 00       	push   $0x8127b8
  809c57:	68 7e 04 00 00       	push   $0x47e
  809c5c:	68 7a 26 81 00       	push   $0x81267a
  809c61:	e8 42 49 00 00       	call   80e5a8 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809c66:	83 ec 04             	sub    $0x4,%esp
  809c69:	53                   	push   %ebx
  809c6a:	8d 46 25             	lea    0x25(%esi),%eax
  809c6d:	50                   	push   %eax
  809c6e:	56                   	push   %esi
  809c6f:	e8 4a f9 ff ff       	call   8095be <etharp_arp_input>
      break;
  809c74:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809c77:	b8 00 00 00 00       	mov    $0x0,%eax
  809c7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809c7f:	5b                   	pop    %ebx
  809c80:	5e                   	pop    %esi
  809c81:	5d                   	pop    %ebp
  809c82:	c3                   	ret    

00809c83 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809c83:	55                   	push   %ebp
  809c84:	89 e5                	mov    %esp,%ebp
  809c86:	53                   	push   %ebx
  809c87:	83 ec 10             	sub    $0x10,%esp
  809c8a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809c8d:	ff 73 04             	pushl  0x4(%ebx)
  809c90:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809c92:	89 1c 24             	mov    %ebx,(%esp)
  809c95:	e8 b4 6a 00 00       	call   81074e <free>
}
  809c9a:	83 c4 10             	add    $0x10,%esp
  809c9d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809ca0:	c9                   	leave  
  809ca1:	c3                   	ret    

00809ca2 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809ca2:	55                   	push   %ebp
  809ca3:	89 e5                	mov    %esp,%ebp
  809ca5:	83 ec 08             	sub    $0x8,%esp
  809ca8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809cab:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809cb0:	89 c8                	mov    %ecx,%eax
  809cb2:	f7 e2                	mul    %edx
  809cb4:	c1 ea 08             	shr    $0x8,%edx
  809cb7:	89 d0                	mov    %edx,%eax
  809cb9:	c1 e0 08             	shl    $0x8,%eax
  809cbc:	01 c2                	add    %eax,%edx
  809cbe:	89 c8                	mov    %ecx,%eax
  809cc0:	29 d0                	sub    %edx,%eax
  809cc2:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809cc9:	85 c0                	test   %eax,%eax
  809ccb:	74 2a                	je     809cf7 <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809ccd:	39 08                	cmp    %ecx,(%eax)
  809ccf:	74 05                	je     809cd6 <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809cd1:	8b 40 08             	mov    0x8(%eax),%eax
  809cd4:	eb f3                	jmp    809cc9 <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809cd6:	8b 50 08             	mov    0x8(%eax),%edx
  809cd9:	85 d2                	test   %edx,%edx
  809cdb:	74 06                	je     809ce3 <timeout_cleanup+0x41>
  809cdd:	8b 48 0c             	mov    0xc(%eax),%ecx
  809ce0:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809ce3:	8b 50 0c             	mov    0xc(%eax),%edx
  809ce6:	8b 48 08             	mov    0x8(%eax),%ecx
  809ce9:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809ceb:	83 ec 0c             	sub    $0xc,%esp
  809cee:	50                   	push   %eax
  809cef:	e8 5a 6a 00 00       	call   81074e <free>
	    goto done;
  809cf4:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809cf7:	c9                   	leave  
  809cf8:	c3                   	ret    

00809cf9 <sys_init>:
{
  809cf9:	55                   	push   %ebp
  809cfa:	89 e5                	mov    %esp,%ebp
  809cfc:	56                   	push   %esi
  809cfd:	53                   	push   %ebx
  809cfe:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809d04:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809d09:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809d0e:	eb 10                	jmp    809d20 <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809d10:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809d17:	83 c0 14             	add    $0x14,%eax
  809d1a:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809d1c:	39 f0                	cmp    %esi,%eax
  809d1e:	74 17                	je     809d37 <sys_init+0x3e>
  809d20:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809d22:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809d28:	89 50 0c             	mov    %edx,0xc(%eax)
  809d2b:	85 d2                	test   %edx,%edx
  809d2d:	74 e1                	je     809d10 <sys_init+0x17>
  809d2f:	8d 58 0c             	lea    0xc(%eax),%ebx
  809d32:	89 5a 10             	mov    %ebx,0x10(%edx)
  809d35:	eb d9                	jmp    809d10 <sys_init+0x17>
  809d37:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809d3e:	b1 b3 00 
  809d41:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809d47:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809d4c:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809d51:	eb 15                	jmp    809d68 <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d53:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809d5a:	4f b3 00 
  809d5d:	05 9c 00 00 00       	add    $0x9c,%eax
  809d62:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809d64:	39 f0                	cmp    %esi,%eax
  809d66:	74 20                	je     809d88 <sys_init+0x8f>
  809d68:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809d6a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809d70:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809d76:	85 d2                	test   %edx,%edx
  809d78:	74 d9                	je     809d53 <sys_init+0x5a>
  809d7a:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809d80:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809d86:	eb cb                	jmp    809d53 <sys_init+0x5a>
  809d88:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809d8f:	9c b3 00 
}
  809d92:	5b                   	pop    %ebx
  809d93:	5e                   	pop    %esi
  809d94:	5d                   	pop    %ebp
  809d95:	c3                   	ret    

00809d96 <sys_sem_new>:
{
  809d96:	55                   	push   %ebp
  809d97:	89 e5                	mov    %esp,%ebp
  809d99:	53                   	push   %ebx
  809d9a:	83 ec 04             	sub    $0x4,%esp
  809d9d:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809da0:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809da5:	85 c0                	test   %eax,%eax
  809da7:	74 3e                	je     809de7 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809da9:	8b 48 0c             	mov    0xc(%eax),%ecx
  809dac:	85 c9                	test   %ecx,%ecx
  809dae:	74 06                	je     809db6 <sys_sem_new+0x20>
  809db0:	8b 58 10             	mov    0x10(%eax),%ebx
  809db3:	89 59 10             	mov    %ebx,0x10(%ecx)
  809db6:	8b 48 10             	mov    0x10(%eax),%ecx
  809db9:	8b 58 0c             	mov    0xc(%eax),%ebx
  809dbc:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809dbe:	83 38 00             	cmpl   $0x0,(%eax)
  809dc1:	74 3b                	je     809dfe <sys_sem_new+0x68>
    se->freed = 0;
  809dc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809dc9:	0f b6 d2             	movzbl %dl,%edx
  809dcc:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809dd0:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809dd4:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809dd9:	c1 f8 02             	sar    $0x2,%eax
  809ddc:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809de2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809de5:	c9                   	leave  
  809de6:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809de7:	83 ec 0c             	sub    $0xc,%esp
  809dea:	68 ec 27 81 00       	push   $0x8127ec
  809def:	e8 aa 48 00 00       	call   80e69e <cprintf>
	return SYS_SEM_NULL;
  809df4:	83 c4 10             	add    $0x10,%esp
  809df7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809dfc:	eb e4                	jmp    809de2 <sys_sem_new+0x4c>
    assert(se->freed);
  809dfe:	68 61 29 81 00       	push   $0x812961
  809e03:	68 6b 29 81 00       	push   $0x81296b
  809e08:	68 8d 00 00 00       	push   $0x8d
  809e0d:	68 80 29 81 00       	push   $0x812980
  809e12:	e8 91 47 00 00       	call   80e5a8 <_panic>

00809e17 <sys_sem_free>:
{
  809e17:	55                   	push   %ebp
  809e18:	89 e5                	mov    %esp,%ebp
  809e1a:	83 ec 08             	sub    $0x8,%esp
  809e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809e20:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809e23:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809e2a:	00 
  809e2b:	75 5a                	jne    809e87 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809e2d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809e30:	c1 e2 02             	shl    $0x2,%edx
  809e33:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809e39:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809e40:	00 00 00 
    sems[sem].gen++;
  809e43:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809e47:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809e4d:	89 51 0c             	mov    %edx,0xc(%ecx)
  809e50:	85 d2                	test   %edx,%edx
  809e52:	74 0d                	je     809e61 <sys_sem_free+0x4a>
  809e54:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809e57:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809e5e:	89 4a 10             	mov    %ecx,0x10(%edx)
  809e61:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809e68:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809e6b:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809e72:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809e78:	01 d0                	add    %edx,%eax
  809e7a:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809e81:	60 9d b3 00 
}
  809e85:	c9                   	leave  
  809e86:	c3                   	ret    
    assert(!sems[sem].freed);
  809e87:	68 9d 29 81 00       	push   $0x81299d
  809e8c:	68 6b 29 81 00       	push   $0x81296b
  809e91:	68 98 00 00 00       	push   $0x98
  809e96:	68 80 29 81 00       	push   $0x812980
  809e9b:	e8 08 47 00 00       	call   80e5a8 <_panic>

00809ea0 <sys_mbox_free>:
{
  809ea0:	55                   	push   %ebp
  809ea1:	89 e5                	mov    %esp,%ebp
  809ea3:	56                   	push   %esi
  809ea4:	53                   	push   %ebx
  809ea5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809ea8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809eae:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809eb5:	75 72                	jne    809f29 <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809eb7:	83 ec 0c             	sub    $0xc,%esp
  809eba:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809ec0:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809ec6:	e8 4c ff ff ff       	call   809e17 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809ecb:	83 c4 04             	add    $0x4,%esp
  809ece:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809ed4:	e8 3e ff ff ff       	call   809e17 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809ed9:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809ede:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809ee4:	83 c4 10             	add    $0x10,%esp
  809ee7:	85 c0                	test   %eax,%eax
  809ee9:	74 12                	je     809efd <sys_mbox_free+0x5d>
  809eeb:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809ef1:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809ef7:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809efd:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809f03:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809f09:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809f0e:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809f15:	4f b3 00 
    mboxes[mbox].freed = 1;
  809f18:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809f1f:	00 00 00 
}
  809f22:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809f25:	5b                   	pop    %ebx
  809f26:	5e                   	pop    %esi
  809f27:	5d                   	pop    %ebp
  809f28:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  809f29:	68 ae 29 81 00       	push   $0x8129ae
  809f2e:	68 6b 29 81 00       	push   $0x81296b
  809f33:	6a 62                	push   $0x62
  809f35:	68 80 29 81 00       	push   $0x812980
  809f3a:	e8 69 46 00 00       	call   80e5a8 <_panic>

00809f3f <sys_mbox_new>:
{
  809f3f:	55                   	push   %ebp
  809f40:	89 e5                	mov    %esp,%ebp
  809f42:	57                   	push   %edi
  809f43:	56                   	push   %esi
  809f44:	53                   	push   %ebx
  809f45:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  809f48:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809f4c:	0f 8f 9f 00 00 00    	jg     809ff1 <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809f52:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809f58:	85 db                	test   %ebx,%ebx
  809f5a:	0f 84 a7 00 00 00    	je     80a007 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  809f60:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  809f66:	85 c0                	test   %eax,%eax
  809f68:	74 0c                	je     809f76 <sys_mbox_new+0x37>
  809f6a:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  809f70:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809f76:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809f7c:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  809f82:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  809f84:	83 3b 00             	cmpl   $0x0,(%ebx)
  809f87:	0f 84 91 00 00 00    	je     80a01e <sys_mbox_new+0xdf>
    mbe->freed = 0;
  809f8d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  809f93:	89 de                	mov    %ebx,%esi
  809f95:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  809f9b:	c1 fe 02             	sar    $0x2,%esi
  809f9e:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  809fa4:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  809fa6:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  809fad:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  809fb4:	83 ec 0c             	sub    $0xc,%esp
  809fb7:	6a 00                	push   $0x0
  809fb9:	e8 d8 fd ff ff       	call   809d96 <sys_sem_new>
  809fbe:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  809fc4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  809fcb:	e8 c6 fd ff ff       	call   809d96 <sys_sem_new>
  809fd0:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  809fd6:	83 c4 10             	add    $0x10,%esp
  809fd9:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  809fe0:	74 52                	je     80a034 <sys_mbox_new+0xf5>
  809fe2:	83 f8 ff             	cmp    $0xffffffff,%eax
  809fe5:	74 4d                	je     80a034 <sys_mbox_new+0xf5>
}
  809fe7:	89 f8                	mov    %edi,%eax
  809fe9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809fec:	5b                   	pop    %ebx
  809fed:	5e                   	pop    %esi
  809fee:	5f                   	pop    %edi
  809fef:	5d                   	pop    %ebp
  809ff0:	c3                   	ret    
    assert(size < MBOXSLOTS);
  809ff1:	68 c2 29 81 00       	push   $0x8129c2
  809ff6:	68 6b 29 81 00       	push   $0x81296b
  809ffb:	6a 45                	push   $0x45
  809ffd:	68 80 29 81 00       	push   $0x812980
  80a002:	e8 a1 45 00 00       	call   80e5a8 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a007:	83 ec 0c             	sub    $0xc,%esp
  80a00a:	68 14 28 81 00       	push   $0x812814
  80a00f:	e8 8a 46 00 00       	call   80e69e <cprintf>
	return SYS_MBOX_NULL;
  80a014:	83 c4 10             	add    $0x10,%esp
  80a017:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a01c:	eb c9                	jmp    809fe7 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a01e:	68 d3 29 81 00       	push   $0x8129d3
  80a023:	68 6b 29 81 00       	push   $0x81296b
  80a028:	6a 4c                	push   $0x4c
  80a02a:	68 80 29 81 00       	push   $0x812980
  80a02f:	e8 74 45 00 00       	call   80e5a8 <_panic>
	sys_mbox_free(i);
  80a034:	83 ec 0c             	sub    $0xc,%esp
  80a037:	56                   	push   %esi
  80a038:	e8 63 fe ff ff       	call   809ea0 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a03d:	c7 04 24 3c 28 81 00 	movl   $0x81283c,(%esp)
  80a044:	e8 55 46 00 00       	call   80e69e <cprintf>
	return SYS_MBOX_NULL;
  80a049:	83 c4 10             	add    $0x10,%esp
  80a04c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a051:	eb 94                	jmp    809fe7 <sys_mbox_new+0xa8>

0080a053 <sys_sem_signal>:
{
  80a053:	55                   	push   %ebp
  80a054:	89 e5                	mov    %esp,%ebp
  80a056:	83 ec 08             	sub    $0x8,%esp
  80a059:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a05c:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a05f:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a066:	00 
  80a067:	75 18                	jne    80a081 <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a069:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a06c:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a073:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a078:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a07d:	75 1b                	jne    80a09a <sys_sem_signal+0x47>
}
  80a07f:	c9                   	leave  
  80a080:	c3                   	ret    
    assert(!sems[sem].freed);
  80a081:	68 9d 29 81 00       	push   $0x81299d
  80a086:	68 6b 29 81 00       	push   $0x81296b
  80a08b:	68 a1 00 00 00       	push   $0xa1
  80a090:	68 80 29 81 00       	push   $0x812980
  80a095:	e8 0e 45 00 00       	call   80e5a8 <_panic>
	sems[sem].waiters = 0;
  80a09a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a0a1:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a0a4:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a0ab:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a0ae:	83 ec 0c             	sub    $0xc,%esp
  80a0b1:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a0b8:	50                   	push   %eax
  80a0b9:	e8 a4 04 00 00       	call   80a562 <thread_wakeup>
  80a0be:	83 c4 10             	add    $0x10,%esp
}
  80a0c1:	eb bc                	jmp    80a07f <sys_sem_signal+0x2c>

0080a0c3 <sys_arch_sem_wait>:
{
  80a0c3:	55                   	push   %ebp
  80a0c4:	89 e5                	mov    %esp,%ebp
  80a0c6:	57                   	push   %edi
  80a0c7:	56                   	push   %esi
  80a0c8:	53                   	push   %ebx
  80a0c9:	83 ec 1c             	sub    $0x1c,%esp
  80a0cc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a0cf:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0d2:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a0d5:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a0dc:	00 
  80a0dd:	75 2c                	jne    80a10b <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a0df:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0e2:	c1 e0 02             	shl    $0x2,%eax
  80a0e5:	89 c2                	mov    %eax,%edx
  80a0e7:	03 55 08             	add    0x8(%ebp),%edx
  80a0ea:	8b 3c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%edi
  80a0f1:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a0f4:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a0fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a0fe:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a103:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a106:	e9 80 00 00 00       	jmp    80a18b <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a10b:	68 9d 29 81 00       	push   $0x81299d
  80a110:	68 6b 29 81 00       	push   $0x81296b
  80a115:	68 ac 00 00 00       	push   $0xac
  80a11a:	68 80 29 81 00       	push   $0x812980
  80a11f:	e8 84 44 00 00       	call   80e5a8 <_panic>
	if (sems[sem].counter > 0) {
  80a124:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a127:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a12e:	00 
  80a12f:	66 85 c0             	test   %ax,%ax
  80a132:	75 6e                	jne    80a1a2 <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a134:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a137:	0f 84 8f 00 00 00    	je     80a1cc <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a13d:	e8 df 52 00 00       	call   80f421 <sys_time_msec>
  80a142:	89 c1                	mov    %eax,%ecx
  80a144:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a147:	89 d8                	mov    %ebx,%eax
  80a149:	29 f8                	sub    %edi,%eax
  80a14b:	01 c8                	add    %ecx,%eax
  80a14d:	85 db                	test   %ebx,%ebx
  80a14f:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a154:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a157:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a15a:	8d 34 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%esi
  80a161:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a167:	83 ec 04             	sub    $0x4,%esp
  80a16a:	50                   	push   %eax
  80a16b:	ff 76 08             	pushl  0x8(%esi)
  80a16e:	ff 75 dc             	pushl  -0x24(%ebp)
  80a171:	e8 02 06 00 00       	call   80a778 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a176:	83 c4 10             	add    $0x10,%esp
  80a179:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a17c:	39 46 04             	cmp    %eax,0x4(%esi)
  80a17f:	75 34                	jne    80a1b5 <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a181:	e8 9b 52 00 00       	call   80f421 <sys_time_msec>
	    waited += (b - a);
  80a186:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a189:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a18b:	85 db                	test   %ebx,%ebx
  80a18d:	74 95                	je     80a124 <sys_arch_sem_wait+0x61>
  80a18f:	39 df                	cmp    %ebx,%edi
  80a191:	72 91                	jb     80a124 <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a193:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a198:	89 f8                	mov    %edi,%eax
  80a19a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a19d:	5b                   	pop    %ebx
  80a19e:	5e                   	pop    %esi
  80a19f:	5f                   	pop    %edi
  80a1a0:	5d                   	pop    %ebp
  80a1a1:	c3                   	ret    
	    sems[sem].counter--;
  80a1a2:	8b 55 08             	mov    0x8(%ebp),%edx
  80a1a5:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a1a8:	83 e8 01             	sub    $0x1,%eax
  80a1ab:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a1b2:	00 
	    return waited;
  80a1b3:	eb e3                	jmp    80a198 <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a1b5:	83 ec 0c             	sub    $0xc,%esp
  80a1b8:	68 68 28 81 00       	push   $0x812868
  80a1bd:	e8 dc 44 00 00       	call   80e69e <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a1c2:	83 c4 10             	add    $0x10,%esp
  80a1c5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a1ca:	eb cc                	jmp    80a198 <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a1cc:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a1d1:	eb c5                	jmp    80a198 <sys_arch_sem_wait+0xd5>

0080a1d3 <sys_mbox_trypost>:
{
  80a1d3:	55                   	push   %ebp
  80a1d4:	89 e5                	mov    %esp,%ebp
  80a1d6:	57                   	push   %edi
  80a1d7:	56                   	push   %esi
  80a1d8:	53                   	push   %ebx
  80a1d9:	83 ec 0c             	sub    $0xc,%esp
  80a1dc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a1df:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a1e5:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a1ec:	75 7f                	jne    80a26d <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a1ee:	83 ec 08             	sub    $0x8,%esp
  80a1f1:	6a 00                	push   $0x0
  80a1f3:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a1f9:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a1ff:	e8 bf fe ff ff       	call   80a0c3 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a204:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a20a:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a210:	83 c4 10             	add    $0x10,%esp
  80a213:	39 ca                	cmp    %ecx,%edx
  80a215:	74 7a                	je     80a291 <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a217:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a21d:	8d 42 01             	lea    0x1(%edx),%eax
  80a220:	89 c7                	mov    %eax,%edi
  80a222:	c1 ff 1f             	sar    $0x1f,%edi
  80a225:	c1 ef 1b             	shr    $0x1b,%edi
  80a228:	01 f8                	add    %edi,%eax
  80a22a:	83 e0 1f             	and    $0x1f,%eax
  80a22d:	29 f8                	sub    %edi,%eax
  80a22f:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a235:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a238:	01 d0                	add    %edx,%eax
  80a23a:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a23d:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a244:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a247:	74 3a                	je     80a283 <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a249:	83 ec 0c             	sub    $0xc,%esp
  80a24c:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a252:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a258:	e8 f6 fd ff ff       	call   80a053 <sys_sem_signal>
    return ERR_OK;
  80a25d:	83 c4 10             	add    $0x10,%esp
  80a260:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a265:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a268:	5b                   	pop    %ebx
  80a269:	5e                   	pop    %esi
  80a26a:	5f                   	pop    %edi
  80a26b:	5d                   	pop    %ebp
  80a26c:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a26d:	68 ae 29 81 00       	push   $0x8129ae
  80a272:	68 6b 29 81 00       	push   $0x81296b
  80a277:	6a 72                	push   $0x72
  80a279:	68 80 29 81 00       	push   $0x812980
  80a27e:	e8 25 43 00 00       	call   80e5a8 <_panic>
	mboxes[mbox].head = slot;
  80a283:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a289:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a28f:	eb b8                	jmp    80a249 <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a296:	eb cd                	jmp    80a265 <sys_mbox_trypost+0x92>

0080a298 <sys_mbox_post>:
{
  80a298:	55                   	push   %ebp
  80a299:	89 e5                	mov    %esp,%ebp
  80a29b:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a29e:	ff 75 0c             	pushl  0xc(%ebp)
  80a2a1:	ff 75 08             	pushl  0x8(%ebp)
  80a2a4:	e8 2a ff ff ff       	call   80a1d3 <sys_mbox_trypost>
  80a2a9:	83 c4 10             	add    $0x10,%esp
  80a2ac:	84 c0                	test   %al,%al
  80a2ae:	75 02                	jne    80a2b2 <sys_mbox_post+0x1a>
}
  80a2b0:	c9                   	leave  
  80a2b1:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a2b2:	68 94 28 81 00       	push   $0x812894
  80a2b7:	68 6b 29 81 00       	push   $0x81296b
  80a2bc:	6a 6c                	push   $0x6c
  80a2be:	68 80 29 81 00       	push   $0x812980
  80a2c3:	e8 e0 42 00 00       	call   80e5a8 <_panic>

0080a2c8 <sys_arch_mbox_fetch>:
{
  80a2c8:	55                   	push   %ebp
  80a2c9:	89 e5                	mov    %esp,%ebp
  80a2cb:	57                   	push   %edi
  80a2cc:	56                   	push   %esi
  80a2cd:	53                   	push   %ebx
  80a2ce:	83 ec 0c             	sub    $0xc,%esp
  80a2d1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a2d4:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a2d7:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2dd:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a2e4:	0f 85 8a 00 00 00    	jne    80a374 <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a2ea:	83 ec 08             	sub    $0x8,%esp
  80a2ed:	ff 75 10             	pushl  0x10(%ebp)
  80a2f0:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a2f6:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a2fc:	e8 c2 fd ff ff       	call   80a0c3 <sys_arch_sem_wait>
  80a301:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a303:	83 c4 10             	add    $0x10,%esp
  80a306:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a309:	74 5f                	je     80a36a <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a30b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a311:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a317:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a31a:	74 71                	je     80a38d <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a31c:	85 ff                	test   %edi,%edi
  80a31e:	74 0e                	je     80a32e <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a320:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a323:	01 c2                	add    %eax,%edx
  80a325:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a32c:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a32e:	83 c0 01             	add    $0x1,%eax
  80a331:	99                   	cltd   
  80a332:	c1 ea 1b             	shr    $0x1b,%edx
  80a335:	01 d0                	add    %edx,%eax
  80a337:	83 e0 1f             	and    $0x1f,%eax
  80a33a:	29 d0                	sub    %edx,%eax
  80a33c:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a342:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a348:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a34e:	3b 42 08             	cmp    0x8(%edx),%eax
  80a351:	74 51                	je     80a3a4 <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a353:	83 ec 0c             	sub    $0xc,%esp
  80a356:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a35c:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a362:	e8 ec fc ff ff       	call   80a053 <sys_sem_signal>
    return waited;
  80a367:	83 c4 10             	add    $0x10,%esp
}
  80a36a:	89 f0                	mov    %esi,%eax
  80a36c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a36f:	5b                   	pop    %ebx
  80a370:	5e                   	pop    %esi
  80a371:	5f                   	pop    %edi
  80a372:	5d                   	pop    %ebp
  80a373:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a374:	68 ae 29 81 00       	push   $0x8129ae
  80a379:	68 6b 29 81 00       	push   $0x81296b
  80a37e:	68 ce 00 00 00       	push   $0xce
  80a383:	68 80 29 81 00       	push   $0x812980
  80a388:	e8 1b 42 00 00       	call   80e5a8 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a38d:	83 ec 04             	sub    $0x4,%esp
  80a390:	68 bc 28 81 00       	push   $0x8128bc
  80a395:	68 d6 00 00 00       	push   $0xd6
  80a39a:	68 80 29 81 00       	push   $0x812980
  80a39f:	e8 04 42 00 00       	call   80e5a8 <_panic>
	mboxes[mbox].head = -1;
  80a3a4:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3aa:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a3b1:	ff ff ff 
  80a3b4:	eb 9d                	jmp    80a353 <sys_arch_mbox_fetch+0x8b>

0080a3b6 <sys_arch_mbox_tryfetch>:
{
  80a3b6:	55                   	push   %ebp
  80a3b7:	89 e5                	mov    %esp,%ebp
  80a3b9:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a3bc:	6a fe                	push   $0xfffffffe
  80a3be:	ff 75 0c             	pushl  0xc(%ebp)
  80a3c1:	ff 75 08             	pushl  0x8(%ebp)
  80a3c4:	e8 ff fe ff ff       	call   80a2c8 <sys_arch_mbox_fetch>
}
  80a3c9:	c9                   	leave  
  80a3ca:	c3                   	ret    

0080a3cb <sys_thread_new>:
{
  80a3cb:	55                   	push   %ebp
  80a3cc:	89 e5                	mov    %esp,%ebp
  80a3ce:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a3d1:	6a 08                	push   $0x8
  80a3d3:	e8 22 64 00 00       	call   8107fa <malloc>
    if (lt == 0)
  80a3d8:	83 c4 10             	add    $0x10,%esp
  80a3db:	85 c0                	test   %eax,%eax
  80a3dd:	74 32                	je     80a411 <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a3df:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a3e6:	7f 40                	jg     80a428 <sys_thread_new+0x5d>
    lt->func = thread;
  80a3e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3eb:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a3ed:	8b 55 10             	mov    0x10(%ebp),%edx
  80a3f0:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a3f3:	50                   	push   %eax
  80a3f4:	68 83 9c 80 00       	push   $0x809c83
  80a3f9:	ff 75 08             	pushl  0x8(%ebp)
  80a3fc:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a3ff:	50                   	push   %eax
  80a400:	e8 c7 01 00 00       	call   80a5cc <thread_create>
    if (r < 0)
  80a405:	83 c4 10             	add    $0x10,%esp
  80a408:	85 c0                	test   %eax,%eax
  80a40a:	78 33                	js     80a43f <sys_thread_new+0x74>
}
  80a40c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a40f:	c9                   	leave  
  80a410:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a411:	83 ec 04             	sub    $0x4,%esp
  80a414:	68 e4 28 81 00       	push   $0x8128e4
  80a419:	68 fd 00 00 00       	push   $0xfd
  80a41e:	68 80 29 81 00       	push   $0x812980
  80a423:	e8 80 41 00 00       	call   80e5a8 <_panic>
	panic("large stack %d", stacksize);
  80a428:	ff 75 14             	pushl  0x14(%ebp)
  80a42b:	68 de 29 81 00       	push   $0x8129de
  80a430:	68 00 01 00 00       	push   $0x100
  80a435:	68 80 29 81 00       	push   $0x812980
  80a43a:	e8 69 41 00 00       	call   80e5a8 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a43f:	83 ec 0c             	sub    $0xc,%esp
  80a442:	50                   	push   %eax
  80a443:	e8 c1 04 00 00       	call   80a909 <e2s>
  80a448:	50                   	push   %eax
  80a449:	68 14 29 81 00       	push   $0x812914
  80a44e:	68 09 01 00 00       	push   $0x109
  80a453:	68 80 29 81 00       	push   $0x812980
  80a458:	e8 4b 41 00 00       	call   80e5a8 <_panic>

0080a45d <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a45d:	55                   	push   %ebp
  80a45e:	89 e5                	mov    %esp,%ebp
  80a460:	57                   	push   %edi
  80a461:	56                   	push   %esi
  80a462:	53                   	push   %ebx
  80a463:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a466:	e8 ef 00 00 00       	call   80a55a <thread_id>
  80a46b:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a46d:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a472:	f7 e2                	mul    %edx
  80a474:	c1 ea 08             	shr    $0x8,%edx
  80a477:	89 d7                	mov    %edx,%edi
  80a479:	c1 e2 08             	shl    $0x8,%edx
  80a47c:	01 d7                	add    %edx,%edi
  80a47e:	89 f0                	mov    %esi,%eax
  80a480:	29 f8                	sub    %edi,%eax
  80a482:	89 c7                	mov    %eax,%edi
  80a484:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a48b:	85 db                	test   %ebx,%ebx
  80a48d:	74 09                	je     80a498 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a48f:	39 33                	cmp    %esi,(%ebx)
  80a491:	74 66                	je     80a4f9 <sys_arch_timeouts+0x9c>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a493:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a496:	eb f3                	jmp    80a48b <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a498:	83 ec 0c             	sub    $0xc,%esp
  80a49b:	6a 10                	push   $0x10
  80a49d:	e8 58 63 00 00       	call   8107fa <malloc>
  80a4a2:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a4a4:	83 c4 10             	add    $0x10,%esp
  80a4a7:	85 c0                	test   %eax,%eax
  80a4a9:	74 59                	je     80a504 <sys_arch_timeouts+0xa7>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a4ab:	83 ec 0c             	sub    $0xc,%esp
  80a4ae:	68 a2 9c 80 00       	push   $0x809ca2
  80a4b3:	e8 ea 00 00 00       	call   80a5a2 <thread_onhalt>
    if (r < 0)
  80a4b8:	83 c4 10             	add    $0x10,%esp
  80a4bb:	85 c0                	test   %eax,%eax
  80a4bd:	78 5c                	js     80a51b <sys_arch_timeouts+0xbe>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a4bf:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a4c1:	83 ec 04             	sub    $0x4,%esp
  80a4c4:	6a 04                	push   $0x4
  80a4c6:	6a 00                	push   $0x0
  80a4c8:	8d 43 04             	lea    0x4(%ebx),%eax
  80a4cb:	50                   	push   %eax
  80a4cc:	e8 72 4a 00 00       	call   80ef43 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a4d1:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a4d8:	89 43 08             	mov    %eax,0x8(%ebx)
  80a4db:	83 c4 10             	add    $0x10,%esp
  80a4de:	85 c0                	test   %eax,%eax
  80a4e0:	74 06                	je     80a4e8 <sys_arch_timeouts+0x8b>
  80a4e2:	8d 53 08             	lea    0x8(%ebx),%edx
  80a4e5:	89 50 0c             	mov    %edx,0xc(%eax)
  80a4e8:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a4ef:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a4f6:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a4f9:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a4fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a4ff:	5b                   	pop    %ebx
  80a500:	5e                   	pop    %esi
  80a501:	5f                   	pop    %edi
  80a502:	5d                   	pop    %ebp
  80a503:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a504:	83 ec 04             	sub    $0x4,%esp
  80a507:	68 40 29 81 00       	push   $0x812940
  80a50c:	68 2c 01 00 00       	push   $0x12c
  80a511:	68 80 29 81 00       	push   $0x812980
  80a516:	e8 8d 40 00 00       	call   80e5a8 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a51b:	83 ec 0c             	sub    $0xc,%esp
  80a51e:	50                   	push   %eax
  80a51f:	e8 e5 03 00 00       	call   80a909 <e2s>
  80a524:	50                   	push   %eax
  80a525:	68 ed 29 81 00       	push   $0x8129ed
  80a52a:	68 30 01 00 00       	push   $0x130
  80a52f:	68 80 29 81 00       	push   $0x812980
  80a534:	e8 6f 40 00 00       	call   80e5a8 <_panic>

0080a539 <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a539:	c3                   	ret    

0080a53a <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a53a:	c3                   	ret    

0080a53b <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a53b:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a542:	00 00 00 
    tq->tq_last = 0;
  80a545:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a54c:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a54f:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a556:	00 00 00 
}
  80a559:	c3                   	ret    

0080a55a <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a55a:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a55f:	8b 00                	mov    (%eax),%eax
}
  80a561:	c3                   	ret    

0080a562 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a562:	55                   	push   %ebp
  80a563:	89 e5                	mov    %esp,%ebp
  80a565:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a568:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a56d:	eb 07                	jmp    80a576 <thread_wakeup+0x14>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a56f:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a573:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a576:	85 c0                	test   %eax,%eax
  80a578:	74 07                	je     80a581 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a57a:	39 50 48             	cmp    %edx,0x48(%eax)
  80a57d:	75 f4                	jne    80a573 <thread_wakeup+0x11>
  80a57f:	eb ee                	jmp    80a56f <thread_wakeup+0xd>
    }
}
  80a581:	5d                   	pop    %ebp
  80a582:	c3                   	ret    

0080a583 <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a583:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a589:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a58e:	85 d2                	test   %edx,%edx
  80a590:	74 0f                	je     80a5a1 <thread_wakeups_pending+0x1e>
	if (tc->tc_wakeup)
  80a592:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a596:	80 f9 01             	cmp    $0x1,%cl
  80a599:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a59c:	8b 52 64             	mov    0x64(%edx),%edx
  80a59f:	eb ed                	jmp    80a58e <thread_wakeups_pending+0xb>
    }
    return n;
}
  80a5a1:	c3                   	ret    

0080a5a2 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a5a2:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a5a7:	8b 50 60             	mov    0x60(%eax),%edx
  80a5aa:	83 fa 03             	cmp    $0x3,%edx
  80a5ad:	7f 17                	jg     80a5c6 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a5af:	55                   	push   %ebp
  80a5b0:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a5b2:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a5b5:	89 48 60             	mov    %ecx,0x60(%eax)
  80a5b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a5bb:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a5bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a5c4:	5d                   	pop    %ebp
  80a5c5:	c3                   	ret    
	return -E_NO_MEM;
  80a5c6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a5cb:	c3                   	ret    

0080a5cc <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a5cc:	55                   	push   %ebp
  80a5cd:	89 e5                	mov    %esp,%ebp
  80a5cf:	57                   	push   %edi
  80a5d0:	56                   	push   %esi
  80a5d1:	53                   	push   %ebx
  80a5d2:	83 ec 18             	sub    $0x18,%esp
  80a5d5:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a5d8:	6a 68                	push   $0x68
  80a5da:	e8 1b 62 00 00       	call   8107fa <malloc>
    if (!tc)
  80a5df:	83 c4 10             	add    $0x10,%esp
  80a5e2:	85 c0                	test   %eax,%eax
  80a5e4:	0f 84 04 01 00 00    	je     80a6ee <thread_create+0x122>
  80a5ea:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a5ec:	83 ec 04             	sub    $0x4,%esp
  80a5ef:	6a 68                	push   $0x68
  80a5f1:	6a 00                	push   $0x0
  80a5f3:	50                   	push   %eax
  80a5f4:	e8 4a 49 00 00       	call   80ef43 <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a5f9:	83 c4 0c             	add    $0xc,%esp
  80a5fc:	6a 1f                	push   $0x1f
  80a5fe:	ff 75 0c             	pushl  0xc(%ebp)
  80a601:	8d 43 08             	lea    0x8(%ebx),%eax
  80a604:	50                   	push   %eax
  80a605:	e8 38 48 00 00       	call   80ee42 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a60a:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a60e:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a613:	8d 50 01             	lea    0x1(%eax),%edx
  80a616:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a61c:	83 c4 10             	add    $0x10,%esp
  80a61f:	83 fa ff             	cmp    $0xffffffff,%edx
  80a622:	0f 84 91 00 00 00    	je     80a6b9 <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a628:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a62a:	83 ec 0c             	sub    $0xc,%esp
  80a62d:	68 00 10 00 00       	push   $0x1000
  80a632:	e8 c3 61 00 00       	call   8107fa <malloc>
  80a637:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a63a:	83 c4 10             	add    $0x10,%esp
  80a63d:	85 c0                	test   %eax,%eax
  80a63f:	0f 84 88 00 00 00    	je     80a6cd <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a645:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a64b:	83 ec 04             	sub    $0x4,%esp
  80a64e:	6a 04                	push   $0x4
  80a650:	6a 00                	push   $0x0
  80a652:	57                   	push   %edi
  80a653:	e8 eb 48 00 00       	call   80ef43 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a658:	83 c4 0c             	add    $0xc,%esp
  80a65b:	6a 18                	push   $0x18
  80a65d:	6a 00                	push   $0x0
  80a65f:	8d 43 30             	lea    0x30(%ebx),%eax
  80a662:	50                   	push   %eax
  80a663:	e8 db 48 00 00       	call   80ef43 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a668:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a66b:	c7 43 30 79 a8 80 00 	movl   $0x80a879,0x30(%ebx)
    tc->tc_entry = entry;
  80a672:	8b 45 10             	mov    0x10(%ebp),%eax
  80a675:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a678:	8b 45 14             	mov    0x14(%ebp),%eax
  80a67b:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a67e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a685:	83 c4 10             	add    $0x10,%esp
  80a688:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a68f:	74 4f                	je     80a6e0 <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a691:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a696:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a699:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a69f:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a6a4:	85 f6                	test   %esi,%esi
  80a6a6:	74 09                	je     80a6b1 <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a6a8:	8b 03                	mov    (%ebx),%eax
  80a6aa:	89 06                	mov    %eax,(%esi)
    return 0;
  80a6ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a6b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a6b4:	5b                   	pop    %ebx
  80a6b5:	5e                   	pop    %esi
  80a6b6:	5f                   	pop    %edi
  80a6b7:	5d                   	pop    %ebp
  80a6b8:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a6b9:	83 ec 04             	sub    $0x4,%esp
  80a6bc:	68 06 2a 81 00       	push   $0x812a06
  80a6c1:	6a 54                	push   $0x54
  80a6c3:	68 24 2a 81 00       	push   $0x812a24
  80a6c8:	e8 db 3e 00 00       	call   80e5a8 <_panic>
	free(tc);
  80a6cd:	83 ec 0c             	sub    $0xc,%esp
  80a6d0:	53                   	push   %ebx
  80a6d1:	e8 78 60 00 00       	call   81074e <free>
	return -E_NO_MEM;
  80a6d6:	83 c4 10             	add    $0x10,%esp
  80a6d9:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6de:	eb d1                	jmp    80a6b1 <thread_create+0xe5>
	tq->tq_first = tc;
  80a6e0:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a6e6:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a6ec:	eb b1                	jmp    80a69f <thread_create+0xd3>
	return -E_NO_MEM;
  80a6ee:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a6f3:	eb bc                	jmp    80a6b1 <thread_create+0xe5>

0080a6f5 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a6f5:	55                   	push   %ebp
  80a6f6:	89 e5                	mov    %esp,%ebp
  80a6f8:	53                   	push   %ebx
  80a6f9:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a6fc:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a702:	85 db                	test   %ebx,%ebx
  80a704:	74 2b                	je     80a731 <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a706:	8b 43 64             	mov    0x64(%ebx),%eax
  80a709:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a70e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a715:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a71a:	85 c0                	test   %eax,%eax
  80a71c:	74 3b                	je     80a759 <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a71e:	83 ec 0c             	sub    $0xc,%esp
  80a721:	83 c0 30             	add    $0x30,%eax
  80a724:	50                   	push   %eax
  80a725:	e8 76 01 00 00       	call   80a8a0 <jos_setjmp>
  80a72a:	83 c4 10             	add    $0x10,%esp
  80a72d:	85 c0                	test   %eax,%eax
  80a72f:	74 05                	je     80a736 <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a731:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a734:	c9                   	leave  
  80a735:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a736:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a73b:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a742:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a749:	74 21                	je     80a76c <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a74b:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a751:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a754:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80a759:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a75f:	8d 43 30             	lea    0x30(%ebx),%eax
  80a762:	ba 01 00 00 00       	mov    $0x1,%edx
  80a767:	e8 64 01 00 00       	call   80a8d0 <jos_longjmp>
	tq->tq_first = tc;
  80a76c:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a771:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a776:	eb e1                	jmp    80a759 <thread_yield+0x64>

0080a778 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a778:	55                   	push   %ebp
  80a779:	89 e5                	mov    %esp,%ebp
  80a77b:	57                   	push   %edi
  80a77c:	56                   	push   %esi
  80a77d:	53                   	push   %ebx
  80a77e:	83 ec 0c             	sub    $0xc,%esp
  80a781:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a784:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a787:	e8 95 4c 00 00       	call   80f421 <sys_time_msec>
  80a78c:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a78e:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a793:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a796:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a79a:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a79c:	eb 17                	jmp    80a7b5 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a79e:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7a3:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a7a7:	84 c0                	test   %al,%al
  80a7a9:	75 1d                	jne    80a7c8 <thread_wait+0x50>
	thread_yield();
  80a7ab:	e8 45 ff ff ff       	call   80a6f5 <thread_yield>
	p = sys_time_msec();
  80a7b0:	e8 6c 4c 00 00       	call   80f421 <sys_time_msec>
	if (p < s)
  80a7b5:	39 f0                	cmp    %esi,%eax
  80a7b7:	72 0f                	jb     80a7c8 <thread_wait+0x50>
  80a7b9:	39 f8                	cmp    %edi,%eax
  80a7bb:	73 0b                	jae    80a7c8 <thread_wait+0x50>
	if (addr && *addr != val)
  80a7bd:	85 db                	test   %ebx,%ebx
  80a7bf:	74 dd                	je     80a79e <thread_wait+0x26>
  80a7c1:	8b 03                	mov    (%ebx),%eax
  80a7c3:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a7c6:	74 d6                	je     80a79e <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a7c8:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7cd:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a7d4:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a7d8:	83 c4 0c             	add    $0xc,%esp
  80a7db:	5b                   	pop    %ebx
  80a7dc:	5e                   	pop    %esi
  80a7dd:	5f                   	pop    %edi
  80a7de:	5d                   	pop    %ebp
  80a7df:	c3                   	ret    

0080a7e0 <thread_halt>:
thread_halt() {
  80a7e0:	55                   	push   %ebp
  80a7e1:	89 e5                	mov    %esp,%ebp
  80a7e3:	56                   	push   %esi
  80a7e4:	53                   	push   %ebx
    if (!tq->tq_first)
  80a7e5:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a7eb:	85 db                	test   %ebx,%ebx
  80a7ed:	74 40                	je     80a82f <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a7ef:	8b 43 64             	mov    0x64(%ebx),%eax
  80a7f2:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a7f7:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a7fe:	be 00 00 00 00       	mov    $0x0,%esi
  80a803:	eb 0f                	jmp    80a814 <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a805:	83 ec 0c             	sub    $0xc,%esp
  80a808:	ff 33                	pushl  (%ebx)
  80a80a:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a80e:	83 c6 01             	add    $0x1,%esi
  80a811:	83 c4 10             	add    $0x10,%esp
  80a814:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a817:	7c ec                	jl     80a805 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a819:	83 ec 0c             	sub    $0xc,%esp
  80a81c:	ff 73 04             	pushl  0x4(%ebx)
  80a81f:	e8 2a 5f 00 00       	call   81074e <free>
    free(tc);
  80a824:	89 1c 24             	mov    %ebx,(%esp)
  80a827:	e8 22 5f 00 00       	call   81074e <free>
  80a82c:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a82f:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a834:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a83b:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a842:	74 29                	je     80a86d <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a844:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a84a:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a84d:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a852:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a859:	00 00 00 
    thread_yield();
  80a85c:	e8 94 fe ff ff       	call   80a6f5 <thread_yield>
    exit();
  80a861:	e8 28 3d 00 00       	call   80e58e <exit>
}
  80a866:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a869:	5b                   	pop    %ebx
  80a86a:	5e                   	pop    %esi
  80a86b:	5d                   	pop    %ebp
  80a86c:	c3                   	ret    
	tq->tq_first = tc;
  80a86d:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a872:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a877:	eb d9                	jmp    80a852 <thread_halt+0x72>

0080a879 <thread_entry>:
thread_entry(void) {
  80a879:	55                   	push   %ebp
  80a87a:	89 e5                	mov    %esp,%ebp
  80a87c:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a87f:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a884:	ff 70 2c             	pushl  0x2c(%eax)
  80a887:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a88a:	e8 51 ff ff ff       	call   80a7e0 <thread_halt>
}
  80a88f:	83 c4 10             	add    $0x10,%esp
  80a892:	c9                   	leave  
  80a893:	c3                   	ret    
  80a894:	66 90                	xchg   %ax,%ax
  80a896:	66 90                	xchg   %ax,%ax
  80a898:	66 90                	xchg   %ax,%ax
  80a89a:	66 90                	xchg   %ax,%ax
  80a89c:	66 90                	xchg   %ax,%ax
  80a89e:	66 90                	xchg   %ax,%ax

0080a8a0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a8a0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a8a4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a8a7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a8a9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a8ad:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a8b0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a8b3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a8b6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a8b9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a8bc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a8c1:	c3                   	ret    
  80a8c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a8c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080a8d0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a8d0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a8d2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a8d5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a8d8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a8db:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a8de:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a8e1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a8e3:	ff e1                	jmp    *%ecx

0080a8e5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a8e5:	55                   	push   %ebp
  80a8e6:	89 e5                	mov    %esp,%ebp
  80a8e8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a8eb:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80a8f0:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a8f7:	ff 75 08             	pushl  0x8(%ebp)
  80a8fa:	68 3f 2a 81 00       	push   $0x812a3f
  80a8ff:	e8 9a 3d 00 00       	call   80e69e <cprintf>
}
  80a904:	83 c4 10             	add    $0x10,%esp
  80a907:	c9                   	leave  
  80a908:	c3                   	ret    

0080a909 <e2s>:
e2s(int err) {
  80a909:	55                   	push   %ebp
  80a90a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a90c:	8b 45 08             	mov    0x8(%ebp),%eax
  80a90f:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a916:	5d                   	pop    %ebp
  80a917:	c3                   	ret    

0080a918 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a918:	55                   	push   %ebp
  80a919:	89 e5                	mov    %esp,%ebp
  80a91b:	57                   	push   %edi
  80a91c:	56                   	push   %esi
  80a91d:	53                   	push   %ebx
  80a91e:	83 ec 20             	sub    $0x20,%esp
  80a921:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a924:	6a 07                	push   $0x7
  80a926:	68 00 00 00 10       	push   $0x10000000
  80a92b:	6a 00                	push   $0x0
  80a92d:	e8 bd 48 00 00       	call   80f1ef <sys_page_alloc>
    if (r < 0)
  80a932:	83 c4 10             	add    $0x10,%esp
  80a935:	85 c0                	test   %eax,%eax
  80a937:	78 49                	js     80a982 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a939:	8b 45 08             	mov    0x8(%ebp),%eax
  80a93c:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a93f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a942:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a947:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a94c:	85 db                	test   %ebx,%ebx
  80a94e:	74 5c                	je     80a9ac <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a950:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a954:	0f b7 d0             	movzwl %ax,%edx
  80a957:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80a95a:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80a960:	7f 34                	jg     80a996 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80a962:	83 ec 04             	sub    $0x4,%esp
  80a965:	0f b7 c0             	movzwl %ax,%eax
  80a968:	50                   	push   %eax
  80a969:	ff 73 04             	pushl  0x4(%ebx)
  80a96c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80a96f:	50                   	push   %eax
  80a970:	e8 78 46 00 00       	call   80efed <memcpy>
	txsize += q->len;
  80a975:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a979:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80a97b:	8b 1b                	mov    (%ebx),%ebx
  80a97d:	83 c4 10             	add    $0x10,%esp
  80a980:	eb ca                	jmp    80a94c <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80a982:	83 ec 04             	sub    $0x4,%esp
  80a985:	68 24 2f 81 00       	push   $0x812f24
  80a98a:	6a 55                	push   $0x55
  80a98c:	68 75 2f 81 00       	push   $0x812f75
  80a991:	e8 12 3c 00 00       	call   80e5a8 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80a996:	83 ec 0c             	sub    $0xc,%esp
  80a999:	56                   	push   %esi
  80a99a:	52                   	push   %edx
  80a99b:	68 4c 2f 81 00       	push   $0x812f4c
  80a9a0:	6a 64                	push   $0x64
  80a9a2:	68 75 2f 81 00       	push   $0x812f75
  80a9a7:	e8 fc 3b 00 00       	call   80e5a8 <_panic>
    }

    pkt->jp_len = txsize;
  80a9ac:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80a9b2:	6a 07                	push   $0x7
  80a9b4:	68 00 00 00 10       	push   $0x10000000
  80a9b9:	6a 0b                	push   $0xb
  80a9bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a9be:	ff 70 04             	pushl  0x4(%eax)
  80a9c1:	e8 62 50 00 00       	call   80fa28 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80a9c6:	83 c4 08             	add    $0x8,%esp
  80a9c9:	68 00 00 00 10       	push   $0x10000000
  80a9ce:	6a 00                	push   $0x0
  80a9d0:	e8 9f 48 00 00       	call   80f274 <sys_page_unmap>

    return ERR_OK;
}
  80a9d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a9da:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a9dd:	5b                   	pop    %ebx
  80a9de:	5e                   	pop    %esi
  80a9df:	5f                   	pop    %edi
  80a9e0:	5d                   	pop    %ebp
  80a9e1:	c3                   	ret    

0080a9e2 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80a9e2:	55                   	push   %ebp
  80a9e3:	89 e5                	mov    %esp,%ebp
  80a9e5:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80a9e8:	ff 75 10             	pushl  0x10(%ebp)
  80a9eb:	ff 75 0c             	pushl  0xc(%ebp)
  80a9ee:	ff 75 08             	pushl  0x8(%ebp)
  80a9f1:	e8 04 f1 ff ff       	call   809afa <etharp_output>
}
  80a9f6:	c9                   	leave  
  80a9f7:	c3                   	ret    

0080a9f8 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80a9f8:	55                   	push   %ebp
  80a9f9:	89 e5                	mov    %esp,%ebp
  80a9fb:	57                   	push   %edi
  80a9fc:	56                   	push   %esi
  80a9fd:	53                   	push   %ebx
  80a9fe:	83 ec 20             	sub    $0x20,%esp
  80aa01:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80aa04:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa07:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aa0a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80aa0d:	8b 06                	mov    (%esi),%eax
  80aa0f:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80aa11:	6a 03                	push   $0x3
  80aa13:	0f b7 c0             	movzwl %ax,%eax
  80aa16:	50                   	push   %eax
  80aa17:	6a 03                	push   $0x3
  80aa19:	e8 8b 9e ff ff       	call   8048a9 <pbuf_alloc>
    if (p == 0)
  80aa1e:	83 c4 10             	add    $0x10,%esp
  80aa21:	85 c0                	test   %eax,%eax
  80aa23:	0f 84 9c 00 00 00    	je     80aac5 <jif_input+0xcd>
  80aa29:	89 c7                	mov    %eax,%edi
    void *rxbuf = (void *) pkt->jp_data;
  80aa2b:	8d 46 04             	lea    0x4(%esi),%eax
  80aa2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80aa31:	89 fe                	mov    %edi,%esi
    int copied = 0;
  80aa33:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80aa38:	0f bf c3             	movswl %bx,%eax
  80aa3b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80aa3e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80aa41:	89 d7                	mov    %edx,%edi
	int bytes = q->len;
  80aa43:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80aa47:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80aa4a:	29 fb                	sub    %edi,%ebx
  80aa4c:	39 c3                	cmp    %eax,%ebx
  80aa4e:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80aa51:	83 ec 04             	sub    $0x4,%esp
  80aa54:	53                   	push   %ebx
  80aa55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa58:	01 f8                	add    %edi,%eax
  80aa5a:	50                   	push   %eax
  80aa5b:	ff 76 04             	pushl  0x4(%esi)
  80aa5e:	e8 8a 45 00 00       	call   80efed <memcpy>
	copied += bytes;
  80aa63:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80aa65:	8b 36                	mov    (%esi),%esi
  80aa67:	83 c4 10             	add    $0x10,%esp
  80aa6a:	85 f6                	test   %esi,%esi
  80aa6c:	75 d5                	jne    80aa43 <jif_input+0x4b>
  80aa6e:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80aa71:	83 ec 0c             	sub    $0xc,%esp
  80aa74:	8b 47 04             	mov    0x4(%edi),%eax
  80aa77:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80aa7b:	50                   	push   %eax
  80aa7c:	e8 3c cc ff ff       	call   8076bd <htons>
  80aa81:	83 c4 10             	add    $0x10,%esp
  80aa84:	66 3d 00 08          	cmp    $0x800,%ax
  80aa88:	74 14                	je     80aa9e <jif_input+0xa6>
  80aa8a:	66 3d 06 08          	cmp    $0x806,%ax
  80aa8e:	74 3d                	je     80aacd <jif_input+0xd5>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80aa90:	83 ec 0c             	sub    $0xc,%esp
  80aa93:	57                   	push   %edi
  80aa94:	e8 4a 9d ff ff       	call   8047e3 <pbuf_free>
  80aa99:	83 c4 10             	add    $0x10,%esp
  80aa9c:	eb 27                	jmp    80aac5 <jif_input+0xcd>
	etharp_ip_input(netif, p);
  80aa9e:	83 ec 08             	sub    $0x8,%esp
  80aaa1:	57                   	push   %edi
  80aaa2:	ff 75 08             	pushl  0x8(%ebp)
  80aaa5:	e8 c8 ea ff ff       	call   809572 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80aaaa:	83 c4 08             	add    $0x8,%esp
  80aaad:	6a f2                	push   $0xfffffff2
  80aaaf:	57                   	push   %edi
  80aab0:	e8 61 9c ff ff       	call   804716 <pbuf_header>
	netif->input(p, netif);
  80aab5:	83 c4 08             	add    $0x8,%esp
  80aab8:	ff 75 08             	pushl  0x8(%ebp)
  80aabb:	57                   	push   %edi
  80aabc:	8b 45 08             	mov    0x8(%ebp),%eax
  80aabf:	ff 50 10             	call   *0x10(%eax)
	break;
  80aac2:	83 c4 10             	add    $0x10,%esp
    }
}
  80aac5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aac8:	5b                   	pop    %ebx
  80aac9:	5e                   	pop    %esi
  80aaca:	5f                   	pop    %edi
  80aacb:	5d                   	pop    %ebp
  80aacc:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80aacd:	83 ec 04             	sub    $0x4,%esp
  80aad0:	57                   	push   %edi
  80aad1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80aad4:	ff 30                	pushl  (%eax)
  80aad6:	ff 75 08             	pushl  0x8(%ebp)
  80aad9:	e8 e0 ea ff ff       	call   8095be <etharp_arp_input>
	break;
  80aade:	83 c4 10             	add    $0x10,%esp
  80aae1:	eb e2                	jmp    80aac5 <jif_input+0xcd>

0080aae3 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80aae3:	55                   	push   %ebp
  80aae4:	89 e5                	mov    %esp,%ebp
  80aae6:	57                   	push   %edi
  80aae7:	56                   	push   %esi
  80aae8:	53                   	push   %ebx
  80aae9:	83 ec 28             	sub    $0x28,%esp
  80aaec:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80aaef:	6a 08                	push   $0x8
  80aaf1:	e8 f6 96 ff ff       	call   8041ec <mem_malloc>

    if (jif == NULL) {
  80aaf6:	83 c4 10             	add    $0x10,%esp
  80aaf9:	85 c0                	test   %eax,%eax
  80aafb:	0f 84 87 00 00 00    	je     80ab88 <jif_init+0xa5>
  80ab01:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ab03:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ab06:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ab09:	c7 43 14 e2 a9 80 00 	movl   $0x80a9e2,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ab10:	c7 43 18 18 a9 80 00 	movl   $0x80a918,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ab17:	83 ec 04             	sub    $0x4,%esp
  80ab1a:	6a 02                	push   $0x2
  80ab1c:	68 54 3d 81 00       	push   $0x813d54
  80ab21:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ab24:	50                   	push   %eax
  80ab25:	e8 c3 44 00 00       	call   80efed <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ab2a:	8d 43 25             	lea    0x25(%ebx),%eax
  80ab2d:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ab2f:	8b 07                	mov    (%edi),%eax
  80ab31:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ab34:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ab38:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ab3e:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80ab42:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ab46:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ab4a:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ab4e:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ab52:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ab56:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ab5a:	c7 04 24 8b 13 81 00 	movl   $0x81138b,(%esp)
  80ab61:	e8 66 cd ff ff       	call   8078cc <inet_addr>
  80ab66:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ab69:	83 c4 0c             	add    $0xc,%esp
  80ab6c:	6a 00                	push   $0x0
  80ab6e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ab71:	50                   	push   %eax
  80ab72:	53                   	push   %ebx
  80ab73:	e8 4c ed ff ff       	call   8098c4 <etharp_query>

    return ERR_OK;
  80ab78:	83 c4 10             	add    $0x10,%esp
  80ab7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ab80:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab83:	5b                   	pop    %ebx
  80ab84:	5e                   	pop    %esi
  80ab85:	5f                   	pop    %edi
  80ab86:	5d                   	pop    %ebp
  80ab87:	c3                   	ret    
	return ERR_MEM;
  80ab88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ab8d:	eb f1                	jmp    80ab80 <jif_init+0x9d>

0080ab8f <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ab8f:	55                   	push   %ebp
  80ab90:	89 e5                	mov    %esp,%ebp
  80ab92:	56                   	push   %esi
  80ab93:	53                   	push   %ebx
  80ab94:	83 ec 28             	sub    $0x28,%esp
  80ab97:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ab9a:	ff 75 10             	pushl  0x10(%ebp)
  80ab9d:	ff 75 08             	pushl  0x8(%ebp)
  80aba0:	e8 47 0f 00 00       	call   80baec <netconn_alloc>
  80aba5:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80aba7:	83 c4 10             	add    $0x10,%esp
  80abaa:	85 c0                	test   %eax,%eax
  80abac:	74 63                	je     80ac11 <netconn_new_with_proto_and_callback+0x82>
    msg.function = do_newconn;
  80abae:	c7 45 e4 e3 b9 80 00 	movl   $0x80b9e3,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80abb5:	89 f0                	mov    %esi,%eax
  80abb7:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80abba:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80abbd:	83 ec 0c             	sub    $0xc,%esp
  80abc0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80abc3:	50                   	push   %eax
  80abc4:	e8 91 77 ff ff       	call   80235a <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80abc9:	83 c4 10             	add    $0x10,%esp
  80abcc:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80abd0:	74 3f                	je     80ac11 <netconn_new_with_proto_and_callback+0x82>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80abd2:	8b 73 08             	mov    0x8(%ebx),%esi
  80abd5:	85 f6                	test   %esi,%esi
  80abd7:	75 41                	jne    80ac1a <netconn_new_with_proto_and_callback+0x8b>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80abd9:	8b 43 10             	mov    0x10(%ebx),%eax
  80abdc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80abdf:	74 4d                	je     80ac2e <netconn_new_with_proto_and_callback+0x9f>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80abe1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80abe5:	74 5b                	je     80ac42 <netconn_new_with_proto_and_callback+0xb3>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80abe7:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80abeb:	75 69                	jne    80ac56 <netconn_new_with_proto_and_callback+0xc7>
      sys_sem_free(conn->op_completed);
  80abed:	83 ec 0c             	sub    $0xc,%esp
  80abf0:	50                   	push   %eax
  80abf1:	e8 21 f2 ff ff       	call   809e17 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80abf6:	83 c4 04             	add    $0x4,%esp
  80abf9:	ff 73 14             	pushl  0x14(%ebx)
  80abfc:	e8 9f f2 ff ff       	call   809ea0 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ac01:	83 c4 08             	add    $0x8,%esp
  80ac04:	53                   	push   %ebx
  80ac05:	6a 07                	push   $0x7
  80ac07:	e8 8a 98 ff ff       	call   804496 <memp_free>
      return NULL;
  80ac0c:	83 c4 10             	add    $0x10,%esp
  80ac0f:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80ac11:	89 d8                	mov    %ebx,%eax
  80ac13:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ac16:	5b                   	pop    %ebx
  80ac17:	5e                   	pop    %esi
  80ac18:	5d                   	pop    %ebp
  80ac19:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ac1a:	83 ec 04             	sub    $0x4,%esp
  80ac1d:	68 8c 2f 81 00       	push   $0x812f8c
  80ac22:	6a 52                	push   $0x52
  80ac24:	68 3e 30 81 00       	push   $0x81303e
  80ac29:	e8 7a 39 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ac2e:	83 ec 04             	sub    $0x4,%esp
  80ac31:	68 55 30 81 00       	push   $0x813055
  80ac36:	6a 53                	push   $0x53
  80ac38:	68 3e 30 81 00       	push   $0x81303e
  80ac3d:	e8 66 39 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ac42:	83 ec 04             	sub    $0x4,%esp
  80ac45:	68 6e 30 81 00       	push   $0x81306e
  80ac4a:	6a 54                	push   $0x54
  80ac4c:	68 3e 30 81 00       	push   $0x81303e
  80ac51:	e8 52 39 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ac56:	83 ec 04             	sub    $0x4,%esp
  80ac59:	68 b0 2f 81 00       	push   $0x812fb0
  80ac5e:	6a 55                	push   $0x55
  80ac60:	68 3e 30 81 00       	push   $0x81303e
  80ac65:	e8 3e 39 00 00       	call   80e5a8 <_panic>

0080ac6a <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ac6a:	55                   	push   %ebp
  80ac6b:	89 e5                	mov    %esp,%ebp
  80ac6d:	53                   	push   %ebx
  80ac6e:	83 ec 24             	sub    $0x24,%esp
  80ac71:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ac74:	85 db                	test   %ebx,%ebx
  80ac76:	74 28                	je     80aca0 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ac78:	c7 45 e4 2b bd 80 00 	movl   $0x80bd2b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ac7f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ac82:	83 ec 0c             	sub    $0xc,%esp
  80ac85:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac88:	50                   	push   %eax
  80ac89:	e8 cc 76 ff ff       	call   80235a <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ac8e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ac95:	89 1c 24             	mov    %ebx,(%esp)
  80ac98:	e8 fd 0e 00 00       	call   80bb9a <netconn_free>

  return ERR_OK;
  80ac9d:	83 c4 10             	add    $0x10,%esp
}
  80aca0:	b8 00 00 00 00       	mov    $0x0,%eax
  80aca5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aca8:	c9                   	leave  
  80aca9:	c3                   	ret    

0080acaa <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80acaa:	55                   	push   %ebp
  80acab:	89 e5                	mov    %esp,%ebp
  80acad:	83 ec 08             	sub    $0x8,%esp
  80acb0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80acb3:	85 c0                	test   %eax,%eax
  80acb5:	74 04                	je     80acbb <netconn_type+0x11>
  80acb7:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80acb9:	c9                   	leave  
  80acba:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80acbb:	83 ec 04             	sub    $0x4,%esp
  80acbe:	68 83 30 81 00       	push   $0x813083
  80acc3:	68 84 00 00 00       	push   $0x84
  80acc8:	68 3e 30 81 00       	push   $0x81303e
  80accd:	e8 d6 38 00 00       	call   80e5a8 <_panic>

0080acd2 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80acd2:	55                   	push   %ebp
  80acd3:	89 e5                	mov    %esp,%ebp
  80acd5:	53                   	push   %ebx
  80acd6:	83 ec 24             	sub    $0x24,%esp
  80acd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80acdc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80acdf:	8b 45 10             	mov    0x10(%ebp),%eax
  80ace2:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ace5:	85 db                	test   %ebx,%ebx
  80ace7:	74 30                	je     80ad19 <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ace9:	85 d2                	test   %edx,%edx
  80aceb:	74 43                	je     80ad30 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80aced:	85 c0                	test   %eax,%eax
  80acef:	74 56                	je     80ad47 <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80acf1:	c7 45 e4 7a c1 80 00 	movl   $0x80c17a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80acf8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80acfb:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80acfe:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ad01:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ad04:	83 ec 0c             	sub    $0xc,%esp
  80ad07:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad0a:	50                   	push   %eax
  80ad0b:	e8 4a 76 ff ff       	call   80235a <tcpip_apimsg>

  return conn->err;
  80ad10:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad14:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad17:	c9                   	leave  
  80ad18:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad19:	83 ec 04             	sub    $0x4,%esp
  80ad1c:	68 9e 30 81 00       	push   $0x81309e
  80ad21:	68 98 00 00 00       	push   $0x98
  80ad26:	68 3e 30 81 00       	push   $0x81303e
  80ad2b:	e8 78 38 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ad30:	83 ec 04             	sub    $0x4,%esp
  80ad33:	68 bc 30 81 00       	push   $0x8130bc
  80ad38:	68 99 00 00 00       	push   $0x99
  80ad3d:	68 3e 30 81 00       	push   $0x81303e
  80ad42:	e8 61 38 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ad47:	83 ec 04             	sub    $0x4,%esp
  80ad4a:	68 da 30 81 00       	push   $0x8130da
  80ad4f:	68 9a 00 00 00       	push   $0x9a
  80ad54:	68 3e 30 81 00       	push   $0x81303e
  80ad59:	e8 4a 38 00 00       	call   80e5a8 <_panic>

0080ad5e <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ad5e:	55                   	push   %ebp
  80ad5f:	89 e5                	mov    %esp,%ebp
  80ad61:	53                   	push   %ebx
  80ad62:	83 ec 24             	sub    $0x24,%esp
  80ad65:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad68:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad6b:	85 db                	test   %ebx,%ebx
  80ad6d:	74 29                	je     80ad98 <netconn_bind+0x3a>

  msg.function = do_bind;
  80ad6f:	c7 45 e4 d4 bd 80 00 	movl   $0x80bdd4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad76:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ad79:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad7c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ad7f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ad83:	83 ec 0c             	sub    $0xc,%esp
  80ad86:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad89:	50                   	push   %eax
  80ad8a:	e8 cb 75 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80ad8f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ad93:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad96:	c9                   	leave  
  80ad97:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad98:	83 ec 04             	sub    $0x4,%esp
  80ad9b:	68 f8 30 81 00       	push   $0x8130f8
  80ada0:	68 b5 00 00 00       	push   $0xb5
  80ada5:	68 3e 30 81 00       	push   $0x81303e
  80adaa:	e8 f9 37 00 00       	call   80e5a8 <_panic>

0080adaf <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80adaf:	55                   	push   %ebp
  80adb0:	89 e5                	mov    %esp,%ebp
  80adb2:	53                   	push   %ebx
  80adb3:	83 ec 24             	sub    $0x24,%esp
  80adb6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80adb9:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80adbc:	85 db                	test   %ebx,%ebx
  80adbe:	74 29                	je     80ade9 <netconn_connect+0x3a>

  msg.function = do_connect;
  80adc0:	c7 45 e4 64 be 80 00 	movl   $0x80be64,-0x1c(%ebp)
  msg.msg.conn = conn;
  80adc7:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80adca:	8b 55 0c             	mov    0xc(%ebp),%edx
  80adcd:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80add0:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80add4:	83 ec 0c             	sub    $0xc,%esp
  80add7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adda:	50                   	push   %eax
  80addb:	e8 7a 75 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80ade0:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ade4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ade7:	c9                   	leave  
  80ade8:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ade9:	83 ec 04             	sub    $0x4,%esp
  80adec:	68 13 31 81 00       	push   $0x813113
  80adf1:	68 cc 00 00 00       	push   $0xcc
  80adf6:	68 3e 30 81 00       	push   $0x81303e
  80adfb:	e8 a8 37 00 00       	call   80e5a8 <_panic>

0080ae00 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80ae00:	55                   	push   %ebp
  80ae01:	89 e5                	mov    %esp,%ebp
  80ae03:	53                   	push   %ebx
  80ae04:	83 ec 24             	sub    $0x24,%esp
  80ae07:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae0a:	85 db                	test   %ebx,%ebx
  80ae0c:	74 1f                	je     80ae2d <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80ae0e:	c7 45 e4 19 bf 80 00 	movl   $0x80bf19,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae15:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80ae18:	83 ec 0c             	sub    $0xc,%esp
  80ae1b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae1e:	50                   	push   %eax
  80ae1f:	e8 36 75 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80ae24:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae28:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae2b:	c9                   	leave  
  80ae2c:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae2d:	83 ec 04             	sub    $0x4,%esp
  80ae30:	68 d4 2f 81 00       	push   $0x812fd4
  80ae35:	68 e2 00 00 00       	push   $0xe2
  80ae3a:	68 3e 30 81 00       	push   $0x81303e
  80ae3f:	e8 64 37 00 00       	call   80e5a8 <_panic>

0080ae44 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80ae44:	55                   	push   %ebp
  80ae45:	89 e5                	mov    %esp,%ebp
  80ae47:	53                   	push   %ebx
  80ae48:	83 ec 24             	sub    $0x24,%esp
  80ae4b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae4e:	85 db                	test   %ebx,%ebx
  80ae50:	74 1f                	je     80ae71 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80ae52:	c7 45 e4 56 bf 80 00 	movl   $0x80bf56,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae59:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80ae5c:	83 ec 0c             	sub    $0xc,%esp
  80ae5f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae62:	50                   	push   %eax
  80ae63:	e8 f2 74 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80ae68:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae6c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae6f:	c9                   	leave  
  80ae70:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae71:	83 ec 04             	sub    $0x4,%esp
  80ae74:	68 31 31 81 00       	push   $0x813131
  80ae79:	68 fa 00 00 00       	push   $0xfa
  80ae7e:	68 3e 30 81 00       	push   $0x81303e
  80ae83:	e8 20 37 00 00       	call   80e5a8 <_panic>

0080ae88 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80ae88:	55                   	push   %ebp
  80ae89:	89 e5                	mov    %esp,%ebp
  80ae8b:	53                   	push   %ebx
  80ae8c:	83 ec 14             	sub    $0x14,%esp
  80ae8f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80ae92:	85 db                	test   %ebx,%ebx
  80ae94:	74 36                	je     80aecc <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80ae96:	8b 43 18             	mov    0x18(%ebx),%eax
  80ae99:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ae9c:	74 45                	je     80aee3 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80ae9e:	83 ec 04             	sub    $0x4,%esp
  80aea1:	6a 00                	push   $0x0
  80aea3:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80aea6:	52                   	push   %edx
  80aea7:	50                   	push   %eax
  80aea8:	e8 1b f4 ff ff       	call   80a2c8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80aead:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80aeb0:	83 c4 10             	add    $0x10,%esp
  80aeb3:	85 c0                	test   %eax,%eax
  80aeb5:	74 0d                	je     80aec4 <netconn_accept+0x3c>
  80aeb7:	83 ec 04             	sub    $0x4,%esp
  80aeba:	6a 00                	push   $0x0
  80aebc:	6a 01                	push   $0x1
  80aebe:	53                   	push   %ebx
  80aebf:	ff d0                	call   *%eax
  80aec1:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80aec4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80aec7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aeca:	c9                   	leave  
  80aecb:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80aecc:	83 ec 04             	sub    $0x4,%esp
  80aecf:	68 4e 31 81 00       	push   $0x81314e
  80aed4:	68 10 01 00 00       	push   $0x110
  80aed9:	68 3e 30 81 00       	push   $0x81303e
  80aede:	e8 c5 36 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80aee3:	83 ec 04             	sub    $0x4,%esp
  80aee6:	68 f8 2f 81 00       	push   $0x812ff8
  80aeeb:	68 11 01 00 00       	push   $0x111
  80aef0:	68 3e 30 81 00       	push   $0x81303e
  80aef5:	e8 ae 36 00 00       	call   80e5a8 <_panic>

0080aefa <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80aefa:	55                   	push   %ebp
  80aefb:	89 e5                	mov    %esp,%ebp
  80aefd:	53                   	push   %ebx
  80aefe:	83 ec 24             	sub    $0x24,%esp
  80af01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80af04:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80af0b:	85 db                	test   %ebx,%ebx
  80af0d:	0f 84 cc 00 00 00    	je     80afdf <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80af13:	8b 43 14             	mov    0x14(%ebx),%eax
  80af16:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af19:	0f 84 d7 00 00 00    	je     80aff6 <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80af1f:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80af23:	0f 8c 27 01 00 00    	jl     80b050 <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80af29:	83 3b 10             	cmpl   $0x10,(%ebx)
  80af2c:	0f 85 e0 00 00 00    	jne    80b012 <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80af32:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80af36:	0f 84 c5 00 00 00    	je     80b001 <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80af3c:	83 ec 0c             	sub    $0xc,%esp
  80af3f:	6a 06                	push   $0x6
  80af41:	e8 fa 94 ff ff       	call   804440 <memp_malloc>
  80af46:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80af49:	83 c4 10             	add    $0x10,%esp
  80af4c:	85 c0                	test   %eax,%eax
  80af4e:	0f 84 b8 00 00 00    	je     80b00c <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80af54:	83 ec 04             	sub    $0x4,%esp
  80af57:	6a 00                	push   $0x0
  80af59:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80af5c:	50                   	push   %eax
  80af5d:	ff 73 14             	pushl  0x14(%ebx)
  80af60:	e8 63 f3 ff ff       	call   80a2c8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80af65:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af68:	83 c4 10             	add    $0x10,%esp
  80af6b:	85 c0                	test   %eax,%eax
  80af6d:	0f 84 e4 00 00 00    	je     80b057 <netconn_recv+0x15d>
      len = p->tot_len;
  80af73:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80af77:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80af7b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80af7e:	85 c9                	test   %ecx,%ecx
  80af80:	74 1a                	je     80af9c <netconn_recv+0xa2>
  80af82:	83 ec 04             	sub    $0x4,%esp
  80af85:	0f b7 d2             	movzwl %dx,%edx
  80af88:	52                   	push   %edx
  80af89:	6a 01                	push   $0x1
  80af8b:	53                   	push   %ebx
  80af8c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80af8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80af91:	83 c4 10             	add    $0x10,%esp
  80af94:	85 c0                	test   %eax,%eax
  80af96:	0f 84 cb 00 00 00    	je     80b067 <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80af9c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80af9f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80afa1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80afa4:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80afa7:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80afad:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80afb4:	c7 45 e4 e4 c0 80 00 	movl   $0x80c0e4,-0x1c(%ebp)
    msg.msg.conn = conn;
  80afbb:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80afbe:	8b 02                	mov    (%edx),%eax
  80afc0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80afc4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80afc8:	83 ec 0c             	sub    $0xc,%esp
  80afcb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afce:	50                   	push   %eax
  80afcf:	e8 86 73 ff ff       	call   80235a <tcpip_apimsg>
  80afd4:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80afd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80afda:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afdd:	c9                   	leave  
  80afde:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80afdf:	83 ec 04             	sub    $0x4,%esp
  80afe2:	68 6b 31 81 00       	push   $0x81316b
  80afe7:	68 3a 01 00 00       	push   $0x13a
  80afec:	68 3e 30 81 00       	push   $0x81303e
  80aff1:	e8 b2 35 00 00       	call   80e5a8 <_panic>
    conn->err = ERR_CONN;
  80aff6:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80affa:	b8 00 00 00 00       	mov    $0x0,%eax
  80afff:	eb d9                	jmp    80afda <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80b001:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b005:	b8 00 00 00 00       	mov    $0x0,%eax
  80b00a:	eb ce                	jmp    80afda <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80b00c:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b010:	eb c8                	jmp    80afda <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b012:	83 ec 04             	sub    $0x4,%esp
  80b015:	6a 00                	push   $0x0
  80b017:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b01a:	52                   	push   %edx
  80b01b:	50                   	push   %eax
  80b01c:	e8 a7 f2 ff ff       	call   80a2c8 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b021:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b024:	83 c4 10             	add    $0x10,%esp
  80b027:	85 c0                	test   %eax,%eax
  80b029:	74 ac                	je     80afd7 <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b02b:	8b 10                	mov    (%eax),%edx
  80b02d:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b031:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b035:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b038:	85 d2                	test   %edx,%edx
  80b03a:	74 9b                	je     80afd7 <netconn_recv+0xdd>
  80b03c:	83 ec 04             	sub    $0x4,%esp
  80b03f:	8b 00                	mov    (%eax),%eax
  80b041:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b045:	50                   	push   %eax
  80b046:	6a 01                	push   $0x1
  80b048:	53                   	push   %ebx
  80b049:	ff d2                	call   *%edx
  80b04b:	83 c4 10             	add    $0x10,%esp
  80b04e:	eb 87                	jmp    80afd7 <netconn_recv+0xdd>
    return NULL;
  80b050:	b8 00 00 00 00       	mov    $0x0,%eax
  80b055:	eb 83                	jmp    80afda <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b057:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b05a:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b05f:	85 c9                	test   %ecx,%ecx
  80b061:	0f 85 1b ff ff ff    	jne    80af82 <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b067:	83 ec 08             	sub    $0x8,%esp
  80b06a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b06d:	6a 06                	push   $0x6
  80b06f:	e8 22 94 ff ff       	call   804496 <memp_free>
      if (conn->err == ERR_OK) {
  80b074:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b077:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b07c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b080:	0f 85 54 ff ff ff    	jne    80afda <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b086:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b08a:	e9 4b ff ff ff       	jmp    80afda <netconn_recv+0xe0>

0080b08f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b08f:	55                   	push   %ebp
  80b090:	89 e5                	mov    %esp,%ebp
  80b092:	53                   	push   %ebx
  80b093:	83 ec 24             	sub    $0x24,%esp
  80b096:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b099:	85 db                	test   %ebx,%ebx
  80b09b:	74 25                	je     80b0c2 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b09d:	c7 45 e4 3e c0 80 00 	movl   $0x80c03e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b0a4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b0a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b0ad:	83 ec 0c             	sub    $0xc,%esp
  80b0b0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b0b3:	50                   	push   %eax
  80b0b4:	e8 a1 72 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80b0b9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b0bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0c0:	c9                   	leave  
  80b0c1:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b0c2:	83 ec 04             	sub    $0x4,%esp
  80b0c5:	68 86 31 81 00       	push   $0x813186
  80b0ca:	68 b9 01 00 00       	push   $0x1b9
  80b0cf:	68 3e 30 81 00       	push   $0x81303e
  80b0d4:	e8 cf 34 00 00       	call   80e5a8 <_panic>

0080b0d9 <netconn_sendto>:
{
  80b0d9:	55                   	push   %ebp
  80b0da:	89 e5                	mov    %esp,%ebp
  80b0dc:	83 ec 08             	sub    $0x8,%esp
  80b0df:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b0e2:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b0e5:	85 c0                	test   %eax,%eax
  80b0e7:	74 1b                	je     80b104 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b0e9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b0ec:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b0ef:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b0f3:	83 ec 08             	sub    $0x8,%esp
  80b0f6:	50                   	push   %eax
  80b0f7:	ff 75 08             	pushl  0x8(%ebp)
  80b0fa:	e8 90 ff ff ff       	call   80b08f <netconn_send>
  80b0ff:	83 c4 10             	add    $0x10,%esp
}
  80b102:	c9                   	leave  
  80b103:	c3                   	ret    
  return ERR_VAL;
  80b104:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b109:	eb f7                	jmp    80b102 <netconn_sendto+0x29>

0080b10b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b10b:	55                   	push   %ebp
  80b10c:	89 e5                	mov    %esp,%ebp
  80b10e:	53                   	push   %ebx
  80b10f:	83 ec 24             	sub    $0x24,%esp
  80b112:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b115:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b118:	85 db                	test   %ebx,%ebx
  80b11a:	74 33                	je     80b14f <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b11c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b11f:	75 45                	jne    80b166 <netconn_write+0x5b>

  msg.function = do_write;
  80b121:	c7 45 e4 2a c1 80 00 	movl   $0x80c12a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b128:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b12b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b12e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b131:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b134:	8b 45 10             	mov    0x10(%ebp),%eax
  80b137:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b13a:	83 ec 0c             	sub    $0xc,%esp
  80b13d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b140:	50                   	push   %eax
  80b141:	e8 14 72 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80b146:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b14a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b14d:	c9                   	leave  
  80b14e:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b14f:	83 ec 04             	sub    $0x4,%esp
  80b152:	68 a1 31 81 00       	push   $0x8131a1
  80b157:	68 d3 01 00 00       	push   $0x1d3
  80b15c:	68 3e 30 81 00       	push   $0x81303e
  80b161:	e8 42 34 00 00       	call   80e5a8 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b166:	83 ec 04             	sub    $0x4,%esp
  80b169:	68 1c 30 81 00       	push   $0x81301c
  80b16e:	68 d4 01 00 00       	push   $0x1d4
  80b173:	68 3e 30 81 00       	push   $0x81303e
  80b178:	e8 2b 34 00 00       	call   80e5a8 <_panic>

0080b17d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b17d:	55                   	push   %ebp
  80b17e:	89 e5                	mov    %esp,%ebp
  80b180:	53                   	push   %ebx
  80b181:	83 ec 24             	sub    $0x24,%esp
  80b184:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b187:	85 db                	test   %ebx,%ebx
  80b189:	74 1f                	je     80b1aa <netconn_close+0x2d>

  msg.function = do_close;
  80b18b:	c7 45 e4 41 c2 80 00 	movl   $0x80c241,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b192:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b195:	83 ec 0c             	sub    $0xc,%esp
  80b198:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b19b:	50                   	push   %eax
  80b19c:	e8 b9 71 ff ff       	call   80235a <tcpip_apimsg>
  return conn->err;
  80b1a1:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1a8:	c9                   	leave  
  80b1a9:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b1aa:	83 ec 04             	sub    $0x4,%esp
  80b1ad:	68 bd 31 81 00       	push   $0x8131bd
  80b1b2:	68 ed 01 00 00       	push   $0x1ed
  80b1b7:	68 3e 30 81 00       	push   $0x81303e
  80b1bc:	e8 e7 33 00 00       	call   80e5a8 <_panic>

0080b1c1 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b1c1:	55                   	push   %ebp
  80b1c2:	89 e5                	mov    %esp,%ebp
  80b1c4:	56                   	push   %esi
  80b1c5:	53                   	push   %ebx
  80b1c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b1c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1cc:	8b 75 10             	mov    0x10(%ebp),%esi
  80b1cf:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b1d2:	85 c0                	test   %eax,%eax
  80b1d4:	74 5a                	je     80b230 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b1d6:	85 db                	test   %ebx,%ebx
  80b1d8:	74 6d                	je     80b247 <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b1da:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b1dd:	75 7f                	jne    80b25e <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b1df:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b1e3:	0f 84 8c 00 00 00    	je     80b275 <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b1e9:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b1ec:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b1f1:	85 f6                	test   %esi,%esi
  80b1f3:	74 08                	je     80b1fd <recv_tcp+0x3c>
    len = p->tot_len;
  80b1f5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b1f9:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b1fd:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b200:	85 d2                	test   %edx,%edx
  80b202:	74 0f                	je     80b213 <recv_tcp+0x52>
  80b204:	83 ec 04             	sub    $0x4,%esp
  80b207:	0f b7 c0             	movzwl %ax,%eax
  80b20a:	50                   	push   %eax
  80b20b:	6a 00                	push   $0x0
  80b20d:	53                   	push   %ebx
  80b20e:	ff d2                	call   *%edx
  80b210:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b213:	83 ec 08             	sub    $0x8,%esp
  80b216:	56                   	push   %esi
  80b217:	ff 73 14             	pushl  0x14(%ebx)
  80b21a:	e8 b4 ef ff ff       	call   80a1d3 <sys_mbox_trypost>
  80b21f:	83 c4 10             	add    $0x10,%esp
  80b222:	84 c0                	test   %al,%al
  80b224:	0f 95 c0             	setne  %al
  80b227:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b229:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b22c:	5b                   	pop    %ebx
  80b22d:	5e                   	pop    %esi
  80b22e:	5d                   	pop    %ebp
  80b22f:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b230:	83 ec 04             	sub    $0x4,%esp
  80b233:	68 dc 31 81 00       	push   $0x8131dc
  80b238:	68 c1 00 00 00       	push   $0xc1
  80b23d:	68 26 33 81 00       	push   $0x813326
  80b242:	e8 61 33 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b247:	83 ec 04             	sub    $0x4,%esp
  80b24a:	68 00 32 81 00       	push   $0x813200
  80b24f:	68 c2 00 00 00       	push   $0xc2
  80b254:	68 26 33 81 00       	push   $0x813326
  80b259:	e8 4a 33 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b25e:	83 ec 04             	sub    $0x4,%esp
  80b261:	68 3d 33 81 00       	push   $0x81333d
  80b266:	68 c4 00 00 00       	push   $0xc4
  80b26b:	68 26 33 81 00       	push   $0x813326
  80b270:	e8 33 33 00 00       	call   80e5a8 <_panic>
    return ERR_VAL;
  80b275:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b27a:	eb ad                	jmp    80b229 <recv_tcp+0x68>

0080b27c <recv_udp>:
{
  80b27c:	55                   	push   %ebp
  80b27d:	89 e5                	mov    %esp,%ebp
  80b27f:	57                   	push   %edi
  80b280:	56                   	push   %esi
  80b281:	53                   	push   %ebx
  80b282:	83 ec 1c             	sub    $0x1c,%esp
  80b285:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b288:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b28b:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b28e:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b291:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b294:	85 c0                	test   %eax,%eax
  80b296:	74 7f                	je     80b317 <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b298:	85 db                	test   %ebx,%ebx
  80b29a:	0f 84 8e 00 00 00    	je     80b32e <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b2a0:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b2a3:	0f 85 9c 00 00 00    	jne    80b345 <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b2a9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b2ad:	0f 84 a9 00 00 00    	je     80b35c <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b2b3:	83 ec 0c             	sub    $0xc,%esp
  80b2b6:	6a 06                	push   $0x6
  80b2b8:	e8 83 91 ff ff       	call   804440 <memp_malloc>
  80b2bd:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b2bf:	83 c4 10             	add    $0x10,%esp
  80b2c2:	85 c0                	test   %eax,%eax
  80b2c4:	0f 84 a0 00 00 00    	je     80b36a <recv_udp+0xee>
    buf->p = p;
  80b2ca:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b2cc:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b2cf:	8b 45 14             	mov    0x14(%ebp),%eax
  80b2d2:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b2d5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2d9:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b2dd:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b2e1:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b2e5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b2e8:	85 c0                	test   %eax,%eax
  80b2ea:	74 10                	je     80b2fc <recv_udp+0x80>
  80b2ec:	83 ec 04             	sub    $0x4,%esp
  80b2ef:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b2f3:	52                   	push   %edx
  80b2f4:	6a 00                	push   $0x0
  80b2f6:	53                   	push   %ebx
  80b2f7:	ff d0                	call   *%eax
  80b2f9:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b2fc:	83 ec 08             	sub    $0x8,%esp
  80b2ff:	56                   	push   %esi
  80b300:	ff 73 14             	pushl  0x14(%ebx)
  80b303:	e8 cb ee ff ff       	call   80a1d3 <sys_mbox_trypost>
  80b308:	83 c4 10             	add    $0x10,%esp
  80b30b:	84 c0                	test   %al,%al
  80b30d:	75 69                	jne    80b378 <recv_udp+0xfc>
}
  80b30f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b312:	5b                   	pop    %ebx
  80b313:	5e                   	pop    %esi
  80b314:	5f                   	pop    %edi
  80b315:	5d                   	pop    %ebp
  80b316:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b317:	83 ec 04             	sub    $0x4,%esp
  80b31a:	68 20 32 81 00       	push   $0x813220
  80b31f:	68 8e 00 00 00       	push   $0x8e
  80b324:	68 26 33 81 00       	push   $0x813326
  80b329:	e8 7a 32 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b32e:	83 ec 04             	sub    $0x4,%esp
  80b331:	68 44 32 81 00       	push   $0x813244
  80b336:	68 8f 00 00 00       	push   $0x8f
  80b33b:	68 26 33 81 00       	push   $0x813326
  80b340:	e8 63 32 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b345:	83 ec 04             	sub    $0x4,%esp
  80b348:	68 5b 33 81 00       	push   $0x81335b
  80b34d:	68 91 00 00 00       	push   $0x91
  80b352:	68 26 33 81 00       	push   $0x813326
  80b357:	e8 4c 32 00 00       	call   80e5a8 <_panic>
    pbuf_free(p);
  80b35c:	83 ec 0c             	sub    $0xc,%esp
  80b35f:	57                   	push   %edi
  80b360:	e8 7e 94 ff ff       	call   8047e3 <pbuf_free>
    return;
  80b365:	83 c4 10             	add    $0x10,%esp
  80b368:	eb a5                	jmp    80b30f <recv_udp+0x93>
    pbuf_free(p);
  80b36a:	83 ec 0c             	sub    $0xc,%esp
  80b36d:	57                   	push   %edi
  80b36e:	e8 70 94 ff ff       	call   8047e3 <pbuf_free>
    return;
  80b373:	83 c4 10             	add    $0x10,%esp
  80b376:	eb 97                	jmp    80b30f <recv_udp+0x93>
    netbuf_delete(buf);
  80b378:	83 ec 0c             	sub    $0xc,%esp
  80b37b:	56                   	push   %esi
  80b37c:	e8 c9 70 ff ff       	call   80244a <netbuf_delete>
    return;
  80b381:	83 c4 10             	add    $0x10,%esp
  80b384:	eb 89                	jmp    80b30f <recv_udp+0x93>

0080b386 <recv_raw>:
{
  80b386:	55                   	push   %ebp
  80b387:	89 e5                	mov    %esp,%ebp
  80b389:	57                   	push   %edi
  80b38a:	56                   	push   %esi
  80b38b:	53                   	push   %ebx
  80b38c:	83 ec 0c             	sub    $0xc,%esp
  80b38f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b392:	85 db                	test   %ebx,%ebx
  80b394:	74 06                	je     80b39c <recv_raw+0x16>
  80b396:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b39a:	75 0d                	jne    80b3a9 <recv_raw+0x23>
}
  80b39c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b3a4:	5b                   	pop    %ebx
  80b3a5:	5e                   	pop    %esi
  80b3a6:	5f                   	pop    %edi
  80b3a7:	5d                   	pop    %ebp
  80b3a8:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b3a9:	83 ec 04             	sub    $0x4,%esp
  80b3ac:	6a 00                	push   $0x0
  80b3ae:	8b 45 10             	mov    0x10(%ebp),%eax
  80b3b1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b3b5:	50                   	push   %eax
  80b3b6:	6a 03                	push   $0x3
  80b3b8:	e8 ec 94 ff ff       	call   8048a9 <pbuf_alloc>
  80b3bd:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b3bf:	83 c4 10             	add    $0x10,%esp
  80b3c2:	85 c0                	test   %eax,%eax
  80b3c4:	74 d6                	je     80b39c <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b3c6:	83 ec 08             	sub    $0x8,%esp
  80b3c9:	ff 75 10             	pushl  0x10(%ebp)
  80b3cc:	50                   	push   %eax
  80b3cd:	e8 b9 99 ff ff       	call   804d8b <pbuf_copy>
  80b3d2:	83 c4 10             	add    $0x10,%esp
  80b3d5:	84 c0                	test   %al,%al
  80b3d7:	75 73                	jne    80b44c <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b3d9:	83 ec 0c             	sub    $0xc,%esp
  80b3dc:	6a 06                	push   $0x6
  80b3de:	e8 5d 90 ff ff       	call   804440 <memp_malloc>
  80b3e3:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b3e5:	83 c4 10             	add    $0x10,%esp
  80b3e8:	85 c0                	test   %eax,%eax
  80b3ea:	74 71                	je     80b45d <recv_raw+0xd7>
      buf->p = q;
  80b3ec:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b3ee:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b3f1:	8b 46 04             	mov    0x4(%esi),%eax
  80b3f4:	83 c0 0c             	add    $0xc,%eax
  80b3f7:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b3fa:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3fd:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b401:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b405:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b409:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b40d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b410:	85 c0                	test   %eax,%eax
  80b412:	74 10                	je     80b424 <recv_raw+0x9e>
  80b414:	83 ec 04             	sub    $0x4,%esp
  80b417:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b41b:	52                   	push   %edx
  80b41c:	6a 00                	push   $0x0
  80b41e:	53                   	push   %ebx
  80b41f:	ff d0                	call   *%eax
  80b421:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b424:	83 ec 08             	sub    $0x8,%esp
  80b427:	57                   	push   %edi
  80b428:	ff 73 14             	pushl  0x14(%ebx)
  80b42b:	e8 a3 ed ff ff       	call   80a1d3 <sys_mbox_trypost>
  80b430:	83 c4 10             	add    $0x10,%esp
  80b433:	84 c0                	test   %al,%al
  80b435:	0f 84 61 ff ff ff    	je     80b39c <recv_raw+0x16>
        netbuf_delete(buf);
  80b43b:	83 ec 0c             	sub    $0xc,%esp
  80b43e:	57                   	push   %edi
  80b43f:	e8 06 70 ff ff       	call   80244a <netbuf_delete>
  80b444:	83 c4 10             	add    $0x10,%esp
  80b447:	e9 50 ff ff ff       	jmp    80b39c <recv_raw+0x16>
        pbuf_free(q);
  80b44c:	83 ec 0c             	sub    $0xc,%esp
  80b44f:	56                   	push   %esi
  80b450:	e8 8e 93 ff ff       	call   8047e3 <pbuf_free>
  80b455:	83 c4 10             	add    $0x10,%esp
  80b458:	e9 3f ff ff ff       	jmp    80b39c <recv_raw+0x16>
        pbuf_free(q);
  80b45d:	83 ec 0c             	sub    $0xc,%esp
  80b460:	56                   	push   %esi
  80b461:	e8 7d 93 ff ff       	call   8047e3 <pbuf_free>
        return 0;
  80b466:	83 c4 10             	add    $0x10,%esp
  80b469:	e9 2e ff ff ff       	jmp    80b39c <recv_raw+0x16>

0080b46e <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b46e:	55                   	push   %ebp
  80b46f:	89 e5                	mov    %esp,%ebp
  80b471:	53                   	push   %ebx
  80b472:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b475:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b478:	50                   	push   %eax
  80b479:	53                   	push   %ebx
  80b47a:	e8 31 a3 ff ff       	call   8057b0 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b47f:	83 c4 08             	add    $0x8,%esp
  80b482:	68 c1 b1 80 00       	push   $0x80b1c1
  80b487:	53                   	push   %ebx
  80b488:	e8 31 a3 ff ff       	call   8057be <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b48d:	83 c4 08             	add    $0x8,%esp
  80b490:	68 50 b9 80 00       	push   $0x80b950
  80b495:	53                   	push   %ebx
  80b496:	e8 34 a3 ff ff       	call   8057cf <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b49b:	83 c4 0c             	add    $0xc,%esp
  80b49e:	6a 04                	push   $0x4
  80b4a0:	68 0a b9 80 00       	push   $0x80b90a
  80b4a5:	53                   	push   %ebx
  80b4a6:	e8 54 a3 ff ff       	call   8057ff <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b4ab:	83 c4 08             	add    $0x8,%esp
  80b4ae:	68 0d b5 80 00       	push   $0x80b50d
  80b4b3:	53                   	push   %ebx
  80b4b4:	e8 27 a3 ff ff       	call   8057e0 <tcp_err>
}
  80b4b9:	83 c4 10             	add    $0x10,%esp
  80b4bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4bf:	c9                   	leave  
  80b4c0:	c3                   	ret    

0080b4c1 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b4c1:	55                   	push   %ebp
  80b4c2:	89 e5                	mov    %esp,%ebp
  80b4c4:	53                   	push   %ebx
  80b4c5:	83 ec 04             	sub    $0x4,%esp
  80b4c8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b4cb:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b4ce:	85 db                	test   %ebx,%ebx
  80b4d0:	74 34                	je     80b506 <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b4d2:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b4d5:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b4d8:	75 04                	jne    80b4de <do_connected+0x1d>
  80b4da:	84 c0                	test   %al,%al
  80b4dc:	74 1f                	je     80b4fd <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b4de:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b4e5:	83 ec 0c             	sub    $0xc,%esp
  80b4e8:	ff 73 10             	pushl  0x10(%ebx)
  80b4eb:	e8 63 eb ff ff       	call   80a053 <sys_sem_signal>
  return ERR_OK;
  80b4f0:	83 c4 10             	add    $0x10,%esp
  80b4f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b4f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b4fb:	c9                   	leave  
  80b4fc:	c3                   	ret    
    setup_tcp(conn);
  80b4fd:	89 d8                	mov    %ebx,%eax
  80b4ff:	e8 6a ff ff ff       	call   80b46e <setup_tcp>
  80b504:	eb d8                	jmp    80b4de <do_connected+0x1d>
    return ERR_VAL;
  80b506:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b50b:	eb eb                	jmp    80b4f8 <do_connected+0x37>

0080b50d <err_tcp>:
{
  80b50d:	55                   	push   %ebp
  80b50e:	89 e5                	mov    %esp,%ebp
  80b510:	53                   	push   %ebx
  80b511:	83 ec 04             	sub    $0x4,%esp
  80b514:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b517:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b51a:	85 db                	test   %ebx,%ebx
  80b51c:	74 7e                	je     80b59c <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b51e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b525:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b528:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b52c:	74 24                	je     80b552 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b52e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b531:	85 c0                	test   %eax,%eax
  80b533:	74 0d                	je     80b542 <err_tcp+0x35>
  80b535:	83 ec 04             	sub    $0x4,%esp
  80b538:	6a 00                	push   $0x0
  80b53a:	6a 00                	push   $0x0
  80b53c:	53                   	push   %ebx
  80b53d:	ff d0                	call   *%eax
  80b53f:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b542:	83 ec 08             	sub    $0x8,%esp
  80b545:	6a 00                	push   $0x0
  80b547:	ff 73 14             	pushl  0x14(%ebx)
  80b54a:	e8 49 ed ff ff       	call   80a298 <sys_mbox_post>
  80b54f:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b552:	8b 43 10             	mov    0x10(%ebx),%eax
  80b555:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b558:	74 06                	je     80b560 <err_tcp+0x53>
  80b55a:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b55e:	74 53                	je     80b5b3 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b560:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b564:	74 24                	je     80b58a <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b566:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b569:	85 c0                	test   %eax,%eax
  80b56b:	74 0d                	je     80b57a <err_tcp+0x6d>
  80b56d:	83 ec 04             	sub    $0x4,%esp
  80b570:	6a 00                	push   $0x0
  80b572:	6a 00                	push   $0x0
  80b574:	53                   	push   %ebx
  80b575:	ff d0                	call   *%eax
  80b577:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b57a:	83 ec 08             	sub    $0x8,%esp
  80b57d:	6a 00                	push   $0x0
  80b57f:	ff 73 18             	pushl  0x18(%ebx)
  80b582:	e8 11 ed ff ff       	call   80a298 <sys_mbox_post>
  80b587:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b58a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b58d:	83 f8 01             	cmp    $0x1,%eax
  80b590:	74 36                	je     80b5c8 <err_tcp+0xbb>
  80b592:	83 f8 04             	cmp    $0x4,%eax
  80b595:	74 31                	je     80b5c8 <err_tcp+0xbb>
}
  80b597:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b59a:	c9                   	leave  
  80b59b:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b59c:	83 ec 04             	sub    $0x4,%esp
  80b59f:	68 79 33 81 00       	push   $0x813379
  80b5a4:	68 22 01 00 00       	push   $0x122
  80b5a9:	68 26 33 81 00       	push   $0x813326
  80b5ae:	e8 f5 2f 00 00       	call   80e5a8 <_panic>
    conn->state = NETCONN_NONE;
  80b5b3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5ba:	83 ec 0c             	sub    $0xc,%esp
  80b5bd:	50                   	push   %eax
  80b5be:	e8 90 ea ff ff       	call   80a053 <sys_sem_signal>
  80b5c3:	83 c4 10             	add    $0x10,%esp
  80b5c6:	eb 98                	jmp    80b560 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b5c8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b5cf:	83 ec 0c             	sub    $0xc,%esp
  80b5d2:	ff 73 10             	pushl  0x10(%ebx)
  80b5d5:	e8 79 ea ff ff       	call   80a053 <sys_sem_signal>
  80b5da:	83 c4 10             	add    $0x10,%esp
}
  80b5dd:	eb b8                	jmp    80b597 <err_tcp+0x8a>

0080b5df <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b5df:	55                   	push   %ebp
  80b5e0:	89 e5                	mov    %esp,%ebp
  80b5e2:	57                   	push   %edi
  80b5e3:	56                   	push   %esi
  80b5e4:	53                   	push   %ebx
  80b5e5:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b5e8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b5ec:	0f 85 c9 00 00 00    	jne    80b6bb <do_writemore+0xdc>
  80b5f2:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b5f4:	8b 40 24             	mov    0x24(%eax),%eax
  80b5f7:	8b 7e 28             	mov    0x28(%esi),%edi
  80b5fa:	89 fa                	mov    %edi,%edx
  80b5fc:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b5ff:	8b 58 08             	mov    0x8(%eax),%ebx
  80b602:	89 d9                	mov    %ebx,%ecx
  80b604:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b606:	29 fb                	sub    %edi,%ebx
  80b608:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b60e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b613:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b616:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b619:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b61d:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b622:	0f b7 db             	movzwl %bx,%ebx
  80b625:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b629:	50                   	push   %eax
  80b62a:	53                   	push   %ebx
  80b62b:	52                   	push   %edx
  80b62c:	51                   	push   %ecx
  80b62d:	e8 95 c9 ff ff       	call   807fc7 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b632:	89 da                	mov    %ebx,%edx
  80b634:	03 56 28             	add    0x28(%esi),%edx
  80b637:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b63a:	83 c4 10             	add    $0x10,%esp
  80b63d:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b640:	0f 8f 8c 00 00 00    	jg     80b6d2 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b646:	84 c0                	test   %al,%al
  80b648:	0f 85 bf 00 00 00    	jne    80b70d <do_writemore+0x12e>
    conn->write_offset += len;
  80b64e:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b651:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b656:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b659:	0f 84 8a 00 00 00    	je     80b6e9 <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b65f:	8b 46 08             	mov    0x8(%esi),%eax
  80b662:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b666:	74 1a                	je     80b682 <do_writemore+0xa3>
  80b668:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b66c:	75 14                	jne    80b682 <do_writemore+0xa3>
  80b66e:	8b 50 74             	mov    0x74(%eax),%edx
  80b671:	85 d2                	test   %edx,%edx
  80b673:	0f 84 88 00 00 00    	je     80b701 <do_writemore+0x122>
  80b679:	83 3a 00             	cmpl   $0x0,(%edx)
  80b67c:	0f 84 85 00 00 00    	je     80b707 <do_writemore+0x128>
  80b682:	83 ec 0c             	sub    $0xc,%esp
  80b685:	50                   	push   %eax
  80b686:	e8 93 c9 ff ff       	call   80801e <tcp_output>
    conn->err = err;
  80b68b:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b68e:	83 c4 10             	add    $0x10,%esp
  80b691:	84 c0                	test   %al,%al
  80b693:	75 1e                	jne    80b6b3 <do_writemore+0xd4>
  80b695:	8b 46 08             	mov    0x8(%esi),%eax
  80b698:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b69e:	77 13                	ja     80b6b3 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b6a0:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b6a3:	85 c0                	test   %eax,%eax
  80b6a5:	74 0c                	je     80b6b3 <do_writemore+0xd4>
  80b6a7:	83 ec 04             	sub    $0x4,%esp
  80b6aa:	53                   	push   %ebx
  80b6ab:	6a 03                	push   $0x3
  80b6ad:	56                   	push   %esi
  80b6ae:	ff d0                	call   *%eax
  80b6b0:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b6b3:	89 f8                	mov    %edi,%eax
  80b6b5:	84 c0                	test   %al,%al
  80b6b7:	74 70                	je     80b729 <do_writemore+0x14a>
  80b6b9:	eb 59                	jmp    80b714 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b6bb:	83 ec 04             	sub    $0x4,%esp
  80b6be:	68 86 33 81 00       	push   $0x813386
  80b6c3:	68 b8 03 00 00       	push   $0x3b8
  80b6c8:	68 26 33 81 00       	push   $0x813326
  80b6cd:	e8 d6 2e 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b6d2:	83 ec 04             	sub    $0x4,%esp
  80b6d5:	68 a3 33 81 00       	push   $0x8133a3
  80b6da:	68 cd 03 00 00       	push   $0x3cd
  80b6df:	68 26 33 81 00       	push   $0x813326
  80b6e4:	e8 bf 2e 00 00       	call   80e5a8 <_panic>
      conn->write_msg = NULL;
  80b6e9:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b6f0:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b6f7:	bf 01 00 00 00       	mov    $0x1,%edi
  80b6fc:	e9 5e ff ff ff       	jmp    80b65f <do_writemore+0x80>
    conn->err = err;
  80b701:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b705:	eb 8e                	jmp    80b695 <do_writemore+0xb6>
  80b707:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b70b:	eb 88                	jmp    80b695 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b70d:	3c ff                	cmp    $0xff,%al
  80b70f:	74 25                	je     80b736 <do_writemore+0x157>
    conn->err = err;
  80b711:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b714:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b71b:	83 ec 0c             	sub    $0xc,%esp
  80b71e:	ff 76 10             	pushl  0x10(%esi)
  80b721:	e8 2d e9 ff ff       	call   80a053 <sys_sem_signal>
  80b726:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b729:	b8 00 00 00 00       	mov    $0x0,%eax
  80b72e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b731:	5b                   	pop    %ebx
  80b732:	5e                   	pop    %esi
  80b733:	5f                   	pop    %edi
  80b734:	5d                   	pop    %ebp
  80b735:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b736:	83 ec 0c             	sub    $0xc,%esp
  80b739:	ff 76 08             	pushl  0x8(%esi)
  80b73c:	e8 dd c8 ff ff       	call   80801e <tcp_output>
  80b741:	83 c4 10             	add    $0x10,%esp
  80b744:	eb e3                	jmp    80b729 <do_writemore+0x14a>

0080b746 <do_close_internal>:
{
  80b746:	55                   	push   %ebp
  80b747:	89 e5                	mov    %esp,%ebp
  80b749:	53                   	push   %ebx
  80b74a:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b74d:	85 c0                	test   %eax,%eax
  80b74f:	0f 84 e2 00 00 00    	je     80b837 <do_close_internal+0xf1>
  80b755:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b757:	83 38 10             	cmpl   $0x10,(%eax)
  80b75a:	0f 85 ee 00 00 00    	jne    80b84e <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b760:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b764:	0f 85 fb 00 00 00    	jne    80b865 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b76a:	8b 40 08             	mov    0x8(%eax),%eax
  80b76d:	85 c0                	test   %eax,%eax
  80b76f:	0f 84 07 01 00 00    	je     80b87c <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b775:	83 ec 08             	sub    $0x8,%esp
  80b778:	6a 00                	push   $0x0
  80b77a:	50                   	push   %eax
  80b77b:	e8 30 a0 ff ff       	call   8057b0 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b780:	8b 43 08             	mov    0x8(%ebx),%eax
  80b783:	83 c4 10             	add    $0x10,%esp
  80b786:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b78a:	0f 84 03 01 00 00    	je     80b893 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b790:	83 ec 08             	sub    $0x8,%esp
  80b793:	6a 00                	push   $0x0
  80b795:	50                   	push   %eax
  80b796:	e8 23 a0 ff ff       	call   8057be <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b79b:	83 c4 08             	add    $0x8,%esp
  80b79e:	6a 00                	push   $0x0
  80b7a0:	ff 73 08             	pushl  0x8(%ebx)
  80b7a3:	e8 49 a0 ff ff       	call   8057f1 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b7a8:	83 c4 08             	add    $0x8,%esp
  80b7ab:	6a 00                	push   $0x0
  80b7ad:	ff 73 08             	pushl  0x8(%ebx)
  80b7b0:	e8 1a a0 ff ff       	call   8057cf <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b7b5:	83 c4 0c             	add    $0xc,%esp
  80b7b8:	6a 04                	push   $0x4
  80b7ba:	6a 00                	push   $0x0
  80b7bc:	ff 73 08             	pushl  0x8(%ebx)
  80b7bf:	e8 3b a0 ff ff       	call   8057ff <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b7c4:	83 c4 08             	add    $0x8,%esp
  80b7c7:	6a 00                	push   $0x0
  80b7c9:	ff 73 08             	pushl  0x8(%ebx)
  80b7cc:	e8 0f a0 ff ff       	call   8057e0 <tcp_err>
  80b7d1:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b7d4:	83 ec 0c             	sub    $0xc,%esp
  80b7d7:	ff 73 08             	pushl  0x8(%ebx)
  80b7da:	e8 d3 a1 ff ff       	call   8059b2 <tcp_close>
  if (err == ERR_OK) {
  80b7df:	83 c4 10             	add    $0x10,%esp
  80b7e2:	84 c0                	test   %al,%al
  80b7e4:	0f 85 bc 00 00 00    	jne    80b8a6 <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b7ea:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b7f1:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b7f8:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b7fc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b7ff:	85 c0                	test   %eax,%eax
  80b801:	74 21                	je     80b824 <do_close_internal+0xde>
  80b803:	83 ec 04             	sub    $0x4,%esp
  80b806:	6a 00                	push   $0x0
  80b808:	6a 00                	push   $0x0
  80b80a:	53                   	push   %ebx
  80b80b:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b80d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b810:	83 c4 10             	add    $0x10,%esp
  80b813:	85 c0                	test   %eax,%eax
  80b815:	74 0d                	je     80b824 <do_close_internal+0xde>
  80b817:	83 ec 04             	sub    $0x4,%esp
  80b81a:	6a 00                	push   $0x0
  80b81c:	6a 02                	push   $0x2
  80b81e:	53                   	push   %ebx
  80b81f:	ff d0                	call   *%eax
  80b821:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b824:	83 ec 0c             	sub    $0xc,%esp
  80b827:	ff 73 10             	pushl  0x10(%ebx)
  80b82a:	e8 24 e8 ff ff       	call   80a053 <sys_sem_signal>
  80b82f:	83 c4 10             	add    $0x10,%esp
}
  80b832:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b835:	c9                   	leave  
  80b836:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b837:	83 ec 04             	sub    $0x4,%esp
  80b83a:	68 94 31 81 00       	push   $0x813194
  80b83f:	68 53 02 00 00       	push   $0x253
  80b844:	68 26 33 81 00       	push   $0x813326
  80b849:	e8 5a 2d 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b84e:	83 ec 04             	sub    $0x4,%esp
  80b851:	68 c1 33 81 00       	push   $0x8133c1
  80b856:	68 54 02 00 00       	push   $0x254
  80b85b:	68 26 33 81 00       	push   $0x813326
  80b860:	e8 43 2d 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b865:	83 ec 04             	sub    $0x4,%esp
  80b868:	68 64 32 81 00       	push   $0x813264
  80b86d:	68 55 02 00 00       	push   $0x255
  80b872:	68 26 33 81 00       	push   $0x813326
  80b877:	e8 2c 2d 00 00       	call   80e5a8 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b87c:	83 ec 04             	sub    $0x4,%esp
  80b87f:	68 df 33 81 00       	push   $0x8133df
  80b884:	68 56 02 00 00       	push   $0x256
  80b889:	68 26 33 81 00       	push   $0x813326
  80b88e:	e8 15 2d 00 00       	call   80e5a8 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80b893:	83 ec 08             	sub    $0x8,%esp
  80b896:	6a 00                	push   $0x0
  80b898:	50                   	push   %eax
  80b899:	e8 53 9f ff ff       	call   8057f1 <tcp_accept>
  80b89e:	83 c4 10             	add    $0x10,%esp
  80b8a1:	e9 2e ff ff ff       	jmp    80b7d4 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b8a6:	8b 43 08             	mov    0x8(%ebx),%eax
  80b8a9:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b8ad:	74 44                	je     80b8f3 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b8af:	83 ec 08             	sub    $0x8,%esp
  80b8b2:	68 50 b9 80 00       	push   $0x80b950
  80b8b7:	50                   	push   %eax
  80b8b8:	e8 12 9f ff ff       	call   8057cf <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b8bd:	83 c4 0c             	add    $0xc,%esp
  80b8c0:	6a 04                	push   $0x4
  80b8c2:	68 0a b9 80 00       	push   $0x80b90a
  80b8c7:	ff 73 08             	pushl  0x8(%ebx)
  80b8ca:	e8 30 9f ff ff       	call   8057ff <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b8cf:	83 c4 08             	add    $0x8,%esp
  80b8d2:	68 0d b5 80 00       	push   $0x80b50d
  80b8d7:	ff 73 08             	pushl  0x8(%ebx)
  80b8da:	e8 01 9f ff ff       	call   8057e0 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b8df:	83 c4 08             	add    $0x8,%esp
  80b8e2:	53                   	push   %ebx
  80b8e3:	ff 73 08             	pushl  0x8(%ebx)
  80b8e6:	e8 c5 9e ff ff       	call   8057b0 <tcp_arg>
  80b8eb:	83 c4 10             	add    $0x10,%esp
}
  80b8ee:	e9 3f ff ff ff       	jmp    80b832 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b8f3:	83 ec 04             	sub    $0x4,%esp
  80b8f6:	68 88 32 81 00       	push   $0x813288
  80b8fb:	68 75 02 00 00       	push   $0x275
  80b900:	68 26 33 81 00       	push   $0x813326
  80b905:	e8 9e 2c 00 00       	call   80e5a8 <_panic>

0080b90a <poll_tcp>:
{
  80b90a:	55                   	push   %ebp
  80b90b:	89 e5                	mov    %esp,%ebp
  80b90d:	83 ec 08             	sub    $0x8,%esp
  80b910:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b913:	85 c0                	test   %eax,%eax
  80b915:	74 14                	je     80b92b <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80b917:	8b 50 04             	mov    0x4(%eax),%edx
  80b91a:	83 fa 01             	cmp    $0x1,%edx
  80b91d:	74 23                	je     80b942 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80b91f:	83 fa 04             	cmp    $0x4,%edx
  80b922:	74 25                	je     80b949 <poll_tcp+0x3f>
}
  80b924:	b8 00 00 00 00       	mov    $0x0,%eax
  80b929:	c9                   	leave  
  80b92a:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b92b:	83 ec 04             	sub    $0x4,%esp
  80b92e:	68 79 33 81 00       	push   $0x813379
  80b933:	68 eb 00 00 00       	push   $0xeb
  80b938:	68 26 33 81 00       	push   $0x813326
  80b93d:	e8 66 2c 00 00       	call   80e5a8 <_panic>
    do_writemore(conn);
  80b942:	e8 98 fc ff ff       	call   80b5df <do_writemore>
  80b947:	eb db                	jmp    80b924 <poll_tcp+0x1a>
    do_close_internal(conn);
  80b949:	e8 f8 fd ff ff       	call   80b746 <do_close_internal>
  80b94e:	eb d4                	jmp    80b924 <poll_tcp+0x1a>

0080b950 <sent_tcp>:
{
  80b950:	55                   	push   %ebp
  80b951:	89 e5                	mov    %esp,%ebp
  80b953:	56                   	push   %esi
  80b954:	53                   	push   %ebx
  80b955:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b958:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b95b:	85 db                	test   %ebx,%ebx
  80b95d:	74 3e                	je     80b99d <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80b95f:	8b 43 04             	mov    0x4(%ebx),%eax
  80b962:	83 f8 01             	cmp    $0x1,%eax
  80b965:	74 4d                	je     80b9b4 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80b967:	83 f8 04             	cmp    $0x4,%eax
  80b96a:	74 6e                	je     80b9da <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80b96c:	8b 43 08             	mov    0x8(%ebx),%eax
  80b96f:	85 c0                	test   %eax,%eax
  80b971:	74 1e                	je     80b991 <sent_tcp+0x41>
  80b973:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b979:	76 16                	jbe    80b991 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80b97b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b97e:	85 c0                	test   %eax,%eax
  80b980:	74 0f                	je     80b991 <sent_tcp+0x41>
  80b982:	83 ec 04             	sub    $0x4,%esp
  80b985:	0f b7 f6             	movzwl %si,%esi
  80b988:	56                   	push   %esi
  80b989:	6a 02                	push   $0x2
  80b98b:	53                   	push   %ebx
  80b98c:	ff d0                	call   *%eax
  80b98e:	83 c4 10             	add    $0x10,%esp
}
  80b991:	b8 00 00 00 00       	mov    $0x0,%eax
  80b996:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b999:	5b                   	pop    %ebx
  80b99a:	5e                   	pop    %esi
  80b99b:	5d                   	pop    %ebp
  80b99c:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b99d:	83 ec 04             	sub    $0x4,%esp
  80b9a0:	68 79 33 81 00       	push   $0x813379
  80b9a5:	68 03 01 00 00       	push   $0x103
  80b9aa:	68 26 33 81 00       	push   $0x813326
  80b9af:	e8 f4 2b 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b9b4:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b9b8:	74 09                	je     80b9c3 <sent_tcp+0x73>
    do_writemore(conn);
  80b9ba:	89 d8                	mov    %ebx,%eax
  80b9bc:	e8 1e fc ff ff       	call   80b5df <do_writemore>
  80b9c1:	eb a9                	jmp    80b96c <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80b9c3:	83 ec 04             	sub    $0x4,%esp
  80b9c6:	68 f2 33 81 00       	push   $0x8133f2
  80b9cb:	68 06 01 00 00       	push   $0x106
  80b9d0:	68 26 33 81 00       	push   $0x813326
  80b9d5:	e8 ce 2b 00 00       	call   80e5a8 <_panic>
    do_close_internal(conn);
  80b9da:	89 d8                	mov    %ebx,%eax
  80b9dc:	e8 65 fd ff ff       	call   80b746 <do_close_internal>
  80b9e1:	eb 89                	jmp    80b96c <sent_tcp+0x1c>

0080b9e3 <do_newconn>:
{
  80b9e3:	55                   	push   %ebp
  80b9e4:	89 e5                	mov    %esp,%ebp
  80b9e6:	56                   	push   %esi
  80b9e7:	53                   	push   %ebx
  80b9e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80b9eb:	8b 03                	mov    (%ebx),%eax
  80b9ed:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80b9f1:	74 17                	je     80ba0a <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80b9f3:	83 ec 0c             	sub    $0xc,%esp
  80b9f6:	8b 03                	mov    (%ebx),%eax
  80b9f8:	ff 70 10             	pushl  0x10(%eax)
  80b9fb:	e8 53 e6 ff ff       	call   80a053 <sys_sem_signal>
}
  80ba00:	83 c4 10             	add    $0x10,%esp
  80ba03:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba06:	5b                   	pop    %ebx
  80ba07:	5e                   	pop    %esi
  80ba08:	5d                   	pop    %ebp
  80ba09:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80ba0a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ba0e:	8b 33                	mov    (%ebx),%esi
  80ba10:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80ba14:	75 20                	jne    80ba36 <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80ba16:	8b 06                	mov    (%esi),%eax
  80ba18:	25 f0 00 00 00       	and    $0xf0,%eax
  80ba1d:	83 f8 20             	cmp    $0x20,%eax
  80ba20:	74 67                	je     80ba89 <do_newconn+0xa6>
  80ba22:	83 f8 40             	cmp    $0x40,%eax
  80ba25:	74 26                	je     80ba4d <do_newconn+0x6a>
  80ba27:	83 f8 10             	cmp    $0x10,%eax
  80ba2a:	0f 84 99 00 00 00    	je     80bac9 <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80ba30:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80ba34:	eb bd                	jmp    80b9f3 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80ba36:	83 ec 04             	sub    $0x4,%esp
  80ba39:	68 ac 32 81 00       	push   $0x8132ac
  80ba3e:	68 8a 01 00 00       	push   $0x18a
  80ba43:	68 26 33 81 00       	push   $0x813326
  80ba48:	e8 5b 2b 00 00       	call   80e5a8 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80ba4d:	83 ec 0c             	sub    $0xc,%esp
  80ba50:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80ba54:	50                   	push   %eax
  80ba55:	e8 67 25 00 00       	call   80dfc1 <raw_new>
  80ba5a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80ba5d:	8b 03                	mov    (%ebx),%eax
  80ba5f:	8b 50 08             	mov    0x8(%eax),%edx
  80ba62:	83 c4 10             	add    $0x10,%esp
  80ba65:	85 d2                	test   %edx,%edx
  80ba67:	74 17                	je     80ba80 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80ba69:	83 ec 04             	sub    $0x4,%esp
  80ba6c:	50                   	push   %eax
  80ba6d:	68 86 b3 80 00       	push   $0x80b386
  80ba72:	52                   	push   %edx
  80ba73:	e8 cd 23 00 00       	call   80de45 <raw_recv>
  80ba78:	83 c4 10             	add    $0x10,%esp
  80ba7b:	e9 73 ff ff ff       	jmp    80b9f3 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80ba80:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80ba84:	e9 6a ff ff ff       	jmp    80b9f3 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80ba89:	e8 26 d5 ff ff       	call   808fb4 <udp_new>
  80ba8e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80ba91:	8b 03                	mov    (%ebx),%eax
  80ba93:	8b 50 08             	mov    0x8(%eax),%edx
  80ba96:	85 d2                	test   %edx,%edx
  80ba98:	74 20                	je     80baba <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80ba9a:	83 38 22             	cmpl   $0x22,(%eax)
  80ba9d:	74 24                	je     80bac3 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80ba9f:	8b 03                	mov    (%ebx),%eax
  80baa1:	83 ec 04             	sub    $0x4,%esp
  80baa4:	50                   	push   %eax
  80baa5:	68 7c b2 80 00       	push   $0x80b27c
  80baaa:	ff 70 08             	pushl  0x8(%eax)
  80baad:	e8 aa d4 ff ff       	call   808f5c <udp_recv>
  80bab2:	83 c4 10             	add    $0x10,%esp
  80bab5:	e9 39 ff ff ff       	jmp    80b9f3 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80baba:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80babe:	e9 30 ff ff ff       	jmp    80b9f3 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bac3:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bac7:	eb d6                	jmp    80ba9f <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bac9:	e8 b2 a7 ff ff       	call   806280 <tcp_new>
  80bace:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bad1:	8b 03                	mov    (%ebx),%eax
  80bad3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bad7:	74 0a                	je     80bae3 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bad9:	e8 90 f9 ff ff       	call   80b46e <setup_tcp>
  80bade:	e9 10 ff ff ff       	jmp    80b9f3 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bae3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bae7:	e9 07 ff ff ff       	jmp    80b9f3 <do_newconn+0x10>

0080baec <netconn_alloc>:
{
  80baec:	55                   	push   %ebp
  80baed:	89 e5                	mov    %esp,%ebp
  80baef:	53                   	push   %ebx
  80baf0:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80baf3:	6a 07                	push   $0x7
  80baf5:	e8 46 89 ff ff       	call   804440 <memp_malloc>
  80bafa:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bafc:	83 c4 10             	add    $0x10,%esp
  80baff:	85 c0                	test   %eax,%eax
  80bb01:	74 5b                	je     80bb5e <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bb03:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bb07:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb0a:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bb0c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bb13:	83 ec 0c             	sub    $0xc,%esp
  80bb16:	6a 00                	push   $0x0
  80bb18:	e8 79 e2 ff ff       	call   809d96 <sys_sem_new>
  80bb1d:	89 43 10             	mov    %eax,0x10(%ebx)
  80bb20:	83 c4 10             	add    $0x10,%esp
  80bb23:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb26:	74 3d                	je     80bb65 <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bb28:	83 ec 0c             	sub    $0xc,%esp
  80bb2b:	6a 00                	push   $0x0
  80bb2d:	e8 0d e4 ff ff       	call   809f3f <sys_mbox_new>
  80bb32:	89 43 14             	mov    %eax,0x14(%ebx)
  80bb35:	83 c4 10             	add    $0x10,%esp
  80bb38:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bb3b:	74 3d                	je     80bb7a <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bb3d:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bb44:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bb4b:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bb52:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb55:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bb58:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bb5e:	89 d8                	mov    %ebx,%eax
  80bb60:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bb63:	c9                   	leave  
  80bb64:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bb65:	83 ec 08             	sub    $0x8,%esp
  80bb68:	53                   	push   %ebx
  80bb69:	6a 07                	push   $0x7
  80bb6b:	e8 26 89 ff ff       	call   804496 <memp_free>
    return NULL;
  80bb70:	83 c4 10             	add    $0x10,%esp
  80bb73:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb78:	eb e4                	jmp    80bb5e <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bb7a:	83 ec 0c             	sub    $0xc,%esp
  80bb7d:	ff 73 10             	pushl  0x10(%ebx)
  80bb80:	e8 92 e2 ff ff       	call   809e17 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bb85:	83 c4 08             	add    $0x8,%esp
  80bb88:	53                   	push   %ebx
  80bb89:	6a 07                	push   $0x7
  80bb8b:	e8 06 89 ff ff       	call   804496 <memp_free>
    return NULL;
  80bb90:	83 c4 10             	add    $0x10,%esp
  80bb93:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bb98:	eb c4                	jmp    80bb5e <netconn_alloc+0x72>

0080bb9a <netconn_free>:
{
  80bb9a:	55                   	push   %ebp
  80bb9b:	89 e5                	mov    %esp,%ebp
  80bb9d:	56                   	push   %esi
  80bb9e:	53                   	push   %ebx
  80bb9f:	83 ec 10             	sub    $0x10,%esp
  80bba2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bba5:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bba9:	75 0b                	jne    80bbb6 <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bbab:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bbae:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bbb2:	75 27                	jne    80bbdb <netconn_free+0x41>
  80bbb4:	eb 68                	jmp    80bc1e <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bbb6:	83 ec 04             	sub    $0x4,%esp
  80bbb9:	68 cc 32 81 00       	push   $0x8132cc
  80bbbe:	68 26 02 00 00       	push   $0x226
  80bbc3:	68 26 33 81 00       	push   $0x813326
  80bbc8:	e8 db 29 00 00       	call   80e5a8 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bbcd:	83 ec 0c             	sub    $0xc,%esp
  80bbd0:	ff 75 f4             	pushl  -0xc(%ebp)
  80bbd3:	e8 72 68 ff ff       	call   80244a <netbuf_delete>
  80bbd8:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bbdb:	83 ec 08             	sub    $0x8,%esp
  80bbde:	56                   	push   %esi
  80bbdf:	ff 73 14             	pushl  0x14(%ebx)
  80bbe2:	e8 cf e7 ff ff       	call   80a3b6 <sys_arch_mbox_tryfetch>
  80bbe7:	83 c4 10             	add    $0x10,%esp
  80bbea:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bbed:	74 1a                	je     80bc09 <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bbef:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bbf2:	75 d9                	jne    80bbcd <netconn_free+0x33>
        if(mem != NULL) {
  80bbf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bbf7:	85 c0                	test   %eax,%eax
  80bbf9:	74 e0                	je     80bbdb <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bbfb:	83 ec 0c             	sub    $0xc,%esp
  80bbfe:	50                   	push   %eax
  80bbff:	e8 df 8b ff ff       	call   8047e3 <pbuf_free>
  80bc04:	83 c4 10             	add    $0x10,%esp
  80bc07:	eb d2                	jmp    80bbdb <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bc09:	83 ec 0c             	sub    $0xc,%esp
  80bc0c:	ff 73 14             	pushl  0x14(%ebx)
  80bc0f:	e8 8c e2 ff ff       	call   809ea0 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bc14:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bc1b:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc1e:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bc21:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bc25:	74 39                	je     80bc60 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc27:	83 ec 08             	sub    $0x8,%esp
  80bc2a:	56                   	push   %esi
  80bc2b:	ff 73 18             	pushl  0x18(%ebx)
  80bc2e:	e8 83 e7 ff ff       	call   80a3b6 <sys_arch_mbox_tryfetch>
  80bc33:	83 c4 10             	add    $0x10,%esp
  80bc36:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc39:	74 10                	je     80bc4b <netconn_free+0xb1>
      netconn_delete((struct netconn *)mem);
  80bc3b:	83 ec 0c             	sub    $0xc,%esp
  80bc3e:	ff 75 f4             	pushl  -0xc(%ebp)
  80bc41:	e8 24 f0 ff ff       	call   80ac6a <netconn_delete>
  80bc46:	83 c4 10             	add    $0x10,%esp
  80bc49:	eb dc                	jmp    80bc27 <netconn_free+0x8d>
    sys_mbox_free(conn->acceptmbox);
  80bc4b:	83 ec 0c             	sub    $0xc,%esp
  80bc4e:	ff 73 18             	pushl  0x18(%ebx)
  80bc51:	e8 4a e2 ff ff       	call   809ea0 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bc56:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bc5d:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bc60:	83 ec 0c             	sub    $0xc,%esp
  80bc63:	ff 73 10             	pushl  0x10(%ebx)
  80bc66:	e8 ac e1 ff ff       	call   809e17 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bc6b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bc72:	83 c4 08             	add    $0x8,%esp
  80bc75:	53                   	push   %ebx
  80bc76:	6a 07                	push   $0x7
  80bc78:	e8 19 88 ff ff       	call   804496 <memp_free>
}
  80bc7d:	83 c4 10             	add    $0x10,%esp
  80bc80:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bc83:	5b                   	pop    %ebx
  80bc84:	5e                   	pop    %esi
  80bc85:	5d                   	pop    %ebp
  80bc86:	c3                   	ret    

0080bc87 <accept_function>:
{
  80bc87:	55                   	push   %ebp
  80bc88:	89 e5                	mov    %esp,%ebp
  80bc8a:	57                   	push   %edi
  80bc8b:	56                   	push   %esi
  80bc8c:	53                   	push   %ebx
  80bc8d:	83 ec 0c             	sub    $0xc,%esp
  80bc90:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc93:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bc96:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bc9a:	74 57                	je     80bcf3 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bc9c:	83 ec 08             	sub    $0x8,%esp
  80bc9f:	ff 73 2c             	pushl  0x2c(%ebx)
  80bca2:	ff 33                	pushl  (%ebx)
  80bca4:	e8 43 fe ff ff       	call   80baec <netconn_alloc>
  80bca9:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bcab:	83 c4 10             	add    $0x10,%esp
  80bcae:	85 c0                	test   %eax,%eax
  80bcb0:	74 72                	je     80bd24 <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bcb2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bcb5:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bcb8:	89 f0                	mov    %esi,%eax
  80bcba:	e8 af f7 ff ff       	call   80b46e <setup_tcp>
  newconn->err = err;
  80bcbf:	89 f8                	mov    %edi,%eax
  80bcc1:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bcc4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcc7:	85 c0                	test   %eax,%eax
  80bcc9:	74 0d                	je     80bcd8 <accept_function+0x51>
  80bccb:	83 ec 04             	sub    $0x4,%esp
  80bcce:	6a 00                	push   $0x0
  80bcd0:	6a 00                	push   $0x0
  80bcd2:	53                   	push   %ebx
  80bcd3:	ff d0                	call   *%eax
  80bcd5:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bcd8:	83 ec 08             	sub    $0x8,%esp
  80bcdb:	56                   	push   %esi
  80bcdc:	ff 73 18             	pushl  0x18(%ebx)
  80bcdf:	e8 ef e4 ff ff       	call   80a1d3 <sys_mbox_trypost>
  80bce4:	83 c4 10             	add    $0x10,%esp
  80bce7:	84 c0                	test   %al,%al
  80bce9:	75 1f                	jne    80bd0a <accept_function+0x83>
}
  80bceb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bcee:	5b                   	pop    %ebx
  80bcef:	5e                   	pop    %esi
  80bcf0:	5f                   	pop    %edi
  80bcf1:	5d                   	pop    %ebp
  80bcf2:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bcf3:	83 ec 04             	sub    $0x4,%esp
  80bcf6:	68 fc 32 81 00       	push   $0x8132fc
  80bcfb:	68 65 01 00 00       	push   $0x165
  80bd00:	68 26 33 81 00       	push   $0x813326
  80bd05:	e8 9e 28 00 00       	call   80e5a8 <_panic>
    newconn->pcb.tcp = NULL;
  80bd0a:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bd11:	83 ec 0c             	sub    $0xc,%esp
  80bd14:	56                   	push   %esi
  80bd15:	e8 80 fe ff ff       	call   80bb9a <netconn_free>
    return ERR_MEM;
  80bd1a:	83 c4 10             	add    $0x10,%esp
  80bd1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd22:	eb c7                	jmp    80bceb <accept_function+0x64>
    return ERR_MEM;
  80bd24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bd29:	eb c0                	jmp    80bceb <accept_function+0x64>

0080bd2b <do_delconn>:
{
  80bd2b:	55                   	push   %ebp
  80bd2c:	89 e5                	mov    %esp,%ebp
  80bd2e:	53                   	push   %ebx
  80bd2f:	83 ec 04             	sub    $0x4,%esp
  80bd32:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bd35:	8b 13                	mov    (%ebx),%edx
  80bd37:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bd3a:	85 c9                	test   %ecx,%ecx
  80bd3c:	74 16                	je     80bd54 <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bd3e:	8b 02                	mov    (%edx),%eax
  80bd40:	25 f0 00 00 00       	and    $0xf0,%eax
  80bd45:	83 f8 20             	cmp    $0x20,%eax
  80bd48:	74 53                	je     80bd9d <do_delconn+0x72>
  80bd4a:	83 f8 40             	cmp    $0x40,%eax
  80bd4d:	74 40                	je     80bd8f <do_delconn+0x64>
  80bd4f:	83 f8 10             	cmp    $0x10,%eax
  80bd52:	74 62                	je     80bdb6 <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bd54:	8b 13                	mov    (%ebx),%edx
  80bd56:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd59:	85 c0                	test   %eax,%eax
  80bd5b:	74 23                	je     80bd80 <do_delconn+0x55>
  80bd5d:	83 ec 04             	sub    $0x4,%esp
  80bd60:	6a 00                	push   $0x0
  80bd62:	6a 00                	push   $0x0
  80bd64:	52                   	push   %edx
  80bd65:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bd67:	8b 13                	mov    (%ebx),%edx
  80bd69:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bd6c:	83 c4 10             	add    $0x10,%esp
  80bd6f:	85 c0                	test   %eax,%eax
  80bd71:	74 0d                	je     80bd80 <do_delconn+0x55>
  80bd73:	83 ec 04             	sub    $0x4,%esp
  80bd76:	6a 00                	push   $0x0
  80bd78:	6a 02                	push   $0x2
  80bd7a:	52                   	push   %edx
  80bd7b:	ff d0                	call   *%eax
  80bd7d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bd80:	8b 03                	mov    (%ebx),%eax
  80bd82:	8b 40 10             	mov    0x10(%eax),%eax
  80bd85:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd88:	75 3c                	jne    80bdc6 <do_delconn+0x9b>
}
  80bd8a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd8d:	c9                   	leave  
  80bd8e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80bd8f:	83 ec 0c             	sub    $0xc,%esp
  80bd92:	51                   	push   %ecx
  80bd93:	e8 e5 21 00 00       	call   80df7d <raw_remove>
      break;
  80bd98:	83 c4 10             	add    $0x10,%esp
  80bd9b:	eb b7                	jmp    80bd54 <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80bd9d:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bda4:	83 ec 0c             	sub    $0xc,%esp
  80bda7:	8b 03                	mov    (%ebx),%eax
  80bda9:	ff 70 08             	pushl  0x8(%eax)
  80bdac:	e8 bf d1 ff ff       	call   808f70 <udp_remove>
      break;
  80bdb1:	83 c4 10             	add    $0x10,%esp
  80bdb4:	eb 9e                	jmp    80bd54 <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80bdb6:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bdbd:	8b 03                	mov    (%ebx),%eax
  80bdbf:	e8 82 f9 ff ff       	call   80b746 <do_close_internal>
      return;
  80bdc4:	eb c4                	jmp    80bd8a <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80bdc6:	83 ec 0c             	sub    $0xc,%esp
  80bdc9:	50                   	push   %eax
  80bdca:	e8 84 e2 ff ff       	call   80a053 <sys_sem_signal>
  80bdcf:	83 c4 10             	add    $0x10,%esp
  80bdd2:	eb b6                	jmp    80bd8a <do_delconn+0x5f>

0080bdd4 <do_bind>:
{
  80bdd4:	55                   	push   %ebp
  80bdd5:	89 e5                	mov    %esp,%ebp
  80bdd7:	56                   	push   %esi
  80bdd8:	53                   	push   %ebx
  80bdd9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bddc:	8b 33                	mov    (%ebx),%esi
  80bdde:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bde2:	7c 1d                	jl     80be01 <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80bde4:	8b 56 08             	mov    0x8(%esi),%edx
  80bde7:	85 d2                	test   %edx,%edx
  80bde9:	74 73                	je     80be5e <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bdeb:	8b 06                	mov    (%esi),%eax
  80bded:	25 f0 00 00 00       	and    $0xf0,%eax
  80bdf2:	83 f8 20             	cmp    $0x20,%eax
  80bdf5:	74 35                	je     80be2c <do_bind+0x58>
  80bdf7:	83 f8 40             	cmp    $0x40,%eax
  80bdfa:	74 1c                	je     80be18 <do_bind+0x44>
  80bdfc:	83 f8 10             	cmp    $0x10,%eax
  80bdff:	74 44                	je     80be45 <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80be01:	83 ec 0c             	sub    $0xc,%esp
  80be04:	8b 03                	mov    (%ebx),%eax
  80be06:	ff 70 10             	pushl  0x10(%eax)
  80be09:	e8 45 e2 ff ff       	call   80a053 <sys_sem_signal>
}
  80be0e:	83 c4 10             	add    $0x10,%esp
  80be11:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be14:	5b                   	pop    %ebx
  80be15:	5e                   	pop    %esi
  80be16:	5d                   	pop    %ebp
  80be17:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80be18:	83 ec 08             	sub    $0x8,%esp
  80be1b:	ff 73 04             	pushl  0x4(%ebx)
  80be1e:	52                   	push   %edx
  80be1f:	e8 e6 1f 00 00       	call   80de0a <raw_bind>
  80be24:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be27:	83 c4 10             	add    $0x10,%esp
  80be2a:	eb d5                	jmp    80be01 <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be2c:	83 ec 04             	sub    $0x4,%esp
  80be2f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be33:	50                   	push   %eax
  80be34:	ff 73 04             	pushl  0x4(%ebx)
  80be37:	52                   	push   %edx
  80be38:	e8 e3 cd ff ff       	call   808c20 <udp_bind>
  80be3d:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be40:	83 c4 10             	add    $0x10,%esp
  80be43:	eb bc                	jmp    80be01 <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80be45:	83 ec 04             	sub    $0x4,%esp
  80be48:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80be4c:	50                   	push   %eax
  80be4d:	ff 73 04             	pushl  0x4(%ebx)
  80be50:	52                   	push   %edx
  80be51:	e8 3d 95 ff ff       	call   805393 <tcp_bind>
  80be56:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80be59:	83 c4 10             	add    $0x10,%esp
  80be5c:	eb a3                	jmp    80be01 <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80be5e:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80be62:	eb 9d                	jmp    80be01 <do_bind+0x2d>

0080be64 <do_connect>:
{
  80be64:	55                   	push   %ebp
  80be65:	89 e5                	mov    %esp,%ebp
  80be67:	56                   	push   %esi
  80be68:	53                   	push   %ebx
  80be69:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80be6c:	8b 33                	mov    (%ebx),%esi
  80be6e:	8b 56 08             	mov    0x8(%esi),%edx
  80be71:	85 d2                	test   %edx,%edx
  80be73:	74 1d                	je     80be92 <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80be75:	8b 06                	mov    (%esi),%eax
  80be77:	25 f0 00 00 00       	and    $0xf0,%eax
  80be7c:	83 f8 20             	cmp    $0x20,%eax
  80be7f:	74 42                	je     80bec3 <do_connect+0x5f>
  80be81:	83 f8 40             	cmp    $0x40,%eax
  80be84:	74 1c                	je     80bea2 <do_connect+0x3e>
  80be86:	83 f8 10             	cmp    $0x10,%eax
  80be89:	74 5e                	je     80bee9 <do_connect+0x85>
}
  80be8b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be8e:	5b                   	pop    %ebx
  80be8f:	5e                   	pop    %esi
  80be90:	5d                   	pop    %ebp
  80be91:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80be92:	83 ec 0c             	sub    $0xc,%esp
  80be95:	ff 76 10             	pushl  0x10(%esi)
  80be98:	e8 b6 e1 ff ff       	call   80a053 <sys_sem_signal>
    return;
  80be9d:	83 c4 10             	add    $0x10,%esp
  80bea0:	eb e9                	jmp    80be8b <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bea2:	83 ec 08             	sub    $0x8,%esp
  80bea5:	ff 73 04             	pushl  0x4(%ebx)
  80bea8:	52                   	push   %edx
  80bea9:	e8 79 1f 00 00       	call   80de27 <raw_connect>
  80beae:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80beb1:	83 c4 04             	add    $0x4,%esp
  80beb4:	8b 03                	mov    (%ebx),%eax
  80beb6:	ff 70 10             	pushl  0x10(%eax)
  80beb9:	e8 95 e1 ff ff       	call   80a053 <sys_sem_signal>
    break;
  80bebe:	83 c4 10             	add    $0x10,%esp
  80bec1:	eb c8                	jmp    80be8b <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bec3:	83 ec 04             	sub    $0x4,%esp
  80bec6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80beca:	50                   	push   %eax
  80becb:	ff 73 04             	pushl  0x4(%ebx)
  80bece:	52                   	push   %edx
  80becf:	e8 fc cf ff ff       	call   808ed0 <udp_connect>
  80bed4:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bed7:	83 c4 04             	add    $0x4,%esp
  80beda:	8b 03                	mov    (%ebx),%eax
  80bedc:	ff 70 10             	pushl  0x10(%eax)
  80bedf:	e8 6f e1 ff ff       	call   80a053 <sys_sem_signal>
    break;
  80bee4:	83 c4 10             	add    $0x10,%esp
  80bee7:	eb a2                	jmp    80be8b <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80bee9:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bef0:	8b 03                	mov    (%ebx),%eax
  80bef2:	e8 77 f5 ff ff       	call   80b46e <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bef7:	8b 33                	mov    (%ebx),%esi
  80bef9:	68 c1 b4 80 00       	push   $0x80b4c1
  80befe:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bf02:	50                   	push   %eax
  80bf03:	ff 73 04             	pushl  0x4(%ebx)
  80bf06:	ff 76 08             	pushl  0x8(%esi)
  80bf09:	e8 ba a3 ff ff       	call   8062c8 <tcp_connect>
  80bf0e:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80bf11:	83 c4 10             	add    $0x10,%esp
  80bf14:	e9 72 ff ff ff       	jmp    80be8b <do_connect+0x27>

0080bf19 <do_disconnect>:
{
  80bf19:	55                   	push   %ebp
  80bf1a:	89 e5                	mov    %esp,%ebp
  80bf1c:	53                   	push   %ebx
  80bf1d:	83 ec 04             	sub    $0x4,%esp
  80bf20:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bf23:	8b 13                	mov    (%ebx),%edx
  80bf25:	8b 02                	mov    (%edx),%eax
  80bf27:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf2c:	83 f8 20             	cmp    $0x20,%eax
  80bf2f:	74 15                	je     80bf46 <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80bf31:	83 ec 0c             	sub    $0xc,%esp
  80bf34:	8b 03                	mov    (%ebx),%eax
  80bf36:	ff 70 10             	pushl  0x10(%eax)
  80bf39:	e8 15 e1 ff ff       	call   80a053 <sys_sem_signal>
}
  80bf3e:	83 c4 10             	add    $0x10,%esp
  80bf41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf44:	c9                   	leave  
  80bf45:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80bf46:	83 ec 0c             	sub    $0xc,%esp
  80bf49:	ff 72 08             	pushl  0x8(%edx)
  80bf4c:	e8 f0 cf ff ff       	call   808f41 <udp_disconnect>
  80bf51:	83 c4 10             	add    $0x10,%esp
  80bf54:	eb db                	jmp    80bf31 <do_disconnect+0x18>

0080bf56 <do_listen>:
{
  80bf56:	55                   	push   %ebp
  80bf57:	89 e5                	mov    %esp,%ebp
  80bf59:	57                   	push   %edi
  80bf5a:	56                   	push   %esi
  80bf5b:	53                   	push   %ebx
  80bf5c:	83 ec 0c             	sub    $0xc,%esp
  80bf5f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bf62:	8b 03                	mov    (%ebx),%eax
  80bf64:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80bf68:	7c 0c                	jl     80bf76 <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80bf6a:	8b 50 08             	mov    0x8(%eax),%edx
  80bf6d:	85 d2                	test   %edx,%edx
  80bf6f:	74 05                	je     80bf76 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80bf71:	83 38 10             	cmpl   $0x10,(%eax)
  80bf74:	74 18                	je     80bf8e <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80bf76:	83 ec 0c             	sub    $0xc,%esp
  80bf79:	8b 03                	mov    (%ebx),%eax
  80bf7b:	ff 70 10             	pushl  0x10(%eax)
  80bf7e:	e8 d0 e0 ff ff       	call   80a053 <sys_sem_signal>
}
  80bf83:	83 c4 10             	add    $0x10,%esp
  80bf86:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bf89:	5b                   	pop    %ebx
  80bf8a:	5e                   	pop    %esi
  80bf8b:	5f                   	pop    %edi
  80bf8c:	5d                   	pop    %ebp
  80bf8d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80bf8e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80bf92:	74 06                	je     80bf9a <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80bf94:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80bf98:	eb dc                	jmp    80bf76 <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80bf9a:	83 ec 08             	sub    $0x8,%esp
  80bf9d:	68 ff 00 00 00       	push   $0xff
  80bfa2:	52                   	push   %edx
  80bfa3:	e8 36 95 ff ff       	call   8054de <tcp_listen_with_backlog>
  80bfa8:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80bfaa:	83 c4 10             	add    $0x10,%esp
  80bfad:	85 c0                	test   %eax,%eax
  80bfaf:	74 4e                	je     80bfff <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80bfb1:	8b 03                	mov    (%ebx),%eax
  80bfb3:	8b 40 14             	mov    0x14(%eax),%eax
  80bfb6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bfb9:	75 4f                	jne    80c00a <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80bfbb:	8b 3b                	mov    (%ebx),%edi
  80bfbd:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80bfc1:	74 5e                	je     80c021 <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80bfc3:	8b 03                	mov    (%ebx),%eax
  80bfc5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80bfc9:	75 ab                	jne    80bf76 <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80bfcb:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80bfd2:	8b 03                	mov    (%ebx),%eax
  80bfd4:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80bfd7:	8b 03                	mov    (%ebx),%eax
  80bfd9:	83 ec 08             	sub    $0x8,%esp
  80bfdc:	50                   	push   %eax
  80bfdd:	ff 70 08             	pushl  0x8(%eax)
  80bfe0:	e8 cb 97 ff ff       	call   8057b0 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80bfe5:	83 c4 08             	add    $0x8,%esp
  80bfe8:	68 87 bc 80 00       	push   $0x80bc87
  80bfed:	8b 03                	mov    (%ebx),%eax
  80bfef:	ff 70 08             	pushl  0x8(%eax)
  80bff2:	e8 fa 97 ff ff       	call   8057f1 <tcp_accept>
  80bff7:	83 c4 10             	add    $0x10,%esp
  80bffa:	e9 77 ff ff ff       	jmp    80bf76 <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80bfff:	8b 03                	mov    (%ebx),%eax
  80c001:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c005:	e9 6c ff ff ff       	jmp    80bf76 <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c00a:	83 ec 0c             	sub    $0xc,%esp
  80c00d:	50                   	push   %eax
  80c00e:	e8 8d de ff ff       	call   809ea0 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c013:	8b 03                	mov    (%ebx),%eax
  80c015:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c01c:	83 c4 10             	add    $0x10,%esp
  80c01f:	eb 9a                	jmp    80bfbb <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c021:	83 ec 0c             	sub    $0xc,%esp
  80c024:	6a 00                	push   $0x0
  80c026:	e8 14 df ff ff       	call   809f3f <sys_mbox_new>
  80c02b:	89 47 18             	mov    %eax,0x18(%edi)
  80c02e:	83 c4 10             	add    $0x10,%esp
  80c031:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c034:	75 8d                	jne    80bfc3 <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c036:	8b 03                	mov    (%ebx),%eax
  80c038:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c03c:	eb 85                	jmp    80bfc3 <do_listen+0x6d>

0080c03e <do_send>:
{
  80c03e:	55                   	push   %ebp
  80c03f:	89 e5                	mov    %esp,%ebp
  80c041:	57                   	push   %edi
  80c042:	56                   	push   %esi
  80c043:	53                   	push   %ebx
  80c044:	83 ec 0c             	sub    $0xc,%esp
  80c047:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c04a:	8b 33                	mov    (%ebx),%esi
  80c04c:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c050:	7c 34                	jl     80c086 <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c052:	8b 56 08             	mov    0x8(%esi),%edx
  80c055:	85 d2                	test   %edx,%edx
  80c057:	74 2d                	je     80c086 <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c059:	8b 06                	mov    (%esi),%eax
  80c05b:	25 f0 00 00 00       	and    $0xf0,%eax
  80c060:	83 f8 20             	cmp    $0x20,%eax
  80c063:	74 4c                	je     80c0b1 <do_send+0x73>
  80c065:	83 f8 40             	cmp    $0x40,%eax
  80c068:	75 1c                	jne    80c086 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c06a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c06d:	8b 48 08             	mov    0x8(%eax),%ecx
  80c070:	85 c9                	test   %ecx,%ecx
  80c072:	74 2a                	je     80c09e <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c074:	83 ec 04             	sub    $0x4,%esp
  80c077:	51                   	push   %ecx
  80c078:	ff 30                	pushl  (%eax)
  80c07a:	52                   	push   %edx
  80c07b:	e8 d9 1d 00 00       	call   80de59 <raw_sendto>
  80c080:	88 46 0c             	mov    %al,0xc(%esi)
  80c083:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c086:	83 ec 0c             	sub    $0xc,%esp
  80c089:	8b 03                	mov    (%ebx),%eax
  80c08b:	ff 70 10             	pushl  0x10(%eax)
  80c08e:	e8 c0 df ff ff       	call   80a053 <sys_sem_signal>
}
  80c093:	83 c4 10             	add    $0x10,%esp
  80c096:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c099:	5b                   	pop    %ebx
  80c09a:	5e                   	pop    %esi
  80c09b:	5f                   	pop    %edi
  80c09c:	5d                   	pop    %ebp
  80c09d:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c09e:	83 ec 08             	sub    $0x8,%esp
  80c0a1:	ff 30                	pushl  (%eax)
  80c0a3:	52                   	push   %edx
  80c0a4:	e8 bc 1e 00 00       	call   80df65 <raw_send>
  80c0a9:	88 46 0c             	mov    %al,0xc(%esi)
  80c0ac:	83 c4 10             	add    $0x10,%esp
  80c0af:	eb d5                	jmp    80c086 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c0b1:	8b 43 04             	mov    0x4(%ebx),%eax
  80c0b4:	8b 48 08             	mov    0x8(%eax),%ecx
  80c0b7:	85 c9                	test   %ecx,%ecx
  80c0b9:	74 16                	je     80c0d1 <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c0bb:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c0bf:	57                   	push   %edi
  80c0c0:	51                   	push   %ecx
  80c0c1:	ff 30                	pushl  (%eax)
  80c0c3:	52                   	push   %edx
  80c0c4:	e8 aa cd ff ff       	call   808e73 <udp_sendto>
  80c0c9:	88 46 0c             	mov    %al,0xc(%esi)
  80c0cc:	83 c4 10             	add    $0x10,%esp
  80c0cf:	eb b5                	jmp    80c086 <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c0d1:	83 ec 08             	sub    $0x8,%esp
  80c0d4:	ff 30                	pushl  (%eax)
  80c0d6:	52                   	push   %edx
  80c0d7:	e8 d7 cd ff ff       	call   808eb3 <udp_send>
  80c0dc:	88 46 0c             	mov    %al,0xc(%esi)
  80c0df:	83 c4 10             	add    $0x10,%esp
  80c0e2:	eb a2                	jmp    80c086 <do_send+0x48>

0080c0e4 <do_recv>:
{
  80c0e4:	55                   	push   %ebp
  80c0e5:	89 e5                	mov    %esp,%ebp
  80c0e7:	53                   	push   %ebx
  80c0e8:	83 ec 04             	sub    $0x4,%esp
  80c0eb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0ee:	8b 03                	mov    (%ebx),%eax
  80c0f0:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c0f4:	7c 0c                	jl     80c102 <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c0f6:	8b 50 08             	mov    0x8(%eax),%edx
  80c0f9:	85 d2                	test   %edx,%edx
  80c0fb:	74 05                	je     80c102 <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c0fd:	83 38 10             	cmpl   $0x10,(%eax)
  80c100:	74 15                	je     80c117 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c102:	83 ec 0c             	sub    $0xc,%esp
  80c105:	8b 03                	mov    (%ebx),%eax
  80c107:	ff 70 10             	pushl  0x10(%eax)
  80c10a:	e8 44 df ff ff       	call   80a053 <sys_sem_signal>
}
  80c10f:	83 c4 10             	add    $0x10,%esp
  80c112:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c115:	c9                   	leave  
  80c116:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c117:	83 ec 08             	sub    $0x8,%esp
  80c11a:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c11e:	50                   	push   %eax
  80c11f:	52                   	push   %edx
  80c120:	e8 d1 94 ff ff       	call   8055f6 <tcp_recved>
  80c125:	83 c4 10             	add    $0x10,%esp
  80c128:	eb d8                	jmp    80c102 <do_recv+0x1e>

0080c12a <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c12a:	55                   	push   %ebp
  80c12b:	89 e5                	mov    %esp,%ebp
  80c12d:	83 ec 08             	sub    $0x8,%esp
  80c130:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c133:	8b 02                	mov    (%edx),%eax
  80c135:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c139:	7c 0f                	jl     80c14a <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c13b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c13f:	74 05                	je     80c146 <do_write+0x1c>
  80c141:	83 38 10             	cmpl   $0x10,(%eax)
  80c144:	74 16                	je     80c15c <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c146:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c14a:	83 ec 0c             	sub    $0xc,%esp
  80c14d:	8b 02                	mov    (%edx),%eax
  80c14f:	ff 70 10             	pushl  0x10(%eax)
  80c152:	e8 fc de ff ff       	call   80a053 <sys_sem_signal>
  80c157:	83 c4 10             	add    $0x10,%esp
}
  80c15a:	c9                   	leave  
  80c15b:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c15c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c163:	8b 02                	mov    (%edx),%eax
  80c165:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c168:	8b 02                	mov    (%edx),%eax
  80c16a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c171:	8b 02                	mov    (%edx),%eax
  80c173:	e8 67 f4 ff ff       	call   80b5df <do_writemore>
      return;
  80c178:	eb e0                	jmp    80c15a <do_write+0x30>

0080c17a <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c17a:	55                   	push   %ebp
  80c17b:	89 e5                	mov    %esp,%ebp
  80c17d:	83 ec 08             	sub    $0x8,%esp
  80c180:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c183:	8b 08                	mov    (%eax),%ecx
  80c185:	8b 51 08             	mov    0x8(%ecx),%edx
  80c188:	85 d2                	test   %edx,%edx
  80c18a:	0f 84 a8 00 00 00    	je     80c238 <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c190:	8b 48 04             	mov    0x4(%eax),%ecx
  80c193:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c197:	74 2f                	je     80c1c8 <do_getaddr+0x4e>
  80c199:	8b 12                	mov    (%edx),%edx
  80c19b:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c19d:	8b 08                	mov    (%eax),%ecx
  80c19f:	8b 11                	mov    (%ecx),%edx
  80c1a1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c1a7:	83 fa 20             	cmp    $0x20,%edx
  80c1aa:	74 3e                	je     80c1ea <do_getaddr+0x70>
  80c1ac:	83 fa 40             	cmp    $0x40,%edx
  80c1af:	74 1e                	je     80c1cf <do_getaddr+0x55>
  80c1b1:	83 fa 10             	cmp    $0x10,%edx
  80c1b4:	74 64                	je     80c21a <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c1b6:	83 ec 0c             	sub    $0xc,%esp
  80c1b9:	8b 00                	mov    (%eax),%eax
  80c1bb:	ff 70 10             	pushl  0x10(%eax)
  80c1be:	e8 90 de ff ff       	call   80a053 <sys_sem_signal>
}
  80c1c3:	83 c4 10             	add    $0x10,%esp
  80c1c6:	c9                   	leave  
  80c1c7:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c1c8:	8b 52 04             	mov    0x4(%edx),%edx
  80c1cb:	89 11                	mov    %edx,(%ecx)
  80c1cd:	eb ce                	jmp    80c19d <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c1cf:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1d3:	74 0f                	je     80c1e4 <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c1d5:	8b 50 08             	mov    0x8(%eax),%edx
  80c1d8:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1db:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c1df:	66 89 0a             	mov    %cx,(%edx)
  80c1e2:	eb d2                	jmp    80c1b6 <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c1e4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c1e8:	eb cc                	jmp    80c1b6 <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c1ea:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1ee:	74 0f                	je     80c1ff <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c1f0:	8b 50 08             	mov    0x8(%eax),%edx
  80c1f3:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c1f6:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c1fa:	66 89 0a             	mov    %cx,(%edx)
  80c1fd:	eb b7                	jmp    80c1b6 <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c1ff:	8b 51 08             	mov    0x8(%ecx),%edx
  80c202:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c206:	75 06                	jne    80c20e <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c208:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c20c:	eb a8                	jmp    80c1b6 <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c20e:	8b 48 08             	mov    0x8(%eax),%ecx
  80c211:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c215:	66 89 11             	mov    %dx,(%ecx)
  80c218:	eb 9c                	jmp    80c1b6 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c21a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c21e:	74 0f                	je     80c22f <do_getaddr+0xb5>
  80c220:	8b 51 08             	mov    0x8(%ecx),%edx
  80c223:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c227:	8b 50 08             	mov    0x8(%eax),%edx
  80c22a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c22d:	eb 87                	jmp    80c1b6 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c22f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c232:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c236:	eb ef                	jmp    80c227 <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c238:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c23c:	e9 75 ff ff ff       	jmp    80c1b6 <do_getaddr+0x3c>

0080c241 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c241:	55                   	push   %ebp
  80c242:	89 e5                	mov    %esp,%ebp
  80c244:	83 ec 08             	sub    $0x8,%esp
  80c247:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c24a:	8b 02                	mov    (%edx),%eax
  80c24c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c250:	74 05                	je     80c257 <do_close+0x16>
  80c252:	83 38 10             	cmpl   $0x10,(%eax)
  80c255:	74 16                	je     80c26d <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c257:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c25b:	83 ec 0c             	sub    $0xc,%esp
  80c25e:	8b 02                	mov    (%edx),%eax
  80c260:	ff 70 10             	pushl  0x10(%eax)
  80c263:	e8 eb dd ff ff       	call   80a053 <sys_sem_signal>
  80c268:	83 c4 10             	add    $0x10,%esp
  }
}
  80c26b:	c9                   	leave  
  80c26c:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c26d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c274:	8b 02                	mov    (%edx),%eax
  80c276:	e8 cb f4 ff ff       	call   80b746 <do_close_internal>
  80c27b:	eb ee                	jmp    80c26b <do_close+0x2a>

0080c27d <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c27d:	55                   	push   %ebp
  80c27e:	89 e5                	mov    %esp,%ebp
  80c280:	57                   	push   %edi
  80c281:	56                   	push   %esi
  80c282:	53                   	push   %ebx
  80c283:	83 ec 18             	sub    $0x18,%esp
  80c286:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c288:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c28e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c292:	50                   	push   %eax
  80c293:	e8 32 b4 ff ff       	call   8076ca <ntohs>
  80c298:	83 c4 10             	add    $0x10,%esp
  80c29b:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c29f:	0f 86 84 00 00 00    	jbe    80c329 <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c2a5:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c2a8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c2ad:	eb 10                	jmp    80c2bf <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c2af:	83 c3 01             	add    $0x1,%ebx
  80c2b2:	eb 0b                	jmp    80c2bf <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c2b4:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c2b9:	84 c0                	test   %al,%al
  80c2bb:	74 6c                	je     80c329 <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c2bd:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c2bf:	83 ec 0c             	sub    $0xc,%esp
  80c2c2:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c2c7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c2cb:	50                   	push   %eax
  80c2cc:	e8 f9 b3 ff ff       	call   8076ca <ntohs>
  80c2d1:	0f b6 d3             	movzbl %bl,%edx
  80c2d4:	66 c1 e8 0c          	shr    $0xc,%ax
  80c2d8:	0f b7 c0             	movzwl %ax,%eax
  80c2db:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c2e2:	83 c4 10             	add    $0x10,%esp
  80c2e5:	39 c2                	cmp    %eax,%edx
  80c2e7:	7d 40                	jge    80c329 <tcp_parseopt+0xac>
      opt = opts[c];
  80c2e9:	0f b6 d3             	movzbl %bl,%edx
  80c2ec:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c2f0:	84 c0                	test   %al,%al
  80c2f2:	74 35                	je     80c329 <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c2f4:	3c 01                	cmp    $0x1,%al
  80c2f6:	74 b7                	je     80c2af <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c2f8:	3c 02                	cmp    $0x2,%al
  80c2fa:	75 b8                	jne    80c2b4 <tcp_parseopt+0x37>
  80c2fc:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c301:	75 b1                	jne    80c2b4 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c303:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c308:	c1 e1 08             	shl    $0x8,%ecx
  80c30b:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c310:	89 d0                	mov    %edx,%eax
  80c312:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c314:	83 e8 01             	sub    $0x1,%eax
  80c317:	09 d1                	or     %edx,%ecx
  80c319:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c31d:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c322:	0f 42 c1             	cmovb  %ecx,%eax
  80c325:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c329:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c32c:	5b                   	pop    %ebx
  80c32d:	5e                   	pop    %esi
  80c32e:	5f                   	pop    %edi
  80c32f:	5d                   	pop    %ebp
  80c330:	c3                   	ret    

0080c331 <tcp_receive>:
{
  80c331:	55                   	push   %ebp
  80c332:	89 e5                	mov    %esp,%ebp
  80c334:	57                   	push   %edi
  80c335:	56                   	push   %esi
  80c336:	53                   	push   %ebx
  80c337:	83 ec 1c             	sub    $0x1c,%esp
  80c33a:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c33c:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c343:	0f 84 22 04 00 00    	je     80c76b <tcp_receive+0x43a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c349:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c34d:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c350:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c355:	39 c2                	cmp    %eax,%edx
  80c357:	78 53                	js     80c3ac <tcp_receive+0x7b>
  80c359:	39 c2                	cmp    %eax,%edx
  80c35b:	74 36                	je     80c393 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c35d:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c363:	39 77 64             	cmp    %esi,0x64(%edi)
  80c366:	74 38                	je     80c3a0 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c368:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c36b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c370:	39 c3                	cmp    %eax,%ebx
  80c372:	74 68                	je     80c3dc <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c374:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c377:	39 da                	cmp    %ebx,%edx
  80c379:	78 0d                	js     80c388 <tcp_receive+0x57>
  80c37b:	89 c2                	mov    %eax,%edx
  80c37d:	2b 57 58             	sub    0x58(%edi),%edx
  80c380:	85 d2                	test   %edx,%edx
  80c382:	0f 8e fa 00 00 00    	jle    80c482 <tcp_receive+0x151>
      pcb->acked = 0;
  80c388:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c38e:	e9 c2 02 00 00       	jmp    80c655 <tcp_receive+0x324>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c393:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c399:	39 77 64             	cmp    %esi,0x64(%edi)
  80c39c:	79 bf                	jns    80c35d <tcp_receive+0x2c>
  80c39e:	eb 0c                	jmp    80c3ac <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c3a0:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c3a6:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c3aa:	73 bc                	jae    80c368 <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c3ac:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c3b2:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c3b6:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c3ba:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c3bd:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c3c2:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c3c5:	66 85 db             	test   %bx,%bx
  80c3c8:	74 9e                	je     80c368 <tcp_receive+0x37>
  80c3ca:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c3d1:	74 95                	je     80c368 <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c3d3:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c3da:	eb 8c                	jmp    80c368 <tcp_receive+0x37>
      pcb->acked = 0;
  80c3dc:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3e2:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c3e6:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c3e9:	0f b7 c9             	movzwl %cx,%ecx
  80c3ec:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c3ee:	39 d0                	cmp    %edx,%eax
  80c3f0:	0f 85 5f 02 00 00    	jne    80c655 <tcp_receive+0x324>
        ++pcb->dupacks;
  80c3f6:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c3fa:	83 c0 01             	add    $0x1,%eax
  80c3fd:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c400:	3c 02                	cmp    $0x2,%al
  80c402:	0f 86 4d 02 00 00    	jbe    80c655 <tcp_receive+0x324>
  80c408:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c40c:	0f 84 43 02 00 00    	je     80c655 <tcp_receive+0x324>
          if (!(pcb->flags & TF_INFR)) {
  80c412:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c416:	74 1c                	je     80c434 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c418:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c41c:	89 d0                	mov    %edx,%eax
  80c41e:	66 03 47 34          	add    0x34(%edi),%ax
  80c422:	66 39 c2             	cmp    %ax,%dx
  80c425:	0f 83 2a 02 00 00    	jae    80c655 <tcp_receive+0x324>
              pcb->cwnd += pcb->mss;
  80c42b:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c42f:	e9 21 02 00 00       	jmp    80c655 <tcp_receive+0x324>
            tcp_rexmit(pcb);
  80c434:	83 ec 0c             	sub    $0xc,%esp
  80c437:	57                   	push   %edi
  80c438:	e8 03 c2 ff ff       	call   808640 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c43d:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c441:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c445:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c448:	89 c2                	mov    %eax,%edx
  80c44a:	66 d1 ea             	shr    %dx
  80c44d:	89 d9                	mov    %ebx,%ecx
  80c44f:	66 d1 e9             	shr    %cx
  80c452:	66 39 c3             	cmp    %ax,%bx
  80c455:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c458:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c45c:	0f b7 f1             	movzwl %cx,%esi
  80c45f:	0f b7 d8             	movzwl %ax,%ebx
  80c462:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c464:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c467:	39 de                	cmp    %ebx,%esi
  80c469:	0f 4d d1             	cmovge %ecx,%edx
  80c46c:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c470:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c473:	01 d0                	add    %edx,%eax
  80c475:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c479:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c47d:	e9 d3 01 00 00       	jmp    80c655 <tcp_receive+0x324>
      if (pcb->flags & TF_INFR) {
  80c482:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c486:	f6 c2 04             	test   $0x4,%dl
  80c489:	74 0e                	je     80c499 <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c48b:	83 e2 fb             	and    $0xfffffffb,%edx
  80c48e:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c491:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c495:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c499:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c49d:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c4a1:	66 c1 fa 03          	sar    $0x3,%dx
  80c4a5:	66 03 57 42          	add    0x42(%edi),%dx
  80c4a9:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c4ad:	89 c2                	mov    %eax,%edx
  80c4af:	29 da                	sub    %ebx,%edx
  80c4b1:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c4b5:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c4b9:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c4bd:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c4c0:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c4c4:	76 1d                	jbe    80c4e3 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c4c6:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c4ca:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c4ce:	0f 83 d7 00 00 00    	jae    80c5ab <tcp_receive+0x27a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c4d4:	89 c8                	mov    %ecx,%eax
  80c4d6:	66 03 47 34          	add    0x34(%edi),%ax
  80c4da:	66 39 c1             	cmp    %ax,%cx
  80c4dd:	73 04                	jae    80c4e3 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c4df:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c4e3:	8b 47 78             	mov    0x78(%edi),%eax
  80c4e6:	85 c0                	test   %eax,%eax
  80c4e8:	0f 84 18 01 00 00    	je     80c606 <tcp_receive+0x2d5>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c4ee:	83 ec 0c             	sub    $0xc,%esp
  80c4f1:	8b 40 10             	mov    0x10(%eax),%eax
  80c4f4:	ff 70 04             	pushl  0x4(%eax)
  80c4f7:	e8 f2 b3 ff ff       	call   8078ee <ntohl>
  80c4fc:	89 c3                	mov    %eax,%ebx
  80c4fe:	8b 47 78             	mov    0x78(%edi),%eax
  80c501:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c505:	8b 40 10             	mov    0x10(%eax),%eax
  80c508:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c50c:	89 04 24             	mov    %eax,(%esp)
  80c50f:	e8 b6 b1 ff ff       	call   8076ca <ntohs>
  80c514:	83 c4 10             	add    $0x10,%esp
  80c517:	ba 01 00 00 00       	mov    $0x1,%edx
  80c51c:	a8 01                	test   $0x1,%al
  80c51e:	0f 84 bf 00 00 00    	je     80c5e3 <tcp_receive+0x2b2>
  80c524:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c52a:	01 d6                	add    %edx,%esi
  80c52c:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c52e:	85 db                	test   %ebx,%ebx
  80c530:	0f 8f d0 00 00 00    	jg     80c606 <tcp_receive+0x2d5>
        next = pcb->unacked;
  80c536:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c539:	8b 03                	mov    (%ebx),%eax
  80c53b:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c53e:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c542:	83 ec 0c             	sub    $0xc,%esp
  80c545:	ff 73 04             	pushl  0x4(%ebx)
  80c548:	e8 e0 86 ff ff       	call   804c2d <pbuf_clen>
  80c54d:	0f b6 c0             	movzbl %al,%eax
  80c550:	83 c4 10             	add    $0x10,%esp
  80c553:	66 39 c6             	cmp    %ax,%si
  80c556:	72 74                	jb     80c5cc <tcp_receive+0x29b>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c558:	83 ec 0c             	sub    $0xc,%esp
  80c55b:	ff 73 04             	pushl  0x4(%ebx)
  80c55e:	e8 ca 86 ff ff       	call   804c2d <pbuf_clen>
  80c563:	0f b6 c0             	movzbl %al,%eax
  80c566:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c56a:	89 1c 24             	mov    %ebx,(%esp)
  80c56d:	e8 8b 91 ff ff       	call   8056fd <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c572:	83 c4 10             	add    $0x10,%esp
  80c575:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c57a:	0f 84 63 ff ff ff    	je     80c4e3 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c580:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c584:	0f 85 59 ff ff ff    	jne    80c4e3 <tcp_receive+0x1b2>
  80c58a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c58e:	0f 85 4f ff ff ff    	jne    80c4e3 <tcp_receive+0x1b2>
  80c594:	83 ec 04             	sub    $0x4,%esp
  80c597:	68 30 34 81 00       	push   $0x813430
  80c59c:	68 5c 03 00 00       	push   $0x35c
  80c5a1:	68 74 35 81 00       	push   $0x813574
  80c5a6:	e8 fd 1f 00 00       	call   80e5a8 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c5ab:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c5af:	0f af c0             	imul   %eax,%eax
  80c5b2:	0f b7 d9             	movzwl %cx,%ebx
  80c5b5:	99                   	cltd   
  80c5b6:	f7 fb                	idiv   %ebx
  80c5b8:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c5ba:	66 39 c1             	cmp    %ax,%cx
  80c5bd:	0f 83 20 ff ff ff    	jae    80c4e3 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c5c3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c5c7:	e9 17 ff ff ff       	jmp    80c4e3 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c5cc:	83 ec 04             	sub    $0x4,%esp
  80c5cf:	68 08 34 81 00       	push   $0x813408
  80c5d4:	68 55 03 00 00       	push   $0x355
  80c5d9:	68 74 35 81 00       	push   $0x813574
  80c5de:	e8 c5 1f 00 00       	call   80e5a8 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c5e3:	83 ec 0c             	sub    $0xc,%esp
  80c5e6:	8b 47 78             	mov    0x78(%edi),%eax
  80c5e9:	8b 40 10             	mov    0x10(%eax),%eax
  80c5ec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5f0:	50                   	push   %eax
  80c5f1:	e8 d4 b0 ff ff       	call   8076ca <ntohs>
  80c5f6:	66 d1 e8             	shr    %ax
  80c5f9:	89 c2                	mov    %eax,%edx
  80c5fb:	83 e2 01             	and    $0x1,%edx
  80c5fe:	83 c4 10             	add    $0x10,%esp
  80c601:	e9 1e ff ff ff       	jmp    80c524 <tcp_receive+0x1f3>
      if(pcb->unacked == NULL)
  80c606:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c60a:	0f 94 c0             	sete   %al
  80c60d:	0f b6 c0             	movzbl %al,%eax
  80c610:	f7 d8                	neg    %eax
  80c612:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c616:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c61a:	eb 39                	jmp    80c655 <tcp_receive+0x324>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c61c:	83 ec 04             	sub    $0x4,%esp
  80c61f:	68 08 34 81 00       	push   $0x813408
  80c624:	68 7f 03 00 00       	push   $0x37f
  80c629:	68 74 35 81 00       	push   $0x813574
  80c62e:	e8 75 1f 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c633:	83 ec 04             	sub    $0x4,%esp
  80c636:	68 30 34 81 00       	push   $0x813430
  80c63b:	68 85 03 00 00       	push   $0x385
  80c640:	68 74 35 81 00       	push   $0x813574
  80c645:	e8 5e 1f 00 00       	call   80e5a8 <_panic>
      if (pcb->unsent != NULL) {
  80c64a:	8b 47 74             	mov    0x74(%edi),%eax
  80c64d:	85 c0                	test   %eax,%eax
  80c64f:	0f 85 c8 00 00 00    	jne    80c71d <tcp_receive+0x3ec>
    while (pcb->unsent != NULL &&
  80c655:	8b 47 74             	mov    0x74(%edi),%eax
  80c658:	85 c0                	test   %eax,%eax
  80c65a:	0f 84 f9 00 00 00    	je     80c759 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c660:	8b 1d a4 b1 b3 00    	mov    0xb3b1a4,%ebx
  80c666:	83 ec 0c             	sub    $0xc,%esp
  80c669:	8b 40 10             	mov    0x10(%eax),%eax
  80c66c:	ff 70 04             	pushl  0x4(%eax)
  80c66f:	e8 7a b2 ff ff       	call   8078ee <ntohl>
  80c674:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c677:	8b 47 74             	mov    0x74(%edi),%eax
  80c67a:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c67e:	8b 40 10             	mov    0x10(%eax),%eax
  80c681:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c685:	89 04 24             	mov    %eax,(%esp)
  80c688:	e8 3d b0 ff ff       	call   8076ca <ntohs>
  80c68d:	83 c4 10             	add    $0x10,%esp
  80c690:	ba 01 00 00 00       	mov    $0x1,%edx
  80c695:	a8 01                	test   $0x1,%al
  80c697:	0f 84 99 00 00 00    	je     80c736 <tcp_receive+0x405>
  80c69d:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c6a0:	01 d6                	add    %edx,%esi
    while (pcb->unsent != NULL &&
  80c6a2:	39 f3                	cmp    %esi,%ebx
  80c6a4:	0f 88 af 00 00 00    	js     80c759 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c6aa:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c6af:	2b 47 58             	sub    0x58(%edi),%eax
  80c6b2:	85 c0                	test   %eax,%eax
  80c6b4:	0f 8f 9f 00 00 00    	jg     80c759 <tcp_receive+0x428>
      next = pcb->unsent;
  80c6ba:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c6bd:	8b 03                	mov    (%ebx),%eax
  80c6bf:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6c2:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c6c6:	83 ec 0c             	sub    $0xc,%esp
  80c6c9:	ff 73 04             	pushl  0x4(%ebx)
  80c6cc:	e8 5c 85 ff ff       	call   804c2d <pbuf_clen>
  80c6d1:	0f b6 c0             	movzbl %al,%eax
  80c6d4:	83 c4 10             	add    $0x10,%esp
  80c6d7:	66 39 c6             	cmp    %ax,%si
  80c6da:	0f 82 3c ff ff ff    	jb     80c61c <tcp_receive+0x2eb>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c6e0:	83 ec 0c             	sub    $0xc,%esp
  80c6e3:	ff 73 04             	pushl  0x4(%ebx)
  80c6e6:	e8 42 85 ff ff       	call   804c2d <pbuf_clen>
  80c6eb:	0f b6 c0             	movzbl %al,%eax
  80c6ee:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c6f2:	89 1c 24             	mov    %ebx,(%esp)
  80c6f5:	e8 03 90 ff ff       	call   8056fd <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c6fa:	83 c4 10             	add    $0x10,%esp
  80c6fd:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c702:	0f 84 42 ff ff ff    	je     80c64a <tcp_receive+0x319>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c708:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c70c:	0f 85 38 ff ff ff    	jne    80c64a <tcp_receive+0x319>
  80c712:	8b 47 74             	mov    0x74(%edi),%eax
  80c715:	85 c0                	test   %eax,%eax
  80c717:	0f 84 16 ff ff ff    	je     80c633 <tcp_receive+0x302>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c71d:	83 ec 0c             	sub    $0xc,%esp
  80c720:	8b 40 10             	mov    0x10(%eax),%eax
  80c723:	ff 70 04             	pushl  0x4(%eax)
  80c726:	e8 ac af ff ff       	call   8076d7 <htonl>
  80c72b:	89 47 54             	mov    %eax,0x54(%edi)
  80c72e:	83 c4 10             	add    $0x10,%esp
  80c731:	e9 1f ff ff ff       	jmp    80c655 <tcp_receive+0x324>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c736:	83 ec 0c             	sub    $0xc,%esp
  80c739:	8b 47 74             	mov    0x74(%edi),%eax
  80c73c:	8b 40 10             	mov    0x10(%eax),%eax
  80c73f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c743:	50                   	push   %eax
  80c744:	e8 81 af ff ff       	call   8076ca <ntohs>
  80c749:	66 d1 e8             	shr    %ax
  80c74c:	89 c2                	mov    %eax,%edx
  80c74e:	83 e2 01             	and    $0x1,%edx
  80c751:	83 c4 10             	add    $0x10,%esp
  80c754:	e9 44 ff ff ff       	jmp    80c69d <tcp_receive+0x36c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c759:	8b 47 38             	mov    0x38(%edi),%eax
  80c75c:	85 c0                	test   %eax,%eax
  80c75e:	74 0b                	je     80c76b <tcp_receive+0x43a>
  80c760:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c766:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c769:	78 70                	js     80c7db <tcp_receive+0x4aa>
  if (tcplen > 0) {
  80c76b:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c772:	66 85 c0             	test   %ax,%ax
  80c775:	0f 84 52 08 00 00    	je     80cfcd <tcp_receive+0xc9c>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c77b:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c77e:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c784:	89 d9                	mov    %ebx,%ecx
  80c786:	29 d1                	sub    %edx,%ecx
  80c788:	89 ce                	mov    %ecx,%esi
  80c78a:	83 ee 01             	sub    $0x1,%esi
  80c78d:	78 16                	js     80c7a5 <tcp_receive+0x474>
  80c78f:	be 01 00 00 00       	mov    $0x1,%esi
  80c794:	29 d6                	sub    %edx,%esi
  80c796:	0f b7 c0             	movzwl %ax,%eax
  80c799:	29 c6                	sub    %eax,%esi
  80c79b:	01 de                	add    %ebx,%esi
  80c79d:	85 f6                	test   %esi,%esi
  80c79f:	0f 8e 84 00 00 00    	jle    80c829 <tcp_receive+0x4f8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c7a5:	39 da                	cmp    %ebx,%edx
  80c7a7:	0f 88 bd 01 00 00    	js     80c96a <tcp_receive+0x639>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c7ad:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c7b1:	89 d1                	mov    %edx,%ecx
  80c7b3:	29 c1                	sub    %eax,%ecx
  80c7b5:	8d 41 01             	lea    0x1(%ecx),%eax
  80c7b8:	29 d8                	sub    %ebx,%eax
  80c7ba:	85 c0                	test   %eax,%eax
  80c7bc:	0f 8e bd 01 00 00    	jle    80c97f <tcp_receive+0x64e>
      tcp_ack_now(pcb);
  80c7c2:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c7c6:	83 ec 0c             	sub    $0xc,%esp
  80c7c9:	57                   	push   %edi
  80c7ca:	e8 4f b8 ff ff       	call   80801e <tcp_output>
  80c7cf:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c7d2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80c7d6:	e9 25 08 00 00       	jmp    80d000 <tcp_receive+0xccf>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7db:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80c7e1:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c7e5:	89 d3                	mov    %edx,%ebx
  80c7e7:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c7eb:	89 f1                	mov    %esi,%ecx
  80c7ed:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c7ef:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80c7f1:	01 ca                	add    %ecx,%edx
  80c7f3:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80c7f7:	29 f0                	sub    %esi,%eax
  80c7f9:	01 d8                	add    %ebx,%eax
  80c7fb:	66 85 c9             	test   %cx,%cx
  80c7fe:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80c801:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80c805:	89 cb                	mov    %ecx,%ebx
  80c807:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c80b:	29 d9                	sub    %ebx,%ecx
  80c80d:	01 c8                	add    %ecx,%eax
  80c80f:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c813:	66 c1 fa 03          	sar    $0x3,%dx
  80c817:	01 d0                	add    %edx,%eax
  80c819:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80c81d:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c824:	e9 42 ff ff ff       	jmp    80c76b <tcp_receive+0x43a>
      off = pcb->rcv_nxt - seqno;
  80c829:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c82b:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c831:	85 db                	test   %ebx,%ebx
  80c833:	0f 84 a4 00 00 00    	je     80c8dd <tcp_receive+0x5ac>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c839:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c83f:	0f 8f af 00 00 00    	jg     80c8f4 <tcp_receive+0x5c3>
      if (inseg.p->len < off) {
  80c845:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c849:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c84c:	39 ca                	cmp    %ecx,%edx
  80c84e:	0f 8d e5 00 00 00    	jge    80c939 <tcp_receive+0x608>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c854:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c858:	0f b7 d6             	movzwl %si,%edx
  80c85b:	39 ca                	cmp    %ecx,%edx
  80c85d:	0f 8c a8 00 00 00    	jl     80c90b <tcp_receive+0x5da>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c863:	29 ce                	sub    %ecx,%esi
  80c865:	89 f1                	mov    %esi,%ecx
  80c867:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80c86a:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80c86c:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c870:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c876:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c878:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c87c:	39 c2                	cmp    %eax,%edx
  80c87e:	7c ea                	jl     80c86a <tcp_receive+0x539>
        if(pbuf_header(p, (s16_t)-off)) {
  80c880:	83 ec 08             	sub    $0x8,%esp
  80c883:	f7 d8                	neg    %eax
  80c885:	98                   	cwtl   
  80c886:	50                   	push   %eax
  80c887:	53                   	push   %ebx
  80c888:	e8 89 7e ff ff       	call   804716 <pbuf_header>
  80c88d:	83 c4 10             	add    $0x10,%esp
  80c890:	84 c0                	test   %al,%al
  80c892:	0f 85 8a 00 00 00    	jne    80c922 <tcp_receive+0x5f1>
      inseg.dataptr = p->payload;
  80c898:	8b 43 04             	mov    0x4(%ebx),%eax
  80c89b:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c8a0:	8b 57 24             	mov    0x24(%edi),%edx
  80c8a3:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c8aa:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c8b1:	29 d0                	sub    %edx,%eax
  80c8b3:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c8b9:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c8bf:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c8c4:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c8c7:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c8cd:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c8d0:	39 da                	cmp    %ebx,%edx
  80c8d2:	0f 88 ea fe ff ff    	js     80c7c2 <tcp_receive+0x491>
  80c8d8:	e9 d0 fe ff ff       	jmp    80c7ad <tcp_receive+0x47c>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c8dd:	83 ec 04             	sub    $0x4,%esp
  80c8e0:	68 8b 35 81 00       	push   $0x81358b
  80c8e5:	68 e5 03 00 00       	push   $0x3e5
  80c8ea:	68 74 35 81 00       	push   $0x813574
  80c8ef:	e8 b4 1c 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c8f4:	83 ec 04             	sub    $0x4,%esp
  80c8f7:	68 9b 35 81 00       	push   $0x81359b
  80c8fc:	68 e6 03 00 00       	push   $0x3e6
  80c901:	68 74 35 81 00       	push   $0x813574
  80c906:	e8 9d 1c 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c90b:	83 ec 04             	sub    $0x4,%esp
  80c90e:	68 aa 35 81 00       	push   $0x8135aa
  80c913:	68 e8 03 00 00       	push   $0x3e8
  80c918:	68 74 35 81 00       	push   $0x813574
  80c91d:	e8 86 1c 00 00       	call   80e5a8 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c922:	83 ec 04             	sub    $0x4,%esp
  80c925:	68 ba 35 81 00       	push   $0x8135ba
  80c92a:	68 f5 03 00 00       	push   $0x3f5
  80c92f:	68 74 35 81 00       	push   $0x813574
  80c934:	e8 6f 1c 00 00       	call   80e5a8 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c939:	83 ec 08             	sub    $0x8,%esp
  80c93c:	f7 d9                	neg    %ecx
  80c93e:	0f bf c1             	movswl %cx,%eax
  80c941:	50                   	push   %eax
  80c942:	53                   	push   %ebx
  80c943:	e8 ce 7d ff ff       	call   804716 <pbuf_header>
  80c948:	83 c4 10             	add    $0x10,%esp
  80c94b:	84 c0                	test   %al,%al
  80c94d:	0f 84 45 ff ff ff    	je     80c898 <tcp_receive+0x567>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c953:	83 ec 04             	sub    $0x4,%esp
  80c956:	68 ba 35 81 00       	push   $0x8135ba
  80c95b:	68 fa 03 00 00       	push   $0x3fa
  80c960:	68 74 35 81 00       	push   $0x813574
  80c965:	e8 3e 1c 00 00       	call   80e5a8 <_panic>
        tcp_ack_now(pcb);
  80c96a:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c96e:	83 ec 0c             	sub    $0xc,%esp
  80c971:	57                   	push   %edi
  80c972:	e8 a7 b6 ff ff       	call   80801e <tcp_output>
  80c977:	83 c4 10             	add    $0x10,%esp
  80c97a:	e9 48 ff ff ff       	jmp    80c8c7 <tcp_receive+0x596>
      if (pcb->rcv_nxt == seqno) {
  80c97f:	39 da                	cmp    %ebx,%edx
  80c981:	0f 85 d2 03 00 00    	jne    80cd59 <tcp_receive+0xa28>
        if (pcb->ooseq != NULL &&
  80c987:	8b 47 7c             	mov    0x7c(%edi),%eax
  80c98a:	85 c0                	test   %eax,%eax
  80c98c:	74 1d                	je     80c9ab <tcp_receive+0x67a>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80c98e:	8b 48 10             	mov    0x10(%eax),%ecx
  80c991:	8b 59 04             	mov    0x4(%ecx),%ebx
  80c994:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80c99b:	89 de                	mov    %ebx,%esi
  80c99d:	29 ce                	sub    %ecx,%esi
  80c99f:	89 f1                	mov    %esi,%ecx
  80c9a1:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80c9a3:	85 c9                	test   %ecx,%ecx
  80c9a5:	0f 8e b0 00 00 00    	jle    80ca5b <tcp_receive+0x72a>
        tcplen = TCP_TCPLEN(&inseg);
  80c9ab:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80c9b2:	83 ec 0c             	sub    $0xc,%esp
  80c9b5:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c9ba:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c9be:	50                   	push   %eax
  80c9bf:	e8 06 ad ff ff       	call   8076ca <ntohs>
  80c9c4:	83 c4 10             	add    $0x10,%esp
  80c9c7:	ba 01 00 00 00       	mov    $0x1,%edx
  80c9cc:	a8 01                	test   $0x1,%al
  80c9ce:	0f 84 00 01 00 00    	je     80cad4 <tcp_receive+0x7a3>
  80c9d4:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80c9d7:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80c9dd:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80c9e1:	74 06                	je     80c9e9 <tcp_receive+0x6b8>
          pcb->rcv_nxt += tcplen;
  80c9e3:	0f b7 d0             	movzwl %ax,%edx
  80c9e6:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80c9e9:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80c9ed:	89 ca                	mov    %ecx,%edx
  80c9ef:	29 c2                	sub    %eax,%edx
  80c9f1:	66 39 c8             	cmp    %cx,%ax
  80c9f4:	b9 00 00 00 00       	mov    $0x0,%ecx
  80c9f9:	0f 47 d1             	cmova  %ecx,%edx
  80c9fc:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80ca00:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80ca04:	89 ca                	mov    %ecx,%edx
  80ca06:	29 c2                	sub    %eax,%edx
  80ca08:	66 39 c8             	cmp    %cx,%ax
  80ca0b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca10:	0f 46 c2             	cmovbe %edx,%eax
  80ca13:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80ca17:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80ca1c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ca21:	74 0f                	je     80ca32 <tcp_receive+0x701>
          recv_data = inseg.p;
  80ca23:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80ca28:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80ca2f:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80ca32:	83 ec 0c             	sub    $0xc,%esp
  80ca35:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ca3a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca3e:	50                   	push   %eax
  80ca3f:	e8 86 ac ff ff       	call   8076ca <ntohs>
  80ca44:	83 c4 10             	add    $0x10,%esp
  80ca47:	a8 01                	test   $0x1,%al
  80ca49:	0f 84 e4 01 00 00    	je     80cc33 <tcp_receive+0x902>
          recv_flags = TF_GOT_FIN;
  80ca4f:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80ca56:	e9 d8 01 00 00       	jmp    80cc33 <tcp_receive+0x902>
          if (pcb->ooseq->len > 0) {
  80ca5b:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80ca60:	74 23                	je     80ca85 <tcp_receive+0x754>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80ca62:	29 d3                	sub    %edx,%ebx
  80ca64:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80ca6b:	83 ec 08             	sub    $0x8,%esp
  80ca6e:	0f b7 db             	movzwl %bx,%ebx
  80ca71:	53                   	push   %ebx
  80ca72:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80ca78:	e8 9e 80 ff ff       	call   804b1b <pbuf_realloc>
  80ca7d:	83 c4 10             	add    $0x10,%esp
  80ca80:	e9 26 ff ff ff       	jmp    80c9ab <tcp_receive+0x67a>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ca85:	83 ec 0c             	sub    $0xc,%esp
  80ca88:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ca8d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca91:	50                   	push   %eax
  80ca92:	e8 33 ac ff ff       	call   8076ca <ntohs>
  80ca97:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80ca99:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ca9c:	8b 40 10             	mov    0x10(%eax),%eax
  80ca9f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80caa3:	89 04 24             	mov    %eax,(%esp)
  80caa6:	e8 1f ac ff ff       	call   8076ca <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80caab:	31 c3                	xor    %eax,%ebx
  80caad:	83 c4 10             	add    $0x10,%esp
  80cab0:	f6 c3 03             	test   $0x3,%bl
  80cab3:	0f 85 f2 fe ff ff    	jne    80c9ab <tcp_receive+0x67a>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cab9:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cabc:	8b 10                	mov    (%eax),%edx
  80cabe:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cac1:	83 ec 08             	sub    $0x8,%esp
  80cac4:	50                   	push   %eax
  80cac5:	6a 04                	push   $0x4
  80cac7:	e8 ca 79 ff ff       	call   804496 <memp_free>
  80cacc:	83 c4 10             	add    $0x10,%esp
  80cacf:	e9 d7 fe ff ff       	jmp    80c9ab <tcp_receive+0x67a>
        tcplen = TCP_TCPLEN(&inseg);
  80cad4:	83 ec 0c             	sub    $0xc,%esp
  80cad7:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cadc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cae0:	50                   	push   %eax
  80cae1:	e8 e4 ab ff ff       	call   8076ca <ntohs>
  80cae6:	66 d1 e8             	shr    %ax
  80cae9:	89 c2                	mov    %eax,%edx
  80caeb:	83 e2 01             	and    $0x1,%edx
  80caee:	83 c4 10             	add    $0x10,%esp
  80caf1:	e9 de fe ff ff       	jmp    80c9d4 <tcp_receive+0x6a3>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80caf6:	83 ec 0c             	sub    $0xc,%esp
  80caf9:	8b 43 10             	mov    0x10(%ebx),%eax
  80cafc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb00:	50                   	push   %eax
  80cb01:	e8 c4 ab ff ff       	call   8076ca <ntohs>
  80cb06:	66 d1 e8             	shr    %ax
  80cb09:	89 c2                	mov    %eax,%edx
  80cb0b:	83 e2 01             	and    $0x1,%edx
  80cb0e:	83 c4 10             	add    $0x10,%esp
  80cb11:	e9 5d 01 00 00       	jmp    80cc73 <tcp_receive+0x942>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cb16:	83 ec 0c             	sub    $0xc,%esp
  80cb19:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb1c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb20:	50                   	push   %eax
  80cb21:	e8 a4 ab ff ff       	call   8076ca <ntohs>
  80cb26:	66 d1 e8             	shr    %ax
  80cb29:	89 c2                	mov    %eax,%edx
  80cb2b:	83 e2 01             	and    $0x1,%edx
  80cb2e:	83 c4 10             	add    $0x10,%esp
  80cb31:	e9 6d 01 00 00       	jmp    80cca3 <tcp_receive+0x972>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cb36:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cb3a:	83 ec 0c             	sub    $0xc,%esp
  80cb3d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb40:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb44:	50                   	push   %eax
  80cb45:	e8 80 ab ff ff       	call   8076ca <ntohs>
  80cb4a:	83 c4 10             	add    $0x10,%esp
  80cb4d:	ba 01 00 00 00       	mov    $0x1,%edx
  80cb52:	a8 01                	test   $0x1,%al
  80cb54:	74 0b                	je     80cb61 <tcp_receive+0x830>
  80cb56:	01 d6                	add    %edx,%esi
  80cb58:	66 29 77 28          	sub    %si,0x28(%edi)
  80cb5c:	e9 53 01 00 00       	jmp    80ccb4 <tcp_receive+0x983>
  80cb61:	83 ec 0c             	sub    $0xc,%esp
  80cb64:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb67:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb6b:	50                   	push   %eax
  80cb6c:	e8 59 ab ff ff       	call   8076ca <ntohs>
  80cb71:	66 d1 e8             	shr    %ax
  80cb74:	89 c2                	mov    %eax,%edx
  80cb76:	83 e2 01             	and    $0x1,%edx
  80cb79:	83 c4 10             	add    $0x10,%esp
  80cb7c:	eb d8                	jmp    80cb56 <tcp_receive+0x825>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cb7e:	83 ec 0c             	sub    $0xc,%esp
  80cb81:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb84:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb88:	50                   	push   %eax
  80cb89:	e8 3c ab ff ff       	call   8076ca <ntohs>
  80cb8e:	66 d1 e8             	shr    %ax
  80cb91:	89 c2                	mov    %eax,%edx
  80cb93:	83 e2 01             	and    $0x1,%edx
  80cb96:	83 c4 10             	add    $0x10,%esp
  80cb99:	e9 41 01 00 00       	jmp    80ccdf <tcp_receive+0x9ae>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cb9e:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cba2:	83 ec 0c             	sub    $0xc,%esp
  80cba5:	8b 43 10             	mov    0x10(%ebx),%eax
  80cba8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbac:	50                   	push   %eax
  80cbad:	e8 18 ab ff ff       	call   8076ca <ntohs>
  80cbb2:	83 c4 10             	add    $0x10,%esp
  80cbb5:	ba 01 00 00 00       	mov    $0x1,%edx
  80cbba:	a8 01                	test   $0x1,%al
  80cbbc:	74 0b                	je     80cbc9 <tcp_receive+0x898>
  80cbbe:	01 d6                	add    %edx,%esi
  80cbc0:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cbc4:	e9 27 01 00 00       	jmp    80ccf0 <tcp_receive+0x9bf>
  80cbc9:	83 ec 0c             	sub    $0xc,%esp
  80cbcc:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbcf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbd3:	50                   	push   %eax
  80cbd4:	e8 f1 aa ff ff       	call   8076ca <ntohs>
  80cbd9:	66 d1 e8             	shr    %ax
  80cbdc:	89 c2                	mov    %eax,%edx
  80cbde:	83 e2 01             	and    $0x1,%edx
  80cbe1:	83 c4 10             	add    $0x10,%esp
  80cbe4:	eb d8                	jmp    80cbbe <tcp_receive+0x88d>
              pbuf_cat(recv_data, cseg->p);
  80cbe6:	83 ec 08             	sub    $0x8,%esp
  80cbe9:	50                   	push   %eax
  80cbea:	52                   	push   %edx
  80cbeb:	e8 66 80 ff ff       	call   804c56 <pbuf_cat>
  80cbf0:	83 c4 10             	add    $0x10,%esp
            cseg->p = NULL;
  80cbf3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cbfa:	83 ec 0c             	sub    $0xc,%esp
  80cbfd:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc00:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc04:	50                   	push   %eax
  80cc05:	e8 c0 aa ff ff       	call   8076ca <ntohs>
  80cc0a:	83 c4 10             	add    $0x10,%esp
  80cc0d:	a8 01                	test   $0x1,%al
  80cc0f:	74 11                	je     80cc22 <tcp_receive+0x8f1>
            recv_flags = TF_GOT_FIN;
  80cc11:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80cc18:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80cc1c:	0f 84 f4 00 00 00    	je     80cd16 <tcp_receive+0x9e5>
          pcb->ooseq = cseg->next;
  80cc22:	8b 03                	mov    (%ebx),%eax
  80cc24:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80cc27:	83 ec 0c             	sub    $0xc,%esp
  80cc2a:	53                   	push   %ebx
  80cc2b:	e8 cd 8a ff ff       	call   8056fd <tcp_seg_free>
  80cc30:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80cc33:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cc36:	85 db                	test   %ebx,%ebx
  80cc38:	0f 84 e4 00 00 00    	je     80cd22 <tcp_receive+0x9f1>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80cc3e:	8b 53 10             	mov    0x10(%ebx),%edx
  80cc41:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cc44:	3b 47 24             	cmp    0x24(%edi),%eax
  80cc47:	0f 85 d5 00 00 00    	jne    80cd22 <tcp_receive+0x9f1>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cc4d:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cc52:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc56:	83 ec 0c             	sub    $0xc,%esp
  80cc59:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80cc5d:	50                   	push   %eax
  80cc5e:	e8 67 aa ff ff       	call   8076ca <ntohs>
  80cc63:	83 c4 10             	add    $0x10,%esp
  80cc66:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc6b:	a8 01                	test   $0x1,%al
  80cc6d:	0f 84 83 fe ff ff    	je     80caf6 <tcp_receive+0x7c5>
  80cc73:	01 d6                	add    %edx,%esi
  80cc75:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cc78:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cc7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cc7f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc83:	83 ec 0c             	sub    $0xc,%esp
  80cc86:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc89:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc8d:	50                   	push   %eax
  80cc8e:	e8 37 aa ff ff       	call   8076ca <ntohs>
  80cc93:	83 c4 10             	add    $0x10,%esp
  80cc96:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc9b:	a8 01                	test   $0x1,%al
  80cc9d:	0f 84 73 fe ff ff    	je     80cb16 <tcp_receive+0x7e5>
  80cca3:	01 d6                	add    %edx,%esi
  80cca5:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cca8:	0f 8d 88 fe ff ff    	jge    80cb36 <tcp_receive+0x805>
            pcb->rcv_wnd = 0;
  80ccae:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80ccb4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80ccb8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ccbb:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ccbf:	83 ec 0c             	sub    $0xc,%esp
  80ccc2:	8b 43 10             	mov    0x10(%ebx),%eax
  80ccc5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccc9:	50                   	push   %eax
  80ccca:	e8 fb a9 ff ff       	call   8076ca <ntohs>
  80cccf:	83 c4 10             	add    $0x10,%esp
  80ccd2:	ba 01 00 00 00       	mov    $0x1,%edx
  80ccd7:	a8 01                	test   $0x1,%al
  80ccd9:	0f 84 9f fe ff ff    	je     80cb7e <tcp_receive+0x84d>
  80ccdf:	01 d6                	add    %edx,%esi
  80cce1:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cce4:	0f 8d b4 fe ff ff    	jge    80cb9e <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80ccea:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80ccf0:	8b 43 04             	mov    0x4(%ebx),%eax
  80ccf3:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80ccf8:	0f 84 fc fe ff ff    	je     80cbfa <tcp_receive+0x8c9>
            if (recv_data) {
  80ccfe:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cd04:	85 d2                	test   %edx,%edx
  80cd06:	0f 85 da fe ff ff    	jne    80cbe6 <tcp_receive+0x8b5>
              recv_data = cseg->p;
  80cd0c:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
  80cd11:	e9 dd fe ff ff       	jmp    80cbf3 <tcp_receive+0x8c2>
              pcb->state = CLOSE_WAIT;
  80cd16:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80cd1d:	e9 00 ff ff ff       	jmp    80cc22 <tcp_receive+0x8f1>
        tcp_ack(pcb);
  80cd22:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cd26:	89 c1                	mov    %eax,%ecx
  80cd28:	83 e1 01             	and    $0x1,%ecx
  80cd2b:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80cd2e:	75 0f                	jne    80cd3f <tcp_receive+0xa0e>
  80cd30:	83 c8 01             	or     $0x1,%eax
  80cd33:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80cd36:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80cd3a:	e9 c1 02 00 00       	jmp    80d000 <tcp_receive+0xccf>
        tcp_ack(pcb);
  80cd3f:	83 e0 fe             	and    $0xfffffffe,%eax
  80cd42:	83 c8 02             	or     $0x2,%eax
  80cd45:	88 47 20             	mov    %al,0x20(%edi)
  80cd48:	83 ec 0c             	sub    $0xc,%esp
  80cd4b:	57                   	push   %edi
  80cd4c:	e8 cd b2 ff ff       	call   80801e <tcp_output>
  80cd51:	83 c4 10             	add    $0x10,%esp
  80cd54:	e9 a7 02 00 00       	jmp    80d000 <tcp_receive+0xccf>
        tcp_ack_now(pcb);
  80cd59:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cd5d:	83 ec 0c             	sub    $0xc,%esp
  80cd60:	57                   	push   %edi
  80cd61:	e8 b8 b2 ff ff       	call   80801e <tcp_output>
        if (pcb->ooseq == NULL) {
  80cd66:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cd69:	83 c4 10             	add    $0x10,%esp
  80cd6c:	85 db                	test   %ebx,%ebx
  80cd6e:	74 1e                	je     80cd8e <tcp_receive+0xa5d>
            if (seqno == next->tcphdr->seqno) {
  80cd70:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80cd76:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cd79:	8d 51 01             	lea    0x1(%ecx),%edx
  80cd7c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80cd7f:	be 00 00 00 00       	mov    $0x0,%esi
  80cd84:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cd87:	89 c7                	mov    %eax,%edi
  80cd89:	e9 d7 00 00 00       	jmp    80ce65 <tcp_receive+0xb34>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cd8e:	83 ec 0c             	sub    $0xc,%esp
  80cd91:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cd96:	e8 db 89 ff ff       	call   805776 <tcp_seg_copy>
  80cd9b:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cd9e:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cda1:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cda5:	e9 56 02 00 00       	jmp    80d000 <tcp_receive+0xccf>
  80cdaa:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cdad:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80cdb1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cdb5:	66 39 05 c0 b1 b3 00 	cmp    %ax,0xb3b1c0
  80cdbc:	0f 86 3e 02 00 00    	jbe    80d000 <tcp_receive+0xccf>
                cseg = tcp_seg_copy(&inseg);
  80cdc2:	83 ec 0c             	sub    $0xc,%esp
  80cdc5:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cdca:	e8 a7 89 ff ff       	call   805776 <tcp_seg_copy>
  80cdcf:	89 c1                	mov    %eax,%ecx
  80cdd1:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80cdd4:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cdd7:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cddb:	85 c0                	test   %eax,%eax
  80cddd:	0f 84 1d 02 00 00    	je     80d000 <tcp_receive+0xccf>
                  cseg->next = next->next;
  80cde3:	8b 03                	mov    (%ebx),%eax
  80cde5:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cde7:	85 f6                	test   %esi,%esi
  80cde9:	74 5c                	je     80ce47 <tcp_receive+0xb16>
                    prev->next = cseg;
  80cdeb:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cded:	83 ec 0c             	sub    $0xc,%esp
  80cdf0:	53                   	push   %ebx
  80cdf1:	e8 07 89 ff ff       	call   8056fd <tcp_seg_free>
                  if (cseg->next != NULL) {
  80cdf6:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80cdf9:	8b 06                	mov    (%esi),%eax
  80cdfb:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cdfe:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80ce02:	85 c0                	test   %eax,%eax
  80ce04:	0f 84 f6 01 00 00    	je     80d000 <tcp_receive+0xccf>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ce0a:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80ce10:	8b 40 10             	mov    0x10(%eax),%eax
  80ce13:	8b 40 04             	mov    0x4(%eax),%eax
  80ce16:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80ce1a:	01 ca                	add    %ecx,%edx
  80ce1c:	29 c2                	sub    %eax,%edx
  80ce1e:	85 d2                	test   %edx,%edx
  80ce20:	0f 8e da 01 00 00    	jle    80d000 <tcp_receive+0xccf>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80ce26:	29 c8                	sub    %ecx,%eax
  80ce28:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80ce2c:	83 ec 08             	sub    $0x8,%esp
  80ce2f:	0f b7 c0             	movzwl %ax,%eax
  80ce32:	50                   	push   %eax
  80ce33:	ff 76 04             	pushl  0x4(%esi)
  80ce36:	e8 e0 7c ff ff       	call   804b1b <pbuf_realloc>
  80ce3b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce3e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80ce42:	e9 b9 01 00 00       	jmp    80d000 <tcp_receive+0xccf>
                    pcb->ooseq = cseg;
  80ce47:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ce4a:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ce4d:	eb 9e                	jmp    80cded <tcp_receive+0xabc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ce4f:	39 c1                	cmp    %eax,%ecx
  80ce51:	0f 88 a0 00 00 00    	js     80cef7 <tcp_receive+0xbc6>
              if (next->next == NULL &&
  80ce57:	8b 13                	mov    (%ebx),%edx
  80ce59:	89 de                	mov    %ebx,%esi
  80ce5b:	85 d2                	test   %edx,%edx
  80ce5d:	0f 84 0d 01 00 00    	je     80cf70 <tcp_receive+0xc3f>
  80ce63:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80ce65:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce68:	8b 40 04             	mov    0x4(%eax),%eax
  80ce6b:	39 c8                	cmp    %ecx,%eax
  80ce6d:	0f 84 37 ff ff ff    	je     80cdaa <tcp_receive+0xa79>
              if (prev == NULL) {
  80ce73:	85 f6                	test   %esi,%esi
  80ce75:	74 d8                	je     80ce4f <tcp_receive+0xb1e>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80ce77:	8b 56 10             	mov    0x10(%esi),%edx
  80ce7a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80ce7d:	78 d8                	js     80ce57 <tcp_receive+0xb26>
  80ce7f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ce82:	29 c2                	sub    %eax,%edx
  80ce84:	85 d2                	test   %edx,%edx
  80ce86:	7f cf                	jg     80ce57 <tcp_receive+0xb26>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80ce88:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80ce8f:	01 ca                	add    %ecx,%edx
  80ce91:	29 c2                	sub    %eax,%edx
  80ce93:	85 d2                	test   %edx,%edx
  80ce95:	0f 8f b3 00 00 00    	jg     80cf4e <tcp_receive+0xc1d>
                cseg = tcp_seg_copy(&inseg);
  80ce9b:	83 ec 0c             	sub    $0xc,%esp
  80ce9e:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cea3:	e8 ce 88 ff ff       	call   805776 <tcp_seg_copy>
                if (cseg != NULL) {
  80cea8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ceab:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80ceaf:	85 c0                	test   %eax,%eax
  80ceb1:	0f 84 49 01 00 00    	je     80d000 <tcp_receive+0xccf>
                  cseg->next = next;
  80ceb7:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80ceb9:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cebb:	8b 46 10             	mov    0x10(%esi),%eax
  80cebe:	8b 48 04             	mov    0x4(%eax),%ecx
  80cec1:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cec6:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80ceca:	01 ca                	add    %ecx,%edx
  80cecc:	29 c2                	sub    %eax,%edx
  80cece:	85 d2                	test   %edx,%edx
  80ced0:	0f 8e 2a 01 00 00    	jle    80d000 <tcp_receive+0xccf>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80ced6:	29 c8                	sub    %ecx,%eax
  80ced8:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cedc:	83 ec 08             	sub    $0x8,%esp
  80cedf:	0f b7 c0             	movzwl %ax,%eax
  80cee2:	50                   	push   %eax
  80cee3:	ff 76 04             	pushl  0x4(%esi)
  80cee6:	e8 30 7c ff ff       	call   804b1b <pbuf_realloc>
  80ceeb:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ceee:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cef2:	e9 09 01 00 00       	jmp    80d000 <tcp_receive+0xccf>
  80cef7:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cefa:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cf01:	01 ca                	add    %ecx,%edx
  80cf03:	29 c2                	sub    %eax,%edx
  80cf05:	85 d2                	test   %edx,%edx
  80cf07:	7f 26                	jg     80cf2f <tcp_receive+0xbfe>
                  cseg = tcp_seg_copy(&inseg);
  80cf09:	83 ec 0c             	sub    $0xc,%esp
  80cf0c:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cf11:	e8 60 88 ff ff       	call   805776 <tcp_seg_copy>
                  if (cseg != NULL) {
  80cf16:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf19:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80cf1d:	85 c0                	test   %eax,%eax
  80cf1f:	0f 84 db 00 00 00    	je     80d000 <tcp_receive+0xccf>
                    cseg->next = next;
  80cf25:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cf27:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cf2a:	e9 d1 00 00 00       	jmp    80d000 <tcp_receive+0xccf>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf2f:	29 c8                	sub    %ecx,%eax
  80cf31:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cf37:	83 ec 08             	sub    $0x8,%esp
  80cf3a:	0f b7 c0             	movzwl %ax,%eax
  80cf3d:	50                   	push   %eax
  80cf3e:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cf44:	e8 d2 7b ff ff       	call   804b1b <pbuf_realloc>
  80cf49:	83 c4 10             	add    $0x10,%esp
  80cf4c:	eb bb                	jmp    80cf09 <tcp_receive+0xbd8>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cf4e:	29 c8                	sub    %ecx,%eax
  80cf50:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cf56:	83 ec 08             	sub    $0x8,%esp
  80cf59:	0f b7 c0             	movzwl %ax,%eax
  80cf5c:	50                   	push   %eax
  80cf5d:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cf63:	e8 b3 7b ff ff       	call   804b1b <pbuf_realloc>
  80cf68:	83 c4 10             	add    $0x10,%esp
  80cf6b:	e9 2b ff ff ff       	jmp    80ce9b <tcp_receive+0xb6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80cf70:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80cf72:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80cf76:	85 c9                	test   %ecx,%ecx
  80cf78:	0f 8e 82 00 00 00    	jle    80d000 <tcp_receive+0xccf>
                next->next = tcp_seg_copy(&inseg);
  80cf7e:	83 ec 0c             	sub    $0xc,%esp
  80cf81:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cf86:	e8 eb 87 ff ff       	call   805776 <tcp_seg_copy>
  80cf8b:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80cf8d:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf90:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80cf94:	85 c0                	test   %eax,%eax
  80cf96:	74 68                	je     80d000 <tcp_receive+0xccf>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80cf98:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf9b:	8b 48 04             	mov    0x4(%eax),%ecx
  80cf9e:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cfa3:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80cfa7:	01 ca                	add    %ecx,%edx
  80cfa9:	29 c2                	sub    %eax,%edx
  80cfab:	85 d2                	test   %edx,%edx
  80cfad:	7e 51                	jle    80d000 <tcp_receive+0xccf>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80cfaf:	29 c8                	sub    %ecx,%eax
  80cfb1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80cfb5:	83 ec 08             	sub    $0x8,%esp
  80cfb8:	0f b7 c0             	movzwl %ax,%eax
  80cfbb:	50                   	push   %eax
  80cfbc:	ff 73 04             	pushl  0x4(%ebx)
  80cfbf:	e8 57 7b ff ff       	call   804b1b <pbuf_realloc>
  80cfc4:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfc7:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cfcb:	eb 33                	jmp    80d000 <tcp_receive+0xccf>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cfcd:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cfd2:	8b 57 24             	mov    0x24(%edi),%edx
  80cfd5:	39 d0                	cmp    %edx,%eax
  80cfd7:	78 13                	js     80cfec <tcp_receive+0xcbb>
  80cfd9:	83 c0 01             	add    $0x1,%eax
  80cfdc:	29 d0                	sub    %edx,%eax
  80cfde:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80cfe2:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80cfe4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80cfe8:	85 c0                	test   %eax,%eax
  80cfea:	7e 14                	jle    80d000 <tcp_receive+0xccf>
      tcp_ack_now(pcb);
  80cfec:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cff0:	83 ec 0c             	sub    $0xc,%esp
  80cff3:	57                   	push   %edi
  80cff4:	e8 25 b0 ff ff       	call   80801e <tcp_output>
  80cff9:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cffc:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d000:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d004:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d007:	5b                   	pop    %ebx
  80d008:	5e                   	pop    %esi
  80d009:	5f                   	pop    %edi
  80d00a:	5d                   	pop    %ebp
  80d00b:	c3                   	ret    

0080d00c <tcp_input>:
{
  80d00c:	55                   	push   %ebp
  80d00d:	89 e5                	mov    %esp,%ebp
  80d00f:	57                   	push   %edi
  80d010:	56                   	push   %esi
  80d011:	53                   	push   %ebx
  80d012:	83 ec 38             	sub    $0x38,%esp
  80d015:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d018:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d01b:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d021:	0f b7 03             	movzwl (%ebx),%eax
  80d024:	50                   	push   %eax
  80d025:	e8 a0 a6 ff ff       	call   8076ca <ntohs>
  80d02a:	66 c1 e8 08          	shr    $0x8,%ax
  80d02e:	83 e0 0f             	and    $0xf,%eax
  80d031:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d034:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d039:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d03e:	0f b7 00             	movzwl (%eax),%eax
  80d041:	89 04 24             	mov    %eax,(%esp)
  80d044:	e8 81 a6 ff ff       	call   8076ca <ntohs>
  80d049:	83 c4 08             	add    $0x8,%esp
  80d04c:	66 c1 e8 06          	shr    $0x6,%ax
  80d050:	83 e0 3c             	and    $0x3c,%eax
  80d053:	f7 d8                	neg    %eax
  80d055:	98                   	cwtl   
  80d056:	50                   	push   %eax
  80d057:	56                   	push   %esi
  80d058:	e8 b9 76 ff ff       	call   804716 <pbuf_header>
  80d05d:	83 c4 10             	add    $0x10,%esp
  80d060:	84 c0                	test   %al,%al
  80d062:	75 07                	jne    80d06b <tcp_input+0x5f>
  80d064:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d069:	77 14                	ja     80d07f <tcp_input+0x73>
    pbuf_free(p);
  80d06b:	83 ec 0c             	sub    $0xc,%esp
  80d06e:	56                   	push   %esi
  80d06f:	e8 6f 77 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d074:	83 c4 10             	add    $0x10,%esp
}
  80d077:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d07a:	5b                   	pop    %ebx
  80d07b:	5e                   	pop    %esi
  80d07c:	5f                   	pop    %edi
  80d07d:	5d                   	pop    %ebp
  80d07e:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d07f:	83 ec 08             	sub    $0x8,%esp
  80d082:	ff 75 0c             	pushl  0xc(%ebp)
  80d085:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d08a:	83 c0 10             	add    $0x10,%eax
  80d08d:	50                   	push   %eax
  80d08e:	e8 c7 93 ff ff       	call   80645a <ip_addr_isbroadcast>
  80d093:	83 c4 10             	add    $0x10,%esp
  80d096:	84 c0                	test   %al,%al
  80d098:	0f 85 54 01 00 00    	jne    80d1f2 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d09e:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d0a3:	8b 58 10             	mov    0x10(%eax),%ebx
  80d0a6:	83 ec 0c             	sub    $0xc,%esp
  80d0a9:	68 00 00 00 f0       	push   $0xf0000000
  80d0ae:	e8 3b a8 ff ff       	call   8078ee <ntohl>
  80d0b3:	21 c3                	and    %eax,%ebx
  80d0b5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d0bc:	e8 2d a8 ff ff       	call   8078ee <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d0c1:	83 c4 10             	add    $0x10,%esp
  80d0c4:	39 c3                	cmp    %eax,%ebx
  80d0c6:	0f 84 26 01 00 00    	je     80d1f2 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d0cc:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d0d1:	83 ec 0c             	sub    $0xc,%esp
  80d0d4:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d0d8:	52                   	push   %edx
  80d0d9:	6a 06                	push   $0x6
  80d0db:	8d 50 10             	lea    0x10(%eax),%edx
  80d0de:	52                   	push   %edx
  80d0df:	83 c0 0c             	add    $0xc,%eax
  80d0e2:	50                   	push   %eax
  80d0e3:	56                   	push   %esi
  80d0e4:	e8 b0 a2 ff ff       	call   807399 <inet_chksum_pseudo>
  80d0e9:	83 c4 20             	add    $0x20,%esp
  80d0ec:	66 85 c0             	test   %ax,%ax
  80d0ef:	0f 85 0e 01 00 00    	jne    80d203 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d0f5:	83 ec 0c             	sub    $0xc,%esp
  80d0f8:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d0fd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d101:	50                   	push   %eax
  80d102:	e8 c3 a5 ff ff       	call   8076ca <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d107:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d10a:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d10e:	f7 d8                	neg    %eax
  80d110:	c1 e0 02             	shl    $0x2,%eax
  80d113:	98                   	cwtl   
  80d114:	50                   	push   %eax
  80d115:	56                   	push   %esi
  80d116:	e8 fb 75 ff ff       	call   804716 <pbuf_header>
  80d11b:	83 c4 10             	add    $0x10,%esp
  80d11e:	84 c0                	test   %al,%al
  80d120:	0f 85 ee 00 00 00    	jne    80d214 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d126:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d12c:	83 ec 0c             	sub    $0xc,%esp
  80d12f:	0f b7 03             	movzwl (%ebx),%eax
  80d132:	50                   	push   %eax
  80d133:	e8 92 a5 ff ff       	call   8076ca <ntohs>
  80d138:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d13b:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d141:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d145:	89 04 24             	mov    %eax,(%esp)
  80d148:	e8 7d a5 ff ff       	call   8076ca <ntohs>
  80d14d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d151:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d157:	83 c4 04             	add    $0x4,%esp
  80d15a:	ff 73 04             	pushl  0x4(%ebx)
  80d15d:	e8 8c a7 ff ff       	call   8078ee <ntohl>
  80d162:	89 43 04             	mov    %eax,0x4(%ebx)
  80d165:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d16a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d170:	83 c4 04             	add    $0x4,%esp
  80d173:	ff 73 08             	pushl  0x8(%ebx)
  80d176:	e8 73 a7 ff ff       	call   8078ee <ntohl>
  80d17b:	89 43 08             	mov    %eax,0x8(%ebx)
  80d17e:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d183:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d189:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d18d:	89 04 24             	mov    %eax,(%esp)
  80d190:	e8 35 a5 ff ff       	call   8076ca <ntohs>
  80d195:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d199:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d19e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d1a2:	89 04 24             	mov    %eax,(%esp)
  80d1a5:	e8 20 a5 ff ff       	call   8076ca <ntohs>
  80d1aa:	89 c1                	mov    %eax,%ecx
  80d1ac:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d1b0:	83 e0 3f             	and    $0x3f,%eax
  80d1b3:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d1b8:	83 c4 10             	add    $0x10,%esp
  80d1bb:	f6 c1 03             	test   $0x3,%cl
  80d1be:	0f 95 c0             	setne  %al
  80d1c1:	0f b6 c0             	movzbl %al,%eax
  80d1c4:	66 03 46 08          	add    0x8(%esi),%ax
  80d1c8:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d1cc:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1d2:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d1d7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d1da:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d1e0:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1e6:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d1e8:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d1ed:	e9 ab 00 00 00       	jmp    80d29d <tcp_input+0x291>
    pbuf_free(p);
  80d1f2:	83 ec 0c             	sub    $0xc,%esp
  80d1f5:	56                   	push   %esi
  80d1f6:	e8 e8 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d1fb:	83 c4 10             	add    $0x10,%esp
  80d1fe:	e9 74 fe ff ff       	jmp    80d077 <tcp_input+0x6b>
    pbuf_free(p);
  80d203:	83 ec 0c             	sub    $0xc,%esp
  80d206:	56                   	push   %esi
  80d207:	e8 d7 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d20c:	83 c4 10             	add    $0x10,%esp
  80d20f:	e9 63 fe ff ff       	jmp    80d077 <tcp_input+0x6b>
    pbuf_free(p);
  80d214:	83 ec 0c             	sub    $0xc,%esp
  80d217:	56                   	push   %esi
  80d218:	e8 c6 75 ff ff       	call   8047e3 <pbuf_free>
    return;
  80d21d:	83 c4 10             	add    $0x10,%esp
  80d220:	e9 52 fe ff ff       	jmp    80d077 <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d225:	83 ec 04             	sub    $0x4,%esp
  80d228:	68 50 34 81 00       	push   $0x813450
  80d22d:	68 b5 00 00 00       	push   $0xb5
  80d232:	68 74 35 81 00       	push   $0x813574
  80d237:	e8 6c 13 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d23c:	83 ec 04             	sub    $0x4,%esp
  80d23f:	68 78 34 81 00       	push   $0x813478
  80d244:	68 b6 00 00 00       	push   $0xb6
  80d249:	68 74 35 81 00       	push   $0x813574
  80d24e:	e8 55 13 00 00       	call   80e5a8 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d253:	83 ec 04             	sub    $0x4,%esp
  80d256:	68 a4 34 81 00       	push   $0x8134a4
  80d25b:	68 b7 00 00 00       	push   $0xb7
  80d260:	68 74 35 81 00       	push   $0x813574
  80d265:	e8 3e 13 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d26a:	83 ec 04             	sub    $0x4,%esp
  80d26d:	68 cc 34 81 00       	push   $0x8134cc
  80d272:	68 c0 00 00 00       	push   $0xc0
  80d277:	68 74 35 81 00       	push   $0x813574
  80d27c:	e8 27 13 00 00       	call   80e5a8 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d281:	83 ec 04             	sub    $0x4,%esp
  80d284:	68 f8 34 81 00       	push   $0x8134f8
  80d289:	68 c6 00 00 00       	push   $0xc6
  80d28e:	68 74 35 81 00       	push   $0x813574
  80d293:	e8 10 13 00 00       	call   80e5a8 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d298:	89 df                	mov    %ebx,%edi
  80d29a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d29d:	85 db                	test   %ebx,%ebx
  80d29f:	0f 84 b3 0a 00 00    	je     80dd58 <tcp_input+0xd4c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d2a5:	8b 43 10             	mov    0x10(%ebx),%eax
  80d2a8:	85 c0                	test   %eax,%eax
  80d2aa:	0f 84 75 ff ff ff    	je     80d225 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d2b0:	83 f8 0a             	cmp    $0xa,%eax
  80d2b3:	74 87                	je     80d23c <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d2b5:	83 f8 01             	cmp    $0x1,%eax
  80d2b8:	74 99                	je     80d253 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d2ba:	0f b7 02             	movzwl (%edx),%eax
  80d2bd:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d2c1:	75 d5                	jne    80d298 <tcp_input+0x28c>
  80d2c3:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d2c7:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d2cb:	75 cb                	jne    80d298 <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d2cd:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d2d0:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d2d3:	75 c3                	jne    80d298 <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d2d5:	8b 41 10             	mov    0x10(%ecx),%eax
  80d2d8:	39 03                	cmp    %eax,(%ebx)
  80d2da:	75 bc                	jne    80d298 <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d2dc:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d2df:	39 c3                	cmp    %eax,%ebx
  80d2e1:	74 87                	je     80d26a <tcp_input+0x25e>
      if (prev != NULL) {
  80d2e3:	85 ff                	test   %edi,%edi
  80d2e5:	74 13                	je     80d2fa <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d2e7:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d2ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d2ed:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d2f0:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d2f6:	39 c3                	cmp    %eax,%ebx
  80d2f8:	74 87                	je     80d281 <tcp_input+0x275>
    inseg.next = NULL;
  80d2fa:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d301:	00 00 00 
    inseg.len = p->tot_len;
  80d304:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d308:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d30e:	8b 46 04             	mov    0x4(%esi),%eax
  80d311:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d316:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d31c:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d322:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d329:	00 00 00 
    recv_flags = 0;
  80d32c:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d333:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d339:	85 c0                	test   %eax,%eax
  80d33b:	74 2c                	je     80d369 <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d33d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d343:	85 d2                	test   %edx,%edx
  80d345:	0f 84 07 03 00 00    	je     80d652 <tcp_input+0x646>
  80d34b:	6a 00                	push   $0x0
  80d34d:	50                   	push   %eax
  80d34e:	53                   	push   %ebx
  80d34f:	ff 73 18             	pushl  0x18(%ebx)
  80d352:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d354:	83 c4 10             	add    $0x10,%esp
  80d357:	84 c0                	test   %al,%al
  80d359:	0f 85 04 03 00 00    	jne    80d663 <tcp_input+0x657>
        pcb->refused_data = NULL;
  80d35f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d366:	00 00 00 
    tcp_input_pcb = pcb;
  80d369:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d36f:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d376:	a8 04                	test   $0x4,%al
  80d378:	0f 84 20 03 00 00    	je     80d69e <tcp_input+0x692>
    if (pcb->state == SYN_SENT) {
  80d37e:	8b 53 10             	mov    0x10(%ebx),%edx
  80d381:	83 fa 02             	cmp    $0x2,%edx
  80d384:	0f 84 ea 02 00 00    	je     80d674 <tcp_input+0x668>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d38a:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d38f:	2b 43 24             	sub    0x24(%ebx),%eax
  80d392:	78 1d                	js     80d3b1 <tcp_input+0x3a5>
  80d394:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d398:	29 c8                	sub    %ecx,%eax
  80d39a:	85 c0                	test   %eax,%eax
  80d39c:	7f 13                	jg     80d3b1 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d39e:	85 d2                	test   %edx,%edx
  80d3a0:	0f 84 e1 02 00 00    	je     80d687 <tcp_input+0x67b>
      recv_flags = TF_RESET;
  80d3a6:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d3ad:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d3b1:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d3b8:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d3bb:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d3c2:	a8 08                	test   $0x8,%al
  80d3c4:	0f 84 37 08 00 00    	je     80dc01 <tcp_input+0xbf5>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d3ca:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d3d0:	85 c0                	test   %eax,%eax
  80d3d2:	74 0d                	je     80d3e1 <tcp_input+0x3d5>
  80d3d4:	83 ec 08             	sub    $0x8,%esp
  80d3d7:	6a fa                	push   $0xfffffffa
  80d3d9:	ff 73 18             	pushl  0x18(%ebx)
  80d3dc:	ff d0                	call   *%eax
  80d3de:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d3e1:	83 ec 08             	sub    $0x8,%esp
  80d3e4:	53                   	push   %ebx
  80d3e5:	68 3c b2 b3 00       	push   $0xb3b23c
  80d3ea:	e8 a4 84 ff ff       	call   805893 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d3ef:	83 c4 08             	add    $0x8,%esp
  80d3f2:	53                   	push   %ebx
  80d3f3:	6a 02                	push   $0x2
  80d3f5:	e8 9c 70 ff ff       	call   804496 <memp_free>
  80d3fa:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d3fd:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d402:	85 c0                	test   %eax,%eax
  80d404:	0f 84 6d fc ff ff    	je     80d077 <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d40a:	83 ec 0c             	sub    $0xc,%esp
  80d40d:	50                   	push   %eax
  80d40e:	e8 d0 73 ff ff       	call   8047e3 <pbuf_free>
      inseg.p = NULL;
  80d413:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d41a:	00 00 00 
  80d41d:	83 c4 10             	add    $0x10,%esp
  80d420:	e9 52 fc ff ff       	jmp    80d077 <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d425:	83 ec 04             	sub    $0x4,%esp
  80d428:	68 24 35 81 00       	push   $0x813524
  80d42d:	68 d0 00 00 00       	push   $0xd0
  80d432:	68 74 35 81 00       	push   $0x813574
  80d437:	e8 6c 11 00 00       	call   80e5a8 <_panic>
    tcp_ack_now(pcb);
  80d43c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d440:	83 ec 0c             	sub    $0xc,%esp
  80d443:	53                   	push   %ebx
  80d444:	e8 d5 ab ff ff       	call   80801e <tcp_output>
  80d449:	83 c4 10             	add    $0x10,%esp
  80d44c:	eb 4c                	jmp    80d49a <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d44e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d451:	85 db                	test   %ebx,%ebx
  80d453:	74 5e                	je     80d4b3 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d455:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d459:	75 ca                	jne    80d425 <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d45b:	0f b7 02             	movzwl (%edx),%eax
  80d45e:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d462:	75 ea                	jne    80d44e <tcp_input+0x442>
  80d464:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d468:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d46c:	75 e0                	jne    80d44e <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d46e:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d471:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d474:	75 d8                	jne    80d44e <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d476:	8b 41 10             	mov    0x10(%ecx),%eax
  80d479:	39 03                	cmp    %eax,(%ebx)
  80d47b:	75 d1                	jne    80d44e <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d47d:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d481:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d487:	89 c2                	mov    %eax,%edx
  80d489:	2b 53 24             	sub    0x24(%ebx),%edx
  80d48c:	85 d2                	test   %edx,%edx
  80d48e:	7e 03                	jle    80d493 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d490:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d493:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d498:	75 a2                	jne    80d43c <tcp_input+0x430>
  return tcp_output(pcb);
  80d49a:	83 ec 0c             	sub    $0xc,%esp
  80d49d:	53                   	push   %ebx
  80d49e:	e8 7b ab ff ff       	call   80801e <tcp_output>
        pbuf_free(p);
  80d4a3:	89 34 24             	mov    %esi,(%esp)
  80d4a6:	e8 38 73 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d4ab:	83 c4 10             	add    $0x10,%esp
  80d4ae:	e9 c4 fb ff ff       	jmp    80d077 <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4b3:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d4b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d4bb:	89 c7                	mov    %eax,%edi
  80d4bd:	eb 0f                	jmp    80d4ce <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d4bf:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d4c3:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d4c7:	74 1a                	je     80d4e3 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d4c9:	89 fb                	mov    %edi,%ebx
  80d4cb:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d4ce:	85 ff                	test   %edi,%edi
  80d4d0:	0f 84 5d 08 00 00    	je     80dd33 <tcp_input+0xd27>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d4d6:	8b 07                	mov    (%edi),%eax
  80d4d8:	85 c0                	test   %eax,%eax
  80d4da:	74 e3                	je     80d4bf <tcp_input+0x4b3>
  80d4dc:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d4df:	75 e8                	jne    80d4c9 <tcp_input+0x4bd>
  80d4e1:	eb dc                	jmp    80d4bf <tcp_input+0x4b3>
        if (prev != NULL) {
  80d4e3:	85 db                	test   %ebx,%ebx
  80d4e5:	74 12                	je     80d4f9 <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d4e7:	8b 47 0c             	mov    0xc(%edi),%eax
  80d4ea:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d4ed:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d4f0:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d4f3:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d4f9:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d4fd:	75 17                	jne    80d516 <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d4ff:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d503:	75 43                	jne    80d548 <tcp_input+0x53c>
        pbuf_free(p);
  80d505:	83 ec 0c             	sub    $0xc,%esp
  80d508:	56                   	push   %esi
  80d509:	e8 d5 72 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d50e:	83 c4 10             	add    $0x10,%esp
  80d511:	e9 61 fb ff ff       	jmp    80d077 <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d516:	83 ec 08             	sub    $0x8,%esp
  80d519:	0f b7 02             	movzwl (%edx),%eax
  80d51c:	50                   	push   %eax
  80d51d:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d521:	50                   	push   %eax
  80d522:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d525:	50                   	push   %eax
  80d526:	83 c1 10             	add    $0x10,%ecx
  80d529:	51                   	push   %ecx
  80d52a:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d52e:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d534:	50                   	push   %eax
  80d535:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d53a:	83 c0 01             	add    $0x1,%eax
  80d53d:	50                   	push   %eax
  80d53e:	e8 7b af ff ff       	call   8084be <tcp_rst>
  80d543:	83 c4 20             	add    $0x20,%esp
  80d546:	eb bd                	jmp    80d505 <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d548:	83 ec 0c             	sub    $0xc,%esp
  80d54b:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d54f:	50                   	push   %eax
  80d550:	e8 9c 8b ff ff       	call   8060f1 <tcp_alloc>
  80d555:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d557:	83 c4 10             	add    $0x10,%esp
  80d55a:	85 c0                	test   %eax,%eax
  80d55c:	74 a7                	je     80d505 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d55e:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d563:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d566:	0f 84 c5 00 00 00    	je     80d631 <tcp_input+0x625>
  80d56c:	8b 50 10             	mov    0x10(%eax),%edx
  80d56f:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d571:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d575:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d579:	8b 50 0c             	mov    0xc(%eax),%edx
  80d57c:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d57f:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d585:	0f b7 02             	movzwl (%edx),%eax
  80d588:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d58c:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d593:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d598:	8d 48 01             	lea    0x1(%eax),%ecx
  80d59b:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d59e:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d5a2:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d5a6:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d5aa:	83 e8 01             	sub    $0x1,%eax
  80d5ad:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d5b0:	8b 47 18             	mov    0x18(%edi),%eax
  80d5b3:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d5b6:	8b 47 20             	mov    0x20(%edi),%eax
  80d5b9:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d5bf:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d5c3:	66 25 99 01          	and    $0x199,%ax
  80d5c7:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d5cb:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d5d0:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d5d3:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d5d9:	e8 db 4b ff ff       	call   8021b9 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d5de:	89 d8                	mov    %ebx,%eax
  80d5e0:	e8 98 ec ff ff       	call   80c27d <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d5e5:	83 ec 08             	sub    $0x8,%esp
  80d5e8:	8d 43 04             	lea    0x4(%ebx),%eax
  80d5eb:	50                   	push   %eax
  80d5ec:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d5f0:	50                   	push   %eax
  80d5f1:	e8 99 8c ff ff       	call   80628f <tcp_eff_send_mss>
  80d5f6:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d5fa:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d601:	e8 d1 a0 ff ff       	call   8076d7 <htonl>
  80d606:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d609:	83 c4 0c             	add    $0xc,%esp
  80d60c:	6a 04                	push   $0x4
  80d60e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d611:	50                   	push   %eax
  80d612:	6a 00                	push   $0x0
  80d614:	6a 12                	push   $0x12
  80d616:	6a 00                	push   $0x0
  80d618:	6a 00                	push   $0x0
  80d61a:	53                   	push   %ebx
  80d61b:	e8 e1 a2 ff ff       	call   807901 <tcp_enqueue>
    return tcp_output(npcb);
  80d620:	83 c4 14             	add    $0x14,%esp
  80d623:	53                   	push   %ebx
  80d624:	e8 f5 a9 ff ff       	call   80801e <tcp_output>
  80d629:	83 c4 10             	add    $0x10,%esp
  80d62c:	e9 d4 fe ff ff       	jmp    80d505 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d631:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    npcb->local_port = pcb->local_port;
  80d637:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d63b:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d63f:	ba 00 00 00 00       	mov    $0x0,%edx
  80d644:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d647:	0f 84 2f ff ff ff    	je     80d57c <tcp_input+0x570>
  80d64d:	e9 27 ff ff ff       	jmp    80d579 <tcp_input+0x56d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d652:	83 ec 0c             	sub    $0xc,%esp
  80d655:	50                   	push   %eax
  80d656:	e8 88 71 ff ff       	call   8047e3 <pbuf_free>
  80d65b:	83 c4 10             	add    $0x10,%esp
  80d65e:	e9 fc fc ff ff       	jmp    80d35f <tcp_input+0x353>
        pbuf_free(p);
  80d663:	83 ec 0c             	sub    $0xc,%esp
  80d666:	56                   	push   %esi
  80d667:	e8 77 71 ff ff       	call   8047e3 <pbuf_free>
        return;
  80d66c:	83 c4 10             	add    $0x10,%esp
  80d66f:	e9 03 fa ff ff       	jmp    80d077 <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d674:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d679:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d67c:	0f 84 24 fd ff ff    	je     80d3a6 <tcp_input+0x39a>
  80d682:	e9 2a fd ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d687:	83 ec 04             	sub    $0x4,%esp
  80d68a:	68 54 35 81 00       	push   $0x813554
  80d68f:	68 09 02 00 00       	push   $0x209
  80d694:	68 74 35 81 00       	push   $0x813574
  80d699:	e8 0a 0f 00 00       	call   80e5a8 <_panic>
  pcb->tmr = tcp_ticks;
  80d69e:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d6a4:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d6a7:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d6ae:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d6b2:	0f 87 3a 05 00 00    	ja     80dbf2 <tcp_input+0xbe6>
  80d6b8:	8b 53 10             	mov    0x10(%ebx),%edx
  80d6bb:	ff 24 95 f8 35 81 00 	jmp    *0x8135f8(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d6c2:	83 e0 12             	and    $0x12,%eax
  80d6c5:	3c 12                	cmp    $0x12,%al
  80d6c7:	74 4d                	je     80d716 <tcp_input+0x70a>
    else if (flags & TCP_ACK) {
  80d6c9:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d6d0:	0f 84 db fc ff ff    	je     80d3b1 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d6d6:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d6dc:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d6e1:	83 ec 08             	sub    $0x8,%esp
  80d6e4:	0f b7 0a             	movzwl (%edx),%ecx
  80d6e7:	51                   	push   %ecx
  80d6e8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d6ec:	52                   	push   %edx
  80d6ed:	8d 50 0c             	lea    0xc(%eax),%edx
  80d6f0:	52                   	push   %edx
  80d6f1:	83 c0 10             	add    $0x10,%eax
  80d6f4:	50                   	push   %eax
  80d6f5:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d6fc:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d702:	50                   	push   %eax
  80d703:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d709:	e8 b0 ad ff ff       	call   8084be <tcp_rst>
  80d70e:	83 c4 20             	add    $0x20,%esp
  80d711:	e9 9b fc ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d716:	83 ec 0c             	sub    $0xc,%esp
  80d719:	8b 43 78             	mov    0x78(%ebx),%eax
  80d71c:	8b 40 10             	mov    0x10(%eax),%eax
  80d71f:	ff 70 04             	pushl  0x4(%eax)
  80d722:	e8 c7 a1 ff ff       	call   8078ee <ntohl>
  80d727:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d72d:	83 c0 01             	add    $0x1,%eax
  80d730:	83 c4 10             	add    $0x10,%esp
  80d733:	39 d0                	cmp    %edx,%eax
  80d735:	75 92                	jne    80d6c9 <tcp_input+0x6bd>
      pcb->snd_buf++;
  80d737:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d73c:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d741:	8d 48 01             	lea    0x1(%eax),%ecx
  80d744:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d747:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d74a:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d750:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d754:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d758:	83 e8 01             	sub    $0x1,%eax
  80d75b:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d75e:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d765:	89 d8                	mov    %ebx,%eax
  80d767:	e8 11 eb ff ff       	call   80c27d <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d76c:	83 ec 08             	sub    $0x8,%esp
  80d76f:	8d 43 04             	lea    0x4(%ebx),%eax
  80d772:	50                   	push   %eax
  80d773:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d777:	50                   	push   %eax
  80d778:	e8 12 8b ff ff       	call   80628f <tcp_eff_send_mss>
  80d77d:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d781:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d784:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d788:	83 c4 10             	add    $0x10,%esp
  80d78b:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d790:	74 63                	je     80d7f5 <tcp_input+0x7e9>
  80d792:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d796:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d79a:	66 85 c0             	test   %ax,%ax
  80d79d:	74 5a                	je     80d7f9 <tcp_input+0x7ed>
      --pcb->snd_queuelen;
  80d79f:	83 e8 01             	sub    $0x1,%eax
  80d7a2:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d7a6:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d7a9:	8b 10                	mov    (%eax),%edx
  80d7ab:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d7ae:	85 d2                	test   %edx,%edx
  80d7b0:	74 5e                	je     80d810 <tcp_input+0x804>
        pcb->rtime = 0;
  80d7b2:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d7b8:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d7bc:	83 ec 0c             	sub    $0xc,%esp
  80d7bf:	50                   	push   %eax
  80d7c0:	e8 38 7f ff ff       	call   8056fd <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d7c5:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d7cb:	83 c4 10             	add    $0x10,%esp
  80d7ce:	85 c0                	test   %eax,%eax
  80d7d0:	74 0e                	je     80d7e0 <tcp_input+0x7d4>
  80d7d2:	83 ec 04             	sub    $0x4,%esp
  80d7d5:	6a 00                	push   $0x0
  80d7d7:	53                   	push   %ebx
  80d7d8:	ff 73 18             	pushl  0x18(%ebx)
  80d7db:	ff d0                	call   *%eax
  80d7dd:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d7e0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d7e4:	83 ec 0c             	sub    $0xc,%esp
  80d7e7:	53                   	push   %ebx
  80d7e8:	e8 31 a8 ff ff       	call   80801e <tcp_output>
  80d7ed:	83 c4 10             	add    $0x10,%esp
  80d7f0:	e9 bc fb ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d7f5:	01 c0                	add    %eax,%eax
  80d7f7:	eb 99                	jmp    80d792 <tcp_input+0x786>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d7f9:	83 ec 04             	sub    $0x4,%esp
  80d7fc:	68 cd 35 81 00       	push   $0x8135cd
  80d801:	68 35 02 00 00       	push   $0x235
  80d806:	68 74 35 81 00       	push   $0x813574
  80d80b:	e8 98 0d 00 00       	call   80e5a8 <_panic>
        pcb->rtime = -1;
  80d810:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d816:	eb a4                	jmp    80d7bc <tcp_input+0x7b0>
    if (flags & TCP_ACK &&
  80d818:	83 e0 14             	and    $0x14,%eax
  80d81b:	3c 10                	cmp    $0x10,%al
  80d81d:	0f 85 8e fb ff ff    	jne    80d3b1 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d823:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d829:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d82c:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d82f:	78 09                	js     80d83a <tcp_input+0x82e>
  80d831:	89 d0                	mov    %edx,%eax
  80d833:	2b 43 54             	sub    0x54(%ebx),%eax
  80d836:	85 c0                	test   %eax,%eax
  80d838:	7e 3b                	jle    80d875 <tcp_input+0x869>
                tcphdr->dest, tcphdr->src);
  80d83a:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d840:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d845:	83 ec 08             	sub    $0x8,%esp
  80d848:	0f b7 31             	movzwl (%ecx),%esi
  80d84b:	56                   	push   %esi
  80d84c:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d850:	51                   	push   %ecx
  80d851:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d854:	51                   	push   %ecx
  80d855:	83 c0 10             	add    $0x10,%eax
  80d858:	50                   	push   %eax
  80d859:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d860:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d866:	50                   	push   %eax
  80d867:	52                   	push   %edx
  80d868:	e8 51 ac ff ff       	call   8084be <tcp_rst>
  80d86d:	83 c4 20             	add    $0x20,%esp
  80d870:	e9 3c fb ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80d875:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d87c:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d882:	85 c0                	test   %eax,%eax
  80d884:	74 5c                	je     80d8e2 <tcp_input+0x8d6>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d886:	83 ec 04             	sub    $0x4,%esp
  80d889:	6a 00                	push   $0x0
  80d88b:	53                   	push   %ebx
  80d88c:	ff 73 18             	pushl  0x18(%ebx)
  80d88f:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d891:	83 c4 10             	add    $0x10,%esp
  80d894:	84 c0                	test   %al,%al
  80d896:	75 61                	jne    80d8f9 <tcp_input+0x8ed>
        old_cwnd = pcb->cwnd;
  80d898:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80d89c:	89 d8                	mov    %ebx,%eax
  80d89e:	e8 8e ea ff ff       	call   80c331 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d8a3:	66 83 fe 01          	cmp    $0x1,%si
  80d8a7:	74 6b                	je     80d914 <tcp_input+0x908>
  80d8a9:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d8ad:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80d8b1:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d8b8:	0f 84 f3 fa ff ff    	je     80d3b1 <tcp_input+0x3a5>
  80d8be:	84 c0                	test   %al,%al
  80d8c0:	0f 84 eb fa ff ff    	je     80d3b1 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80d8c6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d8ca:	83 ec 0c             	sub    $0xc,%esp
  80d8cd:	53                   	push   %ebx
  80d8ce:	e8 4b a7 ff ff       	call   80801e <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d8d3:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d8da:	83 c4 10             	add    $0x10,%esp
  80d8dd:	e9 cf fa ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d8e2:	83 ec 04             	sub    $0x4,%esp
  80d8e5:	68 e3 35 81 00       	push   $0x8135e3
  80d8ea:	68 5b 02 00 00       	push   $0x25b
  80d8ef:	68 74 35 81 00       	push   $0x813574
  80d8f4:	e8 af 0c 00 00       	call   80e5a8 <_panic>
          tcp_abort(pcb);
  80d8f9:	83 ec 0c             	sub    $0xc,%esp
  80d8fc:	53                   	push   %ebx
  80d8fd:	e8 47 82 ff ff       	call   805b49 <tcp_abort>
    tcp_input_pcb = NULL;
  80d902:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d909:	00 00 00 
  80d90c:	83 c4 10             	add    $0x10,%esp
  80d90f:	e9 e9 fa ff ff       	jmp    80d3fd <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d914:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d918:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d91b:	eb 90                	jmp    80d8ad <tcp_input+0x8a1>
    accepted_inseq = tcp_receive(pcb);
  80d91d:	89 d8                	mov    %ebx,%eax
  80d91f:	e8 0d ea ff ff       	call   80c331 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d924:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d92b:	0f 84 80 fa ff ff    	je     80d3b1 <tcp_input+0x3a5>
  80d931:	84 c0                	test   %al,%al
  80d933:	0f 84 78 fa ff ff    	je     80d3b1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80d939:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d93d:	83 ec 0c             	sub    $0xc,%esp
  80d940:	53                   	push   %ebx
  80d941:	e8 d8 a6 ff ff       	call   80801e <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d946:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d94d:	83 c4 10             	add    $0x10,%esp
  80d950:	e9 5c fa ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80d955:	89 d8                	mov    %ebx,%eax
  80d957:	e8 d5 e9 ff ff       	call   80c331 <tcp_receive>
    if (flags & TCP_FIN) {
  80d95c:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d963:	a8 01                	test   $0x1,%al
  80d965:	0f 84 c7 00 00 00    	je     80da32 <tcp_input+0xa26>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80d96b:	a8 10                	test   $0x10,%al
  80d96d:	74 0a                	je     80d979 <tcp_input+0x96d>
  80d96f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d974:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d977:	74 1c                	je     80d995 <tcp_input+0x989>
        tcp_ack_now(pcb);
  80d979:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d97d:	83 ec 0c             	sub    $0xc,%esp
  80d980:	53                   	push   %ebx
  80d981:	e8 98 a6 ff ff       	call   80801e <tcp_output>
        pcb->state = CLOSING;
  80d986:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80d98d:	83 c4 10             	add    $0x10,%esp
  80d990:	e9 1c fa ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80d995:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d999:	83 ec 0c             	sub    $0xc,%esp
  80d99c:	53                   	push   %ebx
  80d99d:	e8 7c a6 ff ff       	call   80801e <tcp_output>
        tcp_pcb_purge(pcb);
  80d9a2:	89 1c 24             	mov    %ebx,(%esp)
  80d9a5:	e8 6c 7e ff ff       	call   805816 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80d9aa:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d9af:	83 c4 10             	add    $0x10,%esp
  80d9b2:	39 c3                	cmp    %eax,%ebx
  80d9b4:	74 2c                	je     80d9e2 <tcp_input+0x9d6>
  80d9b6:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80d9bb:	ba 00 00 00 00       	mov    $0x0,%edx
  80d9c0:	89 de                	mov    %ebx,%esi
  80d9c2:	89 d7                	mov    %edx,%edi
  80d9c4:	85 c0                	test   %eax,%eax
  80d9c6:	74 56                	je     80da1e <tcp_input+0xa12>
  80d9c8:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d9cb:	39 ce                	cmp    %ecx,%esi
  80d9cd:	0f 94 c3             	sete   %bl
  80d9d0:	85 c9                	test   %ecx,%ecx
  80d9d2:	0f 95 c2             	setne  %dl
  80d9d5:	84 d3                	test   %dl,%bl
  80d9d7:	75 30                	jne    80da09 <tcp_input+0x9fd>
  80d9d9:	bf 01 00 00 00       	mov    $0x1,%edi
  80d9de:	89 c8                	mov    %ecx,%eax
  80d9e0:	eb e2                	jmp    80d9c4 <tcp_input+0x9b8>
  80d9e2:	8b 40 0c             	mov    0xc(%eax),%eax
  80d9e5:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80d9ea:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80d9f1:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80d9f6:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d9f9:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80d9ff:	e8 b5 47 ff ff       	call   8021b9 <tcp_timer_needed>
  80da04:	e9 a8 f9 ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
  80da09:	89 f3                	mov    %esi,%ebx
  80da0b:	89 fa                	mov    %edi,%edx
  80da0d:	84 d2                	test   %dl,%dl
  80da0f:	74 05                	je     80da16 <tcp_input+0xa0a>
  80da11:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
        TCP_RMV(&tcp_active_pcbs, pcb);
  80da16:	8b 53 0c             	mov    0xc(%ebx),%edx
  80da19:	89 50 0c             	mov    %edx,0xc(%eax)
  80da1c:	eb cc                	jmp    80d9ea <tcp_input+0x9de>
  80da1e:	89 f3                	mov    %esi,%ebx
  80da20:	89 fa                	mov    %edi,%edx
  80da22:	84 d2                	test   %dl,%dl
  80da24:	74 c4                	je     80d9ea <tcp_input+0x9de>
  80da26:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80da2d:	00 00 00 
  80da30:	eb b8                	jmp    80d9ea <tcp_input+0x9de>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da32:	a8 10                	test   $0x10,%al
  80da34:	0f 84 77 f9 ff ff    	je     80d3b1 <tcp_input+0x3a5>
  80da3a:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da3f:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da42:	0f 85 69 f9 ff ff    	jne    80d3b1 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80da48:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80da4f:	e9 5d f9 ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80da54:	89 d8                	mov    %ebx,%eax
  80da56:	e8 d6 e8 ff ff       	call   80c331 <tcp_receive>
    if (flags & TCP_FIN) {
  80da5b:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80da62:	0f 84 49 f9 ff ff    	je     80d3b1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80da68:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da6c:	83 ec 0c             	sub    $0xc,%esp
  80da6f:	53                   	push   %ebx
  80da70:	e8 a9 a5 ff ff       	call   80801e <tcp_output>
      tcp_pcb_purge(pcb);
  80da75:	89 1c 24             	mov    %ebx,(%esp)
  80da78:	e8 99 7d ff ff       	call   805816 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80da7d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80da82:	83 c4 10             	add    $0x10,%esp
  80da85:	39 c3                	cmp    %eax,%ebx
  80da87:	74 2c                	je     80dab5 <tcp_input+0xaa9>
  80da89:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80da8e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80da93:	89 de                	mov    %ebx,%esi
  80da95:	89 cf                	mov    %ecx,%edi
  80da97:	85 c0                	test   %eax,%eax
  80da99:	74 56                	je     80daf1 <tcp_input+0xae5>
  80da9b:	8b 50 0c             	mov    0xc(%eax),%edx
  80da9e:	85 d2                	test   %edx,%edx
  80daa0:	0f 95 c3             	setne  %bl
  80daa3:	39 d6                	cmp    %edx,%esi
  80daa5:	0f 94 c1             	sete   %cl
  80daa8:	84 cb                	test   %cl,%bl
  80daaa:	75 30                	jne    80dadc <tcp_input+0xad0>
  80daac:	bf 01 00 00 00       	mov    $0x1,%edi
  80dab1:	89 d0                	mov    %edx,%eax
  80dab3:	eb e2                	jmp    80da97 <tcp_input+0xa8b>
  80dab5:	8b 40 0c             	mov    0xc(%eax),%eax
  80dab8:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dabd:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dac4:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dac9:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dacc:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dad2:	e8 e2 46 ff ff       	call   8021b9 <tcp_timer_needed>
  80dad7:	e9 d5 f8 ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
  80dadc:	89 f3                	mov    %esi,%ebx
  80dade:	89 f9                	mov    %edi,%ecx
  80dae0:	84 c9                	test   %cl,%cl
  80dae2:	74 05                	je     80dae9 <tcp_input+0xadd>
  80dae4:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dae9:	8b 53 0c             	mov    0xc(%ebx),%edx
  80daec:	89 50 0c             	mov    %edx,0xc(%eax)
  80daef:	eb cc                	jmp    80dabd <tcp_input+0xab1>
  80daf1:	89 f3                	mov    %esi,%ebx
  80daf3:	89 f9                	mov    %edi,%ecx
  80daf5:	84 c9                	test   %cl,%cl
  80daf7:	74 c4                	je     80dabd <tcp_input+0xab1>
  80daf9:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80db00:	00 00 00 
  80db03:	eb b8                	jmp    80dabd <tcp_input+0xab1>
    tcp_receive(pcb);
  80db05:	89 d8                	mov    %ebx,%eax
  80db07:	e8 25 e8 ff ff       	call   80c331 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80db0c:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80db13:	0f 84 98 f8 ff ff    	je     80d3b1 <tcp_input+0x3a5>
  80db19:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80db1e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80db21:	0f 85 8a f8 ff ff    	jne    80d3b1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80db27:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db2b:	83 ec 0c             	sub    $0xc,%esp
  80db2e:	53                   	push   %ebx
  80db2f:	e8 ea a4 ff ff       	call   80801e <tcp_output>
      tcp_pcb_purge(pcb);
  80db34:	89 1c 24             	mov    %ebx,(%esp)
  80db37:	e8 da 7c ff ff       	call   805816 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db3c:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80db41:	83 c4 10             	add    $0x10,%esp
  80db44:	39 c3                	cmp    %eax,%ebx
  80db46:	74 2c                	je     80db74 <tcp_input+0xb68>
  80db48:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80db4d:	ba 00 00 00 00       	mov    $0x0,%edx
  80db52:	89 de                	mov    %ebx,%esi
  80db54:	89 d7                	mov    %edx,%edi
  80db56:	85 c0                	test   %eax,%eax
  80db58:	74 56                	je     80dbb0 <tcp_input+0xba4>
  80db5a:	8b 48 0c             	mov    0xc(%eax),%ecx
  80db5d:	85 c9                	test   %ecx,%ecx
  80db5f:	0f 95 c3             	setne  %bl
  80db62:	39 ce                	cmp    %ecx,%esi
  80db64:	0f 94 c2             	sete   %dl
  80db67:	84 d3                	test   %dl,%bl
  80db69:	75 30                	jne    80db9b <tcp_input+0xb8f>
  80db6b:	bf 01 00 00 00       	mov    $0x1,%edi
  80db70:	89 c8                	mov    %ecx,%eax
  80db72:	eb e2                	jmp    80db56 <tcp_input+0xb4a>
  80db74:	8b 40 0c             	mov    0xc(%eax),%eax
  80db77:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80db7c:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80db83:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80db88:	89 43 0c             	mov    %eax,0xc(%ebx)
  80db8b:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80db91:	e8 23 46 ff ff       	call   8021b9 <tcp_timer_needed>
  80db96:	e9 16 f8 ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
  80db9b:	89 f3                	mov    %esi,%ebx
  80db9d:	89 fa                	mov    %edi,%edx
  80db9f:	84 d2                	test   %dl,%dl
  80dba1:	74 05                	je     80dba8 <tcp_input+0xb9c>
  80dba3:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dba8:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dbab:	89 50 0c             	mov    %edx,0xc(%eax)
  80dbae:	eb cc                	jmp    80db7c <tcp_input+0xb70>
  80dbb0:	89 f3                	mov    %esi,%ebx
  80dbb2:	89 fa                	mov    %edi,%edx
  80dbb4:	84 d2                	test   %dl,%dl
  80dbb6:	74 c4                	je     80db7c <tcp_input+0xb70>
  80dbb8:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dbbf:	00 00 00 
  80dbc2:	eb b8                	jmp    80db7c <tcp_input+0xb70>
    tcp_receive(pcb);
  80dbc4:	89 d8                	mov    %ebx,%eax
  80dbc6:	e8 66 e7 ff ff       	call   80c331 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dbcb:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dbd2:	0f 84 d9 f7 ff ff    	je     80d3b1 <tcp_input+0x3a5>
  80dbd8:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dbdd:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dbe0:	0f 85 cb f7 ff ff    	jne    80d3b1 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80dbe6:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dbed:	e9 bf f7 ff ff       	jmp    80d3b1 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80dbf2:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dbf9:	00 00 00 
  80dbfc:	e9 ba f7 ff ff       	jmp    80d3bb <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80dc01:	a8 10                	test   $0x10,%al
  80dc03:	0f 85 96 00 00 00    	jne    80dc9f <tcp_input+0xc93>
        if (pcb->acked > 0) {
  80dc09:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dc0d:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dc12:	66 85 d2             	test   %dx,%dx
  80dc15:	74 1a                	je     80dc31 <tcp_input+0xc25>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dc17:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dc1d:	85 c9                	test   %ecx,%ecx
  80dc1f:	74 10                	je     80dc31 <tcp_input+0xc25>
  80dc21:	83 ec 04             	sub    $0x4,%esp
  80dc24:	0f b7 d2             	movzwl %dx,%edx
  80dc27:	52                   	push   %edx
  80dc28:	53                   	push   %ebx
  80dc29:	ff 73 18             	pushl  0x18(%ebx)
  80dc2c:	ff d1                	call   *%ecx
  80dc2e:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dc31:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dc37:	85 d2                	test   %edx,%edx
  80dc39:	0f 84 a9 00 00 00    	je     80dce8 <tcp_input+0xcdc>
          if(flags & TCP_PSH) {
  80dc3f:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80dc46:	74 04                	je     80dc4c <tcp_input+0xc40>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dc48:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dc4c:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc52:	85 c0                	test   %eax,%eax
  80dc54:	74 6a                	je     80dcc0 <tcp_input+0xcb4>
  80dc56:	6a 00                	push   $0x0
  80dc58:	52                   	push   %edx
  80dc59:	53                   	push   %ebx
  80dc5a:	ff 73 18             	pushl  0x18(%ebx)
  80dc5d:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80dc5f:	83 c4 10             	add    $0x10,%esp
  80dc62:	84 c0                	test   %al,%al
  80dc64:	75 68                	jne    80dcce <tcp_input+0xcc2>
        if (recv_flags & TF_GOT_FIN) {
  80dc66:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dc6d:	74 1f                	je     80dc8e <tcp_input+0xc82>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dc6f:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dc75:	85 c0                	test   %eax,%eax
  80dc77:	74 15                	je     80dc8e <tcp_input+0xc82>
  80dc79:	6a 00                	push   $0x0
  80dc7b:	6a 00                	push   $0x0
  80dc7d:	53                   	push   %ebx
  80dc7e:	ff 73 18             	pushl  0x18(%ebx)
  80dc81:	ff d0                	call   *%eax
  80dc83:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80dc86:	84 c0                	test   %al,%al
  80dc88:	0f 85 6f f7 ff ff    	jne    80d3fd <tcp_input+0x3f1>
          tcp_output(pcb);
  80dc8e:	83 ec 0c             	sub    $0xc,%esp
  80dc91:	53                   	push   %ebx
  80dc92:	e8 87 a3 ff ff       	call   80801e <tcp_output>
  80dc97:	83 c4 10             	add    $0x10,%esp
  80dc9a:	e9 5e f7 ff ff       	jmp    80d3fd <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dc9f:	83 ec 08             	sub    $0x8,%esp
  80dca2:	53                   	push   %ebx
  80dca3:	68 3c b2 b3 00       	push   $0xb3b23c
  80dca8:	e8 e6 7b ff ff       	call   805893 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dcad:	83 c4 08             	add    $0x8,%esp
  80dcb0:	53                   	push   %ebx
  80dcb1:	6a 02                	push   $0x2
  80dcb3:	e8 de 67 ff ff       	call   804496 <memp_free>
  80dcb8:	83 c4 10             	add    $0x10,%esp
  80dcbb:	e9 3d f7 ff ff       	jmp    80d3fd <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dcc0:	83 ec 0c             	sub    $0xc,%esp
  80dcc3:	52                   	push   %edx
  80dcc4:	e8 1a 6b ff ff       	call   8047e3 <pbuf_free>
  80dcc9:	83 c4 10             	add    $0x10,%esp
  80dccc:	eb 98                	jmp    80dc66 <tcp_input+0xc5a>
            pcb->refused_data = recv_data;
  80dcce:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80dcd3:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dcd9:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dce0:	0f 84 17 f7 ff ff    	je     80d3fd <tcp_input+0x3f1>
  80dce6:	eb 87                	jmp    80dc6f <tcp_input+0xc63>
  80dce8:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dcef:	74 95                	je     80dc86 <tcp_input+0xc7a>
  80dcf1:	e9 79 ff ff ff       	jmp    80dc6f <tcp_input+0xc63>
        tcphdr->dest, tcphdr->src);
  80dcf6:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80dcfc:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80dd01:	83 ec 08             	sub    $0x8,%esp
  80dd04:	0f b7 0a             	movzwl (%edx),%ecx
  80dd07:	51                   	push   %ecx
  80dd08:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80dd0c:	52                   	push   %edx
  80dd0d:	8d 50 0c             	lea    0xc(%eax),%edx
  80dd10:	52                   	push   %edx
  80dd11:	83 c0 10             	add    $0x10,%eax
  80dd14:	50                   	push   %eax
  80dd15:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80dd1c:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80dd22:	50                   	push   %eax
  80dd23:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80dd29:	e8 90 a7 ff ff       	call   8084be <tcp_rst>
  80dd2e:	83 c4 20             	add    $0x20,%esp
  80dd31:	eb 14                	jmp    80dd47 <tcp_input+0xd3b>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80dd33:	83 ec 0c             	sub    $0xc,%esp
  80dd36:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80dd3a:	50                   	push   %eax
  80dd3b:	e8 8a 99 ff ff       	call   8076ca <ntohs>
  80dd40:	83 c4 10             	add    $0x10,%esp
  80dd43:	a8 04                	test   $0x4,%al
  80dd45:	74 af                	je     80dcf6 <tcp_input+0xcea>
    pbuf_free(p);
  80dd47:	83 ec 0c             	sub    $0xc,%esp
  80dd4a:	56                   	push   %esi
  80dd4b:	e8 93 6a ff ff       	call   8047e3 <pbuf_free>
  80dd50:	83 c4 10             	add    $0x10,%esp
  80dd53:	e9 1f f3 ff ff       	jmp    80d077 <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd58:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80dd5e:	e9 ee f6 ff ff       	jmp    80d451 <tcp_input+0x445>

0080dd63 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80dd63:	55                   	push   %ebp
  80dd64:	89 e5                	mov    %esp,%ebp
  80dd66:	57                   	push   %edi
  80dd67:	56                   	push   %esi
  80dd68:	53                   	push   %ebx
  80dd69:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80dd6c:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd6f:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80dd72:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80dd76:	50                   	push   %eax
  80dd77:	e8 4e 99 ff ff       	call   8076ca <ntohs>
  80dd7c:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80dd7e:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80dd84:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80dd87:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80dd8c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80dd93:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80dd96:	eb 11                	jmp    80dda9 <raw_input+0x46>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dd98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dd9b:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80dd9e:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dda3:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dda6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80dda9:	84 c0                	test   %al,%al
  80ddab:	75 55                	jne    80de02 <raw_input+0x9f>
  80ddad:	85 db                	test   %ebx,%ebx
  80ddaf:	74 51                	je     80de02 <raw_input+0x9f>
    if (pcb->protocol == proto) {
  80ddb1:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80ddb5:	b8 00 00 00 00       	mov    $0x0,%eax
  80ddba:	39 f2                	cmp    %esi,%edx
  80ddbc:	75 e5                	jne    80dda3 <raw_input+0x40>
      if (pcb->recv != NULL) {
  80ddbe:	8b 53 14             	mov    0x14(%ebx),%edx
  80ddc1:	85 d2                	test   %edx,%edx
  80ddc3:	74 de                	je     80dda3 <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80ddc5:	8d 47 0c             	lea    0xc(%edi),%eax
  80ddc8:	50                   	push   %eax
  80ddc9:	ff 75 08             	pushl  0x8(%ebp)
  80ddcc:	53                   	push   %ebx
  80ddcd:	ff 73 18             	pushl  0x18(%ebx)
  80ddd0:	ff d2                	call   *%edx
  80ddd2:	83 c4 10             	add    $0x10,%esp
  80ddd5:	84 c0                	test   %al,%al
  80ddd7:	74 ca                	je     80dda3 <raw_input+0x40>
          if (prev != NULL) {
  80ddd9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80dddc:	85 c9                	test   %ecx,%ecx
  80ddde:	74 b8                	je     80dd98 <raw_input+0x35>
            prev->next = pcb->next;
  80dde0:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dde3:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80dde6:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80ddeb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80ddee:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80ddf4:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80ddf9:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80de00:	eb a1                	jmp    80dda3 <raw_input+0x40>
  }
  return eaten;
}
  80de02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80de05:	5b                   	pop    %ebx
  80de06:	5e                   	pop    %esi
  80de07:	5f                   	pop    %edi
  80de08:	5d                   	pop    %ebp
  80de09:	c3                   	ret    

0080de0a <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80de0a:	55                   	push   %ebp
  80de0b:	89 e5                	mov    %esp,%ebp
  80de0d:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80de10:	b8 00 00 00 00       	mov    $0x0,%eax
  80de15:	85 d2                	test   %edx,%edx
  80de17:	74 02                	je     80de1b <raw_bind+0x11>
  80de19:	8b 02                	mov    (%edx),%eax
  80de1b:	8b 55 08             	mov    0x8(%ebp),%edx
  80de1e:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80de20:	b8 00 00 00 00       	mov    $0x0,%eax
  80de25:	5d                   	pop    %ebp
  80de26:	c3                   	ret    

0080de27 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80de27:	55                   	push   %ebp
  80de28:	89 e5                	mov    %esp,%ebp
  80de2a:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80de2d:	b8 00 00 00 00       	mov    $0x0,%eax
  80de32:	85 d2                	test   %edx,%edx
  80de34:	74 02                	je     80de38 <raw_connect+0x11>
  80de36:	8b 02                	mov    (%edx),%eax
  80de38:	8b 55 08             	mov    0x8(%ebp),%edx
  80de3b:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80de3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80de43:	5d                   	pop    %ebp
  80de44:	c3                   	ret    

0080de45 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80de45:	55                   	push   %ebp
  80de46:	89 e5                	mov    %esp,%ebp
  80de48:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80de4b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80de4e:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80de51:	8b 55 10             	mov    0x10(%ebp),%edx
  80de54:	89 50 18             	mov    %edx,0x18(%eax)
}
  80de57:	5d                   	pop    %ebp
  80de58:	c3                   	ret    

0080de59 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80de59:	55                   	push   %ebp
  80de5a:	89 e5                	mov    %esp,%ebp
  80de5c:	57                   	push   %edi
  80de5d:	56                   	push   %esi
  80de5e:	53                   	push   %ebx
  80de5f:	83 ec 14             	sub    $0x14,%esp
  80de62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80de65:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80de68:	6a 14                	push   $0x14
  80de6a:	57                   	push   %edi
  80de6b:	e8 a6 68 ff ff       	call   804716 <pbuf_header>
  80de70:	83 c4 10             	add    $0x10,%esp
  80de73:	84 c0                	test   %al,%al
  80de75:	74 52                	je     80dec9 <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80de77:	83 ec 04             	sub    $0x4,%esp
  80de7a:	6a 00                	push   $0x0
  80de7c:	6a 00                	push   $0x0
  80de7e:	6a 01                	push   $0x1
  80de80:	e8 24 6a ff ff       	call   8048a9 <pbuf_alloc>
  80de85:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80de87:	83 c4 10             	add    $0x10,%esp
  80de8a:	85 c0                	test   %eax,%eax
  80de8c:	0f 84 be 00 00 00    	je     80df50 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80de92:	83 ec 08             	sub    $0x8,%esp
  80de95:	57                   	push   %edi
  80de96:	50                   	push   %eax
  80de97:	e8 28 6e ff ff       	call   804cc4 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80de9c:	83 c4 04             	add    $0x4,%esp
  80de9f:	ff 75 10             	pushl  0x10(%ebp)
  80dea2:	e8 f6 85 ff ff       	call   80649d <ip_route>
  80dea7:	83 c4 10             	add    $0x10,%esp
  80deaa:	85 c0                	test   %eax,%eax
  80deac:	75 41                	jne    80deef <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80deae:	39 f7                	cmp    %esi,%edi
  80deb0:	0f 84 a1 00 00 00    	je     80df57 <raw_sendto+0xfe>
      pbuf_free(q);
  80deb6:	83 ec 0c             	sub    $0xc,%esp
  80deb9:	56                   	push   %esi
  80deba:	e8 24 69 ff ff       	call   8047e3 <pbuf_free>
  80debf:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80dec2:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80dec7:	eb 66                	jmp    80df2f <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80dec9:	83 ec 08             	sub    $0x8,%esp
  80decc:	6a ec                	push   $0xffffffec
  80dece:	57                   	push   %edi
  80decf:	e8 42 68 ff ff       	call   804716 <pbuf_header>
  80ded4:	83 c4 10             	add    $0x10,%esp
  80ded7:	84 c0                	test   %al,%al
  80ded9:	75 5e                	jne    80df39 <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80dedb:	83 ec 0c             	sub    $0xc,%esp
  80dede:	ff 75 10             	pushl  0x10(%ebp)
  80dee1:	e8 b7 85 ff ff       	call   80649d <ip_route>
  80dee6:	83 c4 10             	add    $0x10,%esp
  80dee9:	85 c0                	test   %eax,%eax
  80deeb:	74 71                	je     80df5e <raw_sendto+0x105>
    q = p;
  80deed:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80deef:	89 da                	mov    %ebx,%edx
  80def1:	85 db                	test   %ebx,%ebx
  80def3:	74 05                	je     80defa <raw_sendto+0xa1>
  80def5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80def8:	75 03                	jne    80defd <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80defa:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80defd:	83 ec 04             	sub    $0x4,%esp
  80df00:	50                   	push   %eax
  80df01:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80df05:	50                   	push   %eax
  80df06:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80df0a:	50                   	push   %eax
  80df0b:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80df0f:	50                   	push   %eax
  80df10:	ff 75 10             	pushl  0x10(%ebp)
  80df13:	52                   	push   %edx
  80df14:	56                   	push   %esi
  80df15:	e8 06 89 ff ff       	call   806820 <ip_output_if>
  80df1a:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80df1c:	83 c4 20             	add    $0x20,%esp
  80df1f:	39 f7                	cmp    %esi,%edi
  80df21:	74 0c                	je     80df2f <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80df23:	83 ec 0c             	sub    $0xc,%esp
  80df26:	56                   	push   %esi
  80df27:	e8 b7 68 ff ff       	call   8047e3 <pbuf_free>
  80df2c:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80df2f:	89 d8                	mov    %ebx,%eax
  80df31:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80df34:	5b                   	pop    %ebx
  80df35:	5e                   	pop    %esi
  80df36:	5f                   	pop    %edi
  80df37:	5d                   	pop    %ebp
  80df38:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80df39:	83 ec 04             	sub    $0x4,%esp
  80df3c:	68 20 36 81 00       	push   $0x813620
  80df41:	68 e3 00 00 00       	push   $0xe3
  80df46:	68 46 36 81 00       	push   $0x813646
  80df4b:	e8 58 06 00 00       	call   80e5a8 <_panic>
      return ERR_MEM;
  80df50:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80df55:	eb d8                	jmp    80df2f <raw_sendto+0xd6>
    return ERR_RTE;
  80df57:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80df5c:	eb d1                	jmp    80df2f <raw_sendto+0xd6>
  80df5e:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80df63:	eb ca                	jmp    80df2f <raw_sendto+0xd6>

0080df65 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80df65:	55                   	push   %ebp
  80df66:	89 e5                	mov    %esp,%ebp
  80df68:	83 ec 0c             	sub    $0xc,%esp
  80df6b:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80df6e:	8d 50 04             	lea    0x4(%eax),%edx
  80df71:	52                   	push   %edx
  80df72:	ff 75 0c             	pushl  0xc(%ebp)
  80df75:	50                   	push   %eax
  80df76:	e8 de fe ff ff       	call   80de59 <raw_sendto>
}
  80df7b:	c9                   	leave  
  80df7c:	c3                   	ret    

0080df7d <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80df7d:	55                   	push   %ebp
  80df7e:	89 e5                	mov    %esp,%ebp
  80df80:	83 ec 08             	sub    $0x8,%esp
  80df83:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80df86:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80df8b:	39 c8                	cmp    %ecx,%eax
  80df8d:	75 1b                	jne    80dfaa <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80df8f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80df92:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80df97:	83 ec 08             	sub    $0x8,%esp
  80df9a:	51                   	push   %ecx
  80df9b:	6a 00                	push   $0x0
  80df9d:	e8 f4 64 ff ff       	call   804496 <memp_free>
}
  80dfa2:	83 c4 10             	add    $0x10,%esp
  80dfa5:	c9                   	leave  
  80dfa6:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80dfa7:	8b 40 0c             	mov    0xc(%eax),%eax
  80dfaa:	85 c0                	test   %eax,%eax
  80dfac:	74 e9                	je     80df97 <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80dfae:	8b 50 0c             	mov    0xc(%eax),%edx
  80dfb1:	39 ca                	cmp    %ecx,%edx
  80dfb3:	75 f2                	jne    80dfa7 <raw_remove+0x2a>
  80dfb5:	85 d2                	test   %edx,%edx
  80dfb7:	74 ee                	je     80dfa7 <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80dfb9:	8b 51 0c             	mov    0xc(%ecx),%edx
  80dfbc:	89 50 0c             	mov    %edx,0xc(%eax)
  80dfbf:	eb e6                	jmp    80dfa7 <raw_remove+0x2a>

0080dfc1 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80dfc1:	55                   	push   %ebp
  80dfc2:	89 e5                	mov    %esp,%ebp
  80dfc4:	56                   	push   %esi
  80dfc5:	53                   	push   %ebx
  80dfc6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80dfc9:	83 ec 0c             	sub    $0xc,%esp
  80dfcc:	6a 00                	push   $0x0
  80dfce:	e8 6d 64 ff ff       	call   804440 <memp_malloc>
  80dfd3:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80dfd5:	83 c4 10             	add    $0x10,%esp
  80dfd8:	85 c0                	test   %eax,%eax
  80dfda:	74 27                	je     80e003 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80dfdc:	83 ec 04             	sub    $0x4,%esp
  80dfdf:	6a 1c                	push   $0x1c
  80dfe1:	6a 00                	push   $0x0
  80dfe3:	50                   	push   %eax
  80dfe4:	e8 5a 0f 00 00       	call   80ef43 <memset>
    pcb->protocol = proto;
  80dfe9:	89 f0                	mov    %esi,%eax
  80dfeb:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80dfee:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80dff2:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80dff7:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80dffa:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e000:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e003:	89 d8                	mov    %ebx,%eax
  80e005:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e008:	5b                   	pop    %ebx
  80e009:	5e                   	pop    %esi
  80e00a:	5d                   	pop    %ebp
  80e00b:	c3                   	ret    

0080e00c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e00c:	55                   	push   %ebp
  80e00d:	89 e5                	mov    %esp,%ebp
  80e00f:	57                   	push   %edi
  80e010:	56                   	push   %esi
  80e011:	53                   	push   %ebx
  80e012:	83 ec 28             	sub    $0x28,%esp
  80e015:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e018:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e01b:	0f b7 07             	movzwl (%edi),%eax
  80e01e:	50                   	push   %eax
  80e01f:	e8 a6 96 ff ff       	call   8076ca <ntohs>
  80e024:	66 c1 e8 06          	shr    $0x6,%ax
  80e028:	83 e0 3c             	and    $0x3c,%eax
  80e02b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e02f:	89 c6                	mov    %eax,%esi
  80e031:	f7 de                	neg    %esi
  80e033:	0f bf f6             	movswl %si,%esi
  80e036:	83 c4 08             	add    $0x8,%esp
  80e039:	56                   	push   %esi
  80e03a:	53                   	push   %ebx
  80e03b:	e8 d6 66 ff ff       	call   804716 <pbuf_header>
  80e040:	83 c4 10             	add    $0x10,%esp
  80e043:	84 c0                	test   %al,%al
  80e045:	75 67                	jne    80e0ae <icmp_input+0xa2>
  80e047:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e04c:	76 60                	jbe    80e0ae <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e04e:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e051:	80 38 08             	cmpb   $0x8,(%eax)
  80e054:	74 0e                	je     80e064 <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e056:	83 ec 0c             	sub    $0xc,%esp
  80e059:	53                   	push   %ebx
  80e05a:	e8 84 67 ff ff       	call   8047e3 <pbuf_free>
  return;
  80e05f:	83 c4 10             	add    $0x10,%esp
  80e062:	eb 56                	jmp    80e0ba <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e064:	83 ec 08             	sub    $0x8,%esp
  80e067:	ff 75 0c             	pushl  0xc(%ebp)
  80e06a:	8d 47 10             	lea    0x10(%edi),%eax
  80e06d:	50                   	push   %eax
  80e06e:	e8 e7 83 ff ff       	call   80645a <ip_addr_isbroadcast>
  80e073:	83 c4 10             	add    $0x10,%esp
  80e076:	84 c0                	test   %al,%al
  80e078:	75 48                	jne    80e0c2 <icmp_input+0xb6>
  80e07a:	8b 47 10             	mov    0x10(%edi),%eax
  80e07d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e080:	83 ec 0c             	sub    $0xc,%esp
  80e083:	68 00 00 00 f0       	push   $0xf0000000
  80e088:	e8 61 98 ff ff       	call   8078ee <ntohl>
  80e08d:	23 45 e0             	and    -0x20(%ebp),%eax
  80e090:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e093:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e09a:	e8 4f 98 ff ff       	call   8078ee <ntohl>
  80e09f:	83 c4 10             	add    $0x10,%esp
  80e0a2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e0a5:	74 1b                	je     80e0c2 <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e0a7:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e0ac:	77 22                	ja     80e0d0 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e0ae:	83 ec 0c             	sub    $0xc,%esp
  80e0b1:	53                   	push   %ebx
  80e0b2:	e8 2c 67 ff ff       	call   8047e3 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e0b7:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e0ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e0bd:	5b                   	pop    %ebx
  80e0be:	5e                   	pop    %esi
  80e0bf:	5f                   	pop    %edi
  80e0c0:	5d                   	pop    %ebp
  80e0c1:	c3                   	ret    
      pbuf_free(p);
  80e0c2:	83 ec 0c             	sub    $0xc,%esp
  80e0c5:	53                   	push   %ebx
  80e0c6:	e8 18 67 ff ff       	call   8047e3 <pbuf_free>
      return;
  80e0cb:	83 c4 10             	add    $0x10,%esp
  80e0ce:	eb ea                	jmp    80e0ba <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e0d0:	83 ec 0c             	sub    $0xc,%esp
  80e0d3:	53                   	push   %ebx
  80e0d4:	e8 cc 94 ff ff       	call   8075a5 <inet_chksum_pbuf>
  80e0d9:	83 c4 10             	add    $0x10,%esp
  80e0dc:	66 85 c0             	test   %ax,%ax
  80e0df:	0f 85 96 00 00 00    	jne    80e17b <icmp_input+0x16f>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e0e5:	83 ec 08             	sub    $0x8,%esp
  80e0e8:	6a 22                	push   $0x22
  80e0ea:	53                   	push   %ebx
  80e0eb:	e8 26 66 ff ff       	call   804716 <pbuf_header>
  80e0f0:	83 c4 10             	add    $0x10,%esp
  80e0f3:	84 c0                	test   %al,%al
  80e0f5:	0f 84 fb 00 00 00    	je     80e1f6 <icmp_input+0x1ea>
      if (pbuf_header(p, hlen)) {
  80e0fb:	83 ec 08             	sub    $0x8,%esp
  80e0fe:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e102:	50                   	push   %eax
  80e103:	53                   	push   %ebx
  80e104:	e8 0d 66 ff ff       	call   804716 <pbuf_header>
  80e109:	83 c4 10             	add    $0x10,%esp
  80e10c:	84 c0                	test   %al,%al
  80e10e:	75 7c                	jne    80e18c <icmp_input+0x180>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e110:	83 ec 04             	sub    $0x4,%esp
  80e113:	6a 00                	push   $0x0
  80e115:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e119:	50                   	push   %eax
  80e11a:	6a 02                	push   $0x2
  80e11c:	e8 88 67 ff ff       	call   8048a9 <pbuf_alloc>
  80e121:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e124:	83 c4 10             	add    $0x10,%esp
  80e127:	85 c0                	test   %eax,%eax
  80e129:	74 75                	je     80e1a0 <icmp_input+0x194>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e12b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e12e:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e132:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e136:	83 c0 08             	add    $0x8,%eax
  80e139:	39 c2                	cmp    %eax,%edx
  80e13b:	72 74                	jb     80e1b1 <icmp_input+0x1a5>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e13d:	83 ec 08             	sub    $0x8,%esp
  80e140:	53                   	push   %ebx
  80e141:	ff 75 e0             	pushl  -0x20(%ebp)
  80e144:	e8 42 6c ff ff       	call   804d8b <pbuf_copy>
  80e149:	83 c4 10             	add    $0x10,%esp
  80e14c:	84 c0                	test   %al,%al
  80e14e:	75 78                	jne    80e1c8 <icmp_input+0x1bc>
      iphdr = r->payload;
  80e150:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e153:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e156:	83 ec 08             	sub    $0x8,%esp
  80e159:	56                   	push   %esi
  80e15a:	50                   	push   %eax
  80e15b:	e8 b6 65 ff ff       	call   804716 <pbuf_header>
  80e160:	83 c4 10             	add    $0x10,%esp
  80e163:	84 c0                	test   %al,%al
  80e165:	75 78                	jne    80e1df <icmp_input+0x1d3>
      pbuf_free(p);
  80e167:	83 ec 0c             	sub    $0xc,%esp
  80e16a:	53                   	push   %ebx
  80e16b:	e8 73 66 ff ff       	call   8047e3 <pbuf_free>
  80e170:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e173:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e176:	e9 91 00 00 00       	jmp    80e20c <icmp_input+0x200>
      pbuf_free(p);
  80e17b:	83 ec 0c             	sub    $0xc,%esp
  80e17e:	53                   	push   %ebx
  80e17f:	e8 5f 66 ff ff       	call   8047e3 <pbuf_free>
      return;
  80e184:	83 c4 10             	add    $0x10,%esp
  80e187:	e9 2e ff ff ff       	jmp    80e0ba <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e18c:	83 ec 04             	sub    $0x4,%esp
  80e18f:	68 5c 36 81 00       	push   $0x81365c
  80e194:	6a 7b                	push   $0x7b
  80e196:	68 50 37 81 00       	push   $0x813750
  80e19b:	e8 08 04 00 00       	call   80e5a8 <_panic>
  pbuf_free(p);
  80e1a0:	83 ec 0c             	sub    $0xc,%esp
  80e1a3:	53                   	push   %ebx
  80e1a4:	e8 3a 66 ff ff       	call   8047e3 <pbuf_free>
  return;
  80e1a9:	83 c4 10             	add    $0x10,%esp
  80e1ac:	e9 09 ff ff ff       	jmp    80e0ba <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e1b1:	83 ec 04             	sub    $0x4,%esp
  80e1b4:	68 90 36 81 00       	push   $0x813690
  80e1b9:	68 85 00 00 00       	push   $0x85
  80e1be:	68 50 37 81 00       	push   $0x813750
  80e1c3:	e8 e0 03 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e1c8:	83 ec 04             	sub    $0x4,%esp
  80e1cb:	68 c8 36 81 00       	push   $0x8136c8
  80e1d0:	68 88 00 00 00       	push   $0x88
  80e1d5:	68 50 37 81 00       	push   $0x813750
  80e1da:	e8 c9 03 00 00       	call   80e5a8 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e1df:	83 ec 04             	sub    $0x4,%esp
  80e1e2:	68 f0 36 81 00       	push   $0x8136f0
  80e1e7:	68 8e 00 00 00       	push   $0x8e
  80e1ec:	68 50 37 81 00       	push   $0x813750
  80e1f1:	e8 b2 03 00 00       	call   80e5a8 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e1f6:	83 ec 08             	sub    $0x8,%esp
  80e1f9:	6a de                	push   $0xffffffde
  80e1fb:	53                   	push   %ebx
  80e1fc:	e8 15 65 ff ff       	call   804716 <pbuf_header>
  80e201:	83 c4 10             	add    $0x10,%esp
  80e204:	84 c0                	test   %al,%al
  80e206:	0f 85 d3 00 00 00    	jne    80e2df <icmp_input+0x2d3>
    iecho = p->payload;
  80e20c:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e20f:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e212:	8b 57 10             	mov    0x10(%edi),%edx
  80e215:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e218:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e21b:	83 ec 0c             	sub    $0xc,%esp
  80e21e:	0f b7 06             	movzwl (%esi),%eax
  80e221:	50                   	push   %eax
  80e222:	e8 a3 94 ff ff       	call   8076ca <ntohs>
  80e227:	0f b6 c0             	movzbl %al,%eax
  80e22a:	89 04 24             	mov    %eax,(%esp)
  80e22d:	e8 8b 94 ff ff       	call   8076bd <htons>
  80e232:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e235:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e239:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e23d:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e244:	e8 74 94 ff ff       	call   8076bd <htons>
  80e249:	83 c4 10             	add    $0x10,%esp
  80e24c:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e250:	0f 82 a0 00 00 00    	jb     80e2f6 <icmp_input+0x2ea>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e256:	83 ec 0c             	sub    $0xc,%esp
  80e259:	68 00 08 00 00       	push   $0x800
  80e25e:	e8 5a 94 ff ff       	call   8076bd <htons>
  80e263:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e267:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e26b:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e26f:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e272:	83 ec 0c             	sub    $0xc,%esp
  80e275:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e279:	50                   	push   %eax
  80e27a:	e8 4b 94 ff ff       	call   8076ca <ntohs>
  80e27f:	66 0d 00 ff          	or     $0xff00,%ax
  80e283:	0f b7 c0             	movzwl %ax,%eax
  80e286:	89 04 24             	mov    %eax,(%esp)
  80e289:	e8 2f 94 ff ff       	call   8076bd <htons>
  80e28e:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e292:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e298:	83 c4 08             	add    $0x8,%esp
  80e29b:	6a 14                	push   $0x14
  80e29d:	57                   	push   %edi
  80e29e:	e8 ec 92 ff ff       	call   80758f <inet_chksum>
  80e2a3:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e2a7:	83 c4 08             	add    $0x8,%esp
  80e2aa:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e2ae:	50                   	push   %eax
  80e2af:	53                   	push   %ebx
  80e2b0:	e8 61 64 ff ff       	call   804716 <pbuf_header>
  80e2b5:	83 c4 10             	add    $0x10,%esp
  80e2b8:	84 c0                	test   %al,%al
  80e2ba:	75 53                	jne    80e30f <icmp_input+0x303>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e2bc:	83 ec 04             	sub    $0x4,%esp
  80e2bf:	ff 75 0c             	pushl  0xc(%ebp)
  80e2c2:	6a 01                	push   $0x1
  80e2c4:	6a 00                	push   $0x0
  80e2c6:	68 ff 00 00 00       	push   $0xff
  80e2cb:	6a 00                	push   $0x0
  80e2cd:	83 c7 0c             	add    $0xc,%edi
  80e2d0:	57                   	push   %edi
  80e2d1:	53                   	push   %ebx
  80e2d2:	e8 49 85 ff ff       	call   806820 <ip_output_if>
  80e2d7:	83 c4 20             	add    $0x20,%esp
  80e2da:	e9 77 fd ff ff       	jmp    80e056 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e2df:	83 ec 04             	sub    $0x4,%esp
  80e2e2:	68 f0 36 81 00       	push   $0x8136f0
  80e2e7:	68 98 00 00 00       	push   $0x98
  80e2ec:	68 50 37 81 00       	push   $0x813750
  80e2f1:	e8 b2 02 00 00       	call   80e5a8 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e2f6:	83 ec 0c             	sub    $0xc,%esp
  80e2f9:	68 00 08 00 00       	push   $0x800
  80e2fe:	e8 ba 93 ff ff       	call   8076bd <htons>
  80e303:	66 01 46 02          	add    %ax,0x2(%esi)
  80e307:	83 c4 10             	add    $0x10,%esp
  80e30a:	e9 63 ff ff ff       	jmp    80e272 <icmp_input+0x266>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e30f:	83 ec 04             	sub    $0x4,%esp
  80e312:	68 b8 27 81 00       	push   $0x8127b8
  80e317:	68 b9 00 00 00       	push   $0xb9
  80e31c:	68 50 37 81 00       	push   $0x813750
  80e321:	e8 82 02 00 00       	call   80e5a8 <_panic>

0080e326 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e326:	55                   	push   %ebp
  80e327:	89 e5                	mov    %esp,%ebp
  80e329:	57                   	push   %edi
  80e32a:	56                   	push   %esi
  80e32b:	53                   	push   %ebx
  80e32c:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e32f:	6a 00                	push   $0x0
  80e331:	6a 24                	push   $0x24
  80e333:	6a 01                	push   $0x1
  80e335:	e8 6f 65 ff ff       	call   8048a9 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e33a:	83 c4 10             	add    $0x10,%esp
  80e33d:	85 c0                	test   %eax,%eax
  80e33f:	0f 84 a5 00 00 00    	je     80e3ea <icmp_dest_unreach+0xc4>
  80e345:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e347:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e34c:	0f 86 a0 00 00 00    	jbe    80e3f2 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e352:	8b 45 08             	mov    0x8(%ebp),%eax
  80e355:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e358:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e35b:	83 ec 0c             	sub    $0xc,%esp
  80e35e:	0f b7 06             	movzwl (%esi),%eax
  80e361:	50                   	push   %eax
  80e362:	e8 63 93 ff ff       	call   8076ca <ntohs>
  80e367:	0f b6 c0             	movzbl %al,%eax
  80e36a:	80 cc 03             	or     $0x3,%ah
  80e36d:	89 04 24             	mov    %eax,(%esp)
  80e370:	e8 48 93 ff ff       	call   8076bd <htons>
  80e375:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e378:	0f b7 c0             	movzwl %ax,%eax
  80e37b:	89 04 24             	mov    %eax,(%esp)
  80e37e:	e8 47 93 ff ff       	call   8076ca <ntohs>
  80e383:	b0 00                	mov    $0x0,%al
  80e385:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e389:	0f b7 c0             	movzwl %ax,%eax
  80e38c:	89 04 24             	mov    %eax,(%esp)
  80e38f:	e8 29 93 ff ff       	call   8076bd <htons>
  80e394:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e397:	83 c4 0c             	add    $0xc,%esp
  80e39a:	6a 1c                	push   $0x1c
  80e39c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e39f:	ff 70 04             	pushl  0x4(%eax)
  80e3a2:	8b 43 04             	mov    0x4(%ebx),%eax
  80e3a5:	83 c0 08             	add    $0x8,%eax
  80e3a8:	50                   	push   %eax
  80e3a9:	e8 3f 0c 00 00       	call   80efed <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e3ae:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e3b4:	83 c4 08             	add    $0x8,%esp
  80e3b7:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e3bb:	50                   	push   %eax
  80e3bc:	56                   	push   %esi
  80e3bd:	e8 cd 91 ff ff       	call   80758f <inet_chksum>
  80e3c2:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e3c6:	83 c4 08             	add    $0x8,%esp
  80e3c9:	6a 01                	push   $0x1
  80e3cb:	6a 00                	push   $0x0
  80e3cd:	68 ff 00 00 00       	push   $0xff
  80e3d2:	83 c7 0c             	add    $0xc,%edi
  80e3d5:	57                   	push   %edi
  80e3d6:	6a 00                	push   $0x0
  80e3d8:	53                   	push   %ebx
  80e3d9:	e8 cf 85 ff ff       	call   8069ad <ip_output>
  pbuf_free(q);
  80e3de:	83 c4 14             	add    $0x14,%esp
  80e3e1:	53                   	push   %ebx
  80e3e2:	e8 fc 63 ff ff       	call   8047e3 <pbuf_free>
  80e3e7:	83 c4 10             	add    $0x10,%esp
}
  80e3ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e3ed:	5b                   	pop    %ebx
  80e3ee:	5e                   	pop    %esi
  80e3ef:	5f                   	pop    %edi
  80e3f0:	5d                   	pop    %ebp
  80e3f1:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e3f2:	83 ec 04             	sub    $0x4,%esp
  80e3f5:	68 24 37 81 00       	push   $0x813724
  80e3fa:	68 ef 00 00 00       	push   $0xef
  80e3ff:	68 50 37 81 00       	push   $0x813750
  80e404:	e8 9f 01 00 00       	call   80e5a8 <_panic>

0080e409 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e409:	55                   	push   %ebp
  80e40a:	89 e5                	mov    %esp,%ebp
  80e40c:	57                   	push   %edi
  80e40d:	56                   	push   %esi
  80e40e:	53                   	push   %ebx
  80e40f:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e412:	6a 00                	push   $0x0
  80e414:	6a 24                	push   $0x24
  80e416:	6a 01                	push   $0x1
  80e418:	e8 8c 64 ff ff       	call   8048a9 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e41d:	83 c4 10             	add    $0x10,%esp
  80e420:	85 c0                	test   %eax,%eax
  80e422:	0f 84 a5 00 00 00    	je     80e4cd <icmp_time_exceeded+0xc4>
  80e428:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e42a:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e42f:	0f 86 a0 00 00 00    	jbe    80e4d5 <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e435:	8b 45 08             	mov    0x8(%ebp),%eax
  80e438:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e43b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e43e:	83 ec 0c             	sub    $0xc,%esp
  80e441:	0f b7 06             	movzwl (%esi),%eax
  80e444:	50                   	push   %eax
  80e445:	e8 80 92 ff ff       	call   8076ca <ntohs>
  80e44a:	0f b6 c0             	movzbl %al,%eax
  80e44d:	80 cc 0b             	or     $0xb,%ah
  80e450:	89 04 24             	mov    %eax,(%esp)
  80e453:	e8 65 92 ff ff       	call   8076bd <htons>
  80e458:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e45b:	0f b7 c0             	movzwl %ax,%eax
  80e45e:	89 04 24             	mov    %eax,(%esp)
  80e461:	e8 64 92 ff ff       	call   8076ca <ntohs>
  80e466:	b0 00                	mov    $0x0,%al
  80e468:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e46c:	0f b7 c0             	movzwl %ax,%eax
  80e46f:	89 04 24             	mov    %eax,(%esp)
  80e472:	e8 46 92 ff ff       	call   8076bd <htons>
  80e477:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e47a:	83 c4 0c             	add    $0xc,%esp
  80e47d:	6a 1c                	push   $0x1c
  80e47f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e482:	ff 70 04             	pushl  0x4(%eax)
  80e485:	8b 43 04             	mov    0x4(%ebx),%eax
  80e488:	83 c0 08             	add    $0x8,%eax
  80e48b:	50                   	push   %eax
  80e48c:	e8 5c 0b 00 00       	call   80efed <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e491:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e497:	83 c4 08             	add    $0x8,%esp
  80e49a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e49e:	50                   	push   %eax
  80e49f:	56                   	push   %esi
  80e4a0:	e8 ea 90 ff ff       	call   80758f <inet_chksum>
  80e4a5:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e4a9:	83 c4 08             	add    $0x8,%esp
  80e4ac:	6a 01                	push   $0x1
  80e4ae:	6a 00                	push   $0x0
  80e4b0:	68 ff 00 00 00       	push   $0xff
  80e4b5:	83 c7 0c             	add    $0xc,%edi
  80e4b8:	57                   	push   %edi
  80e4b9:	6a 00                	push   $0x0
  80e4bb:	53                   	push   %ebx
  80e4bc:	e8 ec 84 ff ff       	call   8069ad <ip_output>
  pbuf_free(q);
  80e4c1:	83 c4 14             	add    $0x14,%esp
  80e4c4:	53                   	push   %ebx
  80e4c5:	e8 19 63 ff ff       	call   8047e3 <pbuf_free>
  80e4ca:	83 c4 10             	add    $0x10,%esp
}
  80e4cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e4d0:	5b                   	pop    %ebx
  80e4d1:	5e                   	pop    %esi
  80e4d2:	5f                   	pop    %edi
  80e4d3:	5d                   	pop    %ebp
  80e4d4:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e4d5:	83 ec 04             	sub    $0x4,%esp
  80e4d8:	68 24 37 81 00       	push   $0x813724
  80e4dd:	68 1e 01 00 00       	push   $0x11e
  80e4e2:	68 50 37 81 00       	push   $0x813750
  80e4e7:	e8 bc 00 00 00       	call   80e5a8 <_panic>

0080e4ec <libmain>:
        return &envs[ENVX(sys_getenvid())];
} 

void
libmain(int argc, char **argv)
{
  80e4ec:	55                   	push   %ebp
  80e4ed:	89 e5                	mov    %esp,%ebp
  80e4ef:	57                   	push   %edi
  80e4f0:	56                   	push   %esi
  80e4f1:	53                   	push   %ebx
  80e4f2:	83 ec 0c             	sub    $0xc,%esp
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.

	thisenv = 0;
  80e4f5:	c7 05 5c b2 b3 00 00 	movl   $0x0,0xb3b25c
  80e4fc:	00 00 00 
	envid_t find = sys_getenvid();
  80e4ff:	e8 ad 0c 00 00       	call   80f1b1 <sys_getenvid>
  80e504:	8b 1d 5c b2 b3 00    	mov    0xb3b25c,%ebx
  80e50a:	be 00 00 00 00       	mov    $0x0,%esi
	for(int i = 0; i < NENV; i++){
  80e50f:	ba 00 00 00 00       	mov    $0x0,%edx
		if(envs[i].env_id == find)
  80e514:	bf 01 00 00 00       	mov    $0x1,%edi
  80e519:	eb 0b                	jmp    80e526 <libmain+0x3a>
	for(int i = 0; i < NENV; i++){
  80e51b:	83 c2 01             	add    $0x1,%edx
  80e51e:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  80e524:	74 21                	je     80e547 <libmain+0x5b>
		if(envs[i].env_id == find)
  80e526:	89 d1                	mov    %edx,%ecx
  80e528:	c1 e1 07             	shl    $0x7,%ecx
  80e52b:	81 c1 00 00 c0 ee    	add    $0xeec00000,%ecx
  80e531:	8b 49 48             	mov    0x48(%ecx),%ecx
  80e534:	39 c1                	cmp    %eax,%ecx
  80e536:	75 e3                	jne    80e51b <libmain+0x2f>
  80e538:	89 d3                	mov    %edx,%ebx
  80e53a:	c1 e3 07             	shl    $0x7,%ebx
  80e53d:	81 c3 00 00 c0 ee    	add    $0xeec00000,%ebx
  80e543:	89 fe                	mov    %edi,%esi
  80e545:	eb d4                	jmp    80e51b <libmain+0x2f>
  80e547:	89 f0                	mov    %esi,%eax
  80e549:	84 c0                	test   %al,%al
  80e54b:	74 06                	je     80e553 <libmain+0x67>
  80e54d:	89 1d 5c b2 b3 00    	mov    %ebx,0xb3b25c
			thisenv = &envs[i];
	}

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e553:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80e557:	7e 0a                	jle    80e563 <libmain+0x77>
		binaryname = argv[0];
  80e559:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e55c:	8b 00                	mov    (%eax),%eax
  80e55e:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	cprintf("call umain!\n");
  80e563:	83 ec 0c             	sub    $0xc,%esp
  80e566:	68 6a 37 81 00       	push   $0x81376a
  80e56b:	e8 2e 01 00 00       	call   80e69e <cprintf>
	// call user main routine
	umain(argc, argv);
  80e570:	83 c4 08             	add    $0x8,%esp
  80e573:	ff 75 0c             	pushl  0xc(%ebp)
  80e576:	ff 75 08             	pushl  0x8(%ebp)
  80e579:	e8 fe 1f ff ff       	call   80057c <umain>

	// exit gracefully
	exit();
  80e57e:	e8 0b 00 00 00       	call   80e58e <exit>
}
  80e583:	83 c4 10             	add    $0x10,%esp
  80e586:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e589:	5b                   	pop    %ebx
  80e58a:	5e                   	pop    %esi
  80e58b:	5f                   	pop    %edi
  80e58c:	5d                   	pop    %ebp
  80e58d:	c3                   	ret    

0080e58e <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e58e:	55                   	push   %ebp
  80e58f:	89 e5                	mov    %esp,%ebp
  80e591:	83 ec 08             	sub    $0x8,%esp
	close_all();
  80e594:	e8 fa 16 00 00       	call   80fc93 <close_all>
	sys_env_destroy(0);
  80e599:	83 ec 0c             	sub    $0xc,%esp
  80e59c:	6a 00                	push   $0x0
  80e59e:	e8 cd 0b 00 00       	call   80f170 <sys_env_destroy>
}
  80e5a3:	83 c4 10             	add    $0x10,%esp
  80e5a6:	c9                   	leave  
  80e5a7:	c3                   	ret    

0080e5a8 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e5a8:	55                   	push   %ebp
  80e5a9:	89 e5                	mov    %esp,%ebp
  80e5ab:	56                   	push   %esi
  80e5ac:	53                   	push   %ebx
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e5ad:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80e5b2:	8b 40 48             	mov    0x48(%eax),%eax
  80e5b5:	83 ec 04             	sub    $0x4,%esp
  80e5b8:	68 b0 37 81 00       	push   $0x8137b0
  80e5bd:	50                   	push   %eax
  80e5be:	68 81 37 81 00       	push   $0x813781
  80e5c3:	e8 d6 00 00 00       	call   80e69e <cprintf>
	va_list ap;

	va_start(ap, fmt);
  80e5c8:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	// cprintf("[%08x] user panic in %s at %s:%d: ",
	// 	sys_getenvid(), binaryname, file, line);
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e5cb:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e5d1:	e8 db 0b 00 00       	call   80f1b1 <sys_getenvid>
  80e5d6:	83 c4 04             	add    $0x4,%esp
  80e5d9:	ff 75 0c             	pushl  0xc(%ebp)
  80e5dc:	ff 75 08             	pushl  0x8(%ebp)
  80e5df:	56                   	push   %esi
  80e5e0:	50                   	push   %eax
  80e5e1:	68 8c 37 81 00       	push   $0x81378c
  80e5e6:	e8 b3 00 00 00       	call   80e69e <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e5eb:	83 c4 18             	add    $0x18,%esp
  80e5ee:	53                   	push   %ebx
  80e5ef:	ff 75 10             	pushl  0x10(%ebp)
  80e5f2:	e8 56 00 00 00       	call   80e64d <vcprintf>
	cprintf("\n");
  80e5f7:	c7 04 24 75 37 81 00 	movl   $0x813775,(%esp)
  80e5fe:	e8 9b 00 00 00       	call   80e69e <cprintf>
  80e603:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e606:	cc                   	int3   
  80e607:	eb fd                	jmp    80e606 <_panic+0x5e>

0080e609 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e609:	55                   	push   %ebp
  80e60a:	89 e5                	mov    %esp,%ebp
  80e60c:	53                   	push   %ebx
  80e60d:	83 ec 04             	sub    $0x4,%esp
  80e610:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e613:	8b 13                	mov    (%ebx),%edx
  80e615:	8d 42 01             	lea    0x1(%edx),%eax
  80e618:	89 03                	mov    %eax,(%ebx)
  80e61a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e61d:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e621:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e626:	74 09                	je     80e631 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e628:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e62c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e62f:	c9                   	leave  
  80e630:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e631:	83 ec 08             	sub    $0x8,%esp
  80e634:	68 ff 00 00 00       	push   $0xff
  80e639:	8d 43 08             	lea    0x8(%ebx),%eax
  80e63c:	50                   	push   %eax
  80e63d:	e8 f1 0a 00 00       	call   80f133 <sys_cputs>
		b->idx = 0;
  80e642:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e648:	83 c4 10             	add    $0x10,%esp
  80e64b:	eb db                	jmp    80e628 <putch+0x1f>

0080e64d <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e64d:	55                   	push   %ebp
  80e64e:	89 e5                	mov    %esp,%ebp
  80e650:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e656:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e65d:	00 00 00 
	b.cnt = 0;
  80e660:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e667:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e66a:	ff 75 0c             	pushl  0xc(%ebp)
  80e66d:	ff 75 08             	pushl  0x8(%ebp)
  80e670:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e676:	50                   	push   %eax
  80e677:	68 09 e6 80 00       	push   $0x80e609
  80e67c:	e8 4a 01 00 00       	call   80e7cb <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e681:	83 c4 08             	add    $0x8,%esp
  80e684:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e68a:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e690:	50                   	push   %eax
  80e691:	e8 9d 0a 00 00       	call   80f133 <sys_cputs>

	return b.cnt;
}
  80e696:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e69c:	c9                   	leave  
  80e69d:	c3                   	ret    

0080e69e <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e69e:	55                   	push   %ebp
  80e69f:	89 e5                	mov    %esp,%ebp
  80e6a1:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e6a4:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e6a7:	50                   	push   %eax
  80e6a8:	ff 75 08             	pushl  0x8(%ebp)
  80e6ab:	e8 9d ff ff ff       	call   80e64d <vcprintf>
	va_end(ap);

	return cnt;
}
  80e6b0:	c9                   	leave  
  80e6b1:	c3                   	ret    

0080e6b2 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e6b2:	55                   	push   %ebp
  80e6b3:	89 e5                	mov    %esp,%ebp
  80e6b5:	57                   	push   %edi
  80e6b6:	56                   	push   %esi
  80e6b7:	53                   	push   %ebx
  80e6b8:	83 ec 1c             	sub    $0x1c,%esp
  80e6bb:	89 c6                	mov    %eax,%esi
  80e6bd:	89 d7                	mov    %edx,%edi
  80e6bf:	8b 45 08             	mov    0x8(%ebp),%eax
  80e6c2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e6c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e6c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e6cb:	8b 45 10             	mov    0x10(%ebp),%eax
  80e6ce:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// if cprintf'parameter includes pattern of the form "%-", padding
	// space on the right side if neccesary.
	// you can add helper function if needed.
	// your code here:
	if(padc == '-'){
  80e6d1:	83 7d 18 2d          	cmpl   $0x2d,0x18(%ebp)
  80e6d5:	74 2c                	je     80e703 <printnum+0x51>
		while (--width > 0)
			putch(padc, putdat);
	}
	else {
		// first recursively print all preceding (more significant) digits
		if (num >= base) {
  80e6d7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e6da:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80e6e1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e6e4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e6e7:	39 c2                	cmp    %eax,%edx
  80e6e9:	1b 4d dc             	sbb    -0x24(%ebp),%ecx
  80e6ec:	73 43                	jae    80e731 <printnum+0x7f>
			printnum(putch, putdat, num / base, base, width - 1, padc);
		} else {
			// print any needed pad characters before first digit
			while (--width > 0)
  80e6ee:	83 eb 01             	sub    $0x1,%ebx
  80e6f1:	85 db                	test   %ebx,%ebx
  80e6f3:	7e 6c                	jle    80e761 <printnum+0xaf>
				putch(padc, putdat);
  80e6f5:	83 ec 08             	sub    $0x8,%esp
  80e6f8:	57                   	push   %edi
  80e6f9:	ff 75 18             	pushl  0x18(%ebp)
  80e6fc:	ff d6                	call   *%esi
  80e6fe:	83 c4 10             	add    $0x10,%esp
  80e701:	eb eb                	jmp    80e6ee <printnum+0x3c>
		printnum(putch, putdat, num, base, 0, padc);
  80e703:	83 ec 0c             	sub    $0xc,%esp
  80e706:	6a 20                	push   $0x20
  80e708:	6a 00                	push   $0x0
  80e70a:	50                   	push   %eax
  80e70b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e70e:	ff 75 e0             	pushl  -0x20(%ebp)
  80e711:	89 fa                	mov    %edi,%edx
  80e713:	89 f0                	mov    %esi,%eax
  80e715:	e8 98 ff ff ff       	call   80e6b2 <printnum>
		while (--width > 0)
  80e71a:	83 c4 20             	add    $0x20,%esp
  80e71d:	83 eb 01             	sub    $0x1,%ebx
  80e720:	85 db                	test   %ebx,%ebx
  80e722:	7e 65                	jle    80e789 <printnum+0xd7>
			putch(padc, putdat);
  80e724:	83 ec 08             	sub    $0x8,%esp
  80e727:	57                   	push   %edi
  80e728:	6a 20                	push   $0x20
  80e72a:	ff d6                	call   *%esi
  80e72c:	83 c4 10             	add    $0x10,%esp
  80e72f:	eb ec                	jmp    80e71d <printnum+0x6b>
			printnum(putch, putdat, num / base, base, width - 1, padc);
  80e731:	83 ec 0c             	sub    $0xc,%esp
  80e734:	ff 75 18             	pushl  0x18(%ebp)
  80e737:	83 eb 01             	sub    $0x1,%ebx
  80e73a:	53                   	push   %ebx
  80e73b:	50                   	push   %eax
  80e73c:	83 ec 08             	sub    $0x8,%esp
  80e73f:	ff 75 dc             	pushl  -0x24(%ebp)
  80e742:	ff 75 d8             	pushl  -0x28(%ebp)
  80e745:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e748:	ff 75 e0             	pushl  -0x20(%ebp)
  80e74b:	e8 30 28 00 00       	call   810f80 <__udivdi3>
  80e750:	83 c4 18             	add    $0x18,%esp
  80e753:	52                   	push   %edx
  80e754:	50                   	push   %eax
  80e755:	89 fa                	mov    %edi,%edx
  80e757:	89 f0                	mov    %esi,%eax
  80e759:	e8 54 ff ff ff       	call   80e6b2 <printnum>
  80e75e:	83 c4 20             	add    $0x20,%esp
		}

		// then print this (the least significant) digit
		putch("0123456789abcdef"[num % base], putdat);
  80e761:	83 ec 08             	sub    $0x8,%esp
  80e764:	57                   	push   %edi
  80e765:	83 ec 04             	sub    $0x4,%esp
  80e768:	ff 75 dc             	pushl  -0x24(%ebp)
  80e76b:	ff 75 d8             	pushl  -0x28(%ebp)
  80e76e:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e771:	ff 75 e0             	pushl  -0x20(%ebp)
  80e774:	e8 17 29 00 00       	call   811090 <__umoddi3>
  80e779:	83 c4 14             	add    $0x14,%esp
  80e77c:	0f be 80 b7 37 81 00 	movsbl 0x8137b7(%eax),%eax
  80e783:	50                   	push   %eax
  80e784:	ff d6                	call   *%esi
  80e786:	83 c4 10             	add    $0x10,%esp
	}
}
  80e789:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e78c:	5b                   	pop    %ebx
  80e78d:	5e                   	pop    %esi
  80e78e:	5f                   	pop    %edi
  80e78f:	5d                   	pop    %ebp
  80e790:	c3                   	ret    

0080e791 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e791:	55                   	push   %ebp
  80e792:	89 e5                	mov    %esp,%ebp
  80e794:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e797:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e79b:	8b 10                	mov    (%eax),%edx
  80e79d:	3b 50 04             	cmp    0x4(%eax),%edx
  80e7a0:	73 0a                	jae    80e7ac <sprintputch+0x1b>
		*b->buf++ = ch;
  80e7a2:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e7a5:	89 08                	mov    %ecx,(%eax)
  80e7a7:	8b 45 08             	mov    0x8(%ebp),%eax
  80e7aa:	88 02                	mov    %al,(%edx)
}
  80e7ac:	5d                   	pop    %ebp
  80e7ad:	c3                   	ret    

0080e7ae <printfmt>:
{
  80e7ae:	55                   	push   %ebp
  80e7af:	89 e5                	mov    %esp,%ebp
  80e7b1:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e7b4:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e7b7:	50                   	push   %eax
  80e7b8:	ff 75 10             	pushl  0x10(%ebp)
  80e7bb:	ff 75 0c             	pushl  0xc(%ebp)
  80e7be:	ff 75 08             	pushl  0x8(%ebp)
  80e7c1:	e8 05 00 00 00       	call   80e7cb <vprintfmt>
}
  80e7c6:	83 c4 10             	add    $0x10,%esp
  80e7c9:	c9                   	leave  
  80e7ca:	c3                   	ret    

0080e7cb <vprintfmt>:
{
  80e7cb:	55                   	push   %ebp
  80e7cc:	89 e5                	mov    %esp,%ebp
  80e7ce:	57                   	push   %edi
  80e7cf:	56                   	push   %esi
  80e7d0:	53                   	push   %ebx
  80e7d1:	83 ec 3c             	sub    $0x3c,%esp
  80e7d4:	8b 75 08             	mov    0x8(%ebp),%esi
  80e7d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e7da:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e7dd:	e9 32 04 00 00       	jmp    80ec14 <vprintfmt+0x449>
		padc = ' ';
  80e7e2:	c6 45 cf 20          	movb   $0x20,-0x31(%ebp)
		plusflag = 0;
  80e7e6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		altflag = 0;
  80e7ed:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		precision = -1;
  80e7f4:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80e7fb:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e802:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80e809:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e80e:	8d 47 01             	lea    0x1(%edi),%eax
  80e811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e814:	0f b6 17             	movzbl (%edi),%edx
  80e817:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e81a:	3c 55                	cmp    $0x55,%al
  80e81c:	0f 87 12 05 00 00    	ja     80ed34 <vprintfmt+0x569>
  80e822:	0f b6 c0             	movzbl %al,%eax
  80e825:	ff 24 85 a0 39 81 00 	jmp    *0x8139a0(,%eax,4)
  80e82c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e82f:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
  80e833:	eb d9                	jmp    80e80e <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80e835:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80e838:	c6 45 cf 30          	movb   $0x30,-0x31(%ebp)
  80e83c:	eb d0                	jmp    80e80e <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80e83e:	0f b6 d2             	movzbl %dl,%edx
  80e841:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80e844:	b8 00 00 00 00       	mov    $0x0,%eax
  80e849:	89 75 08             	mov    %esi,0x8(%ebp)
  80e84c:	eb 03                	jmp    80e851 <vprintfmt+0x86>
  80e84e:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80e851:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e854:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80e858:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80e85b:	8d 72 d0             	lea    -0x30(%edx),%esi
  80e85e:	83 fe 09             	cmp    $0x9,%esi
  80e861:	76 eb                	jbe    80e84e <vprintfmt+0x83>
  80e863:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e866:	8b 75 08             	mov    0x8(%ebp),%esi
  80e869:	eb 14                	jmp    80e87f <vprintfmt+0xb4>
			precision = va_arg(ap, int);
  80e86b:	8b 45 14             	mov    0x14(%ebp),%eax
  80e86e:	8b 00                	mov    (%eax),%eax
  80e870:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e873:	8b 45 14             	mov    0x14(%ebp),%eax
  80e876:	8d 40 04             	lea    0x4(%eax),%eax
  80e879:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e87c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80e87f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e883:	79 89                	jns    80e80e <vprintfmt+0x43>
				width = precision, precision = -1;
  80e885:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e888:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e88b:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80e892:	e9 77 ff ff ff       	jmp    80e80e <vprintfmt+0x43>
  80e897:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e89a:	85 c0                	test   %eax,%eax
  80e89c:	0f 48 c1             	cmovs  %ecx,%eax
  80e89f:	89 45 e0             	mov    %eax,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e8a2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e8a5:	e9 64 ff ff ff       	jmp    80e80e <vprintfmt+0x43>
  80e8aa:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80e8ad:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
			goto reswitch;
  80e8b4:	e9 55 ff ff ff       	jmp    80e80e <vprintfmt+0x43>
			lflag++;
  80e8b9:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e8bd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e8c0:	e9 49 ff ff ff       	jmp    80e80e <vprintfmt+0x43>
			putch(va_arg(ap, int), putdat);
  80e8c5:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8c8:	8d 78 04             	lea    0x4(%eax),%edi
  80e8cb:	83 ec 08             	sub    $0x8,%esp
  80e8ce:	53                   	push   %ebx
  80e8cf:	ff 30                	pushl  (%eax)
  80e8d1:	ff d6                	call   *%esi
			break;
  80e8d3:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80e8d6:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80e8d9:	e9 33 03 00 00       	jmp    80ec11 <vprintfmt+0x446>
			err = va_arg(ap, int);
  80e8de:	8b 45 14             	mov    0x14(%ebp),%eax
  80e8e1:	8d 78 04             	lea    0x4(%eax),%edi
  80e8e4:	8b 00                	mov    (%eax),%eax
  80e8e6:	99                   	cltd   
  80e8e7:	31 d0                	xor    %edx,%eax
  80e8e9:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e8eb:	83 f8 10             	cmp    $0x10,%eax
  80e8ee:	7f 23                	jg     80e913 <vprintfmt+0x148>
  80e8f0:	8b 14 85 00 3b 81 00 	mov    0x813b00(,%eax,4),%edx
  80e8f7:	85 d2                	test   %edx,%edx
  80e8f9:	74 18                	je     80e913 <vprintfmt+0x148>
				printfmt(putch, putdat, "%s", p);
  80e8fb:	52                   	push   %edx
  80e8fc:	68 7d 29 81 00       	push   $0x81297d
  80e901:	53                   	push   %ebx
  80e902:	56                   	push   %esi
  80e903:	e8 a6 fe ff ff       	call   80e7ae <printfmt>
  80e908:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e90b:	89 7d 14             	mov    %edi,0x14(%ebp)
  80e90e:	e9 fe 02 00 00       	jmp    80ec11 <vprintfmt+0x446>
				printfmt(putch, putdat, "error %d", err);
  80e913:	50                   	push   %eax
  80e914:	68 cf 37 81 00       	push   $0x8137cf
  80e919:	53                   	push   %ebx
  80e91a:	56                   	push   %esi
  80e91b:	e8 8e fe ff ff       	call   80e7ae <printfmt>
  80e920:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e923:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80e926:	e9 e6 02 00 00       	jmp    80ec11 <vprintfmt+0x446>
			if ((p = va_arg(ap, char *)) == NULL)
  80e92b:	8b 45 14             	mov    0x14(%ebp),%eax
  80e92e:	83 c0 04             	add    $0x4,%eax
  80e931:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80e934:	8b 45 14             	mov    0x14(%ebp),%eax
  80e937:	8b 08                	mov    (%eax),%ecx
				p = "(null)";
  80e939:	85 c9                	test   %ecx,%ecx
  80e93b:	b8 c8 37 81 00       	mov    $0x8137c8,%eax
  80e940:	0f 45 c1             	cmovne %ecx,%eax
  80e943:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (width > 0 && padc != '-')
  80e946:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e94a:	7e 06                	jle    80e952 <vprintfmt+0x187>
  80e94c:	80 7d cf 2d          	cmpb   $0x2d,-0x31(%ebp)
  80e950:	75 0d                	jne    80e95f <vprintfmt+0x194>
				for (width -= strnlen(p, precision); width > 0; width--)
  80e952:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80e955:	89 c7                	mov    %eax,%edi
  80e957:	03 45 e0             	add    -0x20(%ebp),%eax
  80e95a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e95d:	eb 53                	jmp    80e9b2 <vprintfmt+0x1e7>
  80e95f:	83 ec 08             	sub    $0x8,%esp
  80e962:	ff 75 d8             	pushl  -0x28(%ebp)
  80e965:	50                   	push   %eax
  80e966:	e8 71 04 00 00       	call   80eddc <strnlen>
  80e96b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e96e:	29 c1                	sub    %eax,%ecx
  80e970:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80e973:	83 c4 10             	add    $0x10,%esp
  80e976:	89 cf                	mov    %ecx,%edi
					putch(padc, putdat);
  80e978:	0f be 45 cf          	movsbl -0x31(%ebp),%eax
  80e97c:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80e97f:	eb 0f                	jmp    80e990 <vprintfmt+0x1c5>
					putch(padc, putdat);
  80e981:	83 ec 08             	sub    $0x8,%esp
  80e984:	53                   	push   %ebx
  80e985:	ff 75 e0             	pushl  -0x20(%ebp)
  80e988:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80e98a:	83 ef 01             	sub    $0x1,%edi
  80e98d:	83 c4 10             	add    $0x10,%esp
  80e990:	85 ff                	test   %edi,%edi
  80e992:	7f ed                	jg     80e981 <vprintfmt+0x1b6>
  80e994:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80e997:	85 c9                	test   %ecx,%ecx
  80e999:	b8 00 00 00 00       	mov    $0x0,%eax
  80e99e:	0f 49 c1             	cmovns %ecx,%eax
  80e9a1:	29 c1                	sub    %eax,%ecx
  80e9a3:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80e9a6:	eb aa                	jmp    80e952 <vprintfmt+0x187>
					putch(ch, putdat);
  80e9a8:	83 ec 08             	sub    $0x8,%esp
  80e9ab:	53                   	push   %ebx
  80e9ac:	52                   	push   %edx
  80e9ad:	ff d6                	call   *%esi
  80e9af:	83 c4 10             	add    $0x10,%esp
  80e9b2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e9b5:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80e9b7:	83 c7 01             	add    $0x1,%edi
  80e9ba:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80e9be:	0f be d0             	movsbl %al,%edx
  80e9c1:	85 d2                	test   %edx,%edx
  80e9c3:	74 4b                	je     80ea10 <vprintfmt+0x245>
  80e9c5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80e9c9:	78 06                	js     80e9d1 <vprintfmt+0x206>
  80e9cb:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80e9cf:	78 1e                	js     80e9ef <vprintfmt+0x224>
				if (altflag && (ch < ' ' || ch > '~'))
  80e9d1:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80e9d5:	74 d1                	je     80e9a8 <vprintfmt+0x1dd>
  80e9d7:	0f be c0             	movsbl %al,%eax
  80e9da:	83 e8 20             	sub    $0x20,%eax
  80e9dd:	83 f8 5e             	cmp    $0x5e,%eax
  80e9e0:	76 c6                	jbe    80e9a8 <vprintfmt+0x1dd>
					putch('?', putdat);
  80e9e2:	83 ec 08             	sub    $0x8,%esp
  80e9e5:	53                   	push   %ebx
  80e9e6:	6a 3f                	push   $0x3f
  80e9e8:	ff d6                	call   *%esi
  80e9ea:	83 c4 10             	add    $0x10,%esp
  80e9ed:	eb c3                	jmp    80e9b2 <vprintfmt+0x1e7>
  80e9ef:	89 cf                	mov    %ecx,%edi
  80e9f1:	eb 0e                	jmp    80ea01 <vprintfmt+0x236>
				putch(' ', putdat);
  80e9f3:	83 ec 08             	sub    $0x8,%esp
  80e9f6:	53                   	push   %ebx
  80e9f7:	6a 20                	push   $0x20
  80e9f9:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80e9fb:	83 ef 01             	sub    $0x1,%edi
  80e9fe:	83 c4 10             	add    $0x10,%esp
  80ea01:	85 ff                	test   %edi,%edi
  80ea03:	7f ee                	jg     80e9f3 <vprintfmt+0x228>
			if ((p = va_arg(ap, char *)) == NULL)
  80ea05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80ea08:	89 45 14             	mov    %eax,0x14(%ebp)
  80ea0b:	e9 01 02 00 00       	jmp    80ec11 <vprintfmt+0x446>
  80ea10:	89 cf                	mov    %ecx,%edi
  80ea12:	eb ed                	jmp    80ea01 <vprintfmt+0x236>
		switch (ch = *(unsigned char *) fmt++) {
  80ea14:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			plusflag = 1;
  80ea17:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
			goto reswitch;
  80ea1e:	e9 eb fd ff ff       	jmp    80e80e <vprintfmt+0x43>
	if (lflag >= 2)
  80ea23:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ea27:	7f 21                	jg     80ea4a <vprintfmt+0x27f>
	else if (lflag)
  80ea29:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ea2d:	74 68                	je     80ea97 <vprintfmt+0x2cc>
		return va_arg(*ap, long);
  80ea2f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea32:	8b 00                	mov    (%eax),%eax
  80ea34:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ea37:	89 c1                	mov    %eax,%ecx
  80ea39:	c1 f9 1f             	sar    $0x1f,%ecx
  80ea3c:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80ea3f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea42:	8d 40 04             	lea    0x4(%eax),%eax
  80ea45:	89 45 14             	mov    %eax,0x14(%ebp)
  80ea48:	eb 17                	jmp    80ea61 <vprintfmt+0x296>
		return va_arg(*ap, long long);
  80ea4a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea4d:	8b 50 04             	mov    0x4(%eax),%edx
  80ea50:	8b 00                	mov    (%eax),%eax
  80ea52:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ea55:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80ea58:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea5b:	8d 40 08             	lea    0x8(%eax),%eax
  80ea5e:	89 45 14             	mov    %eax,0x14(%ebp)
			num = getint(&ap, lflag);
  80ea61:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ea64:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ea67:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ea6a:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if ((long long) num < 0) {
  80ea6d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ea71:	78 3f                	js     80eab2 <vprintfmt+0x2e7>
			base = 10;
  80ea73:	b8 0a 00 00 00       	mov    $0xa,%eax
			else if(plusflag){
  80ea78:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  80ea7c:	0f 84 71 01 00 00    	je     80ebf3 <vprintfmt+0x428>
				putch('+', putdat);
  80ea82:	83 ec 08             	sub    $0x8,%esp
  80ea85:	53                   	push   %ebx
  80ea86:	6a 2b                	push   $0x2b
  80ea88:	ff d6                	call   *%esi
  80ea8a:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ea8d:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ea92:	e9 5c 01 00 00       	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, int);
  80ea97:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea9a:	8b 00                	mov    (%eax),%eax
  80ea9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ea9f:	89 c1                	mov    %eax,%ecx
  80eaa1:	c1 f9 1f             	sar    $0x1f,%ecx
  80eaa4:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80eaa7:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaaa:	8d 40 04             	lea    0x4(%eax),%eax
  80eaad:	89 45 14             	mov    %eax,0x14(%ebp)
  80eab0:	eb af                	jmp    80ea61 <vprintfmt+0x296>
				putch('-', putdat);
  80eab2:	83 ec 08             	sub    $0x8,%esp
  80eab5:	53                   	push   %ebx
  80eab6:	6a 2d                	push   $0x2d
  80eab8:	ff d6                	call   *%esi
				num = -(long long) num;
  80eaba:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80eabd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80eac0:	f7 d8                	neg    %eax
  80eac2:	83 d2 00             	adc    $0x0,%edx
  80eac5:	f7 da                	neg    %edx
  80eac7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eaca:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eacd:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ead0:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ead5:	e9 19 01 00 00       	jmp    80ebf3 <vprintfmt+0x428>
	if (lflag >= 2)
  80eada:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80eade:	7f 29                	jg     80eb09 <vprintfmt+0x33e>
	else if (lflag)
  80eae0:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80eae4:	74 44                	je     80eb2a <vprintfmt+0x35f>
		return va_arg(*ap, unsigned long);
  80eae6:	8b 45 14             	mov    0x14(%ebp),%eax
  80eae9:	8b 00                	mov    (%eax),%eax
  80eaeb:	ba 00 00 00 00       	mov    $0x0,%edx
  80eaf0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eaf3:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eaf6:	8b 45 14             	mov    0x14(%ebp),%eax
  80eaf9:	8d 40 04             	lea    0x4(%eax),%eax
  80eafc:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eaff:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eb04:	e9 ea 00 00 00       	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80eb09:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb0c:	8b 50 04             	mov    0x4(%eax),%edx
  80eb0f:	8b 00                	mov    (%eax),%eax
  80eb11:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb14:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb17:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb1a:	8d 40 08             	lea    0x8(%eax),%eax
  80eb1d:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eb20:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eb25:	e9 c9 00 00 00       	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80eb2a:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb2d:	8b 00                	mov    (%eax),%eax
  80eb2f:	ba 00 00 00 00       	mov    $0x0,%edx
  80eb34:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb37:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb3a:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb3d:	8d 40 04             	lea    0x4(%eax),%eax
  80eb40:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eb43:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eb48:	e9 a6 00 00 00       	jmp    80ebf3 <vprintfmt+0x428>
			putch('0', putdat);
  80eb4d:	83 ec 08             	sub    $0x8,%esp
  80eb50:	53                   	push   %ebx
  80eb51:	6a 30                	push   $0x30
  80eb53:	ff d6                	call   *%esi
	if (lflag >= 2)
  80eb55:	83 c4 10             	add    $0x10,%esp
  80eb58:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80eb5c:	7f 26                	jg     80eb84 <vprintfmt+0x3b9>
	else if (lflag)
  80eb5e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80eb62:	74 3e                	je     80eba2 <vprintfmt+0x3d7>
		return va_arg(*ap, unsigned long);
  80eb64:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb67:	8b 00                	mov    (%eax),%eax
  80eb69:	ba 00 00 00 00       	mov    $0x0,%edx
  80eb6e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb71:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb74:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb77:	8d 40 04             	lea    0x4(%eax),%eax
  80eb7a:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80eb7d:	b8 08 00 00 00       	mov    $0x8,%eax
  80eb82:	eb 6f                	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80eb84:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb87:	8b 50 04             	mov    0x4(%eax),%edx
  80eb8a:	8b 00                	mov    (%eax),%eax
  80eb8c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb8f:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eb92:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb95:	8d 40 08             	lea    0x8(%eax),%eax
  80eb98:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80eb9b:	b8 08 00 00 00       	mov    $0x8,%eax
  80eba0:	eb 51                	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80eba2:	8b 45 14             	mov    0x14(%ebp),%eax
  80eba5:	8b 00                	mov    (%eax),%eax
  80eba7:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebac:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebaf:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ebb2:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebb5:	8d 40 04             	lea    0x4(%eax),%eax
  80ebb8:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ebbb:	b8 08 00 00 00       	mov    $0x8,%eax
  80ebc0:	eb 31                	jmp    80ebf3 <vprintfmt+0x428>
			putch('0', putdat);
  80ebc2:	83 ec 08             	sub    $0x8,%esp
  80ebc5:	53                   	push   %ebx
  80ebc6:	6a 30                	push   $0x30
  80ebc8:	ff d6                	call   *%esi
			putch('x', putdat);
  80ebca:	83 c4 08             	add    $0x8,%esp
  80ebcd:	53                   	push   %ebx
  80ebce:	6a 78                	push   $0x78
  80ebd0:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ebd2:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebd5:	8b 00                	mov    (%eax),%eax
  80ebd7:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebdc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebdf:	89 55 dc             	mov    %edx,-0x24(%ebp)
			goto number;
  80ebe2:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80ebe5:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebe8:	8d 40 04             	lea    0x4(%eax),%eax
  80ebeb:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ebee:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80ebf3:	83 ec 0c             	sub    $0xc,%esp
  80ebf6:	0f be 55 cf          	movsbl -0x31(%ebp),%edx
  80ebfa:	52                   	push   %edx
  80ebfb:	ff 75 e0             	pushl  -0x20(%ebp)
  80ebfe:	50                   	push   %eax
  80ebff:	ff 75 dc             	pushl  -0x24(%ebp)
  80ec02:	ff 75 d8             	pushl  -0x28(%ebp)
  80ec05:	89 da                	mov    %ebx,%edx
  80ec07:	89 f0                	mov    %esi,%eax
  80ec09:	e8 a4 fa ff ff       	call   80e6b2 <printnum>
			break;
  80ec0e:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80ec11:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80ec14:	83 c7 01             	add    $0x1,%edi
  80ec17:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ec1b:	83 f8 25             	cmp    $0x25,%eax
  80ec1e:	0f 84 be fb ff ff    	je     80e7e2 <vprintfmt+0x17>
			if (ch == '\0')
  80ec24:	85 c0                	test   %eax,%eax
  80ec26:	0f 84 28 01 00 00    	je     80ed54 <vprintfmt+0x589>
			putch(ch, putdat);
  80ec2c:	83 ec 08             	sub    $0x8,%esp
  80ec2f:	53                   	push   %ebx
  80ec30:	50                   	push   %eax
  80ec31:	ff d6                	call   *%esi
  80ec33:	83 c4 10             	add    $0x10,%esp
  80ec36:	eb dc                	jmp    80ec14 <vprintfmt+0x449>
	if (lflag >= 2)
  80ec38:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ec3c:	7f 26                	jg     80ec64 <vprintfmt+0x499>
	else if (lflag)
  80ec3e:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ec42:	74 41                	je     80ec85 <vprintfmt+0x4ba>
		return va_arg(*ap, unsigned long);
  80ec44:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec47:	8b 00                	mov    (%eax),%eax
  80ec49:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec51:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec54:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec57:	8d 40 04             	lea    0x4(%eax),%eax
  80ec5a:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ec5d:	b8 10 00 00 00       	mov    $0x10,%eax
  80ec62:	eb 8f                	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ec64:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec67:	8b 50 04             	mov    0x4(%eax),%edx
  80ec6a:	8b 00                	mov    (%eax),%eax
  80ec6c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec6f:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec72:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec75:	8d 40 08             	lea    0x8(%eax),%eax
  80ec78:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ec7b:	b8 10 00 00 00       	mov    $0x10,%eax
  80ec80:	e9 6e ff ff ff       	jmp    80ebf3 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ec85:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec88:	8b 00                	mov    (%eax),%eax
  80ec8a:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec8f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec92:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec95:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec98:	8d 40 04             	lea    0x4(%eax),%eax
  80ec9b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ec9e:	b8 10 00 00 00       	mov    $0x10,%eax
  80eca3:	e9 4b ff ff ff       	jmp    80ebf3 <vprintfmt+0x428>
					if ((p = va_arg(ap, char *)) == NULL){
  80eca8:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecab:	83 c0 04             	add    $0x4,%eax
  80ecae:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecb1:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecb4:	8b 00                	mov    (%eax),%eax
  80ecb6:	85 c0                	test   %eax,%eax
  80ecb8:	74 14                	je     80ecce <vprintfmt+0x503>
					}else if(*(int *)putdat > 127){
  80ecba:	8b 13                	mov    (%ebx),%edx
  80ecbc:	83 fa 7f             	cmp    $0x7f,%edx
  80ecbf:	7f 37                	jg     80ecf8 <vprintfmt+0x52d>
						*(char *)p = *(int *)putdat;
  80ecc1:	88 10                	mov    %dl,(%eax)
					if ((p = va_arg(ap, char *)) == NULL){
  80ecc3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ecc6:	89 45 14             	mov    %eax,0x14(%ebp)
  80ecc9:	e9 43 ff ff ff       	jmp    80ec11 <vprintfmt+0x446>
						for (; (ch = *tmp++) != '\0';){
  80ecce:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ecd3:	bf ed 38 81 00       	mov    $0x8138ed,%edi
							putch(ch, putdat);
  80ecd8:	83 ec 08             	sub    $0x8,%esp
  80ecdb:	53                   	push   %ebx
  80ecdc:	50                   	push   %eax
  80ecdd:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80ecdf:	83 c7 01             	add    $0x1,%edi
  80ece2:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80ece6:	83 c4 10             	add    $0x10,%esp
  80ece9:	85 c0                	test   %eax,%eax
  80eceb:	75 eb                	jne    80ecd8 <vprintfmt+0x50d>
					if ((p = va_arg(ap, char *)) == NULL){
  80eced:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ecf0:	89 45 14             	mov    %eax,0x14(%ebp)
  80ecf3:	e9 19 ff ff ff       	jmp    80ec11 <vprintfmt+0x446>
						*(char *)p = *(int *)putdat;
  80ecf8:	88 10                	mov    %dl,(%eax)
						for (; (ch = *tmp++) != '\0';){
  80ecfa:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ecff:	bf 25 39 81 00       	mov    $0x813925,%edi
							putch(ch, putdat);
  80ed04:	83 ec 08             	sub    $0x8,%esp
  80ed07:	53                   	push   %ebx
  80ed08:	50                   	push   %eax
  80ed09:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80ed0b:	83 c7 01             	add    $0x1,%edi
  80ed0e:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80ed12:	83 c4 10             	add    $0x10,%esp
  80ed15:	85 c0                	test   %eax,%eax
  80ed17:	75 eb                	jne    80ed04 <vprintfmt+0x539>
					if ((p = va_arg(ap, char *)) == NULL){
  80ed19:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ed1c:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed1f:	e9 ed fe ff ff       	jmp    80ec11 <vprintfmt+0x446>
			putch(ch, putdat);
  80ed24:	83 ec 08             	sub    $0x8,%esp
  80ed27:	53                   	push   %ebx
  80ed28:	6a 25                	push   $0x25
  80ed2a:	ff d6                	call   *%esi
			break;
  80ed2c:	83 c4 10             	add    $0x10,%esp
  80ed2f:	e9 dd fe ff ff       	jmp    80ec11 <vprintfmt+0x446>
			putch('%', putdat);
  80ed34:	83 ec 08             	sub    $0x8,%esp
  80ed37:	53                   	push   %ebx
  80ed38:	6a 25                	push   $0x25
  80ed3a:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ed3c:	83 c4 10             	add    $0x10,%esp
  80ed3f:	89 f8                	mov    %edi,%eax
  80ed41:	eb 03                	jmp    80ed46 <vprintfmt+0x57b>
  80ed43:	83 e8 01             	sub    $0x1,%eax
  80ed46:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ed4a:	75 f7                	jne    80ed43 <vprintfmt+0x578>
  80ed4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ed4f:	e9 bd fe ff ff       	jmp    80ec11 <vprintfmt+0x446>
}
  80ed54:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ed57:	5b                   	pop    %ebx
  80ed58:	5e                   	pop    %esi
  80ed59:	5f                   	pop    %edi
  80ed5a:	5d                   	pop    %ebp
  80ed5b:	c3                   	ret    

0080ed5c <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ed5c:	55                   	push   %ebp
  80ed5d:	89 e5                	mov    %esp,%ebp
  80ed5f:	83 ec 18             	sub    $0x18,%esp
  80ed62:	8b 45 08             	mov    0x8(%ebp),%eax
  80ed65:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ed68:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ed6b:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ed6f:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ed72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ed79:	85 c0                	test   %eax,%eax
  80ed7b:	74 26                	je     80eda3 <vsnprintf+0x47>
  80ed7d:	85 d2                	test   %edx,%edx
  80ed7f:	7e 22                	jle    80eda3 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ed81:	ff 75 14             	pushl  0x14(%ebp)
  80ed84:	ff 75 10             	pushl  0x10(%ebp)
  80ed87:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ed8a:	50                   	push   %eax
  80ed8b:	68 91 e7 80 00       	push   $0x80e791
  80ed90:	e8 36 fa ff ff       	call   80e7cb <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ed95:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ed98:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ed9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ed9e:	83 c4 10             	add    $0x10,%esp
}
  80eda1:	c9                   	leave  
  80eda2:	c3                   	ret    
		return -E_INVAL;
  80eda3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80eda8:	eb f7                	jmp    80eda1 <vsnprintf+0x45>

0080edaa <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80edaa:	55                   	push   %ebp
  80edab:	89 e5                	mov    %esp,%ebp
  80edad:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80edb0:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80edb3:	50                   	push   %eax
  80edb4:	ff 75 10             	pushl  0x10(%ebp)
  80edb7:	ff 75 0c             	pushl  0xc(%ebp)
  80edba:	ff 75 08             	pushl  0x8(%ebp)
  80edbd:	e8 9a ff ff ff       	call   80ed5c <vsnprintf>
	va_end(ap);

	return rc;
}
  80edc2:	c9                   	leave  
  80edc3:	c3                   	ret    

0080edc4 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80edc4:	55                   	push   %ebp
  80edc5:	89 e5                	mov    %esp,%ebp
  80edc7:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80edca:	b8 00 00 00 00       	mov    $0x0,%eax
  80edcf:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80edd3:	74 05                	je     80edda <strlen+0x16>
		n++;
  80edd5:	83 c0 01             	add    $0x1,%eax
  80edd8:	eb f5                	jmp    80edcf <strlen+0xb>
	return n;
}
  80edda:	5d                   	pop    %ebp
  80eddb:	c3                   	ret    

0080eddc <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80eddc:	55                   	push   %ebp
  80eddd:	89 e5                	mov    %esp,%ebp
  80eddf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ede2:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80ede5:	ba 00 00 00 00       	mov    $0x0,%edx
  80edea:	39 c2                	cmp    %eax,%edx
  80edec:	74 0d                	je     80edfb <strnlen+0x1f>
  80edee:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80edf2:	74 05                	je     80edf9 <strnlen+0x1d>
		n++;
  80edf4:	83 c2 01             	add    $0x1,%edx
  80edf7:	eb f1                	jmp    80edea <strnlen+0xe>
  80edf9:	89 d0                	mov    %edx,%eax
	return n;
}
  80edfb:	5d                   	pop    %ebp
  80edfc:	c3                   	ret    

0080edfd <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80edfd:	55                   	push   %ebp
  80edfe:	89 e5                	mov    %esp,%ebp
  80ee00:	53                   	push   %ebx
  80ee01:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee04:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80ee07:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee0c:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80ee10:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80ee13:	83 c2 01             	add    $0x1,%edx
  80ee16:	84 c9                	test   %cl,%cl
  80ee18:	75 f2                	jne    80ee0c <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80ee1a:	5b                   	pop    %ebx
  80ee1b:	5d                   	pop    %ebp
  80ee1c:	c3                   	ret    

0080ee1d <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ee1d:	55                   	push   %ebp
  80ee1e:	89 e5                	mov    %esp,%ebp
  80ee20:	53                   	push   %ebx
  80ee21:	83 ec 10             	sub    $0x10,%esp
  80ee24:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ee27:	53                   	push   %ebx
  80ee28:	e8 97 ff ff ff       	call   80edc4 <strlen>
  80ee2d:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80ee30:	ff 75 0c             	pushl  0xc(%ebp)
  80ee33:	01 d8                	add    %ebx,%eax
  80ee35:	50                   	push   %eax
  80ee36:	e8 c2 ff ff ff       	call   80edfd <strcpy>
	return dst;
}
  80ee3b:	89 d8                	mov    %ebx,%eax
  80ee3d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ee40:	c9                   	leave  
  80ee41:	c3                   	ret    

0080ee42 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ee42:	55                   	push   %ebp
  80ee43:	89 e5                	mov    %esp,%ebp
  80ee45:	56                   	push   %esi
  80ee46:	53                   	push   %ebx
  80ee47:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee4d:	89 c6                	mov    %eax,%esi
  80ee4f:	03 75 10             	add    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ee52:	89 c2                	mov    %eax,%edx
  80ee54:	39 f2                	cmp    %esi,%edx
  80ee56:	74 11                	je     80ee69 <strncpy+0x27>
		*dst++ = *src;
  80ee58:	83 c2 01             	add    $0x1,%edx
  80ee5b:	0f b6 19             	movzbl (%ecx),%ebx
  80ee5e:	88 5a ff             	mov    %bl,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ee61:	80 fb 01             	cmp    $0x1,%bl
  80ee64:	83 d9 ff             	sbb    $0xffffffff,%ecx
  80ee67:	eb eb                	jmp    80ee54 <strncpy+0x12>
	}
	return ret;
}
  80ee69:	5b                   	pop    %ebx
  80ee6a:	5e                   	pop    %esi
  80ee6b:	5d                   	pop    %ebp
  80ee6c:	c3                   	ret    

0080ee6d <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ee6d:	55                   	push   %ebp
  80ee6e:	89 e5                	mov    %esp,%ebp
  80ee70:	56                   	push   %esi
  80ee71:	53                   	push   %ebx
  80ee72:	8b 75 08             	mov    0x8(%ebp),%esi
  80ee75:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ee78:	8b 55 10             	mov    0x10(%ebp),%edx
  80ee7b:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ee7d:	85 d2                	test   %edx,%edx
  80ee7f:	74 21                	je     80eea2 <strlcpy+0x35>
  80ee81:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ee85:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80ee87:	39 c2                	cmp    %eax,%edx
  80ee89:	74 14                	je     80ee9f <strlcpy+0x32>
  80ee8b:	0f b6 19             	movzbl (%ecx),%ebx
  80ee8e:	84 db                	test   %bl,%bl
  80ee90:	74 0b                	je     80ee9d <strlcpy+0x30>
			*dst++ = *src++;
  80ee92:	83 c1 01             	add    $0x1,%ecx
  80ee95:	83 c2 01             	add    $0x1,%edx
  80ee98:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ee9b:	eb ea                	jmp    80ee87 <strlcpy+0x1a>
  80ee9d:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80ee9f:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80eea2:	29 f0                	sub    %esi,%eax
}
  80eea4:	5b                   	pop    %ebx
  80eea5:	5e                   	pop    %esi
  80eea6:	5d                   	pop    %ebp
  80eea7:	c3                   	ret    

0080eea8 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80eea8:	55                   	push   %ebp
  80eea9:	89 e5                	mov    %esp,%ebp
  80eeab:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eeae:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80eeb1:	0f b6 01             	movzbl (%ecx),%eax
  80eeb4:	84 c0                	test   %al,%al
  80eeb6:	74 0c                	je     80eec4 <strcmp+0x1c>
  80eeb8:	3a 02                	cmp    (%edx),%al
  80eeba:	75 08                	jne    80eec4 <strcmp+0x1c>
		p++, q++;
  80eebc:	83 c1 01             	add    $0x1,%ecx
  80eebf:	83 c2 01             	add    $0x1,%edx
  80eec2:	eb ed                	jmp    80eeb1 <strcmp+0x9>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80eec4:	0f b6 c0             	movzbl %al,%eax
  80eec7:	0f b6 12             	movzbl (%edx),%edx
  80eeca:	29 d0                	sub    %edx,%eax
}
  80eecc:	5d                   	pop    %ebp
  80eecd:	c3                   	ret    

0080eece <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80eece:	55                   	push   %ebp
  80eecf:	89 e5                	mov    %esp,%ebp
  80eed1:	53                   	push   %ebx
  80eed2:	8b 45 08             	mov    0x8(%ebp),%eax
  80eed5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80eed8:	89 c3                	mov    %eax,%ebx
  80eeda:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80eedd:	eb 06                	jmp    80eee5 <strncmp+0x17>
		n--, p++, q++;
  80eedf:	83 c0 01             	add    $0x1,%eax
  80eee2:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80eee5:	39 d8                	cmp    %ebx,%eax
  80eee7:	74 16                	je     80eeff <strncmp+0x31>
  80eee9:	0f b6 08             	movzbl (%eax),%ecx
  80eeec:	84 c9                	test   %cl,%cl
  80eeee:	74 04                	je     80eef4 <strncmp+0x26>
  80eef0:	3a 0a                	cmp    (%edx),%cl
  80eef2:	74 eb                	je     80eedf <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80eef4:	0f b6 00             	movzbl (%eax),%eax
  80eef7:	0f b6 12             	movzbl (%edx),%edx
  80eefa:	29 d0                	sub    %edx,%eax
}
  80eefc:	5b                   	pop    %ebx
  80eefd:	5d                   	pop    %ebp
  80eefe:	c3                   	ret    
		return 0;
  80eeff:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef04:	eb f6                	jmp    80eefc <strncmp+0x2e>

0080ef06 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80ef06:	55                   	push   %ebp
  80ef07:	89 e5                	mov    %esp,%ebp
  80ef09:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef0c:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ef10:	0f b6 10             	movzbl (%eax),%edx
  80ef13:	84 d2                	test   %dl,%dl
  80ef15:	74 09                	je     80ef20 <strchr+0x1a>
		if (*s == c)
  80ef17:	38 ca                	cmp    %cl,%dl
  80ef19:	74 0a                	je     80ef25 <strchr+0x1f>
	for (; *s; s++)
  80ef1b:	83 c0 01             	add    $0x1,%eax
  80ef1e:	eb f0                	jmp    80ef10 <strchr+0xa>
			return (char *) s;
	return 0;
  80ef20:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ef25:	5d                   	pop    %ebp
  80ef26:	c3                   	ret    

0080ef27 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80ef27:	55                   	push   %ebp
  80ef28:	89 e5                	mov    %esp,%ebp
  80ef2a:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef2d:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80ef31:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80ef34:	38 ca                	cmp    %cl,%dl
  80ef36:	74 09                	je     80ef41 <strfind+0x1a>
  80ef38:	84 d2                	test   %dl,%dl
  80ef3a:	74 05                	je     80ef41 <strfind+0x1a>
	for (; *s; s++)
  80ef3c:	83 c0 01             	add    $0x1,%eax
  80ef3f:	eb f0                	jmp    80ef31 <strfind+0xa>
			break;
	return (char *) s;
}
  80ef41:	5d                   	pop    %ebp
  80ef42:	c3                   	ret    

0080ef43 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80ef43:	55                   	push   %ebp
  80ef44:	89 e5                	mov    %esp,%ebp
  80ef46:	57                   	push   %edi
  80ef47:	56                   	push   %esi
  80ef48:	53                   	push   %ebx
  80ef49:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ef4c:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80ef4f:	85 c9                	test   %ecx,%ecx
  80ef51:	74 31                	je     80ef84 <memset+0x41>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80ef53:	89 f8                	mov    %edi,%eax
  80ef55:	09 c8                	or     %ecx,%eax
  80ef57:	a8 03                	test   $0x3,%al
  80ef59:	75 23                	jne    80ef7e <memset+0x3b>
		c &= 0xFF;
  80ef5b:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80ef5f:	89 d3                	mov    %edx,%ebx
  80ef61:	c1 e3 08             	shl    $0x8,%ebx
  80ef64:	89 d0                	mov    %edx,%eax
  80ef66:	c1 e0 18             	shl    $0x18,%eax
  80ef69:	89 d6                	mov    %edx,%esi
  80ef6b:	c1 e6 10             	shl    $0x10,%esi
  80ef6e:	09 f0                	or     %esi,%eax
  80ef70:	09 c2                	or     %eax,%edx
  80ef72:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80ef74:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80ef77:	89 d0                	mov    %edx,%eax
  80ef79:	fc                   	cld    
  80ef7a:	f3 ab                	rep stos %eax,%es:(%edi)
  80ef7c:	eb 06                	jmp    80ef84 <memset+0x41>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80ef7e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ef81:	fc                   	cld    
  80ef82:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80ef84:	89 f8                	mov    %edi,%eax
  80ef86:	5b                   	pop    %ebx
  80ef87:	5e                   	pop    %esi
  80ef88:	5f                   	pop    %edi
  80ef89:	5d                   	pop    %ebp
  80ef8a:	c3                   	ret    

0080ef8b <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80ef8b:	55                   	push   %ebp
  80ef8c:	89 e5                	mov    %esp,%ebp
  80ef8e:	57                   	push   %edi
  80ef8f:	56                   	push   %esi
  80ef90:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef93:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ef96:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80ef99:	39 c6                	cmp    %eax,%esi
  80ef9b:	73 32                	jae    80efcf <memmove+0x44>
  80ef9d:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80efa0:	39 c2                	cmp    %eax,%edx
  80efa2:	76 2b                	jbe    80efcf <memmove+0x44>
		s += n;
		d += n;
  80efa4:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80efa7:	89 fe                	mov    %edi,%esi
  80efa9:	09 ce                	or     %ecx,%esi
  80efab:	09 d6                	or     %edx,%esi
  80efad:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80efb3:	75 0e                	jne    80efc3 <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80efb5:	83 ef 04             	sub    $0x4,%edi
  80efb8:	8d 72 fc             	lea    -0x4(%edx),%esi
  80efbb:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80efbe:	fd                   	std    
  80efbf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80efc1:	eb 09                	jmp    80efcc <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80efc3:	83 ef 01             	sub    $0x1,%edi
  80efc6:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80efc9:	fd                   	std    
  80efca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80efcc:	fc                   	cld    
  80efcd:	eb 1a                	jmp    80efe9 <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80efcf:	89 c2                	mov    %eax,%edx
  80efd1:	09 ca                	or     %ecx,%edx
  80efd3:	09 f2                	or     %esi,%edx
  80efd5:	f6 c2 03             	test   $0x3,%dl
  80efd8:	75 0a                	jne    80efe4 <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80efda:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80efdd:	89 c7                	mov    %eax,%edi
  80efdf:	fc                   	cld    
  80efe0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80efe2:	eb 05                	jmp    80efe9 <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80efe4:	89 c7                	mov    %eax,%edi
  80efe6:	fc                   	cld    
  80efe7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80efe9:	5e                   	pop    %esi
  80efea:	5f                   	pop    %edi
  80efeb:	5d                   	pop    %ebp
  80efec:	c3                   	ret    

0080efed <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80efed:	55                   	push   %ebp
  80efee:	89 e5                	mov    %esp,%ebp
  80eff0:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80eff3:	ff 75 10             	pushl  0x10(%ebp)
  80eff6:	ff 75 0c             	pushl  0xc(%ebp)
  80eff9:	ff 75 08             	pushl  0x8(%ebp)
  80effc:	e8 8a ff ff ff       	call   80ef8b <memmove>
}
  80f001:	c9                   	leave  
  80f002:	c3                   	ret    

0080f003 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f003:	55                   	push   %ebp
  80f004:	89 e5                	mov    %esp,%ebp
  80f006:	56                   	push   %esi
  80f007:	53                   	push   %ebx
  80f008:	8b 45 08             	mov    0x8(%ebp),%eax
  80f00b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f00e:	89 c6                	mov    %eax,%esi
  80f010:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f013:	39 f0                	cmp    %esi,%eax
  80f015:	74 1c                	je     80f033 <memcmp+0x30>
		if (*s1 != *s2)
  80f017:	0f b6 08             	movzbl (%eax),%ecx
  80f01a:	0f b6 1a             	movzbl (%edx),%ebx
  80f01d:	38 d9                	cmp    %bl,%cl
  80f01f:	75 08                	jne    80f029 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f021:	83 c0 01             	add    $0x1,%eax
  80f024:	83 c2 01             	add    $0x1,%edx
  80f027:	eb ea                	jmp    80f013 <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80f029:	0f b6 c1             	movzbl %cl,%eax
  80f02c:	0f b6 db             	movzbl %bl,%ebx
  80f02f:	29 d8                	sub    %ebx,%eax
  80f031:	eb 05                	jmp    80f038 <memcmp+0x35>
	}

	return 0;
  80f033:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f038:	5b                   	pop    %ebx
  80f039:	5e                   	pop    %esi
  80f03a:	5d                   	pop    %ebp
  80f03b:	c3                   	ret    

0080f03c <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f03c:	55                   	push   %ebp
  80f03d:	89 e5                	mov    %esp,%ebp
  80f03f:	8b 45 08             	mov    0x8(%ebp),%eax
  80f042:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f045:	89 c2                	mov    %eax,%edx
  80f047:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f04a:	39 d0                	cmp    %edx,%eax
  80f04c:	73 09                	jae    80f057 <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f04e:	38 08                	cmp    %cl,(%eax)
  80f050:	74 05                	je     80f057 <memfind+0x1b>
	for (; s < ends; s++)
  80f052:	83 c0 01             	add    $0x1,%eax
  80f055:	eb f3                	jmp    80f04a <memfind+0xe>
			break;
	return (void *) s;
}
  80f057:	5d                   	pop    %ebp
  80f058:	c3                   	ret    

0080f059 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f059:	55                   	push   %ebp
  80f05a:	89 e5                	mov    %esp,%ebp
  80f05c:	57                   	push   %edi
  80f05d:	56                   	push   %esi
  80f05e:	53                   	push   %ebx
  80f05f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f062:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f065:	eb 03                	jmp    80f06a <strtol+0x11>
		s++;
  80f067:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f06a:	0f b6 01             	movzbl (%ecx),%eax
  80f06d:	3c 20                	cmp    $0x20,%al
  80f06f:	74 f6                	je     80f067 <strtol+0xe>
  80f071:	3c 09                	cmp    $0x9,%al
  80f073:	74 f2                	je     80f067 <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80f075:	3c 2b                	cmp    $0x2b,%al
  80f077:	74 2a                	je     80f0a3 <strtol+0x4a>
	int neg = 0;
  80f079:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f07e:	3c 2d                	cmp    $0x2d,%al
  80f080:	74 2b                	je     80f0ad <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f082:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f088:	75 0f                	jne    80f099 <strtol+0x40>
  80f08a:	80 39 30             	cmpb   $0x30,(%ecx)
  80f08d:	74 28                	je     80f0b7 <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f08f:	85 db                	test   %ebx,%ebx
  80f091:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f096:	0f 44 d8             	cmove  %eax,%ebx
  80f099:	b8 00 00 00 00       	mov    $0x0,%eax
  80f09e:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f0a1:	eb 50                	jmp    80f0f3 <strtol+0x9a>
		s++;
  80f0a3:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f0a6:	bf 00 00 00 00       	mov    $0x0,%edi
  80f0ab:	eb d5                	jmp    80f082 <strtol+0x29>
		s++, neg = 1;
  80f0ad:	83 c1 01             	add    $0x1,%ecx
  80f0b0:	bf 01 00 00 00       	mov    $0x1,%edi
  80f0b5:	eb cb                	jmp    80f082 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f0b7:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f0bb:	74 0e                	je     80f0cb <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80f0bd:	85 db                	test   %ebx,%ebx
  80f0bf:	75 d8                	jne    80f099 <strtol+0x40>
		s++, base = 8;
  80f0c1:	83 c1 01             	add    $0x1,%ecx
  80f0c4:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f0c9:	eb ce                	jmp    80f099 <strtol+0x40>
		s += 2, base = 16;
  80f0cb:	83 c1 02             	add    $0x2,%ecx
  80f0ce:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f0d3:	eb c4                	jmp    80f099 <strtol+0x40>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80f0d5:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f0d8:	89 f3                	mov    %esi,%ebx
  80f0da:	80 fb 19             	cmp    $0x19,%bl
  80f0dd:	77 29                	ja     80f108 <strtol+0xaf>
			dig = *s - 'a' + 10;
  80f0df:	0f be d2             	movsbl %dl,%edx
  80f0e2:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f0e5:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f0e8:	7d 30                	jge    80f11a <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80f0ea:	83 c1 01             	add    $0x1,%ecx
  80f0ed:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f0f1:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f0f3:	0f b6 11             	movzbl (%ecx),%edx
  80f0f6:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f0f9:	89 f3                	mov    %esi,%ebx
  80f0fb:	80 fb 09             	cmp    $0x9,%bl
  80f0fe:	77 d5                	ja     80f0d5 <strtol+0x7c>
			dig = *s - '0';
  80f100:	0f be d2             	movsbl %dl,%edx
  80f103:	83 ea 30             	sub    $0x30,%edx
  80f106:	eb dd                	jmp    80f0e5 <strtol+0x8c>
		else if (*s >= 'A' && *s <= 'Z')
  80f108:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f10b:	89 f3                	mov    %esi,%ebx
  80f10d:	80 fb 19             	cmp    $0x19,%bl
  80f110:	77 08                	ja     80f11a <strtol+0xc1>
			dig = *s - 'A' + 10;
  80f112:	0f be d2             	movsbl %dl,%edx
  80f115:	83 ea 37             	sub    $0x37,%edx
  80f118:	eb cb                	jmp    80f0e5 <strtol+0x8c>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f11a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f11e:	74 05                	je     80f125 <strtol+0xcc>
		*endptr = (char *) s;
  80f120:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f123:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f125:	89 c2                	mov    %eax,%edx
  80f127:	f7 da                	neg    %edx
  80f129:	85 ff                	test   %edi,%edi
  80f12b:	0f 45 c2             	cmovne %edx,%eax
}
  80f12e:	5b                   	pop    %ebx
  80f12f:	5e                   	pop    %esi
  80f130:	5f                   	pop    %edi
  80f131:	5d                   	pop    %ebp
  80f132:	c3                   	ret    

0080f133 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f133:	55                   	push   %ebp
  80f134:	89 e5                	mov    %esp,%ebp
  80f136:	57                   	push   %edi
  80f137:	56                   	push   %esi
  80f138:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f139:	b8 00 00 00 00       	mov    $0x0,%eax
  80f13e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f141:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f144:	89 c3                	mov    %eax,%ebx
  80f146:	89 c7                	mov    %eax,%edi
  80f148:	89 c6                	mov    %eax,%esi
  80f14a:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f14c:	5b                   	pop    %ebx
  80f14d:	5e                   	pop    %esi
  80f14e:	5f                   	pop    %edi
  80f14f:	5d                   	pop    %ebp
  80f150:	c3                   	ret    

0080f151 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f151:	55                   	push   %ebp
  80f152:	89 e5                	mov    %esp,%ebp
  80f154:	57                   	push   %edi
  80f155:	56                   	push   %esi
  80f156:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f157:	ba 00 00 00 00       	mov    $0x0,%edx
  80f15c:	b8 01 00 00 00       	mov    $0x1,%eax
  80f161:	89 d1                	mov    %edx,%ecx
  80f163:	89 d3                	mov    %edx,%ebx
  80f165:	89 d7                	mov    %edx,%edi
  80f167:	89 d6                	mov    %edx,%esi
  80f169:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f16b:	5b                   	pop    %ebx
  80f16c:	5e                   	pop    %esi
  80f16d:	5f                   	pop    %edi
  80f16e:	5d                   	pop    %ebp
  80f16f:	c3                   	ret    

0080f170 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f170:	55                   	push   %ebp
  80f171:	89 e5                	mov    %esp,%ebp
  80f173:	57                   	push   %edi
  80f174:	56                   	push   %esi
  80f175:	53                   	push   %ebx
  80f176:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f179:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f17e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f181:	b8 03 00 00 00       	mov    $0x3,%eax
  80f186:	89 cb                	mov    %ecx,%ebx
  80f188:	89 cf                	mov    %ecx,%edi
  80f18a:	89 ce                	mov    %ecx,%esi
  80f18c:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f18e:	85 c0                	test   %eax,%eax
  80f190:	7f 08                	jg     80f19a <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f192:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f195:	5b                   	pop    %ebx
  80f196:	5e                   	pop    %esi
  80f197:	5f                   	pop    %edi
  80f198:	5d                   	pop    %ebp
  80f199:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f19a:	83 ec 0c             	sub    $0xc,%esp
  80f19d:	50                   	push   %eax
  80f19e:	6a 03                	push   $0x3
  80f1a0:	68 44 3b 81 00       	push   $0x813b44
  80f1a5:	6a 43                	push   $0x43
  80f1a7:	68 61 3b 81 00       	push   $0x813b61
  80f1ac:	e8 f7 f3 ff ff       	call   80e5a8 <_panic>

0080f1b1 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f1b1:	55                   	push   %ebp
  80f1b2:	89 e5                	mov    %esp,%ebp
  80f1b4:	57                   	push   %edi
  80f1b5:	56                   	push   %esi
  80f1b6:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f1b7:	ba 00 00 00 00       	mov    $0x0,%edx
  80f1bc:	b8 02 00 00 00       	mov    $0x2,%eax
  80f1c1:	89 d1                	mov    %edx,%ecx
  80f1c3:	89 d3                	mov    %edx,%ebx
  80f1c5:	89 d7                	mov    %edx,%edi
  80f1c7:	89 d6                	mov    %edx,%esi
  80f1c9:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f1cb:	5b                   	pop    %ebx
  80f1cc:	5e                   	pop    %esi
  80f1cd:	5f                   	pop    %edi
  80f1ce:	5d                   	pop    %ebp
  80f1cf:	c3                   	ret    

0080f1d0 <sys_yield>:

void
sys_yield(void)
{
  80f1d0:	55                   	push   %ebp
  80f1d1:	89 e5                	mov    %esp,%ebp
  80f1d3:	57                   	push   %edi
  80f1d4:	56                   	push   %esi
  80f1d5:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f1d6:	ba 00 00 00 00       	mov    $0x0,%edx
  80f1db:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f1e0:	89 d1                	mov    %edx,%ecx
  80f1e2:	89 d3                	mov    %edx,%ebx
  80f1e4:	89 d7                	mov    %edx,%edi
  80f1e6:	89 d6                	mov    %edx,%esi
  80f1e8:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f1ea:	5b                   	pop    %ebx
  80f1eb:	5e                   	pop    %esi
  80f1ec:	5f                   	pop    %edi
  80f1ed:	5d                   	pop    %ebp
  80f1ee:	c3                   	ret    

0080f1ef <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f1ef:	55                   	push   %ebp
  80f1f0:	89 e5                	mov    %esp,%ebp
  80f1f2:	57                   	push   %edi
  80f1f3:	56                   	push   %esi
  80f1f4:	53                   	push   %ebx
  80f1f5:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f1f8:	be 00 00 00 00       	mov    $0x0,%esi
  80f1fd:	8b 55 08             	mov    0x8(%ebp),%edx
  80f200:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f203:	b8 04 00 00 00       	mov    $0x4,%eax
  80f208:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f20b:	89 f7                	mov    %esi,%edi
  80f20d:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f20f:	85 c0                	test   %eax,%eax
  80f211:	7f 08                	jg     80f21b <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f213:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f216:	5b                   	pop    %ebx
  80f217:	5e                   	pop    %esi
  80f218:	5f                   	pop    %edi
  80f219:	5d                   	pop    %ebp
  80f21a:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f21b:	83 ec 0c             	sub    $0xc,%esp
  80f21e:	50                   	push   %eax
  80f21f:	6a 04                	push   $0x4
  80f221:	68 44 3b 81 00       	push   $0x813b44
  80f226:	6a 43                	push   $0x43
  80f228:	68 61 3b 81 00       	push   $0x813b61
  80f22d:	e8 76 f3 ff ff       	call   80e5a8 <_panic>

0080f232 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f232:	55                   	push   %ebp
  80f233:	89 e5                	mov    %esp,%ebp
  80f235:	57                   	push   %edi
  80f236:	56                   	push   %esi
  80f237:	53                   	push   %ebx
  80f238:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f23b:	8b 55 08             	mov    0x8(%ebp),%edx
  80f23e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f241:	b8 05 00 00 00       	mov    $0x5,%eax
  80f246:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f249:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f24c:	8b 75 18             	mov    0x18(%ebp),%esi
  80f24f:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f251:	85 c0                	test   %eax,%eax
  80f253:	7f 08                	jg     80f25d <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f255:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f258:	5b                   	pop    %ebx
  80f259:	5e                   	pop    %esi
  80f25a:	5f                   	pop    %edi
  80f25b:	5d                   	pop    %ebp
  80f25c:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f25d:	83 ec 0c             	sub    $0xc,%esp
  80f260:	50                   	push   %eax
  80f261:	6a 05                	push   $0x5
  80f263:	68 44 3b 81 00       	push   $0x813b44
  80f268:	6a 43                	push   $0x43
  80f26a:	68 61 3b 81 00       	push   $0x813b61
  80f26f:	e8 34 f3 ff ff       	call   80e5a8 <_panic>

0080f274 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f274:	55                   	push   %ebp
  80f275:	89 e5                	mov    %esp,%ebp
  80f277:	57                   	push   %edi
  80f278:	56                   	push   %esi
  80f279:	53                   	push   %ebx
  80f27a:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f27d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f282:	8b 55 08             	mov    0x8(%ebp),%edx
  80f285:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f288:	b8 06 00 00 00       	mov    $0x6,%eax
  80f28d:	89 df                	mov    %ebx,%edi
  80f28f:	89 de                	mov    %ebx,%esi
  80f291:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f293:	85 c0                	test   %eax,%eax
  80f295:	7f 08                	jg     80f29f <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f297:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f29a:	5b                   	pop    %ebx
  80f29b:	5e                   	pop    %esi
  80f29c:	5f                   	pop    %edi
  80f29d:	5d                   	pop    %ebp
  80f29e:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f29f:	83 ec 0c             	sub    $0xc,%esp
  80f2a2:	50                   	push   %eax
  80f2a3:	6a 06                	push   $0x6
  80f2a5:	68 44 3b 81 00       	push   $0x813b44
  80f2aa:	6a 43                	push   $0x43
  80f2ac:	68 61 3b 81 00       	push   $0x813b61
  80f2b1:	e8 f2 f2 ff ff       	call   80e5a8 <_panic>

0080f2b6 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f2b6:	55                   	push   %ebp
  80f2b7:	89 e5                	mov    %esp,%ebp
  80f2b9:	57                   	push   %edi
  80f2ba:	56                   	push   %esi
  80f2bb:	53                   	push   %ebx
  80f2bc:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f2bf:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f2c4:	8b 55 08             	mov    0x8(%ebp),%edx
  80f2c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f2ca:	b8 08 00 00 00       	mov    $0x8,%eax
  80f2cf:	89 df                	mov    %ebx,%edi
  80f2d1:	89 de                	mov    %ebx,%esi
  80f2d3:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f2d5:	85 c0                	test   %eax,%eax
  80f2d7:	7f 08                	jg     80f2e1 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f2d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f2dc:	5b                   	pop    %ebx
  80f2dd:	5e                   	pop    %esi
  80f2de:	5f                   	pop    %edi
  80f2df:	5d                   	pop    %ebp
  80f2e0:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f2e1:	83 ec 0c             	sub    $0xc,%esp
  80f2e4:	50                   	push   %eax
  80f2e5:	6a 08                	push   $0x8
  80f2e7:	68 44 3b 81 00       	push   $0x813b44
  80f2ec:	6a 43                	push   $0x43
  80f2ee:	68 61 3b 81 00       	push   $0x813b61
  80f2f3:	e8 b0 f2 ff ff       	call   80e5a8 <_panic>

0080f2f8 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f2f8:	55                   	push   %ebp
  80f2f9:	89 e5                	mov    %esp,%ebp
  80f2fb:	57                   	push   %edi
  80f2fc:	56                   	push   %esi
  80f2fd:	53                   	push   %ebx
  80f2fe:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f301:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f306:	8b 55 08             	mov    0x8(%ebp),%edx
  80f309:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f30c:	b8 09 00 00 00       	mov    $0x9,%eax
  80f311:	89 df                	mov    %ebx,%edi
  80f313:	89 de                	mov    %ebx,%esi
  80f315:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f317:	85 c0                	test   %eax,%eax
  80f319:	7f 08                	jg     80f323 <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f31b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f31e:	5b                   	pop    %ebx
  80f31f:	5e                   	pop    %esi
  80f320:	5f                   	pop    %edi
  80f321:	5d                   	pop    %ebp
  80f322:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f323:	83 ec 0c             	sub    $0xc,%esp
  80f326:	50                   	push   %eax
  80f327:	6a 09                	push   $0x9
  80f329:	68 44 3b 81 00       	push   $0x813b44
  80f32e:	6a 43                	push   $0x43
  80f330:	68 61 3b 81 00       	push   $0x813b61
  80f335:	e8 6e f2 ff ff       	call   80e5a8 <_panic>

0080f33a <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f33a:	55                   	push   %ebp
  80f33b:	89 e5                	mov    %esp,%ebp
  80f33d:	57                   	push   %edi
  80f33e:	56                   	push   %esi
  80f33f:	53                   	push   %ebx
  80f340:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f343:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f348:	8b 55 08             	mov    0x8(%ebp),%edx
  80f34b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f34e:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f353:	89 df                	mov    %ebx,%edi
  80f355:	89 de                	mov    %ebx,%esi
  80f357:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f359:	85 c0                	test   %eax,%eax
  80f35b:	7f 08                	jg     80f365 <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f35d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f360:	5b                   	pop    %ebx
  80f361:	5e                   	pop    %esi
  80f362:	5f                   	pop    %edi
  80f363:	5d                   	pop    %ebp
  80f364:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f365:	83 ec 0c             	sub    $0xc,%esp
  80f368:	50                   	push   %eax
  80f369:	6a 0a                	push   $0xa
  80f36b:	68 44 3b 81 00       	push   $0x813b44
  80f370:	6a 43                	push   $0x43
  80f372:	68 61 3b 81 00       	push   $0x813b61
  80f377:	e8 2c f2 ff ff       	call   80e5a8 <_panic>

0080f37c <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f37c:	55                   	push   %ebp
  80f37d:	89 e5                	mov    %esp,%ebp
  80f37f:	57                   	push   %edi
  80f380:	56                   	push   %esi
  80f381:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f382:	8b 55 08             	mov    0x8(%ebp),%edx
  80f385:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f388:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f38d:	be 00 00 00 00       	mov    $0x0,%esi
  80f392:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f395:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f398:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f39a:	5b                   	pop    %ebx
  80f39b:	5e                   	pop    %esi
  80f39c:	5f                   	pop    %edi
  80f39d:	5d                   	pop    %ebp
  80f39e:	c3                   	ret    

0080f39f <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f39f:	55                   	push   %ebp
  80f3a0:	89 e5                	mov    %esp,%ebp
  80f3a2:	57                   	push   %edi
  80f3a3:	56                   	push   %esi
  80f3a4:	53                   	push   %ebx
  80f3a5:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3a8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f3ad:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3b0:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f3b5:	89 cb                	mov    %ecx,%ebx
  80f3b7:	89 cf                	mov    %ecx,%edi
  80f3b9:	89 ce                	mov    %ecx,%esi
  80f3bb:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f3bd:	85 c0                	test   %eax,%eax
  80f3bf:	7f 08                	jg     80f3c9 <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f3c1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3c4:	5b                   	pop    %ebx
  80f3c5:	5e                   	pop    %esi
  80f3c6:	5f                   	pop    %edi
  80f3c7:	5d                   	pop    %ebp
  80f3c8:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3c9:	83 ec 0c             	sub    $0xc,%esp
  80f3cc:	50                   	push   %eax
  80f3cd:	6a 0d                	push   $0xd
  80f3cf:	68 44 3b 81 00       	push   $0x813b44
  80f3d4:	6a 43                	push   $0x43
  80f3d6:	68 61 3b 81 00       	push   $0x813b61
  80f3db:	e8 c8 f1 ff ff       	call   80e5a8 <_panic>

0080f3e0 <sys_map_kernel_page>:

int
sys_map_kernel_page(void* kpage, void* va)
{
  80f3e0:	55                   	push   %ebp
  80f3e1:	89 e5                	mov    %esp,%ebp
  80f3e3:	57                   	push   %edi
  80f3e4:	56                   	push   %esi
  80f3e5:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3e6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f3eb:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3f1:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f3f6:	89 df                	mov    %ebx,%edi
  80f3f8:	89 de                	mov    %ebx,%esi
  80f3fa:	cd 30                	int    $0x30
	return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}
  80f3fc:	5b                   	pop    %ebx
  80f3fd:	5e                   	pop    %esi
  80f3fe:	5f                   	pop    %edi
  80f3ff:	5d                   	pop    %ebp
  80f400:	c3                   	ret    

0080f401 <sys_sbrk>:

int
sys_sbrk(uint32_t inc)
{
  80f401:	55                   	push   %ebp
  80f402:	89 e5                	mov    %esp,%ebp
  80f404:	57                   	push   %edi
  80f405:	56                   	push   %esi
  80f406:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f407:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f40c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f40f:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f414:	89 cb                	mov    %ecx,%ebx
  80f416:	89 cf                	mov    %ecx,%edi
  80f418:	89 ce                	mov    %ecx,%esi
  80f41a:	cd 30                	int    $0x30
	return syscall(SYS_sbrk, 0, (uint32_t)inc, (uint32_t)0, 0, 0, 0);
}
  80f41c:	5b                   	pop    %ebx
  80f41d:	5e                   	pop    %esi
  80f41e:	5f                   	pop    %edi
  80f41f:	5d                   	pop    %ebp
  80f420:	c3                   	ret    

0080f421 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f421:	55                   	push   %ebp
  80f422:	89 e5                	mov    %esp,%ebp
  80f424:	57                   	push   %edi
  80f425:	56                   	push   %esi
  80f426:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f427:	ba 00 00 00 00       	mov    $0x0,%edx
  80f42c:	b8 10 00 00 00       	mov    $0x10,%eax
  80f431:	89 d1                	mov    %edx,%ecx
  80f433:	89 d3                	mov    %edx,%ebx
  80f435:	89 d7                	mov    %edx,%edi
  80f437:	89 d6                	mov    %edx,%esi
  80f439:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f43b:	5b                   	pop    %ebx
  80f43c:	5e                   	pop    %esi
  80f43d:	5f                   	pop    %edi
  80f43e:	5d                   	pop    %ebp
  80f43f:	c3                   	ret    

0080f440 <sys_net_send>:

int
sys_net_send(const void *buf, uint32_t len)
{
  80f440:	55                   	push   %ebp
  80f441:	89 e5                	mov    %esp,%ebp
  80f443:	57                   	push   %edi
  80f444:	56                   	push   %esi
  80f445:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f446:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f44b:	8b 55 08             	mov    0x8(%ebp),%edx
  80f44e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f451:	b8 11 00 00 00       	mov    $0x11,%eax
  80f456:	89 df                	mov    %ebx,%edi
  80f458:	89 de                	mov    %ebx,%esi
  80f45a:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_send, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f45c:	5b                   	pop    %ebx
  80f45d:	5e                   	pop    %esi
  80f45e:	5f                   	pop    %edi
  80f45f:	5d                   	pop    %ebp
  80f460:	c3                   	ret    

0080f461 <sys_net_recv>:

int
sys_net_recv(void *buf, uint32_t len)
{
  80f461:	55                   	push   %ebp
  80f462:	89 e5                	mov    %esp,%ebp
  80f464:	57                   	push   %edi
  80f465:	56                   	push   %esi
  80f466:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f467:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f46c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f46f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f472:	b8 12 00 00 00       	mov    $0x12,%eax
  80f477:	89 df                	mov    %ebx,%edi
  80f479:	89 de                	mov    %ebx,%esi
  80f47b:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_recv, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f47d:	5b                   	pop    %ebx
  80f47e:	5e                   	pop    %esi
  80f47f:	5f                   	pop    %edi
  80f480:	5d                   	pop    %ebp
  80f481:	c3                   	ret    

0080f482 <sys_clear_access_bit>:
int
sys_clear_access_bit(envid_t envid, void *va)
{
  80f482:	55                   	push   %ebp
  80f483:	89 e5                	mov    %esp,%ebp
  80f485:	57                   	push   %edi
  80f486:	56                   	push   %esi
  80f487:	53                   	push   %ebx
  80f488:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f48b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f490:	8b 55 08             	mov    0x8(%ebp),%edx
  80f493:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f496:	b8 13 00 00 00       	mov    $0x13,%eax
  80f49b:	89 df                	mov    %ebx,%edi
  80f49d:	89 de                	mov    %ebx,%esi
  80f49f:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4a1:	85 c0                	test   %eax,%eax
  80f4a3:	7f 08                	jg     80f4ad <sys_clear_access_bit+0x2b>
	return syscall(SYS_clear_access_bit, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f4a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4a8:	5b                   	pop    %ebx
  80f4a9:	5e                   	pop    %esi
  80f4aa:	5f                   	pop    %edi
  80f4ab:	5d                   	pop    %ebp
  80f4ac:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4ad:	83 ec 0c             	sub    $0xc,%esp
  80f4b0:	50                   	push   %eax
  80f4b1:	6a 13                	push   $0x13
  80f4b3:	68 44 3b 81 00       	push   $0x813b44
  80f4b8:	6a 43                	push   $0x43
  80f4ba:	68 61 3b 81 00       	push   $0x813b61
  80f4bf:	e8 e4 f0 ff ff       	call   80e5a8 <_panic>

0080f4c4 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80f4c4:	55                   	push   %ebp
  80f4c5:	89 e5                	mov    %esp,%ebp
  80f4c7:	53                   	push   %ebx
  80f4c8:	83 ec 04             	sub    $0x4,%esp
  80f4cb:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80f4ce:	8b 02                	mov    (%edx),%eax
	// copy-on-write page.  If not, panic.
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).
	// LAB 4: Your code here.
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f4d0:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80f4d4:	0f 84 99 00 00 00    	je     80f573 <pgfault+0xaf>
  80f4da:	89 c2                	mov    %eax,%edx
  80f4dc:	c1 ea 16             	shr    $0x16,%edx
  80f4df:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f4e6:	f6 c2 01             	test   $0x1,%dl
  80f4e9:	0f 84 84 00 00 00    	je     80f573 <pgfault+0xaf>
		((uvpt[PGNUM(addr)] & (PTE_P | PTE_COW)) 
  80f4ef:	89 c2                	mov    %eax,%edx
  80f4f1:	c1 ea 0c             	shr    $0xc,%edx
  80f4f4:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f4fb:	81 e2 01 08 00 00    	and    $0x801,%edx
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f501:	81 fa 01 08 00 00    	cmp    $0x801,%edx
  80f507:	75 6a                	jne    80f573 <pgfault+0xaf>
	// Allocate a new page, map it at a temporary location (PFTEMP),
	// copy the data from the old page to the new page, then move the new
	// page to the old page's address.
	// Hint:
	//   You should make three system calls.
	addr = ROUNDDOWN(addr, PGSIZE);
  80f509:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f50e:	89 c3                	mov    %eax,%ebx
	int ret;
	ret = sys_page_alloc(0, (void *)PFTEMP, PTE_P | PTE_U | PTE_W);
  80f510:	83 ec 04             	sub    $0x4,%esp
  80f513:	6a 07                	push   $0x7
  80f515:	68 00 f0 7f 00       	push   $0x7ff000
  80f51a:	6a 00                	push   $0x0
  80f51c:	e8 ce fc ff ff       	call   80f1ef <sys_page_alloc>
	if(ret < 0)
  80f521:	83 c4 10             	add    $0x10,%esp
  80f524:	85 c0                	test   %eax,%eax
  80f526:	78 5f                	js     80f587 <pgfault+0xc3>
		panic("panic in sys_page_alloc()\n");
	
	memcpy((void *)PFTEMP, (void *)addr, PGSIZE);
  80f528:	83 ec 04             	sub    $0x4,%esp
  80f52b:	68 00 10 00 00       	push   $0x1000
  80f530:	53                   	push   %ebx
  80f531:	68 00 f0 7f 00       	push   $0x7ff000
  80f536:	e8 b2 fa ff ff       	call   80efed <memcpy>
	ret = sys_page_map(0, PFTEMP, 0, addr,  PTE_P | PTE_U | PTE_W);
  80f53b:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f542:	53                   	push   %ebx
  80f543:	6a 00                	push   $0x0
  80f545:	68 00 f0 7f 00       	push   $0x7ff000
  80f54a:	6a 00                	push   $0x0
  80f54c:	e8 e1 fc ff ff       	call   80f232 <sys_page_map>
	if(ret < 0)
  80f551:	83 c4 20             	add    $0x20,%esp
  80f554:	85 c0                	test   %eax,%eax
  80f556:	78 43                	js     80f59b <pgfault+0xd7>
		panic("panic in sys_page_map()\n");
	ret = sys_page_unmap(0, (void *)PFTEMP);
  80f558:	83 ec 08             	sub    $0x8,%esp
  80f55b:	68 00 f0 7f 00       	push   $0x7ff000
  80f560:	6a 00                	push   $0x0
  80f562:	e8 0d fd ff ff       	call   80f274 <sys_page_unmap>
	if(ret < 0)
  80f567:	83 c4 10             	add    $0x10,%esp
  80f56a:	85 c0                	test   %eax,%eax
  80f56c:	78 41                	js     80f5af <pgfault+0xeb>
		panic("panic in sys_page_unmap()\n");
	// LAB 4: Your code here.

	// panic("pgfault not implemented");

}
  80f56e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f571:	c9                   	leave  
  80f572:	c3                   	ret    
		panic("panic at pgfault()\n");
  80f573:	83 ec 04             	sub    $0x4,%esp
  80f576:	68 6f 3b 81 00       	push   $0x813b6f
  80f57b:	6a 26                	push   $0x26
  80f57d:	68 83 3b 81 00       	push   $0x813b83
  80f582:	e8 21 f0 ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_page_alloc()\n");
  80f587:	83 ec 04             	sub    $0x4,%esp
  80f58a:	68 8e 3b 81 00       	push   $0x813b8e
  80f58f:	6a 31                	push   $0x31
  80f591:	68 83 3b 81 00       	push   $0x813b83
  80f596:	e8 0d f0 ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_page_map()\n");
  80f59b:	83 ec 04             	sub    $0x4,%esp
  80f59e:	68 a9 3b 81 00       	push   $0x813ba9
  80f5a3:	6a 36                	push   $0x36
  80f5a5:	68 83 3b 81 00       	push   $0x813b83
  80f5aa:	e8 f9 ef ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_page_unmap()\n");
  80f5af:	83 ec 04             	sub    $0x4,%esp
  80f5b2:	68 c2 3b 81 00       	push   $0x813bc2
  80f5b7:	6a 39                	push   $0x39
  80f5b9:	68 83 3b 81 00       	push   $0x813b83
  80f5be:	e8 e5 ef ff ff       	call   80e5a8 <_panic>

0080f5c3 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  80f5c3:	55                   	push   %ebp
  80f5c4:	89 e5                	mov    %esp,%ebp
  80f5c6:	56                   	push   %esi
  80f5c7:	53                   	push   %ebx
  80f5c8:	89 c6                	mov    %eax,%esi
  80f5ca:	89 d3                	mov    %edx,%ebx
	cprintf("in %s\n", __FUNCTION__);
  80f5cc:	83 ec 08             	sub    $0x8,%esp
  80f5cf:	68 60 3c 81 00       	push   $0x813c60
  80f5d4:	68 85 37 81 00       	push   $0x813785
  80f5d9:	e8 c0 f0 ff ff       	call   80e69e <cprintf>
	int r;
	//lab5 bug?
	if((uvpt[pn]) & PTE_SHARE){
  80f5de:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  80f5e5:	83 c4 10             	add    $0x10,%esp
  80f5e8:	f6 c4 04             	test   $0x4,%ah
  80f5eb:	75 45                	jne    80f632 <duppage+0x6f>
							uvpt[pn] & PTE_SYSCALL);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_W)) == (PTE_P | PTE_U | PTE_W)){
  80f5ed:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  80f5f4:	83 e0 07             	and    $0x7,%eax
  80f5f7:	83 f8 07             	cmp    $0x7,%eax
  80f5fa:	74 6e                	je     80f66a <duppage+0xa7>
						 PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_COW)) == (PTE_P | PTE_U | PTE_COW)){
  80f5fc:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  80f603:	25 05 08 00 00       	and    $0x805,%eax
  80f608:	3d 05 08 00 00       	cmp    $0x805,%eax
  80f60d:	0f 84 b5 00 00 00    	je     80f6c8 <duppage+0x105>
						PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U)) == (PTE_P | PTE_U)){
  80f613:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  80f61a:	83 e0 05             	and    $0x5,%eax
  80f61d:	83 f8 05             	cmp    $0x5,%eax
  80f620:	0f 84 d6 00 00 00    	je     80f6fc <duppage+0x139>
	}

	// LAB 4: Your code here.
	// panic("duppage not implemented");
	return 0;
}
  80f626:	b8 00 00 00 00       	mov    $0x0,%eax
  80f62b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80f62e:	5b                   	pop    %ebx
  80f62f:	5e                   	pop    %esi
  80f630:	5d                   	pop    %ebp
  80f631:	c3                   	ret    
							uvpt[pn] & PTE_SYSCALL);
  80f632:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f639:	c1 e3 0c             	shl    $0xc,%ebx
  80f63c:	83 ec 0c             	sub    $0xc,%esp
  80f63f:	25 07 0e 00 00       	and    $0xe07,%eax
  80f644:	50                   	push   %eax
  80f645:	53                   	push   %ebx
  80f646:	56                   	push   %esi
  80f647:	53                   	push   %ebx
  80f648:	6a 00                	push   $0x0
  80f64a:	e8 e3 fb ff ff       	call   80f232 <sys_page_map>
		if(r < 0)
  80f64f:	83 c4 20             	add    $0x20,%esp
  80f652:	85 c0                	test   %eax,%eax
  80f654:	79 d0                	jns    80f626 <duppage+0x63>
			panic("sys_page_map() panic\n");
  80f656:	83 ec 04             	sub    $0x4,%esp
  80f659:	68 dd 3b 81 00       	push   $0x813bdd
  80f65e:	6a 55                	push   $0x55
  80f660:	68 83 3b 81 00       	push   $0x813b83
  80f665:	e8 3e ef ff ff       	call   80e5a8 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f66a:	c1 e3 0c             	shl    $0xc,%ebx
  80f66d:	83 ec 0c             	sub    $0xc,%esp
  80f670:	68 05 08 00 00       	push   $0x805
  80f675:	53                   	push   %ebx
  80f676:	56                   	push   %esi
  80f677:	53                   	push   %ebx
  80f678:	6a 00                	push   $0x0
  80f67a:	e8 b3 fb ff ff       	call   80f232 <sys_page_map>
		if(r < 0)
  80f67f:	83 c4 20             	add    $0x20,%esp
  80f682:	85 c0                	test   %eax,%eax
  80f684:	78 2e                	js     80f6b4 <duppage+0xf1>
		r = sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE),
  80f686:	83 ec 0c             	sub    $0xc,%esp
  80f689:	68 05 08 00 00       	push   $0x805
  80f68e:	53                   	push   %ebx
  80f68f:	6a 00                	push   $0x0
  80f691:	53                   	push   %ebx
  80f692:	6a 00                	push   $0x0
  80f694:	e8 99 fb ff ff       	call   80f232 <sys_page_map>
		if(r < 0)
  80f699:	83 c4 20             	add    $0x20,%esp
  80f69c:	85 c0                	test   %eax,%eax
  80f69e:	79 86                	jns    80f626 <duppage+0x63>
			panic("sys_page_map() panic\n");
  80f6a0:	83 ec 04             	sub    $0x4,%esp
  80f6a3:	68 dd 3b 81 00       	push   $0x813bdd
  80f6a8:	6a 60                	push   $0x60
  80f6aa:	68 83 3b 81 00       	push   $0x813b83
  80f6af:	e8 f4 ee ff ff       	call   80e5a8 <_panic>
			panic("sys_page_map() panic\n");
  80f6b4:	83 ec 04             	sub    $0x4,%esp
  80f6b7:	68 dd 3b 81 00       	push   $0x813bdd
  80f6bc:	6a 5c                	push   $0x5c
  80f6be:	68 83 3b 81 00       	push   $0x813b83
  80f6c3:	e8 e0 ee ff ff       	call   80e5a8 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f6c8:	c1 e3 0c             	shl    $0xc,%ebx
  80f6cb:	83 ec 0c             	sub    $0xc,%esp
  80f6ce:	68 05 08 00 00       	push   $0x805
  80f6d3:	53                   	push   %ebx
  80f6d4:	56                   	push   %esi
  80f6d5:	53                   	push   %ebx
  80f6d6:	6a 00                	push   $0x0
  80f6d8:	e8 55 fb ff ff       	call   80f232 <sys_page_map>
		if(r < 0)
  80f6dd:	83 c4 20             	add    $0x20,%esp
  80f6e0:	85 c0                	test   %eax,%eax
  80f6e2:	0f 89 3e ff ff ff    	jns    80f626 <duppage+0x63>
			panic("sys_page_map() panic\n");
  80f6e8:	83 ec 04             	sub    $0x4,%esp
  80f6eb:	68 dd 3b 81 00       	push   $0x813bdd
  80f6f0:	6a 67                	push   $0x67
  80f6f2:	68 83 3b 81 00       	push   $0x813b83
  80f6f7:	e8 ac ee ff ff       	call   80e5a8 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f6fc:	c1 e3 0c             	shl    $0xc,%ebx
  80f6ff:	83 ec 0c             	sub    $0xc,%esp
  80f702:	6a 05                	push   $0x5
  80f704:	53                   	push   %ebx
  80f705:	56                   	push   %esi
  80f706:	53                   	push   %ebx
  80f707:	6a 00                	push   $0x0
  80f709:	e8 24 fb ff ff       	call   80f232 <sys_page_map>
		if(r < 0)
  80f70e:	83 c4 20             	add    $0x20,%esp
  80f711:	85 c0                	test   %eax,%eax
  80f713:	0f 89 0d ff ff ff    	jns    80f626 <duppage+0x63>
			panic("sys_page_map() panic\n");
  80f719:	83 ec 04             	sub    $0x4,%esp
  80f71c:	68 dd 3b 81 00       	push   $0x813bdd
  80f721:	6a 6e                	push   $0x6e
  80f723:	68 83 3b 81 00       	push   $0x813b83
  80f728:	e8 7b ee ff ff       	call   80e5a8 <_panic>

0080f72d <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f72d:	55                   	push   %ebp
  80f72e:	89 e5                	mov    %esp,%ebp
  80f730:	57                   	push   %edi
  80f731:	56                   	push   %esi
  80f732:	53                   	push   %ebx
  80f733:	83 ec 18             	sub    $0x18,%esp
	int ret;
	set_pgfault_handler(pgfault);
  80f736:	68 c4 f4 80 00       	push   $0x80f4c4
  80f73b:	e8 6a 17 00 00       	call   810eaa <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f740:	b8 07 00 00 00       	mov    $0x7,%eax
  80f745:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f747:	83 c4 10             	add    $0x10,%esp
  80f74a:	85 c0                	test   %eax,%eax
  80f74c:	78 27                	js     80f775 <fork+0x48>
  80f74e:	89 c6                	mov    %eax,%esi
  80f750:	89 c7                	mov    %eax,%edi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f752:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f757:	75 48                	jne    80f7a1 <fork+0x74>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f759:	e8 53 fa ff ff       	call   80f1b1 <sys_getenvid>
  80f75e:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f763:	c1 e0 07             	shl    $0x7,%eax
  80f766:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f76b:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f770:	e9 90 00 00 00       	jmp    80f805 <fork+0xd8>
		panic("the fork panic! at sys_exofork()\n");
  80f775:	83 ec 04             	sub    $0x4,%esp
  80f778:	68 f4 3b 81 00       	push   $0x813bf4
  80f77d:	68 8d 00 00 00       	push   $0x8d
  80f782:	68 83 3b 81 00       	push   $0x813b83
  80f787:	e8 1c ee ff ff       	call   80e5a8 <_panic>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
			duppage(child_envid, PGNUM(i));
  80f78c:	89 f8                	mov    %edi,%eax
  80f78e:	e8 30 fe ff ff       	call   80f5c3 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f793:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f799:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f79f:	74 26                	je     80f7c7 <fork+0x9a>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
  80f7a1:	89 d8                	mov    %ebx,%eax
  80f7a3:	c1 e8 16             	shr    $0x16,%eax
  80f7a6:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f7ad:	a8 01                	test   $0x1,%al
  80f7af:	74 e2                	je     80f793 <fork+0x66>
  80f7b1:	89 da                	mov    %ebx,%edx
  80f7b3:	c1 ea 0c             	shr    $0xc,%edx
  80f7b6:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f7bd:	83 e0 05             	and    $0x5,%eax
  80f7c0:	83 f8 05             	cmp    $0x5,%eax
  80f7c3:	75 ce                	jne    80f793 <fork+0x66>
  80f7c5:	eb c5                	jmp    80f78c <fork+0x5f>
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80f7c7:	83 ec 04             	sub    $0x4,%esp
  80f7ca:	6a 07                	push   $0x7
  80f7cc:	68 00 f0 bf ee       	push   $0xeebff000
  80f7d1:	56                   	push   %esi
  80f7d2:	e8 18 fa ff ff       	call   80f1ef <sys_page_alloc>
	if(ret < 0)
  80f7d7:	83 c4 10             	add    $0x10,%esp
  80f7da:	85 c0                	test   %eax,%eax
  80f7dc:	78 31                	js     80f80f <fork+0xe2>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80f7de:	83 ec 08             	sub    $0x8,%esp
  80f7e1:	68 19 0f 81 00       	push   $0x810f19
  80f7e6:	56                   	push   %esi
  80f7e7:	e8 4e fb ff ff       	call   80f33a <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80f7ec:	83 c4 10             	add    $0x10,%esp
  80f7ef:	85 c0                	test   %eax,%eax
  80f7f1:	78 33                	js     80f826 <fork+0xf9>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80f7f3:	83 ec 08             	sub    $0x8,%esp
  80f7f6:	6a 02                	push   $0x2
  80f7f8:	56                   	push   %esi
  80f7f9:	e8 b8 fa ff ff       	call   80f2b6 <sys_env_set_status>
	if(ret < 0)
  80f7fe:	83 c4 10             	add    $0x10,%esp
  80f801:	85 c0                	test   %eax,%eax
  80f803:	78 38                	js     80f83d <fork+0x110>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
	// LAB 4: Your code here.
	// panic("fork not implemented");
}
  80f805:	89 f0                	mov    %esi,%eax
  80f807:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f80a:	5b                   	pop    %ebx
  80f80b:	5e                   	pop    %esi
  80f80c:	5f                   	pop    %edi
  80f80d:	5d                   	pop    %ebp
  80f80e:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80f80f:	83 ec 04             	sub    $0x4,%esp
  80f812:	68 8e 3b 81 00       	push   $0x813b8e
  80f817:	68 99 00 00 00       	push   $0x99
  80f81c:	68 83 3b 81 00       	push   $0x813b83
  80f821:	e8 82 ed ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80f826:	83 ec 04             	sub    $0x4,%esp
  80f829:	68 18 3c 81 00       	push   $0x813c18
  80f82e:	68 9c 00 00 00       	push   $0x9c
  80f833:	68 83 3b 81 00       	push   $0x813b83
  80f838:	e8 6b ed ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_env_set_status()\n");
  80f83d:	83 ec 04             	sub    $0x4,%esp
  80f840:	68 40 3c 81 00       	push   $0x813c40
  80f845:	68 9f 00 00 00       	push   $0x9f
  80f84a:	68 83 3b 81 00       	push   $0x813b83
  80f84f:	e8 54 ed ff ff       	call   80e5a8 <_panic>

0080f854 <sfork>:

// Challenge!
int
sfork(void)
{
  80f854:	55                   	push   %ebp
  80f855:	89 e5                	mov    %esp,%ebp
  80f857:	57                   	push   %edi
  80f858:	56                   	push   %esi
  80f859:	53                   	push   %ebx
  80f85a:	83 ec 18             	sub    $0x18,%esp
	// panic("sfork not implemented");
	// envid_t child_envid = sys_exofork();
	// return -E_INVAL;
	int ret;
	set_pgfault_handler(pgfault);
  80f85d:	68 c4 f4 80 00       	push   $0x80f4c4
  80f862:	e8 43 16 00 00       	call   810eaa <set_pgfault_handler>
  80f867:	b8 07 00 00 00       	mov    $0x7,%eax
  80f86c:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f86e:	83 c4 10             	add    $0x10,%esp
  80f871:	85 c0                	test   %eax,%eax
  80f873:	78 27                	js     80f89c <sfork+0x48>
  80f875:	89 c7                	mov    %eax,%edi
  80f877:	89 c6                	mov    %eax,%esi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f879:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f87e:	75 55                	jne    80f8d5 <sfork+0x81>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f880:	e8 2c f9 ff ff       	call   80f1b1 <sys_getenvid>
  80f885:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f88a:	c1 e0 07             	shl    $0x7,%eax
  80f88d:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f892:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f897:	e9 d4 00 00 00       	jmp    80f970 <sfork+0x11c>
		panic("the fork panic! at sys_exofork()\n");
  80f89c:	83 ec 04             	sub    $0x4,%esp
  80f89f:	68 f4 3b 81 00       	push   $0x813bf4
  80f8a4:	68 b0 00 00 00       	push   $0xb0
  80f8a9:	68 83 3b 81 00       	push   $0x813b83
  80f8ae:	e8 f5 ec ff ff       	call   80e5a8 <_panic>
		if(i == (USTACKTOP - PGSIZE))
			duppage(child_envid, PGNUM(i));
  80f8b3:	ba fd eb 0e 00       	mov    $0xeebfd,%edx
  80f8b8:	89 f0                	mov    %esi,%eax
  80f8ba:	e8 04 fd ff ff       	call   80f5c3 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f8bf:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f8c5:	81 fb ff df bf ee    	cmp    $0xeebfdfff,%ebx
  80f8cb:	77 65                	ja     80f932 <sfork+0xde>
		if(i == (USTACKTOP - PGSIZE))
  80f8cd:	81 fb 00 d0 bf ee    	cmp    $0xeebfd000,%ebx
  80f8d3:	74 de                	je     80f8b3 <sfork+0x5f>
		else if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U))){
  80f8d5:	89 d8                	mov    %ebx,%eax
  80f8d7:	c1 e8 16             	shr    $0x16,%eax
  80f8da:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f8e1:	a8 01                	test   $0x1,%al
  80f8e3:	74 da                	je     80f8bf <sfork+0x6b>
  80f8e5:	89 da                	mov    %ebx,%edx
  80f8e7:	c1 ea 0c             	shr    $0xc,%edx
  80f8ea:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f8f1:	83 e0 05             	and    $0x5,%eax
  80f8f4:	83 f8 05             	cmp    $0x5,%eax
  80f8f7:	75 c6                	jne    80f8bf <sfork+0x6b>
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
						((uvpt[PGNUM(i)] & (PTE_P | PTE_U | PTE_W)))))
  80f8f9:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
  80f900:	c1 e2 0c             	shl    $0xc,%edx
  80f903:	83 ec 0c             	sub    $0xc,%esp
  80f906:	83 e0 07             	and    $0x7,%eax
  80f909:	50                   	push   %eax
  80f90a:	52                   	push   %edx
  80f90b:	56                   	push   %esi
  80f90c:	52                   	push   %edx
  80f90d:	6a 00                	push   $0x0
  80f90f:	e8 1e f9 ff ff       	call   80f232 <sys_page_map>
  80f914:	83 c4 20             	add    $0x20,%esp
  80f917:	85 c0                	test   %eax,%eax
  80f919:	74 a4                	je     80f8bf <sfork+0x6b>
				panic("sys_page_map() panic\n");
  80f91b:	83 ec 04             	sub    $0x4,%esp
  80f91e:	68 dd 3b 81 00       	push   $0x813bdd
  80f923:	68 bb 00 00 00       	push   $0xbb
  80f928:	68 83 3b 81 00       	push   $0x813b83
  80f92d:	e8 76 ec ff ff       	call   80e5a8 <_panic>
		}
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80f932:	83 ec 04             	sub    $0x4,%esp
  80f935:	6a 07                	push   $0x7
  80f937:	68 00 f0 bf ee       	push   $0xeebff000
  80f93c:	57                   	push   %edi
  80f93d:	e8 ad f8 ff ff       	call   80f1ef <sys_page_alloc>
	if(ret < 0)
  80f942:	83 c4 10             	add    $0x10,%esp
  80f945:	85 c0                	test   %eax,%eax
  80f947:	78 31                	js     80f97a <sfork+0x126>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80f949:	83 ec 08             	sub    $0x8,%esp
  80f94c:	68 19 0f 81 00       	push   $0x810f19
  80f951:	57                   	push   %edi
  80f952:	e8 e3 f9 ff ff       	call   80f33a <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80f957:	83 c4 10             	add    $0x10,%esp
  80f95a:	85 c0                	test   %eax,%eax
  80f95c:	78 33                	js     80f991 <sfork+0x13d>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80f95e:	83 ec 08             	sub    $0x8,%esp
  80f961:	6a 02                	push   $0x2
  80f963:	57                   	push   %edi
  80f964:	e8 4d f9 ff ff       	call   80f2b6 <sys_env_set_status>
	if(ret < 0)
  80f969:	83 c4 10             	add    $0x10,%esp
  80f96c:	85 c0                	test   %eax,%eax
  80f96e:	78 38                	js     80f9a8 <sfork+0x154>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
  80f970:	89 f8                	mov    %edi,%eax
  80f972:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f975:	5b                   	pop    %ebx
  80f976:	5e                   	pop    %esi
  80f977:	5f                   	pop    %edi
  80f978:	5d                   	pop    %ebp
  80f979:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80f97a:	83 ec 04             	sub    $0x4,%esp
  80f97d:	68 8e 3b 81 00       	push   $0x813b8e
  80f982:	68 c1 00 00 00       	push   $0xc1
  80f987:	68 83 3b 81 00       	push   $0x813b83
  80f98c:	e8 17 ec ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80f991:	83 ec 04             	sub    $0x4,%esp
  80f994:	68 18 3c 81 00       	push   $0x813c18
  80f999:	68 c4 00 00 00       	push   $0xc4
  80f99e:	68 83 3b 81 00       	push   $0x813b83
  80f9a3:	e8 00 ec ff ff       	call   80e5a8 <_panic>
		panic("panic in sys_env_set_status()\n");
  80f9a8:	83 ec 04             	sub    $0x4,%esp
  80f9ab:	68 40 3c 81 00       	push   $0x813c40
  80f9b0:	68 c7 00 00 00       	push   $0xc7
  80f9b5:	68 83 3b 81 00       	push   $0x813b83
  80f9ba:	e8 e9 eb ff ff       	call   80e5a8 <_panic>

0080f9bf <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80f9bf:	55                   	push   %ebp
  80f9c0:	89 e5                	mov    %esp,%ebp
  80f9c2:	56                   	push   %esi
  80f9c3:	53                   	push   %ebx
  80f9c4:	8b 75 08             	mov    0x8(%ebp),%esi
  80f9c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9ca:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");
	int ret;
	if(!pg)
  80f9cd:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80f9cf:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80f9d4:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  80f9d7:	83 ec 0c             	sub    $0xc,%esp
  80f9da:	50                   	push   %eax
  80f9db:	e8 bf f9 ff ff       	call   80f39f <sys_ipc_recv>
	if(ret < 0){
  80f9e0:	83 c4 10             	add    $0x10,%esp
  80f9e3:	85 c0                	test   %eax,%eax
  80f9e5:	78 2b                	js     80fa12 <ipc_recv+0x53>
			*from_env_store = 0;
		if(perm_store)
			*perm_store = 0;
		return ret;
	}
	if(from_env_store){
  80f9e7:	85 f6                	test   %esi,%esi
  80f9e9:	74 0a                	je     80f9f5 <ipc_recv+0x36>
		// *from_env_store = getthisenv()->env_ipc_from;
		*from_env_store = thisenv->env_ipc_from;
  80f9eb:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f9f0:	8b 40 74             	mov    0x74(%eax),%eax
  80f9f3:	89 06                	mov    %eax,(%esi)
	}
	if(perm_store){
  80f9f5:	85 db                	test   %ebx,%ebx
  80f9f7:	74 0a                	je     80fa03 <ipc_recv+0x44>
		// *perm_store = getthisenv()->env_ipc_perm;
		*perm_store = thisenv->env_ipc_perm;
  80f9f9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80f9fe:	8b 40 78             	mov    0x78(%eax),%eax
  80fa01:	89 03                	mov    %eax,(%ebx)
	}
	// return getthisenv()->env_ipc_value;
	return thisenv->env_ipc_value;
  80fa03:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fa08:	8b 40 70             	mov    0x70(%eax),%eax
}
  80fa0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fa0e:	5b                   	pop    %ebx
  80fa0f:	5e                   	pop    %esi
  80fa10:	5d                   	pop    %ebp
  80fa11:	c3                   	ret    
		if(from_env_store)
  80fa12:	85 f6                	test   %esi,%esi
  80fa14:	74 06                	je     80fa1c <ipc_recv+0x5d>
			*from_env_store = 0;
  80fa16:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store)
  80fa1c:	85 db                	test   %ebx,%ebx
  80fa1e:	74 eb                	je     80fa0b <ipc_recv+0x4c>
			*perm_store = 0;
  80fa20:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80fa26:	eb e3                	jmp    80fa0b <ipc_recv+0x4c>

0080fa28 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{	
  80fa28:	55                   	push   %ebp
  80fa29:	89 e5                	mov    %esp,%ebp
  80fa2b:	57                   	push   %edi
  80fa2c:	56                   	push   %esi
  80fa2d:	53                   	push   %ebx
  80fa2e:	83 ec 0c             	sub    $0xc,%esp
  80fa31:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fa34:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fa37:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int ret;
	if(!pg)
		pg = (void *)UTOP;
  80fa3a:	85 db                	test   %ebx,%ebx
  80fa3c:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80fa41:	0f 44 d8             	cmove  %eax,%ebx
  80fa44:	eb 05                	jmp    80fa4b <ipc_send+0x23>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
			panic("panic at ipc_send()\n");
		}
		sys_yield();
  80fa46:	e8 85 f7 ff ff       	call   80f1d0 <sys_yield>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
  80fa4b:	ff 75 14             	pushl  0x14(%ebp)
  80fa4e:	53                   	push   %ebx
  80fa4f:	56                   	push   %esi
  80fa50:	57                   	push   %edi
  80fa51:	e8 26 f9 ff ff       	call   80f37c <sys_ipc_try_send>
  80fa56:	83 c4 10             	add    $0x10,%esp
  80fa59:	85 c0                	test   %eax,%eax
  80fa5b:	74 1b                	je     80fa78 <ipc_send+0x50>
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
  80fa5d:	79 e7                	jns    80fa46 <ipc_send+0x1e>
  80fa5f:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80fa62:	74 e2                	je     80fa46 <ipc_send+0x1e>
			panic("panic at ipc_send()\n");
  80fa64:	83 ec 04             	sub    $0x4,%esp
  80fa67:	68 68 3c 81 00       	push   $0x813c68
  80fa6c:	6a 48                	push   $0x48
  80fa6e:	68 7d 3c 81 00       	push   $0x813c7d
  80fa73:	e8 30 eb ff ff       	call   80e5a8 <_panic>
	}
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");
}
  80fa78:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fa7b:	5b                   	pop    %ebx
  80fa7c:	5e                   	pop    %esi
  80fa7d:	5f                   	pop    %edi
  80fa7e:	5d                   	pop    %ebp
  80fa7f:	c3                   	ret    

0080fa80 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80fa80:	55                   	push   %ebp
  80fa81:	89 e5                	mov    %esp,%ebp
  80fa83:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80fa86:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80fa8b:	89 c2                	mov    %eax,%edx
  80fa8d:	c1 e2 07             	shl    $0x7,%edx
  80fa90:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80fa96:	8b 52 50             	mov    0x50(%edx),%edx
  80fa99:	39 ca                	cmp    %ecx,%edx
  80fa9b:	74 11                	je     80faae <ipc_find_env+0x2e>
	for (i = 0; i < NENV; i++)
  80fa9d:	83 c0 01             	add    $0x1,%eax
  80faa0:	3d 00 04 00 00       	cmp    $0x400,%eax
  80faa5:	75 e4                	jne    80fa8b <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80faa7:	b8 00 00 00 00       	mov    $0x0,%eax
  80faac:	eb 0b                	jmp    80fab9 <ipc_find_env+0x39>
			return envs[i].env_id;
  80faae:	c1 e0 07             	shl    $0x7,%eax
  80fab1:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fab6:	8b 40 48             	mov    0x48(%eax),%eax
}
  80fab9:	5d                   	pop    %ebp
  80faba:	c3                   	ret    

0080fabb <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80fabb:	55                   	push   %ebp
  80fabc:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fabe:	8b 45 08             	mov    0x8(%ebp),%eax
  80fac1:	05 00 00 00 30       	add    $0x30000000,%eax
  80fac6:	c1 e8 0c             	shr    $0xc,%eax
}
  80fac9:	5d                   	pop    %ebp
  80faca:	c3                   	ret    

0080facb <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80facb:	55                   	push   %ebp
  80facc:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80face:	8b 45 08             	mov    0x8(%ebp),%eax
  80fad1:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fad6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fadb:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fae0:	5d                   	pop    %ebp
  80fae1:	c3                   	ret    

0080fae2 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fae2:	55                   	push   %ebp
  80fae3:	89 e5                	mov    %esp,%ebp
  80fae5:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80faea:	89 c2                	mov    %eax,%edx
  80faec:	c1 ea 16             	shr    $0x16,%edx
  80faef:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80faf6:	f6 c2 01             	test   $0x1,%dl
  80faf9:	74 2d                	je     80fb28 <fd_alloc+0x46>
  80fafb:	89 c2                	mov    %eax,%edx
  80fafd:	c1 ea 0c             	shr    $0xc,%edx
  80fb00:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fb07:	f6 c2 01             	test   $0x1,%dl
  80fb0a:	74 1c                	je     80fb28 <fd_alloc+0x46>
  80fb0c:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fb11:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fb16:	75 d2                	jne    80faea <fd_alloc+0x8>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fb18:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb1b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fb21:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fb26:	eb 0a                	jmp    80fb32 <fd_alloc+0x50>
			*fd_store = fd;
  80fb28:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fb2b:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fb2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb32:	5d                   	pop    %ebp
  80fb33:	c3                   	ret    

0080fb34 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fb34:	55                   	push   %ebp
  80fb35:	89 e5                	mov    %esp,%ebp
  80fb37:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fb3a:	83 f8 1f             	cmp    $0x1f,%eax
  80fb3d:	77 30                	ja     80fb6f <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fb3f:	c1 e0 0c             	shl    $0xc,%eax
  80fb42:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fb47:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fb4d:	f6 c2 01             	test   $0x1,%dl
  80fb50:	74 24                	je     80fb76 <fd_lookup+0x42>
  80fb52:	89 c2                	mov    %eax,%edx
  80fb54:	c1 ea 0c             	shr    $0xc,%edx
  80fb57:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fb5e:	f6 c2 01             	test   $0x1,%dl
  80fb61:	74 1a                	je     80fb7d <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fb63:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fb66:	89 02                	mov    %eax,(%edx)
	return 0;
  80fb68:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fb6d:	5d                   	pop    %ebp
  80fb6e:	c3                   	ret    
		return -E_INVAL;
  80fb6f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fb74:	eb f7                	jmp    80fb6d <fd_lookup+0x39>
		return -E_INVAL;
  80fb76:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fb7b:	eb f0                	jmp    80fb6d <fd_lookup+0x39>
  80fb7d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fb82:	eb e9                	jmp    80fb6d <fd_lookup+0x39>

0080fb84 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fb84:	55                   	push   %ebp
  80fb85:	89 e5                	mov    %esp,%ebp
  80fb87:	83 ec 08             	sub    $0x8,%esp
  80fb8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fb8d:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb92:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fb97:	39 08                	cmp    %ecx,(%eax)
  80fb99:	74 38                	je     80fbd3 <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80fb9b:	83 c2 01             	add    $0x1,%edx
  80fb9e:	8b 04 95 04 3d 81 00 	mov    0x813d04(,%edx,4),%eax
  80fba5:	85 c0                	test   %eax,%eax
  80fba7:	75 ee                	jne    80fb97 <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fba9:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fbae:	8b 40 48             	mov    0x48(%eax),%eax
  80fbb1:	83 ec 04             	sub    $0x4,%esp
  80fbb4:	51                   	push   %ecx
  80fbb5:	50                   	push   %eax
  80fbb6:	68 88 3c 81 00       	push   $0x813c88
  80fbbb:	e8 de ea ff ff       	call   80e69e <cprintf>
	*dev = 0;
  80fbc0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fbc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fbc9:	83 c4 10             	add    $0x10,%esp
  80fbcc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fbd1:	c9                   	leave  
  80fbd2:	c3                   	ret    
			*dev = devtab[i];
  80fbd3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbd6:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fbd8:	b8 00 00 00 00       	mov    $0x0,%eax
  80fbdd:	eb f2                	jmp    80fbd1 <dev_lookup+0x4d>

0080fbdf <fd_close>:
{
  80fbdf:	55                   	push   %ebp
  80fbe0:	89 e5                	mov    %esp,%ebp
  80fbe2:	57                   	push   %edi
  80fbe3:	56                   	push   %esi
  80fbe4:	53                   	push   %ebx
  80fbe5:	83 ec 24             	sub    $0x24,%esp
  80fbe8:	8b 75 08             	mov    0x8(%ebp),%esi
  80fbeb:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fbee:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fbf1:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fbf2:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fbf8:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fbfb:	50                   	push   %eax
  80fbfc:	e8 33 ff ff ff       	call   80fb34 <fd_lookup>
  80fc01:	89 c3                	mov    %eax,%ebx
  80fc03:	83 c4 10             	add    $0x10,%esp
  80fc06:	85 c0                	test   %eax,%eax
  80fc08:	78 05                	js     80fc0f <fd_close+0x30>
	    || fd != fd2)
  80fc0a:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fc0d:	74 16                	je     80fc25 <fd_close+0x46>
		return (must_exist ? r : 0);
  80fc0f:	89 f8                	mov    %edi,%eax
  80fc11:	84 c0                	test   %al,%al
  80fc13:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc18:	0f 44 d8             	cmove  %eax,%ebx
}
  80fc1b:	89 d8                	mov    %ebx,%eax
  80fc1d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fc20:	5b                   	pop    %ebx
  80fc21:	5e                   	pop    %esi
  80fc22:	5f                   	pop    %edi
  80fc23:	5d                   	pop    %ebp
  80fc24:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fc25:	83 ec 08             	sub    $0x8,%esp
  80fc28:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fc2b:	50                   	push   %eax
  80fc2c:	ff 36                	pushl  (%esi)
  80fc2e:	e8 51 ff ff ff       	call   80fb84 <dev_lookup>
  80fc33:	89 c3                	mov    %eax,%ebx
  80fc35:	83 c4 10             	add    $0x10,%esp
  80fc38:	85 c0                	test   %eax,%eax
  80fc3a:	78 1a                	js     80fc56 <fd_close+0x77>
		if (dev->dev_close)
  80fc3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fc3f:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fc42:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fc47:	85 c0                	test   %eax,%eax
  80fc49:	74 0b                	je     80fc56 <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80fc4b:	83 ec 0c             	sub    $0xc,%esp
  80fc4e:	56                   	push   %esi
  80fc4f:	ff d0                	call   *%eax
  80fc51:	89 c3                	mov    %eax,%ebx
  80fc53:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fc56:	83 ec 08             	sub    $0x8,%esp
  80fc59:	56                   	push   %esi
  80fc5a:	6a 00                	push   $0x0
  80fc5c:	e8 13 f6 ff ff       	call   80f274 <sys_page_unmap>
	return r;
  80fc61:	83 c4 10             	add    $0x10,%esp
  80fc64:	eb b5                	jmp    80fc1b <fd_close+0x3c>

0080fc66 <close>:

int
close(int fdnum)
{
  80fc66:	55                   	push   %ebp
  80fc67:	89 e5                	mov    %esp,%ebp
  80fc69:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fc6c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fc6f:	50                   	push   %eax
  80fc70:	ff 75 08             	pushl  0x8(%ebp)
  80fc73:	e8 bc fe ff ff       	call   80fb34 <fd_lookup>
  80fc78:	83 c4 10             	add    $0x10,%esp
  80fc7b:	85 c0                	test   %eax,%eax
  80fc7d:	79 02                	jns    80fc81 <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80fc7f:	c9                   	leave  
  80fc80:	c3                   	ret    
		return fd_close(fd, 1);
  80fc81:	83 ec 08             	sub    $0x8,%esp
  80fc84:	6a 01                	push   $0x1
  80fc86:	ff 75 f4             	pushl  -0xc(%ebp)
  80fc89:	e8 51 ff ff ff       	call   80fbdf <fd_close>
  80fc8e:	83 c4 10             	add    $0x10,%esp
  80fc91:	eb ec                	jmp    80fc7f <close+0x19>

0080fc93 <close_all>:

void
close_all(void)
{
  80fc93:	55                   	push   %ebp
  80fc94:	89 e5                	mov    %esp,%ebp
  80fc96:	53                   	push   %ebx
  80fc97:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fc9a:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fc9f:	83 ec 0c             	sub    $0xc,%esp
  80fca2:	53                   	push   %ebx
  80fca3:	e8 be ff ff ff       	call   80fc66 <close>
	for (i = 0; i < MAXFD; i++)
  80fca8:	83 c3 01             	add    $0x1,%ebx
  80fcab:	83 c4 10             	add    $0x10,%esp
  80fcae:	83 fb 20             	cmp    $0x20,%ebx
  80fcb1:	75 ec                	jne    80fc9f <close_all+0xc>
}
  80fcb3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fcb6:	c9                   	leave  
  80fcb7:	c3                   	ret    

0080fcb8 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fcb8:	55                   	push   %ebp
  80fcb9:	89 e5                	mov    %esp,%ebp
  80fcbb:	57                   	push   %edi
  80fcbc:	56                   	push   %esi
  80fcbd:	53                   	push   %ebx
  80fcbe:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fcc1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fcc4:	50                   	push   %eax
  80fcc5:	ff 75 08             	pushl  0x8(%ebp)
  80fcc8:	e8 67 fe ff ff       	call   80fb34 <fd_lookup>
  80fccd:	89 c3                	mov    %eax,%ebx
  80fccf:	83 c4 10             	add    $0x10,%esp
  80fcd2:	85 c0                	test   %eax,%eax
  80fcd4:	0f 88 81 00 00 00    	js     80fd5b <dup+0xa3>
		return r;
	close(newfdnum);
  80fcda:	83 ec 0c             	sub    $0xc,%esp
  80fcdd:	ff 75 0c             	pushl  0xc(%ebp)
  80fce0:	e8 81 ff ff ff       	call   80fc66 <close>

	newfd = INDEX2FD(newfdnum);
  80fce5:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fce8:	c1 e6 0c             	shl    $0xc,%esi
  80fceb:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fcf1:	83 c4 04             	add    $0x4,%esp
  80fcf4:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fcf7:	e8 cf fd ff ff       	call   80facb <fd2data>
  80fcfc:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fcfe:	89 34 24             	mov    %esi,(%esp)
  80fd01:	e8 c5 fd ff ff       	call   80facb <fd2data>
  80fd06:	83 c4 10             	add    $0x10,%esp
  80fd09:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fd0b:	89 d8                	mov    %ebx,%eax
  80fd0d:	c1 e8 16             	shr    $0x16,%eax
  80fd10:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fd17:	a8 01                	test   $0x1,%al
  80fd19:	74 11                	je     80fd2c <dup+0x74>
  80fd1b:	89 d8                	mov    %ebx,%eax
  80fd1d:	c1 e8 0c             	shr    $0xc,%eax
  80fd20:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fd27:	f6 c2 01             	test   $0x1,%dl
  80fd2a:	75 39                	jne    80fd65 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fd2c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fd2f:	89 d0                	mov    %edx,%eax
  80fd31:	c1 e8 0c             	shr    $0xc,%eax
  80fd34:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fd3b:	83 ec 0c             	sub    $0xc,%esp
  80fd3e:	25 07 0e 00 00       	and    $0xe07,%eax
  80fd43:	50                   	push   %eax
  80fd44:	56                   	push   %esi
  80fd45:	6a 00                	push   $0x0
  80fd47:	52                   	push   %edx
  80fd48:	6a 00                	push   $0x0
  80fd4a:	e8 e3 f4 ff ff       	call   80f232 <sys_page_map>
  80fd4f:	89 c3                	mov    %eax,%ebx
  80fd51:	83 c4 20             	add    $0x20,%esp
  80fd54:	85 c0                	test   %eax,%eax
  80fd56:	78 31                	js     80fd89 <dup+0xd1>
		goto err;

	return newfdnum;
  80fd58:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fd5b:	89 d8                	mov    %ebx,%eax
  80fd5d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fd60:	5b                   	pop    %ebx
  80fd61:	5e                   	pop    %esi
  80fd62:	5f                   	pop    %edi
  80fd63:	5d                   	pop    %ebp
  80fd64:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80fd65:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fd6c:	83 ec 0c             	sub    $0xc,%esp
  80fd6f:	25 07 0e 00 00       	and    $0xe07,%eax
  80fd74:	50                   	push   %eax
  80fd75:	57                   	push   %edi
  80fd76:	6a 00                	push   $0x0
  80fd78:	53                   	push   %ebx
  80fd79:	6a 00                	push   $0x0
  80fd7b:	e8 b2 f4 ff ff       	call   80f232 <sys_page_map>
  80fd80:	89 c3                	mov    %eax,%ebx
  80fd82:	83 c4 20             	add    $0x20,%esp
  80fd85:	85 c0                	test   %eax,%eax
  80fd87:	79 a3                	jns    80fd2c <dup+0x74>
	sys_page_unmap(0, newfd);
  80fd89:	83 ec 08             	sub    $0x8,%esp
  80fd8c:	56                   	push   %esi
  80fd8d:	6a 00                	push   $0x0
  80fd8f:	e8 e0 f4 ff ff       	call   80f274 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fd94:	83 c4 08             	add    $0x8,%esp
  80fd97:	57                   	push   %edi
  80fd98:	6a 00                	push   $0x0
  80fd9a:	e8 d5 f4 ff ff       	call   80f274 <sys_page_unmap>
	return r;
  80fd9f:	83 c4 10             	add    $0x10,%esp
  80fda2:	eb b7                	jmp    80fd5b <dup+0xa3>

0080fda4 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fda4:	55                   	push   %ebp
  80fda5:	89 e5                	mov    %esp,%ebp
  80fda7:	53                   	push   %ebx
  80fda8:	83 ec 1c             	sub    $0x1c,%esp
  80fdab:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fdae:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fdb1:	50                   	push   %eax
  80fdb2:	53                   	push   %ebx
  80fdb3:	e8 7c fd ff ff       	call   80fb34 <fd_lookup>
  80fdb8:	83 c4 10             	add    $0x10,%esp
  80fdbb:	85 c0                	test   %eax,%eax
  80fdbd:	78 3f                	js     80fdfe <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fdbf:	83 ec 08             	sub    $0x8,%esp
  80fdc2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fdc5:	50                   	push   %eax
  80fdc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fdc9:	ff 30                	pushl  (%eax)
  80fdcb:	e8 b4 fd ff ff       	call   80fb84 <dev_lookup>
  80fdd0:	83 c4 10             	add    $0x10,%esp
  80fdd3:	85 c0                	test   %eax,%eax
  80fdd5:	78 27                	js     80fdfe <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80fdd7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80fdda:	8b 42 08             	mov    0x8(%edx),%eax
  80fddd:	83 e0 03             	and    $0x3,%eax
  80fde0:	83 f8 01             	cmp    $0x1,%eax
  80fde3:	74 1e                	je     80fe03 <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fde5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fde8:	8b 40 08             	mov    0x8(%eax),%eax
  80fdeb:	85 c0                	test   %eax,%eax
  80fded:	74 35                	je     80fe24 <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fdef:	83 ec 04             	sub    $0x4,%esp
  80fdf2:	ff 75 10             	pushl  0x10(%ebp)
  80fdf5:	ff 75 0c             	pushl  0xc(%ebp)
  80fdf8:	52                   	push   %edx
  80fdf9:	ff d0                	call   *%eax
  80fdfb:	83 c4 10             	add    $0x10,%esp
}
  80fdfe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fe01:	c9                   	leave  
  80fe02:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fe03:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fe08:	8b 40 48             	mov    0x48(%eax),%eax
  80fe0b:	83 ec 04             	sub    $0x4,%esp
  80fe0e:	53                   	push   %ebx
  80fe0f:	50                   	push   %eax
  80fe10:	68 c9 3c 81 00       	push   $0x813cc9
  80fe15:	e8 84 e8 ff ff       	call   80e69e <cprintf>
		return -E_INVAL;
  80fe1a:	83 c4 10             	add    $0x10,%esp
  80fe1d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fe22:	eb da                	jmp    80fdfe <read+0x5a>
		return -E_NOT_SUPP;
  80fe24:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fe29:	eb d3                	jmp    80fdfe <read+0x5a>

0080fe2b <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80fe2b:	55                   	push   %ebp
  80fe2c:	89 e5                	mov    %esp,%ebp
  80fe2e:	57                   	push   %edi
  80fe2f:	56                   	push   %esi
  80fe30:	53                   	push   %ebx
  80fe31:	83 ec 0c             	sub    $0xc,%esp
  80fe34:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fe37:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80fe3a:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe3f:	39 f3                	cmp    %esi,%ebx
  80fe41:	73 23                	jae    80fe66 <readn+0x3b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fe43:	83 ec 04             	sub    $0x4,%esp
  80fe46:	89 f0                	mov    %esi,%eax
  80fe48:	29 d8                	sub    %ebx,%eax
  80fe4a:	50                   	push   %eax
  80fe4b:	89 d8                	mov    %ebx,%eax
  80fe4d:	03 45 0c             	add    0xc(%ebp),%eax
  80fe50:	50                   	push   %eax
  80fe51:	57                   	push   %edi
  80fe52:	e8 4d ff ff ff       	call   80fda4 <read>
		if (m < 0)
  80fe57:	83 c4 10             	add    $0x10,%esp
  80fe5a:	85 c0                	test   %eax,%eax
  80fe5c:	78 06                	js     80fe64 <readn+0x39>
			return m;
		if (m == 0)
  80fe5e:	74 06                	je     80fe66 <readn+0x3b>
	for (tot = 0; tot < n; tot += m) {
  80fe60:	01 c3                	add    %eax,%ebx
  80fe62:	eb db                	jmp    80fe3f <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80fe64:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80fe66:	89 d8                	mov    %ebx,%eax
  80fe68:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fe6b:	5b                   	pop    %ebx
  80fe6c:	5e                   	pop    %esi
  80fe6d:	5f                   	pop    %edi
  80fe6e:	5d                   	pop    %ebp
  80fe6f:	c3                   	ret    

0080fe70 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80fe70:	55                   	push   %ebp
  80fe71:	89 e5                	mov    %esp,%ebp
  80fe73:	53                   	push   %ebx
  80fe74:	83 ec 1c             	sub    $0x1c,%esp
  80fe77:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fe7a:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fe7d:	50                   	push   %eax
  80fe7e:	53                   	push   %ebx
  80fe7f:	e8 b0 fc ff ff       	call   80fb34 <fd_lookup>
  80fe84:	83 c4 10             	add    $0x10,%esp
  80fe87:	85 c0                	test   %eax,%eax
  80fe89:	78 3a                	js     80fec5 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fe8b:	83 ec 08             	sub    $0x8,%esp
  80fe8e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fe91:	50                   	push   %eax
  80fe92:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fe95:	ff 30                	pushl  (%eax)
  80fe97:	e8 e8 fc ff ff       	call   80fb84 <dev_lookup>
  80fe9c:	83 c4 10             	add    $0x10,%esp
  80fe9f:	85 c0                	test   %eax,%eax
  80fea1:	78 22                	js     80fec5 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80fea3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fea6:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80feaa:	74 1e                	je     80feca <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80feac:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80feaf:	8b 52 0c             	mov    0xc(%edx),%edx
  80feb2:	85 d2                	test   %edx,%edx
  80feb4:	74 35                	je     80feeb <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80feb6:	83 ec 04             	sub    $0x4,%esp
  80feb9:	ff 75 10             	pushl  0x10(%ebp)
  80febc:	ff 75 0c             	pushl  0xc(%ebp)
  80febf:	50                   	push   %eax
  80fec0:	ff d2                	call   *%edx
  80fec2:	83 c4 10             	add    $0x10,%esp
}
  80fec5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fec8:	c9                   	leave  
  80fec9:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80feca:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fecf:	8b 40 48             	mov    0x48(%eax),%eax
  80fed2:	83 ec 04             	sub    $0x4,%esp
  80fed5:	53                   	push   %ebx
  80fed6:	50                   	push   %eax
  80fed7:	68 e5 3c 81 00       	push   $0x813ce5
  80fedc:	e8 bd e7 ff ff       	call   80e69e <cprintf>
		return -E_INVAL;
  80fee1:	83 c4 10             	add    $0x10,%esp
  80fee4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fee9:	eb da                	jmp    80fec5 <write+0x55>
		return -E_NOT_SUPP;
  80feeb:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80fef0:	eb d3                	jmp    80fec5 <write+0x55>

0080fef2 <seek>:

int
seek(int fdnum, off_t offset)
{
  80fef2:	55                   	push   %ebp
  80fef3:	89 e5                	mov    %esp,%ebp
  80fef5:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fef8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fefb:	50                   	push   %eax
  80fefc:	ff 75 08             	pushl  0x8(%ebp)
  80feff:	e8 30 fc ff ff       	call   80fb34 <fd_lookup>
  80ff04:	83 c4 10             	add    $0x10,%esp
  80ff07:	85 c0                	test   %eax,%eax
  80ff09:	78 0e                	js     80ff19 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80ff0b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ff0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ff11:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80ff14:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ff19:	c9                   	leave  
  80ff1a:	c3                   	ret    

0080ff1b <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80ff1b:	55                   	push   %ebp
  80ff1c:	89 e5                	mov    %esp,%ebp
  80ff1e:	53                   	push   %ebx
  80ff1f:	83 ec 1c             	sub    $0x1c,%esp
  80ff22:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ff25:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ff28:	50                   	push   %eax
  80ff29:	53                   	push   %ebx
  80ff2a:	e8 05 fc ff ff       	call   80fb34 <fd_lookup>
  80ff2f:	83 c4 10             	add    $0x10,%esp
  80ff32:	85 c0                	test   %eax,%eax
  80ff34:	78 37                	js     80ff6d <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ff36:	83 ec 08             	sub    $0x8,%esp
  80ff39:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ff3c:	50                   	push   %eax
  80ff3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff40:	ff 30                	pushl  (%eax)
  80ff42:	e8 3d fc ff ff       	call   80fb84 <dev_lookup>
  80ff47:	83 c4 10             	add    $0x10,%esp
  80ff4a:	85 c0                	test   %eax,%eax
  80ff4c:	78 1f                	js     80ff6d <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80ff4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff51:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80ff55:	74 1b                	je     80ff72 <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80ff57:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80ff5a:	8b 52 18             	mov    0x18(%edx),%edx
  80ff5d:	85 d2                	test   %edx,%edx
  80ff5f:	74 32                	je     80ff93 <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  80ff61:	83 ec 08             	sub    $0x8,%esp
  80ff64:	ff 75 0c             	pushl  0xc(%ebp)
  80ff67:	50                   	push   %eax
  80ff68:	ff d2                	call   *%edx
  80ff6a:	83 c4 10             	add    $0x10,%esp
}
  80ff6d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff70:	c9                   	leave  
  80ff71:	c3                   	ret    
			thisenv->env_id, fdnum);
  80ff72:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  80ff77:	8b 40 48             	mov    0x48(%eax),%eax
  80ff7a:	83 ec 04             	sub    $0x4,%esp
  80ff7d:	53                   	push   %ebx
  80ff7e:	50                   	push   %eax
  80ff7f:	68 a8 3c 81 00       	push   $0x813ca8
  80ff84:	e8 15 e7 ff ff       	call   80e69e <cprintf>
		return -E_INVAL;
  80ff89:	83 c4 10             	add    $0x10,%esp
  80ff8c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ff91:	eb da                	jmp    80ff6d <ftruncate+0x52>
		return -E_NOT_SUPP;
  80ff93:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ff98:	eb d3                	jmp    80ff6d <ftruncate+0x52>

0080ff9a <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  80ff9a:	55                   	push   %ebp
  80ff9b:	89 e5                	mov    %esp,%ebp
  80ff9d:	53                   	push   %ebx
  80ff9e:	83 ec 1c             	sub    $0x1c,%esp
  80ffa1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ffa4:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ffa7:	50                   	push   %eax
  80ffa8:	ff 75 08             	pushl  0x8(%ebp)
  80ffab:	e8 84 fb ff ff       	call   80fb34 <fd_lookup>
  80ffb0:	83 c4 10             	add    $0x10,%esp
  80ffb3:	85 c0                	test   %eax,%eax
  80ffb5:	78 4b                	js     810002 <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ffb7:	83 ec 08             	sub    $0x8,%esp
  80ffba:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ffbd:	50                   	push   %eax
  80ffbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ffc1:	ff 30                	pushl  (%eax)
  80ffc3:	e8 bc fb ff ff       	call   80fb84 <dev_lookup>
  80ffc8:	83 c4 10             	add    $0x10,%esp
  80ffcb:	85 c0                	test   %eax,%eax
  80ffcd:	78 33                	js     810002 <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  80ffcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ffd2:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  80ffd6:	74 2f                	je     810007 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80ffd8:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  80ffdb:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80ffe2:	00 00 00 
	stat->st_isdir = 0;
  80ffe5:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  80ffec:	00 00 00 
	stat->st_dev = dev;
  80ffef:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  80fff5:	83 ec 08             	sub    $0x8,%esp
  80fff8:	53                   	push   %ebx
  80fff9:	ff 75 f0             	pushl  -0x10(%ebp)
  80fffc:	ff 50 14             	call   *0x14(%eax)
  80ffff:	83 c4 10             	add    $0x10,%esp
}
  810002:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810005:	c9                   	leave  
  810006:	c3                   	ret    
		return -E_NOT_SUPP;
  810007:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81000c:	eb f4                	jmp    810002 <fstat+0x68>

0081000e <stat>:

int
stat(const char *path, struct Stat *stat)
{
  81000e:	55                   	push   %ebp
  81000f:	89 e5                	mov    %esp,%ebp
  810011:	56                   	push   %esi
  810012:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  810013:	83 ec 08             	sub    $0x8,%esp
  810016:	6a 00                	push   $0x0
  810018:	ff 75 08             	pushl  0x8(%ebp)
  81001b:	e8 22 02 00 00       	call   810242 <open>
  810020:	89 c3                	mov    %eax,%ebx
  810022:	83 c4 10             	add    $0x10,%esp
  810025:	85 c0                	test   %eax,%eax
  810027:	78 1b                	js     810044 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  810029:	83 ec 08             	sub    $0x8,%esp
  81002c:	ff 75 0c             	pushl  0xc(%ebp)
  81002f:	50                   	push   %eax
  810030:	e8 65 ff ff ff       	call   80ff9a <fstat>
  810035:	89 c6                	mov    %eax,%esi
	close(fd);
  810037:	89 1c 24             	mov    %ebx,(%esp)
  81003a:	e8 27 fc ff ff       	call   80fc66 <close>
	return r;
  81003f:	83 c4 10             	add    $0x10,%esp
  810042:	89 f3                	mov    %esi,%ebx
}
  810044:	89 d8                	mov    %ebx,%eax
  810046:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810049:	5b                   	pop    %ebx
  81004a:	5e                   	pop    %esi
  81004b:	5d                   	pop    %ebp
  81004c:	c3                   	ret    

0081004d <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  81004d:	55                   	push   %ebp
  81004e:	89 e5                	mov    %esp,%ebp
  810050:	56                   	push   %esi
  810051:	53                   	push   %ebx
  810052:	89 c6                	mov    %eax,%esi
  810054:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  810056:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  81005d:	74 27                	je     810086 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  81005f:	6a 07                	push   $0x7
  810061:	68 00 c0 b3 00       	push   $0xb3c000
  810066:	56                   	push   %esi
  810067:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  81006d:	e8 b6 f9 ff ff       	call   80fa28 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  810072:	83 c4 0c             	add    $0xc,%esp
  810075:	6a 00                	push   $0x0
  810077:	53                   	push   %ebx
  810078:	6a 00                	push   $0x0
  81007a:	e8 40 f9 ff ff       	call   80f9bf <ipc_recv>
}
  81007f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810082:	5b                   	pop    %ebx
  810083:	5e                   	pop    %esi
  810084:	5d                   	pop    %ebp
  810085:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810086:	83 ec 0c             	sub    $0xc,%esp
  810089:	6a 01                	push   $0x1
  81008b:	e8 f0 f9 ff ff       	call   80fa80 <ipc_find_env>
  810090:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  810095:	83 c4 10             	add    $0x10,%esp
  810098:	eb c5                	jmp    81005f <fsipc+0x12>

0081009a <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  81009a:	55                   	push   %ebp
  81009b:	89 e5                	mov    %esp,%ebp
  81009d:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8100a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8100a3:	8b 40 0c             	mov    0xc(%eax),%eax
  8100a6:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  8100ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  8100ae:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  8100b3:	ba 00 00 00 00       	mov    $0x0,%edx
  8100b8:	b8 02 00 00 00       	mov    $0x2,%eax
  8100bd:	e8 8b ff ff ff       	call   81004d <fsipc>
}
  8100c2:	c9                   	leave  
  8100c3:	c3                   	ret    

008100c4 <devfile_flush>:
{
  8100c4:	55                   	push   %ebp
  8100c5:	89 e5                	mov    %esp,%ebp
  8100c7:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  8100ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8100cd:	8b 40 0c             	mov    0xc(%eax),%eax
  8100d0:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  8100d5:	ba 00 00 00 00       	mov    $0x0,%edx
  8100da:	b8 06 00 00 00       	mov    $0x6,%eax
  8100df:	e8 69 ff ff ff       	call   81004d <fsipc>
}
  8100e4:	c9                   	leave  
  8100e5:	c3                   	ret    

008100e6 <devfile_stat>:
{
  8100e6:	55                   	push   %ebp
  8100e7:	89 e5                	mov    %esp,%ebp
  8100e9:	53                   	push   %ebx
  8100ea:	83 ec 04             	sub    $0x4,%esp
  8100ed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8100f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8100f3:	8b 40 0c             	mov    0xc(%eax),%eax
  8100f6:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8100fb:	ba 00 00 00 00       	mov    $0x0,%edx
  810100:	b8 05 00 00 00       	mov    $0x5,%eax
  810105:	e8 43 ff ff ff       	call   81004d <fsipc>
  81010a:	85 c0                	test   %eax,%eax
  81010c:	78 2c                	js     81013a <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  81010e:	83 ec 08             	sub    $0x8,%esp
  810111:	68 00 c0 b3 00       	push   $0xb3c000
  810116:	53                   	push   %ebx
  810117:	e8 e1 ec ff ff       	call   80edfd <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  81011c:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  810121:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810127:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  81012c:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  810132:	83 c4 10             	add    $0x10,%esp
  810135:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81013a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81013d:	c9                   	leave  
  81013e:	c3                   	ret    

0081013f <devfile_write>:
{
  81013f:	55                   	push   %ebp
  810140:	89 e5                	mov    %esp,%ebp
  810142:	53                   	push   %ebx
  810143:	83 ec 08             	sub    $0x8,%esp
  810146:	8b 5d 10             	mov    0x10(%ebp),%ebx
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810149:	8b 45 08             	mov    0x8(%ebp),%eax
  81014c:	8b 40 0c             	mov    0xc(%eax),%eax
  81014f:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.write.req_n = n;
  810154:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
	memcpy(fsipcbuf.write.req_buf, buf, n);
  81015a:	53                   	push   %ebx
  81015b:	ff 75 0c             	pushl  0xc(%ebp)
  81015e:	68 08 c0 b3 00       	push   $0xb3c008
  810163:	e8 85 ee ff ff       	call   80efed <memcpy>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  810168:	ba 00 00 00 00       	mov    $0x0,%edx
  81016d:	b8 04 00 00 00       	mov    $0x4,%eax
  810172:	e8 d6 fe ff ff       	call   81004d <fsipc>
  810177:	83 c4 10             	add    $0x10,%esp
  81017a:	85 c0                	test   %eax,%eax
  81017c:	78 0b                	js     810189 <devfile_write+0x4a>
	assert(r <= n);
  81017e:	39 d8                	cmp    %ebx,%eax
  810180:	77 0c                	ja     81018e <devfile_write+0x4f>
	assert(r <= PGSIZE);
  810182:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810187:	7f 1e                	jg     8101a7 <devfile_write+0x68>
}
  810189:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81018c:	c9                   	leave  
  81018d:	c3                   	ret    
	assert(r <= n);
  81018e:	68 18 3d 81 00       	push   $0x813d18
  810193:	68 6b 29 81 00       	push   $0x81296b
  810198:	68 98 00 00 00       	push   $0x98
  81019d:	68 1f 3d 81 00       	push   $0x813d1f
  8101a2:	e8 01 e4 ff ff       	call   80e5a8 <_panic>
	assert(r <= PGSIZE);
  8101a7:	68 2a 3d 81 00       	push   $0x813d2a
  8101ac:	68 6b 29 81 00       	push   $0x81296b
  8101b1:	68 99 00 00 00       	push   $0x99
  8101b6:	68 1f 3d 81 00       	push   $0x813d1f
  8101bb:	e8 e8 e3 ff ff       	call   80e5a8 <_panic>

008101c0 <devfile_read>:
{
  8101c0:	55                   	push   %ebp
  8101c1:	89 e5                	mov    %esp,%ebp
  8101c3:	56                   	push   %esi
  8101c4:	53                   	push   %ebx
  8101c5:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  8101c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8101cb:	8b 40 0c             	mov    0xc(%eax),%eax
  8101ce:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  8101d3:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  8101d9:	ba 00 00 00 00       	mov    $0x0,%edx
  8101de:	b8 03 00 00 00       	mov    $0x3,%eax
  8101e3:	e8 65 fe ff ff       	call   81004d <fsipc>
  8101e8:	89 c3                	mov    %eax,%ebx
  8101ea:	85 c0                	test   %eax,%eax
  8101ec:	78 1f                	js     81020d <devfile_read+0x4d>
	assert(r <= n);
  8101ee:	39 f0                	cmp    %esi,%eax
  8101f0:	77 24                	ja     810216 <devfile_read+0x56>
	assert(r <= PGSIZE);
  8101f2:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8101f7:	7f 33                	jg     81022c <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  8101f9:	83 ec 04             	sub    $0x4,%esp
  8101fc:	50                   	push   %eax
  8101fd:	68 00 c0 b3 00       	push   $0xb3c000
  810202:	ff 75 0c             	pushl  0xc(%ebp)
  810205:	e8 81 ed ff ff       	call   80ef8b <memmove>
	return r;
  81020a:	83 c4 10             	add    $0x10,%esp
}
  81020d:	89 d8                	mov    %ebx,%eax
  81020f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810212:	5b                   	pop    %ebx
  810213:	5e                   	pop    %esi
  810214:	5d                   	pop    %ebp
  810215:	c3                   	ret    
	assert(r <= n);
  810216:	68 18 3d 81 00       	push   $0x813d18
  81021b:	68 6b 29 81 00       	push   $0x81296b
  810220:	6a 7c                	push   $0x7c
  810222:	68 1f 3d 81 00       	push   $0x813d1f
  810227:	e8 7c e3 ff ff       	call   80e5a8 <_panic>
	assert(r <= PGSIZE);
  81022c:	68 2a 3d 81 00       	push   $0x813d2a
  810231:	68 6b 29 81 00       	push   $0x81296b
  810236:	6a 7d                	push   $0x7d
  810238:	68 1f 3d 81 00       	push   $0x813d1f
  81023d:	e8 66 e3 ff ff       	call   80e5a8 <_panic>

00810242 <open>:
{
  810242:	55                   	push   %ebp
  810243:	89 e5                	mov    %esp,%ebp
  810245:	56                   	push   %esi
  810246:	53                   	push   %ebx
  810247:	83 ec 1c             	sub    $0x1c,%esp
  81024a:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  81024d:	56                   	push   %esi
  81024e:	e8 71 eb ff ff       	call   80edc4 <strlen>
  810253:	83 c4 10             	add    $0x10,%esp
  810256:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  81025b:	7f 6c                	jg     8102c9 <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  81025d:	83 ec 0c             	sub    $0xc,%esp
  810260:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810263:	50                   	push   %eax
  810264:	e8 79 f8 ff ff       	call   80fae2 <fd_alloc>
  810269:	89 c3                	mov    %eax,%ebx
  81026b:	83 c4 10             	add    $0x10,%esp
  81026e:	85 c0                	test   %eax,%eax
  810270:	78 3c                	js     8102ae <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  810272:	83 ec 08             	sub    $0x8,%esp
  810275:	56                   	push   %esi
  810276:	68 00 c0 b3 00       	push   $0xb3c000
  81027b:	e8 7d eb ff ff       	call   80edfd <strcpy>
	fsipcbuf.open.req_omode = mode;
  810280:	8b 45 0c             	mov    0xc(%ebp),%eax
  810283:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810288:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81028b:	b8 01 00 00 00       	mov    $0x1,%eax
  810290:	e8 b8 fd ff ff       	call   81004d <fsipc>
  810295:	89 c3                	mov    %eax,%ebx
  810297:	83 c4 10             	add    $0x10,%esp
  81029a:	85 c0                	test   %eax,%eax
  81029c:	78 19                	js     8102b7 <open+0x75>
	return fd2num(fd);
  81029e:	83 ec 0c             	sub    $0xc,%esp
  8102a1:	ff 75 f4             	pushl  -0xc(%ebp)
  8102a4:	e8 12 f8 ff ff       	call   80fabb <fd2num>
  8102a9:	89 c3                	mov    %eax,%ebx
  8102ab:	83 c4 10             	add    $0x10,%esp
}
  8102ae:	89 d8                	mov    %ebx,%eax
  8102b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8102b3:	5b                   	pop    %ebx
  8102b4:	5e                   	pop    %esi
  8102b5:	5d                   	pop    %ebp
  8102b6:	c3                   	ret    
		fd_close(fd, 0);
  8102b7:	83 ec 08             	sub    $0x8,%esp
  8102ba:	6a 00                	push   $0x0
  8102bc:	ff 75 f4             	pushl  -0xc(%ebp)
  8102bf:	e8 1b f9 ff ff       	call   80fbdf <fd_close>
		return r;
  8102c4:	83 c4 10             	add    $0x10,%esp
  8102c7:	eb e5                	jmp    8102ae <open+0x6c>
		return -E_BAD_PATH;
  8102c9:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  8102ce:	eb de                	jmp    8102ae <open+0x6c>

008102d0 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  8102d0:	55                   	push   %ebp
  8102d1:	89 e5                	mov    %esp,%ebp
  8102d3:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  8102d6:	ba 00 00 00 00       	mov    $0x0,%edx
  8102db:	b8 08 00 00 00       	mov    $0x8,%eax
  8102e0:	e8 68 fd ff ff       	call   81004d <fsipc>
}
  8102e5:	c9                   	leave  
  8102e6:	c3                   	ret    

008102e7 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8102e7:	55                   	push   %ebp
  8102e8:	89 e5                	mov    %esp,%ebp
  8102ea:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  8102ed:	68 36 3d 81 00       	push   $0x813d36
  8102f2:	ff 75 0c             	pushl  0xc(%ebp)
  8102f5:	e8 03 eb ff ff       	call   80edfd <strcpy>
	return 0;
}
  8102fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8102ff:	c9                   	leave  
  810300:	c3                   	ret    

00810301 <devsock_close>:
{
  810301:	55                   	push   %ebp
  810302:	89 e5                	mov    %esp,%ebp
  810304:	53                   	push   %ebx
  810305:	83 ec 10             	sub    $0x10,%esp
  810308:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  81030b:	53                   	push   %ebx
  81030c:	e8 2e 0c 00 00       	call   810f3f <pageref>
  810311:	83 c4 10             	add    $0x10,%esp
		return 0;
  810314:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  810319:	83 f8 01             	cmp    $0x1,%eax
  81031c:	74 07                	je     810325 <devsock_close+0x24>
}
  81031e:	89 d0                	mov    %edx,%eax
  810320:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810323:	c9                   	leave  
  810324:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  810325:	83 ec 0c             	sub    $0xc,%esp
  810328:	ff 73 0c             	pushl  0xc(%ebx)
  81032b:	e8 b9 02 00 00       	call   8105e9 <nsipc_close>
  810330:	89 c2                	mov    %eax,%edx
  810332:	83 c4 10             	add    $0x10,%esp
  810335:	eb e7                	jmp    81031e <devsock_close+0x1d>

00810337 <devsock_write>:
{
  810337:	55                   	push   %ebp
  810338:	89 e5                	mov    %esp,%ebp
  81033a:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  81033d:	6a 00                	push   $0x0
  81033f:	ff 75 10             	pushl  0x10(%ebp)
  810342:	ff 75 0c             	pushl  0xc(%ebp)
  810345:	8b 45 08             	mov    0x8(%ebp),%eax
  810348:	ff 70 0c             	pushl  0xc(%eax)
  81034b:	e8 76 03 00 00       	call   8106c6 <nsipc_send>
}
  810350:	c9                   	leave  
  810351:	c3                   	ret    

00810352 <devsock_read>:
{
  810352:	55                   	push   %ebp
  810353:	89 e5                	mov    %esp,%ebp
  810355:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  810358:	6a 00                	push   $0x0
  81035a:	ff 75 10             	pushl  0x10(%ebp)
  81035d:	ff 75 0c             	pushl  0xc(%ebp)
  810360:	8b 45 08             	mov    0x8(%ebp),%eax
  810363:	ff 70 0c             	pushl  0xc(%eax)
  810366:	e8 ef 02 00 00       	call   81065a <nsipc_recv>
}
  81036b:	c9                   	leave  
  81036c:	c3                   	ret    

0081036d <fd2sockid>:
{
  81036d:	55                   	push   %ebp
  81036e:	89 e5                	mov    %esp,%ebp
  810370:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  810373:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810376:	52                   	push   %edx
  810377:	50                   	push   %eax
  810378:	e8 b7 f7 ff ff       	call   80fb34 <fd_lookup>
  81037d:	83 c4 10             	add    $0x10,%esp
  810380:	85 c0                	test   %eax,%eax
  810382:	78 10                	js     810394 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  810384:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810387:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  81038d:	39 08                	cmp    %ecx,(%eax)
  81038f:	75 05                	jne    810396 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  810391:	8b 40 0c             	mov    0xc(%eax),%eax
}
  810394:	c9                   	leave  
  810395:	c3                   	ret    
		return -E_NOT_SUPP;
  810396:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81039b:	eb f7                	jmp    810394 <fd2sockid+0x27>

0081039d <alloc_sockfd>:
{
  81039d:	55                   	push   %ebp
  81039e:	89 e5                	mov    %esp,%ebp
  8103a0:	56                   	push   %esi
  8103a1:	53                   	push   %ebx
  8103a2:	83 ec 1c             	sub    $0x1c,%esp
  8103a5:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  8103a7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8103aa:	50                   	push   %eax
  8103ab:	e8 32 f7 ff ff       	call   80fae2 <fd_alloc>
  8103b0:	89 c3                	mov    %eax,%ebx
  8103b2:	83 c4 10             	add    $0x10,%esp
  8103b5:	85 c0                	test   %eax,%eax
  8103b7:	78 43                	js     8103fc <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  8103b9:	83 ec 04             	sub    $0x4,%esp
  8103bc:	68 07 04 00 00       	push   $0x407
  8103c1:	ff 75 f4             	pushl  -0xc(%ebp)
  8103c4:	6a 00                	push   $0x0
  8103c6:	e8 24 ee ff ff       	call   80f1ef <sys_page_alloc>
  8103cb:	89 c3                	mov    %eax,%ebx
  8103cd:	83 c4 10             	add    $0x10,%esp
  8103d0:	85 c0                	test   %eax,%eax
  8103d2:	78 28                	js     8103fc <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  8103d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8103d7:	8b 15 08 43 81 00    	mov    0x814308,%edx
  8103dd:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8103df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8103e2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8103e9:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8103ec:	83 ec 0c             	sub    $0xc,%esp
  8103ef:	50                   	push   %eax
  8103f0:	e8 c6 f6 ff ff       	call   80fabb <fd2num>
  8103f5:	89 c3                	mov    %eax,%ebx
  8103f7:	83 c4 10             	add    $0x10,%esp
  8103fa:	eb 0c                	jmp    810408 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  8103fc:	83 ec 0c             	sub    $0xc,%esp
  8103ff:	56                   	push   %esi
  810400:	e8 e4 01 00 00       	call   8105e9 <nsipc_close>
		return r;
  810405:	83 c4 10             	add    $0x10,%esp
}
  810408:	89 d8                	mov    %ebx,%eax
  81040a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81040d:	5b                   	pop    %ebx
  81040e:	5e                   	pop    %esi
  81040f:	5d                   	pop    %ebp
  810410:	c3                   	ret    

00810411 <accept>:
{
  810411:	55                   	push   %ebp
  810412:	89 e5                	mov    %esp,%ebp
  810414:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810417:	8b 45 08             	mov    0x8(%ebp),%eax
  81041a:	e8 4e ff ff ff       	call   81036d <fd2sockid>
  81041f:	85 c0                	test   %eax,%eax
  810421:	78 1b                	js     81043e <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810423:	83 ec 04             	sub    $0x4,%esp
  810426:	ff 75 10             	pushl  0x10(%ebp)
  810429:	ff 75 0c             	pushl  0xc(%ebp)
  81042c:	50                   	push   %eax
  81042d:	e8 0e 01 00 00       	call   810540 <nsipc_accept>
  810432:	83 c4 10             	add    $0x10,%esp
  810435:	85 c0                	test   %eax,%eax
  810437:	78 05                	js     81043e <accept+0x2d>
	return alloc_sockfd(r);
  810439:	e8 5f ff ff ff       	call   81039d <alloc_sockfd>
}
  81043e:	c9                   	leave  
  81043f:	c3                   	ret    

00810440 <bind>:
{
  810440:	55                   	push   %ebp
  810441:	89 e5                	mov    %esp,%ebp
  810443:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810446:	8b 45 08             	mov    0x8(%ebp),%eax
  810449:	e8 1f ff ff ff       	call   81036d <fd2sockid>
  81044e:	85 c0                	test   %eax,%eax
  810450:	78 12                	js     810464 <bind+0x24>
	return nsipc_bind(r, name, namelen);
  810452:	83 ec 04             	sub    $0x4,%esp
  810455:	ff 75 10             	pushl  0x10(%ebp)
  810458:	ff 75 0c             	pushl  0xc(%ebp)
  81045b:	50                   	push   %eax
  81045c:	e8 31 01 00 00       	call   810592 <nsipc_bind>
  810461:	83 c4 10             	add    $0x10,%esp
}
  810464:	c9                   	leave  
  810465:	c3                   	ret    

00810466 <shutdown>:
{
  810466:	55                   	push   %ebp
  810467:	89 e5                	mov    %esp,%ebp
  810469:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81046c:	8b 45 08             	mov    0x8(%ebp),%eax
  81046f:	e8 f9 fe ff ff       	call   81036d <fd2sockid>
  810474:	85 c0                	test   %eax,%eax
  810476:	78 0f                	js     810487 <shutdown+0x21>
	return nsipc_shutdown(r, how);
  810478:	83 ec 08             	sub    $0x8,%esp
  81047b:	ff 75 0c             	pushl  0xc(%ebp)
  81047e:	50                   	push   %eax
  81047f:	e8 43 01 00 00       	call   8105c7 <nsipc_shutdown>
  810484:	83 c4 10             	add    $0x10,%esp
}
  810487:	c9                   	leave  
  810488:	c3                   	ret    

00810489 <connect>:
{
  810489:	55                   	push   %ebp
  81048a:	89 e5                	mov    %esp,%ebp
  81048c:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81048f:	8b 45 08             	mov    0x8(%ebp),%eax
  810492:	e8 d6 fe ff ff       	call   81036d <fd2sockid>
  810497:	85 c0                	test   %eax,%eax
  810499:	78 12                	js     8104ad <connect+0x24>
	return nsipc_connect(r, name, namelen);
  81049b:	83 ec 04             	sub    $0x4,%esp
  81049e:	ff 75 10             	pushl  0x10(%ebp)
  8104a1:	ff 75 0c             	pushl  0xc(%ebp)
  8104a4:	50                   	push   %eax
  8104a5:	e8 59 01 00 00       	call   810603 <nsipc_connect>
  8104aa:	83 c4 10             	add    $0x10,%esp
}
  8104ad:	c9                   	leave  
  8104ae:	c3                   	ret    

008104af <listen>:
{
  8104af:	55                   	push   %ebp
  8104b0:	89 e5                	mov    %esp,%ebp
  8104b2:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104b5:	8b 45 08             	mov    0x8(%ebp),%eax
  8104b8:	e8 b0 fe ff ff       	call   81036d <fd2sockid>
  8104bd:	85 c0                	test   %eax,%eax
  8104bf:	78 0f                	js     8104d0 <listen+0x21>
	return nsipc_listen(r, backlog);
  8104c1:	83 ec 08             	sub    $0x8,%esp
  8104c4:	ff 75 0c             	pushl  0xc(%ebp)
  8104c7:	50                   	push   %eax
  8104c8:	e8 6b 01 00 00       	call   810638 <nsipc_listen>
  8104cd:	83 c4 10             	add    $0x10,%esp
}
  8104d0:	c9                   	leave  
  8104d1:	c3                   	ret    

008104d2 <socket>:

int
socket(int domain, int type, int protocol)
{
  8104d2:	55                   	push   %ebp
  8104d3:	89 e5                	mov    %esp,%ebp
  8104d5:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8104d8:	ff 75 10             	pushl  0x10(%ebp)
  8104db:	ff 75 0c             	pushl  0xc(%ebp)
  8104de:	ff 75 08             	pushl  0x8(%ebp)
  8104e1:	e8 3e 02 00 00       	call   810724 <nsipc_socket>
  8104e6:	83 c4 10             	add    $0x10,%esp
  8104e9:	85 c0                	test   %eax,%eax
  8104eb:	78 05                	js     8104f2 <socket+0x20>
		return r;
	return alloc_sockfd(r);
  8104ed:	e8 ab fe ff ff       	call   81039d <alloc_sockfd>
}
  8104f2:	c9                   	leave  
  8104f3:	c3                   	ret    

008104f4 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8104f4:	55                   	push   %ebp
  8104f5:	89 e5                	mov    %esp,%ebp
  8104f7:	53                   	push   %ebx
  8104f8:	83 ec 04             	sub    $0x4,%esp
  8104fb:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8104fd:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  810504:	74 26                	je     81052c <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810506:	6a 07                	push   $0x7
  810508:	68 00 d0 b3 00       	push   $0xb3d000
  81050d:	53                   	push   %ebx
  81050e:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  810514:	e8 0f f5 ff ff       	call   80fa28 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810519:	83 c4 0c             	add    $0xc,%esp
  81051c:	6a 00                	push   $0x0
  81051e:	6a 00                	push   $0x0
  810520:	6a 00                	push   $0x0
  810522:	e8 98 f4 ff ff       	call   80f9bf <ipc_recv>
}
  810527:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81052a:	c9                   	leave  
  81052b:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  81052c:	83 ec 0c             	sub    $0xc,%esp
  81052f:	6a 02                	push   $0x2
  810531:	e8 4a f5 ff ff       	call   80fa80 <ipc_find_env>
  810536:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  81053b:	83 c4 10             	add    $0x10,%esp
  81053e:	eb c6                	jmp    810506 <nsipc+0x12>

00810540 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810540:	55                   	push   %ebp
  810541:	89 e5                	mov    %esp,%ebp
  810543:	56                   	push   %esi
  810544:	53                   	push   %ebx
  810545:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810548:	8b 45 08             	mov    0x8(%ebp),%eax
  81054b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810550:	8b 06                	mov    (%esi),%eax
  810552:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810557:	b8 01 00 00 00       	mov    $0x1,%eax
  81055c:	e8 93 ff ff ff       	call   8104f4 <nsipc>
  810561:	89 c3                	mov    %eax,%ebx
  810563:	85 c0                	test   %eax,%eax
  810565:	79 09                	jns    810570 <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  810567:	89 d8                	mov    %ebx,%eax
  810569:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81056c:	5b                   	pop    %ebx
  81056d:	5e                   	pop    %esi
  81056e:	5d                   	pop    %ebp
  81056f:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  810570:	83 ec 04             	sub    $0x4,%esp
  810573:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  810579:	68 00 d0 b3 00       	push   $0xb3d000
  81057e:	ff 75 0c             	pushl  0xc(%ebp)
  810581:	e8 05 ea ff ff       	call   80ef8b <memmove>
		*addrlen = ret->ret_addrlen;
  810586:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  81058b:	89 06                	mov    %eax,(%esi)
  81058d:	83 c4 10             	add    $0x10,%esp
	return r;
  810590:	eb d5                	jmp    810567 <nsipc_accept+0x27>

00810592 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810592:	55                   	push   %ebp
  810593:	89 e5                	mov    %esp,%ebp
  810595:	53                   	push   %ebx
  810596:	83 ec 08             	sub    $0x8,%esp
  810599:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  81059c:	8b 45 08             	mov    0x8(%ebp),%eax
  81059f:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8105a4:	53                   	push   %ebx
  8105a5:	ff 75 0c             	pushl  0xc(%ebp)
  8105a8:	68 04 d0 b3 00       	push   $0xb3d004
  8105ad:	e8 d9 e9 ff ff       	call   80ef8b <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8105b2:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  8105b8:	b8 02 00 00 00       	mov    $0x2,%eax
  8105bd:	e8 32 ff ff ff       	call   8104f4 <nsipc>
}
  8105c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8105c5:	c9                   	leave  
  8105c6:	c3                   	ret    

008105c7 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  8105c7:	55                   	push   %ebp
  8105c8:	89 e5                	mov    %esp,%ebp
  8105ca:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  8105cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8105d0:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  8105d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8105d8:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  8105dd:	b8 03 00 00 00       	mov    $0x3,%eax
  8105e2:	e8 0d ff ff ff       	call   8104f4 <nsipc>
}
  8105e7:	c9                   	leave  
  8105e8:	c3                   	ret    

008105e9 <nsipc_close>:

int
nsipc_close(int s)
{
  8105e9:	55                   	push   %ebp
  8105ea:	89 e5                	mov    %esp,%ebp
  8105ec:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  8105ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8105f2:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  8105f7:	b8 04 00 00 00       	mov    $0x4,%eax
  8105fc:	e8 f3 fe ff ff       	call   8104f4 <nsipc>
}
  810601:	c9                   	leave  
  810602:	c3                   	ret    

00810603 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810603:	55                   	push   %ebp
  810604:	89 e5                	mov    %esp,%ebp
  810606:	53                   	push   %ebx
  810607:	83 ec 08             	sub    $0x8,%esp
  81060a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  81060d:	8b 45 08             	mov    0x8(%ebp),%eax
  810610:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810615:	53                   	push   %ebx
  810616:	ff 75 0c             	pushl  0xc(%ebp)
  810619:	68 04 d0 b3 00       	push   $0xb3d004
  81061e:	e8 68 e9 ff ff       	call   80ef8b <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810623:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810629:	b8 05 00 00 00       	mov    $0x5,%eax
  81062e:	e8 c1 fe ff ff       	call   8104f4 <nsipc>
}
  810633:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810636:	c9                   	leave  
  810637:	c3                   	ret    

00810638 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810638:	55                   	push   %ebp
  810639:	89 e5                	mov    %esp,%ebp
  81063b:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  81063e:	8b 45 08             	mov    0x8(%ebp),%eax
  810641:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  810646:	8b 45 0c             	mov    0xc(%ebp),%eax
  810649:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  81064e:	b8 06 00 00 00       	mov    $0x6,%eax
  810653:	e8 9c fe ff ff       	call   8104f4 <nsipc>
}
  810658:	c9                   	leave  
  810659:	c3                   	ret    

0081065a <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  81065a:	55                   	push   %ebp
  81065b:	89 e5                	mov    %esp,%ebp
  81065d:	56                   	push   %esi
  81065e:	53                   	push   %ebx
  81065f:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  810662:	8b 45 08             	mov    0x8(%ebp),%eax
  810665:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  81066a:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  810670:	8b 45 14             	mov    0x14(%ebp),%eax
  810673:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810678:	b8 07 00 00 00       	mov    $0x7,%eax
  81067d:	e8 72 fe ff ff       	call   8104f4 <nsipc>
  810682:	89 c3                	mov    %eax,%ebx
  810684:	85 c0                	test   %eax,%eax
  810686:	78 1f                	js     8106a7 <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  810688:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  81068d:	7f 21                	jg     8106b0 <nsipc_recv+0x56>
  81068f:	39 c6                	cmp    %eax,%esi
  810691:	7c 1d                	jl     8106b0 <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810693:	83 ec 04             	sub    $0x4,%esp
  810696:	50                   	push   %eax
  810697:	68 00 d0 b3 00       	push   $0xb3d000
  81069c:	ff 75 0c             	pushl  0xc(%ebp)
  81069f:	e8 e7 e8 ff ff       	call   80ef8b <memmove>
  8106a4:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  8106a7:	89 d8                	mov    %ebx,%eax
  8106a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8106ac:	5b                   	pop    %ebx
  8106ad:	5e                   	pop    %esi
  8106ae:	5d                   	pop    %ebp
  8106af:	c3                   	ret    
		assert(r < 1600 && r <= len);
  8106b0:	68 42 3d 81 00       	push   $0x813d42
  8106b5:	68 6b 29 81 00       	push   $0x81296b
  8106ba:	6a 62                	push   $0x62
  8106bc:	68 57 3d 81 00       	push   $0x813d57
  8106c1:	e8 e2 de ff ff       	call   80e5a8 <_panic>

008106c6 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  8106c6:	55                   	push   %ebp
  8106c7:	89 e5                	mov    %esp,%ebp
  8106c9:	53                   	push   %ebx
  8106ca:	83 ec 04             	sub    $0x4,%esp
  8106cd:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8106d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8106d3:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  8106d8:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8106de:	7f 2e                	jg     81070e <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8106e0:	83 ec 04             	sub    $0x4,%esp
  8106e3:	53                   	push   %ebx
  8106e4:	ff 75 0c             	pushl  0xc(%ebp)
  8106e7:	68 0c d0 b3 00       	push   $0xb3d00c
  8106ec:	e8 9a e8 ff ff       	call   80ef8b <memmove>
	nsipcbuf.send.req_size = size;
  8106f1:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8106f7:	8b 45 14             	mov    0x14(%ebp),%eax
  8106fa:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  8106ff:	b8 08 00 00 00       	mov    $0x8,%eax
  810704:	e8 eb fd ff ff       	call   8104f4 <nsipc>
}
  810709:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81070c:	c9                   	leave  
  81070d:	c3                   	ret    
	assert(size < 1600);
  81070e:	68 63 3d 81 00       	push   $0x813d63
  810713:	68 6b 29 81 00       	push   $0x81296b
  810718:	6a 6d                	push   $0x6d
  81071a:	68 57 3d 81 00       	push   $0x813d57
  81071f:	e8 84 de ff ff       	call   80e5a8 <_panic>

00810724 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810724:	55                   	push   %ebp
  810725:	89 e5                	mov    %esp,%ebp
  810727:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  81072a:	8b 45 08             	mov    0x8(%ebp),%eax
  81072d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  810732:	8b 45 0c             	mov    0xc(%ebp),%eax
  810735:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  81073a:	8b 45 10             	mov    0x10(%ebp),%eax
  81073d:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  810742:	b8 09 00 00 00       	mov    $0x9,%eax
  810747:	e8 a8 fd ff ff       	call   8104f4 <nsipc>
}
  81074c:	c9                   	leave  
  81074d:	c3                   	ret    

0081074e <free>:
	return v;
}

void
free(void *v)
{
  81074e:	55                   	push   %ebp
  81074f:	89 e5                	mov    %esp,%ebp
  810751:	53                   	push   %ebx
  810752:	83 ec 04             	sub    $0x4,%esp
  810755:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810758:	85 db                	test   %ebx,%ebx
  81075a:	0f 84 85 00 00 00    	je     8107e5 <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810760:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810766:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  81076b:	77 51                	ja     8107be <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  81076d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810773:	89 d8                	mov    %ebx,%eax
  810775:	c1 e8 0c             	shr    $0xc,%eax
  810778:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  81077f:	f6 c4 02             	test   $0x2,%ah
  810782:	74 50                	je     8107d4 <free+0x86>
		sys_page_unmap(0, c);
  810784:	83 ec 08             	sub    $0x8,%esp
  810787:	53                   	push   %ebx
  810788:	6a 00                	push   $0x0
  81078a:	e8 e5 ea ff ff       	call   80f274 <sys_page_unmap>
		c += PGSIZE;
  81078f:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810795:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  81079b:	83 c4 10             	add    $0x10,%esp
  81079e:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8107a3:	76 ce                	jbe    810773 <free+0x25>
  8107a5:	68 ab 3d 81 00       	push   $0x813dab
  8107aa:	68 6b 29 81 00       	push   $0x81296b
  8107af:	68 81 00 00 00       	push   $0x81
  8107b4:	68 9e 3d 81 00       	push   $0x813d9e
  8107b9:	e8 ea dd ff ff       	call   80e5a8 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8107be:	68 70 3d 81 00       	push   $0x813d70
  8107c3:	68 6b 29 81 00       	push   $0x81296b
  8107c8:	6a 7a                	push   $0x7a
  8107ca:	68 9e 3d 81 00       	push   $0x813d9e
  8107cf:	e8 d4 dd ff ff       	call   80e5a8 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8107d4:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8107da:	83 e8 01             	sub    $0x1,%eax
  8107dd:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8107e3:	74 05                	je     8107ea <free+0x9c>
		sys_page_unmap(0, c);
}
  8107e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8107e8:	c9                   	leave  
  8107e9:	c3                   	ret    
		sys_page_unmap(0, c);
  8107ea:	83 ec 08             	sub    $0x8,%esp
  8107ed:	53                   	push   %ebx
  8107ee:	6a 00                	push   $0x0
  8107f0:	e8 7f ea ff ff       	call   80f274 <sys_page_unmap>
  8107f5:	83 c4 10             	add    $0x10,%esp
  8107f8:	eb eb                	jmp    8107e5 <free+0x97>

008107fa <malloc>:
{
  8107fa:	55                   	push   %ebp
  8107fb:	89 e5                	mov    %esp,%ebp
  8107fd:	57                   	push   %edi
  8107fe:	56                   	push   %esi
  8107ff:	53                   	push   %ebx
  810800:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810803:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  810808:	85 c0                	test   %eax,%eax
  81080a:	74 74                	je     810880 <malloc+0x86>
	n = ROUNDUP(n, 4);
  81080c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81080f:	8d 51 03             	lea    0x3(%ecx),%edx
  810812:	83 e2 fc             	and    $0xfffffffc,%edx
  810815:	89 d6                	mov    %edx,%esi
  810817:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  81081a:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810820:	0f 87 55 01 00 00    	ja     81097b <malloc+0x181>
	if ((uintptr_t) mptr % PGSIZE){
  810826:	89 c1                	mov    %eax,%ecx
  810828:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81082d:	74 30                	je     81085f <malloc+0x65>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81082f:	89 c3                	mov    %eax,%ebx
  810831:	c1 eb 0c             	shr    $0xc,%ebx
  810834:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810838:	c1 ea 0c             	shr    $0xc,%edx
  81083b:	39 d3                	cmp    %edx,%ebx
  81083d:	74 64                	je     8108a3 <malloc+0xa9>
		free(mptr);	/* drop reference to this page */
  81083f:	83 ec 0c             	sub    $0xc,%esp
  810842:	50                   	push   %eax
  810843:	e8 06 ff ff ff       	call   81074e <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810848:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  81084d:	05 00 10 00 00       	add    $0x1000,%eax
  810852:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810857:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  81085c:	83 c4 10             	add    $0x10,%esp
  81085f:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  810865:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  81086c:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  810871:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810874:	8d 78 04             	lea    0x4(%eax),%edi
  810877:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  81087b:	e9 86 00 00 00       	jmp    810906 <malloc+0x10c>
		mptr = mbegin;
  810880:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810887:	00 00 08 
	n = ROUNDUP(n, 4);
  81088a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81088d:	8d 51 03             	lea    0x3(%ecx),%edx
  810890:	83 e2 fc             	and    $0xfffffffc,%edx
  810893:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810896:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  81089c:	76 c1                	jbe    81085f <malloc+0x65>
  81089e:	e9 fd 00 00 00       	jmp    8109a0 <malloc+0x1a6>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8108a3:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  8108a9:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  8108af:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  8108b3:	89 f2                	mov    %esi,%edx
  8108b5:	01 c2                	add    %eax,%edx
  8108b7:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  8108bd:	e9 de 00 00 00       	jmp    8109a0 <malloc+0x1a6>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8108c2:	05 00 10 00 00       	add    $0x1000,%eax
  8108c7:	39 c8                	cmp    %ecx,%eax
  8108c9:	73 66                	jae    810931 <malloc+0x137>
		if (va >= (uintptr_t) mend
  8108cb:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8108d0:	77 22                	ja     8108f4 <malloc+0xfa>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8108d2:	89 c3                	mov    %eax,%ebx
  8108d4:	c1 eb 16             	shr    $0x16,%ebx
  8108d7:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  8108de:	f6 c3 01             	test   $0x1,%bl
  8108e1:	74 df                	je     8108c2 <malloc+0xc8>
  8108e3:	89 c3                	mov    %eax,%ebx
  8108e5:	c1 eb 0c             	shr    $0xc,%ebx
  8108e8:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  8108ef:	f6 c3 01             	test   $0x1,%bl
  8108f2:	74 ce                	je     8108c2 <malloc+0xc8>
  8108f4:	81 c2 00 10 00 00    	add    $0x1000,%edx
  8108fa:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  8108fe:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  810904:	74 0a                	je     810910 <malloc+0x116>
  810906:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810909:	89 d0                	mov    %edx,%eax
  81090b:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  81090e:	eb b7                	jmp    8108c7 <malloc+0xcd>
			mptr = mbegin;
  810910:	ba 00 00 00 08       	mov    $0x8000000,%edx
  810915:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  81091a:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  81091e:	75 e6                	jne    810906 <malloc+0x10c>
  810920:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810927:	00 00 08 
				return 0;	/* out of address space */
  81092a:	b8 00 00 00 00       	mov    $0x0,%eax
  81092f:	eb 6f                	jmp    8109a0 <malloc+0x1a6>
  810931:	89 f0                	mov    %esi,%eax
  810933:	84 c0                	test   %al,%al
  810935:	74 08                	je     81093f <malloc+0x145>
  810937:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81093a:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  81093f:	bb 00 00 00 00       	mov    $0x0,%ebx
  810944:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810947:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  81094d:	39 f7                	cmp    %esi,%edi
  81094f:	76 57                	jbe    8109a8 <malloc+0x1ae>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810951:	83 ec 04             	sub    $0x4,%esp
  810954:	68 07 02 00 00       	push   $0x207
  810959:	89 d8                	mov    %ebx,%eax
  81095b:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810961:	50                   	push   %eax
  810962:	6a 00                	push   $0x0
  810964:	e8 86 e8 ff ff       	call   80f1ef <sys_page_alloc>
  810969:	83 c4 10             	add    $0x10,%esp
  81096c:	85 c0                	test   %eax,%eax
  81096e:	78 55                	js     8109c5 <malloc+0x1cb>
	for (i = 0; i < n + 4; i += PGSIZE){
  810970:	89 f3                	mov    %esi,%ebx
  810972:	eb d0                	jmp    810944 <malloc+0x14a>
			return 0;	/* out of physical memory */
  810974:	b8 00 00 00 00       	mov    $0x0,%eax
  810979:	eb 25                	jmp    8109a0 <malloc+0x1a6>
		return 0;
  81097b:	b8 00 00 00 00       	mov    $0x0,%eax
  810980:	eb 1e                	jmp    8109a0 <malloc+0x1a6>
	ref = (uint32_t*) (mptr + i - 4);
  810982:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810987:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  81098a:	c7 84 08 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%ecx,1)
  810991:	02 00 00 00 
	mptr += n;
  810995:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810998:	01 c2                	add    %eax,%edx
  81099a:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  8109a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8109a3:	5b                   	pop    %ebx
  8109a4:	5e                   	pop    %esi
  8109a5:	5f                   	pop    %edi
  8109a6:	5d                   	pop    %ebp
  8109a7:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8109a8:	83 ec 04             	sub    $0x4,%esp
  8109ab:	6a 07                	push   $0x7
  8109ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8109b0:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  8109b6:	50                   	push   %eax
  8109b7:	6a 00                	push   $0x0
  8109b9:	e8 31 e8 ff ff       	call   80f1ef <sys_page_alloc>
  8109be:	83 c4 10             	add    $0x10,%esp
  8109c1:	85 c0                	test   %eax,%eax
  8109c3:	79 bd                	jns    810982 <malloc+0x188>
			for (; i >= 0; i -= PGSIZE)
  8109c5:	85 db                	test   %ebx,%ebx
  8109c7:	78 ab                	js     810974 <malloc+0x17a>
				sys_page_unmap(0, mptr + i);
  8109c9:	83 ec 08             	sub    $0x8,%esp
  8109cc:	89 d8                	mov    %ebx,%eax
  8109ce:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  8109d4:	50                   	push   %eax
  8109d5:	6a 00                	push   $0x0
  8109d7:	e8 98 e8 ff ff       	call   80f274 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  8109dc:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  8109e2:	83 c4 10             	add    $0x10,%esp
  8109e5:	eb de                	jmp    8109c5 <malloc+0x1cb>

008109e7 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8109e7:	55                   	push   %ebp
  8109e8:	89 e5                	mov    %esp,%ebp
  8109ea:	56                   	push   %esi
  8109eb:	53                   	push   %ebx
  8109ec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8109ef:	83 ec 0c             	sub    $0xc,%esp
  8109f2:	ff 75 08             	pushl  0x8(%ebp)
  8109f5:	e8 d1 f0 ff ff       	call   80facb <fd2data>
  8109fa:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8109fc:	83 c4 08             	add    $0x8,%esp
  8109ff:	68 c3 3d 81 00       	push   $0x813dc3
  810a04:	53                   	push   %ebx
  810a05:	e8 f3 e3 ff ff       	call   80edfd <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810a0a:	8b 46 04             	mov    0x4(%esi),%eax
  810a0d:	2b 06                	sub    (%esi),%eax
  810a0f:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810a15:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810a1c:	00 00 00 
	stat->st_dev = &devpipe;
  810a1f:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810a26:	43 81 00 
	return 0;
}
  810a29:	b8 00 00 00 00       	mov    $0x0,%eax
  810a2e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810a31:	5b                   	pop    %ebx
  810a32:	5e                   	pop    %esi
  810a33:	5d                   	pop    %ebp
  810a34:	c3                   	ret    

00810a35 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810a35:	55                   	push   %ebp
  810a36:	89 e5                	mov    %esp,%ebp
  810a38:	53                   	push   %ebx
  810a39:	83 ec 0c             	sub    $0xc,%esp
  810a3c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810a3f:	53                   	push   %ebx
  810a40:	6a 00                	push   $0x0
  810a42:	e8 2d e8 ff ff       	call   80f274 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810a47:	89 1c 24             	mov    %ebx,(%esp)
  810a4a:	e8 7c f0 ff ff       	call   80facb <fd2data>
  810a4f:	83 c4 08             	add    $0x8,%esp
  810a52:	50                   	push   %eax
  810a53:	6a 00                	push   $0x0
  810a55:	e8 1a e8 ff ff       	call   80f274 <sys_page_unmap>
}
  810a5a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810a5d:	c9                   	leave  
  810a5e:	c3                   	ret    

00810a5f <_pipeisclosed>:
{
  810a5f:	55                   	push   %ebp
  810a60:	89 e5                	mov    %esp,%ebp
  810a62:	57                   	push   %edi
  810a63:	56                   	push   %esi
  810a64:	53                   	push   %ebx
  810a65:	83 ec 1c             	sub    $0x1c,%esp
  810a68:	89 c7                	mov    %eax,%edi
  810a6a:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810a6c:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810a71:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810a74:	83 ec 0c             	sub    $0xc,%esp
  810a77:	57                   	push   %edi
  810a78:	e8 c2 04 00 00       	call   810f3f <pageref>
  810a7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810a80:	89 34 24             	mov    %esi,(%esp)
  810a83:	e8 b7 04 00 00       	call   810f3f <pageref>
		nn = thisenv->env_runs;
  810a88:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810a8e:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810a91:	83 c4 10             	add    $0x10,%esp
  810a94:	39 cb                	cmp    %ecx,%ebx
  810a96:	74 1b                	je     810ab3 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810a98:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810a9b:	75 cf                	jne    810a6c <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810a9d:	8b 42 58             	mov    0x58(%edx),%eax
  810aa0:	6a 01                	push   $0x1
  810aa2:	50                   	push   %eax
  810aa3:	53                   	push   %ebx
  810aa4:	68 ca 3d 81 00       	push   $0x813dca
  810aa9:	e8 f0 db ff ff       	call   80e69e <cprintf>
  810aae:	83 c4 10             	add    $0x10,%esp
  810ab1:	eb b9                	jmp    810a6c <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810ab3:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810ab6:	0f 94 c0             	sete   %al
  810ab9:	0f b6 c0             	movzbl %al,%eax
}
  810abc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810abf:	5b                   	pop    %ebx
  810ac0:	5e                   	pop    %esi
  810ac1:	5f                   	pop    %edi
  810ac2:	5d                   	pop    %ebp
  810ac3:	c3                   	ret    

00810ac4 <devpipe_write>:
{
  810ac4:	55                   	push   %ebp
  810ac5:	89 e5                	mov    %esp,%ebp
  810ac7:	57                   	push   %edi
  810ac8:	56                   	push   %esi
  810ac9:	53                   	push   %ebx
  810aca:	83 ec 28             	sub    $0x28,%esp
  810acd:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810ad0:	56                   	push   %esi
  810ad1:	e8 f5 ef ff ff       	call   80facb <fd2data>
  810ad6:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810ad8:	83 c4 10             	add    $0x10,%esp
  810adb:	bf 00 00 00 00       	mov    $0x0,%edi
  810ae0:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810ae3:	74 4f                	je     810b34 <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810ae5:	8b 43 04             	mov    0x4(%ebx),%eax
  810ae8:	8b 0b                	mov    (%ebx),%ecx
  810aea:	8d 51 20             	lea    0x20(%ecx),%edx
  810aed:	39 d0                	cmp    %edx,%eax
  810aef:	72 14                	jb     810b05 <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810af1:	89 da                	mov    %ebx,%edx
  810af3:	89 f0                	mov    %esi,%eax
  810af5:	e8 65 ff ff ff       	call   810a5f <_pipeisclosed>
  810afa:	85 c0                	test   %eax,%eax
  810afc:	75 3b                	jne    810b39 <devpipe_write+0x75>
			sys_yield();
  810afe:	e8 cd e6 ff ff       	call   80f1d0 <sys_yield>
  810b03:	eb e0                	jmp    810ae5 <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810b05:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810b08:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810b0c:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810b0f:	89 c2                	mov    %eax,%edx
  810b11:	c1 fa 1f             	sar    $0x1f,%edx
  810b14:	89 d1                	mov    %edx,%ecx
  810b16:	c1 e9 1b             	shr    $0x1b,%ecx
  810b19:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810b1c:	83 e2 1f             	and    $0x1f,%edx
  810b1f:	29 ca                	sub    %ecx,%edx
  810b21:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810b25:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810b29:	83 c0 01             	add    $0x1,%eax
  810b2c:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810b2f:	83 c7 01             	add    $0x1,%edi
  810b32:	eb ac                	jmp    810ae0 <devpipe_write+0x1c>
	return i;
  810b34:	8b 45 10             	mov    0x10(%ebp),%eax
  810b37:	eb 05                	jmp    810b3e <devpipe_write+0x7a>
				return 0;
  810b39:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810b3e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b41:	5b                   	pop    %ebx
  810b42:	5e                   	pop    %esi
  810b43:	5f                   	pop    %edi
  810b44:	5d                   	pop    %ebp
  810b45:	c3                   	ret    

00810b46 <devpipe_read>:
{
  810b46:	55                   	push   %ebp
  810b47:	89 e5                	mov    %esp,%ebp
  810b49:	57                   	push   %edi
  810b4a:	56                   	push   %esi
  810b4b:	53                   	push   %ebx
  810b4c:	83 ec 18             	sub    $0x18,%esp
  810b4f:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810b52:	57                   	push   %edi
  810b53:	e8 73 ef ff ff       	call   80facb <fd2data>
  810b58:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810b5a:	83 c4 10             	add    $0x10,%esp
  810b5d:	be 00 00 00 00       	mov    $0x0,%esi
  810b62:	3b 75 10             	cmp    0x10(%ebp),%esi
  810b65:	75 14                	jne    810b7b <devpipe_read+0x35>
	return i;
  810b67:	8b 45 10             	mov    0x10(%ebp),%eax
  810b6a:	eb 02                	jmp    810b6e <devpipe_read+0x28>
				return i;
  810b6c:	89 f0                	mov    %esi,%eax
}
  810b6e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b71:	5b                   	pop    %ebx
  810b72:	5e                   	pop    %esi
  810b73:	5f                   	pop    %edi
  810b74:	5d                   	pop    %ebp
  810b75:	c3                   	ret    
			sys_yield();
  810b76:	e8 55 e6 ff ff       	call   80f1d0 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810b7b:	8b 03                	mov    (%ebx),%eax
  810b7d:	3b 43 04             	cmp    0x4(%ebx),%eax
  810b80:	75 18                	jne    810b9a <devpipe_read+0x54>
			if (i > 0)
  810b82:	85 f6                	test   %esi,%esi
  810b84:	75 e6                	jne    810b6c <devpipe_read+0x26>
			if (_pipeisclosed(fd, p))
  810b86:	89 da                	mov    %ebx,%edx
  810b88:	89 f8                	mov    %edi,%eax
  810b8a:	e8 d0 fe ff ff       	call   810a5f <_pipeisclosed>
  810b8f:	85 c0                	test   %eax,%eax
  810b91:	74 e3                	je     810b76 <devpipe_read+0x30>
				return 0;
  810b93:	b8 00 00 00 00       	mov    $0x0,%eax
  810b98:	eb d4                	jmp    810b6e <devpipe_read+0x28>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810b9a:	99                   	cltd   
  810b9b:	c1 ea 1b             	shr    $0x1b,%edx
  810b9e:	01 d0                	add    %edx,%eax
  810ba0:	83 e0 1f             	and    $0x1f,%eax
  810ba3:	29 d0                	sub    %edx,%eax
  810ba5:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810baa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810bad:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810bb0:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810bb3:	83 c6 01             	add    $0x1,%esi
  810bb6:	eb aa                	jmp    810b62 <devpipe_read+0x1c>

00810bb8 <pipe>:
{
  810bb8:	55                   	push   %ebp
  810bb9:	89 e5                	mov    %esp,%ebp
  810bbb:	56                   	push   %esi
  810bbc:	53                   	push   %ebx
  810bbd:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810bc0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810bc3:	50                   	push   %eax
  810bc4:	e8 19 ef ff ff       	call   80fae2 <fd_alloc>
  810bc9:	89 c3                	mov    %eax,%ebx
  810bcb:	83 c4 10             	add    $0x10,%esp
  810bce:	85 c0                	test   %eax,%eax
  810bd0:	0f 88 23 01 00 00    	js     810cf9 <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810bd6:	83 ec 04             	sub    $0x4,%esp
  810bd9:	68 07 04 00 00       	push   $0x407
  810bde:	ff 75 f4             	pushl  -0xc(%ebp)
  810be1:	6a 00                	push   $0x0
  810be3:	e8 07 e6 ff ff       	call   80f1ef <sys_page_alloc>
  810be8:	89 c3                	mov    %eax,%ebx
  810bea:	83 c4 10             	add    $0x10,%esp
  810bed:	85 c0                	test   %eax,%eax
  810bef:	0f 88 04 01 00 00    	js     810cf9 <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  810bf5:	83 ec 0c             	sub    $0xc,%esp
  810bf8:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810bfb:	50                   	push   %eax
  810bfc:	e8 e1 ee ff ff       	call   80fae2 <fd_alloc>
  810c01:	89 c3                	mov    %eax,%ebx
  810c03:	83 c4 10             	add    $0x10,%esp
  810c06:	85 c0                	test   %eax,%eax
  810c08:	0f 88 db 00 00 00    	js     810ce9 <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810c0e:	83 ec 04             	sub    $0x4,%esp
  810c11:	68 07 04 00 00       	push   $0x407
  810c16:	ff 75 f0             	pushl  -0x10(%ebp)
  810c19:	6a 00                	push   $0x0
  810c1b:	e8 cf e5 ff ff       	call   80f1ef <sys_page_alloc>
  810c20:	89 c3                	mov    %eax,%ebx
  810c22:	83 c4 10             	add    $0x10,%esp
  810c25:	85 c0                	test   %eax,%eax
  810c27:	0f 88 bc 00 00 00    	js     810ce9 <pipe+0x131>
	va = fd2data(fd0);
  810c2d:	83 ec 0c             	sub    $0xc,%esp
  810c30:	ff 75 f4             	pushl  -0xc(%ebp)
  810c33:	e8 93 ee ff ff       	call   80facb <fd2data>
  810c38:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810c3a:	83 c4 0c             	add    $0xc,%esp
  810c3d:	68 07 04 00 00       	push   $0x407
  810c42:	50                   	push   %eax
  810c43:	6a 00                	push   $0x0
  810c45:	e8 a5 e5 ff ff       	call   80f1ef <sys_page_alloc>
  810c4a:	89 c3                	mov    %eax,%ebx
  810c4c:	83 c4 10             	add    $0x10,%esp
  810c4f:	85 c0                	test   %eax,%eax
  810c51:	0f 88 82 00 00 00    	js     810cd9 <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810c57:	83 ec 0c             	sub    $0xc,%esp
  810c5a:	ff 75 f0             	pushl  -0x10(%ebp)
  810c5d:	e8 69 ee ff ff       	call   80facb <fd2data>
  810c62:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810c69:	50                   	push   %eax
  810c6a:	6a 00                	push   $0x0
  810c6c:	56                   	push   %esi
  810c6d:	6a 00                	push   $0x0
  810c6f:	e8 be e5 ff ff       	call   80f232 <sys_page_map>
  810c74:	89 c3                	mov    %eax,%ebx
  810c76:	83 c4 20             	add    $0x20,%esp
  810c79:	85 c0                	test   %eax,%eax
  810c7b:	78 4e                	js     810ccb <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  810c7d:	a1 24 43 81 00       	mov    0x814324,%eax
  810c82:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c85:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810c87:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810c8a:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810c91:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810c94:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810c96:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810c99:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810ca0:	83 ec 0c             	sub    $0xc,%esp
  810ca3:	ff 75 f4             	pushl  -0xc(%ebp)
  810ca6:	e8 10 ee ff ff       	call   80fabb <fd2num>
  810cab:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810cae:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810cb0:	83 c4 04             	add    $0x4,%esp
  810cb3:	ff 75 f0             	pushl  -0x10(%ebp)
  810cb6:	e8 00 ee ff ff       	call   80fabb <fd2num>
  810cbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810cbe:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810cc1:	83 c4 10             	add    $0x10,%esp
  810cc4:	bb 00 00 00 00       	mov    $0x0,%ebx
  810cc9:	eb 2e                	jmp    810cf9 <pipe+0x141>
	sys_page_unmap(0, va);
  810ccb:	83 ec 08             	sub    $0x8,%esp
  810cce:	56                   	push   %esi
  810ccf:	6a 00                	push   $0x0
  810cd1:	e8 9e e5 ff ff       	call   80f274 <sys_page_unmap>
  810cd6:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810cd9:	83 ec 08             	sub    $0x8,%esp
  810cdc:	ff 75 f0             	pushl  -0x10(%ebp)
  810cdf:	6a 00                	push   $0x0
  810ce1:	e8 8e e5 ff ff       	call   80f274 <sys_page_unmap>
  810ce6:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810ce9:	83 ec 08             	sub    $0x8,%esp
  810cec:	ff 75 f4             	pushl  -0xc(%ebp)
  810cef:	6a 00                	push   $0x0
  810cf1:	e8 7e e5 ff ff       	call   80f274 <sys_page_unmap>
  810cf6:	83 c4 10             	add    $0x10,%esp
}
  810cf9:	89 d8                	mov    %ebx,%eax
  810cfb:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810cfe:	5b                   	pop    %ebx
  810cff:	5e                   	pop    %esi
  810d00:	5d                   	pop    %ebp
  810d01:	c3                   	ret    

00810d02 <pipeisclosed>:
{
  810d02:	55                   	push   %ebp
  810d03:	89 e5                	mov    %esp,%ebp
  810d05:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810d08:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810d0b:	50                   	push   %eax
  810d0c:	ff 75 08             	pushl  0x8(%ebp)
  810d0f:	e8 20 ee ff ff       	call   80fb34 <fd_lookup>
  810d14:	83 c4 10             	add    $0x10,%esp
  810d17:	85 c0                	test   %eax,%eax
  810d19:	78 18                	js     810d33 <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810d1b:	83 ec 0c             	sub    $0xc,%esp
  810d1e:	ff 75 f4             	pushl  -0xc(%ebp)
  810d21:	e8 a5 ed ff ff       	call   80facb <fd2data>
	return _pipeisclosed(fd, p);
  810d26:	89 c2                	mov    %eax,%edx
  810d28:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810d2b:	e8 2f fd ff ff       	call   810a5f <_pipeisclosed>
  810d30:	83 c4 10             	add    $0x10,%esp
}
  810d33:	c9                   	leave  
  810d34:	c3                   	ret    

00810d35 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810d35:	b8 00 00 00 00       	mov    $0x0,%eax
  810d3a:	c3                   	ret    

00810d3b <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810d3b:	55                   	push   %ebp
  810d3c:	89 e5                	mov    %esp,%ebp
  810d3e:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810d41:	68 e2 3d 81 00       	push   $0x813de2
  810d46:	ff 75 0c             	pushl  0xc(%ebp)
  810d49:	e8 af e0 ff ff       	call   80edfd <strcpy>
	return 0;
}
  810d4e:	b8 00 00 00 00       	mov    $0x0,%eax
  810d53:	c9                   	leave  
  810d54:	c3                   	ret    

00810d55 <devcons_write>:
{
  810d55:	55                   	push   %ebp
  810d56:	89 e5                	mov    %esp,%ebp
  810d58:	57                   	push   %edi
  810d59:	56                   	push   %esi
  810d5a:	53                   	push   %ebx
  810d5b:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810d61:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810d66:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810d6c:	3b 75 10             	cmp    0x10(%ebp),%esi
  810d6f:	73 31                	jae    810da2 <devcons_write+0x4d>
		m = n - tot;
  810d71:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810d74:	29 f3                	sub    %esi,%ebx
  810d76:	83 fb 7f             	cmp    $0x7f,%ebx
  810d79:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810d7e:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810d81:	83 ec 04             	sub    $0x4,%esp
  810d84:	53                   	push   %ebx
  810d85:	89 f0                	mov    %esi,%eax
  810d87:	03 45 0c             	add    0xc(%ebp),%eax
  810d8a:	50                   	push   %eax
  810d8b:	57                   	push   %edi
  810d8c:	e8 fa e1 ff ff       	call   80ef8b <memmove>
		sys_cputs(buf, m);
  810d91:	83 c4 08             	add    $0x8,%esp
  810d94:	53                   	push   %ebx
  810d95:	57                   	push   %edi
  810d96:	e8 98 e3 ff ff       	call   80f133 <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810d9b:	01 de                	add    %ebx,%esi
  810d9d:	83 c4 10             	add    $0x10,%esp
  810da0:	eb ca                	jmp    810d6c <devcons_write+0x17>
}
  810da2:	89 f0                	mov    %esi,%eax
  810da4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810da7:	5b                   	pop    %ebx
  810da8:	5e                   	pop    %esi
  810da9:	5f                   	pop    %edi
  810daa:	5d                   	pop    %ebp
  810dab:	c3                   	ret    

00810dac <devcons_read>:
{
  810dac:	55                   	push   %ebp
  810dad:	89 e5                	mov    %esp,%ebp
  810daf:	83 ec 08             	sub    $0x8,%esp
  810db2:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810db7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810dbb:	74 21                	je     810dde <devcons_read+0x32>
	while ((c = sys_cgetc()) == 0)
  810dbd:	e8 8f e3 ff ff       	call   80f151 <sys_cgetc>
  810dc2:	85 c0                	test   %eax,%eax
  810dc4:	75 07                	jne    810dcd <devcons_read+0x21>
		sys_yield();
  810dc6:	e8 05 e4 ff ff       	call   80f1d0 <sys_yield>
  810dcb:	eb f0                	jmp    810dbd <devcons_read+0x11>
	if (c < 0)
  810dcd:	78 0f                	js     810dde <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  810dcf:	83 f8 04             	cmp    $0x4,%eax
  810dd2:	74 0c                	je     810de0 <devcons_read+0x34>
	*(char*)vbuf = c;
  810dd4:	8b 55 0c             	mov    0xc(%ebp),%edx
  810dd7:	88 02                	mov    %al,(%edx)
	return 1;
  810dd9:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810dde:	c9                   	leave  
  810ddf:	c3                   	ret    
		return 0;
  810de0:	b8 00 00 00 00       	mov    $0x0,%eax
  810de5:	eb f7                	jmp    810dde <devcons_read+0x32>

00810de7 <cputchar>:
{
  810de7:	55                   	push   %ebp
  810de8:	89 e5                	mov    %esp,%ebp
  810dea:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810ded:	8b 45 08             	mov    0x8(%ebp),%eax
  810df0:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810df3:	6a 01                	push   $0x1
  810df5:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810df8:	50                   	push   %eax
  810df9:	e8 35 e3 ff ff       	call   80f133 <sys_cputs>
}
  810dfe:	83 c4 10             	add    $0x10,%esp
  810e01:	c9                   	leave  
  810e02:	c3                   	ret    

00810e03 <getchar>:
{
  810e03:	55                   	push   %ebp
  810e04:	89 e5                	mov    %esp,%ebp
  810e06:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810e09:	6a 01                	push   $0x1
  810e0b:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810e0e:	50                   	push   %eax
  810e0f:	6a 00                	push   $0x0
  810e11:	e8 8e ef ff ff       	call   80fda4 <read>
	if (r < 0)
  810e16:	83 c4 10             	add    $0x10,%esp
  810e19:	85 c0                	test   %eax,%eax
  810e1b:	78 06                	js     810e23 <getchar+0x20>
	if (r < 1)
  810e1d:	74 06                	je     810e25 <getchar+0x22>
	return c;
  810e1f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810e23:	c9                   	leave  
  810e24:	c3                   	ret    
		return -E_EOF;
  810e25:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810e2a:	eb f7                	jmp    810e23 <getchar+0x20>

00810e2c <iscons>:
{
  810e2c:	55                   	push   %ebp
  810e2d:	89 e5                	mov    %esp,%ebp
  810e2f:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810e32:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e35:	50                   	push   %eax
  810e36:	ff 75 08             	pushl  0x8(%ebp)
  810e39:	e8 f6 ec ff ff       	call   80fb34 <fd_lookup>
  810e3e:	83 c4 10             	add    $0x10,%esp
  810e41:	85 c0                	test   %eax,%eax
  810e43:	78 11                	js     810e56 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  810e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e48:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810e4e:	39 10                	cmp    %edx,(%eax)
  810e50:	0f 94 c0             	sete   %al
  810e53:	0f b6 c0             	movzbl %al,%eax
}
  810e56:	c9                   	leave  
  810e57:	c3                   	ret    

00810e58 <opencons>:
{
  810e58:	55                   	push   %ebp
  810e59:	89 e5                	mov    %esp,%ebp
  810e5b:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810e5e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e61:	50                   	push   %eax
  810e62:	e8 7b ec ff ff       	call   80fae2 <fd_alloc>
  810e67:	83 c4 10             	add    $0x10,%esp
  810e6a:	85 c0                	test   %eax,%eax
  810e6c:	78 3a                	js     810ea8 <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810e6e:	83 ec 04             	sub    $0x4,%esp
  810e71:	68 07 04 00 00       	push   $0x407
  810e76:	ff 75 f4             	pushl  -0xc(%ebp)
  810e79:	6a 00                	push   $0x0
  810e7b:	e8 6f e3 ff ff       	call   80f1ef <sys_page_alloc>
  810e80:	83 c4 10             	add    $0x10,%esp
  810e83:	85 c0                	test   %eax,%eax
  810e85:	78 21                	js     810ea8 <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  810e87:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e8a:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810e90:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810e92:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e95:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810e9c:	83 ec 0c             	sub    $0xc,%esp
  810e9f:	50                   	push   %eax
  810ea0:	e8 16 ec ff ff       	call   80fabb <fd2num>
  810ea5:	83 c4 10             	add    $0x10,%esp
}
  810ea8:	c9                   	leave  
  810ea9:	c3                   	ret    

00810eaa <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810eaa:	55                   	push   %ebp
  810eab:	89 e5                	mov    %esp,%ebp
  810ead:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810eb0:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810eb7:	74 0a                	je     810ec3 <set_pgfault_handler+0x19>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
		// panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810eb9:	8b 45 08             	mov    0x8(%ebp),%eax
  810ebc:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810ec1:	c9                   	leave  
  810ec2:	c3                   	ret    
		r = sys_page_alloc((envid_t)0, (void*)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P);
  810ec3:	83 ec 04             	sub    $0x4,%esp
  810ec6:	6a 07                	push   $0x7
  810ec8:	68 00 f0 bf ee       	push   $0xeebff000
  810ecd:	6a 00                	push   $0x0
  810ecf:	e8 1b e3 ff ff       	call   80f1ef <sys_page_alloc>
		if(r < 0)
  810ed4:	83 c4 10             	add    $0x10,%esp
  810ed7:	85 c0                	test   %eax,%eax
  810ed9:	78 2a                	js     810f05 <set_pgfault_handler+0x5b>
		r = sys_env_set_pgfault_upcall((envid_t)0, _pgfault_upcall);
  810edb:	83 ec 08             	sub    $0x8,%esp
  810ede:	68 19 0f 81 00       	push   $0x810f19
  810ee3:	6a 00                	push   $0x0
  810ee5:	e8 50 e4 ff ff       	call   80f33a <sys_env_set_pgfault_upcall>
		if(r < 0)
  810eea:	83 c4 10             	add    $0x10,%esp
  810eed:	85 c0                	test   %eax,%eax
  810eef:	79 c8                	jns    810eb9 <set_pgfault_handler+0xf>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
  810ef1:	83 ec 04             	sub    $0x4,%esp
  810ef4:	68 20 3e 81 00       	push   $0x813e20
  810ef9:	6a 25                	push   $0x25
  810efb:	68 5c 3e 81 00       	push   $0x813e5c
  810f00:	e8 a3 d6 ff ff       	call   80e5a8 <_panic>
			panic("the sys_page_alloc() return value is wrong!\n");
  810f05:	83 ec 04             	sub    $0x4,%esp
  810f08:	68 f0 3d 81 00       	push   $0x813df0
  810f0d:	6a 22                	push   $0x22
  810f0f:	68 5c 3e 81 00       	push   $0x813e5c
  810f14:	e8 8f d6 ff ff       	call   80e5a8 <_panic>

00810f19 <_pgfault_upcall>:
_pgfault_upcall:
	//movl testxixi, %eax 
	//call *%eax 

	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810f19:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810f1a:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  810f1f:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810f21:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %ebx 
  810f24:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl 0x30(%esp), %eax 
  810f28:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax 
  810f2c:	83 e8 04             	sub    $0x4,%eax
	movl %ebx, (%eax)
  810f2f:	89 18                	mov    %ebx,(%eax)
	movl %eax, 0x30(%esp)
  810f31:	89 44 24 30          	mov    %eax,0x30(%esp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp 
  810f35:	83 c4 08             	add    $0x8,%esp
	popal
  810f38:	61                   	popa   
	
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp
  810f39:	83 c4 04             	add    $0x4,%esp
	popfl
  810f3c:	9d                   	popf   
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  810f3d:	5c                   	pop    %esp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
  810f3e:	c3                   	ret    

00810f3f <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  810f3f:	55                   	push   %ebp
  810f40:	89 e5                	mov    %esp,%ebp
  810f42:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  810f45:	89 d0                	mov    %edx,%eax
  810f47:	c1 e8 16             	shr    $0x16,%eax
  810f4a:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  810f51:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  810f56:	f6 c1 01             	test   $0x1,%cl
  810f59:	74 1d                	je     810f78 <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  810f5b:	c1 ea 0c             	shr    $0xc,%edx
  810f5e:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  810f65:	f6 c2 01             	test   $0x1,%dl
  810f68:	74 0e                	je     810f78 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  810f6a:	c1 ea 0c             	shr    $0xc,%edx
  810f6d:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  810f74:	ef 
  810f75:	0f b7 c0             	movzwl %ax,%eax
}
  810f78:	5d                   	pop    %ebp
  810f79:	c3                   	ret    
  810f7a:	66 90                	xchg   %ax,%ax
  810f7c:	66 90                	xchg   %ax,%ax
  810f7e:	66 90                	xchg   %ax,%ax

00810f80 <__udivdi3>:
  810f80:	55                   	push   %ebp
  810f81:	57                   	push   %edi
  810f82:	56                   	push   %esi
  810f83:	53                   	push   %ebx
  810f84:	83 ec 1c             	sub    $0x1c,%esp
  810f87:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  810f8b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  810f8f:	8b 74 24 34          	mov    0x34(%esp),%esi
  810f93:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  810f97:	85 d2                	test   %edx,%edx
  810f99:	75 4d                	jne    810fe8 <__udivdi3+0x68>
  810f9b:	39 f3                	cmp    %esi,%ebx
  810f9d:	76 19                	jbe    810fb8 <__udivdi3+0x38>
  810f9f:	31 ff                	xor    %edi,%edi
  810fa1:	89 e8                	mov    %ebp,%eax
  810fa3:	89 f2                	mov    %esi,%edx
  810fa5:	f7 f3                	div    %ebx
  810fa7:	89 fa                	mov    %edi,%edx
  810fa9:	83 c4 1c             	add    $0x1c,%esp
  810fac:	5b                   	pop    %ebx
  810fad:	5e                   	pop    %esi
  810fae:	5f                   	pop    %edi
  810faf:	5d                   	pop    %ebp
  810fb0:	c3                   	ret    
  810fb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810fb8:	89 d9                	mov    %ebx,%ecx
  810fba:	85 db                	test   %ebx,%ebx
  810fbc:	75 0b                	jne    810fc9 <__udivdi3+0x49>
  810fbe:	b8 01 00 00 00       	mov    $0x1,%eax
  810fc3:	31 d2                	xor    %edx,%edx
  810fc5:	f7 f3                	div    %ebx
  810fc7:	89 c1                	mov    %eax,%ecx
  810fc9:	31 d2                	xor    %edx,%edx
  810fcb:	89 f0                	mov    %esi,%eax
  810fcd:	f7 f1                	div    %ecx
  810fcf:	89 c6                	mov    %eax,%esi
  810fd1:	89 e8                	mov    %ebp,%eax
  810fd3:	89 f7                	mov    %esi,%edi
  810fd5:	f7 f1                	div    %ecx
  810fd7:	89 fa                	mov    %edi,%edx
  810fd9:	83 c4 1c             	add    $0x1c,%esp
  810fdc:	5b                   	pop    %ebx
  810fdd:	5e                   	pop    %esi
  810fde:	5f                   	pop    %edi
  810fdf:	5d                   	pop    %ebp
  810fe0:	c3                   	ret    
  810fe1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  810fe8:	39 f2                	cmp    %esi,%edx
  810fea:	77 1c                	ja     811008 <__udivdi3+0x88>
  810fec:	0f bd fa             	bsr    %edx,%edi
  810fef:	83 f7 1f             	xor    $0x1f,%edi
  810ff2:	75 2c                	jne    811020 <__udivdi3+0xa0>
  810ff4:	39 f2                	cmp    %esi,%edx
  810ff6:	72 06                	jb     810ffe <__udivdi3+0x7e>
  810ff8:	31 c0                	xor    %eax,%eax
  810ffa:	39 eb                	cmp    %ebp,%ebx
  810ffc:	77 a9                	ja     810fa7 <__udivdi3+0x27>
  810ffe:	b8 01 00 00 00       	mov    $0x1,%eax
  811003:	eb a2                	jmp    810fa7 <__udivdi3+0x27>
  811005:	8d 76 00             	lea    0x0(%esi),%esi
  811008:	31 ff                	xor    %edi,%edi
  81100a:	31 c0                	xor    %eax,%eax
  81100c:	89 fa                	mov    %edi,%edx
  81100e:	83 c4 1c             	add    $0x1c,%esp
  811011:	5b                   	pop    %ebx
  811012:	5e                   	pop    %esi
  811013:	5f                   	pop    %edi
  811014:	5d                   	pop    %ebp
  811015:	c3                   	ret    
  811016:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81101d:	8d 76 00             	lea    0x0(%esi),%esi
  811020:	89 f9                	mov    %edi,%ecx
  811022:	b8 20 00 00 00       	mov    $0x20,%eax
  811027:	29 f8                	sub    %edi,%eax
  811029:	d3 e2                	shl    %cl,%edx
  81102b:	89 54 24 08          	mov    %edx,0x8(%esp)
  81102f:	89 c1                	mov    %eax,%ecx
  811031:	89 da                	mov    %ebx,%edx
  811033:	d3 ea                	shr    %cl,%edx
  811035:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811039:	09 d1                	or     %edx,%ecx
  81103b:	89 f2                	mov    %esi,%edx
  81103d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811041:	89 f9                	mov    %edi,%ecx
  811043:	d3 e3                	shl    %cl,%ebx
  811045:	89 c1                	mov    %eax,%ecx
  811047:	d3 ea                	shr    %cl,%edx
  811049:	89 f9                	mov    %edi,%ecx
  81104b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81104f:	89 eb                	mov    %ebp,%ebx
  811051:	d3 e6                	shl    %cl,%esi
  811053:	89 c1                	mov    %eax,%ecx
  811055:	d3 eb                	shr    %cl,%ebx
  811057:	09 de                	or     %ebx,%esi
  811059:	89 f0                	mov    %esi,%eax
  81105b:	f7 74 24 08          	divl   0x8(%esp)
  81105f:	89 d6                	mov    %edx,%esi
  811061:	89 c3                	mov    %eax,%ebx
  811063:	f7 64 24 0c          	mull   0xc(%esp)
  811067:	39 d6                	cmp    %edx,%esi
  811069:	72 15                	jb     811080 <__udivdi3+0x100>
  81106b:	89 f9                	mov    %edi,%ecx
  81106d:	d3 e5                	shl    %cl,%ebp
  81106f:	39 c5                	cmp    %eax,%ebp
  811071:	73 04                	jae    811077 <__udivdi3+0xf7>
  811073:	39 d6                	cmp    %edx,%esi
  811075:	74 09                	je     811080 <__udivdi3+0x100>
  811077:	89 d8                	mov    %ebx,%eax
  811079:	31 ff                	xor    %edi,%edi
  81107b:	e9 27 ff ff ff       	jmp    810fa7 <__udivdi3+0x27>
  811080:	8d 43 ff             	lea    -0x1(%ebx),%eax
  811083:	31 ff                	xor    %edi,%edi
  811085:	e9 1d ff ff ff       	jmp    810fa7 <__udivdi3+0x27>
  81108a:	66 90                	xchg   %ax,%ax
  81108c:	66 90                	xchg   %ax,%ax
  81108e:	66 90                	xchg   %ax,%ax

00811090 <__umoddi3>:
  811090:	55                   	push   %ebp
  811091:	57                   	push   %edi
  811092:	56                   	push   %esi
  811093:	53                   	push   %ebx
  811094:	83 ec 1c             	sub    $0x1c,%esp
  811097:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  81109b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  81109f:	8b 74 24 30          	mov    0x30(%esp),%esi
  8110a3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8110a7:	89 da                	mov    %ebx,%edx
  8110a9:	85 c0                	test   %eax,%eax
  8110ab:	75 43                	jne    8110f0 <__umoddi3+0x60>
  8110ad:	39 df                	cmp    %ebx,%edi
  8110af:	76 17                	jbe    8110c8 <__umoddi3+0x38>
  8110b1:	89 f0                	mov    %esi,%eax
  8110b3:	f7 f7                	div    %edi
  8110b5:	89 d0                	mov    %edx,%eax
  8110b7:	31 d2                	xor    %edx,%edx
  8110b9:	83 c4 1c             	add    $0x1c,%esp
  8110bc:	5b                   	pop    %ebx
  8110bd:	5e                   	pop    %esi
  8110be:	5f                   	pop    %edi
  8110bf:	5d                   	pop    %ebp
  8110c0:	c3                   	ret    
  8110c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110c8:	89 fd                	mov    %edi,%ebp
  8110ca:	85 ff                	test   %edi,%edi
  8110cc:	75 0b                	jne    8110d9 <__umoddi3+0x49>
  8110ce:	b8 01 00 00 00       	mov    $0x1,%eax
  8110d3:	31 d2                	xor    %edx,%edx
  8110d5:	f7 f7                	div    %edi
  8110d7:	89 c5                	mov    %eax,%ebp
  8110d9:	89 d8                	mov    %ebx,%eax
  8110db:	31 d2                	xor    %edx,%edx
  8110dd:	f7 f5                	div    %ebp
  8110df:	89 f0                	mov    %esi,%eax
  8110e1:	f7 f5                	div    %ebp
  8110e3:	89 d0                	mov    %edx,%eax
  8110e5:	eb d0                	jmp    8110b7 <__umoddi3+0x27>
  8110e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110ee:	66 90                	xchg   %ax,%ax
  8110f0:	89 f1                	mov    %esi,%ecx
  8110f2:	39 d8                	cmp    %ebx,%eax
  8110f4:	76 0a                	jbe    811100 <__umoddi3+0x70>
  8110f6:	89 f0                	mov    %esi,%eax
  8110f8:	83 c4 1c             	add    $0x1c,%esp
  8110fb:	5b                   	pop    %ebx
  8110fc:	5e                   	pop    %esi
  8110fd:	5f                   	pop    %edi
  8110fe:	5d                   	pop    %ebp
  8110ff:	c3                   	ret    
  811100:	0f bd e8             	bsr    %eax,%ebp
  811103:	83 f5 1f             	xor    $0x1f,%ebp
  811106:	75 20                	jne    811128 <__umoddi3+0x98>
  811108:	39 d8                	cmp    %ebx,%eax
  81110a:	0f 82 b0 00 00 00    	jb     8111c0 <__umoddi3+0x130>
  811110:	39 f7                	cmp    %esi,%edi
  811112:	0f 86 a8 00 00 00    	jbe    8111c0 <__umoddi3+0x130>
  811118:	89 c8                	mov    %ecx,%eax
  81111a:	83 c4 1c             	add    $0x1c,%esp
  81111d:	5b                   	pop    %ebx
  81111e:	5e                   	pop    %esi
  81111f:	5f                   	pop    %edi
  811120:	5d                   	pop    %ebp
  811121:	c3                   	ret    
  811122:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811128:	89 e9                	mov    %ebp,%ecx
  81112a:	ba 20 00 00 00       	mov    $0x20,%edx
  81112f:	29 ea                	sub    %ebp,%edx
  811131:	d3 e0                	shl    %cl,%eax
  811133:	89 44 24 08          	mov    %eax,0x8(%esp)
  811137:	89 d1                	mov    %edx,%ecx
  811139:	89 f8                	mov    %edi,%eax
  81113b:	d3 e8                	shr    %cl,%eax
  81113d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811141:	89 54 24 04          	mov    %edx,0x4(%esp)
  811145:	8b 54 24 04          	mov    0x4(%esp),%edx
  811149:	09 c1                	or     %eax,%ecx
  81114b:	89 d8                	mov    %ebx,%eax
  81114d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811151:	89 e9                	mov    %ebp,%ecx
  811153:	d3 e7                	shl    %cl,%edi
  811155:	89 d1                	mov    %edx,%ecx
  811157:	d3 e8                	shr    %cl,%eax
  811159:	89 e9                	mov    %ebp,%ecx
  81115b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81115f:	d3 e3                	shl    %cl,%ebx
  811161:	89 c7                	mov    %eax,%edi
  811163:	89 d1                	mov    %edx,%ecx
  811165:	89 f0                	mov    %esi,%eax
  811167:	d3 e8                	shr    %cl,%eax
  811169:	89 e9                	mov    %ebp,%ecx
  81116b:	89 fa                	mov    %edi,%edx
  81116d:	d3 e6                	shl    %cl,%esi
  81116f:	09 d8                	or     %ebx,%eax
  811171:	f7 74 24 08          	divl   0x8(%esp)
  811175:	89 d1                	mov    %edx,%ecx
  811177:	89 f3                	mov    %esi,%ebx
  811179:	f7 64 24 0c          	mull   0xc(%esp)
  81117d:	89 c6                	mov    %eax,%esi
  81117f:	89 d7                	mov    %edx,%edi
  811181:	39 d1                	cmp    %edx,%ecx
  811183:	72 06                	jb     81118b <__umoddi3+0xfb>
  811185:	75 10                	jne    811197 <__umoddi3+0x107>
  811187:	39 c3                	cmp    %eax,%ebx
  811189:	73 0c                	jae    811197 <__umoddi3+0x107>
  81118b:	2b 44 24 0c          	sub    0xc(%esp),%eax
  81118f:	1b 54 24 08          	sbb    0x8(%esp),%edx
  811193:	89 d7                	mov    %edx,%edi
  811195:	89 c6                	mov    %eax,%esi
  811197:	89 ca                	mov    %ecx,%edx
  811199:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  81119e:	29 f3                	sub    %esi,%ebx
  8111a0:	19 fa                	sbb    %edi,%edx
  8111a2:	89 d0                	mov    %edx,%eax
  8111a4:	d3 e0                	shl    %cl,%eax
  8111a6:	89 e9                	mov    %ebp,%ecx
  8111a8:	d3 eb                	shr    %cl,%ebx
  8111aa:	d3 ea                	shr    %cl,%edx
  8111ac:	09 d8                	or     %ebx,%eax
  8111ae:	83 c4 1c             	add    $0x1c,%esp
  8111b1:	5b                   	pop    %ebx
  8111b2:	5e                   	pop    %esi
  8111b3:	5f                   	pop    %edi
  8111b4:	5d                   	pop    %ebp
  8111b5:	c3                   	ret    
  8111b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111bd:	8d 76 00             	lea    0x0(%esi),%esi
  8111c0:	89 da                	mov    %ebx,%edx
  8111c2:	29 fe                	sub    %edi,%esi
  8111c4:	19 c2                	sbb    %eax,%edx
  8111c6:	89 f1                	mov    %esi,%ecx
  8111c8:	89 c8                	mov    %ecx,%eax
  8111ca:	e9 4b ff ff ff       	jmp    81111a <__umoddi3+0x8a>
