
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 cb e6 00 00       	call   80e6fc <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 2b a7 00 00       	call   80a773 <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 70 a7 00 00       	call   80a7dd <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 97 aa 00 00       	call   80ab19 <e2s>
  800082:	50                   	push   %eax
  800083:	68 20 14 81 00       	push   $0x811420
  800088:	6a 7a                	push   $0x7a
  80008a:	68 55 15 81 00       	push   $0x811555
  80008f:	e8 75 e7 00 00       	call   80e809 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 e1 f5 00 00       	call   80f682 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 a2 a6 00 00       	call   80a74a <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 9b a6 00 00       	call   80a74b <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 ca a8 00 00       	call   80a989 <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 24 16 81 00 	jmp    *0x811624(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 1d 0f 00 00       	call   80101a <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 de f0 00 00       	call   80f1ec <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 00 60 81 00 00 	movb   $0x0,0x816000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 94 f3 00 00       	call   80f4d5 <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 52 08 01 00       	call   81099b <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 76 14             	pushl  0x14(%esi)
  80015a:	8d 46 04             	lea    0x4(%esi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 36                	pushl  (%esi)
  800160:	e8 67 10 00 00       	call   8011cc <lwip_bind>
  800165:	89 c7                	mov    %eax,%edi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 76 04             	pushl  0x4(%esi)
  800172:	ff 36                	pushl  (%esi)
  800174:	e8 ae 1b 00 00       	call   801d27 <lwip_shutdown>
  800179:	89 c7                	mov    %eax,%edi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 36                	pushl  (%esi)
  800185:	e8 f8 10 00 00       	call   801282 <lwip_close>
  80018a:	89 c7                	mov    %eax,%edi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 76 14             	pushl  0x14(%esi)
  800197:	8d 46 04             	lea    0x4(%esi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 36                	pushl  (%esi)
  80019d:	e8 69 11 00 00       	call   80130b <lwip_connect>
  8001a2:	89 c7                	mov    %eax,%edi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 76 04             	pushl  0x4(%esi)
  8001b2:	ff 36                	pushl  (%esi)
  8001b4:	e8 08 12 00 00       	call   8013c1 <lwip_listen>
  8001b9:	89 c7                	mov    %eax,%edi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 76 08             	pushl  0x8(%esi)
  8001c6:	ff 76 04             	pushl  0x4(%esi)
  8001c9:	56                   	push   %esi
  8001ca:	ff 36                	pushl  (%esi)
  8001cc:	e8 db 14 00 00       	call   8016ac <lwip_recv>
  8001d1:	89 c7                	mov    %eax,%edi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 76 08             	pushl  0x8(%esi)
  8001de:	ff 76 04             	pushl  0x4(%esi)
  8001e1:	8d 46 0c             	lea    0xc(%esi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 36                	pushl  (%esi)
  8001e7:	e8 52 16 00 00       	call   80183e <lwip_send>
  8001ec:	89 c7                	mov    %eax,%edi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 76 08             	pushl  0x8(%esi)
  8001fc:	ff 76 04             	pushl  0x4(%esi)
  8001ff:	ff 36                	pushl  (%esi)
  800201:	e8 c9 16 00 00       	call   8018cf <lwip_socket>
  800206:	89 c7                	mov    %eax,%edi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	56                   	push   %esi
  800214:	68 00 c2 b3 00       	push   $0xb3c200
  800219:	e8 ea a9 00 00       	call   80ac08 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	bf 00 00 00 00       	mov    $0x0,%edi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	56                   	push   %esi
  80022f:	ff 73 04             	pushl  0x4(%ebx)
  800232:	68 40 14 81 00       	push   $0x811440
  800237:	e8 c3 e6 00 00       	call   80e8ff <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	pushl  (%ebx)
  80024b:	68 60 15 81 00       	push   $0x811560
  800250:	6a 64                	push   $0x64
  800252:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800255:	56                   	push   %esi
  800256:	e8 b0 ed 00 00       	call   80f00b <snprintf>
		perror(buf);
  80025b:	89 34 24             	mov    %esi,(%esp)
  80025e:	e8 92 a8 00 00       	call   80aaf5 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	57                   	push   %edi
  800270:	ff 73 04             	pushl  0x4(%ebx)
  800273:	e8 fd f9 00 00       	call   80fc75 <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 ba a4 00 00       	call   80a74a <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 12 23 00 00       	call   8025ba <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 9e a4 00 00       	call   80a74b <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 cf a6 00 00       	call   80a989 <thread_wait>
	lwip_core_lock();
  8002ba:	e8 8b a4 00 00       	call   80a74a <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 0b 67 80 00       	push   $0x80670b
  8002d6:	68 f3 ac 80 00       	push   $0x80acf3
  8002db:	68 14 60 81 00       	push   $0x816014
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 c2 b3 00       	push   $0xb3c200
  8002f1:	e8 1a 45 00 00       	call   804810 <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 c2 b3 00       	push   $0xb3c200
  800309:	e8 b4 45 00 00       	call   8048c2 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 c2 b3 00 	movl   $0xb3c200,(%esp)
  800315:	e8 b5 45 00 00       	call   8048cf <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 6f 15 81 00       	mov    $0x81156f,%ecx
  800326:	ba cd 96 80 00       	mov    $0x8096cd,%edx
  80032b:	b8 34 60 81 00       	mov    $0x816034,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 79 15 81 00       	mov    $0x811579,%ecx
  800341:	ba 97 58 80 00       	mov    $0x805897,%edx
  800346:	b8 28 60 81 00       	mov    $0x816028,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 85 15 81 00       	mov    $0x811585,%ecx
  80035c:	ba 50 5e 80 00       	mov    $0x805e50,%edx
  800361:	b8 1c 60 81 00       	mov    $0x81601c,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 bb 74 00 00       	call   80782e <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a c2 b3 00 	movzbl 0xb3c22a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 c2 b3 00 	movzbl 0xb3c229,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 c2 b3 00 	movzbl 0xb3c228,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 c2 b3 00 	movzbl 0xb3c227,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 c2 b3 00 	movzbl 0xb3c226,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 c2 b3 00 	movzbl 0xb3c225,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 84 14 81 00       	push   $0x811484
  8003a9:	e8 51 e5 00 00       	call   80e8ff <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 95 a3 00 00       	call   80a74b <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 91 15 81 00       	push   $0x811591
  8003be:	e8 3c e5 00 00       	call   80e8ff <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 64 14 81 00       	push   $0x811464
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 55 15 81 00       	push   $0x811555
  8003dc:	e8 28 e4 00 00       	call   80e809 <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 9d 00 00 00       	jmp    80048f <serve+0xae>
		perm = 0;
  8003f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f9:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003fe:	80 b8 00 60 81 00 00 	cmpb   $0x0,0x816000(%eax)
  800405:	74 1c                	je     800423 <serve+0x42>
	for (i = 0; i < QUEUE_SIZE; i++)
  800407:	83 c0 01             	add    $0x1,%eax
  80040a:	83 f8 14             	cmp    $0x14,%eax
  80040d:	75 ef                	jne    8003fe <serve+0x1d>
		panic("NS: buffer overflow");
  80040f:	83 ec 04             	sub    $0x4,%esp
  800412:	68 aa 15 81 00       	push   $0x8115aa
  800417:	6a 3f                	push   $0x3f
  800419:	68 55 15 81 00       	push   $0x811555
  80041e:	e8 e6 e3 00 00       	call   80e809 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800423:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  800429:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042c:	c6 80 00 60 81 00 01 	movb   $0x1,0x816000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800433:	83 ec 04             	sub    $0x4,%esp
  800436:	57                   	push   %edi
  800437:	53                   	push   %ebx
  800438:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043b:	50                   	push   %eax
  80043c:	e8 cb f7 00 00       	call   80fc0c <ipc_recv>
  800441:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800443:	83 c4 10             	add    $0x10,%esp
  800446:	83 f8 0c             	cmp    $0xc,%eax
  800449:	74 69                	je     8004b4 <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80044b:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80044f:	0f 84 ba 00 00 00    	je     80050f <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800455:	83 ec 0c             	sub    $0xc,%esp
  800458:	6a 0c                	push   $0xc
  80045a:	e8 e8 05 01 00       	call   810a47 <malloc>
		if (!args)
  80045f:	83 c4 10             	add    $0x10,%esp
  800462:	85 c0                	test   %eax,%eax
  800464:	0f 84 bd 00 00 00    	je     800527 <serve+0x146>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80046a:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  80046c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80046f:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800472:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  800475:	50                   	push   %eax
  800476:	68 c4 00 80 00       	push   $0x8000c4
  80047b:	68 be 15 81 00       	push   $0x8115be
  800480:	6a 00                	push   $0x0
  800482:	e8 56 a3 00 00       	call   80a7dd <thread_create>
		thread_yield(); // let the thread created run
  800487:	e8 7a a4 00 00       	call   80a906 <thread_yield>
  80048c:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  800494:	e8 fb a2 00 00       	call   80a794 <thread_wakeups_pending>
  800499:	85 c0                	test   %eax,%eax
  80049b:	0f 84 51 ff ff ff    	je     8003f2 <serve+0x11>
  8004a1:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a4:	0f 8f 48 ff ff ff    	jg     8003f2 <serve+0x11>
			thread_yield();
  8004aa:	e8 57 a4 00 00       	call   80a906 <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004af:	83 c3 01             	add    $0x1,%ebx
  8004b2:	eb e0                	jmp    800494 <serve+0xb3>
			process_timer(whom);
  8004b4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b7:	3b 35 18 60 81 00    	cmp    0x816018,%esi
  8004bd:	74 23                	je     8004e2 <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004bf:	83 ec 08             	sub    $0x8,%esp
  8004c2:	56                   	push   %esi
  8004c3:	68 c0 14 81 00       	push   $0x8114c0
  8004c8:	e8 32 e4 00 00       	call   80e8ff <cprintf>
  8004cd:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004d0:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d6:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d9:	c6 83 00 60 81 00 00 	movb   $0x0,0x816000(%ebx)
  8004e0:	eb ad                	jmp    80048f <serve+0xae>
	start = sys_time_msec();
  8004e2:	e8 9b f1 00 00       	call   80f682 <sys_time_msec>
  8004e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ea:	e8 17 a4 00 00       	call   80a906 <thread_yield>
	now = sys_time_msec();
  8004ef:	e8 8e f1 00 00       	call   80f682 <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004f4:	6a 00                	push   $0x0
  8004f6:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004fb:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800501:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800503:	52                   	push   %edx
  800504:	56                   	push   %esi
  800505:	e8 6b f7 00 00       	call   80fc75 <ipc_send>
  80050a:	83 c4 10             	add    $0x10,%esp
  80050d:	eb c1                	jmp    8004d0 <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050f:	83 ec 08             	sub    $0x8,%esp
  800512:	ff 75 e4             	pushl  -0x1c(%ebp)
  800515:	68 fc 14 81 00       	push   $0x8114fc
  80051a:	e8 e0 e3 00 00       	call   80e8ff <cprintf>
			continue; // just leave it hanging...
  80051f:	83 c4 10             	add    $0x10,%esp
  800522:	e9 68 ff ff ff       	jmp    80048f <serve+0xae>
			panic("could not allocate thread args structure");
  800527:	83 ec 04             	sub    $0x4,%esp
  80052a:	68 2c 15 81 00       	push   $0x81152c
  80052f:	68 27 01 00 00       	push   $0x127
  800534:	68 55 15 81 00       	push   $0x811555
  800539:	e8 cb e2 00 00       	call   80e809 <_panic>

0080053e <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80053e:	55                   	push   %ebp
  80053f:	89 e5                	mov    %esp,%ebp
  800541:	56                   	push   %esi
  800542:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800543:	83 ec 0c             	sub    $0xc,%esp
  800546:	68 cb 15 81 00       	push   $0x8115cb
  80054b:	e8 8d 75 00 00       	call   807add <inet_addr>
  800550:	89 c6                	mov    %eax,%esi
  800552:	c7 04 24 d4 15 81 00 	movl   $0x8115d4,(%esp)
  800559:	e8 7f 75 00 00       	call   807add <inet_addr>
  80055e:	89 c3                	mov    %eax,%ebx
  800560:	c7 04 24 e2 15 81 00 	movl   $0x8115e2,(%esp)
  800567:	e8 71 75 00 00       	call   807add <inet_addr>
  80056c:	83 c4 0c             	add    $0xc,%esp
  80056f:	56                   	push   %esi
  800570:	53                   	push   %ebx
  800571:	50                   	push   %eax
  800572:	e8 09 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800577:	e8 65 fe ff ff       	call   8003e1 <serve>

0080057c <umain>:
}

void
umain(int argc, char **argv)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	53                   	push   %ebx
  800580:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in umain serv.c\n", thisenv->env_id);
  800583:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800588:	8b 40 48             	mov    0x48(%eax),%eax
  80058b:	50                   	push   %eax
  80058c:	68 ec 15 81 00       	push   $0x8115ec
  800591:	e8 69 e3 00 00       	call   80e8ff <cprintf>
	envid_t ns_envid = sys_getenvid();
  800596:	e8 77 ee 00 00       	call   80f412 <sys_getenvid>
  80059b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80059d:	c7 05 e8 52 81 00 27 	movl   $0x814127,0x8152e8
  8005a4:	41 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005a7:	e8 ce f3 00 00       	call   80f97a <fork>
  8005ac:	a3 18 60 81 00       	mov    %eax,0x816018
	if (timer_envid < 0)
  8005b1:	83 c4 10             	add    $0x10,%esp
  8005b4:	85 c0                	test   %eax,%eax
  8005b6:	78 43                	js     8005fb <umain+0x7f>
		panic("error forking");
	else if (timer_envid == 0) {
  8005b8:	74 58                	je     800612 <umain+0x96>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005ba:	e8 bb f3 00 00       	call   80f97a <fork>
	if (input_envid < 0)
  8005bf:	85 c0                	test   %eax,%eax
  8005c1:	78 65                	js     800628 <umain+0xac>
		panic("error forking");
	else if (input_envid == 0) {
  8005c3:	74 7a                	je     80063f <umain+0xc3>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005c5:	e8 b0 f3 00 00       	call   80f97a <fork>
  8005ca:	a3 14 60 81 00       	mov    %eax,0x816014
	if (output_envid < 0)
  8005cf:	85 c0                	test   %eax,%eax
  8005d1:	78 7a                	js     80064d <umain+0xd1>
		panic("error forking");
	else if (output_envid == 0) {
  8005d3:	0f 84 8b 00 00 00    	je     800664 <umain+0xe8>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005d9:	e8 6e a1 00 00       	call   80a74c <thread_init>
	thread_create(0, "main", tmain, 0);
  8005de:	6a 00                	push   $0x0
  8005e0:	68 3e 05 80 00       	push   $0x80053e
  8005e5:	68 1f 16 81 00       	push   $0x81161f
  8005ea:	6a 00                	push   $0x0
  8005ec:	e8 ec a1 00 00       	call   80a7dd <thread_create>
	thread_yield();
  8005f1:	e8 10 a3 00 00       	call   80a906 <thread_yield>
  8005f6:	83 c4 10             	add    $0x10,%esp
  8005f9:	eb 28                	jmp    800623 <umain+0xa7>
		panic("error forking");
  8005fb:	83 ec 04             	sub    $0x4,%esp
  8005fe:	68 01 16 81 00       	push   $0x811601
  800603:	68 45 01 00 00       	push   $0x145
  800608:	68 55 15 81 00       	push   $0x811555
  80060d:	e8 f7 e1 00 00       	call   80e809 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  800612:	83 ec 08             	sub    $0x8,%esp
  800615:	68 fa 00 00 00       	push   $0xfa
  80061a:	53                   	push   %ebx
  80061b:	e8 67 00 00 00       	call   800687 <timer>
		return;
  800620:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800623:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800626:	c9                   	leave  
  800627:	c3                   	ret    
		panic("error forking");
  800628:	83 ec 04             	sub    $0x4,%esp
  80062b:	68 01 16 81 00       	push   $0x811601
  800630:	68 4f 01 00 00       	push   $0x14f
  800635:	68 55 15 81 00       	push   $0x811555
  80063a:	e8 ca e1 00 00       	call   80e809 <_panic>
		input(ns_envid);
  80063f:	83 ec 0c             	sub    $0xc,%esp
  800642:	53                   	push   %ebx
  800643:	e8 d2 00 00 00       	call   80071a <input>
		return;
  800648:	83 c4 10             	add    $0x10,%esp
  80064b:	eb d6                	jmp    800623 <umain+0xa7>
		panic("error forking");
  80064d:	83 ec 04             	sub    $0x4,%esp
  800650:	68 01 16 81 00       	push   $0x811601
  800655:	68 59 01 00 00       	push   $0x159
  80065a:	68 55 15 81 00       	push   $0x811555
  80065f:	e8 a5 e1 00 00       	call   80e809 <_panic>
		cprintf("%d: after fork\n", thisenv->env_id);
  800664:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800669:	8b 40 48             	mov    0x48(%eax),%eax
  80066c:	83 ec 08             	sub    $0x8,%esp
  80066f:	50                   	push   %eax
  800670:	68 0f 16 81 00       	push   $0x81160f
  800675:	e8 85 e2 00 00       	call   80e8ff <cprintf>
		output(ns_envid);
  80067a:	89 1c 24             	mov    %ebx,(%esp)
  80067d:	e8 7a 01 00 00       	call   8007fc <output>
		return;
  800682:	83 c4 10             	add    $0x10,%esp
  800685:	eb 9c                	jmp    800623 <umain+0xa7>

00800687 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800687:	55                   	push   %ebp
  800688:	89 e5                	mov    %esp,%ebp
  80068a:	57                   	push   %edi
  80068b:	56                   	push   %esi
  80068c:	53                   	push   %ebx
  80068d:	83 ec 1c             	sub    $0x1c,%esp
  800690:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800693:	e8 ea ef 00 00       	call   80f682 <sys_time_msec>
  800698:	03 45 0c             	add    0xc(%ebp),%eax
  80069b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80069d:	c7 05 e8 52 81 00 50 	movl   $0x811650,0x8152e8
  8006a4:	16 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006a7:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006aa:	eb 33                	jmp    8006df <timer+0x58>
		if (r < 0)
  8006ac:	85 c0                	test   %eax,%eax
  8006ae:	78 45                	js     8006f5 <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006b0:	6a 00                	push   $0x0
  8006b2:	6a 00                	push   $0x0
  8006b4:	6a 0c                	push   $0xc
  8006b6:	56                   	push   %esi
  8006b7:	e8 b9 f5 00 00       	call   80fc75 <ipc_send>
  8006bc:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006bf:	83 ec 04             	sub    $0x4,%esp
  8006c2:	6a 00                	push   $0x0
  8006c4:	6a 00                	push   $0x0
  8006c6:	57                   	push   %edi
  8006c7:	e8 40 f5 00 00       	call   80fc0c <ipc_recv>
  8006cc:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006d1:	83 c4 10             	add    $0x10,%esp
  8006d4:	39 f0                	cmp    %esi,%eax
  8006d6:	75 2f                	jne    800707 <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006d8:	e8 a5 ef 00 00       	call   80f682 <sys_time_msec>
  8006dd:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006df:	e8 9e ef 00 00       	call   80f682 <sys_time_msec>
  8006e4:	89 c2                	mov    %eax,%edx
  8006e6:	85 c0                	test   %eax,%eax
  8006e8:	78 c2                	js     8006ac <timer+0x25>
  8006ea:	39 d8                	cmp    %ebx,%eax
  8006ec:	73 be                	jae    8006ac <timer+0x25>
			sys_yield();
  8006ee:	e8 3e ed 00 00       	call   80f431 <sys_yield>
  8006f3:	eb ea                	jmp    8006df <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006f5:	52                   	push   %edx
  8006f6:	68 59 16 81 00       	push   $0x811659
  8006fb:	6a 0f                	push   $0xf
  8006fd:	68 6b 16 81 00       	push   $0x81166b
  800702:	e8 02 e1 00 00       	call   80e809 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800707:	83 ec 08             	sub    $0x8,%esp
  80070a:	50                   	push   %eax
  80070b:	68 78 16 81 00       	push   $0x811678
  800710:	e8 ea e1 00 00       	call   80e8ff <cprintf>
				continue;
  800715:	83 c4 10             	add    $0x10,%esp
  800718:	eb a5                	jmp    8006bf <timer+0x38>

0080071a <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  80071a:	55                   	push   %ebp
  80071b:	89 e5                	mov    %esp,%ebp
  80071d:	57                   	push   %edi
  80071e:	56                   	push   %esi
  80071f:	53                   	push   %ebx
  800720:	81 ec 0c 08 00 00    	sub    $0x80c,%esp
  800726:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_input";
  800729:	c7 05 e8 52 81 00 b3 	movl   $0x8116b3,0x8152e8
  800730:	16 81 00 
	// another packet in to the same physical page.
	
	int r;
	char buf[2048];
	while(1){
		if((r = sys_net_recv(buf, 2048)) < 0) {
  800733:	8d b5 e8 f7 ff ff    	lea    -0x818(%ebp),%esi
  800739:	eb 46                	jmp    800781 <input+0x67>
       		sys_yield();
       		continue;
     	}
     	while (sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_W|PTE_U) < 0) ;
  80073b:	83 ec 04             	sub    $0x4,%esp
  80073e:	6a 07                	push   $0x7
  800740:	68 00 e0 b3 00       	push   $0xb3e000
  800745:	6a 00                	push   $0x0
  800747:	e8 04 ed 00 00       	call   80f450 <sys_page_alloc>
  80074c:	83 c4 10             	add    $0x10,%esp
  80074f:	85 c0                	test   %eax,%eax
  800751:	78 e8                	js     80073b <input+0x21>
     	nsipcbuf.pkt.jp_len = r; 
  800753:	89 3d 00 e0 b3 00    	mov    %edi,0xb3e000
     	memcpy(nsipcbuf.pkt.jp_data, buf, r);
  800759:	83 ec 04             	sub    $0x4,%esp
  80075c:	57                   	push   %edi
  80075d:	56                   	push   %esi
  80075e:	68 04 e0 b3 00       	push   $0xb3e004
  800763:	e8 e6 ea 00 00       	call   80f24e <memcpy>
     	while(sys_ipc_try_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_W|PTE_U) < 0) ;
  800768:	83 c4 10             	add    $0x10,%esp
  80076b:	6a 07                	push   $0x7
  80076d:	68 00 e0 b3 00       	push   $0xb3e000
  800772:	6a 0a                	push   $0xa
  800774:	53                   	push   %ebx
  800775:	e8 63 ee 00 00       	call   80f5dd <sys_ipc_try_send>
  80077a:	83 c4 10             	add    $0x10,%esp
  80077d:	85 c0                	test   %eax,%eax
  80077f:	78 ea                	js     80076b <input+0x51>
		if((r = sys_net_recv(buf, 2048)) < 0) {
  800781:	83 ec 08             	sub    $0x8,%esp
  800784:	68 00 08 00 00       	push   $0x800
  800789:	56                   	push   %esi
  80078a:	e8 33 ef 00 00       	call   80f6c2 <sys_net_recv>
  80078f:	89 c7                	mov    %eax,%edi
  800791:	83 c4 10             	add    $0x10,%esp
  800794:	85 c0                	test   %eax,%eax
  800796:	79 a3                	jns    80073b <input+0x21>
       		sys_yield();
  800798:	e8 94 ec 00 00       	call   80f431 <sys_yield>
       		continue;
  80079d:	eb e2                	jmp    800781 <input+0x67>

0080079f <sleep>:

extern union Nsipc nsipcbuf;

void
sleep(int sec)
{
  80079f:	55                   	push   %ebp
  8007a0:	89 e5                	mov    %esp,%ebp
  8007a2:	53                   	push   %ebx
  8007a3:	83 ec 04             	sub    $0x4,%esp
	unsigned now = sys_time_msec();
  8007a6:	e8 d7 ee 00 00       	call   80f682 <sys_time_msec>
	unsigned end = now + sec * 1000;
  8007ab:	69 5d 08 e8 03 00 00 	imul   $0x3e8,0x8(%ebp),%ebx
  8007b2:	01 c3                	add    %eax,%ebx

	if ((int)now < 0 && (int)now > -MAXERROR)
  8007b4:	85 c0                	test   %eax,%eax
  8007b6:	79 05                	jns    8007bd <sleep+0x1e>
  8007b8:	83 f8 ef             	cmp    $0xffffffef,%eax
  8007bb:	7d 14                	jge    8007d1 <sleep+0x32>
		panic("sys_time_msec: %e", (int)now);
	if (end < now)
  8007bd:	39 d8                	cmp    %ebx,%eax
  8007bf:	77 22                	ja     8007e3 <sleep+0x44>
		panic("sleep: wrap");

	while (sys_time_msec() < end)
  8007c1:	e8 bc ee 00 00       	call   80f682 <sys_time_msec>
  8007c6:	39 d8                	cmp    %ebx,%eax
  8007c8:	73 2d                	jae    8007f7 <sleep+0x58>
		sys_yield();
  8007ca:	e8 62 ec 00 00       	call   80f431 <sys_yield>
  8007cf:	eb f0                	jmp    8007c1 <sleep+0x22>
		panic("sys_time_msec: %e", (int)now);
  8007d1:	50                   	push   %eax
  8007d2:	68 59 16 81 00       	push   $0x811659
  8007d7:	6a 0c                	push   $0xc
  8007d9:	68 bc 16 81 00       	push   $0x8116bc
  8007de:	e8 26 e0 00 00       	call   80e809 <_panic>
		panic("sleep: wrap");
  8007e3:	83 ec 04             	sub    $0x4,%esp
  8007e6:	68 c9 16 81 00       	push   $0x8116c9
  8007eb:	6a 0e                	push   $0xe
  8007ed:	68 bc 16 81 00       	push   $0x8116bc
  8007f2:	e8 12 e0 00 00       	call   80e809 <_panic>
}
  8007f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8007fa:	c9                   	leave  
  8007fb:	c3                   	ret    

008007fc <output>:

void
output(envid_t ns_envid)
{
  8007fc:	55                   	push   %ebp
  8007fd:	89 e5                	mov    %esp,%ebp
  8007ff:	56                   	push   %esi
  800800:	53                   	push   %ebx
  800801:	83 ec 10             	sub    $0x10,%esp
	// 	}
	// }
	// cprintf("return in output\n");


binaryname = "ns_output";
  800804:	c7 05 e8 52 81 00 d5 	movl   $0x8116d5,0x8152e8
  80080b:	16 81 00 
	//	do the above things in a loop
	while(1){
		envid_t env;
		int r;
		cprintf("%d: %s before ipc_recv\n", thisenv->env_id, __FUNCTION__);
		if((r = ipc_recv(&env, &nsipcbuf, NULL)) < 0){
  80080e:	8d 75 f4             	lea    -0xc(%ebp),%esi
  800811:	eb 1a                	jmp    80082d <output+0x31>
			panic("ipc_recv:%d", r);
  800813:	50                   	push   %eax
  800814:	68 f7 16 81 00       	push   $0x8116f7
  800819:	6a 39                	push   $0x39
  80081b:	68 bc 16 81 00       	push   $0x8116bc
  800820:	e8 e4 df 00 00       	call   80e809 <_panic>
			cprintf("again!\n");
			sleep(2);
			// sys_yield();
			r = sys_net_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
		}
		if(r < 0){
  800825:	85 db                	test   %ebx,%ebx
  800827:	0f 88 d7 00 00 00    	js     800904 <output+0x108>
		cprintf("%d: %s before ipc_recv\n", thisenv->env_id, __FUNCTION__);
  80082d:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800832:	8b 40 48             	mov    0x48(%eax),%eax
  800835:	83 ec 04             	sub    $0x4,%esp
  800838:	68 6c 17 81 00       	push   $0x81176c
  80083d:	50                   	push   %eax
  80083e:	68 df 16 81 00       	push   $0x8116df
  800843:	e8 b7 e0 00 00       	call   80e8ff <cprintf>
		if((r = ipc_recv(&env, &nsipcbuf, NULL)) < 0){
  800848:	83 c4 0c             	add    $0xc,%esp
  80084b:	6a 00                	push   $0x0
  80084d:	68 00 e0 b3 00       	push   $0xb3e000
  800852:	56                   	push   %esi
  800853:	e8 b4 f3 00 00       	call   80fc0c <ipc_recv>
  800858:	83 c4 10             	add    $0x10,%esp
  80085b:	85 c0                	test   %eax,%eax
  80085d:	78 b4                	js     800813 <output+0x17>
		cprintf("%d: %s after ipc_recv\n", thisenv->env_id, __FUNCTION__);
  80085f:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  800864:	8b 40 48             	mov    0x48(%eax),%eax
  800867:	83 ec 04             	sub    $0x4,%esp
  80086a:	68 6c 17 81 00       	push   $0x81176c
  80086f:	50                   	push   %eax
  800870:	68 03 17 81 00       	push   $0x811703
  800875:	e8 85 e0 00 00       	call   80e8ff <cprintf>
		cprintf("%d: %s before sys_net_send\n", thisenv->env_id, __FUNCTION__);
  80087a:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80087f:	8b 40 48             	mov    0x48(%eax),%eax
  800882:	83 c4 0c             	add    $0xc,%esp
  800885:	68 6c 17 81 00       	push   $0x81176c
  80088a:	50                   	push   %eax
  80088b:	68 1a 17 81 00       	push   $0x81171a
  800890:	e8 6a e0 00 00       	call   80e8ff <cprintf>
		r = sys_net_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
  800895:	83 c4 08             	add    $0x8,%esp
  800898:	ff 35 00 e0 b3 00    	pushl  0xb3e000
  80089e:	68 04 e0 b3 00       	push   $0xb3e004
  8008a3:	e8 f9 ed 00 00       	call   80f6a1 <sys_net_send>
  8008a8:	89 c3                	mov    %eax,%ebx
		cprintf("%d: %s after sys_net_send\n", thisenv->env_id, __FUNCTION__);
  8008aa:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  8008af:	8b 40 48             	mov    0x48(%eax),%eax
  8008b2:	83 c4 0c             	add    $0xc,%esp
  8008b5:	68 6c 17 81 00       	push   $0x81176c
  8008ba:	50                   	push   %eax
  8008bb:	68 36 17 81 00       	push   $0x811736
  8008c0:	e8 3a e0 00 00       	call   80e8ff <cprintf>
		while(r == -E_AGAIN){
  8008c5:	83 c4 10             	add    $0x10,%esp
  8008c8:	83 fb f0             	cmp    $0xfffffff0,%ebx
  8008cb:	0f 85 54 ff ff ff    	jne    800825 <output+0x29>
			cprintf("again!\n");
  8008d1:	83 ec 0c             	sub    $0xc,%esp
  8008d4:	68 51 17 81 00       	push   $0x811751
  8008d9:	e8 21 e0 00 00       	call   80e8ff <cprintf>
			sleep(2);
  8008de:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8008e5:	e8 b5 fe ff ff       	call   80079f <sleep>
			r = sys_net_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
  8008ea:	83 c4 08             	add    $0x8,%esp
  8008ed:	ff 35 00 e0 b3 00    	pushl  0xb3e000
  8008f3:	68 04 e0 b3 00       	push   $0xb3e004
  8008f8:	e8 a4 ed 00 00       	call   80f6a1 <sys_net_send>
  8008fd:	89 c3                	mov    %eax,%ebx
  8008ff:	83 c4 10             	add    $0x10,%esp
  800902:	eb c4                	jmp    8008c8 <output+0xcc>
			panic("sys_net_send:%d", r);
  800904:	53                   	push   %ebx
  800905:	68 59 17 81 00       	push   $0x811759
  80090a:	6a 46                	push   $0x46
  80090c:	68 bc 16 81 00       	push   $0x8116bc
  800911:	e8 f3 de 00 00       	call   80e809 <_panic>

00800916 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800916:	89 c2                	mov    %eax,%edx
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800918:	83 f8 1f             	cmp    $0x1f,%eax
  80091b:	77 19                	ja     800936 <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  80091d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  800920:	8d 04 85 60 60 81 00 	lea    0x816060(,%eax,4),%eax

  if (!sock->conn) {
  800927:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80092a:	8b 14 95 60 60 81 00 	mov    0x816060(,%edx,4),%edx
  800931:	85 d2                	test   %edx,%edx
  800933:	74 11                	je     800946 <get_socket+0x30>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  800935:	c3                   	ret    
    set_errno(EBADF);
  800936:	c7 05 e0 c1 b3 00 09 	movl   $0x9,0xb3c1e0
  80093d:	00 00 00 
    return NULL;
  800940:	b8 00 00 00 00       	mov    $0x0,%eax
  800945:	c3                   	ret    
    set_errno(EBADF);
  800946:	c7 05 e0 c1 b3 00 09 	movl   $0x9,0xb3c1e0
  80094d:	00 00 00 
    return NULL;
  800950:	89 d0                	mov    %edx,%eax
  800952:	eb e1                	jmp    800935 <get_socket+0x1f>

00800954 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  800954:	55                   	push   %ebp
  800955:	89 e5                	mov    %esp,%ebp
  800957:	57                   	push   %edi
  800958:	56                   	push   %esi
  800959:	53                   	push   %ebx
  80095a:	83 ec 40             	sub    $0x40,%esp
  80095d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800960:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800963:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  800966:	6a 04                	push   $0x4
  800968:	6a 00                	push   $0x0
  80096a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80096d:	50                   	push   %eax
  80096e:	e8 31 e8 00 00       	call   80f1a4 <memset>
  FD_ZERO(&lwriteset);
  800973:	83 c4 0c             	add    $0xc,%esp
  800976:	6a 04                	push   $0x4
  800978:	6a 00                	push   $0x0
  80097a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80097d:	50                   	push   %eax
  80097e:	e8 21 e8 00 00       	call   80f1a4 <memset>
  FD_ZERO(&lexceptset);
  800983:	83 c4 0c             	add    $0xc,%esp
  800986:	6a 04                	push   $0x4
  800988:	6a 00                	push   $0x0
  80098a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80098d:	50                   	push   %eax
  80098e:	e8 11 e8 00 00       	call   80f1a4 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800993:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  800996:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  80099d:	bf 00 00 00 00       	mov    $0x0,%edi
  8009a2:	eb 33                	jmp    8009d7 <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8009a4:	89 f8                	mov    %edi,%eax
  8009a6:	e8 6b ff ff ff       	call   800916 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8009ab:	85 c0                	test   %eax,%eax
  8009ad:	74 4c                	je     8009fb <lwip_selscan+0xa7>
  8009af:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8009b3:	74 16                	je     8009cb <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  8009b5:	b8 01 00 00 00       	mov    $0x1,%eax
  8009ba:	89 f1                	mov    %esi,%ecx
  8009bc:	d3 e0                	shl    %cl,%eax
  8009be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8009c1:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  8009c5:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8009c9:	eb 30                	jmp    8009fb <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8009cb:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8009d0:	74 29                	je     8009fb <lwip_selscan+0xa7>
  8009d2:	eb e1                	jmp    8009b5 <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  8009d4:	83 c7 01             	add    $0x1,%edi
  8009d7:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  8009da:	7d 53                	jge    800a2f <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  8009dc:	8d 5f 07             	lea    0x7(%edi),%ebx
  8009df:	85 ff                	test   %edi,%edi
  8009e1:	0f 49 df             	cmovns %edi,%ebx
  8009e4:	c1 fb 03             	sar    $0x3,%ebx
  8009e7:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  8009ea:	89 fe                	mov    %edi,%esi
  8009ec:	83 e6 07             	and    $0x7,%esi
  8009ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8009f2:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  8009f6:	0f a3 f0             	bt     %esi,%eax
  8009f9:	72 a9                	jb     8009a4 <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  8009fb:	8b 45 c8             	mov    -0x38(%ebp),%eax
  8009fe:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a02:	0f a3 f0             	bt     %esi,%eax
  800a05:	73 cd                	jae    8009d4 <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800a07:	89 f8                	mov    %edi,%eax
  800a09:	e8 08 ff ff ff       	call   800916 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800a0e:	85 c0                	test   %eax,%eax
  800a10:	74 c2                	je     8009d4 <lwip_selscan+0x80>
  800a12:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a17:	74 bb                	je     8009d4 <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  800a19:	b8 01 00 00 00       	mov    $0x1,%eax
  800a1e:	89 f1                	mov    %esi,%ecx
  800a20:	d3 e0                	shl    %cl,%eax
  800a22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a25:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800a29:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  800a2d:	eb a5                	jmp    8009d4 <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  800a2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a32:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800a35:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800a37:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800a3a:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800a3d:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800a3f:	83 ec 04             	sub    $0x4,%esp
  800a42:	6a 04                	push   $0x4
  800a44:	6a 00                	push   $0x0
  800a46:	ff 75 08             	pushl  0x8(%ebp)
  800a49:	e8 56 e7 00 00       	call   80f1a4 <memset>
  
  return nready;
}
  800a4e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800a51:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800a54:	5b                   	pop    %ebx
  800a55:	5e                   	pop    %esi
  800a56:	5f                   	pop    %edi
  800a57:	5d                   	pop    %ebp
  800a58:	c3                   	ret    

00800a59 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800a59:	55                   	push   %ebp
  800a5a:	89 e5                	mov    %esp,%ebp
  800a5c:	57                   	push   %edi
  800a5d:	56                   	push   %esi
  800a5e:	53                   	push   %ebx
  800a5f:	83 ec 3c             	sub    $0x3c,%esp
  800a62:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  800a65:	89 cf                	mov    %ecx,%edi
  800a67:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800a6a:	e8 a7 fe ff ff       	call   800916 <get_socket>
  if (!sock)
  800a6f:	85 c0                	test   %eax,%eax
  800a71:	0f 84 86 00 00 00    	je     800afd <lwip_getaddrname+0xa4>
  800a77:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  800a79:	83 ec 04             	sub    $0x4,%esp
  800a7c:	6a 10                	push   $0x10
  800a7e:	6a 00                	push   $0x0
  800a80:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800a83:	50                   	push   %eax
  800a84:	e8 1b e7 00 00       	call   80f1a4 <memset>
  sin.sin_len = sizeof(sin);
  800a89:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800a8d:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800a91:	89 f0                	mov    %esi,%eax
  800a93:	0f b6 f0             	movzbl %al,%esi
  800a96:	56                   	push   %esi
  800a97:	8d 45 da             	lea    -0x26(%ebp),%eax
  800a9a:	50                   	push   %eax
  800a9b:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800a9e:	50                   	push   %eax
  800a9f:	ff 33                	pushl  (%ebx)
  800aa1:	e8 3c a4 00 00       	call   80aee2 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800aa6:	83 c4 14             	add    $0x14,%esp
  800aa9:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800aad:	50                   	push   %eax
  800aae:	e8 1b 6e 00 00       	call   8078ce <htons>
  800ab3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800ab7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800aba:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800abd:	83 c4 10             	add    $0x10,%esp
  800ac0:	83 3f 10             	cmpl   $0x10,(%edi)
  800ac3:	76 06                	jbe    800acb <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  800ac5:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  800acb:	83 ec 04             	sub    $0x4,%esp
  800ace:	ff 37                	pushl  (%edi)
  800ad0:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800ad3:	50                   	push   %eax
  800ad4:	ff 75 c4             	pushl  -0x3c(%ebp)
  800ad7:	e8 72 e7 00 00       	call   80f24e <memcpy>
  sock_set_errno(sock, 0);
  800adc:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800ae3:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  800aea:	00 00 00 
  return 0;
  800aed:	83 c4 10             	add    $0x10,%esp
  800af0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800af5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800af8:	5b                   	pop    %ebx
  800af9:	5e                   	pop    %esi
  800afa:	5f                   	pop    %edi
  800afb:	5d                   	pop    %ebp
  800afc:	c3                   	ret    
    return -1;
  800afd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800b02:	eb f1                	jmp    800af5 <lwip_getaddrname+0x9c>

00800b04 <event_callback>:
{
  800b04:	55                   	push   %ebp
  800b05:	89 e5                	mov    %esp,%ebp
  800b07:	57                   	push   %edi
  800b08:	56                   	push   %esi
  800b09:	53                   	push   %ebx
  800b0a:	83 ec 1c             	sub    $0x1c,%esp
  800b0d:	8b 7d 08             	mov    0x8(%ebp),%edi
  800b10:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  800b13:	85 ff                	test   %edi,%edi
  800b15:	0f 84 8b 01 00 00    	je     800ca6 <event_callback+0x1a2>
    s = conn->socket;
  800b1b:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800b1e:	85 db                	test   %ebx,%ebx
  800b20:	78 4d                	js     800b6f <event_callback+0x6b>
    sock = get_socket(s);
  800b22:	89 d8                	mov    %ebx,%eax
  800b24:	e8 ed fd ff ff       	call   800916 <get_socket>
  800b29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800b2c:	85 c0                	test   %eax,%eax
  800b2e:	0f 84 72 01 00 00    	je     800ca6 <event_callback+0x1a2>
  sys_sem_wait(selectsem);
  800b34:	83 ec 0c             	sub    $0xc,%esp
  800b37:	ff 35 40 60 81 00    	pushl  0x816040
  800b3d:	e8 90 47 00 00       	call   8052d2 <sys_sem_wait>
  switch (evt) {
  800b42:	83 c4 10             	add    $0x10,%esp
  800b45:	83 fe 01             	cmp    $0x1,%esi
  800b48:	0f 84 a1 00 00 00    	je     800bef <event_callback+0xeb>
  800b4e:	85 f6                	test   %esi,%esi
  800b50:	74 68                	je     800bba <event_callback+0xb6>
  800b52:	83 fe 02             	cmp    $0x2,%esi
  800b55:	0f 84 9e 00 00 00    	je     800bf9 <event_callback+0xf5>
  800b5b:	83 fe 03             	cmp    $0x3,%esi
  800b5e:	0f 85 a0 00 00 00    	jne    800c04 <event_callback+0x100>
      sock->sendevent = 0;
  800b64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b67:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800b6d:	eb 53                	jmp    800bc2 <event_callback+0xbe>
      sys_sem_wait(socksem);
  800b6f:	83 ec 0c             	sub    $0xc,%esp
  800b72:	ff 35 44 60 81 00    	pushl  0x816044
  800b78:	e8 55 47 00 00       	call   8052d2 <sys_sem_wait>
      if (conn->socket < 0) {
  800b7d:	8b 47 1c             	mov    0x1c(%edi),%eax
  800b80:	83 c4 10             	add    $0x10,%esp
  800b83:	85 c0                	test   %eax,%eax
  800b85:	78 13                	js     800b9a <event_callback+0x96>
      sys_sem_signal(socksem);
  800b87:	83 ec 0c             	sub    $0xc,%esp
  800b8a:	ff 35 44 60 81 00    	pushl  0x816044
  800b90:	e8 cf 96 00 00       	call   80a264 <sys_sem_signal>
  800b95:	83 c4 10             	add    $0x10,%esp
  800b98:	eb 88                	jmp    800b22 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800b9a:	85 f6                	test   %esi,%esi
  800b9c:	75 06                	jne    800ba4 <event_callback+0xa0>
          conn->socket--;
  800b9e:	83 e8 01             	sub    $0x1,%eax
  800ba1:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800ba4:	83 ec 0c             	sub    $0xc,%esp
  800ba7:	ff 35 44 60 81 00    	pushl  0x816044
  800bad:	e8 b2 96 00 00       	call   80a264 <sys_sem_signal>
        return;
  800bb2:	83 c4 10             	add    $0x10,%esp
  800bb5:	e9 ec 00 00 00       	jmp    800ca6 <event_callback+0x1a2>
      sock->rcvevent++;
  800bba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800bbd:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800bc2:	83 ec 0c             	sub    $0xc,%esp
  800bc5:	ff 35 40 60 81 00    	pushl  0x816040
  800bcb:	e8 94 96 00 00       	call   80a264 <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800bd0:	8d 73 07             	lea    0x7(%ebx),%esi
  800bd3:	83 c4 10             	add    $0x10,%esp
  800bd6:	85 db                	test   %ebx,%ebx
  800bd8:	0f 49 f3             	cmovns %ebx,%esi
  800bdb:	c1 fe 03             	sar    $0x3,%esi
  800bde:	89 d9                	mov    %ebx,%ecx
  800be0:	83 e1 07             	and    $0x7,%ecx
  800be3:	bf 01 00 00 00       	mov    $0x1,%edi
  800be8:	d3 e7                	shl    %cl,%edi
  800bea:	e9 8d 00 00 00       	jmp    800c7c <event_callback+0x178>
      sock->rcvevent--;
  800bef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800bf2:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800bf7:	eb c9                	jmp    800bc2 <event_callback+0xbe>
      sock->sendevent = 1;
  800bf9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800bfc:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800c02:	eb be                	jmp    800bc2 <event_callback+0xbe>
      LWIP_ASSERT("unknown event", 0);
  800c04:	83 ec 04             	sub    $0x4,%esp
  800c07:	68 73 17 81 00       	push   $0x811773
  800c0c:	68 17 04 00 00       	push   $0x417
  800c11:	68 81 17 81 00       	push   $0x811781
  800c16:	e8 ee db 00 00       	call   80e809 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800c1b:	8b 1b                	mov    (%ebx),%ebx
  800c1d:	85 db                	test   %ebx,%ebx
  800c1f:	74 74                	je     800c95 <event_callback+0x191>
      if (scb->sem_signalled == 0) {
  800c21:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800c25:	75 f4                	jne    800c1b <event_callback+0x117>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c27:	8b 43 04             	mov    0x4(%ebx),%eax
  800c2a:	85 c0                	test   %eax,%eax
  800c2c:	74 12                	je     800c40 <event_callback+0x13c>
  800c2e:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800c32:	85 f8                	test   %edi,%eax
  800c34:	74 0a                	je     800c40 <event_callback+0x13c>
          if (sock->rcvevent)
  800c36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c39:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800c3e:	75 19                	jne    800c59 <event_callback+0x155>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800c40:	8b 43 08             	mov    0x8(%ebx),%eax
  800c43:	85 c0                	test   %eax,%eax
  800c45:	74 d4                	je     800c1b <event_callback+0x117>
  800c47:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800c4b:	85 f8                	test   %edi,%eax
  800c4d:	74 cc                	je     800c1b <event_callback+0x117>
          if (sock->sendevent)
  800c4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c52:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800c57:	74 c2                	je     800c1b <event_callback+0x117>
      scb->sem_signalled = 1;
  800c59:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800c60:	83 ec 0c             	sub    $0xc,%esp
  800c63:	ff 35 40 60 81 00    	pushl  0x816040
  800c69:	e8 f6 95 00 00       	call   80a264 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800c6e:	83 c4 04             	add    $0x4,%esp
  800c71:	ff 73 14             	pushl  0x14(%ebx)
  800c74:	e8 eb 95 00 00       	call   80a264 <sys_sem_signal>
    sys_sem_wait(selectsem);
  800c79:	83 c4 10             	add    $0x10,%esp
  800c7c:	83 ec 0c             	sub    $0xc,%esp
  800c7f:	ff 35 40 60 81 00    	pushl  0x816040
  800c85:	e8 48 46 00 00       	call   8052d2 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800c8a:	8b 1d 48 60 81 00    	mov    0x816048,%ebx
  800c90:	83 c4 10             	add    $0x10,%esp
  800c93:	eb 88                	jmp    800c1d <event_callback+0x119>
      sys_sem_signal(selectsem);
  800c95:	83 ec 0c             	sub    $0xc,%esp
  800c98:	ff 35 40 60 81 00    	pushl  0x816040
  800c9e:	e8 c1 95 00 00       	call   80a264 <sys_sem_signal>
      break;
  800ca3:	83 c4 10             	add    $0x10,%esp
}
  800ca6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800ca9:	5b                   	pop    %ebx
  800caa:	5e                   	pop    %esi
  800cab:	5f                   	pop    %edi
  800cac:	5d                   	pop    %ebp
  800cad:	c3                   	ret    

00800cae <alloc_socket>:
{
  800cae:	55                   	push   %ebp
  800caf:	89 e5                	mov    %esp,%ebp
  800cb1:	56                   	push   %esi
  800cb2:	53                   	push   %ebx
  800cb3:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800cb5:	83 ec 0c             	sub    $0xc,%esp
  800cb8:	ff 35 44 60 81 00    	pushl  0x816044
  800cbe:	e8 0f 46 00 00       	call   8052d2 <sys_sem_wait>
  800cc3:	b8 60 60 81 00       	mov    $0x816060,%eax
  800cc8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800ccb:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800cd0:	83 38 00             	cmpl   $0x0,(%eax)
  800cd3:	74 23                	je     800cf8 <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800cd5:	83 c3 01             	add    $0x1,%ebx
  800cd8:	83 c0 14             	add    $0x14,%eax
  800cdb:	83 fb 20             	cmp    $0x20,%ebx
  800cde:	75 f0                	jne    800cd0 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800ce0:	83 ec 0c             	sub    $0xc,%esp
  800ce3:	ff 35 44 60 81 00    	pushl  0x816044
  800ce9:	e8 76 95 00 00       	call   80a264 <sys_sem_signal>
  return -1;
  800cee:	83 c4 10             	add    $0x10,%esp
  800cf1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800cf6:	eb 55                	jmp    800d4d <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800cf8:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800cfb:	c1 e2 02             	shl    $0x2,%edx
  800cfe:	89 b2 60 60 81 00    	mov    %esi,0x816060(%edx)
      sockets[i].lastdata   = NULL;
  800d04:	c7 82 64 60 81 00 00 	movl   $0x0,0x816064(%edx)
  800d0b:	00 00 00 
      sockets[i].lastoffset = 0;
  800d0e:	66 c7 82 68 60 81 00 	movw   $0x0,0x816068(%edx)
  800d15:	00 00 
      sockets[i].rcvevent   = 0;
  800d17:	66 c7 82 6a 60 81 00 	movw   $0x0,0x81606a(%edx)
  800d1e:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800d20:	66 c7 82 6c 60 81 00 	movw   $0x1,0x81606c(%edx)
  800d27:	01 00 
      sockets[i].flags      = 0;
  800d29:	66 c7 82 6e 60 81 00 	movw   $0x0,0x81606e(%edx)
  800d30:	00 00 
      sockets[i].err        = 0;
  800d32:	c7 82 70 60 81 00 00 	movl   $0x0,0x816070(%edx)
  800d39:	00 00 00 
      sys_sem_signal(socksem);
  800d3c:	83 ec 0c             	sub    $0xc,%esp
  800d3f:	ff 35 44 60 81 00    	pushl  0x816044
  800d45:	e8 1a 95 00 00       	call   80a264 <sys_sem_signal>
      return i;
  800d4a:	83 c4 10             	add    $0x10,%esp
}
  800d4d:	89 d8                	mov    %ebx,%eax
  800d4f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800d52:	5b                   	pop    %ebx
  800d53:	5e                   	pop    %esi
  800d54:	5d                   	pop    %ebp
  800d55:	c3                   	ret    

00800d56 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800d56:	55                   	push   %ebp
  800d57:	89 e5                	mov    %esp,%ebp
  800d59:	53                   	push   %ebx
  800d5a:	83 ec 04             	sub    $0x4,%esp
  800d5d:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d60:	85 c0                	test   %eax,%eax
  800d62:	74 39                	je     800d9d <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800d64:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800d66:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800d69:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800d6c:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800d6f:	83 fa 06             	cmp    $0x6,%edx
  800d72:	0f 84 37 01 00 00    	je     800eaf <lwip_getsockopt_internal+0x159>
  800d78:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800d7e:	74 34                	je     800db4 <lwip_getsockopt_internal+0x5e>
  800d80:	85 d2                	test   %edx,%edx
  800d82:	0f 84 f9 00 00 00    	je     800e81 <lwip_getsockopt_internal+0x12b>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800d88:	83 ec 0c             	sub    $0xc,%esp
  800d8b:	8b 03                	mov    (%ebx),%eax
  800d8d:	ff 70 10             	pushl  0x10(%eax)
  800d90:	e8 cf 94 00 00       	call   80a264 <sys_sem_signal>
}
  800d95:	83 c4 10             	add    $0x10,%esp
  800d98:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800d9b:	c9                   	leave  
  800d9c:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d9d:	83 ec 04             	sub    $0x4,%esp
  800da0:	68 98 17 81 00       	push   $0x811798
  800da5:	68 38 05 00 00       	push   $0x538
  800daa:	68 81 17 81 00       	push   $0x811781
  800daf:	e8 55 da 00 00       	call   80e809 <_panic>
  800db4:	83 f9 20             	cmp    $0x20,%ecx
  800db7:	74 65                	je     800e1e <lwip_getsockopt_internal+0xc8>
  800db9:	7e 55                	jle    800e10 <lwip_getsockopt_internal+0xba>
  800dbb:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800dc1:	74 6d                	je     800e30 <lwip_getsockopt_internal+0xda>
  800dc3:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800dc9:	0f 84 9f 00 00 00    	je     800e6e <lwip_getsockopt_internal+0x118>
  800dcf:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800dd5:	75 b1                	jne    800d88 <lwip_getsockopt_internal+0x32>
      if (sock->err == 0) {
  800dd7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800ddb:	75 22                	jne    800dff <lwip_getsockopt_internal+0xa9>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800ddd:	8b 13                	mov    (%ebx),%edx
  800ddf:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800de3:	f7 da                	neg    %edx
  800de5:	b9 05 00 00 00       	mov    $0x5,%ecx
  800dea:	83 fa 0e             	cmp    $0xe,%edx
  800ded:	77 07                	ja     800df6 <lwip_getsockopt_internal+0xa0>
  800def:	8b 0c 95 40 18 81 00 	mov    0x811840(,%edx,4),%ecx
  800df6:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800df9:	89 0d e0 c1 b3 00    	mov    %ecx,0xb3c1e0
      *(int *)optval = sock->err;
  800dff:	8b 53 10             	mov    0x10(%ebx),%edx
  800e02:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800e04:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800e0b:	e9 78 ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
  800e10:	83 f9 02             	cmp    $0x2,%ecx
  800e13:	74 09                	je     800e1e <lwip_getsockopt_internal+0xc8>
  800e15:	83 f9 08             	cmp    $0x8,%ecx
  800e18:	0f 85 6a ff ff ff    	jne    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800e1e:	8b 13                	mov    (%ebx),%edx
  800e20:	8b 52 08             	mov    0x8(%edx),%edx
  800e23:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800e27:	21 d1                	and    %edx,%ecx
  800e29:	89 08                	mov    %ecx,(%eax)
      break;
  800e2b:	e9 58 ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800e30:	8b 13                	mov    (%ebx),%edx
  800e32:	8b 12                	mov    (%edx),%edx
  800e34:	89 d1                	mov    %edx,%ecx
  800e36:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800e3c:	83 f9 20             	cmp    $0x20,%ecx
  800e3f:	74 22                	je     800e63 <lwip_getsockopt_internal+0x10d>
  800e41:	83 f9 40             	cmp    $0x40,%ecx
  800e44:	74 12                	je     800e58 <lwip_getsockopt_internal+0x102>
        *(int*)optval = sock->conn->type;
  800e46:	83 f9 10             	cmp    $0x10,%ecx
  800e49:	b9 01 00 00 00       	mov    $0x1,%ecx
  800e4e:	0f 44 d1             	cmove  %ecx,%edx
  800e51:	89 10                	mov    %edx,(%eax)
  800e53:	e9 30 ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_RAW;
  800e58:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800e5e:	e9 25 ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_DGRAM;
  800e63:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800e69:	e9 1a ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800e6e:	8b 13                	mov    (%ebx),%edx
  800e70:	8b 52 08             	mov    0x8(%edx),%edx
  800e73:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800e77:	83 e2 01             	and    $0x1,%edx
  800e7a:	89 10                	mov    %edx,(%eax)
      break;
  800e7c:	e9 07 ff ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
  800e81:	83 f9 01             	cmp    $0x1,%ecx
  800e84:	74 19                	je     800e9f <lwip_getsockopt_internal+0x149>
  800e86:	83 f9 02             	cmp    $0x2,%ecx
  800e89:	0f 85 f9 fe ff ff    	jne    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800e8f:	8b 13                	mov    (%ebx),%edx
  800e91:	8b 52 08             	mov    0x8(%edx),%edx
  800e94:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800e98:	89 10                	mov    %edx,(%eax)
      break;
  800e9a:	e9 e9 fe ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800e9f:	8b 13                	mov    (%ebx),%edx
  800ea1:	8b 52 08             	mov    0x8(%edx),%edx
  800ea4:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800ea8:	89 10                	mov    %edx,(%eax)
      break;
  800eaa:	e9 d9 fe ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
  800eaf:	83 f9 01             	cmp    $0x1,%ecx
  800eb2:	74 1b                	je     800ecf <lwip_getsockopt_internal+0x179>
  800eb4:	83 f9 02             	cmp    $0x2,%ecx
  800eb7:	0f 85 cb fe ff ff    	jne    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800ebd:	8b 13                	mov    (%ebx),%edx
  800ebf:	8b 52 08             	mov    0x8(%edx),%edx
  800ec2:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800ec8:	89 10                	mov    %edx,(%eax)
      break;
  800eca:	e9 b9 fe ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800ecf:	8b 13                	mov    (%ebx),%edx
  800ed1:	8b 52 08             	mov    0x8(%edx),%edx
  800ed4:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800ed8:	83 e2 40             	and    $0x40,%edx
  800edb:	0f b6 d2             	movzbl %dl,%edx
  800ede:	89 10                	mov    %edx,(%eax)
      break;
  800ee0:	e9 a3 fe ff ff       	jmp    800d88 <lwip_getsockopt_internal+0x32>

00800ee5 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800ee5:	55                   	push   %ebp
  800ee6:	89 e5                	mov    %esp,%ebp
  800ee8:	53                   	push   %ebx
  800ee9:	83 ec 04             	sub    $0x4,%esp
  800eec:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800eef:	85 c0                	test   %eax,%eax
  800ef1:	74 35                	je     800f28 <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800ef3:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800ef5:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800ef8:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800efb:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800efe:	83 fa 06             	cmp    $0x6,%edx
  800f01:	0f 84 aa 00 00 00    	je     800fb1 <lwip_setsockopt_internal+0xcc>
  800f07:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800f0d:	74 30                	je     800f3f <lwip_setsockopt_internal+0x5a>
  800f0f:	85 d2                	test   %edx,%edx
  800f11:	74 76                	je     800f89 <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800f13:	83 ec 0c             	sub    $0xc,%esp
  800f16:	8b 03                	mov    (%ebx),%eax
  800f18:	ff 70 10             	pushl  0x10(%eax)
  800f1b:	e8 44 93 00 00       	call   80a264 <sys_sem_signal>
}
  800f20:	83 c4 10             	add    $0x10,%esp
  800f23:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800f26:	c9                   	leave  
  800f27:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800f28:	83 ec 04             	sub    $0x4,%esp
  800f2b:	68 98 17 81 00       	push   $0x811798
  800f30:	68 ae 06 00 00       	push   $0x6ae
  800f35:	68 81 17 81 00       	push   $0x811781
  800f3a:	e8 ca d8 00 00       	call   80e809 <_panic>
  800f3f:	83 f9 20             	cmp    $0x20,%ecx
  800f42:	74 0d                	je     800f51 <lwip_setsockopt_internal+0x6c>
  800f44:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800f4a:	74 22                	je     800f6e <lwip_setsockopt_internal+0x89>
  800f4c:	83 f9 08             	cmp    $0x8,%ecx
  800f4f:	75 c2                	jne    800f13 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800f51:	83 38 00             	cmpl   $0x0,(%eax)
  800f54:	74 0b                	je     800f61 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800f56:	8b 03                	mov    (%ebx),%eax
  800f58:	8b 40 08             	mov    0x8(%eax),%eax
  800f5b:	66 09 48 08          	or     %cx,0x8(%eax)
  800f5f:	eb b2                	jmp    800f13 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800f61:	8b 03                	mov    (%ebx),%eax
  800f63:	8b 40 08             	mov    0x8(%eax),%eax
  800f66:	f7 d1                	not    %ecx
  800f68:	66 21 48 08          	and    %cx,0x8(%eax)
  800f6c:	eb a5                	jmp    800f13 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800f6e:	83 38 00             	cmpl   $0x0,(%eax)
  800f71:	74 0b                	je     800f7e <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800f73:	8b 03                	mov    (%ebx),%eax
  800f75:	8b 40 08             	mov    0x8(%eax),%eax
  800f78:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800f7c:	eb 95                	jmp    800f13 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800f7e:	8b 03                	mov    (%ebx),%eax
  800f80:	8b 40 08             	mov    0x8(%eax),%eax
  800f83:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800f87:	eb 8a                	jmp    800f13 <lwip_setsockopt_internal+0x2e>
  800f89:	83 f9 01             	cmp    $0x1,%ecx
  800f8c:	74 14                	je     800fa2 <lwip_setsockopt_internal+0xbd>
  800f8e:	83 f9 02             	cmp    $0x2,%ecx
  800f91:	75 80                	jne    800f13 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800f93:	8b 13                	mov    (%ebx),%edx
  800f95:	8b 52 08             	mov    0x8(%edx),%edx
  800f98:	8b 00                	mov    (%eax),%eax
  800f9a:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800f9d:	e9 71 ff ff ff       	jmp    800f13 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800fa2:	8b 13                	mov    (%ebx),%edx
  800fa4:	8b 52 08             	mov    0x8(%edx),%edx
  800fa7:	8b 00                	mov    (%eax),%eax
  800fa9:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800fac:	e9 62 ff ff ff       	jmp    800f13 <lwip_setsockopt_internal+0x2e>
  800fb1:	83 f9 01             	cmp    $0x1,%ecx
  800fb4:	74 1b                	je     800fd1 <lwip_setsockopt_internal+0xec>
  800fb6:	83 f9 02             	cmp    $0x2,%ecx
  800fb9:	0f 85 54 ff ff ff    	jne    800f13 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800fbf:	8b 13                	mov    (%ebx),%edx
  800fc1:	8b 52 08             	mov    0x8(%edx),%edx
  800fc4:	8b 00                	mov    (%eax),%eax
  800fc6:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800fcc:	e9 42 ff ff ff       	jmp    800f13 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800fd1:	83 38 00             	cmpl   $0x0,(%eax)
  800fd4:	74 0e                	je     800fe4 <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800fd6:	8b 03                	mov    (%ebx),%eax
  800fd8:	8b 40 08             	mov    0x8(%eax),%eax
  800fdb:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800fdf:	e9 2f ff ff ff       	jmp    800f13 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800fe4:	8b 03                	mov    (%ebx),%eax
  800fe6:	8b 40 08             	mov    0x8(%eax),%eax
  800fe9:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800fed:	e9 21 ff ff ff       	jmp    800f13 <lwip_setsockopt_internal+0x2e>

00800ff2 <lwip_socket_init>:
{
  800ff2:	55                   	push   %ebp
  800ff3:	89 e5                	mov    %esp,%ebp
  800ff5:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800ff8:	6a 01                	push   $0x1
  800ffa:	e8 a8 8f 00 00       	call   809fa7 <sys_sem_new>
  800fff:	a3 44 60 81 00       	mov    %eax,0x816044
  selectsem = sys_sem_new(1);
  801004:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80100b:	e8 97 8f 00 00       	call   809fa7 <sys_sem_new>
  801010:	a3 40 60 81 00       	mov    %eax,0x816040
}
  801015:	83 c4 10             	add    $0x10,%esp
  801018:	c9                   	leave  
  801019:	c3                   	ret    

0080101a <lwip_accept>:
{
  80101a:	55                   	push   %ebp
  80101b:	89 e5                	mov    %esp,%ebp
  80101d:	57                   	push   %edi
  80101e:	56                   	push   %esi
  80101f:	53                   	push   %ebx
  801020:	83 ec 3c             	sub    $0x3c,%esp
  801023:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  801026:	8b 45 08             	mov    0x8(%ebp),%eax
  801029:	e8 e8 f8 ff ff       	call   800916 <get_socket>
  if (!sock)
  80102e:	85 c0                	test   %eax,%eax
  801030:	0f 84 8c 01 00 00    	je     8011c2 <lwip_accept+0x1a8>
  801036:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  801038:	83 ec 0c             	sub    $0xc,%esp
  80103b:	ff 30                	pushl  (%eax)
  80103d:	e8 56 a0 00 00       	call   80b098 <netconn_accept>
  801042:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  801044:	83 c4 10             	add    $0x10,%esp
  801047:	85 c0                	test   %eax,%eax
  801049:	0f 84 de 00 00 00    	je     80112d <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  80104f:	6a 00                	push   $0x0
  801051:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  801054:	50                   	push   %eax
  801055:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801058:	50                   	push   %eax
  801059:	53                   	push   %ebx
  80105a:	e8 83 9e 00 00       	call   80aee2 <netconn_getaddr>
  80105f:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  801062:	83 c4 10             	add    $0x10,%esp
  801065:	84 c0                	test   %al,%al
  801067:	0f 85 e9 00 00 00    	jne    801156 <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  80106d:	83 ec 04             	sub    $0x4,%esp
  801070:	6a 10                	push   $0x10
  801072:	6a 00                	push   $0x0
  801074:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801077:	50                   	push   %eax
  801078:	e8 27 e1 00 00       	call   80f1a4 <memset>
  sin.sin_len = sizeof(sin);
  80107d:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  801081:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  801085:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801089:	89 04 24             	mov    %eax,(%esp)
  80108c:	e8 3d 68 00 00       	call   8078ce <htons>
  801091:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  801095:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801098:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  80109b:	83 c4 10             	add    $0x10,%esp
  80109e:	83 3f 10             	cmpl   $0x10,(%edi)
  8010a1:	76 06                	jbe    8010a9 <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  8010a3:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  8010a9:	83 ec 04             	sub    $0x4,%esp
  8010ac:	ff 37                	pushl  (%edi)
  8010ae:	8d 45 d0             	lea    -0x30(%ebp),%eax
  8010b1:	50                   	push   %eax
  8010b2:	ff 75 0c             	pushl  0xc(%ebp)
  8010b5:	e8 94 e1 00 00       	call   80f24e <memcpy>
  newsock = alloc_socket(newconn);
  8010ba:	89 d8                	mov    %ebx,%eax
  8010bc:	e8 ed fb ff ff       	call   800cae <alloc_socket>
  8010c1:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  8010c3:	83 c4 10             	add    $0x10,%esp
  8010c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8010c9:	0f 84 ba 00 00 00    	je     801189 <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8010cf:	83 f8 1f             	cmp    $0x1f,%eax
  8010d2:	0f 87 d3 00 00 00    	ja     8011ab <lwip_accept+0x191>
  newconn->callback = event_callback;
  8010d8:	c7 43 2c 04 0b 80 00 	movl   $0x800b04,0x2c(%ebx)
  sys_sem_wait(socksem);
  8010df:	83 ec 0c             	sub    $0xc,%esp
  8010e2:	ff 35 44 60 81 00    	pushl  0x816044
  8010e8:	e8 e5 41 00 00       	call   8052d2 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  8010ed:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  8010f0:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  8010f4:	f7 d2                	not    %edx
  8010f6:	66 01 14 85 6a 60 81 	add    %dx,0x81606a(,%eax,4)
  8010fd:	00 
  newconn->socket = newsock;
  8010fe:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801101:	83 c4 04             	add    $0x4,%esp
  801104:	ff 35 44 60 81 00    	pushl  0x816044
  80110a:	e8 55 91 00 00       	call   80a264 <sys_sem_signal>
  sock_set_errno(sock, 0);
  80110f:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801116:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80111d:	00 00 00 
  return newsock;
  801120:	83 c4 10             	add    $0x10,%esp
}
  801123:	89 f8                	mov    %edi,%eax
  801125:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801128:	5b                   	pop    %ebx
  801129:	5e                   	pop    %esi
  80112a:	5f                   	pop    %edi
  80112b:	5d                   	pop    %ebp
  80112c:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  80112d:	8b 06                	mov    (%esi),%eax
  80112f:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  801133:	f7 d8                	neg    %eax
  801135:	ba 05 00 00 00       	mov    $0x5,%edx
  80113a:	83 f8 0e             	cmp    $0xe,%eax
  80113d:	77 07                	ja     801146 <lwip_accept+0x12c>
  80113f:	8b 14 85 40 18 81 00 	mov    0x811840(,%eax,4),%edx
  801146:	89 56 10             	mov    %edx,0x10(%esi)
  801149:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  80114f:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  801154:	eb cd                	jmp    801123 <lwip_accept+0x109>
    netconn_delete(newconn);
  801156:	83 ec 0c             	sub    $0xc,%esp
  801159:	53                   	push   %ebx
  80115a:	e8 1b 9d 00 00       	call   80ae7a <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80115f:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  801163:	f7 d8                	neg    %eax
  801165:	83 c4 10             	add    $0x10,%esp
  801168:	ba 05 00 00 00       	mov    $0x5,%edx
  80116d:	83 f8 0e             	cmp    $0xe,%eax
  801170:	77 07                	ja     801179 <lwip_accept+0x15f>
  801172:	8b 14 85 40 18 81 00 	mov    0x811840(,%eax,4),%edx
  801179:	89 56 10             	mov    %edx,0x10(%esi)
  80117c:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  801182:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  801187:	eb 9a                	jmp    801123 <lwip_accept+0x109>
    netconn_delete(newconn);
  801189:	83 ec 0c             	sub    $0xc,%esp
  80118c:	53                   	push   %ebx
  80118d:	e8 e8 9c 00 00       	call   80ae7a <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801192:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  801199:	c7 05 e0 c1 b3 00 17 	movl   $0x17,0xb3c1e0
  8011a0:	00 00 00 
    return -1;
  8011a3:	83 c4 10             	add    $0x10,%esp
  8011a6:	e9 78 ff ff ff       	jmp    801123 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8011ab:	83 ec 04             	sub    $0x4,%esp
  8011ae:	68 a4 17 81 00       	push   $0x8117a4
  8011b3:	68 25 01 00 00       	push   $0x125
  8011b8:	68 81 17 81 00       	push   $0x811781
  8011bd:	e8 47 d6 00 00       	call   80e809 <_panic>
    return -1;
  8011c2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  8011c7:	e9 57 ff ff ff       	jmp    801123 <lwip_accept+0x109>

008011cc <lwip_bind>:
{
  8011cc:	55                   	push   %ebp
  8011cd:	89 e5                	mov    %esp,%ebp
  8011cf:	56                   	push   %esi
  8011d0:	53                   	push   %ebx
  8011d1:	83 ec 10             	sub    $0x10,%esp
  8011d4:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8011d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8011da:	e8 37 f7 ff ff       	call   800916 <get_socket>
  if (!sock)
  8011df:	85 c0                	test   %eax,%eax
  8011e1:	0f 84 94 00 00 00    	je     80127b <lwip_bind+0xaf>
  8011e7:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011e9:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011ed:	75 4f                	jne    80123e <lwip_bind+0x72>
  8011ef:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011f3:	75 49                	jne    80123e <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8011f5:	8b 46 04             	mov    0x4(%esi),%eax
  8011f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8011fb:	83 ec 0c             	sub    $0xc,%esp
  8011fe:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801202:	50                   	push   %eax
  801203:	e8 d3 66 00 00       	call   8078db <ntohs>
  801208:	83 c4 0c             	add    $0xc,%esp
  80120b:	0f b7 c0             	movzwl %ax,%eax
  80120e:	50                   	push   %eax
  80120f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801212:	50                   	push   %eax
  801213:	ff 33                	pushl  (%ebx)
  801215:	e8 54 9d 00 00       	call   80af6e <netconn_bind>
  if (err != ERR_OK) {
  80121a:	83 c4 10             	add    $0x10,%esp
  80121d:	84 c0                	test   %al,%al
  80121f:	75 34                	jne    801255 <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  801221:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801228:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80122f:	00 00 00 
  return 0;
  801232:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801237:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80123a:	5b                   	pop    %ebx
  80123b:	5e                   	pop    %esi
  80123c:	5d                   	pop    %ebp
  80123d:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80123e:	83 ec 04             	sub    $0x4,%esp
  801241:	68 b9 17 81 00       	push   $0x8117b9
  801246:	68 4a 01 00 00       	push   $0x14a
  80124b:	68 81 17 81 00       	push   $0x811781
  801250:	e8 b4 d5 00 00       	call   80e809 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801255:	0f be c0             	movsbl %al,%eax
  801258:	f7 d8                	neg    %eax
  80125a:	ba 05 00 00 00       	mov    $0x5,%edx
  80125f:	83 f8 0e             	cmp    $0xe,%eax
  801262:	77 07                	ja     80126b <lwip_bind+0x9f>
  801264:	8b 14 85 40 18 81 00 	mov    0x811840(,%eax,4),%edx
  80126b:	89 53 10             	mov    %edx,0x10(%ebx)
  80126e:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  801274:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801279:	eb bc                	jmp    801237 <lwip_bind+0x6b>
    return -1;
  80127b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801280:	eb b5                	jmp    801237 <lwip_bind+0x6b>

00801282 <lwip_close>:
{
  801282:	55                   	push   %ebp
  801283:	89 e5                	mov    %esp,%ebp
  801285:	53                   	push   %ebx
  801286:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  801289:	8b 45 08             	mov    0x8(%ebp),%eax
  80128c:	e8 85 f6 ff ff       	call   800916 <get_socket>
  if (!sock) {
  801291:	85 c0                	test   %eax,%eax
  801293:	74 6f                	je     801304 <lwip_close+0x82>
  801295:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  801297:	83 ec 0c             	sub    $0xc,%esp
  80129a:	ff 30                	pushl  (%eax)
  80129c:	e8 d9 9b 00 00       	call   80ae7a <netconn_delete>
  sys_sem_wait(socksem);
  8012a1:	83 c4 04             	add    $0x4,%esp
  8012a4:	ff 35 44 60 81 00    	pushl  0x816044
  8012aa:	e8 23 40 00 00       	call   8052d2 <sys_sem_wait>
  if (sock->lastdata) {
  8012af:	8b 43 04             	mov    0x4(%ebx),%eax
  8012b2:	83 c4 10             	add    $0x10,%esp
  8012b5:	85 c0                	test   %eax,%eax
  8012b7:	74 0c                	je     8012c5 <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  8012b9:	83 ec 0c             	sub    $0xc,%esp
  8012bc:	50                   	push   %eax
  8012bd:	e8 99 13 00 00       	call   80265b <netbuf_delete>
  8012c2:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  8012c5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  8012cc:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8012d2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8012d8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8012df:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8012e6:	00 00 00 
  sys_sem_signal(socksem);
  8012e9:	83 ec 0c             	sub    $0xc,%esp
  8012ec:	ff 35 44 60 81 00    	pushl  0x816044
  8012f2:	e8 6d 8f 00 00       	call   80a264 <sys_sem_signal>
  return 0;
  8012f7:	83 c4 10             	add    $0x10,%esp
  8012fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8012ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801302:	c9                   	leave  
  801303:	c3                   	ret    
    return -1;
  801304:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801309:	eb f4                	jmp    8012ff <lwip_close+0x7d>

0080130b <lwip_connect>:
{
  80130b:	55                   	push   %ebp
  80130c:	89 e5                	mov    %esp,%ebp
  80130e:	56                   	push   %esi
  80130f:	53                   	push   %ebx
  801310:	83 ec 10             	sub    $0x10,%esp
  801313:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  801316:	8b 45 08             	mov    0x8(%ebp),%eax
  801319:	e8 f8 f5 ff ff       	call   800916 <get_socket>
  if (!sock)
  80131e:	85 c0                	test   %eax,%eax
  801320:	0f 84 94 00 00 00    	je     8013ba <lwip_connect+0xaf>
  801326:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801328:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80132c:	75 4f                	jne    80137d <lwip_connect+0x72>
  80132e:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801332:	75 49                	jne    80137d <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  801334:	8b 46 04             	mov    0x4(%esi),%eax
  801337:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80133a:	83 ec 0c             	sub    $0xc,%esp
  80133d:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801341:	50                   	push   %eax
  801342:	e8 94 65 00 00       	call   8078db <ntohs>
  801347:	83 c4 0c             	add    $0xc,%esp
  80134a:	0f b7 c0             	movzwl %ax,%eax
  80134d:	50                   	push   %eax
  80134e:	8d 45 f4             	lea    -0xc(%ebp),%eax
  801351:	50                   	push   %eax
  801352:	ff 33                	pushl  (%ebx)
  801354:	e8 66 9c 00 00       	call   80afbf <netconn_connect>
  if (err != ERR_OK) {
  801359:	83 c4 10             	add    $0x10,%esp
  80135c:	84 c0                	test   %al,%al
  80135e:	75 34                	jne    801394 <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  801360:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801367:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80136e:	00 00 00 
  return 0;
  801371:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801376:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801379:	5b                   	pop    %ebx
  80137a:	5e                   	pop    %esi
  80137b:	5d                   	pop    %ebp
  80137c:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80137d:	83 ec 04             	sub    $0x4,%esp
  801380:	68 d4 17 81 00       	push   $0x8117d4
  801385:	68 86 01 00 00       	push   $0x186
  80138a:	68 81 17 81 00       	push   $0x811781
  80138f:	e8 75 d4 00 00       	call   80e809 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  801394:	0f be c0             	movsbl %al,%eax
  801397:	f7 d8                	neg    %eax
  801399:	ba 05 00 00 00       	mov    $0x5,%edx
  80139e:	83 f8 0e             	cmp    $0xe,%eax
  8013a1:	77 07                	ja     8013aa <lwip_connect+0x9f>
  8013a3:	8b 14 85 40 18 81 00 	mov    0x811840(,%eax,4),%edx
  8013aa:	89 53 10             	mov    %edx,0x10(%ebx)
  8013ad:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  8013b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013b8:	eb bc                	jmp    801376 <lwip_connect+0x6b>
    return -1;
  8013ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8013bf:	eb b5                	jmp    801376 <lwip_connect+0x6b>

008013c1 <lwip_listen>:
{
  8013c1:	55                   	push   %ebp
  8013c2:	89 e5                	mov    %esp,%ebp
  8013c4:	56                   	push   %esi
  8013c5:	53                   	push   %ebx
  8013c6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  8013c9:	8b 45 08             	mov    0x8(%ebp),%eax
  8013cc:	e8 45 f5 ff ff       	call   800916 <get_socket>
  if (!sock)
  8013d1:	85 c0                	test   %eax,%eax
  8013d3:	74 6f                	je     801444 <lwip_listen+0x83>
  8013d5:	89 c6                	mov    %eax,%esi
  8013d7:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8013dd:	b8 ff 00 00 00       	mov    $0xff,%eax
  8013e2:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  8013e5:	83 ec 08             	sub    $0x8,%esp
  8013e8:	85 db                	test   %ebx,%ebx
  8013ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8013ef:	0f 48 d8             	cmovs  %eax,%ebx
  8013f2:	53                   	push   %ebx
  8013f3:	ff 36                	pushl  (%esi)
  8013f5:	e8 5a 9c 00 00       	call   80b054 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  8013fa:	83 c4 10             	add    $0x10,%esp
  8013fd:	84 c0                	test   %al,%al
  8013ff:	75 1d                	jne    80141e <lwip_listen+0x5d>
  sock_set_errno(sock, 0);
  801401:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  801408:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80140f:	00 00 00 
  return 0;
  801412:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801417:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80141a:	5b                   	pop    %ebx
  80141b:	5e                   	pop    %esi
  80141c:	5d                   	pop    %ebp
  80141d:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  80141e:	0f be c0             	movsbl %al,%eax
  801421:	f7 d8                	neg    %eax
  801423:	ba 05 00 00 00       	mov    $0x5,%edx
  801428:	83 f8 0e             	cmp    $0xe,%eax
  80142b:	77 07                	ja     801434 <lwip_listen+0x73>
  80142d:	8b 14 85 40 18 81 00 	mov    0x811840(,%eax,4),%edx
  801434:	89 56 10             	mov    %edx,0x10(%esi)
  801437:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
    return -1;
  80143d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801442:	eb d3                	jmp    801417 <lwip_listen+0x56>
    return -1;
  801444:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801449:	eb cc                	jmp    801417 <lwip_listen+0x56>

0080144b <lwip_recvfrom>:
{
  80144b:	55                   	push   %ebp
  80144c:	89 e5                	mov    %esp,%ebp
  80144e:	57                   	push   %edi
  80144f:	56                   	push   %esi
  801450:	53                   	push   %ebx
  801451:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  801454:	8b 45 08             	mov    0x8(%ebp),%eax
  801457:	e8 ba f4 ff ff       	call   800916 <get_socket>
  if (!sock)
  80145c:	85 c0                	test   %eax,%eax
  80145e:	0f 84 22 02 00 00    	je     801686 <lwip_recvfrom+0x23b>
  801464:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  801466:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80146c:	8b 45 14             	mov    0x14(%ebp),%eax
  80146f:	83 e0 08             	and    $0x8,%eax
  801472:	89 45 b8             	mov    %eax,-0x48(%ebp)
  801475:	e9 a7 00 00 00       	jmp    801521 <lwip_recvfrom+0xd6>
  80147a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  80147e:	75 06                	jne    801486 <lwip_recvfrom+0x3b>
  801480:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801484:	74 07                	je     80148d <lwip_recvfrom+0x42>
  801486:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80148b:	74 56                	je     8014e3 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  80148d:	83 ec 0c             	sub    $0xc,%esp
  801490:	ff 37                	pushl  (%edi)
  801492:	e8 73 9c 00 00       	call   80b10a <netconn_recv>
  801497:	89 c6                	mov    %eax,%esi
  801499:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  80149c:	83 c4 10             	add    $0x10,%esp
  80149f:	85 c0                	test   %eax,%eax
  8014a1:	0f 85 85 00 00 00    	jne    80152c <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8014a7:	8b 17                	mov    (%edi),%edx
  8014a9:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8014ad:	74 0b                	je     8014ba <lwip_recvfrom+0x6f>
  8014af:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8014b4:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8014b8:	74 17                	je     8014d1 <lwip_recvfrom+0x86>
  8014ba:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  8014be:	f7 da                	neg    %edx
  8014c0:	b8 05 00 00 00       	mov    $0x5,%eax
  8014c5:	83 fa 0e             	cmp    $0xe,%edx
  8014c8:	77 07                	ja     8014d1 <lwip_recvfrom+0x86>
  8014ca:	8b 04 95 40 18 81 00 	mov    0x811840(,%edx,4),%eax
  8014d1:	89 47 10             	mov    %eax,0x10(%edi)
  8014d4:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
        return 0;
  8014d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8014de:	e9 0b 01 00 00       	jmp    8015ee <lwip_recvfrom+0x1a3>
        sock_set_errno(sock, EWOULDBLOCK);
  8014e3:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  8014ea:	c7 05 e0 c1 b3 00 0b 	movl   $0xb,0xb3c1e0
  8014f1:	00 00 00 
        return -1;
  8014f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8014f9:	e9 f0 00 00 00       	jmp    8015ee <lwip_recvfrom+0x1a3>
        sock->lastdata = NULL;
  8014fe:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  801505:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  80150b:	83 ec 0c             	sub    $0xc,%esp
  80150e:	56                   	push   %esi
  80150f:	e8 47 11 00 00       	call   80265b <netbuf_delete>
  801514:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  801517:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80151b:	0f 85 ac 00 00 00    	jne    8015cd <lwip_recvfrom+0x182>
    if (sock->lastdata) {
  801521:	8b 77 04             	mov    0x4(%edi),%esi
  801524:	85 f6                	test   %esi,%esi
  801526:	0f 84 4e ff ff ff    	je     80147a <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  80152c:	8b 16                	mov    (%esi),%edx
  80152e:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  801532:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  801536:	89 cb                	mov    %ecx,%ebx
  801538:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  80153a:	0f b7 db             	movzwl %bx,%ebx
  80153d:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  801540:	29 c1                	sub    %eax,%ecx
  801542:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  801545:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  80154a:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80154c:	0f b7 c9             	movzwl %cx,%ecx
  80154f:	0f b7 c0             	movzwl %ax,%eax
  801552:	50                   	push   %eax
  801553:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  801556:	51                   	push   %ecx
  801557:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80155b:	03 45 0c             	add    0xc(%ebp),%eax
  80155e:	50                   	push   %eax
  80155f:	52                   	push   %edx
  801560:	e8 0b 3c 00 00       	call   805170 <pbuf_copy_partial>
    off += copylen;
  801565:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801569:	83 c4 04             	add    $0x4,%esp
  80156c:	ff 37                	pushl  (%edi)
  80156e:	e8 47 99 00 00       	call   80aeba <netconn_type>
  801573:	83 c4 10             	add    $0x10,%esp
      done = 1;
  801576:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80157a:	83 f8 10             	cmp    $0x10,%eax
  80157d:	75 23                	jne    8015a2 <lwip_recvfrom+0x157>
      len -= copylen;
  80157f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801582:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  801585:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801589:	7e 17                	jle    8015a2 <lwip_recvfrom+0x157>
  80158b:	8b 06                	mov    (%esi),%eax
  80158d:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  801591:	83 e0 01             	and    $0x1,%eax
  801594:	88 45 c7             	mov    %al,-0x39(%ebp)
  801597:	75 09                	jne    8015a2 <lwip_recvfrom+0x157>
  801599:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  80159e:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  8015a2:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  8015a6:	75 25                	jne    8015cd <lwip_recvfrom+0x182>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8015a8:	8b 07                	mov    (%edi),%eax
  8015aa:	83 38 10             	cmpl   $0x10,(%eax)
  8015ad:	0f 85 4b ff ff ff    	jne    8014fe <lwip_recvfrom+0xb3>
  8015b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8015b6:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8015b9:	85 c0                	test   %eax,%eax
  8015bb:	0f 8e 3d ff ff ff    	jle    8014fe <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  8015c1:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  8015c4:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  8015c8:	e9 4a ff ff ff       	jmp    801517 <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  8015cd:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8015d1:	74 06                	je     8015d9 <lwip_recvfrom+0x18e>
  8015d3:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8015d7:	75 1d                	jne    8015f6 <lwip_recvfrom+0x1ab>
  sock_set_errno(sock, 0);
  8015d9:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8015e0:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8015e7:	00 00 00 
  return off;
  8015ea:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  8015ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8015f1:	5b                   	pop    %ebx
  8015f2:	5e                   	pop    %esi
  8015f3:	5f                   	pop    %edi
  8015f4:	5d                   	pop    %ebp
  8015f5:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015f6:	83 ec 0c             	sub    $0xc,%esp
  8015f9:	ff 37                	pushl  (%edi)
  8015fb:	e8 ba 98 00 00       	call   80aeba <netconn_type>
  801600:	83 c4 10             	add    $0x10,%esp
  801603:	83 f8 10             	cmp    $0x10,%eax
  801606:	74 65                	je     80166d <lwip_recvfrom+0x222>
      addr = netbuf_fromaddr(buf);
  801608:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80160b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80160f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  801613:	83 ec 04             	sub    $0x4,%esp
  801616:	6a 10                	push   $0x10
  801618:	6a 00                	push   $0x0
  80161a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80161d:	50                   	push   %eax
  80161e:	e8 81 db 00 00       	call   80f1a4 <memset>
    sin.sin_len = sizeof(sin);
  801623:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  801627:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80162b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80162f:	89 04 24             	mov    %eax,(%esp)
  801632:	e8 97 62 00 00       	call   8078ce <htons>
  801637:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80163b:	8b 03                	mov    (%ebx),%eax
  80163d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  801640:	83 c4 10             	add    $0x10,%esp
  801643:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801646:	83 38 10             	cmpl   $0x10,(%eax)
  801649:	76 06                	jbe    801651 <lwip_recvfrom+0x206>
      *fromlen = sizeof(sin);
  80164b:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  801651:	83 ec 04             	sub    $0x4,%esp
  801654:	8b 45 1c             	mov    0x1c(%ebp),%eax
  801657:	ff 30                	pushl  (%eax)
  801659:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80165c:	50                   	push   %eax
  80165d:	ff 75 18             	pushl  0x18(%ebp)
  801660:	e8 e9 db 00 00       	call   80f24e <memcpy>
  801665:	83 c4 10             	add    $0x10,%esp
  801668:	e9 6c ff ff ff       	jmp    8015d9 <lwip_recvfrom+0x18e>
      netconn_getaddr(sock->conn, addr, &port, 0);
  80166d:	6a 00                	push   $0x0
  80166f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801672:	50                   	push   %eax
  801673:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801676:	50                   	push   %eax
  801677:	ff 37                	pushl  (%edi)
  801679:	e8 64 98 00 00       	call   80aee2 <netconn_getaddr>
  80167e:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801681:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  801684:	eb 8d                	jmp    801613 <lwip_recvfrom+0x1c8>
    return -1;
  801686:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80168b:	e9 5e ff ff ff       	jmp    8015ee <lwip_recvfrom+0x1a3>

00801690 <lwip_read>:
{
  801690:	55                   	push   %ebp
  801691:	89 e5                	mov    %esp,%ebp
  801693:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801696:	6a 00                	push   $0x0
  801698:	6a 00                	push   $0x0
  80169a:	6a 00                	push   $0x0
  80169c:	ff 75 10             	pushl  0x10(%ebp)
  80169f:	ff 75 0c             	pushl  0xc(%ebp)
  8016a2:	ff 75 08             	pushl  0x8(%ebp)
  8016a5:	e8 a1 fd ff ff       	call   80144b <lwip_recvfrom>
}
  8016aa:	c9                   	leave  
  8016ab:	c3                   	ret    

008016ac <lwip_recv>:
{
  8016ac:	55                   	push   %ebp
  8016ad:	89 e5                	mov    %esp,%ebp
  8016af:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8016b2:	6a 00                	push   $0x0
  8016b4:	6a 00                	push   $0x0
  8016b6:	ff 75 14             	pushl  0x14(%ebp)
  8016b9:	ff 75 10             	pushl  0x10(%ebp)
  8016bc:	ff 75 0c             	pushl  0xc(%ebp)
  8016bf:	ff 75 08             	pushl  0x8(%ebp)
  8016c2:	e8 84 fd ff ff       	call   80144b <lwip_recvfrom>
}
  8016c7:	c9                   	leave  
  8016c8:	c3                   	ret    

008016c9 <lwip_sendto>:
{
  8016c9:	55                   	push   %ebp
  8016ca:	89 e5                	mov    %esp,%ebp
  8016cc:	57                   	push   %edi
  8016cd:	56                   	push   %esi
  8016ce:	53                   	push   %ebx
  8016cf:	83 ec 2c             	sub    $0x2c,%esp
  8016d2:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8016d5:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  8016d8:	8b 45 08             	mov    0x8(%ebp),%eax
  8016db:	e8 36 f2 ff ff       	call   800916 <get_socket>
  if (!sock)
  8016e0:	85 c0                	test   %eax,%eax
  8016e2:	0f 84 28 01 00 00    	je     801810 <lwip_sendto+0x147>
  8016e8:	89 c6                	mov    %eax,%esi
  if (sock->conn->type==NETCONN_TCP) {
  8016ea:	8b 00                	mov    (%eax),%eax
  8016ec:	83 38 10             	cmpl   $0x10,(%eax)
  8016ef:	0f 84 be 00 00 00    	je     8017b3 <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8016f5:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  8016fb:	0f 87 c8 00 00 00    	ja     8017c9 <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801701:	89 f8                	mov    %edi,%eax
  801703:	0b 45 1c             	or     0x1c(%ebp),%eax
  801706:	0f 84 0b 01 00 00    	je     801817 <lwip_sendto+0x14e>
  80170c:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  801710:	0f 85 ca 00 00 00    	jne    8017e0 <lwip_sendto+0x117>
  801716:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  80171a:	0f 85 c0 00 00 00    	jne    8017e0 <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  801720:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801727:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  80172e:	8b 47 04             	mov    0x4(%edi),%eax
  801731:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801734:	83 ec 0c             	sub    $0xc,%esp
  801737:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80173b:	50                   	push   %eax
  80173c:	e8 9a 61 00 00       	call   8078db <ntohs>
    buf.addr         = &remote_addr;
  801741:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801744:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  801747:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80174b:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  80174e:	83 ec 04             	sub    $0x4,%esp
  801751:	0f b7 c3             	movzwl %bx,%eax
  801754:	50                   	push   %eax
  801755:	ff 75 0c             	pushl  0xc(%ebp)
  801758:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80175b:	50                   	push   %eax
  80175c:	e8 f5 0f 00 00       	call   802756 <netbuf_ref>
  801761:	0f be f8             	movsbl %al,%edi
  801764:	83 c4 10             	add    $0x10,%esp
  801767:	85 ff                	test   %edi,%edi
  801769:	0f 84 88 00 00 00    	je     8017f7 <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  80176f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801772:	85 c0                	test   %eax,%eax
  801774:	74 0c                	je     801782 <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  801776:	83 ec 0c             	sub    $0xc,%esp
  801779:	50                   	push   %eax
  80177a:	e8 75 32 00 00       	call   8049f4 <pbuf_free>
  80177f:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801782:	89 fa                	mov    %edi,%edx
  801784:	f7 da                	neg    %edx
  801786:	b8 05 00 00 00       	mov    $0x5,%eax
  80178b:	83 fa 0e             	cmp    $0xe,%edx
  80178e:	77 07                	ja     801797 <lwip_sendto+0xce>
  801790:	8b 04 95 40 18 81 00 	mov    0x811840(,%edx,4),%eax
  801797:	89 46 10             	mov    %eax,0x10(%esi)
  80179a:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
  return (err==ERR_OK?size:-1);
  80179f:	85 ff                	test   %edi,%edi
  8017a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8017a6:	0f 45 d8             	cmovne %eax,%ebx
}
  8017a9:	89 d8                	mov    %ebx,%eax
  8017ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8017ae:	5b                   	pop    %ebx
  8017af:	5e                   	pop    %esi
  8017b0:	5f                   	pop    %edi
  8017b1:	5d                   	pop    %ebp
  8017b2:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  8017b3:	ff 75 14             	pushl  0x14(%ebp)
  8017b6:	53                   	push   %ebx
  8017b7:	ff 75 0c             	pushl  0xc(%ebp)
  8017ba:	ff 75 08             	pushl  0x8(%ebp)
  8017bd:	e8 7c 00 00 00       	call   80183e <lwip_send>
  8017c2:	89 c3                	mov    %eax,%ebx
  8017c4:	83 c4 10             	add    $0x10,%esp
  8017c7:	eb e0                	jmp    8017a9 <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8017c9:	83 ec 04             	sub    $0x4,%esp
  8017cc:	68 10 18 81 00       	push   $0x811810
  8017d1:	68 97 02 00 00       	push   $0x297
  8017d6:	68 81 17 81 00       	push   $0x811781
  8017db:	e8 29 d0 00 00       	call   80e809 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017e0:	83 ec 04             	sub    $0x4,%esp
  8017e3:	68 f2 17 81 00       	push   $0x8117f2
  8017e8:	68 9b 02 00 00       	push   $0x29b
  8017ed:	68 81 17 81 00       	push   $0x811781
  8017f2:	e8 12 d0 00 00       	call   80e809 <_panic>
    err = netconn_send(sock->conn, &buf);
  8017f7:	83 ec 08             	sub    $0x8,%esp
  8017fa:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8017fd:	50                   	push   %eax
  8017fe:	ff 36                	pushl  (%esi)
  801800:	e8 9a 9a 00 00       	call   80b29f <netconn_send>
  801805:	0f be f8             	movsbl %al,%edi
  801808:	83 c4 10             	add    $0x10,%esp
  80180b:	e9 5f ff ff ff       	jmp    80176f <lwip_sendto+0xa6>
    return -1;
  801810:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801815:	eb 92                	jmp    8017a9 <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  801817:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80181e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  801825:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  80182c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  801833:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  801839:	e9 10 ff ff ff       	jmp    80174e <lwip_sendto+0x85>

0080183e <lwip_send>:
{
  80183e:	55                   	push   %ebp
  80183f:	89 e5                	mov    %esp,%ebp
  801841:	57                   	push   %edi
  801842:	56                   	push   %esi
  801843:	53                   	push   %ebx
  801844:	83 ec 0c             	sub    $0xc,%esp
  801847:	8b 7d 08             	mov    0x8(%ebp),%edi
  80184a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  80184d:	89 f8                	mov    %edi,%eax
  80184f:	e8 c2 f0 ff ff       	call   800916 <get_socket>
  if (!sock)
  801854:	85 c0                	test   %eax,%eax
  801856:	74 70                	je     8018c8 <lwip_send+0x8a>
  801858:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  80185a:	8b 00                	mov    (%eax),%eax
  80185c:	83 38 10             	cmpl   $0x10,(%eax)
  80185f:	74 1f                	je     801880 <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801861:	83 ec 08             	sub    $0x8,%esp
  801864:	6a 00                	push   $0x0
  801866:	6a 00                	push   $0x0
  801868:	ff 75 14             	pushl  0x14(%ebp)
  80186b:	53                   	push   %ebx
  80186c:	ff 75 0c             	pushl  0xc(%ebp)
  80186f:	57                   	push   %edi
  801870:	e8 54 fe ff ff       	call   8016c9 <lwip_sendto>
  801875:	83 c4 20             	add    $0x20,%esp
}
  801878:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80187b:	5b                   	pop    %ebx
  80187c:	5e                   	pop    %esi
  80187d:	5f                   	pop    %edi
  80187e:	5d                   	pop    %ebp
  80187f:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801880:	8b 55 14             	mov    0x14(%ebp),%edx
  801883:	c1 ea 03             	shr    $0x3,%edx
  801886:	83 e2 02             	and    $0x2,%edx
  801889:	83 ca 01             	or     $0x1,%edx
  80188c:	0f b6 d2             	movzbl %dl,%edx
  80188f:	52                   	push   %edx
  801890:	53                   	push   %ebx
  801891:	ff 75 0c             	pushl  0xc(%ebp)
  801894:	50                   	push   %eax
  801895:	e8 81 9a 00 00       	call   80b31b <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  80189a:	0f be d0             	movsbl %al,%edx
  80189d:	f7 da                	neg    %edx
  80189f:	83 c4 10             	add    $0x10,%esp
  8018a2:	b9 05 00 00 00       	mov    $0x5,%ecx
  8018a7:	83 fa 0e             	cmp    $0xe,%edx
  8018aa:	77 07                	ja     8018b3 <lwip_send+0x75>
  8018ac:	8b 0c 95 40 18 81 00 	mov    0x811840(,%edx,4),%ecx
  8018b3:	89 4e 10             	mov    %ecx,0x10(%esi)
  8018b6:	89 0d e0 c1 b3 00    	mov    %ecx,0xb3c1e0
  return (err==ERR_OK?size:-1);
  8018bc:	84 c0                	test   %al,%al
  8018be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8018c3:	0f 44 c3             	cmove  %ebx,%eax
  8018c6:	eb b0                	jmp    801878 <lwip_send+0x3a>
    return -1;
  8018c8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8018cd:	eb a9                	jmp    801878 <lwip_send+0x3a>

008018cf <lwip_socket>:
{
  8018cf:	55                   	push   %ebp
  8018d0:	89 e5                	mov    %esp,%ebp
  8018d2:	56                   	push   %esi
  8018d3:	53                   	push   %ebx
  8018d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  8018d7:	83 f8 02             	cmp    $0x2,%eax
  8018da:	74 5c                	je     801938 <lwip_socket+0x69>
  8018dc:	83 f8 03             	cmp    $0x3,%eax
  8018df:	74 16                	je     8018f7 <lwip_socket+0x28>
  8018e1:	83 f8 01             	cmp    $0x1,%eax
  8018e4:	74 79                	je     80195f <lwip_socket+0x90>
    set_errno(EINVAL);
  8018e6:	c7 05 e0 c1 b3 00 16 	movl   $0x16,0xb3c1e0
  8018ed:	00 00 00 
    return -1;
  8018f0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8018f5:	eb 38                	jmp    80192f <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8018f7:	83 ec 04             	sub    $0x4,%esp
  8018fa:	68 04 0b 80 00       	push   $0x800b04
  8018ff:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801903:	50                   	push   %eax
  801904:	6a 40                	push   $0x40
  801906:	e8 94 94 00 00       	call   80ad9f <netconn_new_with_proto_and_callback>
  80190b:	89 c6                	mov    %eax,%esi
    break;
  80190d:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  801910:	85 f6                	test   %esi,%esi
  801912:	74 63                	je     801977 <lwip_socket+0xa8>
  i = alloc_socket(conn);
  801914:	89 f0                	mov    %esi,%eax
  801916:	e8 93 f3 ff ff       	call   800cae <alloc_socket>
  80191b:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  80191d:	83 f8 ff             	cmp    $0xffffffff,%eax
  801920:	74 66                	je     801988 <lwip_socket+0xb9>
  conn->socket = i;
  801922:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  801925:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  80192c:	00 00 00 
}
  80192f:	89 d8                	mov    %ebx,%eax
  801931:	8d 65 f8             	lea    -0x8(%ebp),%esp
  801934:	5b                   	pop    %ebx
  801935:	5e                   	pop    %esi
  801936:	5d                   	pop    %ebp
  801937:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  801938:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  80193f:	0f 94 c0             	sete   %al
  801942:	0f b6 c0             	movzbl %al,%eax
  801945:	83 c0 20             	add    $0x20,%eax
  801948:	83 ec 04             	sub    $0x4,%esp
  80194b:	68 04 0b 80 00       	push   $0x800b04
  801950:	6a 00                	push   $0x0
  801952:	50                   	push   %eax
  801953:	e8 47 94 00 00       	call   80ad9f <netconn_new_with_proto_and_callback>
  801958:	89 c6                	mov    %eax,%esi
    break;
  80195a:	83 c4 10             	add    $0x10,%esp
  80195d:	eb b1                	jmp    801910 <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  80195f:	83 ec 04             	sub    $0x4,%esp
  801962:	68 04 0b 80 00       	push   $0x800b04
  801967:	6a 00                	push   $0x0
  801969:	6a 10                	push   $0x10
  80196b:	e8 2f 94 00 00       	call   80ad9f <netconn_new_with_proto_and_callback>
  801970:	89 c6                	mov    %eax,%esi
    break;
  801972:	83 c4 10             	add    $0x10,%esp
  801975:	eb 99                	jmp    801910 <lwip_socket+0x41>
    set_errno(ENOBUFS);
  801977:	c7 05 e0 c1 b3 00 69 	movl   $0x69,0xb3c1e0
  80197e:	00 00 00 
    return -1;
  801981:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  801986:	eb a7                	jmp    80192f <lwip_socket+0x60>
    netconn_delete(conn);
  801988:	83 ec 0c             	sub    $0xc,%esp
  80198b:	56                   	push   %esi
  80198c:	e8 e9 94 00 00       	call   80ae7a <netconn_delete>
    set_errno(ENFILE);
  801991:	c7 05 e0 c1 b3 00 17 	movl   $0x17,0xb3c1e0
  801998:	00 00 00 
    return -1;
  80199b:	83 c4 10             	add    $0x10,%esp
  80199e:	eb 8f                	jmp    80192f <lwip_socket+0x60>

008019a0 <lwip_write>:
{
  8019a0:	55                   	push   %ebp
  8019a1:	89 e5                	mov    %esp,%ebp
  8019a3:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  8019a6:	6a 00                	push   $0x0
  8019a8:	ff 75 10             	pushl  0x10(%ebp)
  8019ab:	ff 75 0c             	pushl  0xc(%ebp)
  8019ae:	ff 75 08             	pushl  0x8(%ebp)
  8019b1:	e8 88 fe ff ff       	call   80183e <lwip_send>
}
  8019b6:	c9                   	leave  
  8019b7:	c3                   	ret    

008019b8 <lwip_select>:
{
  8019b8:	55                   	push   %ebp
  8019b9:	89 e5                	mov    %esp,%ebp
  8019bb:	57                   	push   %edi
  8019bc:	56                   	push   %esi
  8019bd:	53                   	push   %ebx
  8019be:	83 ec 58             	sub    $0x58,%esp
  8019c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8019c4:	8b 75 10             	mov    0x10(%ebp),%esi
  8019c7:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  8019ca:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8019d1:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  8019d4:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8019d7:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8019da:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  8019e1:	ff 35 40 60 81 00    	pushl  0x816040
  8019e7:	e8 e6 38 00 00       	call   8052d2 <sys_sem_wait>
  if (readset)
  8019ec:	83 c4 10             	add    $0x10,%esp
  8019ef:	85 db                	test   %ebx,%ebx
  8019f1:	0f 84 0b 01 00 00    	je     801b02 <lwip_select+0x14a>
    lreadset = *readset;
  8019f7:	8b 03                	mov    (%ebx),%eax
  8019f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  8019fc:	85 f6                	test   %esi,%esi
  8019fe:	0f 84 16 01 00 00    	je     801b1a <lwip_select+0x162>
    lwriteset = *writeset;
  801a04:	8b 06                	mov    (%esi),%eax
  801a06:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  801a09:	85 ff                	test   %edi,%edi
  801a0b:	0f 84 21 01 00 00    	je     801b32 <lwip_select+0x17a>
    lexceptset = *exceptset;
  801a11:	8b 07                	mov    (%edi),%eax
  801a13:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a16:	83 ec 0c             	sub    $0xc,%esp
  801a19:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a1c:	50                   	push   %eax
  801a1d:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a20:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801a23:	8b 45 08             	mov    0x8(%ebp),%eax
  801a26:	e8 29 ef ff ff       	call   800954 <lwip_selscan>
  801a2b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  801a2e:	83 c4 10             	add    $0x10,%esp
  801a31:	85 c0                	test   %eax,%eax
  801a33:	0f 85 a0 02 00 00    	jne    801cd9 <lwip_select+0x321>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801a39:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801a3d:	0f 84 ac 02 00 00    	je     801cef <lwip_select+0x337>
  801a43:	8b 45 18             	mov    0x18(%ebp),%eax
  801a46:	83 38 00             	cmpl   $0x0,(%eax)
  801a49:	75 0e                	jne    801a59 <lwip_select+0xa1>
  801a4b:	8b 40 04             	mov    0x4(%eax),%eax
  801a4e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a51:	85 c0                	test   %eax,%eax
  801a53:	0f 84 f1 00 00 00    	je     801b4a <lwip_select+0x192>
    select_cb.sem = sys_sem_new(0);
  801a59:	83 ec 0c             	sub    $0xc,%esp
  801a5c:	6a 00                	push   $0x0
  801a5e:	e8 44 85 00 00       	call   809fa7 <sys_sem_new>
  801a63:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801a66:	a1 48 60 81 00       	mov    0x816048,%eax
  801a6b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801a6e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801a71:	a3 48 60 81 00       	mov    %eax,0x816048
    sys_sem_signal(selectsem);
  801a76:	83 c4 04             	add    $0x4,%esp
  801a79:	ff 35 40 60 81 00    	pushl  0x816040
  801a7f:	e8 e0 87 00 00       	call   80a264 <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801a84:	8b 45 18             	mov    0x18(%ebp),%eax
  801a87:	8b 40 04             	mov    0x4(%eax),%eax
  801a8a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801a8d:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801a93:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801a98:	89 c8                	mov    %ecx,%eax
  801a9a:	f7 ea                	imul   %edx
  801a9c:	c1 fa 06             	sar    $0x6,%edx
  801a9f:	c1 f9 1f             	sar    $0x1f,%ecx
  801aa2:	29 ca                	sub    %ecx,%edx
  801aa4:	8b 45 18             	mov    0x18(%ebp),%eax
  801aa7:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801aad:	83 c4 10             	add    $0x10,%esp
  801ab0:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  801ab2:	ba 01 00 00 00       	mov    $0x1,%edx
  801ab7:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801aba:	83 ec 08             	sub    $0x8,%esp
  801abd:	50                   	push   %eax
  801abe:	ff 75 d8             	pushl  -0x28(%ebp)
  801ac1:	e8 dc 39 00 00       	call   8054a2 <sys_sem_wait_timeout>
  801ac6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  801ac9:	83 c4 04             	add    $0x4,%esp
  801acc:	ff 35 40 60 81 00    	pushl  0x816040
  801ad2:	e8 fb 37 00 00       	call   8052d2 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801ad7:	a1 48 60 81 00       	mov    0x816048,%eax
  801adc:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801adf:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801ae2:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  801ae4:	39 d0                	cmp    %edx,%eax
  801ae6:	0f 84 ba 00 00 00    	je     801ba6 <lwip_select+0x1ee>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801aec:	85 c0                	test   %eax,%eax
  801aee:	0f 84 c1 00 00 00    	je     801bb5 <lwip_select+0x1fd>
        if (p_selcb->next == &select_cb) {
  801af4:	8b 10                	mov    (%eax),%edx
  801af6:	39 ca                	cmp    %ecx,%edx
  801af8:	0f 84 b2 00 00 00    	je     801bb0 <lwip_select+0x1f8>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801afe:	89 d0                	mov    %edx,%eax
  801b00:	eb ea                	jmp    801aec <lwip_select+0x134>
    FD_ZERO(&lreadset);
  801b02:	83 ec 04             	sub    $0x4,%esp
  801b05:	6a 04                	push   $0x4
  801b07:	6a 00                	push   $0x0
  801b09:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801b0c:	50                   	push   %eax
  801b0d:	e8 92 d6 00 00       	call   80f1a4 <memset>
  801b12:	83 c4 10             	add    $0x10,%esp
  801b15:	e9 e2 fe ff ff       	jmp    8019fc <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  801b1a:	83 ec 04             	sub    $0x4,%esp
  801b1d:	6a 04                	push   $0x4
  801b1f:	6a 00                	push   $0x0
  801b21:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b24:	50                   	push   %eax
  801b25:	e8 7a d6 00 00       	call   80f1a4 <memset>
  801b2a:	83 c4 10             	add    $0x10,%esp
  801b2d:	e9 d7 fe ff ff       	jmp    801a09 <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  801b32:	83 ec 04             	sub    $0x4,%esp
  801b35:	6a 04                	push   $0x4
  801b37:	6a 00                	push   $0x0
  801b39:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b3c:	50                   	push   %eax
  801b3d:	e8 62 d6 00 00       	call   80f1a4 <memset>
  801b42:	83 c4 10             	add    $0x10,%esp
  801b45:	e9 cc fe ff ff       	jmp    801a16 <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  801b4a:	83 ec 0c             	sub    $0xc,%esp
  801b4d:	ff 35 40 60 81 00    	pushl  0x816040
  801b53:	e8 0c 87 00 00       	call   80a264 <sys_sem_signal>
      if (readset)
  801b58:	83 c4 10             	add    $0x10,%esp
  801b5b:	85 db                	test   %ebx,%ebx
  801b5d:	74 10                	je     801b6f <lwip_select+0x1b7>
        FD_ZERO(readset);
  801b5f:	83 ec 04             	sub    $0x4,%esp
  801b62:	6a 04                	push   $0x4
  801b64:	6a 00                	push   $0x0
  801b66:	53                   	push   %ebx
  801b67:	e8 38 d6 00 00       	call   80f1a4 <memset>
  801b6c:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801b6f:	85 f6                	test   %esi,%esi
  801b71:	74 10                	je     801b83 <lwip_select+0x1cb>
        FD_ZERO(writeset);
  801b73:	83 ec 04             	sub    $0x4,%esp
  801b76:	6a 04                	push   $0x4
  801b78:	6a 00                	push   $0x0
  801b7a:	56                   	push   %esi
  801b7b:	e8 24 d6 00 00       	call   80f1a4 <memset>
  801b80:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801b83:	85 ff                	test   %edi,%edi
  801b85:	74 10                	je     801b97 <lwip_select+0x1df>
        FD_ZERO(exceptset);
  801b87:	83 ec 04             	sub    $0x4,%esp
  801b8a:	6a 04                	push   $0x4
  801b8c:	6a 00                	push   $0x0
  801b8e:	57                   	push   %edi
  801b8f:	e8 10 d6 00 00       	call   80f1a4 <memset>
  801b94:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801b97:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801b9e:	00 00 00 
      return 0;
  801ba1:	e9 98 00 00 00       	jmp    801c3e <lwip_select+0x286>
      select_cb_list = select_cb.next;
  801ba6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801ba9:	a3 48 60 81 00       	mov    %eax,0x816048
  801bae:	eb 05                	jmp    801bb5 <lwip_select+0x1fd>
          p_selcb->next = select_cb.next;
  801bb0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801bb3:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801bb5:	83 ec 0c             	sub    $0xc,%esp
  801bb8:	ff 35 40 60 81 00    	pushl  0x816040
  801bbe:	e8 a1 86 00 00       	call   80a264 <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801bc3:	83 c4 04             	add    $0x4,%esp
  801bc6:	ff 75 d8             	pushl  -0x28(%ebp)
  801bc9:	e8 5a 84 00 00       	call   80a028 <sys_sem_free>
    if (i == 0)  {
  801bce:	83 c4 10             	add    $0x10,%esp
  801bd1:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801bd5:	74 72                	je     801c49 <lwip_select+0x291>
    if (readset)
  801bd7:	85 db                	test   %ebx,%ebx
  801bd9:	0f 84 b2 00 00 00    	je     801c91 <lwip_select+0x2d9>
      lreadset = *readset;
  801bdf:	8b 03                	mov    (%ebx),%eax
  801be1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801be4:	85 f6                	test   %esi,%esi
  801be6:	0f 84 bd 00 00 00    	je     801ca9 <lwip_select+0x2f1>
      lwriteset = *writeset;
  801bec:	8b 06                	mov    (%esi),%eax
  801bee:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801bf1:	85 ff                	test   %edi,%edi
  801bf3:	0f 84 c8 00 00 00    	je     801cc1 <lwip_select+0x309>
      lexceptset = *exceptset;
  801bf9:	8b 07                	mov    (%edi),%eax
  801bfb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801bfe:	83 ec 0c             	sub    $0xc,%esp
  801c01:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801c04:	50                   	push   %eax
  801c05:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801c08:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801c0b:	8b 45 08             	mov    0x8(%ebp),%eax
  801c0e:	e8 41 ed ff ff       	call   800954 <lwip_selscan>
  801c13:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801c16:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801c19:	85 db                	test   %ebx,%ebx
  801c1b:	74 05                	je     801c22 <lwip_select+0x26a>
    *readset = lreadset;
  801c1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801c20:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801c22:	85 f6                	test   %esi,%esi
  801c24:	74 05                	je     801c2b <lwip_select+0x273>
    *writeset = lwriteset;
  801c26:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801c29:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801c2b:	85 ff                	test   %edi,%edi
  801c2d:	74 05                	je     801c34 <lwip_select+0x27c>
    *exceptset = lexceptset;
  801c2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801c32:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801c34:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801c3b:	00 00 00 
}
  801c3e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801c41:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801c44:	5b                   	pop    %ebx
  801c45:	5e                   	pop    %esi
  801c46:	5f                   	pop    %edi
  801c47:	5d                   	pop    %ebp
  801c48:	c3                   	ret    
      if (readset)
  801c49:	85 db                	test   %ebx,%ebx
  801c4b:	74 10                	je     801c5d <lwip_select+0x2a5>
        FD_ZERO(readset);
  801c4d:	83 ec 04             	sub    $0x4,%esp
  801c50:	6a 04                	push   $0x4
  801c52:	6a 00                	push   $0x0
  801c54:	53                   	push   %ebx
  801c55:	e8 4a d5 00 00       	call   80f1a4 <memset>
  801c5a:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801c5d:	85 f6                	test   %esi,%esi
  801c5f:	74 10                	je     801c71 <lwip_select+0x2b9>
        FD_ZERO(writeset);
  801c61:	83 ec 04             	sub    $0x4,%esp
  801c64:	6a 04                	push   $0x4
  801c66:	6a 00                	push   $0x0
  801c68:	56                   	push   %esi
  801c69:	e8 36 d5 00 00       	call   80f1a4 <memset>
  801c6e:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801c71:	85 ff                	test   %edi,%edi
  801c73:	74 10                	je     801c85 <lwip_select+0x2cd>
        FD_ZERO(exceptset);
  801c75:	83 ec 04             	sub    $0x4,%esp
  801c78:	6a 04                	push   $0x4
  801c7a:	6a 00                	push   $0x0
  801c7c:	57                   	push   %edi
  801c7d:	e8 22 d5 00 00       	call   80f1a4 <memset>
  801c82:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801c85:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  801c8c:	00 00 00 
      return 0;
  801c8f:	eb ad                	jmp    801c3e <lwip_select+0x286>
      FD_ZERO(&lreadset);
  801c91:	83 ec 04             	sub    $0x4,%esp
  801c94:	6a 04                	push   $0x4
  801c96:	6a 00                	push   $0x0
  801c98:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801c9b:	50                   	push   %eax
  801c9c:	e8 03 d5 00 00       	call   80f1a4 <memset>
  801ca1:	83 c4 10             	add    $0x10,%esp
  801ca4:	e9 3b ff ff ff       	jmp    801be4 <lwip_select+0x22c>
      FD_ZERO(&lwriteset);
  801ca9:	83 ec 04             	sub    $0x4,%esp
  801cac:	6a 04                	push   $0x4
  801cae:	6a 00                	push   $0x0
  801cb0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801cb3:	50                   	push   %eax
  801cb4:	e8 eb d4 00 00       	call   80f1a4 <memset>
  801cb9:	83 c4 10             	add    $0x10,%esp
  801cbc:	e9 30 ff ff ff       	jmp    801bf1 <lwip_select+0x239>
      FD_ZERO(&lexceptset);
  801cc1:	83 ec 04             	sub    $0x4,%esp
  801cc4:	6a 04                	push   $0x4
  801cc6:	6a 00                	push   $0x0
  801cc8:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801ccb:	50                   	push   %eax
  801ccc:	e8 d3 d4 00 00       	call   80f1a4 <memset>
  801cd1:	83 c4 10             	add    $0x10,%esp
  801cd4:	e9 25 ff ff ff       	jmp    801bfe <lwip_select+0x246>
    sys_sem_signal(selectsem);
  801cd9:	83 ec 0c             	sub    $0xc,%esp
  801cdc:	ff 35 40 60 81 00    	pushl  0x816040
  801ce2:	e8 7d 85 00 00       	call   80a264 <sys_sem_signal>
  801ce7:	83 c4 10             	add    $0x10,%esp
  801cea:	e9 2a ff ff ff       	jmp    801c19 <lwip_select+0x261>
    select_cb.sem = sys_sem_new(0);
  801cef:	83 ec 0c             	sub    $0xc,%esp
  801cf2:	6a 00                	push   $0x0
  801cf4:	e8 ae 82 00 00       	call   809fa7 <sys_sem_new>
  801cf9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801cfc:	a1 48 60 81 00       	mov    0x816048,%eax
  801d01:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801d04:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801d07:	a3 48 60 81 00       	mov    %eax,0x816048
    sys_sem_signal(selectsem);
  801d0c:	83 c4 04             	add    $0x4,%esp
  801d0f:	ff 35 40 60 81 00    	pushl  0x816040
  801d15:	e8 4a 85 00 00       	call   80a264 <sys_sem_signal>
  801d1a:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801d1d:	b8 00 00 00 00       	mov    $0x0,%eax
  801d22:	e9 93 fd ff ff       	jmp    801aba <lwip_select+0x102>

00801d27 <lwip_shutdown>:
{
  801d27:	55                   	push   %ebp
  801d28:	89 e5                	mov    %esp,%ebp
  801d2a:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801d2d:	ff 75 08             	pushl  0x8(%ebp)
  801d30:	e8 4d f5 ff ff       	call   801282 <lwip_close>
}
  801d35:	c9                   	leave  
  801d36:	c3                   	ret    

00801d37 <lwip_getpeername>:
{
  801d37:	55                   	push   %ebp
  801d38:	89 e5                	mov    %esp,%ebp
  801d3a:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801d3d:	6a 00                	push   $0x0
  801d3f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801d42:	8b 55 0c             	mov    0xc(%ebp),%edx
  801d45:	8b 45 08             	mov    0x8(%ebp),%eax
  801d48:	e8 0c ed ff ff       	call   800a59 <lwip_getaddrname>
}
  801d4d:	c9                   	leave  
  801d4e:	c3                   	ret    

00801d4f <lwip_getsockname>:
{
  801d4f:	55                   	push   %ebp
  801d50:	89 e5                	mov    %esp,%ebp
  801d52:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801d55:	6a 01                	push   $0x1
  801d57:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801d5a:	8b 55 0c             	mov    0xc(%ebp),%edx
  801d5d:	8b 45 08             	mov    0x8(%ebp),%eax
  801d60:	e8 f4 ec ff ff       	call   800a59 <lwip_getaddrname>
}
  801d65:	c9                   	leave  
  801d66:	c3                   	ret    

00801d67 <lwip_getsockopt>:
{
  801d67:	55                   	push   %ebp
  801d68:	89 e5                	mov    %esp,%ebp
  801d6a:	57                   	push   %edi
  801d6b:	56                   	push   %esi
  801d6c:	53                   	push   %ebx
  801d6d:	83 ec 2c             	sub    $0x2c,%esp
  801d70:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801d73:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801d76:	8b 45 08             	mov    0x8(%ebp),%eax
  801d79:	e8 98 eb ff ff       	call   800916 <get_socket>
  if (!sock)
  801d7e:	85 c0                	test   %eax,%eax
  801d80:	0f 84 af 01 00 00    	je     801f35 <lwip_getsockopt+0x1ce>
  801d86:	89 c6                	mov    %eax,%esi
  if ((NULL == optval) || (NULL == optlen)) {
  801d88:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801d8c:	74 39                	je     801dc7 <lwip_getsockopt+0x60>
  801d8e:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801d92:	74 33                	je     801dc7 <lwip_getsockopt+0x60>
  switch (level) {
  801d94:	83 fb 06             	cmp    $0x6,%ebx
  801d97:	0f 84 36 01 00 00    	je     801ed3 <lwip_getsockopt+0x16c>
  801d9d:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801da3:	74 3d                	je     801de2 <lwip_getsockopt+0x7b>
      err = ENOPROTOOPT;
  801da5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801daa:	85 db                	test   %ebx,%ebx
  801dac:	0f 84 a9 00 00 00    	je     801e5b <lwip_getsockopt+0xf4>
    sock_set_errno(sock, err);
  801db2:	0f be c0             	movsbl %al,%eax
  801db5:	89 46 10             	mov    %eax,0x10(%esi)
  801db8:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
    return -1;
  801dbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801dc2:	e9 04 01 00 00       	jmp    801ecb <lwip_getsockopt+0x164>
    sock_set_errno(sock, EFAULT);
  801dc7:	c7 46 10 0e 00 00 00 	movl   $0xe,0x10(%esi)
  801dce:	c7 05 e0 c1 b3 00 0e 	movl   $0xe,0xb3c1e0
  801dd5:	00 00 00 
    return -1;
  801dd8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ddd:	e9 e9 00 00 00       	jmp    801ecb <lwip_getsockopt+0x164>
  801de2:	83 ff 20             	cmp    $0x20,%edi
  801de5:	74 62                	je     801e49 <lwip_getsockopt+0xe2>
  801de7:	7e 4d                	jle    801e36 <lwip_getsockopt+0xcf>
  801de9:	81 ff 07 10 00 00    	cmp    $0x1007,%edi
  801def:	0f 8c 04 01 00 00    	jl     801ef9 <lwip_getsockopt+0x192>
  801df5:	81 ff 08 10 00 00    	cmp    $0x1008,%edi
  801dfb:	7e 4c                	jle    801e49 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801dfd:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e02:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  801e08:	75 a8                	jne    801db2 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801e0a:	8b 45 18             	mov    0x18(%ebp),%eax
  801e0d:	83 38 04             	cmpl   $0x4,(%eax)
  801e10:	19 c0                	sbb    %eax,%eax
  801e12:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801e15:	8b 16                	mov    (%esi),%edx
  801e17:	83 3a 20             	cmpl   $0x20,(%edx)
  801e1a:	0f 85 e3 00 00 00    	jne    801f03 <lwip_getsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e20:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801e23:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e27:	0f 85 e0 00 00 00    	jne    801f0d <lwip_getsockopt+0x1a6>
  if (err != ERR_OK) {
  801e2d:	84 c0                	test   %al,%al
  801e2f:	74 42                	je     801e73 <lwip_getsockopt+0x10c>
  801e31:	e9 7c ff ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
  801e36:	83 ff 02             	cmp    $0x2,%edi
  801e39:	74 0e                	je     801e49 <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801e3b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e40:	83 ff 08             	cmp    $0x8,%edi
  801e43:	0f 85 69 ff ff ff    	jne    801db2 <lwip_getsockopt+0x4b>
      if (*optlen < sizeof(int)) {
  801e49:	8b 45 18             	mov    0x18(%ebp),%eax
  801e4c:	83 38 03             	cmpl   $0x3,(%eax)
  801e4f:	77 22                	ja     801e73 <lwip_getsockopt+0x10c>
        err = EINVAL;
  801e51:	b8 16 00 00 00       	mov    $0x16,%eax
  801e56:	e9 57 ff ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
  801e5b:	8d 47 ff             	lea    -0x1(%edi),%eax
  801e5e:	83 f8 01             	cmp    $0x1,%eax
  801e61:	0f 87 b0 00 00 00    	ja     801f17 <lwip_getsockopt+0x1b0>
      if (*optlen < sizeof(int)) {
  801e67:	8b 45 18             	mov    0x18(%ebp),%eax
  801e6a:	83 38 03             	cmpl   $0x3,(%eax)
  801e6d:	0f 86 ae 00 00 00    	jbe    801f21 <lwip_getsockopt+0x1ba>
  data.sock = sock;
  801e73:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801e76:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801e79:	89 7d d8             	mov    %edi,-0x28(%ebp)
  data.optval = optval;
  801e7c:	8b 45 14             	mov    0x14(%ebp),%eax
  801e7f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801e82:	8b 45 18             	mov    0x18(%ebp),%eax
  801e85:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801e88:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801e8c:	83 ec 04             	sub    $0x4,%esp
  801e8f:	6a 01                	push   $0x1
  801e91:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801e94:	50                   	push   %eax
  801e95:	68 56 0d 80 00       	push   $0x800d56
  801e9a:	e8 dc 05 00 00       	call   80247b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801e9f:	83 c4 08             	add    $0x8,%esp
  801ea2:	6a 00                	push   $0x0
  801ea4:	8b 06                	mov    (%esi),%eax
  801ea6:	ff 70 10             	pushl  0x10(%eax)
  801ea9:	e8 26 84 00 00       	call   80a2d4 <sys_arch_sem_wait>
  err = data.err;
  801eae:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801eb2:	0f be d0             	movsbl %al,%edx
  801eb5:	89 56 10             	mov    %edx,0x10(%esi)
  801eb8:	89 15 e0 c1 b3 00    	mov    %edx,0xb3c1e0
  return err ? -1 : 0;
  801ebe:	83 c4 10             	add    $0x10,%esp
  801ec1:	84 c0                	test   %al,%al
  801ec3:	0f 95 c0             	setne  %al
  801ec6:	0f b6 c0             	movzbl %al,%eax
  801ec9:	f7 d8                	neg    %eax
}
  801ecb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ece:	5b                   	pop    %ebx
  801ecf:	5e                   	pop    %esi
  801ed0:	5f                   	pop    %edi
  801ed1:	5d                   	pop    %ebp
  801ed2:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801ed3:	8b 45 18             	mov    0x18(%ebp),%eax
  801ed6:	83 38 03             	cmpl   $0x3,(%eax)
  801ed9:	76 50                	jbe    801f2b <lwip_getsockopt+0x1c4>
    if (sock->conn->type != NETCONN_TCP)
  801edb:	8b 16                	mov    (%esi),%edx
      return 0;
  801edd:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801ee2:	83 3a 10             	cmpl   $0x10,(%edx)
  801ee5:	75 e4                	jne    801ecb <lwip_getsockopt+0x164>
  801ee7:	8d 47 ff             	lea    -0x1(%edi),%eax
  801eea:	83 f8 01             	cmp    $0x1,%eax
  801eed:	76 84                	jbe    801e73 <lwip_getsockopt+0x10c>
      err = ENOPROTOOPT;
  801eef:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801ef4:	e9 b9 fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801ef9:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801efe:	e9 af fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
        err = EAFNOSUPPORT;
  801f03:	b8 61 00 00 00       	mov    $0x61,%eax
  801f08:	e9 a5 fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
  801f0d:	b8 61 00 00 00       	mov    $0x61,%eax
  801f12:	e9 9b fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801f17:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f1c:	e9 91 fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801f21:	b8 16 00 00 00       	mov    $0x16,%eax
  801f26:	e9 87 fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
      err = EINVAL;
  801f2b:	b8 16 00 00 00       	mov    $0x16,%eax
  801f30:	e9 7d fe ff ff       	jmp    801db2 <lwip_getsockopt+0x4b>
    return -1;
  801f35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f3a:	eb 8f                	jmp    801ecb <lwip_getsockopt+0x164>

00801f3c <lwip_setsockopt>:
{
  801f3c:	55                   	push   %ebp
  801f3d:	89 e5                	mov    %esp,%ebp
  801f3f:	57                   	push   %edi
  801f40:	56                   	push   %esi
  801f41:	53                   	push   %ebx
  801f42:	83 ec 2c             	sub    $0x2c,%esp
  801f45:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f48:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801f4b:	8b 45 08             	mov    0x8(%ebp),%eax
  801f4e:	e8 c3 e9 ff ff       	call   800916 <get_socket>
  if (!sock)
  801f53:	85 c0                	test   %eax,%eax
  801f55:	0f 84 69 01 00 00    	je     8020c4 <lwip_setsockopt+0x188>
  801f5b:	89 c6                	mov    %eax,%esi
  if (NULL == optval) {
  801f5d:	85 ff                	test   %edi,%edi
  801f5f:	74 2c                	je     801f8d <lwip_setsockopt+0x51>
  switch (level) {
  801f61:	83 fb 06             	cmp    $0x6,%ebx
  801f64:	0f 84 01 01 00 00    	je     80206b <lwip_setsockopt+0x12f>
  801f6a:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801f70:	74 36                	je     801fa8 <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801f72:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801f77:	85 db                	test   %ebx,%ebx
  801f79:	74 7b                	je     801ff6 <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801f7b:	89 46 10             	mov    %eax,0x10(%esi)
  801f7e:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
    return -1;
  801f83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f88:	e9 d6 00 00 00       	jmp    802063 <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801f8d:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801f94:	c7 05 e0 c1 b3 00 0e 	movl   $0xe,0xb3c1e0
  801f9b:	00 00 00 
    return -1;
  801f9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fa3:	e9 bb 00 00 00       	jmp    802063 <lwip_setsockopt+0x127>
  801fa8:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801fac:	74 14                	je     801fc2 <lwip_setsockopt+0x86>
  801fae:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801fb5:	74 18                	je     801fcf <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801fb7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fbc:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801fc0:	75 b9                	jne    801f7b <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801fc2:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801fc6:	77 47                	ja     80200f <lwip_setsockopt+0xd3>
        err = EINVAL;
  801fc8:	b8 16 00 00 00       	mov    $0x16,%eax
  801fcd:	eb ac                	jmp    801f7b <lwip_setsockopt+0x3f>
        err = EINVAL;
  801fcf:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801fd3:	19 c0                	sbb    %eax,%eax
  801fd5:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801fd8:	8b 16                	mov    (%esi),%edx
  801fda:	83 3a 20             	cmpl   $0x20,(%edx)
  801fdd:	0f 85 af 00 00 00    	jne    802092 <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801fe3:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801fe6:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801fea:	0f 85 ac 00 00 00    	jne    80209c <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801ff0:	85 c0                	test   %eax,%eax
  801ff2:	74 1b                	je     80200f <lwip_setsockopt+0xd3>
  801ff4:	eb 85                	jmp    801f7b <lwip_setsockopt+0x3f>
  801ff6:	8b 45 10             	mov    0x10(%ebp),%eax
  801ff9:	83 e8 01             	sub    $0x1,%eax
  801ffc:	83 f8 01             	cmp    $0x1,%eax
  801fff:	0f 87 a1 00 00 00    	ja     8020a6 <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  802005:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  802009:	0f 86 a1 00 00 00    	jbe    8020b0 <lwip_setsockopt+0x174>
  data.sock = sock;
  80200f:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  802012:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  802015:	8b 45 10             	mov    0x10(%ebp),%eax
  802018:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  80201b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  80201e:	8d 45 18             	lea    0x18(%ebp),%eax
  802021:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  802024:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  802028:	83 ec 04             	sub    $0x4,%esp
  80202b:	6a 01                	push   $0x1
  80202d:	8d 45 cc             	lea    -0x34(%ebp),%eax
  802030:	50                   	push   %eax
  802031:	68 e5 0e 80 00       	push   $0x800ee5
  802036:	e8 40 04 00 00       	call   80247b <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80203b:	83 c4 08             	add    $0x8,%esp
  80203e:	6a 00                	push   $0x0
  802040:	8b 06                	mov    (%esi),%eax
  802042:	ff 70 10             	pushl  0x10(%eax)
  802045:	e8 8a 82 00 00       	call   80a2d4 <sys_arch_sem_wait>
  err = data.err;
  80204a:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  80204e:	89 46 10             	mov    %eax,0x10(%esi)
  802051:	a3 e0 c1 b3 00       	mov    %eax,0xb3c1e0
  return err ? -1 : 0;
  802056:	83 c4 10             	add    $0x10,%esp
  802059:	85 c0                	test   %eax,%eax
  80205b:	0f 95 c0             	setne  %al
  80205e:	0f b6 c0             	movzbl %al,%eax
  802061:	f7 d8                	neg    %eax
}
  802063:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802066:	5b                   	pop    %ebx
  802067:	5e                   	pop    %esi
  802068:	5f                   	pop    %edi
  802069:	5d                   	pop    %ebp
  80206a:	c3                   	ret    
    if (optlen < sizeof(int)) {
  80206b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80206f:	76 49                	jbe    8020ba <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  802071:	8b 10                	mov    (%eax),%edx
      return 0;
  802073:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  802078:	83 3a 10             	cmpl   $0x10,(%edx)
  80207b:	75 e6                	jne    802063 <lwip_setsockopt+0x127>
  80207d:	8b 45 10             	mov    0x10(%ebp),%eax
  802080:	83 e8 01             	sub    $0x1,%eax
  802083:	83 f8 01             	cmp    $0x1,%eax
  802086:	76 87                	jbe    80200f <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  802088:	b8 5c 00 00 00       	mov    $0x5c,%eax
  80208d:	e9 e9 fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
        err = EAFNOSUPPORT;
  802092:	b8 61 00 00 00       	mov    $0x61,%eax
  802097:	e9 df fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
  80209c:	b8 61 00 00 00       	mov    $0x61,%eax
  8020a1:	e9 d5 fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  8020a6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8020ab:	e9 cb fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
        err = EINVAL;
  8020b0:	b8 16 00 00 00       	mov    $0x16,%eax
  8020b5:	e9 c1 fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
      err = EINVAL;
  8020ba:	b8 16 00 00 00       	mov    $0x16,%eax
  8020bf:	e9 b7 fe ff ff       	jmp    801f7b <lwip_setsockopt+0x3f>
    return -1;
  8020c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020c9:	eb 98                	jmp    802063 <lwip_setsockopt+0x127>

008020cb <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8020cb:	55                   	push   %ebp
  8020cc:	89 e5                	mov    %esp,%ebp
  8020ce:	56                   	push   %esi
  8020cf:	53                   	push   %ebx
  8020d0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8020d3:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  8020d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8020d9:	e8 38 e8 ff ff       	call   800916 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  8020de:	85 c0                	test   %eax,%eax
  8020e0:	0f 84 b4 00 00 00    	je     80219a <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  8020e6:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  8020ec:	74 5d                	je     80214b <lwip_ioctl+0x80>
  8020ee:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  8020f4:	0f 85 88 00 00 00    	jne    802182 <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  8020fa:	85 f6                	test   %esi,%esi
  8020fc:	74 35                	je     802133 <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  8020fe:	8b 10                	mov    (%eax),%edx
  802100:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  802104:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  802107:	8b 48 04             	mov    0x4(%eax),%ecx
  80210a:	85 c9                	test   %ecx,%ecx
  80210c:	74 0d                	je     80211b <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  80210e:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  802110:	66 2b 50 08          	sub    0x8(%eax),%dx
  802114:	66 03 51 08          	add    0x8(%ecx),%dx
  802118:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  80211b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802122:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  802129:	00 00 00 
    return 0;
  80212c:	b8 00 00 00 00       	mov    $0x0,%eax
  802131:	eb 4b                	jmp    80217e <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  802133:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  80213a:	c7 05 e0 c1 b3 00 16 	movl   $0x16,0xb3c1e0
  802141:	00 00 00 
      return -1;
  802144:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802149:	eb 33                	jmp    80217e <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  80214b:	85 f6                	test   %esi,%esi
  80214d:	74 0e                	je     80215d <lwip_ioctl+0x92>
  80214f:	83 3e 00             	cmpl   $0x0,(%esi)
  802152:	74 09                	je     80215d <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  802154:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  802158:	80 ce 08             	or     $0x8,%dh
  80215b:	eb 07                	jmp    802164 <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  80215d:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  802161:	80 e6 f7             	and    $0xf7,%dh
  802164:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  802168:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80216f:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  802176:	00 00 00 
    return 0;
  802179:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  80217e:	5b                   	pop    %ebx
  80217f:	5e                   	pop    %esi
  802180:	5d                   	pop    %ebp
  802181:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802182:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  802189:	c7 05 e0 c1 b3 00 26 	movl   $0x26,0xb3c1e0
  802190:	00 00 00 
    return -1;
  802193:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802198:	eb e4                	jmp    80217e <lwip_ioctl+0xb3>
    return -1;
  80219a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80219f:	eb dd                	jmp    80217e <lwip_ioctl+0xb3>

008021a1 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8021a1:	55                   	push   %ebp
  8021a2:	89 e5                	mov    %esp,%ebp
  8021a4:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8021a7:	e8 1e 41 00 00       	call   8062ca <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8021ac:	83 3d 3c c2 b3 00 00 	cmpl   $0x0,0xb3c23c
  8021b3:	74 19                	je     8021ce <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8021b5:	83 ec 04             	sub    $0x4,%esp
  8021b8:	6a 00                	push   $0x0
  8021ba:	68 a1 21 80 00       	push   $0x8021a1
  8021bf:	68 fa 00 00 00       	push   $0xfa
  8021c4:	e8 96 31 00 00       	call   80535f <sys_timeout>
  8021c9:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  8021cc:	c9                   	leave  
  8021cd:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8021ce:	83 3d 50 c2 b3 00 00 	cmpl   $0x0,0xb3c250
  8021d5:	75 de                	jne    8021b5 <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  8021d7:	c7 05 e0 62 81 00 00 	movl   $0x0,0x8162e0
  8021de:	00 00 00 
}
  8021e1:	eb e9                	jmp    8021cc <tcpip_tcp_timer+0x2b>

008021e3 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8021e3:	55                   	push   %ebp
  8021e4:	89 e5                	mov    %esp,%ebp
  8021e6:	53                   	push   %ebx
  8021e7:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8021ea:	6a 00                	push   $0x0
  8021ec:	68 93 23 80 00       	push   $0x802393
  8021f1:	68 e8 03 00 00       	push   $0x3e8
  8021f6:	e8 64 31 00 00       	call   80535f <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8021fb:	83 c4 0c             	add    $0xc,%esp
  8021fe:	6a 00                	push   $0x0
  802200:	68 6f 23 80 00       	push   $0x80236f
  802205:	68 88 13 00 00       	push   $0x1388
  80220a:	e8 50 31 00 00       	call   80535f <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80220f:	83 c4 0c             	add    $0xc,%esp
  802212:	6a 00                	push   $0x0
  802214:	68 4b 23 80 00       	push   $0x80234b
  802219:	68 60 ea 00 00       	push   $0xea60
  80221e:	e8 3c 31 00 00       	call   80535f <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802223:	83 c4 0c             	add    $0xc,%esp
  802226:	6a 00                	push   $0x0
  802228:	68 27 23 80 00       	push   $0x802327
  80222d:	68 f4 01 00 00       	push   $0x1f4
  802232:	e8 28 31 00 00       	call   80535f <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  802237:	a1 e8 62 81 00       	mov    0x8162e8,%eax
  80223c:	83 c4 10             	add    $0x10,%esp
  80223f:	85 c0                	test   %eax,%eax
  802241:	74 0e                	je     802251 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  802243:	83 ec 0c             	sub    $0xc,%esp
  802246:	ff 35 e4 62 81 00    	pushl  0x8162e4
  80224c:	ff d0                	call   *%eax
  80224e:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802251:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  802254:	eb 0f                	jmp    802265 <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802256:	8b 42 08             	mov    0x8(%edx),%eax
  802259:	83 ec 0c             	sub    $0xc,%esp
  80225c:	8d 50 04             	lea    0x4(%eax),%edx
  80225f:	52                   	push   %edx
  802260:	ff 10                	call   *(%eax)
      break;
  802262:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  802265:	83 ec 08             	sub    $0x8,%esp
  802268:	53                   	push   %ebx
  802269:	ff 35 00 50 81 00    	pushl  0x815000
  80226f:	e8 cb 2f 00 00       	call   80523f <sys_mbox_fetch>
    switch (msg->type) {
  802274:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802277:	8b 02                	mov    (%edx),%eax
  802279:	83 c4 10             	add    $0x10,%esp
  80227c:	83 f8 01             	cmp    $0x1,%eax
  80227f:	74 3a                	je     8022bb <tcpip_thread+0xd8>
  802281:	85 c0                	test   %eax,%eax
  802283:	74 d1                	je     802256 <tcpip_thread+0x73>
  802285:	83 f8 02             	cmp    $0x2,%eax
  802288:	74 6c                	je     8022f6 <tcpip_thread+0x113>
  80228a:	83 f8 03             	cmp    $0x3,%eax
  80228d:	75 d6                	jne    802265 <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  80228f:	8b 42 08             	mov    0x8(%edx),%eax
  802292:	83 f8 ff             	cmp    $0xffffffff,%eax
  802295:	74 7d                	je     802314 <tcpip_thread+0x131>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  802297:	83 ec 04             	sub    $0x4,%esp
  80229a:	ff 72 10             	pushl  0x10(%edx)
  80229d:	ff 72 0c             	pushl  0xc(%edx)
  8022a0:	50                   	push   %eax
  8022a1:	e8 b9 30 00 00       	call   80535f <sys_timeout>
  8022a6:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8022a9:	83 ec 08             	sub    $0x8,%esp
  8022ac:	ff 75 f4             	pushl  -0xc(%ebp)
  8022af:	6a 08                	push   $0x8
  8022b1:	e8 f1 23 00 00       	call   8046a7 <memp_free>
      break;
  8022b6:	83 c4 10             	add    $0x10,%esp
  8022b9:	eb aa                	jmp    802265 <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  8022bb:	8b 42 0c             	mov    0xc(%edx),%eax
  8022be:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  8022c2:	74 21                	je     8022e5 <tcpip_thread+0x102>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  8022c4:	83 ec 08             	sub    $0x8,%esp
  8022c7:	50                   	push   %eax
  8022c8:	ff 72 08             	pushl  0x8(%edx)
  8022cb:	e8 2d 7b 00 00       	call   809dfd <ethernet_input>
  8022d0:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022d3:	83 ec 08             	sub    $0x8,%esp
  8022d6:	ff 75 f4             	pushl  -0xc(%ebp)
  8022d9:	6a 09                	push   $0x9
  8022db:	e8 c7 23 00 00       	call   8046a7 <memp_free>
      break;
  8022e0:	83 c4 10             	add    $0x10,%esp
  8022e3:	eb 80                	jmp    802265 <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8022e5:	83 ec 08             	sub    $0x8,%esp
  8022e8:	50                   	push   %eax
  8022e9:	ff 72 08             	pushl  0x8(%edx)
  8022ec:	e8 1a 44 00 00       	call   80670b <ip_input>
  8022f1:	83 c4 10             	add    $0x10,%esp
  8022f4:	eb dd                	jmp    8022d3 <tcpip_thread+0xf0>
      msg->msg.cb.f(msg->msg.cb.ctx);
  8022f6:	83 ec 0c             	sub    $0xc,%esp
  8022f9:	ff 72 0c             	pushl  0xc(%edx)
  8022fc:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8022ff:	83 c4 08             	add    $0x8,%esp
  802302:	ff 75 f4             	pushl  -0xc(%ebp)
  802305:	6a 08                	push   $0x8
  802307:	e8 9b 23 00 00       	call   8046a7 <memp_free>
      break;
  80230c:	83 c4 10             	add    $0x10,%esp
  80230f:	e9 51 ff ff ff       	jmp    802265 <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  802314:	83 ec 08             	sub    $0x8,%esp
  802317:	ff 72 10             	pushl  0x10(%edx)
  80231a:	ff 72 0c             	pushl  0xc(%edx)
  80231d:	e8 00 31 00 00       	call   805422 <sys_untimeout>
  802322:	83 c4 10             	add    $0x10,%esp
  802325:	eb 82                	jmp    8022a9 <tcpip_thread+0xc6>

00802327 <dhcp_timer_fine>:
{
  802327:	55                   	push   %ebp
  802328:	89 e5                	mov    %esp,%ebp
  80232a:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  80232d:	e8 45 1b 00 00       	call   803e77 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  802332:	83 ec 04             	sub    $0x4,%esp
  802335:	6a 00                	push   $0x0
  802337:	68 27 23 80 00       	push   $0x802327
  80233c:	68 f4 01 00 00       	push   $0x1f4
  802341:	e8 19 30 00 00       	call   80535f <sys_timeout>
}
  802346:	83 c4 10             	add    $0x10,%esp
  802349:	c9                   	leave  
  80234a:	c3                   	ret    

0080234b <dhcp_timer_coarse>:
{
  80234b:	55                   	push   %ebp
  80234c:	89 e5                	mov    %esp,%ebp
  80234e:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  802351:	e8 55 19 00 00       	call   803cab <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  802356:	83 ec 04             	sub    $0x4,%esp
  802359:	6a 00                	push   $0x0
  80235b:	68 4b 23 80 00       	push   $0x80234b
  802360:	68 60 ea 00 00       	push   $0xea60
  802365:	e8 f5 2f 00 00       	call   80535f <sys_timeout>
}
  80236a:	83 c4 10             	add    $0x10,%esp
  80236d:	c9                   	leave  
  80236e:	c3                   	ret    

0080236f <arp_timer>:
{
  80236f:	55                   	push   %ebp
  802370:	89 e5                	mov    %esp,%ebp
  802372:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  802375:	e8 53 73 00 00       	call   8096cd <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80237a:	83 ec 04             	sub    $0x4,%esp
  80237d:	6a 00                	push   $0x0
  80237f:	68 6f 23 80 00       	push   $0x80236f
  802384:	68 88 13 00 00       	push   $0x1388
  802389:	e8 d1 2f 00 00       	call   80535f <sys_timeout>
}
  80238e:	83 c4 10             	add    $0x10,%esp
  802391:	c9                   	leave  
  802392:	c3                   	ret    

00802393 <ip_reass_timer>:
{
  802393:	55                   	push   %ebp
  802394:	89 e5                	mov    %esp,%ebp
  802396:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  802399:	e8 68 4a 00 00       	call   806e06 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80239e:	83 ec 04             	sub    $0x4,%esp
  8023a1:	6a 00                	push   $0x0
  8023a3:	68 93 23 80 00       	push   $0x802393
  8023a8:	68 e8 03 00 00       	push   $0x3e8
  8023ad:	e8 ad 2f 00 00       	call   80535f <sys_timeout>
}
  8023b2:	83 c4 10             	add    $0x10,%esp
  8023b5:	c9                   	leave  
  8023b6:	c3                   	ret    

008023b7 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8023b7:	55                   	push   %ebp
  8023b8:	89 e5                	mov    %esp,%ebp
  8023ba:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8023bd:	ff 75 08             	pushl  0x8(%ebp)
  8023c0:	e8 2f 26 00 00       	call   8049f4 <pbuf_free>
}
  8023c5:	83 c4 10             	add    $0x10,%esp
  8023c8:	c9                   	leave  
  8023c9:	c3                   	ret    

008023ca <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8023ca:	83 3d e0 62 81 00 00 	cmpl   $0x0,0x8162e0
  8023d1:	75 38                	jne    80240b <tcp_timer_needed+0x41>
  8023d3:	83 3d 3c c2 b3 00 00 	cmpl   $0x0,0xb3c23c
  8023da:	74 26                	je     802402 <tcp_timer_needed+0x38>
{
  8023dc:	55                   	push   %ebp
  8023dd:	89 e5                	mov    %esp,%ebp
  8023df:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  8023e2:	c7 05 e0 62 81 00 01 	movl   $0x1,0x8162e0
  8023e9:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8023ec:	6a 00                	push   $0x0
  8023ee:	68 a1 21 80 00       	push   $0x8021a1
  8023f3:	68 fa 00 00 00       	push   $0xfa
  8023f8:	e8 62 2f 00 00       	call   80535f <sys_timeout>
  8023fd:	83 c4 10             	add    $0x10,%esp
}
  802400:	c9                   	leave  
  802401:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802402:	83 3d 50 c2 b3 00 00 	cmpl   $0x0,0xb3c250
  802409:	75 d1                	jne    8023dc <tcp_timer_needed+0x12>
  80240b:	c3                   	ret    

0080240c <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  80240c:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802413:	74 59                	je     80246e <tcpip_input+0x62>
{
  802415:	55                   	push   %ebp
  802416:	89 e5                	mov    %esp,%ebp
  802418:	53                   	push   %ebx
  802419:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80241c:	6a 09                	push   $0x9
  80241e:	e8 2e 22 00 00       	call   804651 <memp_malloc>
  802423:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802425:	83 c4 10             	add    $0x10,%esp
  802428:	85 c0                	test   %eax,%eax
  80242a:	74 48                	je     802474 <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  80242c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802432:	8b 45 08             	mov    0x8(%ebp),%eax
  802435:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802438:	8b 45 0c             	mov    0xc(%ebp),%eax
  80243b:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80243e:	83 ec 08             	sub    $0x8,%esp
  802441:	53                   	push   %ebx
  802442:	ff 35 00 50 81 00    	pushl  0x815000
  802448:	e8 97 7f 00 00       	call   80a3e4 <sys_mbox_trypost>
  80244d:	83 c4 10             	add    $0x10,%esp
  802450:	84 c0                	test   %al,%al
  802452:	75 05                	jne    802459 <tcpip_input+0x4d>
}
  802454:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802457:	c9                   	leave  
  802458:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802459:	83 ec 08             	sub    $0x8,%esp
  80245c:	53                   	push   %ebx
  80245d:	6a 09                	push   $0x9
  80245f:	e8 43 22 00 00       	call   8046a7 <memp_free>
      return ERR_MEM;
  802464:	83 c4 10             	add    $0x10,%esp
  802467:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80246c:	eb e6                	jmp    802454 <tcpip_input+0x48>
  return ERR_VAL;
  80246e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802473:	c3                   	ret    
      return ERR_MEM;
  802474:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802479:	eb d9                	jmp    802454 <tcpip_input+0x48>

0080247b <tcpip_callback_with_block>:
{
  80247b:	55                   	push   %ebp
  80247c:	89 e5                	mov    %esp,%ebp
  80247e:	56                   	push   %esi
  80247f:	53                   	push   %ebx
  802480:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802483:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  80248a:	74 76                	je     802502 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80248c:	83 ec 0c             	sub    $0xc,%esp
  80248f:	6a 08                	push   $0x8
  802491:	e8 bb 21 00 00       	call   804651 <memp_malloc>
  802496:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802498:	83 c4 10             	add    $0x10,%esp
  80249b:	85 c0                	test   %eax,%eax
  80249d:	74 6a                	je     802509 <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  80249f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  8024a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8024a8:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  8024ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  8024ae:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  8024b1:	89 f0                	mov    %esi,%eax
  8024b3:	84 c0                	test   %al,%al
  8024b5:	75 1d                	jne    8024d4 <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8024b7:	83 ec 08             	sub    $0x8,%esp
  8024ba:	53                   	push   %ebx
  8024bb:	ff 35 00 50 81 00    	pushl  0x815000
  8024c1:	e8 1e 7f 00 00       	call   80a3e4 <sys_mbox_trypost>
  8024c6:	83 c4 10             	add    $0x10,%esp
  8024c9:	84 c0                	test   %al,%al
  8024cb:	75 20                	jne    8024ed <tcpip_callback_with_block+0x72>
}
  8024cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8024d0:	5b                   	pop    %ebx
  8024d1:	5e                   	pop    %esi
  8024d2:	5d                   	pop    %ebp
  8024d3:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  8024d4:	83 ec 08             	sub    $0x8,%esp
  8024d7:	53                   	push   %ebx
  8024d8:	ff 35 00 50 81 00    	pushl  0x815000
  8024de:	e8 c6 7f 00 00       	call   80a4a9 <sys_mbox_post>
  8024e3:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  8024e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8024eb:	eb e0                	jmp    8024cd <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8024ed:	83 ec 08             	sub    $0x8,%esp
  8024f0:	53                   	push   %ebx
  8024f1:	6a 08                	push   $0x8
  8024f3:	e8 af 21 00 00       	call   8046a7 <memp_free>
        return ERR_MEM;
  8024f8:	83 c4 10             	add    $0x10,%esp
  8024fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802500:	eb cb                	jmp    8024cd <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  802502:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  802507:	eb c4                	jmp    8024cd <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  802509:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80250e:	eb bd                	jmp    8024cd <tcpip_callback_with_block+0x52>

00802510 <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  802510:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802517:	74 45                	je     80255e <tcpip_timeout+0x4e>
{
  802519:	55                   	push   %ebp
  80251a:	89 e5                	mov    %esp,%ebp
  80251c:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80251f:	6a 08                	push   $0x8
  802521:	e8 2b 21 00 00       	call   804651 <memp_malloc>
    if (msg == NULL) {
  802526:	83 c4 10             	add    $0x10,%esp
  802529:	85 c0                	test   %eax,%eax
  80252b:	74 37                	je     802564 <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  80252d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802533:	8b 55 08             	mov    0x8(%ebp),%edx
  802536:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  802539:	8b 55 0c             	mov    0xc(%ebp),%edx
  80253c:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  80253f:	8b 55 10             	mov    0x10(%ebp),%edx
  802542:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802545:	83 ec 08             	sub    $0x8,%esp
  802548:	50                   	push   %eax
  802549:	ff 35 00 50 81 00    	pushl  0x815000
  80254f:	e8 55 7f 00 00       	call   80a4a9 <sys_mbox_post>
    return ERR_OK;
  802554:	83 c4 10             	add    $0x10,%esp
  802557:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80255c:	c9                   	leave  
  80255d:	c3                   	ret    
  return ERR_VAL;
  80255e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802563:	c3                   	ret    
      return ERR_MEM;
  802564:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802569:	eb f1                	jmp    80255c <tcpip_timeout+0x4c>

0080256b <tcpip_apimsg>:
{
  80256b:	55                   	push   %ebp
  80256c:	89 e5                	mov    %esp,%ebp
  80256e:	53                   	push   %ebx
  80256f:	83 ec 24             	sub    $0x24,%esp
  802572:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  802575:	a1 00 50 81 00       	mov    0x815000,%eax
  80257a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80257d:	74 34                	je     8025b3 <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  80257f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802586:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802589:	83 ec 08             	sub    $0x8,%esp
  80258c:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80258f:	52                   	push   %edx
  802590:	50                   	push   %eax
  802591:	e8 13 7f 00 00       	call   80a4a9 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802596:	83 c4 08             	add    $0x8,%esp
  802599:	6a 00                	push   $0x0
  80259b:	8b 43 04             	mov    0x4(%ebx),%eax
  80259e:	ff 70 10             	pushl  0x10(%eax)
  8025a1:	e8 2e 7d 00 00       	call   80a2d4 <sys_arch_sem_wait>
    return ERR_OK;
  8025a6:	83 c4 10             	add    $0x10,%esp
  8025a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8025ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025b1:	c9                   	leave  
  8025b2:	c3                   	ret    
  return ERR_VAL;
  8025b3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8025b8:	eb f4                	jmp    8025ae <tcpip_apimsg+0x43>

008025ba <tcpip_init>:
{
  8025ba:	55                   	push   %ebp
  8025bb:	89 e5                	mov    %esp,%ebp
  8025bd:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  8025c0:	e8 6a 03 00 00       	call   80292f <lwip_init>
  tcpip_init_done = initfunc;
  8025c5:	8b 45 08             	mov    0x8(%ebp),%eax
  8025c8:	a3 e8 62 81 00       	mov    %eax,0x8162e8
  tcpip_init_done_arg = arg;
  8025cd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8025d0:	a3 e4 62 81 00       	mov    %eax,0x8162e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8025d5:	83 ec 0c             	sub    $0xc,%esp
  8025d8:	6a 00                	push   $0x0
  8025da:	e8 71 7b 00 00       	call   80a150 <sys_mbox_new>
  8025df:	a3 00 50 81 00       	mov    %eax,0x815000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8025e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8025eb:	6a 00                	push   $0x0
  8025ed:	6a 00                	push   $0x0
  8025ef:	68 e3 21 80 00       	push   $0x8021e3
  8025f4:	68 7c 18 81 00       	push   $0x81187c
  8025f9:	e8 de 7f 00 00       	call   80a5dc <sys_thread_new>
}
  8025fe:	83 c4 20             	add    $0x20,%esp
  802601:	c9                   	leave  
  802602:	c3                   	ret    

00802603 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802603:	55                   	push   %ebp
  802604:	89 e5                	mov    %esp,%ebp
  802606:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802609:	6a 00                	push   $0x0
  80260b:	ff 75 08             	pushl  0x8(%ebp)
  80260e:	68 b7 23 80 00       	push   $0x8023b7
  802613:	e8 63 fe ff ff       	call   80247b <tcpip_callback_with_block>
}
  802618:	c9                   	leave  
  802619:	c3                   	ret    

0080261a <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  80261a:	55                   	push   %ebp
  80261b:	89 e5                	mov    %esp,%ebp
  80261d:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802620:	6a 00                	push   $0x0
  802622:	ff 75 08             	pushl  0x8(%ebp)
  802625:	68 0e 41 80 00       	push   $0x80410e
  80262a:	e8 4c fe ff ff       	call   80247b <tcpip_callback_with_block>
}
  80262f:	c9                   	leave  
  802630:	c3                   	ret    

00802631 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802631:	55                   	push   %ebp
  802632:	89 e5                	mov    %esp,%ebp
  802634:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802637:	6a 06                	push   $0x6
  802639:	e8 13 20 00 00       	call   804651 <memp_malloc>
  if (buf != NULL) {
  80263e:	83 c4 10             	add    $0x10,%esp
  802641:	85 c0                	test   %eax,%eax
  802643:	74 14                	je     802659 <netbuf_new+0x28>
    buf->p = NULL;
  802645:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80264b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802652:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  802659:	c9                   	leave  
  80265a:	c3                   	ret    

0080265b <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80265b:	55                   	push   %ebp
  80265c:	89 e5                	mov    %esp,%ebp
  80265e:	53                   	push   %ebx
  80265f:	83 ec 04             	sub    $0x4,%esp
  802662:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802665:	85 db                	test   %ebx,%ebx
  802667:	74 2d                	je     802696 <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  802669:	8b 03                	mov    (%ebx),%eax
  80266b:	85 c0                	test   %eax,%eax
  80266d:	74 19                	je     802688 <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  80266f:	83 ec 0c             	sub    $0xc,%esp
  802672:	50                   	push   %eax
  802673:	e8 7c 23 00 00       	call   8049f4 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802678:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80267f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802685:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  802688:	83 ec 08             	sub    $0x8,%esp
  80268b:	53                   	push   %ebx
  80268c:	6a 06                	push   $0x6
  80268e:	e8 14 20 00 00       	call   8046a7 <memp_free>
  802693:	83 c4 10             	add    $0x10,%esp
  }
}
  802696:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802699:	c9                   	leave  
  80269a:	c3                   	ret    

0080269b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80269b:	55                   	push   %ebp
  80269c:	89 e5                	mov    %esp,%ebp
  80269e:	56                   	push   %esi
  80269f:	53                   	push   %ebx
  8026a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8026a3:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8026a6:	85 db                	test   %ebx,%ebx
  8026a8:	74 3e                	je     8026e8 <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8026aa:	8b 03                	mov    (%ebx),%eax
  8026ac:	85 c0                	test   %eax,%eax
  8026ae:	74 0c                	je     8026bc <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  8026b0:	83 ec 0c             	sub    $0xc,%esp
  8026b3:	50                   	push   %eax
  8026b4:	e8 3b 23 00 00       	call   8049f4 <pbuf_free>
  8026b9:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8026bc:	83 ec 04             	sub    $0x4,%esp
  8026bf:	6a 00                	push   $0x0
  8026c1:	0f b7 c6             	movzwl %si,%eax
  8026c4:	50                   	push   %eax
  8026c5:	6a 00                	push   $0x0
  8026c7:	e8 ee 23 00 00       	call   804aba <pbuf_alloc>
  8026cc:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8026ce:	83 c4 10             	add    $0x10,%esp
  8026d1:	85 c0                	test   %eax,%eax
  8026d3:	74 0c                	je     8026e1 <netbuf_alloc+0x46>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8026d5:	66 39 70 0a          	cmp    %si,0xa(%eax)
  8026d9:	72 21                	jb     8026fc <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8026db:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8026de:	8b 40 04             	mov    0x4(%eax),%eax
}
  8026e1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026e4:	5b                   	pop    %ebx
  8026e5:	5e                   	pop    %esi
  8026e6:	5d                   	pop    %ebp
  8026e7:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8026e8:	83 ec 04             	sub    $0x4,%esp
  8026eb:	68 89 18 81 00       	push   $0x811889
  8026f0:	6a 63                	push   $0x63
  8026f2:	68 a3 18 81 00       	push   $0x8118a3
  8026f7:	e8 0d c1 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  8026fc:	83 ec 04             	sub    $0x4,%esp
  8026ff:	68 70 19 81 00       	push   $0x811970
  802704:	6a 6e                	push   $0x6e
  802706:	68 a3 18 81 00       	push   $0x8118a3
  80270b:	e8 f9 c0 00 00       	call   80e809 <_panic>

00802710 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  802710:	55                   	push   %ebp
  802711:	89 e5                	mov    %esp,%ebp
  802713:	53                   	push   %ebx
  802714:	83 ec 04             	sub    $0x4,%esp
  802717:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80271a:	85 db                	test   %ebx,%ebx
  80271c:	74 24                	je     802742 <netbuf_free+0x32>
  if (buf->p != NULL) {
  80271e:	8b 03                	mov    (%ebx),%eax
  802720:	85 c0                	test   %eax,%eax
  802722:	74 0c                	je     802730 <netbuf_free+0x20>
    pbuf_free(buf->p);
  802724:	83 ec 0c             	sub    $0xc,%esp
  802727:	50                   	push   %eax
  802728:	e8 c7 22 00 00       	call   8049f4 <pbuf_free>
  80272d:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  802730:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802737:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  80273d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802740:	c9                   	leave  
  802741:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802742:	83 ec 04             	sub    $0x4,%esp
  802745:	68 b9 18 81 00       	push   $0x8118b9
  80274a:	6a 7b                	push   $0x7b
  80274c:	68 a3 18 81 00       	push   $0x8118a3
  802751:	e8 b3 c0 00 00       	call   80e809 <_panic>

00802756 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802756:	55                   	push   %ebp
  802757:	89 e5                	mov    %esp,%ebp
  802759:	56                   	push   %esi
  80275a:	53                   	push   %ebx
  80275b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80275e:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802761:	85 db                	test   %ebx,%ebx
  802763:	74 4c                	je     8027b1 <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  802765:	8b 03                	mov    (%ebx),%eax
  802767:	85 c0                	test   %eax,%eax
  802769:	74 0c                	je     802777 <netbuf_ref+0x21>
    pbuf_free(buf->p);
  80276b:	83 ec 0c             	sub    $0xc,%esp
  80276e:	50                   	push   %eax
  80276f:	e8 80 22 00 00       	call   8049f4 <pbuf_free>
  802774:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  802777:	83 ec 04             	sub    $0x4,%esp
  80277a:	6a 02                	push   $0x2
  80277c:	6a 00                	push   $0x0
  80277e:	6a 00                	push   $0x0
  802780:	e8 35 23 00 00       	call   804aba <pbuf_alloc>
  802785:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802787:	83 c4 10             	add    $0x10,%esp
  80278a:	85 c0                	test   %eax,%eax
  80278c:	74 3a                	je     8027c8 <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  80278e:	8b 55 0c             	mov    0xc(%ebp),%edx
  802791:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802794:	8b 03                	mov    (%ebx),%eax
  802796:	66 89 70 08          	mov    %si,0x8(%eax)
  80279a:	8b 03                	mov    (%ebx),%eax
  80279c:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  8027a0:	8b 03                	mov    (%ebx),%eax
  8027a2:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  8027a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8027aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8027ad:	5b                   	pop    %ebx
  8027ae:	5e                   	pop    %esi
  8027af:	5d                   	pop    %ebp
  8027b0:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8027b1:	83 ec 04             	sub    $0x4,%esp
  8027b4:	68 d2 18 81 00       	push   $0x8118d2
  8027b9:	68 8e 00 00 00       	push   $0x8e
  8027be:	68 a3 18 81 00       	push   $0x8118a3
  8027c3:	e8 41 c0 00 00       	call   80e809 <_panic>
    buf->ptr = NULL;
  8027c8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8027cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8027d4:	eb d4                	jmp    8027aa <netbuf_ref+0x54>

008027d6 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8027d6:	55                   	push   %ebp
  8027d7:	89 e5                	mov    %esp,%ebp
  8027d9:	56                   	push   %esi
  8027da:	53                   	push   %ebx
  8027db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8027de:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8027e1:	85 db                	test   %ebx,%ebx
  8027e3:	74 2a                	je     80280f <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8027e5:	85 f6                	test   %esi,%esi
  8027e7:	74 3d                	je     802826 <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  8027e9:	83 ec 08             	sub    $0x8,%esp
  8027ec:	ff 36                	pushl  (%esi)
  8027ee:	ff 33                	pushl  (%ebx)
  8027f0:	e8 e0 26 00 00       	call   804ed5 <pbuf_chain>
  head->ptr = head->p;
  8027f5:	8b 03                	mov    (%ebx),%eax
  8027f7:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  8027fa:	83 c4 08             	add    $0x8,%esp
  8027fd:	56                   	push   %esi
  8027fe:	6a 06                	push   $0x6
  802800:	e8 a2 1e 00 00       	call   8046a7 <memp_free>
  802805:	83 c4 10             	add    $0x10,%esp
}
  802808:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80280b:	5b                   	pop    %ebx
  80280c:	5e                   	pop    %esi
  80280d:	5d                   	pop    %ebp
  80280e:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  80280f:	83 ec 04             	sub    $0x4,%esp
  802812:	68 ea 18 81 00       	push   $0x8118ea
  802817:	68 a6 00 00 00       	push   $0xa6
  80281c:	68 a3 18 81 00       	push   $0x8118a3
  802821:	e8 e3 bf 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802826:	83 ec 04             	sub    $0x4,%esp
  802829:	68 03 19 81 00       	push   $0x811903
  80282e:	68 a7 00 00 00       	push   $0xa7
  802833:	68 a3 18 81 00       	push   $0x8118a3
  802838:	e8 cc bf 00 00       	call   80e809 <_panic>

0080283d <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80283d:	55                   	push   %ebp
  80283e:	89 e5                	mov    %esp,%ebp
  802840:	53                   	push   %ebx
  802841:	83 ec 04             	sub    $0x4,%esp
  802844:	8b 45 08             	mov    0x8(%ebp),%eax
  802847:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80284a:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80284d:	85 c0                	test   %eax,%eax
  80284f:	74 28                	je     802879 <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802851:	85 c9                	test   %ecx,%ecx
  802853:	74 3b                	je     802890 <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802855:	85 d2                	test   %edx,%edx
  802857:	74 4e                	je     8028a7 <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  802859:	8b 58 04             	mov    0x4(%eax),%ebx
  80285c:	85 db                	test   %ebx,%ebx
  80285e:	74 5e                	je     8028be <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802860:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802863:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802865:	8b 40 04             	mov    0x4(%eax),%eax
  802868:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  80286c:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  80286f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802874:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802877:	c9                   	leave  
  802878:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802879:	83 ec 04             	sub    $0x4,%esp
  80287c:	68 1e 19 81 00       	push   $0x81191e
  802881:	68 b9 00 00 00       	push   $0xb9
  802886:	68 a3 18 81 00       	push   $0x8118a3
  80288b:	e8 79 bf 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802890:	83 ec 04             	sub    $0x4,%esp
  802893:	68 37 19 81 00       	push   $0x811937
  802898:	68 ba 00 00 00       	push   $0xba
  80289d:	68 a3 18 81 00       	push   $0x8118a3
  8028a2:	e8 62 bf 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8028a7:	83 ec 04             	sub    $0x4,%esp
  8028aa:	68 54 19 81 00       	push   $0x811954
  8028af:	68 bb 00 00 00       	push   $0xbb
  8028b4:	68 a3 18 81 00       	push   $0x8118a3
  8028b9:	e8 4b bf 00 00       	call   80e809 <_panic>
    return ERR_BUF;
  8028be:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8028c3:	eb af                	jmp    802874 <netbuf_data+0x37>

008028c5 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8028c5:	55                   	push   %ebp
  8028c6:	89 e5                	mov    %esp,%ebp
  8028c8:	83 ec 08             	sub    $0x8,%esp
  8028cb:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8028ce:	85 c0                	test   %eax,%eax
  8028d0:	74 14                	je     8028e6 <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  8028d2:	8b 50 04             	mov    0x4(%eax),%edx
  8028d5:	8b 12                	mov    (%edx),%edx
  8028d7:	85 d2                	test   %edx,%edx
  8028d9:	74 22                	je     8028fd <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  8028db:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  8028de:	83 3a 00             	cmpl   $0x0,(%edx)
  8028e1:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  8028e4:	c9                   	leave  
  8028e5:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8028e6:	83 ec 04             	sub    $0x4,%esp
  8028e9:	68 b9 18 81 00       	push   $0x8118b9
  8028ee:	68 d2 00 00 00       	push   $0xd2
  8028f3:	68 a3 18 81 00       	push   $0x8118a3
  8028f8:	e8 0c bf 00 00       	call   80e809 <_panic>
    return -1;
  8028fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802902:	eb e0                	jmp    8028e4 <netbuf_next+0x1f>

00802904 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802904:	55                   	push   %ebp
  802905:	89 e5                	mov    %esp,%ebp
  802907:	83 ec 08             	sub    $0x8,%esp
  80290a:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80290d:	85 c0                	test   %eax,%eax
  80290f:	74 07                	je     802918 <netbuf_first+0x14>
  buf->ptr = buf->p;
  802911:	8b 10                	mov    (%eax),%edx
  802913:	89 50 04             	mov    %edx,0x4(%eax)
}
  802916:	c9                   	leave  
  802917:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802918:	83 ec 04             	sub    $0x4,%esp
  80291b:	68 b9 18 81 00       	push   $0x8118b9
  802920:	68 e7 00 00 00       	push   $0xe7
  802925:	68 a3 18 81 00       	push   $0x8118a3
  80292a:	e8 da be 00 00       	call   80e809 <_panic>

0080292f <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  80292f:	55                   	push   %ebp
  802930:	89 e5                	mov    %esp,%ebp
  802932:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802935:	e8 d0 75 00 00       	call   809f0a <sys_init>
  mem_init();
  80293a:	e8 69 17 00 00       	call   8040a8 <mem_init>
  memp_init();
  80293f:	e8 b1 1c 00 00       	call   8045f5 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802944:	e8 a9 e6 ff ff       	call   800ff2 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802949:	c9                   	leave  
  80294a:	c3                   	ret    

0080294b <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  80294b:	38 10                	cmp    %dl,(%eax)
  80294d:	74 06                	je     802955 <dhcp_set_state+0xa>
    dhcp->state = new_state;
  80294f:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802951:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802955:	c3                   	ret    

00802956 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802956:	55                   	push   %ebp
  802957:	89 e5                	mov    %esp,%ebp
  802959:	57                   	push   %edi
  80295a:	56                   	push   %esi
  80295b:	53                   	push   %ebx
  80295c:	83 ec 0c             	sub    $0xc,%esp
  80295f:	89 c7                	mov    %eax,%edi
  802961:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802964:	8b 40 14             	mov    0x14(%eax),%eax
  802967:	85 c0                	test   %eax,%eax
  802969:	74 19                	je     802984 <dhcp_get_option_ptr+0x2e>
  80296b:	89 d6                	mov    %edx,%esi
  80296d:	0f b7 7f 18          	movzwl 0x18(%edi),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802971:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  802976:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80297a:	66 85 ff             	test   %di,%di
  80297d:	75 2d                	jne    8029ac <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80297f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802984:	83 c4 0c             	add    $0xc,%esp
  802987:	5b                   	pop    %ebx
  802988:	5e                   	pop    %esi
  802989:	5f                   	pop    %edi
  80298a:	5d                   	pop    %ebp
  80298b:	c3                   	ret    
        offset += 2;
  80298c:	8d 51 02             	lea    0x2(%ecx),%edx
        overload = options[offset++];
  80298f:	83 c1 03             	add    $0x3,%ecx
  802992:	0f b7 d2             	movzwl %dx,%edx
  802995:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
  802999:	88 5d ef             	mov    %bl,-0x11(%ebp)
  80299c:	eb 0e                	jmp    8029ac <dhcp_get_option_ptr+0x56>
        offset++;
  80299e:	8d 51 01             	lea    0x1(%ecx),%edx
        offset += 1 + options[offset];
  8029a1:	0f b7 d2             	movzwl %dx,%edx
  8029a4:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  8029a8:	8d 4c 0a 02          	lea    0x2(%edx,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8029ac:	66 39 cf             	cmp    %cx,%di
  8029af:	76 22                	jbe    8029d3 <dhcp_get_option_ptr+0x7d>
  8029b1:	0f b7 d9             	movzwl %cx,%ebx
  8029b4:	01 c3                	add    %eax,%ebx
  8029b6:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  8029b9:	0f b6 13             	movzbl (%ebx),%edx
  8029bc:	80 fa ff             	cmp    $0xff,%dl
  8029bf:	74 12                	je     8029d3 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8029c1:	80 fa 34             	cmp    $0x34,%dl
  8029c4:	74 c6                	je     80298c <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  8029c6:	89 f3                	mov    %esi,%ebx
  8029c8:	38 da                	cmp    %bl,%dl
  8029ca:	75 d2                	jne    80299e <dhcp_get_option_ptr+0x48>
  8029cc:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8029cf:	89 d8                	mov    %ebx,%eax
  8029d1:	eb b1                	jmp    802984 <dhcp_get_option_ptr+0x2e>
  return NULL;
  8029d3:	b8 00 00 00 00       	mov    $0x0,%eax
    if (overload != DHCP_OVERLOAD_NONE) {
  8029d8:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  8029dc:	84 c9                	test   %cl,%cl
  8029de:	74 a4                	je     802984 <dhcp_get_option_ptr+0x2e>
      if (overload == DHCP_OVERLOAD_FILE) {
  8029e0:	80 f9 01             	cmp    $0x1,%cl
  8029e3:	74 55                	je     802a3a <dhcp_get_option_ptr+0xe4>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8029e5:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  8029e9:	74 5f                	je     802a4a <dhcp_get_option_ptr+0xf4>
        options = (u8_t *)&dhcp->msg_in->sname;
  8029eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8029ee:	8b 48 10             	mov    0x10(%eax),%ecx
  8029f1:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  8029f4:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  8029f9:	ba 00 00 00 00       	mov    $0x0,%edx
  8029fe:	89 f0                	mov    %esi,%eax
  802a00:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802a03:	0f b7 c2             	movzwl %dx,%eax
  802a06:	01 c8                	add    %ecx,%eax
  802a08:	0f b6 30             	movzbl (%eax),%esi
  802a0b:	89 f3                	mov    %esi,%ebx
  802a0d:	80 fb ff             	cmp    $0xff,%bl
  802a10:	74 48                	je     802a5a <dhcp_get_option_ptr+0x104>
        if (options[offset] == option_type) {
  802a12:	89 f3                	mov    %esi,%ebx
  802a14:	3a 5d f0             	cmp    -0x10(%ebp),%bl
  802a17:	0f 84 67 ff ff ff    	je     802984 <dhcp_get_option_ptr+0x2e>
          offset++;
  802a1d:	8d 42 01             	lea    0x1(%edx),%eax
          offset += 1 + options[offset];
  802a20:	0f b7 c0             	movzwl %ax,%eax
  802a23:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  802a27:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802a2b:	66 39 d7             	cmp    %dx,%di
  802a2e:	77 d3                	ja     802a03 <dhcp_get_option_ptr+0xad>
  return NULL;
  802a30:	b8 00 00 00 00       	mov    $0x0,%eax
  802a35:	e9 4a ff ff ff       	jmp    802984 <dhcp_get_option_ptr+0x2e>
        options = (u8_t *)&dhcp->msg_in->file;
  802a3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802a3d:	8b 48 10             	mov    0x10(%eax),%ecx
  802a40:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  802a43:	bf 80 00 00 00       	mov    $0x80,%edi
  802a48:	eb af                	jmp    8029f9 <dhcp_get_option_ptr+0xa3>
        options = (u8_t *)&dhcp->msg_in->sname;
  802a4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802a4d:	8b 48 10             	mov    0x10(%eax),%ecx
  802a50:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  802a53:	bf 40 00 00 00       	mov    $0x40,%edi
  802a58:	eb 9f                	jmp    8029f9 <dhcp_get_option_ptr+0xa3>
  return NULL;
  802a5a:	b8 00 00 00 00       	mov    $0x0,%eax
  802a5f:	e9 20 ff ff ff       	jmp    802984 <dhcp_get_option_ptr+0x2e>

00802a64 <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802a64:	0f b6 10             	movzbl (%eax),%edx
  802a67:	89 d1                	mov    %edx,%ecx
  802a69:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802a6c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802a70:	c1 e2 10             	shl    $0x10,%edx
  802a73:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802a75:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  802a79:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  802a7b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802a7f:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  802a82:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802a84:	c3                   	ret    

00802a85 <dhcp_option_byte>:
{
  802a85:	55                   	push   %ebp
  802a86:	89 e5                	mov    %esp,%ebp
  802a88:	56                   	push   %esi
  802a89:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a8a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802a8e:	66 83 f9 43          	cmp    $0x43,%cx
  802a92:	77 1b                	ja     802aaf <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802a94:	8b 58 20             	mov    0x20(%eax),%ebx
  802a97:	8d 71 01             	lea    0x1(%ecx),%esi
  802a9a:	66 89 70 24          	mov    %si,0x24(%eax)
  802a9e:	0f b7 c9             	movzwl %cx,%ecx
  802aa1:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802aa8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802aab:	5b                   	pop    %ebx
  802aac:	5e                   	pop    %esi
  802aad:	5d                   	pop    %ebp
  802aae:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aaf:	83 ec 04             	sub    $0x4,%esp
  802ab2:	68 94 19 81 00       	push   $0x811994
  802ab7:	68 65 04 00 00       	push   $0x465
  802abc:	68 e2 1c 81 00       	push   $0x811ce2
  802ac1:	e8 43 bd 00 00       	call   80e809 <_panic>

00802ac6 <dhcp_option>:
{
  802ac6:	55                   	push   %ebp
  802ac7:	89 e5                	mov    %esp,%ebp
  802ac9:	57                   	push   %edi
  802aca:	56                   	push   %esi
  802acb:	53                   	push   %ebx
  802acc:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802acf:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802ad3:	0f b6 f9             	movzbl %cl,%edi
  802ad6:	0f b7 f3             	movzwl %bx,%esi
  802ad9:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802add:	83 fe 44             	cmp    $0x44,%esi
  802ae0:	77 34                	ja     802b16 <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802ae2:	8b 70 20             	mov    0x20(%eax),%esi
  802ae5:	8d 7b 01             	lea    0x1(%ebx),%edi
  802ae8:	66 89 78 24          	mov    %di,0x24(%eax)
  802aec:	0f b7 db             	movzwl %bx,%ebx
  802aef:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802af6:	8b 58 20             	mov    0x20(%eax),%ebx
  802af9:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802afd:	8d 72 01             	lea    0x1(%edx),%esi
  802b00:	66 89 70 24          	mov    %si,0x24(%eax)
  802b04:	0f b7 d2             	movzwl %dx,%edx
  802b07:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802b0e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802b11:	5b                   	pop    %ebx
  802b12:	5e                   	pop    %esi
  802b13:	5f                   	pop    %edi
  802b14:	5d                   	pop    %ebp
  802b15:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802b16:	83 ec 04             	sub    $0x4,%esp
  802b19:	68 d0 19 81 00       	push   $0x8119d0
  802b1e:	68 5a 04 00 00       	push   $0x45a
  802b23:	68 e2 1c 81 00       	push   $0x811ce2
  802b28:	e8 dc bc 00 00       	call   80e809 <_panic>

00802b2d <dhcp_option_short>:
{
  802b2d:	55                   	push   %ebp
  802b2e:	89 e5                	mov    %esp,%ebp
  802b30:	56                   	push   %esi
  802b31:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802b32:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b36:	0f b7 d9             	movzwl %cx,%ebx
  802b39:	83 c3 02             	add    $0x2,%ebx
  802b3c:	83 fb 44             	cmp    $0x44,%ebx
  802b3f:	77 33                	ja     802b74 <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802b41:	8b 58 20             	mov    0x20(%eax),%ebx
  802b44:	8d 71 01             	lea    0x1(%ecx),%esi
  802b47:	66 89 70 24          	mov    %si,0x24(%eax)
  802b4b:	0f b7 c9             	movzwl %cx,%ecx
  802b4e:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802b55:	8b 58 20             	mov    0x20(%eax),%ebx
  802b58:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b5c:	8d 71 01             	lea    0x1(%ecx),%esi
  802b5f:	66 89 70 24          	mov    %si,0x24(%eax)
  802b63:	0f b7 c9             	movzwl %cx,%ecx
  802b66:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b6d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b70:	5b                   	pop    %ebx
  802b71:	5e                   	pop    %esi
  802b72:	5d                   	pop    %ebp
  802b73:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802b74:	83 ec 04             	sub    $0x4,%esp
  802b77:	68 18 1a 81 00       	push   $0x811a18
  802b7c:	68 6c 04 00 00       	push   $0x46c
  802b81:	68 e2 1c 81 00       	push   $0x811ce2
  802b86:	e8 7e bc 00 00       	call   80e809 <_panic>

00802b8b <dhcp_option_trailer>:
{
  802b8b:	55                   	push   %ebp
  802b8c:	89 e5                	mov    %esp,%ebp
  802b8e:	53                   	push   %ebx
  802b8f:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802b92:	85 c0                	test   %eax,%eax
  802b94:	74 25                	je     802bbb <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802b96:	8b 48 20             	mov    0x20(%eax),%ecx
  802b99:	85 c9                	test   %ecx,%ecx
  802b9b:	74 35                	je     802bd2 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802b9d:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ba1:	66 83 fa 43          	cmp    $0x43,%dx
  802ba5:	77 42                	ja     802be9 <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802ba7:	8d 5a 01             	lea    0x1(%edx),%ebx
  802baa:	66 89 58 24          	mov    %bx,0x24(%eax)
  802bae:	0f b7 d2             	movzwl %dx,%edx
  802bb1:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802bb8:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802bb9:	eb 5a                	jmp    802c15 <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802bbb:	83 ec 04             	sub    $0x4,%esp
  802bbe:	68 5c 1a 81 00       	push   $0x811a5c
  802bc3:	68 80 05 00 00       	push   $0x580
  802bc8:	68 e2 1c 81 00       	push   $0x811ce2
  802bcd:	e8 37 bc 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802bd2:	83 ec 04             	sub    $0x4,%esp
  802bd5:	68 80 1a 81 00       	push   $0x811a80
  802bda:	68 81 05 00 00       	push   $0x581
  802bdf:	68 e2 1c 81 00       	push   $0x811ce2
  802be4:	e8 20 bc 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802be9:	83 ec 04             	sub    $0x4,%esp
  802bec:	68 ac 1a 81 00       	push   $0x811aac
  802bf1:	68 82 05 00 00       	push   $0x582
  802bf6:	68 e2 1c 81 00       	push   $0x811ce2
  802bfb:	e8 09 bc 00 00       	call   80e809 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802c00:	8b 48 20             	mov    0x20(%eax),%ecx
  802c03:	8d 5a 01             	lea    0x1(%edx),%ebx
  802c06:	66 89 58 24          	mov    %bx,0x24(%eax)
  802c0a:	0f b7 d2             	movzwl %dx,%edx
  802c0d:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802c14:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802c15:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802c19:	66 83 fa 43          	cmp    $0x43,%dx
  802c1d:	76 e1                	jbe    802c00 <dhcp_option_trailer+0x75>
  802c1f:	f6 c2 03             	test   $0x3,%dl
  802c22:	74 17                	je     802c3b <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802c24:	83 ec 04             	sub    $0x4,%esp
  802c27:	68 ac 1a 81 00       	push   $0x811aac
  802c2c:	68 87 05 00 00       	push   $0x587
  802c31:	68 e2 1c 81 00       	push   $0x811ce2
  802c36:	e8 ce bb 00 00       	call   80e809 <_panic>
}
  802c3b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802c3e:	c9                   	leave  
  802c3f:	c3                   	ret    

00802c40 <dhcp_option_long>:
{
  802c40:	55                   	push   %ebp
  802c41:	89 e5                	mov    %esp,%ebp
  802c43:	56                   	push   %esi
  802c44:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802c45:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c49:	0f b7 d9             	movzwl %cx,%ebx
  802c4c:	83 c3 04             	add    $0x4,%ebx
  802c4f:	83 fb 44             	cmp    $0x44,%ebx
  802c52:	77 6d                	ja     802cc1 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802c54:	8d 71 01             	lea    0x1(%ecx),%esi
  802c57:	66 89 70 24          	mov    %si,0x24(%eax)
  802c5b:	0f b7 c9             	movzwl %cx,%ecx
  802c5e:	89 d3                	mov    %edx,%ebx
  802c60:	c1 eb 18             	shr    $0x18,%ebx
  802c63:	8b 70 20             	mov    0x20(%eax),%esi
  802c66:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802c6d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c71:	8d 71 01             	lea    0x1(%ecx),%esi
  802c74:	66 89 70 24          	mov    %si,0x24(%eax)
  802c78:	0f b7 c9             	movzwl %cx,%ecx
  802c7b:	89 d3                	mov    %edx,%ebx
  802c7d:	c1 eb 10             	shr    $0x10,%ebx
  802c80:	8b 70 20             	mov    0x20(%eax),%esi
  802c83:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802c8a:	8b 58 20             	mov    0x20(%eax),%ebx
  802c8d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802c91:	8d 71 01             	lea    0x1(%ecx),%esi
  802c94:	66 89 70 24          	mov    %si,0x24(%eax)
  802c98:	0f b7 c9             	movzwl %cx,%ecx
  802c9b:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802ca2:	8b 58 20             	mov    0x20(%eax),%ebx
  802ca5:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802ca9:	8d 71 01             	lea    0x1(%ecx),%esi
  802cac:	66 89 70 24          	mov    %si,0x24(%eax)
  802cb0:	0f b7 c9             	movzwl %cx,%ecx
  802cb3:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802cba:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802cbd:	5b                   	pop    %ebx
  802cbe:	5e                   	pop    %esi
  802cbf:	5d                   	pop    %ebp
  802cc0:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802cc1:	83 ec 04             	sub    $0x4,%esp
  802cc4:	68 ec 1a 81 00       	push   $0x811aec
  802cc9:	68 74 04 00 00       	push   $0x474
  802cce:	68 e2 1c 81 00       	push   $0x811ce2
  802cd3:	e8 31 bb 00 00       	call   80e809 <_panic>

00802cd8 <dhcp_create_request>:
{
  802cd8:	55                   	push   %ebp
  802cd9:	89 e5                	mov    %esp,%ebp
  802cdb:	57                   	push   %edi
  802cdc:	56                   	push   %esi
  802cdd:	53                   	push   %ebx
  802cde:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802ce1:	85 c0                	test   %eax,%eax
  802ce3:	0f 84 d8 00 00 00    	je     802dc1 <dhcp_create_request+0xe9>
  802ce9:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802ceb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802cee:	85 db                	test   %ebx,%ebx
  802cf0:	0f 84 e2 00 00 00    	je     802dd8 <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802cf6:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802cfa:	0f 85 ef 00 00 00    	jne    802def <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802d00:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802d04:	0f 85 fc 00 00 00    	jne    802e06 <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802d0a:	83 ec 04             	sub    $0x4,%esp
  802d0d:	6a 00                	push   $0x0
  802d0f:	68 34 01 00 00       	push   $0x134
  802d14:	6a 00                	push   $0x0
  802d16:	e8 9f 1d 00 00       	call   804aba <pbuf_alloc>
  802d1b:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802d1e:	83 c4 10             	add    $0x10,%esp
  802d21:	85 c0                	test   %eax,%eax
  802d23:	0f 84 9b 01 00 00    	je     802ec4 <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802d29:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802d2f:	0f 86 e8 00 00 00    	jbe    802e1d <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802d35:	8b 15 04 50 81 00    	mov    0x815004,%edx
  802d3b:	8d 4a 01             	lea    0x1(%edx),%ecx
  802d3e:	89 0d 04 50 81 00    	mov    %ecx,0x815004
  802d44:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802d47:	8b 40 04             	mov    0x4(%eax),%eax
  802d4a:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802d4d:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802d50:	8b 43 20             	mov    0x20(%ebx),%eax
  802d53:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802d57:	8b 43 20             	mov    0x20(%ebx),%eax
  802d5a:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802d5e:	8b 43 20             	mov    0x20(%ebx),%eax
  802d61:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802d65:	8b 7b 20             	mov    0x20(%ebx),%edi
  802d68:	83 ec 0c             	sub    $0xc,%esp
  802d6b:	ff 73 04             	pushl  0x4(%ebx)
  802d6e:	e8 75 4b 00 00       	call   8078e8 <htonl>
  802d73:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802d76:	8b 43 20             	mov    0x20(%ebx),%eax
  802d79:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802d7f:	8b 43 20             	mov    0x20(%ebx),%eax
  802d82:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802d88:	8b 43 20             	mov    0x20(%ebx),%eax
  802d8b:	8b 56 04             	mov    0x4(%esi),%edx
  802d8e:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802d91:	8b 43 20             	mov    0x20(%ebx),%eax
  802d94:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802d9b:	8b 43 20             	mov    0x20(%ebx),%eax
  802d9e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802da5:	8b 43 20             	mov    0x20(%ebx),%eax
  802da8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802daf:	83 c4 10             	add    $0x10,%esp
  802db2:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802db7:	bf 00 00 00 00       	mov    $0x0,%edi
  802dbc:	e9 82 00 00 00       	jmp    802e43 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802dc1:	83 ec 04             	sub    $0x4,%esp
  802dc4:	68 2c 1b 81 00       	push   $0x811b2c
  802dc9:	68 2d 05 00 00       	push   $0x52d
  802dce:	68 e2 1c 81 00       	push   $0x811ce2
  802dd3:	e8 31 ba 00 00       	call   80e809 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802dd8:	83 ec 04             	sub    $0x4,%esp
  802ddb:	68 50 1b 81 00       	push   $0x811b50
  802de0:	68 2f 05 00 00       	push   $0x52f
  802de5:	68 e2 1c 81 00       	push   $0x811ce2
  802dea:	e8 1a ba 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802def:	83 ec 04             	sub    $0x4,%esp
  802df2:	68 74 1b 81 00       	push   $0x811b74
  802df7:	68 30 05 00 00       	push   $0x530
  802dfc:	68 e2 1c 81 00       	push   $0x811ce2
  802e01:	e8 03 ba 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802e06:	83 ec 04             	sub    $0x4,%esp
  802e09:	68 a0 1b 81 00       	push   $0x811ba0
  802e0e:	68 31 05 00 00       	push   $0x531
  802e13:	68 e2 1c 81 00       	push   $0x811ce2
  802e18:	e8 ec b9 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802e1d:	83 ec 04             	sub    $0x4,%esp
  802e20:	68 cc 1b 81 00       	push   $0x811bcc
  802e25:	68 38 05 00 00       	push   $0x538
  802e2a:	68 e2 1c 81 00       	push   $0x811ce2
  802e2f:	e8 d5 b9 00 00       	call   80e809 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802e34:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802e37:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802e3b:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802e3e:	83 f8 10             	cmp    $0x10,%eax
  802e41:	74 12                	je     802e55 <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802e43:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802e47:	89 fa                	mov    %edi,%edx
  802e49:	66 39 c1             	cmp    %ax,%cx
  802e4c:	76 e6                	jbe    802e34 <dhcp_create_request+0x15c>
  802e4e:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802e53:	eb df                	jmp    802e34 <dhcp_create_request+0x15c>
  802e55:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802e5a:	8b 53 20             	mov    0x20(%ebx),%edx
  802e5d:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802e62:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802e65:	83 f8 40             	cmp    $0x40,%eax
  802e68:	75 f0                	jne    802e5a <dhcp_create_request+0x182>
  802e6a:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802e6f:	8b 53 20             	mov    0x20(%ebx),%edx
  802e72:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802e77:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802e7a:	3d 80 00 00 00       	cmp    $0x80,%eax
  802e7f:	75 ee                	jne    802e6f <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802e81:	8b 73 20             	mov    0x20(%ebx),%esi
  802e84:	83 ec 0c             	sub    $0xc,%esp
  802e87:	68 63 53 82 63       	push   $0x63825363
  802e8c:	e8 57 4a 00 00       	call   8078e8 <htonl>
  802e91:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802e97:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802e9d:	83 c4 10             	add    $0x10,%esp
  802ea0:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802ea5:	8b 53 20             	mov    0x20(%ebx),%edx
  802ea8:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802eaf:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802eb2:	83 f8 44             	cmp    $0x44,%eax
  802eb5:	75 ee                	jne    802ea5 <dhcp_create_request+0x1cd>
  return ERR_OK;
  802eb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802ebc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802ebf:	5b                   	pop    %ebx
  802ec0:	5e                   	pop    %esi
  802ec1:	5f                   	pop    %edi
  802ec2:	5d                   	pop    %ebp
  802ec3:	c3                   	ret    
    return ERR_MEM;
  802ec4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802ec9:	eb f1                	jmp    802ebc <dhcp_create_request+0x1e4>

00802ecb <dhcp_delete_request>:
{
  802ecb:	55                   	push   %ebp
  802ecc:	89 e5                	mov    %esp,%ebp
  802ece:	53                   	push   %ebx
  802ecf:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802ed2:	85 c0                	test   %eax,%eax
  802ed4:	74 33                	je     802f09 <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802ed6:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802ed9:	85 db                	test   %ebx,%ebx
  802edb:	74 43                	je     802f20 <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802edd:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802ee0:	85 c0                	test   %eax,%eax
  802ee2:	74 53                	je     802f37 <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802ee4:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802ee8:	74 64                	je     802f4e <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802eea:	83 ec 0c             	sub    $0xc,%esp
  802eed:	50                   	push   %eax
  802eee:	e8 01 1b 00 00       	call   8049f4 <pbuf_free>
  dhcp->p_out = NULL;
  802ef3:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802efa:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802f01:	83 c4 10             	add    $0x10,%esp
}
  802f04:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802f07:	c9                   	leave  
  802f08:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802f09:	83 ec 04             	sub    $0x4,%esp
  802f0c:	68 10 1c 81 00       	push   $0x811c10
  802f11:	68 69 05 00 00       	push   $0x569
  802f16:	68 e2 1c 81 00       	push   $0x811ce2
  802f1b:	e8 e9 b8 00 00       	call   80e809 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802f20:	83 ec 04             	sub    $0x4,%esp
  802f23:	68 34 1c 81 00       	push   $0x811c34
  802f28:	68 6b 05 00 00       	push   $0x56b
  802f2d:	68 e2 1c 81 00       	push   $0x811ce2
  802f32:	e8 d2 b8 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802f37:	83 ec 04             	sub    $0x4,%esp
  802f3a:	68 58 1c 81 00       	push   $0x811c58
  802f3f:	68 6c 05 00 00       	push   $0x56c
  802f44:	68 e2 1c 81 00       	push   $0x811ce2
  802f49:	e8 bb b8 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802f4e:	83 ec 04             	sub    $0x4,%esp
  802f51:	68 84 1c 81 00       	push   $0x811c84
  802f56:	68 6d 05 00 00       	push   $0x56d
  802f5b:	68 e2 1c 81 00       	push   $0x811ce2
  802f60:	e8 a4 b8 00 00       	call   80e809 <_panic>

00802f65 <dhcp_rebind>:
{
  802f65:	55                   	push   %ebp
  802f66:	89 e5                	mov    %esp,%ebp
  802f68:	57                   	push   %edi
  802f69:	56                   	push   %esi
  802f6a:	53                   	push   %ebx
  802f6b:	83 ec 0c             	sub    $0xc,%esp
  802f6e:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802f70:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802f73:	ba 04 00 00 00       	mov    $0x4,%edx
  802f78:	89 d8                	mov    %ebx,%eax
  802f7a:	e8 cc f9 ff ff       	call   80294b <dhcp_set_state>
  result = dhcp_create_request(netif);
  802f7f:	89 f8                	mov    %edi,%eax
  802f81:	e8 52 fd ff ff       	call   802cd8 <dhcp_create_request>
  802f86:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f88:	84 c0                	test   %al,%al
  802f8a:	74 3e                	je     802fca <dhcp_rebind+0x65>
  dhcp->tries++;
  802f8c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f90:	83 c0 01             	add    $0x1,%eax
  802f93:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802f96:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f9b:	3c 09                	cmp    $0x9,%al
  802f9d:	77 08                	ja     802fa7 <dhcp_rebind+0x42>
  802f9f:	0f b6 d0             	movzbl %al,%edx
  802fa2:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802fa7:	0f b7 d2             	movzwl %dx,%edx
  802faa:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802fb0:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802fb5:	89 d0                	mov    %edx,%eax
  802fb7:	f7 e9                	imul   %ecx
  802fb9:	c1 fa 05             	sar    $0x5,%edx
  802fbc:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802fc0:	89 f0                	mov    %esi,%eax
  802fc2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802fc5:	5b                   	pop    %ebx
  802fc6:	5e                   	pop    %esi
  802fc7:	5f                   	pop    %edi
  802fc8:	5d                   	pop    %ebp
  802fc9:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802fca:	b9 01 00 00 00       	mov    $0x1,%ecx
  802fcf:	ba 35 00 00 00       	mov    $0x35,%edx
  802fd4:	89 d8                	mov    %ebx,%eax
  802fd6:	e8 eb fa ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802fdb:	ba 03 00 00 00       	mov    $0x3,%edx
  802fe0:	89 d8                	mov    %ebx,%eax
  802fe2:	e8 9e fa ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802fe7:	b9 02 00 00 00       	mov    $0x2,%ecx
  802fec:	ba 39 00 00 00       	mov    $0x39,%edx
  802ff1:	89 d8                	mov    %ebx,%eax
  802ff3:	e8 ce fa ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802ff8:	ba 40 02 00 00       	mov    $0x240,%edx
  802ffd:	89 d8                	mov    %ebx,%eax
  802fff:	e8 29 fb ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803004:	89 d8                	mov    %ebx,%eax
  803006:	e8 80 fb ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80300b:	83 ec 08             	sub    $0x8,%esp
  80300e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803012:	66 05 f0 00          	add    $0xf0,%ax
  803016:	0f b7 c0             	movzwl %ax,%eax
  803019:	50                   	push   %eax
  80301a:	ff 73 1c             	pushl  0x1c(%ebx)
  80301d:	e8 0a 1d 00 00       	call   804d2c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803022:	83 c4 0c             	add    $0xc,%esp
  803025:	6a 43                	push   $0x43
  803027:	68 88 25 81 00       	push   $0x812588
  80302c:	ff 73 08             	pushl  0x8(%ebx)
  80302f:	e8 ad 60 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803034:	89 3c 24             	mov    %edi,(%esp)
  803037:	6a 43                	push   $0x43
  803039:	68 84 25 81 00       	push   $0x812584
  80303e:	ff 73 1c             	pushl  0x1c(%ebx)
  803041:	ff 73 08             	pushl  0x8(%ebx)
  803044:	e8 a3 5e 00 00       	call   808eec <udp_sendto_if>
    dhcp_delete_request(netif);
  803049:	83 c4 20             	add    $0x20,%esp
  80304c:	89 f8                	mov    %edi,%eax
  80304e:	e8 78 fe ff ff       	call   802ecb <dhcp_delete_request>
  803053:	e9 34 ff ff ff       	jmp    802f8c <dhcp_rebind+0x27>

00803058 <dhcp_discover>:
{
  803058:	55                   	push   %ebp
  803059:	89 e5                	mov    %esp,%ebp
  80305b:	57                   	push   %edi
  80305c:	56                   	push   %esi
  80305d:	53                   	push   %ebx
  80305e:	83 ec 0c             	sub    $0xc,%esp
  803061:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803063:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  803066:	a1 88 25 81 00       	mov    0x812588,%eax
  80306b:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  80306e:	89 f8                	mov    %edi,%eax
  803070:	e8 63 fc ff ff       	call   802cd8 <dhcp_create_request>
  803075:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803077:	84 c0                	test   %al,%al
  803079:	74 41                	je     8030bc <dhcp_discover+0x64>
  dhcp->tries++;
  80307b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80307f:	83 c0 01             	add    $0x1,%eax
  803082:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  803085:	ba 10 27 00 00       	mov    $0x2710,%edx
  80308a:	3c 03                	cmp    $0x3,%al
  80308c:	77 0b                	ja     803099 <dhcp_discover+0x41>
  80308e:	0f b6 d0             	movzbl %al,%edx
  803091:	83 c2 01             	add    $0x1,%edx
  803094:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803099:	0f b7 d2             	movzwl %dx,%edx
  80309c:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8030a2:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8030a7:	89 d0                	mov    %edx,%eax
  8030a9:	f7 e9                	imul   %ecx
  8030ab:	c1 fa 05             	sar    $0x5,%edx
  8030ae:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8030b2:	89 f0                	mov    %esi,%eax
  8030b4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8030b7:	5b                   	pop    %ebx
  8030b8:	5e                   	pop    %esi
  8030b9:	5f                   	pop    %edi
  8030ba:	5d                   	pop    %ebp
  8030bb:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8030bc:	b9 01 00 00 00       	mov    $0x1,%ecx
  8030c1:	ba 35 00 00 00       	mov    $0x35,%edx
  8030c6:	89 d8                	mov    %ebx,%eax
  8030c8:	e8 f9 f9 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  8030cd:	ba 01 00 00 00       	mov    $0x1,%edx
  8030d2:	89 d8                	mov    %ebx,%eax
  8030d4:	e8 ac f9 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8030d9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8030de:	ba 39 00 00 00       	mov    $0x39,%edx
  8030e3:	89 d8                	mov    %ebx,%eax
  8030e5:	e8 dc f9 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8030ea:	ba 40 02 00 00       	mov    $0x240,%edx
  8030ef:	89 d8                	mov    %ebx,%eax
  8030f1:	e8 37 fa ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8030f6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030fb:	ba 37 00 00 00       	mov    $0x37,%edx
  803100:	89 d8                	mov    %ebx,%eax
  803102:	e8 bf f9 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803107:	ba 01 00 00 00       	mov    $0x1,%edx
  80310c:	89 d8                	mov    %ebx,%eax
  80310e:	e8 72 f9 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803113:	ba 03 00 00 00       	mov    $0x3,%edx
  803118:	89 d8                	mov    %ebx,%eax
  80311a:	e8 66 f9 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80311f:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803124:	89 d8                	mov    %ebx,%eax
  803126:	e8 5a f9 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80312b:	ba 06 00 00 00       	mov    $0x6,%edx
  803130:	89 d8                	mov    %ebx,%eax
  803132:	e8 4e f9 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803137:	89 d8                	mov    %ebx,%eax
  803139:	e8 4d fa ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80313e:	83 ec 08             	sub    $0x8,%esp
  803141:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803145:	66 05 f0 00          	add    $0xf0,%ax
  803149:	0f b7 c0             	movzwl %ax,%eax
  80314c:	50                   	push   %eax
  80314d:	ff 73 1c             	pushl  0x1c(%ebx)
  803150:	e8 d7 1b 00 00       	call   804d2c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803155:	83 c4 0c             	add    $0xc,%esp
  803158:	6a 43                	push   $0x43
  80315a:	68 88 25 81 00       	push   $0x812588
  80315f:	ff 73 08             	pushl  0x8(%ebx)
  803162:	e8 7a 5f 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803167:	89 3c 24             	mov    %edi,(%esp)
  80316a:	6a 43                	push   $0x43
  80316c:	68 84 25 81 00       	push   $0x812584
  803171:	ff 73 1c             	pushl  0x1c(%ebx)
  803174:	ff 73 08             	pushl  0x8(%ebx)
  803177:	e8 70 5d 00 00       	call   808eec <udp_sendto_if>
    dhcp_delete_request(netif);
  80317c:	83 c4 20             	add    $0x20,%esp
  80317f:	89 f8                	mov    %edi,%eax
  803181:	e8 45 fd ff ff       	call   802ecb <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  803186:	ba 06 00 00 00       	mov    $0x6,%edx
  80318b:	89 d8                	mov    %ebx,%eax
  80318d:	e8 b9 f7 ff ff       	call   80294b <dhcp_set_state>
  803192:	e9 e4 fe ff ff       	jmp    80307b <dhcp_discover+0x23>

00803197 <dhcp_select>:
{
  803197:	55                   	push   %ebp
  803198:	89 e5                	mov    %esp,%ebp
  80319a:	57                   	push   %edi
  80319b:	56                   	push   %esi
  80319c:	53                   	push   %ebx
  80319d:	83 ec 0c             	sub    $0xc,%esp
  8031a0:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8031a2:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  8031a5:	e8 2e fb ff ff       	call   802cd8 <dhcp_create_request>
  8031aa:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8031ac:	84 c0                	test   %al,%al
  8031ae:	74 3e                	je     8031ee <dhcp_select+0x57>
  dhcp->tries++;
  8031b0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8031b4:	83 c0 01             	add    $0x1,%eax
  8031b7:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8031ba:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8031bf:	3c 03                	cmp    $0x3,%al
  8031c1:	77 08                	ja     8031cb <dhcp_select+0x34>
  8031c3:	0f b6 d0             	movzbl %al,%edx
  8031c6:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8031cb:	0f b7 d2             	movzwl %dx,%edx
  8031ce:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8031d4:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8031d9:	89 d0                	mov    %edx,%eax
  8031db:	f7 e9                	imul   %ecx
  8031dd:	c1 fa 05             	sar    $0x5,%edx
  8031e0:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  8031e4:	89 f0                	mov    %esi,%eax
  8031e6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8031e9:	5b                   	pop    %ebx
  8031ea:	5e                   	pop    %esi
  8031eb:	5f                   	pop    %edi
  8031ec:	5d                   	pop    %ebp
  8031ed:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8031ee:	b9 01 00 00 00       	mov    $0x1,%ecx
  8031f3:	ba 35 00 00 00       	mov    $0x35,%edx
  8031f8:	89 d8                	mov    %ebx,%eax
  8031fa:	e8 c7 f8 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8031ff:	ba 03 00 00 00       	mov    $0x3,%edx
  803204:	89 d8                	mov    %ebx,%eax
  803206:	e8 7a f8 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80320b:	b9 02 00 00 00       	mov    $0x2,%ecx
  803210:	ba 39 00 00 00       	mov    $0x39,%edx
  803215:	89 d8                	mov    %ebx,%eax
  803217:	e8 aa f8 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80321c:	ba 40 02 00 00       	mov    $0x240,%edx
  803221:	89 d8                	mov    %ebx,%eax
  803223:	e8 05 f9 ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803228:	b9 04 00 00 00       	mov    $0x4,%ecx
  80322d:	ba 32 00 00 00       	mov    $0x32,%edx
  803232:	89 d8                	mov    %ebx,%eax
  803234:	e8 8d f8 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803239:	83 ec 0c             	sub    $0xc,%esp
  80323c:	ff 73 30             	pushl  0x30(%ebx)
  80323f:	e8 bb 48 00 00       	call   807aff <ntohl>
  803244:	89 c2                	mov    %eax,%edx
  803246:	89 d8                	mov    %ebx,%eax
  803248:	e8 f3 f9 ff ff       	call   802c40 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  80324d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803252:	ba 36 00 00 00       	mov    $0x36,%edx
  803257:	89 d8                	mov    %ebx,%eax
  803259:	e8 68 f8 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80325e:	83 c4 04             	add    $0x4,%esp
  803261:	ff 73 2c             	pushl  0x2c(%ebx)
  803264:	e8 96 48 00 00       	call   807aff <ntohl>
  803269:	89 c2                	mov    %eax,%edx
  80326b:	89 d8                	mov    %ebx,%eax
  80326d:	e8 ce f9 ff ff       	call   802c40 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803272:	b9 04 00 00 00       	mov    $0x4,%ecx
  803277:	ba 37 00 00 00       	mov    $0x37,%edx
  80327c:	89 d8                	mov    %ebx,%eax
  80327e:	e8 43 f8 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803283:	ba 01 00 00 00       	mov    $0x1,%edx
  803288:	89 d8                	mov    %ebx,%eax
  80328a:	e8 f6 f7 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80328f:	ba 03 00 00 00       	mov    $0x3,%edx
  803294:	89 d8                	mov    %ebx,%eax
  803296:	e8 ea f7 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80329b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8032a0:	89 d8                	mov    %ebx,%eax
  8032a2:	e8 de f7 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8032a7:	ba 06 00 00 00       	mov    $0x6,%edx
  8032ac:	89 d8                	mov    %ebx,%eax
  8032ae:	e8 d2 f7 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  8032b3:	89 d8                	mov    %ebx,%eax
  8032b5:	e8 d1 f8 ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8032ba:	83 c4 08             	add    $0x8,%esp
  8032bd:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8032c1:	66 05 f0 00          	add    $0xf0,%ax
  8032c5:	0f b7 c0             	movzwl %ax,%eax
  8032c8:	50                   	push   %eax
  8032c9:	ff 73 1c             	pushl  0x1c(%ebx)
  8032cc:	e8 5b 1a 00 00       	call   804d2c <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8032d1:	89 3c 24             	mov    %edi,(%esp)
  8032d4:	6a 43                	push   $0x43
  8032d6:	68 84 25 81 00       	push   $0x812584
  8032db:	ff 73 1c             	pushl  0x1c(%ebx)
  8032de:	ff 73 08             	pushl  0x8(%ebx)
  8032e1:	e8 06 5c 00 00       	call   808eec <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8032e6:	83 c4 1c             	add    $0x1c,%esp
  8032e9:	6a 43                	push   $0x43
  8032eb:	68 88 25 81 00       	push   $0x812588
  8032f0:	ff 73 08             	pushl  0x8(%ebx)
  8032f3:	e8 e9 5d 00 00       	call   8090e1 <udp_connect>
    dhcp_delete_request(netif);
  8032f8:	89 f8                	mov    %edi,%eax
  8032fa:	e8 cc fb ff ff       	call   802ecb <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8032ff:	ba 01 00 00 00       	mov    $0x1,%edx
  803304:	89 d8                	mov    %ebx,%eax
  803306:	e8 40 f6 ff ff       	call   80294b <dhcp_set_state>
  80330b:	83 c4 10             	add    $0x10,%esp
  80330e:	e9 9d fe ff ff       	jmp    8031b0 <dhcp_select+0x19>

00803313 <dhcp_check>:
{
  803313:	55                   	push   %ebp
  803314:	89 e5                	mov    %esp,%ebp
  803316:	53                   	push   %ebx
  803317:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  80331a:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80331d:	6a 00                	push   $0x0
  80331f:	8d 53 30             	lea    0x30(%ebx),%edx
  803322:	52                   	push   %edx
  803323:	50                   	push   %eax
  803324:	e8 ac 67 00 00       	call   809ad5 <etharp_query>
  dhcp->tries++;
  803329:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80332d:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  803333:	ba 08 00 00 00       	mov    $0x8,%edx
  803338:	89 d8                	mov    %ebx,%eax
  80333a:	e8 0c f6 ff ff       	call   80294b <dhcp_set_state>
}
  80333f:	83 c4 10             	add    $0x10,%esp
  803342:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803345:	c9                   	leave  
  803346:	c3                   	ret    

00803347 <dhcp_bind>:
{
  803347:	55                   	push   %ebp
  803348:	89 e5                	mov    %esp,%ebp
  80334a:	56                   	push   %esi
  80334b:	53                   	push   %ebx
  80334c:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80334f:	85 c0                	test   %eax,%eax
  803351:	0f 84 cf 00 00 00    	je     803426 <dhcp_bind+0xdf>
  803357:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  803359:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80335c:	85 db                	test   %ebx,%ebx
  80335e:	0f 84 d9 00 00 00    	je     80343d <dhcp_bind+0xf6>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  803364:	8b 53 50             	mov    0x50(%ebx),%edx
  803367:	83 fa ff             	cmp    $0xffffffff,%edx
  80336a:	74 2a                	je     803396 <dhcp_bind+0x4f>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80336c:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  80336f:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  803375:	0f 87 74 01 00 00    	ja     8034ef <dhcp_bind+0x1a8>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80337b:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803380:	89 d0                	mov    %edx,%eax
  803382:	f7 e1                	mul    %ecx
  803384:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t1_timeout == 0) {
  803387:	66 85 d2             	test   %dx,%dx
  80338a:	0f 85 c4 00 00 00    	jne    803454 <dhcp_bind+0x10d>
      dhcp->t1_timeout = 1;
  803390:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  803396:	8b 53 54             	mov    0x54(%ebx),%edx
  803399:	83 fa ff             	cmp    $0xffffffff,%edx
  80339c:	74 2a                	je     8033c8 <dhcp_bind+0x81>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80339e:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  8033a1:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  8033a7:	0f 87 37 01 00 00    	ja     8034e4 <dhcp_bind+0x19d>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8033ad:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8033b2:	89 d0                	mov    %edx,%eax
  8033b4:	f7 e1                	mul    %ecx
  8033b6:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t2_timeout == 0) {
  8033b9:	66 85 d2             	test   %dx,%dx
  8033bc:	0f 85 9b 00 00 00    	jne    80345d <dhcp_bind+0x116>
      dhcp->t2_timeout = 1;
  8033c2:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8033c8:	8b 43 34             	mov    0x34(%ebx),%eax
  8033cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  8033ce:	85 c0                	test   %eax,%eax
  8033d0:	0f 84 90 00 00 00    	je     803466 <dhcp_bind+0x11f>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8033d6:	8b 43 38             	mov    0x38(%ebx),%eax
  8033d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  8033dc:	85 c0                	test   %eax,%eax
  8033de:	0f 84 e2 00 00 00    	je     8034c6 <dhcp_bind+0x17f>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8033e4:	83 ec 08             	sub    $0x8,%esp
  8033e7:	8d 43 30             	lea    0x30(%ebx),%eax
  8033ea:	50                   	push   %eax
  8033eb:	56                   	push   %esi
  8033ec:	e8 73 13 00 00       	call   804764 <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  8033f1:	83 c4 08             	add    $0x8,%esp
  8033f4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8033f7:	50                   	push   %eax
  8033f8:	56                   	push   %esi
  8033f9:	e8 ab 14 00 00       	call   8048a9 <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  8033fe:	83 c4 08             	add    $0x8,%esp
  803401:	8d 45 f0             	lea    -0x10(%ebp),%eax
  803404:	50                   	push   %eax
  803405:	56                   	push   %esi
  803406:	e8 85 14 00 00       	call   804890 <netif_set_gw>
  netif_set_up(netif);
  80340b:	89 34 24             	mov    %esi,(%esp)
  80340e:	e8 bc 14 00 00       	call   8048cf <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  803413:	ba 0a 00 00 00       	mov    $0xa,%edx
  803418:	89 d8                	mov    %ebx,%eax
  80341a:	e8 2c f5 ff ff       	call   80294b <dhcp_set_state>
}
  80341f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803422:	5b                   	pop    %ebx
  803423:	5e                   	pop    %esi
  803424:	5d                   	pop    %ebp
  803425:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  803426:	83 ec 04             	sub    $0x4,%esp
  803429:	68 f7 1c 81 00       	push   $0x811cf7
  80342e:	68 3d 03 00 00       	push   $0x33d
  803433:	68 e2 1c 81 00       	push   $0x811ce2
  803438:	e8 cc b3 00 00       	call   80e809 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80343d:	83 ec 04             	sub    $0x4,%esp
  803440:	68 10 1d 81 00       	push   $0x811d10
  803445:	68 3f 03 00 00       	push   $0x33f
  80344a:	68 e2 1c 81 00       	push   $0x811ce2
  80344f:	e8 b5 b3 00 00       	call   80e809 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  803454:	66 89 53 28          	mov    %dx,0x28(%ebx)
  803458:	e9 39 ff ff ff       	jmp    803396 <dhcp_bind+0x4f>
    dhcp->t2_timeout = (u16_t)timeout;
  80345d:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  803461:	e9 62 ff ff ff       	jmp    8033c8 <dhcp_bind+0x81>
    u8_t first_octet = ip4_addr1(&sn_mask);
  803466:	83 ec 0c             	sub    $0xc,%esp
  803469:	6a 00                	push   $0x0
  80346b:	e8 8f 46 00 00       	call   807aff <ntohl>
  803470:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803473:	83 c4 10             	add    $0x10,%esp
  803476:	84 c0                	test   %al,%al
  803478:	79 1c                	jns    803496 <dhcp_bind+0x14f>
    } else if (first_octet >= 192) {
  80347a:	3c bf                	cmp    $0xbf,%al
  80347c:	76 30                	jbe    8034ae <dhcp_bind+0x167>
      sn_mask.addr = htonl(0xffffff00);
  80347e:	83 ec 0c             	sub    $0xc,%esp
  803481:	68 00 ff ff ff       	push   $0xffffff00
  803486:	e8 5d 44 00 00       	call   8078e8 <htonl>
  80348b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80348e:	83 c4 10             	add    $0x10,%esp
  803491:	e9 40 ff ff ff       	jmp    8033d6 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xff000000);
  803496:	83 ec 0c             	sub    $0xc,%esp
  803499:	68 00 00 00 ff       	push   $0xff000000
  80349e:	e8 45 44 00 00       	call   8078e8 <htonl>
  8034a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8034a6:	83 c4 10             	add    $0x10,%esp
  8034a9:	e9 28 ff ff ff       	jmp    8033d6 <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xffff0000);
  8034ae:	83 ec 0c             	sub    $0xc,%esp
  8034b1:	68 00 00 ff ff       	push   $0xffff0000
  8034b6:	e8 2d 44 00 00       	call   8078e8 <htonl>
  8034bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8034be:	83 c4 10             	add    $0x10,%esp
  8034c1:	e9 10 ff ff ff       	jmp    8033d6 <dhcp_bind+0x8f>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8034c6:	8b 43 30             	mov    0x30(%ebx),%eax
  8034c9:	23 45 f4             	and    -0xc(%ebp),%eax
  8034cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  8034cf:	83 ec 0c             	sub    $0xc,%esp
  8034d2:	6a 01                	push   $0x1
  8034d4:	e8 0f 44 00 00       	call   8078e8 <htonl>
  8034d9:	09 45 f0             	or     %eax,-0x10(%ebp)
  8034dc:	83 c4 10             	add    $0x10,%esp
  8034df:	e9 00 ff ff ff       	jmp    8033e4 <dhcp_bind+0x9d>
    dhcp->t2_timeout = (u16_t)timeout;
  8034e4:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  8034ea:	e9 d9 fe ff ff       	jmp    8033c8 <dhcp_bind+0x81>
    dhcp->t1_timeout = (u16_t)timeout;
  8034ef:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  8034f5:	e9 9c fe ff ff       	jmp    803396 <dhcp_bind+0x4f>

008034fa <dhcp_free_reply>:
{
  8034fa:	55                   	push   %ebp
  8034fb:	89 e5                	mov    %esp,%ebp
  8034fd:	53                   	push   %ebx
  8034fe:	83 ec 04             	sub    $0x4,%esp
  803501:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803503:	8b 40 10             	mov    0x10(%eax),%eax
  803506:	85 c0                	test   %eax,%eax
  803508:	74 13                	je     80351d <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  80350a:	83 ec 0c             	sub    $0xc,%esp
  80350d:	50                   	push   %eax
  80350e:	e8 fb 0b 00 00       	call   80410e <mem_free>
    dhcp->msg_in = NULL;
  803513:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80351a:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  80351d:	8b 43 14             	mov    0x14(%ebx),%eax
  803520:	85 c0                	test   %eax,%eax
  803522:	74 19                	je     80353d <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  803524:	83 ec 0c             	sub    $0xc,%esp
  803527:	50                   	push   %eax
  803528:	e8 e1 0b 00 00       	call   80410e <mem_free>
    dhcp->options_in = NULL;
  80352d:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803534:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  80353a:	83 c4 10             	add    $0x10,%esp
}
  80353d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803540:	c9                   	leave  
  803541:	c3                   	ret    

00803542 <dhcp_recv>:
{
  803542:	55                   	push   %ebp
  803543:	89 e5                	mov    %esp,%ebp
  803545:	57                   	push   %edi
  803546:	56                   	push   %esi
  803547:	53                   	push   %ebx
  803548:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  80354b:	8b 45 08             	mov    0x8(%ebp),%eax
  80354e:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  803551:	8b 45 10             	mov    0x10(%ebp),%eax
  803554:	8b 70 04             	mov    0x4(%eax),%esi
  803557:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  80355a:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80355d:	80 3e 02             	cmpb   $0x2,(%esi)
  803560:	75 26                	jne    803588 <dhcp_recv+0x46>
  803562:	8b 45 08             	mov    0x8(%ebp),%eax
  803565:	83 c0 25             	add    $0x25,%eax
  803568:	8d 56 1c             	lea    0x1c(%esi),%edx
  80356b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80356e:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803572:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  803574:	39 f0                	cmp    %esi,%eax
  803576:	74 2a                	je     8035a2 <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803578:	0f b6 18             	movzbl (%eax),%ebx
  80357b:	0f b6 0a             	movzbl (%edx),%ecx
  80357e:	83 c0 01             	add    $0x1,%eax
  803581:	83 c2 01             	add    $0x1,%edx
  803584:	38 cb                	cmp    %cl,%bl
  803586:	74 ec                	je     803574 <dhcp_recv+0x32>
  pbuf_free(p);
  803588:	83 ec 0c             	sub    $0xc,%esp
  80358b:	ff 75 10             	pushl  0x10(%ebp)
  80358e:	e8 61 14 00 00       	call   8049f4 <pbuf_free>
  dhcp->p = NULL;
  803593:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  80359a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80359d:	5b                   	pop    %ebx
  80359e:	5e                   	pop    %esi
  80359f:	5f                   	pop    %edi
  8035a0:	5d                   	pop    %ebp
  8035a1:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8035a2:	83 ec 0c             	sub    $0xc,%esp
  8035a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8035a8:	ff 70 04             	pushl  0x4(%eax)
  8035ab:	e8 4f 45 00 00       	call   807aff <ntohl>
  8035b0:	83 c4 10             	add    $0x10,%esp
  8035b3:	3b 47 04             	cmp    0x4(%edi),%eax
  8035b6:	75 d0                	jne    803588 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8035b8:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  8035bc:	0f 84 20 01 00 00    	je     8036e2 <dhcp_recv+0x1a0>
  dhcp_free_reply(dhcp);
  8035c2:	89 f8                	mov    %edi,%eax
  8035c4:	e8 31 ff ff ff       	call   8034fa <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8035c9:	8b 47 0c             	mov    0xc(%edi),%eax
  8035cc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8035d0:	66 3d f0 00          	cmp    $0xf0,%ax
  8035d4:	76 1e                	jbe    8035f4 <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035d6:	66 2d f0 00          	sub    $0xf0,%ax
  8035da:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8035de:	83 ec 0c             	sub    $0xc,%esp
  8035e1:	0f b7 c0             	movzwl %ax,%eax
  8035e4:	50                   	push   %eax
  8035e5:	e8 13 0e 00 00       	call   8043fd <mem_malloc>
  8035ea:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  8035ed:	83 c4 10             	add    $0x10,%esp
  8035f0:	85 c0                	test   %eax,%eax
  8035f2:	74 94                	je     803588 <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035f4:	83 ec 0c             	sub    $0xc,%esp
  8035f7:	68 f0 00 00 00       	push   $0xf0
  8035fc:	e8 fc 0d 00 00       	call   8043fd <mem_malloc>
  803601:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  803604:	83 c4 10             	add    $0x10,%esp
  803607:	85 c0                	test   %eax,%eax
  803609:	0f 84 ea 00 00 00    	je     8036f9 <dhcp_recv+0x1b7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80360f:	6a 00                	push   $0x0
  803611:	68 f0 00 00 00       	push   $0xf0
  803616:	50                   	push   %eax
  803617:	ff 77 0c             	pushl  0xc(%edi)
  80361a:	e8 51 1b 00 00       	call   805170 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80361f:	83 c4 10             	add    $0x10,%esp
  803622:	66 3d f0 00          	cmp    $0xf0,%ax
  803626:	0f 85 e7 00 00 00    	jne    803713 <dhcp_recv+0x1d1>
  if (dhcp->options_in != NULL) {
  80362c:	8b 47 14             	mov    0x14(%edi),%eax
  80362f:	85 c0                	test   %eax,%eax
  803631:	74 20                	je     803653 <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803633:	68 f0 00 00 00       	push   $0xf0
  803638:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  80363c:	52                   	push   %edx
  80363d:	50                   	push   %eax
  80363e:	ff 77 0c             	pushl  0xc(%edi)
  803641:	e8 2a 1b 00 00       	call   805170 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  803646:	83 c4 10             	add    $0x10,%esp
  803649:	66 3b 47 18          	cmp    0x18(%edi),%ax
  80364d:	0f 85 d7 00 00 00    	jne    80372a <dhcp_recv+0x1e8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803653:	ba 35 00 00 00       	mov    $0x35,%edx
  803658:	89 f8                	mov    %edi,%eax
  80365a:	e8 f7 f2 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  80365f:	85 c0                	test   %eax,%eax
  803661:	0f 84 21 ff ff ff    	je     803588 <dhcp_recv+0x46>
  return *ptr;
  803667:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  80366b:	3c 05                	cmp    $0x5,%al
  80366d:	0f 84 ce 00 00 00    	je     803741 <dhcp_recv+0x1ff>
  else if ((msg_type == DHCP_NAK) &&
  803673:	3c 06                	cmp    $0x6,%al
  803675:	0f 84 6e 02 00 00    	je     8038e9 <dhcp_recv+0x3a7>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80367b:	3c 02                	cmp    $0x2,%al
  80367d:	0f 85 05 ff ff ff    	jne    803588 <dhcp_recv+0x46>
  803683:	80 3f 06             	cmpb   $0x6,(%edi)
  803686:	0f 85 fc fe ff ff    	jne    803588 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  80368c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803692:	8b 45 08             	mov    0x8(%ebp),%eax
  803695:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803698:	ba 36 00 00 00       	mov    $0x36,%edx
  80369d:	89 d8                	mov    %ebx,%eax
  80369f:	e8 b2 f2 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036a4:	85 c0                	test   %eax,%eax
  8036a6:	0f 84 dc fe ff ff    	je     803588 <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036ac:	83 c0 02             	add    $0x2,%eax
  8036af:	e8 b0 f3 ff ff       	call   802a64 <dhcp_get_option_long>
  8036b4:	83 ec 0c             	sub    $0xc,%esp
  8036b7:	50                   	push   %eax
  8036b8:	e8 2b 42 00 00       	call   8078e8 <htonl>
  8036bd:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8036c0:	8b 43 10             	mov    0x10(%ebx),%eax
  8036c3:	83 c4 10             	add    $0x10,%esp
  8036c6:	83 f8 f0             	cmp    $0xfffffff0,%eax
  8036c9:	0f 84 8e 02 00 00    	je     80395d <dhcp_recv+0x41b>
  8036cf:	8b 40 10             	mov    0x10(%eax),%eax
  8036d2:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  8036d5:	8b 45 08             	mov    0x8(%ebp),%eax
  8036d8:	e8 ba fa ff ff       	call   803197 <dhcp_select>
  8036dd:	e9 a6 fe ff ff       	jmp    803588 <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8036e2:	83 ec 04             	sub    $0x4,%esp
  8036e5:	68 28 1d 81 00       	push   $0x811d28
  8036ea:	68 8a 04 00 00       	push   $0x48a
  8036ef:	68 e2 1c 81 00       	push   $0x811ce2
  8036f4:	e8 10 b1 00 00       	call   80e809 <_panic>
    mem_free((void *)dhcp->options_in);
  8036f9:	83 ec 0c             	sub    $0xc,%esp
  8036fc:	ff 77 14             	pushl  0x14(%edi)
  8036ff:	e8 0a 0a 00 00       	call   80410e <mem_free>
    dhcp->options_in = NULL;
  803704:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
  80370b:	83 c4 10             	add    $0x10,%esp
  80370e:	e9 75 fe ff ff       	jmp    803588 <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803713:	83 ec 04             	sub    $0x4,%esp
  803716:	68 b0 1c 81 00       	push   $0x811cb0
  80371b:	68 a0 04 00 00       	push   $0x4a0
  803720:	68 e2 1c 81 00       	push   $0x811ce2
  803725:	e8 df b0 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80372a:	83 ec 04             	sub    $0x4,%esp
  80372d:	68 38 1d 81 00       	push   $0x811d38
  803732:	68 a7 04 00 00       	push   $0x4a7
  803737:	68 e2 1c 81 00       	push   $0x811ce2
  80373c:	e8 c8 b0 00 00       	call   80e809 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  803741:	0f b6 07             	movzbl (%edi),%eax
  803744:	3c 01                	cmp    $0x1,%al
  803746:	74 1e                	je     803766 <dhcp_recv+0x224>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803748:	83 e8 03             	sub    $0x3,%eax
  80374b:	3c 02                	cmp    $0x2,%al
  80374d:	0f 87 35 fe ff ff    	ja     803588 <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  803753:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  803759:	8b 45 08             	mov    0x8(%ebp),%eax
  80375c:	e8 e6 fb ff ff       	call   803347 <dhcp_bind>
  803761:	e9 22 fe ff ff       	jmp    803588 <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  803766:	8b 45 08             	mov    0x8(%ebp),%eax
  803769:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  80376c:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803773:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  80377a:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803781:	ba 33 00 00 00       	mov    $0x33,%edx
  803786:	89 f0                	mov    %esi,%eax
  803788:	e8 c9 f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80378d:	85 c0                	test   %eax,%eax
  80378f:	74 0b                	je     80379c <dhcp_recv+0x25a>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803791:	83 c0 02             	add    $0x2,%eax
  803794:	e8 cb f2 ff ff       	call   802a64 <dhcp_get_option_long>
  803799:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80379c:	ba 3a 00 00 00       	mov    $0x3a,%edx
  8037a1:	89 f0                	mov    %esi,%eax
  8037a3:	e8 ae f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037a8:	85 c0                	test   %eax,%eax
  8037aa:	0f 84 e7 00 00 00    	je     803897 <dhcp_recv+0x355>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8037b0:	83 c0 02             	add    $0x2,%eax
  8037b3:	e8 ac f2 ff ff       	call   802a64 <dhcp_get_option_long>
  8037b8:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8037bb:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8037c0:	89 f0                	mov    %esi,%eax
  8037c2:	e8 8f f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037c7:	85 c0                	test   %eax,%eax
  8037c9:	0f 84 d2 00 00 00    	je     8038a1 <dhcp_recv+0x35f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8037cf:	83 c0 02             	add    $0x2,%eax
  8037d2:	e8 8d f2 ff ff       	call   802a64 <dhcp_get_option_long>
  8037d7:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8037da:	8b 56 10             	mov    0x10(%esi),%edx
  8037dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8037e2:	83 fa f0             	cmp    $0xfffffff0,%edx
  8037e5:	74 03                	je     8037ea <dhcp_recv+0x2a8>
  8037e7:	8b 42 10             	mov    0x10(%edx),%eax
  8037ea:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8037ed:	ba 01 00 00 00       	mov    $0x1,%edx
  8037f2:	89 f0                	mov    %esi,%eax
  8037f4:	e8 5d f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8037f9:	85 c0                	test   %eax,%eax
  8037fb:	74 17                	je     803814 <dhcp_recv+0x2d2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8037fd:	83 c0 02             	add    $0x2,%eax
  803800:	e8 5f f2 ff ff       	call   802a64 <dhcp_get_option_long>
  803805:	83 ec 0c             	sub    $0xc,%esp
  803808:	50                   	push   %eax
  803809:	e8 da 40 00 00       	call   8078e8 <htonl>
  80380e:	89 46 34             	mov    %eax,0x34(%esi)
  803811:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803814:	ba 03 00 00 00       	mov    $0x3,%edx
  803819:	89 f0                	mov    %esi,%eax
  80381b:	e8 36 f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803820:	85 c0                	test   %eax,%eax
  803822:	74 17                	je     80383b <dhcp_recv+0x2f9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803824:	83 c0 02             	add    $0x2,%eax
  803827:	e8 38 f2 ff ff       	call   802a64 <dhcp_get_option_long>
  80382c:	83 ec 0c             	sub    $0xc,%esp
  80382f:	50                   	push   %eax
  803830:	e8 b3 40 00 00       	call   8078e8 <htonl>
  803835:	89 46 38             	mov    %eax,0x38(%esi)
  803838:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80383b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803840:	89 f0                	mov    %esi,%eax
  803842:	e8 0f f1 ff ff       	call   802956 <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803847:	85 c0                	test   %eax,%eax
  803849:	74 17                	je     803862 <dhcp_recv+0x320>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80384b:	83 c0 02             	add    $0x2,%eax
  80384e:	e8 11 f2 ff ff       	call   802a64 <dhcp_get_option_long>
  803853:	83 ec 0c             	sub    $0xc,%esp
  803856:	50                   	push   %eax
  803857:	e8 8c 40 00 00       	call   8078e8 <htonl>
  80385c:	89 46 3c             	mov    %eax,0x3c(%esi)
  80385f:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803862:	ba 06 00 00 00       	mov    $0x6,%edx
  803867:	89 f0                	mov    %esi,%eax
  803869:	e8 e8 f0 ff ff       	call   802956 <dhcp_get_option_ptr>
  80386e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803871:	85 c0                	test   %eax,%eax
  803873:	74 61                	je     8038d6 <dhcp_recv+0x394>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803875:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803879:	c0 e8 02             	shr    $0x2,%al
  80387c:	0f b6 c0             	movzbl %al,%eax
  80387f:	83 f8 02             	cmp    $0x2,%eax
  803882:	ba 02 00 00 00       	mov    $0x2,%edx
  803887:	0f 47 c2             	cmova  %edx,%eax
  80388a:	89 46 40             	mov    %eax,0x40(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  80388d:	bb 00 00 00 00       	mov    $0x0,%ebx
  803892:	89 7d e0             	mov    %edi,-0x20(%ebp)
  803895:	eb 34                	jmp    8038cb <dhcp_recv+0x389>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803897:	8b 46 4c             	mov    0x4c(%esi),%eax
  80389a:	d1 e8                	shr    %eax
  80389c:	e9 17 ff ff ff       	jmp    8037b8 <dhcp_recv+0x276>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8038a1:	8b 46 4c             	mov    0x4c(%esi),%eax
  8038a4:	e9 2e ff ff ff       	jmp    8037d7 <dhcp_recv+0x295>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  8038a9:	0f b6 fb             	movzbl %bl,%edi
  8038ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8038af:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  8038b3:	e8 ac f1 ff ff       	call   802a64 <dhcp_get_option_long>
  8038b8:	83 ec 0c             	sub    $0xc,%esp
  8038bb:	50                   	push   %eax
  8038bc:	e8 27 40 00 00       	call   8078e8 <htonl>
  8038c1:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  8038c5:	83 c3 01             	add    $0x1,%ebx
  8038c8:	83 c4 10             	add    $0x10,%esp
  8038cb:	0f b6 c3             	movzbl %bl,%eax
  8038ce:	3b 46 40             	cmp    0x40(%esi),%eax
  8038d1:	72 d6                	jb     8038a9 <dhcp_recv+0x367>
  8038d3:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  8038d6:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  8038dc:	8b 45 08             	mov    0x8(%ebp),%eax
  8038df:	e8 2f fa ff ff       	call   803313 <dhcp_check>
  8038e4:	e9 9f fc ff ff       	jmp    803588 <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8038e9:	0f b6 07             	movzbl (%edi),%eax
  8038ec:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  8038ef:	80 fa 02             	cmp    $0x2,%dl
  8038f2:	76 08                	jbe    8038fc <dhcp_recv+0x3ba>
  8038f4:	3c 01                	cmp    $0x1,%al
  8038f6:	0f 85 8c fc ff ff    	jne    803588 <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  8038fc:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803902:	8b 45 08             	mov    0x8(%ebp),%eax
  803905:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  803908:	83 ec 0c             	sub    $0xc,%esp
  80390b:	50                   	push   %eax
  80390c:	e8 f1 0f 00 00       	call   804902 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803911:	83 c4 08             	add    $0x8,%esp
  803914:	68 88 25 81 00       	push   $0x812588
  803919:	ff 75 08             	pushl  0x8(%ebp)
  80391c:	e8 43 0e 00 00       	call   804764 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803921:	83 c4 08             	add    $0x8,%esp
  803924:	68 88 25 81 00       	push   $0x812588
  803929:	ff 75 08             	pushl  0x8(%ebp)
  80392c:	e8 5f 0f 00 00       	call   804890 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803931:	83 c4 08             	add    $0x8,%esp
  803934:	68 88 25 81 00       	push   $0x812588
  803939:	ff 75 08             	pushl  0x8(%ebp)
  80393c:	e8 68 0f 00 00       	call   8048a9 <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803941:	ba 0c 00 00 00       	mov    $0xc,%edx
  803946:	89 d8                	mov    %ebx,%eax
  803948:	e8 fe ef ff ff       	call   80294b <dhcp_set_state>
  dhcp_discover(netif);
  80394d:	8b 45 08             	mov    0x8(%ebp),%eax
  803950:	e8 03 f7 ff ff       	call   803058 <dhcp_discover>
  803955:	83 c4 10             	add    $0x10,%esp
  803958:	e9 2b fc ff ff       	jmp    803588 <dhcp_recv+0x46>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  80395d:	b8 00 00 00 00       	mov    $0x0,%eax
  803962:	e9 6b fd ff ff       	jmp    8036d2 <dhcp_recv+0x190>

00803967 <dhcp_inform>:
{
  803967:	55                   	push   %ebp
  803968:	89 e5                	mov    %esp,%ebp
  80396a:	57                   	push   %edi
  80396b:	56                   	push   %esi
  80396c:	53                   	push   %ebx
  80396d:	83 ec 18             	sub    $0x18,%esp
  803970:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803973:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  803976:	6a 58                	push   $0x58
  803978:	e8 80 0a 00 00       	call   8043fd <mem_malloc>
  if (dhcp == NULL) {
  80397d:	83 c4 10             	add    $0x10,%esp
  803980:	85 c0                	test   %eax,%eax
  803982:	74 55                	je     8039d9 <dhcp_inform+0x72>
  803984:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  803986:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803989:	83 ec 04             	sub    $0x4,%esp
  80398c:	6a 58                	push   $0x58
  80398e:	6a 00                	push   $0x0
  803990:	50                   	push   %eax
  803991:	e8 0e b8 00 00       	call   80f1a4 <memset>
  dhcp->pcb = udp_new();
  803996:	e8 2a 58 00 00       	call   8091c5 <udp_new>
  80399b:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  80399e:	83 c4 10             	add    $0x10,%esp
  8039a1:	85 c0                	test   %eax,%eax
  8039a3:	74 3c                	je     8039e1 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  8039a5:	89 f0                	mov    %esi,%eax
  8039a7:	e8 2c f3 ff ff       	call   802cd8 <dhcp_create_request>
  if (result == ERR_OK) {
  8039ac:	84 c0                	test   %al,%al
  8039ae:	74 3f                	je     8039ef <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  8039b0:	8b 43 08             	mov    0x8(%ebx),%eax
  8039b3:	85 c0                	test   %eax,%eax
  8039b5:	74 0c                	je     8039c3 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  8039b7:	83 ec 0c             	sub    $0xc,%esp
  8039ba:	50                   	push   %eax
  8039bb:	e8 c1 57 00 00       	call   809181 <udp_remove>
  8039c0:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  8039c3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  8039ca:	83 ec 0c             	sub    $0xc,%esp
  8039cd:	53                   	push   %ebx
  8039ce:	e8 3b 07 00 00       	call   80410e <mem_free>
    netif->dhcp = old_dhcp;
  8039d3:	89 7e 20             	mov    %edi,0x20(%esi)
  8039d6:	83 c4 10             	add    $0x10,%esp
}
  8039d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8039dc:	5b                   	pop    %ebx
  8039dd:	5e                   	pop    %esi
  8039de:	5f                   	pop    %edi
  8039df:	5d                   	pop    %ebp
  8039e0:	c3                   	ret    
    mem_free((void *)dhcp);
  8039e1:	83 ec 0c             	sub    $0xc,%esp
  8039e4:	53                   	push   %ebx
  8039e5:	e8 24 07 00 00       	call   80410e <mem_free>
    return;
  8039ea:	83 c4 10             	add    $0x10,%esp
  8039ed:	eb ea                	jmp    8039d9 <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8039ef:	b9 01 00 00 00       	mov    $0x1,%ecx
  8039f4:	ba 35 00 00 00       	mov    $0x35,%edx
  8039f9:	89 d8                	mov    %ebx,%eax
  8039fb:	e8 c6 f0 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803a00:	ba 08 00 00 00       	mov    $0x8,%edx
  803a05:	89 d8                	mov    %ebx,%eax
  803a07:	e8 79 f0 ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803a0c:	b9 02 00 00 00       	mov    $0x2,%ecx
  803a11:	ba 39 00 00 00       	mov    $0x39,%edx
  803a16:	89 d8                	mov    %ebx,%eax
  803a18:	e8 a9 f0 ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803a1d:	ba 40 02 00 00       	mov    $0x240,%edx
  803a22:	89 d8                	mov    %ebx,%eax
  803a24:	e8 04 f1 ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803a29:	89 d8                	mov    %ebx,%eax
  803a2b:	e8 5b f1 ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a30:	83 ec 08             	sub    $0x8,%esp
  803a33:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a37:	66 05 f0 00          	add    $0xf0,%ax
  803a3b:	0f b7 c0             	movzwl %ax,%eax
  803a3e:	50                   	push   %eax
  803a3f:	ff 73 1c             	pushl  0x1c(%ebx)
  803a42:	e8 e5 12 00 00       	call   804d2c <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803a47:	83 c4 0c             	add    $0xc,%esp
  803a4a:	6a 44                	push   $0x44
  803a4c:	68 88 25 81 00       	push   $0x812588
  803a51:	ff 73 08             	pushl  0x8(%ebx)
  803a54:	e8 d8 53 00 00       	call   808e31 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803a59:	83 c4 0c             	add    $0xc,%esp
  803a5c:	6a 43                	push   $0x43
  803a5e:	68 84 25 81 00       	push   $0x812584
  803a63:	ff 73 08             	pushl  0x8(%ebx)
  803a66:	e8 76 56 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803a6b:	89 34 24             	mov    %esi,(%esp)
  803a6e:	6a 43                	push   $0x43
  803a70:	68 84 25 81 00       	push   $0x812584
  803a75:	ff 73 1c             	pushl  0x1c(%ebx)
  803a78:	ff 73 08             	pushl  0x8(%ebx)
  803a7b:	e8 6c 54 00 00       	call   808eec <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a80:	83 c4 1c             	add    $0x1c,%esp
  803a83:	6a 43                	push   $0x43
  803a85:	68 88 25 81 00       	push   $0x812588
  803a8a:	ff 73 08             	pushl  0x8(%ebx)
  803a8d:	e8 4f 56 00 00       	call   8090e1 <udp_connect>
    dhcp_delete_request(netif);
  803a92:	89 f0                	mov    %esi,%eax
  803a94:	e8 32 f4 ff ff       	call   802ecb <dhcp_delete_request>
  803a99:	83 c4 10             	add    $0x10,%esp
  803a9c:	e9 0f ff ff ff       	jmp    8039b0 <dhcp_inform+0x49>

00803aa1 <dhcp_arp_reply>:
{
  803aa1:	55                   	push   %ebp
  803aa2:	89 e5                	mov    %esp,%ebp
  803aa4:	56                   	push   %esi
  803aa5:	53                   	push   %ebx
  803aa6:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803aa9:	85 f6                	test   %esi,%esi
  803aab:	74 13                	je     803ac0 <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803aad:	8b 5e 20             	mov    0x20(%esi),%ebx
  803ab0:	85 db                	test   %ebx,%ebx
  803ab2:	74 05                	je     803ab9 <dhcp_arp_reply+0x18>
  803ab4:	80 3b 08             	cmpb   $0x8,(%ebx)
  803ab7:	74 1e                	je     803ad7 <dhcp_arp_reply+0x36>
}
  803ab9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803abc:	5b                   	pop    %ebx
  803abd:	5e                   	pop    %esi
  803abe:	5d                   	pop    %ebp
  803abf:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803ac0:	83 ec 04             	sub    $0x4,%esp
  803ac3:	68 02 1d 81 00       	push   $0x811d02
  803ac8:	68 b5 02 00 00       	push   $0x2b5
  803acd:	68 e2 1c 81 00       	push   $0x811ce2
  803ad2:	e8 32 ad 00 00       	call   80e809 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803ad7:	8b 45 0c             	mov    0xc(%ebp),%eax
  803ada:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803add:	39 08                	cmp    %ecx,(%eax)
  803adf:	75 d8                	jne    803ab9 <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803ae1:	ba 0c 00 00 00       	mov    $0xc,%edx
  803ae6:	89 d8                	mov    %ebx,%eax
  803ae8:	e8 5e ee ff ff       	call   80294b <dhcp_set_state>
  result = dhcp_create_request(netif);
  803aed:	89 f0                	mov    %esi,%eax
  803aef:	e8 e4 f1 ff ff       	call   802cd8 <dhcp_create_request>
  if (result == ERR_OK) {
  803af4:	84 c0                	test   %al,%al
  803af6:	74 0c                	je     803b04 <dhcp_arp_reply+0x63>
  dhcp->tries++;
  803af8:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803afc:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  803b02:	eb b5                	jmp    803ab9 <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803b04:	b9 01 00 00 00       	mov    $0x1,%ecx
  803b09:	ba 35 00 00 00       	mov    $0x35,%edx
  803b0e:	89 d8                	mov    %ebx,%eax
  803b10:	e8 b1 ef ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803b15:	ba 04 00 00 00       	mov    $0x4,%edx
  803b1a:	89 d8                	mov    %ebx,%eax
  803b1c:	e8 64 ef ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803b21:	b9 02 00 00 00       	mov    $0x2,%ecx
  803b26:	ba 39 00 00 00       	mov    $0x39,%edx
  803b2b:	89 d8                	mov    %ebx,%eax
  803b2d:	e8 94 ef ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803b32:	ba 40 02 00 00       	mov    $0x240,%edx
  803b37:	89 d8                	mov    %ebx,%eax
  803b39:	e8 ef ef ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803b3e:	b9 04 00 00 00       	mov    $0x4,%ecx
  803b43:	ba 32 00 00 00       	mov    $0x32,%edx
  803b48:	89 d8                	mov    %ebx,%eax
  803b4a:	e8 77 ef ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803b4f:	83 ec 0c             	sub    $0xc,%esp
  803b52:	ff 73 30             	pushl  0x30(%ebx)
  803b55:	e8 a5 3f 00 00       	call   807aff <ntohl>
  803b5a:	89 c2                	mov    %eax,%edx
  803b5c:	89 d8                	mov    %ebx,%eax
  803b5e:	e8 dd f0 ff ff       	call   802c40 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  803b63:	89 d8                	mov    %ebx,%eax
  803b65:	e8 21 f0 ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803b6a:	83 c4 08             	add    $0x8,%esp
  803b6d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803b71:	66 05 f0 00          	add    $0xf0,%ax
  803b75:	0f b7 c0             	movzwl %ax,%eax
  803b78:	50                   	push   %eax
  803b79:	ff 73 1c             	pushl  0x1c(%ebx)
  803b7c:	e8 ab 11 00 00       	call   804d2c <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803b81:	83 c4 0c             	add    $0xc,%esp
  803b84:	6a 43                	push   $0x43
  803b86:	68 88 25 81 00       	push   $0x812588
  803b8b:	ff 73 08             	pushl  0x8(%ebx)
  803b8e:	e8 4e 55 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803b93:	89 34 24             	mov    %esi,(%esp)
  803b96:	6a 43                	push   $0x43
  803b98:	68 84 25 81 00       	push   $0x812584
  803b9d:	ff 73 1c             	pushl  0x1c(%ebx)
  803ba0:	ff 73 08             	pushl  0x8(%ebx)
  803ba3:	e8 44 53 00 00       	call   808eec <udp_sendto_if>
    dhcp_delete_request(netif);
  803ba8:	83 c4 20             	add    $0x20,%esp
  803bab:	89 f0                	mov    %esi,%eax
  803bad:	e8 19 f3 ff ff       	call   802ecb <dhcp_delete_request>
  803bb2:	e9 41 ff ff ff       	jmp    803af8 <dhcp_arp_reply+0x57>

00803bb7 <dhcp_renew>:
{
  803bb7:	55                   	push   %ebp
  803bb8:	89 e5                	mov    %esp,%ebp
  803bba:	57                   	push   %edi
  803bbb:	56                   	push   %esi
  803bbc:	53                   	push   %ebx
  803bbd:	83 ec 1c             	sub    $0x1c,%esp
  803bc0:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803bc3:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803bc6:	ba 05 00 00 00       	mov    $0x5,%edx
  803bcb:	89 d8                	mov    %ebx,%eax
  803bcd:	e8 79 ed ff ff       	call   80294b <dhcp_set_state>
  result = dhcp_create_request(netif);
  803bd2:	89 f0                	mov    %esi,%eax
  803bd4:	e8 ff f0 ff ff       	call   802cd8 <dhcp_create_request>
  803bd9:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803bdb:	84 c0                	test   %al,%al
  803bdd:	74 3e                	je     803c1d <dhcp_renew+0x66>
  dhcp->tries++;
  803bdf:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803be3:	83 c0 01             	add    $0x1,%eax
  803be6:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803be9:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803bee:	3c 09                	cmp    $0x9,%al
  803bf0:	77 08                	ja     803bfa <dhcp_renew+0x43>
  803bf2:	0f b6 d0             	movzbl %al,%edx
  803bf5:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803bfa:	0f b7 d2             	movzwl %dx,%edx
  803bfd:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803c03:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803c08:	89 d0                	mov    %edx,%eax
  803c0a:	f7 e9                	imul   %ecx
  803c0c:	c1 fa 05             	sar    $0x5,%edx
  803c0f:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803c13:	89 f8                	mov    %edi,%eax
  803c15:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803c18:	5b                   	pop    %ebx
  803c19:	5e                   	pop    %esi
  803c1a:	5f                   	pop    %edi
  803c1b:	5d                   	pop    %ebp
  803c1c:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c1d:	b9 01 00 00 00       	mov    $0x1,%ecx
  803c22:	ba 35 00 00 00       	mov    $0x35,%edx
  803c27:	89 d8                	mov    %ebx,%eax
  803c29:	e8 98 ee ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803c2e:	ba 03 00 00 00       	mov    $0x3,%edx
  803c33:	89 d8                	mov    %ebx,%eax
  803c35:	e8 4b ee ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803c3a:	b9 02 00 00 00       	mov    $0x2,%ecx
  803c3f:	ba 39 00 00 00       	mov    $0x39,%edx
  803c44:	89 d8                	mov    %ebx,%eax
  803c46:	e8 7b ee ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803c4b:	ba 40 02 00 00       	mov    $0x240,%edx
  803c50:	89 d8                	mov    %ebx,%eax
  803c52:	e8 d6 ee ff ff       	call   802b2d <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803c57:	89 d8                	mov    %ebx,%eax
  803c59:	e8 2d ef ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803c5e:	83 ec 08             	sub    $0x8,%esp
  803c61:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803c65:	66 05 f0 00          	add    $0xf0,%ax
  803c69:	0f b7 c0             	movzwl %ax,%eax
  803c6c:	50                   	push   %eax
  803c6d:	ff 73 1c             	pushl  0x1c(%ebx)
  803c70:	e8 b7 10 00 00       	call   804d2c <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803c75:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803c78:	83 c4 0c             	add    $0xc,%esp
  803c7b:	6a 43                	push   $0x43
  803c7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c80:	50                   	push   %eax
  803c81:	ff 73 08             	pushl  0x8(%ebx)
  803c84:	e8 58 54 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803c89:	89 34 24             	mov    %esi,(%esp)
  803c8c:	6a 43                	push   $0x43
  803c8e:	ff 75 e4             	pushl  -0x1c(%ebp)
  803c91:	ff 73 1c             	pushl  0x1c(%ebx)
  803c94:	ff 73 08             	pushl  0x8(%ebx)
  803c97:	e8 50 52 00 00       	call   808eec <udp_sendto_if>
    dhcp_delete_request(netif);
  803c9c:	83 c4 20             	add    $0x20,%esp
  803c9f:	89 f0                	mov    %esi,%eax
  803ca1:	e8 25 f2 ff ff       	call   802ecb <dhcp_delete_request>
  803ca6:	e9 34 ff ff ff       	jmp    803bdf <dhcp_renew+0x28>

00803cab <dhcp_coarse_tmr>:
{
  803cab:	55                   	push   %ebp
  803cac:	89 e5                	mov    %esp,%ebp
  803cae:	53                   	push   %ebx
  803caf:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803cb2:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  while (netif != NULL) {
  803cb8:	eb 1d                	jmp    803cd7 <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803cba:	8b 43 20             	mov    0x20(%ebx),%eax
  803cbd:	0f b6 00             	movzbl (%eax),%eax
  803cc0:	89 c2                	mov    %eax,%edx
  803cc2:	83 e2 fb             	and    $0xfffffffb,%edx
  803cc5:	80 fa 01             	cmp    $0x1,%dl
  803cc8:	74 04                	je     803cce <dhcp_coarse_tmr+0x23>
  803cca:	3c 0a                	cmp    $0xa,%al
  803ccc:	75 07                	jne    803cd5 <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803cce:	89 d8                	mov    %ebx,%eax
  803cd0:	e8 90 f2 ff ff       	call   802f65 <dhcp_rebind>
    netif = netif->next;
  803cd5:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803cd7:	85 db                	test   %ebx,%ebx
  803cd9:	74 4e                	je     803d29 <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803cdb:	8b 43 20             	mov    0x20(%ebx),%eax
  803cde:	85 c0                	test   %eax,%eax
  803ce0:	74 f3                	je     803cd5 <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803ce2:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803ce6:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803ce9:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803ced:	66 83 fa 01          	cmp    $0x1,%dx
  803cf1:	74 c7                	je     803cba <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803cf3:	8b 53 20             	mov    0x20(%ebx),%edx
  803cf6:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803cfa:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803cfd:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803d01:	66 83 f8 01          	cmp    $0x1,%ax
  803d05:	75 ce                	jne    803cd5 <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803d07:	8b 43 20             	mov    0x20(%ebx),%eax
  803d0a:	0f b6 00             	movzbl (%eax),%eax
  803d0d:	89 c2                	mov    %eax,%edx
  803d0f:	83 e2 fb             	and    $0xfffffffb,%edx
  803d12:	80 fa 01             	cmp    $0x1,%dl
  803d15:	74 04                	je     803d1b <dhcp_coarse_tmr+0x70>
  803d17:	3c 0a                	cmp    $0xa,%al
  803d19:	75 ba                	jne    803cd5 <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803d1b:	83 ec 0c             	sub    $0xc,%esp
  803d1e:	53                   	push   %ebx
  803d1f:	e8 93 fe ff ff       	call   803bb7 <dhcp_renew>
  803d24:	83 c4 10             	add    $0x10,%esp
  803d27:	eb ac                	jmp    803cd5 <dhcp_coarse_tmr+0x2a>
}
  803d29:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803d2c:	c9                   	leave  
  803d2d:	c3                   	ret    

00803d2e <dhcp_release>:
{
  803d2e:	55                   	push   %ebp
  803d2f:	89 e5                	mov    %esp,%ebp
  803d31:	57                   	push   %edi
  803d32:	56                   	push   %esi
  803d33:	53                   	push   %ebx
  803d34:	83 ec 1c             	sub    $0x1c,%esp
  803d37:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803d3a:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803d3d:	ba 0d 00 00 00       	mov    $0xd,%edx
  803d42:	89 d8                	mov    %ebx,%eax
  803d44:	e8 02 ec ff ff       	call   80294b <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803d49:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803d50:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803d57:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803d5e:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803d65:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803d6c:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803d73:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803d7a:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803d81:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803d88:	89 f0                	mov    %esi,%eax
  803d8a:	e8 49 ef ff ff       	call   802cd8 <dhcp_create_request>
  803d8f:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803d91:	84 c0                	test   %al,%al
  803d93:	74 71                	je     803e06 <dhcp_release+0xd8>
  dhcp->tries++;
  803d95:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803d99:	83 c0 01             	add    $0x1,%eax
  803d9c:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803d9f:	ba 10 27 00 00       	mov    $0x2710,%edx
  803da4:	3c 09                	cmp    $0x9,%al
  803da6:	77 08                	ja     803db0 <dhcp_release+0x82>
  803da8:	0f b6 d0             	movzbl %al,%edx
  803dab:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803db0:	0f b7 d2             	movzwl %dx,%edx
  803db3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803db9:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803dbe:	89 d0                	mov    %edx,%eax
  803dc0:	f7 e9                	imul   %ecx
  803dc2:	c1 fa 05             	sar    $0x5,%edx
  803dc5:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803dc9:	83 ec 0c             	sub    $0xc,%esp
  803dcc:	56                   	push   %esi
  803dcd:	e8 30 0b 00 00       	call   804902 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803dd2:	83 c4 08             	add    $0x8,%esp
  803dd5:	68 88 25 81 00       	push   $0x812588
  803dda:	56                   	push   %esi
  803ddb:	e8 84 09 00 00       	call   804764 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803de0:	83 c4 08             	add    $0x8,%esp
  803de3:	68 88 25 81 00       	push   $0x812588
  803de8:	56                   	push   %esi
  803de9:	e8 a2 0a 00 00       	call   804890 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803dee:	83 c4 08             	add    $0x8,%esp
  803df1:	68 88 25 81 00       	push   $0x812588
  803df6:	56                   	push   %esi
  803df7:	e8 ad 0a 00 00       	call   8048a9 <netif_set_netmask>
}
  803dfc:	89 f8                	mov    %edi,%eax
  803dfe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803e01:	5b                   	pop    %ebx
  803e02:	5e                   	pop    %esi
  803e03:	5f                   	pop    %edi
  803e04:	5d                   	pop    %ebp
  803e05:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803e06:	b9 01 00 00 00       	mov    $0x1,%ecx
  803e0b:	ba 35 00 00 00       	mov    $0x35,%edx
  803e10:	89 d8                	mov    %ebx,%eax
  803e12:	e8 af ec ff ff       	call   802ac6 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803e17:	ba 07 00 00 00       	mov    $0x7,%edx
  803e1c:	89 d8                	mov    %ebx,%eax
  803e1e:	e8 62 ec ff ff       	call   802a85 <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803e23:	89 d8                	mov    %ebx,%eax
  803e25:	e8 61 ed ff ff       	call   802b8b <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803e2a:	83 ec 08             	sub    $0x8,%esp
  803e2d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803e31:	66 05 f0 00          	add    $0xf0,%ax
  803e35:	0f b7 c0             	movzwl %ax,%eax
  803e38:	50                   	push   %eax
  803e39:	ff 73 1c             	pushl  0x1c(%ebx)
  803e3c:	e8 eb 0e 00 00       	call   804d2c <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803e41:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803e44:	83 c4 0c             	add    $0xc,%esp
  803e47:	6a 43                	push   $0x43
  803e49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803e4c:	50                   	push   %eax
  803e4d:	ff 73 08             	pushl  0x8(%ebx)
  803e50:	e8 8c 52 00 00       	call   8090e1 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803e55:	89 34 24             	mov    %esi,(%esp)
  803e58:	6a 43                	push   $0x43
  803e5a:	ff 75 e4             	pushl  -0x1c(%ebp)
  803e5d:	ff 73 1c             	pushl  0x1c(%ebx)
  803e60:	ff 73 08             	pushl  0x8(%ebx)
  803e63:	e8 84 50 00 00       	call   808eec <udp_sendto_if>
    dhcp_delete_request(netif);
  803e68:	83 c4 20             	add    $0x20,%esp
  803e6b:	89 f0                	mov    %esi,%eax
  803e6d:	e8 59 f0 ff ff       	call   802ecb <dhcp_delete_request>
  803e72:	e9 1e ff ff ff       	jmp    803d95 <dhcp_release+0x67>

00803e77 <dhcp_fine_tmr>:
{
  803e77:	55                   	push   %ebp
  803e78:	89 e5                	mov    %esp,%ebp
  803e7a:	53                   	push   %ebx
  803e7b:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803e7e:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  while (netif != NULL) {
  803e84:	eb 04                	jmp    803e8a <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803e86:	74 24                	je     803eac <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803e88:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803e8a:	85 db                	test   %ebx,%ebx
  803e8c:	0f 84 c4 00 00 00    	je     803f56 <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803e92:	8b 43 20             	mov    0x20(%ebx),%eax
  803e95:	85 c0                	test   %eax,%eax
  803e97:	74 ef                	je     803e88 <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803e99:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803e9d:	66 83 fa 01          	cmp    $0x1,%dx
  803ea1:	76 e3                	jbe    803e86 <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803ea3:	83 ea 01             	sub    $0x1,%edx
  803ea6:	66 89 50 26          	mov    %dx,0x26(%eax)
  803eaa:	eb dc                	jmp    803e88 <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803eac:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803eb2:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803eb5:	0f b6 02             	movzbl (%edx),%eax
  803eb8:	3c 0c                	cmp    $0xc,%al
  803eba:	74 23                	je     803edf <dhcp_fine_tmr+0x68>
  803ebc:	3c 06                	cmp    $0x6,%al
  803ebe:	74 1f                	je     803edf <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803ec0:	3c 01                	cmp    $0x1,%al
  803ec2:	74 24                	je     803ee8 <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803ec4:	3c 08                	cmp    $0x8,%al
  803ec6:	74 47                	je     803f0f <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803ec8:	3c 05                	cmp    $0x5,%al
  803eca:	74 61                	je     803f2d <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803ecc:	3c 04                	cmp    $0x4,%al
  803ece:	75 b8                	jne    803e88 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803ed0:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803ed4:	77 68                	ja     803f3e <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803ed6:	89 d8                	mov    %ebx,%eax
  803ed8:	e8 88 f0 ff ff       	call   802f65 <dhcp_rebind>
  803edd:	eb a9                	jmp    803e88 <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803edf:	89 d8                	mov    %ebx,%eax
  803ee1:	e8 72 f1 ff ff       	call   803058 <dhcp_discover>
  803ee6:	eb a0                	jmp    803e88 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803ee8:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803eec:	77 09                	ja     803ef7 <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803eee:	89 d8                	mov    %ebx,%eax
  803ef0:	e8 a2 f2 ff ff       	call   803197 <dhcp_select>
  803ef5:	eb 91                	jmp    803e88 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803ef7:	83 ec 0c             	sub    $0xc,%esp
  803efa:	53                   	push   %ebx
  803efb:	e8 2e fe ff ff       	call   803d2e <dhcp_release>
      dhcp_discover(netif);
  803f00:	89 d8                	mov    %ebx,%eax
  803f02:	e8 51 f1 ff ff       	call   803058 <dhcp_discover>
  803f07:	83 c4 10             	add    $0x10,%esp
  803f0a:	e9 79 ff ff ff       	jmp    803e88 <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803f0f:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803f13:	76 0c                	jbe    803f21 <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803f15:	89 d8                	mov    %ebx,%eax
  803f17:	e8 2b f4 ff ff       	call   803347 <dhcp_bind>
  803f1c:	e9 67 ff ff ff       	jmp    803e88 <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803f21:	89 d8                	mov    %ebx,%eax
  803f23:	e8 eb f3 ff ff       	call   803313 <dhcp_check>
  803f28:	e9 5b ff ff ff       	jmp    803e88 <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803f2d:	83 ec 0c             	sub    $0xc,%esp
  803f30:	53                   	push   %ebx
  803f31:	e8 81 fc ff ff       	call   803bb7 <dhcp_renew>
  803f36:	83 c4 10             	add    $0x10,%esp
  803f39:	e9 4a ff ff ff       	jmp    803e88 <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803f3e:	83 ec 0c             	sub    $0xc,%esp
  803f41:	53                   	push   %ebx
  803f42:	e8 e7 fd ff ff       	call   803d2e <dhcp_release>
      dhcp_discover(netif);
  803f47:	89 d8                	mov    %ebx,%eax
  803f49:	e8 0a f1 ff ff       	call   803058 <dhcp_discover>
  803f4e:	83 c4 10             	add    $0x10,%esp
  803f51:	e9 32 ff ff ff       	jmp    803e88 <dhcp_fine_tmr+0x11>
}
  803f56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803f59:	c9                   	leave  
  803f5a:	c3                   	ret    

00803f5b <dhcp_stop>:
{
  803f5b:	55                   	push   %ebp
  803f5c:	89 e5                	mov    %esp,%ebp
  803f5e:	56                   	push   %esi
  803f5f:	53                   	push   %ebx
  803f60:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f63:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803f66:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803f6a:	85 db                	test   %ebx,%ebx
  803f6c:	74 4e                	je     803fbc <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803f6e:	8b 43 08             	mov    0x8(%ebx),%eax
  803f71:	85 c0                	test   %eax,%eax
  803f73:	74 13                	je     803f88 <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803f75:	83 ec 0c             	sub    $0xc,%esp
  803f78:	50                   	push   %eax
  803f79:	e8 03 52 00 00       	call   809181 <udp_remove>
      dhcp->pcb = NULL;
  803f7e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803f85:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803f88:	8b 43 0c             	mov    0xc(%ebx),%eax
  803f8b:	85 c0                	test   %eax,%eax
  803f8d:	74 13                	je     803fa2 <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803f8f:	83 ec 0c             	sub    $0xc,%esp
  803f92:	50                   	push   %eax
  803f93:	e8 5c 0a 00 00       	call   8049f4 <pbuf_free>
      dhcp->p = NULL;
  803f98:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803f9f:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803fa2:	89 d8                	mov    %ebx,%eax
  803fa4:	e8 51 f5 ff ff       	call   8034fa <dhcp_free_reply>
    mem_free((void *)dhcp);
  803fa9:	83 ec 0c             	sub    $0xc,%esp
  803fac:	53                   	push   %ebx
  803fad:	e8 5c 01 00 00       	call   80410e <mem_free>
    netif->dhcp = NULL;
  803fb2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803fb9:	83 c4 10             	add    $0x10,%esp
}
  803fbc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803fbf:	5b                   	pop    %ebx
  803fc0:	5e                   	pop    %esi
  803fc1:	5d                   	pop    %ebp
  803fc2:	c3                   	ret    

00803fc3 <dhcp_start>:
{
  803fc3:	55                   	push   %ebp
  803fc4:	89 e5                	mov    %esp,%ebp
  803fc6:	56                   	push   %esi
  803fc7:	53                   	push   %ebx
  803fc8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803fcb:	85 db                	test   %ebx,%ebx
  803fcd:	74 73                	je     804042 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803fcf:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803fd2:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803fd6:	85 f6                	test   %esi,%esi
  803fd8:	74 7f                	je     804059 <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803fda:	83 ec 04             	sub    $0x4,%esp
  803fdd:	6a 58                	push   $0x58
  803fdf:	6a 00                	push   $0x0
  803fe1:	56                   	push   %esi
  803fe2:	e8 bd b1 00 00       	call   80f1a4 <memset>
  dhcp->pcb = udp_new();
  803fe7:	e8 d9 51 00 00       	call   8091c5 <udp_new>
  803fec:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803fef:	83 c4 10             	add    $0x10,%esp
  803ff2:	85 c0                	test   %eax,%eax
  803ff4:	74 7e                	je     804074 <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803ff6:	83 ec 04             	sub    $0x4,%esp
  803ff9:	6a 44                	push   $0x44
  803ffb:	68 88 25 81 00       	push   $0x812588
  804000:	50                   	push   %eax
  804001:	e8 2b 4e 00 00       	call   808e31 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  804006:	83 c4 0c             	add    $0xc,%esp
  804009:	6a 43                	push   $0x43
  80400b:	68 88 25 81 00       	push   $0x812588
  804010:	ff 76 08             	pushl  0x8(%esi)
  804013:	e8 c9 50 00 00       	call   8090e1 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  804018:	83 c4 0c             	add    $0xc,%esp
  80401b:	53                   	push   %ebx
  80401c:	68 42 35 80 00       	push   $0x803542
  804021:	ff 76 08             	pushl  0x8(%esi)
  804024:	e8 44 51 00 00       	call   80916d <udp_recv>
  result = dhcp_discover(netif);
  804029:	89 d8                	mov    %ebx,%eax
  80402b:	e8 28 f0 ff ff       	call   803058 <dhcp_discover>
  if (result != ERR_OK) {
  804030:	83 c4 10             	add    $0x10,%esp
  804033:	84 c0                	test   %al,%al
  804035:	75 57                	jne    80408e <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  804037:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  80403b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80403e:	5b                   	pop    %ebx
  80403f:	5e                   	pop    %esi
  804040:	5d                   	pop    %ebp
  804041:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  804042:	83 ec 04             	sub    $0x4,%esp
  804045:	68 02 1d 81 00       	push   $0x811d02
  80404a:	68 38 02 00 00       	push   $0x238
  80404f:	68 e2 1c 81 00       	push   $0x811ce2
  804054:	e8 b0 a7 00 00       	call   80e809 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  804059:	83 ec 0c             	sub    $0xc,%esp
  80405c:	6a 58                	push   $0x58
  80405e:	e8 9a 03 00 00       	call   8043fd <mem_malloc>
  804063:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  804065:	83 c4 10             	add    $0x10,%esp
  804068:	85 c0                	test   %eax,%eax
  80406a:	74 35                	je     8040a1 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  80406c:	89 43 20             	mov    %eax,0x20(%ebx)
  80406f:	e9 66 ff ff ff       	jmp    803fda <dhcp_start+0x17>
    mem_free((void *)dhcp);
  804074:	83 ec 0c             	sub    $0xc,%esp
  804077:	56                   	push   %esi
  804078:	e8 91 00 00 00       	call   80410e <mem_free>
    netif->dhcp = dhcp = NULL;
  80407d:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  804084:	83 c4 10             	add    $0x10,%esp
  804087:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80408c:	eb ad                	jmp    80403b <dhcp_start+0x78>
    dhcp_stop(netif);
  80408e:	83 ec 0c             	sub    $0xc,%esp
  804091:	53                   	push   %ebx
  804092:	e8 c4 fe ff ff       	call   803f5b <dhcp_stop>
    return ERR_MEM;
  804097:	83 c4 10             	add    $0x10,%esp
  80409a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80409f:	eb 9a                	jmp    80403b <dhcp_start+0x78>
      return ERR_MEM;
  8040a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8040a6:	eb 93                	jmp    80403b <dhcp_start+0x78>

008040a8 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8040a8:	55                   	push   %ebp
  8040a9:	89 e5                	mov    %esp,%ebp
  8040ab:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  8040ae:	b8 23 63 81 00       	mov    $0x816323,%eax
  8040b3:	83 e0 fc             	and    $0xfffffffc,%eax
  8040b6:	a3 0c 63 81 00       	mov    %eax,0x81630c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  8040bb:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  8040c1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8040c8:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  8040cc:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  8040d2:	89 15 08 63 81 00    	mov    %edx,0x816308
  ram_end->used = 1;
  8040d8:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  8040df:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  8040e6:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  8040e9:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8040f0:	00 22 00 

  mem_sem = sys_sem_new(1);
  8040f3:	6a 01                	push   $0x1
  8040f5:	e8 ad 5e 00 00       	call   809fa7 <sys_sem_new>
  8040fa:	a3 00 63 81 00       	mov    %eax,0x816300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  8040ff:	a1 0c 63 81 00       	mov    0x81630c,%eax
  804104:	a3 04 63 81 00       	mov    %eax,0x816304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804109:	83 c4 10             	add    $0x10,%esp
  80410c:	c9                   	leave  
  80410d:	c3                   	ret    

0080410e <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80410e:	55                   	push   %ebp
  80410f:	89 e5                	mov    %esp,%ebp
  804111:	56                   	push   %esi
  804112:	53                   	push   %ebx
  804113:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  804116:	85 db                	test   %ebx,%ebx
  804118:	0f 84 e1 00 00 00    	je     8041ff <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80411e:	f6 c3 03             	test   $0x3,%bl
  804121:	0f 85 df 00 00 00    	jne    804206 <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804127:	39 1d 0c 63 81 00    	cmp    %ebx,0x81630c
  80412d:	0f 87 ea 00 00 00    	ja     80421d <mem_free+0x10f>
  804133:	39 1d 08 63 81 00    	cmp    %ebx,0x816308
  804139:	0f 86 de 00 00 00    	jbe    80421d <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80413f:	83 ec 08             	sub    $0x8,%esp
  804142:	6a 00                	push   $0x0
  804144:	ff 35 00 63 81 00    	pushl  0x816300
  80414a:	e8 85 61 00 00       	call   80a2d4 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80414f:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804152:	83 c4 10             	add    $0x10,%esp
  804155:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804159:	0f 84 d5 00 00 00    	je     804234 <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  80415f:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  804163:	39 05 04 63 81 00    	cmp    %eax,0x816304
  804169:	76 05                	jbe    804170 <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80416b:	a3 04 63 81 00       	mov    %eax,0x816304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804170:	8b 0d 0c 63 81 00    	mov    0x81630c,%ecx
  804176:	39 c8                	cmp    %ecx,%eax
  804178:	0f 82 cd 00 00 00    	jb     80424b <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80417e:	8b 35 08 63 81 00    	mov    0x816308,%esi
  804184:	39 f0                	cmp    %esi,%eax
  804186:	0f 83 d6 00 00 00    	jae    804262 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80418c:	8b 53 f4             	mov    -0xc(%ebx),%edx
  80418f:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804195:	0f 87 de 00 00 00    	ja     804279 <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  80419b:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80419d:	39 d0                	cmp    %edx,%eax
  80419f:	74 25                	je     8041c6 <mem_free+0xb8>
  8041a1:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8041a5:	75 1f                	jne    8041c6 <mem_free+0xb8>
  8041a7:	39 d6                	cmp    %edx,%esi
  8041a9:	74 1b                	je     8041c6 <mem_free+0xb8>
    if (lfree == nmem) {
  8041ab:	3b 15 04 63 81 00    	cmp    0x816304,%edx
  8041b1:	0f 84 d9 00 00 00    	je     804290 <mem_free+0x182>
    mem->next = nmem->next;
  8041b7:	8b 32                	mov    (%edx),%esi
  8041b9:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8041bc:	8b 12                	mov    (%edx),%edx
  8041be:	89 c6                	mov    %eax,%esi
  8041c0:	29 ce                	sub    %ecx,%esi
  8041c2:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  8041c6:	8b 73 f8             	mov    -0x8(%ebx),%esi
  8041c9:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  8041cc:	39 d0                	cmp    %edx,%eax
  8041ce:	74 1e                	je     8041ee <mem_free+0xe0>
  8041d0:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8041d4:	75 18                	jne    8041ee <mem_free+0xe0>
    if (lfree == mem) {
  8041d6:	3b 05 04 63 81 00    	cmp    0x816304,%eax
  8041dc:	0f 84 b8 00 00 00    	je     80429a <mem_free+0x18c>
    pmem->next = mem->next;
  8041e2:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041e5:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8041e7:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8041ea:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041ee:	83 ec 0c             	sub    $0xc,%esp
  8041f1:	ff 35 00 63 81 00    	pushl  0x816300
  8041f7:	e8 68 60 00 00       	call   80a264 <sys_sem_signal>
  8041fc:	83 c4 10             	add    $0x10,%esp
}
  8041ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804202:	5b                   	pop    %ebx
  804203:	5e                   	pop    %esi
  804204:	5d                   	pop    %ebp
  804205:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804206:	83 ec 04             	sub    $0x4,%esp
  804209:	68 54 1d 81 00       	push   $0x811d54
  80420e:	68 30 01 00 00       	push   $0x130
  804213:	68 4b 1e 81 00       	push   $0x811e4b
  804218:	e8 ec a5 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80421d:	83 ec 04             	sub    $0x4,%esp
  804220:	68 5f 1e 81 00       	push   $0x811e5f
  804225:	68 33 01 00 00       	push   $0x133
  80422a:	68 4b 1e 81 00       	push   $0x811e4b
  80422f:	e8 d5 a5 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  804234:	83 ec 04             	sub    $0x4,%esp
  804237:	68 76 1e 81 00       	push   $0x811e76
  80423c:	68 43 01 00 00       	push   $0x143
  804241:	68 4b 1e 81 00       	push   $0x811e4b
  804246:	e8 be a5 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80424b:	83 ec 04             	sub    $0x4,%esp
  80424e:	68 8a 1e 81 00       	push   $0x811e8a
  804253:	68 e3 00 00 00       	push   $0xe3
  804258:	68 4b 1e 81 00       	push   $0x811e4b
  80425d:	e8 a7 a5 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804262:	83 ec 04             	sub    $0x4,%esp
  804265:	68 a1 1e 81 00       	push   $0x811ea1
  80426a:	68 e4 00 00 00       	push   $0xe4
  80426f:	68 4b 1e 81 00       	push   $0x811e4b
  804274:	e8 90 a5 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804279:	83 ec 04             	sub    $0x4,%esp
  80427c:	68 78 1d 81 00       	push   $0x811d78
  804281:	68 e8 00 00 00       	push   $0xe8
  804286:	68 4b 1e 81 00       	push   $0x811e4b
  80428b:	e8 79 a5 00 00       	call   80e809 <_panic>
      lfree = mem;
  804290:	a3 04 63 81 00       	mov    %eax,0x816304
  804295:	e9 1d ff ff ff       	jmp    8041b7 <mem_free+0xa9>
      lfree = pmem;
  80429a:	89 15 04 63 81 00    	mov    %edx,0x816304
  8042a0:	e9 3d ff ff ff       	jmp    8041e2 <mem_free+0xd4>

008042a5 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8042a5:	55                   	push   %ebp
  8042a6:	89 e5                	mov    %esp,%ebp
  8042a8:	57                   	push   %edi
  8042a9:	56                   	push   %esi
  8042aa:	53                   	push   %ebx
  8042ab:	83 ec 1c             	sub    $0x1c,%esp
  8042ae:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8042b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8042b4:	8d 58 03             	lea    0x3(%eax),%ebx
  8042b7:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  8042ba:	83 fb 0b             	cmp    $0xb,%ebx
  8042bd:	76 12                	jbe    8042d1 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8042bf:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  8042c5:	76 0f                	jbe    8042d6 <mem_realloc+0x31>
    return NULL;
  8042c7:	be 00 00 00 00       	mov    $0x0,%esi
  8042cc:	e9 a1 00 00 00       	jmp    804372 <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  8042d1:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8042d6:	a1 0c 63 81 00       	mov    0x81630c,%eax
  8042db:	39 f0                	cmp    %esi,%eax
  8042dd:	0f 87 99 00 00 00    	ja     80437c <mem_realloc+0xd7>
  8042e3:	39 35 08 63 81 00    	cmp    %esi,0x816308
  8042e9:	0f 86 8d 00 00 00    	jbe    80437c <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8042ef:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8042f2:	29 c2                	sub    %eax,%edx
  8042f4:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8042f7:	8b 4e f4             	mov    -0xc(%esi),%ecx
  8042fa:	8d 79 f4             	lea    -0xc(%ecx),%edi
  8042fd:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  8042ff:	39 df                	cmp    %ebx,%edi
  804301:	0f 82 8c 00 00 00    	jb     804393 <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804307:	74 69                	je     804372 <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804309:	83 ec 08             	sub    $0x8,%esp
  80430c:	6a 00                	push   $0x0
  80430e:	ff 35 00 63 81 00    	pushl  0x816300
  804314:	e8 bb 5f 00 00       	call   80a2d4 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804319:	a1 0c 63 81 00       	mov    0x81630c,%eax
  80431e:	89 c2                	mov    %eax,%edx
  804320:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  804323:	83 c4 10             	add    $0x10,%esp
  804326:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80432a:	0f 85 85 00 00 00    	jne    8043b5 <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804330:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804332:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804335:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  804339:	39 15 04 63 81 00    	cmp    %edx,0x816304
  80433f:	74 69                	je     8043aa <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  804341:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  804344:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804348:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  80434a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80434d:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  804350:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804353:	8b 12                	mov    (%edx),%edx
  804355:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80435b:	74 04                	je     804361 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80435d:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804361:	83 ec 0c             	sub    $0xc,%esp
  804364:	ff 35 00 63 81 00    	pushl  0x816300
  80436a:	e8 f5 5e 00 00       	call   80a264 <sys_sem_signal>
  return rmem;
  80436f:	83 c4 10             	add    $0x10,%esp
}
  804372:	89 f0                	mov    %esi,%eax
  804374:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804377:	5b                   	pop    %ebx
  804378:	5e                   	pop    %esi
  804379:	5f                   	pop    %edi
  80437a:	5d                   	pop    %ebp
  80437b:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80437c:	83 ec 04             	sub    $0x4,%esp
  80437f:	68 bb 1e 81 00       	push   $0x811ebb
  804384:	68 79 01 00 00       	push   $0x179
  804389:	68 4b 1e 81 00       	push   $0x811e4b
  80438e:	e8 76 a4 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804393:	83 ec 04             	sub    $0x4,%esp
  804396:	68 a4 1d 81 00       	push   $0x811da4
  80439b:	68 8a 01 00 00       	push   $0x18a
  8043a0:	68 4b 1e 81 00       	push   $0x811e4b
  8043a5:	e8 5f a4 00 00       	call   80e809 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  8043aa:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8043ad:	89 15 04 63 81 00    	mov    %edx,0x816304
  8043b3:	eb 8c                	jmp    804341 <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8043b5:	8d 53 18             	lea    0x18(%ebx),%edx
  8043b8:	39 fa                	cmp    %edi,%edx
  8043ba:	77 a5                	ja     804361 <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8043bc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8043bf:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8043c3:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8043c6:	39 15 04 63 81 00    	cmp    %edx,0x816304
  8043cc:	76 06                	jbe    8043d4 <mem_realloc+0x12f>
      lfree = mem2;
  8043ce:	89 15 04 63 81 00    	mov    %edx,0x816304
    mem2->used = 0;
  8043d4:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8043d8:	8b 5e f4             	mov    -0xc(%esi),%ebx
  8043db:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  8043dd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8043e0:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8043e3:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8043e6:	8b 12                	mov    (%edx),%edx
  8043e8:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8043ee:	0f 84 6d ff ff ff    	je     804361 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8043f4:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  8043f8:	e9 64 ff ff ff       	jmp    804361 <mem_realloc+0xbc>

008043fd <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8043fd:	55                   	push   %ebp
  8043fe:	89 e5                	mov    %esp,%ebp
  804400:	57                   	push   %edi
  804401:	56                   	push   %esi
  804402:	53                   	push   %ebx
  804403:	83 ec 1c             	sub    $0x1c,%esp
  804406:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  804409:	85 c0                	test   %eax,%eax
  80440b:	0f 84 a0 01 00 00    	je     8045b1 <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804411:	83 c0 03             	add    $0x3,%eax
  804414:	83 e0 fc             	and    $0xfffffffc,%eax
  804417:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  804419:	83 f8 0b             	cmp    $0xb,%eax
  80441c:	76 3a                	jbe    804458 <mem_malloc+0x5b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80441e:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804423:	0f 87 8f 01 00 00    	ja     8045b8 <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804429:	83 ec 08             	sub    $0x8,%esp
  80442c:	6a 00                	push   $0x0
  80442e:	ff 35 00 63 81 00    	pushl  0x816300
  804434:	e8 9b 5e 00 00       	call   80a2d4 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804439:	a1 04 63 81 00       	mov    0x816304,%eax
  80443e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804441:	8b 35 0c 63 81 00    	mov    0x81630c,%esi
  804447:	29 f0                	sub    %esi,%eax
  804449:	83 c4 10             	add    $0x10,%esp
  80444c:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804451:	29 f9                	sub    %edi,%ecx
  804453:	e9 e2 00 00 00       	jmp    80453a <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  804458:	bf 0c 00 00 00       	mov    $0xc,%edi
  80445d:	eb ca                	jmp    804429 <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80445f:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  804463:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  804466:	74 4c                	je     8044b4 <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  804468:	83 ec 0c             	sub    $0xc,%esp
  80446b:	ff 35 00 63 81 00    	pushl  0x816300
  804471:	e8 ee 5d 00 00       	call   80a264 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  804476:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  80447a:	83 c4 10             	add    $0x10,%esp
  80447d:	39 05 08 63 81 00    	cmp    %eax,0x816308
  804483:	0f 82 81 00 00 00    	jb     80450a <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804489:	8d 43 0c             	lea    0xc(%ebx),%eax
  80448c:	a8 03                	test   $0x3,%al
  80448e:	0f 85 8d 00 00 00    	jne    804521 <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  804494:	f6 c3 03             	test   $0x3,%bl
  804497:	0f 84 0c 01 00 00    	je     8045a9 <mem_malloc+0x1ac>
  80449d:	83 ec 04             	sub    $0x4,%esp
  8044a0:	68 28 1e 81 00       	push   $0x811e28
  8044a5:	68 4f 02 00 00       	push   $0x24f
  8044aa:	68 4b 1e 81 00       	push   $0x811e4b
  8044af:	e8 55 a3 00 00       	call   80e809 <_panic>
          while (lfree->used && lfree != ram_end) {
  8044b4:	8b 15 08 63 81 00    	mov    0x816308,%edx
  8044ba:	b8 00 00 00 00       	mov    $0x0,%eax
  8044bf:	b9 01 00 00 00       	mov    $0x1,%ecx
  8044c4:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8044c7:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8044ca:	eb 08                	jmp    8044d4 <mem_malloc+0xd7>
            lfree = (struct mem *)&ram[lfree->next];
  8044cc:	89 f0                	mov    %esi,%eax
  8044ce:	03 07                	add    (%edi),%eax
  8044d0:	89 c7                	mov    %eax,%edi
  8044d2:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  8044d4:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  8044d8:	74 18                	je     8044f2 <mem_malloc+0xf5>
  8044da:	39 fa                	cmp    %edi,%edx
  8044dc:	75 ee                	jne    8044cc <mem_malloc+0xcf>
  8044de:	89 fe                	mov    %edi,%esi
  8044e0:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044e3:	84 c0                	test   %al,%al
  8044e5:	74 81                	je     804468 <mem_malloc+0x6b>
  8044e7:	89 35 04 63 81 00    	mov    %esi,0x816304
  8044ed:	e9 76 ff ff ff       	jmp    804468 <mem_malloc+0x6b>
  8044f2:	89 fe                	mov    %edi,%esi
  8044f4:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8044f7:	84 c0                	test   %al,%al
  8044f9:	0f 84 69 ff ff ff    	je     804468 <mem_malloc+0x6b>
  8044ff:	89 35 04 63 81 00    	mov    %esi,0x816304
  804505:	e9 5e ff ff ff       	jmp    804468 <mem_malloc+0x6b>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80450a:	83 ec 04             	sub    $0x4,%esp
  80450d:	68 c8 1d 81 00       	push   $0x811dc8
  804512:	68 4b 02 00 00       	push   $0x24b
  804517:	68 4b 1e 81 00       	push   $0x811e4b
  80451c:	e8 e8 a2 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  804521:	83 ec 04             	sub    $0x4,%esp
  804524:	68 f8 1d 81 00       	push   $0x811df8
  804529:	68 4d 02 00 00       	push   $0x24d
  80452e:	68 4b 1e 81 00       	push   $0x811e4b
  804533:	e8 d1 a2 00 00       	call   80e809 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  804538:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80453a:	39 c1                	cmp    %eax,%ecx
  80453c:	76 55                	jbe    804593 <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  80453e:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  804541:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804545:	75 f1                	jne    804538 <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  804547:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  80454c:	29 c2                	sub    %eax,%edx
  80454e:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  804550:	39 fa                	cmp    %edi,%edx
  804552:	72 e4                	jb     804538 <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  804554:	8d 4f 18             	lea    0x18(%edi),%ecx
  804557:	39 ca                	cmp    %ecx,%edx
  804559:	0f 82 00 ff ff ff    	jb     80445f <mem_malloc+0x62>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80455f:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  804563:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  804566:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  804569:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80456d:	8b 0b                	mov    (%ebx),%ecx
  80456f:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804571:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  804574:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  804577:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  804579:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  80457d:	8b 02                	mov    (%edx),%eax
  80457f:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804584:	0f 84 d9 fe ff ff    	je     804463 <mem_malloc+0x66>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80458a:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  80458e:	e9 d0 fe ff ff       	jmp    804463 <mem_malloc+0x66>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804593:	83 ec 0c             	sub    $0xc,%esp
  804596:	ff 35 00 63 81 00    	pushl  0x816300
  80459c:	e8 c3 5c 00 00       	call   80a264 <sys_sem_signal>
  return NULL;
  8045a1:	83 c4 10             	add    $0x10,%esp
  8045a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8045a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8045ac:	5b                   	pop    %ebx
  8045ad:	5e                   	pop    %esi
  8045ae:	5f                   	pop    %edi
  8045af:	5d                   	pop    %ebp
  8045b0:	c3                   	ret    
    return NULL;
  8045b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8045b6:	eb f1                	jmp    8045a9 <mem_malloc+0x1ac>
    return NULL;
  8045b8:	b8 00 00 00 00       	mov    $0x0,%eax
  8045bd:	eb ea                	jmp    8045a9 <mem_malloc+0x1ac>

008045bf <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8045bf:	55                   	push   %ebp
  8045c0:	89 e5                	mov    %esp,%ebp
  8045c2:	56                   	push   %esi
  8045c3:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8045c4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8045c7:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  8045cb:	83 ec 0c             	sub    $0xc,%esp
  8045ce:	53                   	push   %ebx
  8045cf:	e8 29 fe ff ff       	call   8043fd <mem_malloc>
  8045d4:	89 c6                	mov    %eax,%esi
  if (p) {
  8045d6:	83 c4 10             	add    $0x10,%esp
  8045d9:	85 c0                	test   %eax,%eax
  8045db:	74 0f                	je     8045ec <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  8045dd:	83 ec 04             	sub    $0x4,%esp
  8045e0:	53                   	push   %ebx
  8045e1:	6a 00                	push   $0x0
  8045e3:	50                   	push   %eax
  8045e4:	e8 bb ab 00 00       	call   80f1a4 <memset>
  8045e9:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  8045ec:	89 f0                	mov    %esi,%eax
  8045ee:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8045f1:	5b                   	pop    %ebx
  8045f2:	5e                   	pop    %esi
  8045f3:	5d                   	pop    %ebp
  8045f4:	c3                   	ret    

008045f5 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8045f5:	55                   	push   %ebp
  8045f6:	89 e5                	mov    %esp,%ebp
  8045f8:	56                   	push   %esi
  8045f9:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8045fa:	b8 43 63 a3 00       	mov    $0xa36343,%eax
  8045ff:	83 e0 fc             	and    $0xfffffffc,%eax
  804602:	ba 00 00 00 00       	mov    $0x0,%edx
  804607:	eb 08                	jmp    804611 <memp_init+0x1c>
  804609:	83 c2 01             	add    $0x1,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80460c:	83 fa 0e             	cmp    $0xe,%edx
  80460f:	74 3c                	je     80464d <memp_init+0x58>
    memp_tab[i] = NULL;
  804611:	c7 04 95 c0 53 b3 00 	movl   $0x0,0xb353c0(,%edx,4)
  804618:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80461c:	0f b7 b4 12 4c 1f 81 	movzwl 0x811f4c(%edx,%edx,1),%esi
  804623:	00 
  804624:	b9 00 00 00 00       	mov    $0x0,%ecx
  804629:	66 39 ce             	cmp    %cx,%si
  80462c:	74 db                	je     804609 <memp_init+0x14>
      memp->next = memp_tab[i];
  80462e:	8b 1c 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%ebx
  804635:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  804637:	89 04 95 c0 53 b3 00 	mov    %eax,0xb353c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80463e:	0f b7 9c 12 68 1f 81 	movzwl 0x811f68(%edx,%edx,1),%ebx
  804645:	00 
  804646:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  804648:	83 c1 01             	add    $0x1,%ecx
  80464b:	eb dc                	jmp    804629 <memp_init+0x34>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80464d:	5b                   	pop    %ebx
  80464e:	5e                   	pop    %esi
  80464f:	5d                   	pop    %ebp
  804650:	c3                   	ret    

00804651 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804651:	55                   	push   %ebp
  804652:	89 e5                	mov    %esp,%ebp
  804654:	83 ec 08             	sub    $0x8,%esp
  804657:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80465a:	83 fa 0d             	cmp    $0xd,%edx
  80465d:	77 1a                	ja     804679 <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80465f:	8b 04 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804666:	85 c0                	test   %eax,%eax
  804668:	74 0d                	je     804677 <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  80466a:	8b 08                	mov    (%eax),%ecx
  80466c:	89 0c 95 c0 53 b3 00 	mov    %ecx,0xb353c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804673:	a8 03                	test   $0x3,%al
  804675:	75 19                	jne    804690 <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804677:	c9                   	leave  
  804678:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804679:	83 ec 04             	sub    $0x4,%esp
  80467c:	68 d5 1e 81 00       	push   $0x811ed5
  804681:	68 2d 01 00 00       	push   $0x12d
  804686:	68 f2 1e 81 00       	push   $0x811ef2
  80468b:	e8 79 a1 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804690:	83 ec 04             	sub    $0x4,%esp
  804693:	68 08 1f 81 00       	push   $0x811f08
  804698:	68 3f 01 00 00       	push   $0x13f
  80469d:	68 f2 1e 81 00       	push   $0x811ef2
  8046a2:	e8 62 a1 00 00       	call   80e809 <_panic>

008046a7 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8046a7:	55                   	push   %ebp
  8046a8:	89 e5                	mov    %esp,%ebp
  8046aa:	83 ec 08             	sub    $0x8,%esp
  8046ad:	8b 55 08             	mov    0x8(%ebp),%edx
  8046b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8046b3:	85 c0                	test   %eax,%eax
  8046b5:	74 14                	je     8046cb <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046b7:	a8 03                	test   $0x3,%al
  8046b9:	75 12                	jne    8046cd <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8046bb:	8b 0c 95 c0 53 b3 00 	mov    0xb353c0(,%edx,4),%ecx
  8046c2:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  8046c4:	89 04 95 c0 53 b3 00 	mov    %eax,0xb353c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8046cb:	c9                   	leave  
  8046cc:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  8046cd:	83 ec 04             	sub    $0x4,%esp
  8046d0:	68 2c 1f 81 00       	push   $0x811f2c
  8046d5:	68 5b 01 00 00       	push   $0x15b
  8046da:	68 f2 1e 81 00       	push   $0x811ef2
  8046df:	e8 25 a1 00 00       	call   80e809 <_panic>

008046e4 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8046e4:	55                   	push   %ebp
  8046e5:	89 e5                	mov    %esp,%ebp
  8046e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8046ea:	85 c9                	test   %ecx,%ecx
  8046ec:	74 2c                	je     80471a <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8046ee:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  8046f3:	39 c8                	cmp    %ecx,%eax
  8046f5:	74 0e                	je     804705 <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  8046f7:	85 c0                	test   %eax,%eax
  8046f9:	74 1f                	je     80471a <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  8046fb:	8b 10                	mov    (%eax),%edx
  8046fd:	39 ca                	cmp    %ecx,%edx
  8046ff:	74 0d                	je     80470e <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804701:	89 d0                	mov    %edx,%eax
  804703:	eb f2                	jmp    8046f7 <netif_remove+0x13>
    netif_list = netif->next;
  804705:	8b 01                	mov    (%ecx),%eax
  804707:	a3 34 c2 b3 00       	mov    %eax,0xb3c234
  80470c:	eb 04                	jmp    804712 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  80470e:	8b 11                	mov    (%ecx),%edx
  804710:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804712:	39 0d 38 c2 b3 00    	cmp    %ecx,0xb3c238
  804718:	74 02                	je     80471c <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80471a:	5d                   	pop    %ebp
  80471b:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80471c:	c7 05 38 c2 b3 00 00 	movl   $0x0,0xb3c238
  804723:	00 00 00 
  804726:	eb f2                	jmp    80471a <netif_remove+0x36>

00804728 <netif_find>:
{
  804728:	55                   	push   %ebp
  804729:	89 e5                	mov    %esp,%ebp
  80472b:	53                   	push   %ebx
  80472c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  80472f:	85 c9                	test   %ecx,%ecx
  804731:	74 2d                	je     804760 <netif_find+0x38>
  num = name[2] - '0';
  804733:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804737:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80473a:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  80473f:	eb 02                	jmp    804743 <netif_find+0x1b>
  804741:	8b 00                	mov    (%eax),%eax
  804743:	85 c0                	test   %eax,%eax
  804745:	74 16                	je     80475d <netif_find+0x35>
    if (num == netif->num &&
  804747:	38 50 31             	cmp    %dl,0x31(%eax)
  80474a:	75 f5                	jne    804741 <netif_find+0x19>
  80474c:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804750:	38 19                	cmp    %bl,(%ecx)
  804752:	75 ed                	jne    804741 <netif_find+0x19>
       name[0] == netif->name[0] &&
  804754:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804758:	38 59 01             	cmp    %bl,0x1(%ecx)
  80475b:	75 e4                	jne    804741 <netif_find+0x19>
}
  80475d:	5b                   	pop    %ebx
  80475e:	5d                   	pop    %ebp
  80475f:	c3                   	ret    
    return NULL;
  804760:	89 c8                	mov    %ecx,%eax
  804762:	eb f9                	jmp    80475d <netif_find+0x35>

00804764 <netif_set_ipaddr>:
{
  804764:	55                   	push   %ebp
  804765:	89 e5                	mov    %esp,%ebp
  804767:	57                   	push   %edi
  804768:	56                   	push   %esi
  804769:	53                   	push   %ebx
  80476a:	83 ec 0c             	sub    $0xc,%esp
  80476d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804770:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804773:	8b 43 04             	mov    0x4(%ebx),%eax
  804776:	39 06                	cmp    %eax,(%esi)
  804778:	74 47                	je     8047c1 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  80477a:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
    while (pcb != NULL) {
  80477f:	eb 11                	jmp    804792 <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  804781:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  804784:	83 ec 0c             	sub    $0xc,%esp
  804787:	50                   	push   %eax
  804788:	e8 cd 15 00 00       	call   805d5a <tcp_abort>
  80478d:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  804790:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804792:	85 c0                	test   %eax,%eax
  804794:	74 0c                	je     8047a2 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804796:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804799:	39 08                	cmp    %ecx,(%eax)
  80479b:	74 e4                	je     804781 <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  80479d:	8b 40 0c             	mov    0xc(%eax),%eax
  8047a0:	eb f0                	jmp    804792 <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8047a2:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  8047a7:	eb 03                	jmp    8047ac <netif_set_ipaddr+0x48>
  8047a9:	8b 40 0c             	mov    0xc(%eax),%eax
  8047ac:	85 c0                	test   %eax,%eax
  8047ae:	74 11                	je     8047c1 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8047b0:	8b 10                	mov    (%eax),%edx
  8047b2:	85 d2                	test   %edx,%edx
  8047b4:	74 f3                	je     8047a9 <netif_set_ipaddr+0x45>
  8047b6:	3b 53 04             	cmp    0x4(%ebx),%edx
  8047b9:	75 ee                	jne    8047a9 <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8047bb:	8b 16                	mov    (%esi),%edx
  8047bd:	89 10                	mov    %edx,(%eax)
  8047bf:	eb e8                	jmp    8047a9 <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  8047c1:	8b 06                	mov    (%esi),%eax
  8047c3:	89 43 04             	mov    %eax,0x4(%ebx)
}
  8047c6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8047c9:	5b                   	pop    %ebx
  8047ca:	5e                   	pop    %esi
  8047cb:	5f                   	pop    %edi
  8047cc:	5d                   	pop    %ebp
  8047cd:	c3                   	ret    

008047ce <netif_set_addr>:
{
  8047ce:	55                   	push   %ebp
  8047cf:	89 e5                	mov    %esp,%ebp
  8047d1:	57                   	push   %edi
  8047d2:	56                   	push   %esi
  8047d3:	53                   	push   %ebx
  8047d4:	83 ec 14             	sub    $0x14,%esp
  8047d7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8047da:	8b 7d 10             	mov    0x10(%ebp),%edi
  8047dd:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  8047e0:	ff 75 0c             	pushl  0xc(%ebp)
  8047e3:	53                   	push   %ebx
  8047e4:	e8 7b ff ff ff       	call   804764 <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  8047e9:	83 c4 10             	add    $0x10,%esp
  8047ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8047f1:	85 ff                	test   %edi,%edi
  8047f3:	74 02                	je     8047f7 <netif_set_addr+0x29>
  8047f5:	8b 07                	mov    (%edi),%eax
  8047f7:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  8047fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8047ff:	85 f6                	test   %esi,%esi
  804801:	74 02                	je     804805 <netif_set_addr+0x37>
  804803:	8b 06                	mov    (%esi),%eax
  804805:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  804808:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80480b:	5b                   	pop    %ebx
  80480c:	5e                   	pop    %esi
  80480d:	5f                   	pop    %edi
  80480e:	5d                   	pop    %ebp
  80480f:	c3                   	ret    

00804810 <netif_add>:
{
  804810:	55                   	push   %ebp
  804811:	89 e5                	mov    %esp,%ebp
  804813:	53                   	push   %ebx
  804814:	83 ec 04             	sub    $0x4,%esp
  804817:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  80481a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804821:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804828:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  80482f:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  804833:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  80483a:	8b 45 18             	mov    0x18(%ebp),%eax
  80483d:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804840:	0f b6 05 f8 53 b3 00 	movzbl 0xb353f8,%eax
  804847:	8d 50 01             	lea    0x1(%eax),%edx
  80484a:	88 15 f8 53 b3 00    	mov    %dl,0xb353f8
  804850:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804853:	8b 45 20             	mov    0x20(%ebp),%eax
  804856:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  804859:	ff 75 14             	pushl  0x14(%ebp)
  80485c:	ff 75 10             	pushl  0x10(%ebp)
  80485f:	ff 75 0c             	pushl  0xc(%ebp)
  804862:	53                   	push   %ebx
  804863:	e8 66 ff ff ff       	call   8047ce <netif_set_addr>
  if (init(netif) != ERR_OK) {
  804868:	89 1c 24             	mov    %ebx,(%esp)
  80486b:	ff 55 1c             	call   *0x1c(%ebp)
  80486e:	83 c4 10             	add    $0x10,%esp
  804871:	84 c0                	test   %al,%al
  804873:	75 14                	jne    804889 <netif_add+0x79>
  netif->next = netif_list;
  804875:	a1 34 c2 b3 00       	mov    0xb3c234,%eax
  80487a:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80487c:	89 1d 34 c2 b3 00    	mov    %ebx,0xb3c234
  return netif;
  804882:	89 d8                	mov    %ebx,%eax
}
  804884:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804887:	c9                   	leave  
  804888:	c3                   	ret    
    return NULL;
  804889:	b8 00 00 00 00       	mov    $0x0,%eax
  80488e:	eb f4                	jmp    804884 <netif_add+0x74>

00804890 <netif_set_gw>:
{
  804890:	55                   	push   %ebp
  804891:	89 e5                	mov    %esp,%ebp
  804893:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  804896:	b8 00 00 00 00       	mov    $0x0,%eax
  80489b:	85 d2                	test   %edx,%edx
  80489d:	74 02                	je     8048a1 <netif_set_gw+0x11>
  80489f:	8b 02                	mov    (%edx),%eax
  8048a1:	8b 55 08             	mov    0x8(%ebp),%edx
  8048a4:	89 42 0c             	mov    %eax,0xc(%edx)
}
  8048a7:	5d                   	pop    %ebp
  8048a8:	c3                   	ret    

008048a9 <netif_set_netmask>:
{
  8048a9:	55                   	push   %ebp
  8048aa:	89 e5                	mov    %esp,%ebp
  8048ac:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  8048af:	b8 00 00 00 00       	mov    $0x0,%eax
  8048b4:	85 d2                	test   %edx,%edx
  8048b6:	74 02                	je     8048ba <netif_set_netmask+0x11>
  8048b8:	8b 02                	mov    (%edx),%eax
  8048ba:	8b 55 08             	mov    0x8(%ebp),%edx
  8048bd:	89 42 08             	mov    %eax,0x8(%edx)
}
  8048c0:	5d                   	pop    %ebp
  8048c1:	c3                   	ret    

008048c2 <netif_set_default>:
{
  8048c2:	55                   	push   %ebp
  8048c3:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  8048c5:	8b 45 08             	mov    0x8(%ebp),%eax
  8048c8:	a3 38 c2 b3 00       	mov    %eax,0xb3c238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8048cd:	5d                   	pop    %ebp
  8048ce:	c3                   	ret    

008048cf <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8048cf:	55                   	push   %ebp
  8048d0:	89 e5                	mov    %esp,%ebp
  8048d2:	83 ec 08             	sub    $0x8,%esp
  8048d5:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8048d8:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8048dc:	a8 01                	test   $0x1,%al
  8048de:	75 0c                	jne    8048ec <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  8048e0:	89 c1                	mov    %eax,%ecx
  8048e2:	83 c9 01             	or     $0x1,%ecx
  8048e5:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8048e8:	a8 20                	test   $0x20,%al
  8048ea:	75 02                	jne    8048ee <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  8048ec:	c9                   	leave  
  8048ed:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  8048ee:	83 ec 04             	sub    $0x4,%esp
  8048f1:	6a 00                	push   $0x0
  8048f3:	8d 42 04             	lea    0x4(%edx),%eax
  8048f6:	50                   	push   %eax
  8048f7:	52                   	push   %edx
  8048f8:	e8 d8 51 00 00       	call   809ad5 <etharp_query>
  8048fd:	83 c4 10             	add    $0x10,%esp
}
  804900:	eb ea                	jmp    8048ec <netif_set_up+0x1d>

00804902 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804902:	55                   	push   %ebp
  804903:	89 e5                	mov    %esp,%ebp
  804905:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  804908:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  80490c:	a8 01                	test   $0x1,%al
  80490e:	74 06                	je     804916 <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804910:	83 e0 fe             	and    $0xfffffffe,%eax
  804913:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804916:	5d                   	pop    %ebp
  804917:	c3                   	ret    

00804918 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804918:	55                   	push   %ebp
  804919:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80491b:	8b 45 08             	mov    0x8(%ebp),%eax
  80491e:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804922:	83 e0 01             	and    $0x1,%eax
}
  804925:	5d                   	pop    %ebp
  804926:	c3                   	ret    

00804927 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804927:	55                   	push   %ebp
  804928:	89 e5                	mov    %esp,%ebp
  80492a:	56                   	push   %esi
  80492b:	53                   	push   %ebx
  80492c:	8b 55 08             	mov    0x8(%ebp),%edx
  80492f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804932:	85 d2                	test   %edx,%edx
  804934:	74 42                	je     804978 <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  804936:	66 85 c9             	test   %cx,%cx
  804939:	0f 84 ae 00 00 00    	je     8049ed <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80493f:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  804941:	78 4c                	js     80498f <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804943:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804947:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80494a:	66 85 c0             	test   %ax,%ax
  80494d:	74 5f                	je     8049ae <pbuf_header+0x87>
  80494f:	66 83 f8 03          	cmp    $0x3,%ax
  804953:	74 59                	je     8049ae <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804955:	83 e8 01             	sub    $0x1,%eax
  804958:	66 83 f8 01          	cmp    $0x1,%ax
  80495c:	77 78                	ja     8049d6 <pbuf_header+0xaf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80495e:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804963:	66 85 c9             	test   %cx,%cx
  804966:	79 67                	jns    8049cf <pbuf_header+0xa8>
  804968:	66 39 72 0a          	cmp    %si,0xa(%edx)
  80496c:	72 61                	jb     8049cf <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  80496e:	0f bf c1             	movswl %cx,%eax
  804971:	29 c3                	sub    %eax,%ebx
  804973:	89 5a 04             	mov    %ebx,0x4(%edx)
  804976:	eb 4a                	jmp    8049c2 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  804978:	83 ec 04             	sub    $0x4,%esp
  80497b:	68 48 20 81 00       	push   $0x812048
  804980:	68 64 01 00 00       	push   $0x164
  804985:	68 84 1f 81 00       	push   $0x811f84
  80498a:	e8 7a 9e 00 00       	call   80e809 <_panic>
    increment_magnitude = -header_size_increment;
  80498f:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804991:	66 39 72 0a          	cmp    %si,0xa(%edx)
  804995:	73 ac                	jae    804943 <pbuf_header+0x1c>
  804997:	83 ec 04             	sub    $0x4,%esp
  80499a:	68 99 1f 81 00       	push   $0x811f99
  80499f:	68 6b 01 00 00       	push   $0x16b
  8049a4:	68 84 1f 81 00       	push   $0x811f84
  8049a9:	e8 5b 9e 00 00       	call   80e809 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049ae:	0f bf c1             	movswl %cx,%eax
  8049b1:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049b3:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  8049b6:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8049bb:	39 f3                	cmp    %esi,%ebx
  8049bd:	72 10                	jb     8049cf <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  8049bf:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8049c2:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8049c6:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8049ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8049cf:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8049d2:	5b                   	pop    %ebx
  8049d3:	5e                   	pop    %esi
  8049d4:	5d                   	pop    %ebp
  8049d5:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  8049d6:	83 ec 04             	sub    $0x4,%esp
  8049d9:	68 b7 1f 81 00       	push   $0x811fb7
  8049de:	68 9a 01 00 00       	push   $0x19a
  8049e3:	68 84 1f 81 00       	push   $0x811f84
  8049e8:	e8 1c 9e 00 00       	call   80e809 <_panic>
    return 0;
  8049ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8049f2:	eb db                	jmp    8049cf <pbuf_header+0xa8>

008049f4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  8049f4:	55                   	push   %ebp
  8049f5:	89 e5                	mov    %esp,%ebp
  8049f7:	56                   	push   %esi
  8049f8:	53                   	push   %ebx
  8049f9:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  8049fc:	85 c0                	test   %eax,%eax
  8049fe:	74 0d                	je     804a0d <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804a00:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  804a04:	77 1e                	ja     804a24 <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  804a06:	bb 00 00 00 00       	mov    $0x0,%ebx
  804a0b:	eb 6c                	jmp    804a79 <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  804a0d:	83 ec 04             	sub    $0x4,%esp
  804a10:	68 48 20 81 00       	push   $0x812048
  804a15:	68 d0 01 00 00       	push   $0x1d0
  804a1a:	68 84 1f 81 00       	push   $0x811f84
  804a1f:	e8 e5 9d 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  804a24:	83 ec 04             	sub    $0x4,%esp
  804a27:	68 c5 1f 81 00       	push   $0x811fc5
  804a2c:	68 db 01 00 00       	push   $0x1db
  804a31:	68 84 1f 81 00       	push   $0x811f84
  804a36:	e8 ce 9d 00 00       	call   80e809 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804a3b:	83 ec 04             	sub    $0x4,%esp
  804a3e:	68 da 1f 81 00       	push   $0x811fda
  804a43:	68 e8 01 00 00       	push   $0x1e8
  804a48:	68 84 1f 81 00       	push   $0x811f84
  804a4d:	e8 b7 9d 00 00       	call   80e809 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  804a52:	83 ec 08             	sub    $0x8,%esp
  804a55:	50                   	push   %eax
  804a56:	6a 0d                	push   $0xd
  804a58:	e8 4a fc ff ff       	call   8046a7 <memp_free>
  804a5d:	83 c4 10             	add    $0x10,%esp
  804a60:	eb 0e                	jmp    804a70 <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  804a62:	83 ec 08             	sub    $0x8,%esp
  804a65:	50                   	push   %eax
  804a66:	6a 0c                	push   $0xc
  804a68:	e8 3a fc ff ff       	call   8046a7 <memp_free>
  804a6d:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  804a70:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  804a73:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  804a75:	85 f6                	test   %esi,%esi
  804a77:	74 38                	je     804ab1 <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804a79:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  804a7d:	66 85 d2             	test   %dx,%dx
  804a80:	74 b9                	je     804a3b <pbuf_free+0x47>
    ref = --(p->ref);
  804a82:	83 ea 01             	sub    $0x1,%edx
  804a85:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  804a89:	66 85 d2             	test   %dx,%dx
  804a8c:	75 23                	jne    804ab1 <pbuf_free+0xbd>
      q = p->next;
  804a8e:	8b 30                	mov    (%eax),%esi
      type = p->type;
  804a90:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  804a94:	66 83 fa 03          	cmp    $0x3,%dx
  804a98:	74 b8                	je     804a52 <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804a9a:	83 ea 01             	sub    $0x1,%edx
  804a9d:	66 83 fa 01          	cmp    $0x1,%dx
  804aa1:	76 bf                	jbe    804a62 <pbuf_free+0x6e>
        mem_free(p);
  804aa3:	83 ec 0c             	sub    $0xc,%esp
  804aa6:	50                   	push   %eax
  804aa7:	e8 62 f6 ff ff       	call   80410e <mem_free>
  804aac:	83 c4 10             	add    $0x10,%esp
  804aaf:	eb bf                	jmp    804a70 <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804ab1:	89 d8                	mov    %ebx,%eax
  804ab3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804ab6:	5b                   	pop    %ebx
  804ab7:	5e                   	pop    %esi
  804ab8:	5d                   	pop    %ebp
  804ab9:	c3                   	ret    

00804aba <pbuf_alloc>:
{
  804aba:	55                   	push   %ebp
  804abb:	89 e5                	mov    %esp,%ebp
  804abd:	57                   	push   %edi
  804abe:	56                   	push   %esi
  804abf:	53                   	push   %ebx
  804ac0:	83 ec 1c             	sub    $0x1c,%esp
  804ac3:	8b 45 08             	mov    0x8(%ebp),%eax
  804ac6:	8b 75 0c             	mov    0xc(%ebp),%esi
  804ac9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804acc:	83 f8 01             	cmp    $0x1,%eax
  804acf:	0f 84 8a 00 00 00    	je     804b5f <pbuf_alloc+0xa5>
  804ad5:	85 c0                	test   %eax,%eax
  804ad7:	0f 84 89 00 00 00    	je     804b66 <pbuf_alloc+0xac>
  804add:	83 f8 02             	cmp    $0x2,%eax
  804ae0:	0f 84 94 00 00 00    	je     804b7a <pbuf_alloc+0xc0>
  804ae6:	83 f8 03             	cmp    $0x3,%eax
  804ae9:	0f 85 92 00 00 00    	jne    804b81 <pbuf_alloc+0xc7>
  offset = 0;
  804aef:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  804af5:	83 fb 02             	cmp    $0x2,%ebx
  804af8:	0f 87 9a 00 00 00    	ja     804b98 <pbuf_alloc+0xde>
  804afe:	85 db                	test   %ebx,%ebx
  804b00:	0f 85 db 01 00 00    	jne    804ce1 <pbuf_alloc+0x227>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  804b06:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  804b0a:	83 ec 0c             	sub    $0xc,%esp
  804b0d:	8d 43 13             	lea    0x13(%ebx),%eax
  804b10:	83 e0 fc             	and    $0xfffffffc,%eax
  804b13:	89 c2                	mov    %eax,%edx
  804b15:	0f b7 c6             	movzwl %si,%eax
  804b18:	83 c0 03             	add    $0x3,%eax
  804b1b:	83 e0 fc             	and    $0xfffffffc,%eax
  804b1e:	01 d0                	add    %edx,%eax
  804b20:	50                   	push   %eax
  804b21:	e8 d7 f8 ff ff       	call   8043fd <mem_malloc>
  804b26:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b28:	83 c4 10             	add    $0x10,%esp
  804b2b:	85 c0                	test   %eax,%eax
  804b2d:	74 26                	je     804b55 <pbuf_alloc+0x9b>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  804b2f:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  804b33:	83 e0 fc             	and    $0xfffffffc,%eax
  804b36:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  804b39:	66 89 77 08          	mov    %si,0x8(%edi)
  804b3d:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  804b41:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  804b47:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  804b4b:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  804b51:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  804b55:	89 f8                	mov    %edi,%eax
  804b57:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804b5a:	5b                   	pop    %ebx
  804b5b:	5e                   	pop    %esi
  804b5c:	5f                   	pop    %edi
  804b5d:	5d                   	pop    %ebp
  804b5e:	c3                   	ret    
  offset = 0;
  804b5f:	bf 00 00 00 00       	mov    $0x0,%edi
  804b64:	eb 05                	jmp    804b6b <pbuf_alloc+0xb1>
    offset += PBUF_TRANSPORT_HLEN;
  804b66:	bf 14 00 00 00       	mov    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804b6b:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804b6e:	8d 47 0e             	lea    0xe(%edi),%eax
  804b71:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804b75:	e9 7b ff ff ff       	jmp    804af5 <pbuf_alloc+0x3b>
  offset = 0;
  804b7a:	bf 00 00 00 00       	mov    $0x0,%edi
  804b7f:	eb ed                	jmp    804b6e <pbuf_alloc+0xb4>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804b81:	83 ec 04             	sub    $0x4,%esp
  804b84:	68 f0 1f 81 00       	push   $0x811ff0
  804b89:	68 8a 00 00 00       	push   $0x8a
  804b8e:	68 84 1f 81 00       	push   $0x811f84
  804b93:	e8 71 9c 00 00       	call   80e809 <_panic>
  switch (type) {
  804b98:	83 fb 03             	cmp    $0x3,%ebx
  804b9b:	0f 85 74 01 00 00    	jne    804d15 <pbuf_alloc+0x25b>
      p = memp_malloc(MEMP_PBUF_POOL);
  804ba1:	83 ec 0c             	sub    $0xc,%esp
  804ba4:	6a 0d                	push   $0xd
  804ba6:	e8 a6 fa ff ff       	call   804651 <memp_malloc>
  804bab:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804bad:	83 c4 10             	add    $0x10,%esp
  804bb0:	85 c0                	test   %eax,%eax
  804bb2:	74 a1                	je     804b55 <pbuf_alloc+0x9b>
    p->type = type;
  804bb4:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804bb8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804bbe:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804bc2:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804bc6:	83 e2 fc             	and    $0xfffffffc,%edx
  804bc9:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804bcc:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804bd0:	0f b7 f6             	movzwl %si,%esi
  804bd3:	83 c0 03             	add    $0x3,%eax
  804bd6:	83 e0 fc             	and    $0xfffffffc,%eax
  804bd9:	89 c1                	mov    %eax,%ecx
  804bdb:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804be0:	29 c8                	sub    %ecx,%eax
  804be2:	39 f0                	cmp    %esi,%eax
  804be4:	0f 4f c6             	cmovg  %esi,%eax
  804be7:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804beb:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804bf1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804bf4:	01 c2                	add    %eax,%edx
  804bf6:	39 d3                	cmp    %edx,%ebx
  804bf8:	72 76                	jb     804c70 <pbuf_alloc+0x1b6>
    p->ref = 1;
  804bfa:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804c00:	29 c6                	sub    %eax,%esi
    r = p;
  804c02:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804c04:	85 f6                	test   %esi,%esi
  804c06:	0f 8e 3f ff ff ff    	jle    804b4b <pbuf_alloc+0x91>
      q = memp_malloc(MEMP_PBUF_POOL);
  804c0c:	83 ec 0c             	sub    $0xc,%esp
  804c0f:	6a 0d                	push   $0xd
  804c11:	e8 3b fa ff ff       	call   804651 <memp_malloc>
      if (q == NULL) {
  804c16:	83 c4 10             	add    $0x10,%esp
  804c19:	85 c0                	test   %eax,%eax
  804c1b:	74 6a                	je     804c87 <pbuf_alloc+0x1cd>
      q->type = type;
  804c1d:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804c21:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804c25:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804c2b:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804c2d:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804c33:	7f 67                	jg     804c9c <pbuf_alloc+0x1e2>
      q->tot_len = (u16_t)rem_len;
  804c35:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804c39:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804c3e:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804c43:	0f 46 d6             	cmovbe %esi,%edx
  804c46:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804c4a:	8d 48 10             	lea    0x10(%eax),%ecx
  804c4d:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804c50:	f6 c1 03             	test   $0x3,%cl
  804c53:	75 5e                	jne    804cb3 <pbuf_alloc+0x1f9>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c55:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804c59:	03 4f 04             	add    0x4(%edi),%ecx
  804c5c:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804c5f:	72 69                	jb     804cca <pbuf_alloc+0x210>
      q->ref = 1;
  804c61:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804c67:	0f b7 d2             	movzwl %dx,%edx
  804c6a:	29 d6                	sub    %edx,%esi
      r = q;
  804c6c:	89 c3                	mov    %eax,%ebx
  804c6e:	eb 94                	jmp    804c04 <pbuf_alloc+0x14a>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804c70:	83 ec 04             	sub    $0x4,%esp
  804c73:	68 08 21 81 00       	push   $0x812108
  804c78:	68 a3 00 00 00       	push   $0xa3
  804c7d:	68 84 1f 81 00       	push   $0x811f84
  804c82:	e8 82 9b 00 00       	call   80e809 <_panic>
  804c87:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804c89:	83 ec 0c             	sub    $0xc,%esp
  804c8c:	57                   	push   %edi
  804c8d:	e8 62 fd ff ff       	call   8049f4 <pbuf_free>
        return NULL;
  804c92:	83 c4 10             	add    $0x10,%esp
  804c95:	89 df                	mov    %ebx,%edi
  804c97:	e9 b9 fe ff ff       	jmp    804b55 <pbuf_alloc+0x9b>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804c9c:	83 ec 04             	sub    $0x4,%esp
  804c9f:	68 0b 20 81 00       	push   $0x81200b
  804ca4:	68 bc 00 00 00       	push   $0xbc
  804ca9:	68 84 1f 81 00       	push   $0x811f84
  804cae:	e8 56 9b 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804cb3:	83 ec 04             	sub    $0x4,%esp
  804cb6:	68 3c 21 81 00       	push   $0x81213c
  804cbb:	68 c2 00 00 00       	push   $0xc2
  804cc0:	68 84 1f 81 00       	push   $0x811f84
  804cc5:	e8 3f 9b 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804cca:	83 ec 04             	sub    $0x4,%esp
  804ccd:	68 08 21 81 00       	push   $0x812108
  804cd2:	68 c5 00 00 00       	push   $0xc5
  804cd7:	68 84 1f 81 00       	push   $0x811f84
  804cdc:	e8 28 9b 00 00       	call   80e809 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804ce1:	83 ec 0c             	sub    $0xc,%esp
  804ce4:	6a 0c                	push   $0xc
  804ce6:	e8 66 f9 ff ff       	call   804651 <memp_malloc>
  804ceb:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804ced:	83 c4 10             	add    $0x10,%esp
  804cf0:	85 c0                	test   %eax,%eax
  804cf2:	0f 84 5d fe ff ff    	je     804b55 <pbuf_alloc+0x9b>
    p->payload = NULL;
  804cf8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804cff:	66 89 70 08          	mov    %si,0x8(%eax)
  804d03:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804d07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804d0d:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804d10:	e9 36 fe ff ff       	jmp    804b4b <pbuf_alloc+0x91>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804d15:	83 ec 04             	sub    $0x4,%esp
  804d18:	68 1f 20 81 00       	push   $0x81201f
  804d1d:	68 f1 00 00 00       	push   $0xf1
  804d22:	68 84 1f 81 00       	push   $0x811f84
  804d27:	e8 dd 9a 00 00       	call   80e809 <_panic>

00804d2c <pbuf_realloc>:
{
  804d2c:	55                   	push   %ebp
  804d2d:	89 e5                	mov    %esp,%ebp
  804d2f:	57                   	push   %edi
  804d30:	56                   	push   %esi
  804d31:	53                   	push   %ebx
  804d32:	83 ec 0c             	sub    $0xc,%esp
  804d35:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804d38:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804d3b:	85 db                	test   %ebx,%ebx
  804d3d:	74 53                	je     804d92 <pbuf_realloc+0x66>
  804d3f:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804d41:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804d45:	77 62                	ja     804da9 <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804d47:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804d4b:	66 39 f0             	cmp    %si,%ax
  804d4e:	0f 86 ae 00 00 00    	jbe    804e02 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804d54:	0f b7 ce             	movzwl %si,%ecx
  804d57:	0f b7 f8             	movzwl %ax,%edi
  804d5a:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804d5c:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804d5e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804d62:	66 39 f0             	cmp    %si,%ax
  804d65:	73 70                	jae    804dd7 <pbuf_realloc+0xab>
    rem_len -= q->len;
  804d67:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804d69:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804d6f:	7f 4f                	jg     804dc0 <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804d71:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804d75:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804d77:	85 db                	test   %ebx,%ebx
  804d79:	75 e3                	jne    804d5e <pbuf_realloc+0x32>
  804d7b:	83 ec 04             	sub    $0x4,%esp
  804d7e:	68 7e 20 81 00       	push   $0x81207e
  804d83:	68 2f 01 00 00       	push   $0x12f
  804d88:	68 84 1f 81 00       	push   $0x811f84
  804d8d:	e8 77 9a 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804d92:	83 ec 04             	sub    $0x4,%esp
  804d95:	68 3a 20 81 00       	push   $0x81203a
  804d9a:	68 13 01 00 00       	push   $0x113
  804d9f:	68 84 1f 81 00       	push   $0x811f84
  804da4:	e8 60 9a 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804da9:	83 ec 04             	sub    $0x4,%esp
  804dac:	68 52 20 81 00       	push   $0x812052
  804db1:	68 17 01 00 00       	push   $0x117
  804db6:	68 84 1f 81 00       	push   $0x811f84
  804dbb:	e8 49 9a 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804dc0:	83 ec 04             	sub    $0x4,%esp
  804dc3:	68 6d 20 81 00       	push   $0x81206d
  804dc8:	68 2b 01 00 00       	push   $0x12b
  804dcd:	68 84 1f 81 00       	push   $0x811f84
  804dd2:	e8 32 9a 00 00       	call   80e809 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804dd7:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804ddb:	75 05                	jne    804de2 <pbuf_realloc+0xb6>
  804ddd:	66 39 f0             	cmp    %si,%ax
  804de0:	75 28                	jne    804e0a <pbuf_realloc+0xde>
  q->len = rem_len;
  804de2:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804de6:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804dea:	8b 03                	mov    (%ebx),%eax
  804dec:	85 c0                	test   %eax,%eax
  804dee:	74 0c                	je     804dfc <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804df0:	83 ec 0c             	sub    $0xc,%esp
  804df3:	50                   	push   %eax
  804df4:	e8 fb fb ff ff       	call   8049f4 <pbuf_free>
  804df9:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804dfc:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804e02:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804e05:	5b                   	pop    %ebx
  804e06:	5e                   	pop    %esi
  804e07:	5f                   	pop    %edi
  804e08:	5d                   	pop    %ebp
  804e09:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804e0a:	8b 43 04             	mov    0x4(%ebx),%eax
  804e0d:	29 d8                	sub    %ebx,%eax
  804e0f:	0f b7 d6             	movzwl %si,%edx
  804e12:	01 d0                	add    %edx,%eax
  804e14:	83 ec 08             	sub    $0x8,%esp
  804e17:	50                   	push   %eax
  804e18:	53                   	push   %ebx
  804e19:	e8 87 f4 ff ff       	call   8042a5 <mem_realloc>
  804e1e:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804e20:	83 c4 10             	add    $0x10,%esp
  804e23:	85 c0                	test   %eax,%eax
  804e25:	75 bb                	jne    804de2 <pbuf_realloc+0xb6>
  804e27:	83 ec 04             	sub    $0x4,%esp
  804e2a:	68 96 20 81 00       	push   $0x812096
  804e2f:	68 39 01 00 00       	push   $0x139
  804e34:	68 84 1f 81 00       	push   $0x811f84
  804e39:	e8 cb 99 00 00       	call   80e809 <_panic>

00804e3e <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804e3e:	55                   	push   %ebp
  804e3f:	89 e5                	mov    %esp,%ebp
  804e41:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804e44:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804e49:	85 d2                	test   %edx,%edx
  804e4b:	74 07                	je     804e54 <pbuf_clen+0x16>
    ++len;
  804e4d:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804e50:	8b 12                	mov    (%edx),%edx
  804e52:	eb f5                	jmp    804e49 <pbuf_clen+0xb>
  }
  return len;
}
  804e54:	5d                   	pop    %ebp
  804e55:	c3                   	ret    

00804e56 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804e56:	55                   	push   %ebp
  804e57:	89 e5                	mov    %esp,%ebp
  804e59:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804e5c:	85 c0                	test   %eax,%eax
  804e5e:	74 05                	je     804e65 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804e60:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804e65:	5d                   	pop    %ebp
  804e66:	c3                   	ret    

00804e67 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804e67:	55                   	push   %ebp
  804e68:	89 e5                	mov    %esp,%ebp
  804e6a:	53                   	push   %ebx
  804e6b:	83 ec 04             	sub    $0x4,%esp
  804e6e:	8b 45 08             	mov    0x8(%ebp),%eax
  804e71:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804e74:	85 c0                	test   %eax,%eax
  804e76:	74 16                	je     804e8e <pbuf_cat+0x27>
  804e78:	85 db                	test   %ebx,%ebx
  804e7a:	74 12                	je     804e8e <pbuf_cat+0x27>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804e7c:	8b 10                	mov    (%eax),%edx
  804e7e:	85 d2                	test   %edx,%edx
  804e80:	74 23                	je     804ea5 <pbuf_cat+0x3e>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804e82:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804e86:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804e8a:	89 d0                	mov    %edx,%eax
  804e8c:	eb ee                	jmp    804e7c <pbuf_cat+0x15>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804e8e:	83 ec 04             	sub    $0x4,%esp
  804e91:	68 6c 21 81 00       	push   $0x81216c
  804e96:	68 42 02 00 00       	push   $0x242
  804e9b:	68 84 1f 81 00       	push   $0x811f84
  804ea0:	e8 64 99 00 00       	call   80e809 <_panic>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ea5:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804ea9:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804ead:	75 0f                	jne    804ebe <pbuf_cat+0x57>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804eaf:	66 03 53 08          	add    0x8(%ebx),%dx
  804eb3:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804eb7:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804eb9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804ebc:	c9                   	leave  
  804ebd:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804ebe:	83 ec 04             	sub    $0x4,%esp
  804ec1:	68 a4 21 81 00       	push   $0x8121a4
  804ec6:	68 4a 02 00 00       	push   $0x24a
  804ecb:	68 84 1f 81 00       	push   $0x811f84
  804ed0:	e8 34 99 00 00       	call   80e809 <_panic>

00804ed5 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804ed5:	55                   	push   %ebp
  804ed6:	89 e5                	mov    %esp,%ebp
  804ed8:	53                   	push   %ebx
  804ed9:	83 ec 0c             	sub    $0xc,%esp
  804edc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804edf:	53                   	push   %ebx
  804ee0:	ff 75 08             	pushl  0x8(%ebp)
  804ee3:	e8 7f ff ff ff       	call   804e67 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804ee8:	89 1c 24             	mov    %ebx,(%esp)
  804eeb:	e8 66 ff ff ff       	call   804e56 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804ef0:	83 c4 10             	add    $0x10,%esp
  804ef3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804ef6:	c9                   	leave  
  804ef7:	c3                   	ret    

00804ef8 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804ef8:	55                   	push   %ebp
  804ef9:	89 e5                	mov    %esp,%ebp
  804efb:	57                   	push   %edi
  804efc:	56                   	push   %esi
  804efd:	53                   	push   %ebx
  804efe:	83 ec 1c             	sub    $0x1c,%esp
  804f01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804f04:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804f06:	85 f6                	test   %esi,%esi
  804f08:	74 71                	je     804f7b <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f0a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804f0e:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f12:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804f16:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804f19:	0f b7 d0             	movzwl %ax,%edx
  804f1c:	0f b7 f9             	movzwl %cx,%edi
  804f1f:	29 fa                	sub    %edi,%edx
  804f21:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804f24:	75 3e                	jne    804f64 <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804f26:	29 c8                	sub    %ecx,%eax
  804f28:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804f2c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804f32:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f36:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804f3a:	83 ec 0c             	sub    $0xc,%esp
  804f3d:	56                   	push   %esi
  804f3e:	e8 b1 fa ff ff       	call   8049f4 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804f43:	83 c4 10             	add    $0x10,%esp
  804f46:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804f4a:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804f4e:	75 35                	jne    804f85 <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804f50:	84 c0                	test   %al,%al
  804f52:	b8 00 00 00 00       	mov    $0x0,%eax
  804f57:	0f 45 f0             	cmovne %eax,%esi
}
  804f5a:	89 f0                	mov    %esi,%eax
  804f5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804f5f:	5b                   	pop    %ebx
  804f60:	5e                   	pop    %esi
  804f61:	5f                   	pop    %edi
  804f62:	5d                   	pop    %ebp
  804f63:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804f64:	83 ec 04             	sub    $0x4,%esp
  804f67:	68 d4 21 81 00       	push   $0x8121d4
  804f6c:	68 80 02 00 00       	push   $0x280
  804f71:	68 84 1f 81 00       	push   $0x811f84
  804f76:	e8 8e 98 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804f7b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f7f:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804f83:	74 d5                	je     804f5a <pbuf_dechain+0x62>
  804f85:	83 ec 04             	sub    $0x4,%esp
  804f88:	68 b1 20 81 00       	push   $0x8120b1
  804f8d:	68 91 02 00 00       	push   $0x291
  804f92:	68 84 1f 81 00       	push   $0x811f84
  804f97:	e8 6d 98 00 00       	call   80e809 <_panic>

00804f9c <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804f9c:	55                   	push   %ebp
  804f9d:	89 e5                	mov    %esp,%ebp
  804f9f:	57                   	push   %edi
  804fa0:	56                   	push   %esi
  804fa1:	53                   	push   %ebx
  804fa2:	83 ec 1c             	sub    $0x1c,%esp
  804fa5:	8b 7d 08             	mov    0x8(%ebp),%edi
  804fa8:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804fab:	85 ff                	test   %edi,%edi
  804fad:	74 22                	je     804fd1 <pbuf_copy+0x35>
  804faf:	85 db                	test   %ebx,%ebx
  804fb1:	74 1e                	je     804fd1 <pbuf_copy+0x35>
  804fb3:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804fb7:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804fbb:	72 14                	jb     804fd1 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804fbd:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804fc3:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804fc9:	89 7d 08             	mov    %edi,0x8(%ebp)
  804fcc:	e9 92 00 00 00       	jmp    805063 <pbuf_copy+0xc7>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804fd1:	83 ec 04             	sub    $0x4,%esp
  804fd4:	68 f8 21 81 00       	push   $0x8121f8
  804fd9:	68 b1 02 00 00       	push   $0x2b1
  804fde:	68 84 1f 81 00       	push   $0x811f84
  804fe3:	e8 21 98 00 00       	call   80e809 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804fe8:	83 ec 04             	sub    $0x4,%esp
  804feb:	68 c6 20 81 00       	push   $0x8120c6
  804ff0:	68 c2 02 00 00       	push   $0x2c2
  804ff5:	68 84 1f 81 00       	push   $0x811f84
  804ffa:	e8 0a 98 00 00       	call   80e809 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804fff:	8b 45 08             	mov    0x8(%ebp),%eax
  805002:	8b 00                	mov    (%eax),%eax
  805004:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  805007:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80500d:	e9 c7 00 00 00       	jmp    8050d9 <pbuf_copy+0x13d>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805012:	83 ec 04             	sub    $0x4,%esp
  805015:	68 dd 20 81 00       	push   $0x8120dd
  80501a:	68 c8 02 00 00       	push   $0x2c8
  80501f:	68 84 1f 81 00       	push   $0x811f84
  805024:	e8 e0 97 00 00       	call   80e809 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805029:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80502f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805033:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  805037:	0f 84 cf 00 00 00    	je     80510c <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80503d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  805041:	0f 84 05 01 00 00    	je     80514c <pbuf_copy+0x1b0>
  805047:	8b 45 08             	mov    0x8(%ebp),%eax
  80504a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80504e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  805051:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  805055:	0f 84 d1 00 00 00    	je     80512c <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80505b:	85 db                	test   %ebx,%ebx
  80505d:	0f 84 00 01 00 00    	je     805163 <pbuf_copy+0x1c7>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  805063:	8b 45 08             	mov    0x8(%ebp),%eax
  805066:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  80506a:	0f b7 ce             	movzwl %si,%ecx
  80506d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  805071:	29 c1                	sub    %eax,%ecx
  805073:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  805077:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80507b:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  80507d:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  805081:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  805085:	89 f8                	mov    %edi,%eax
  805087:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  80508b:	29 fe                	sub    %edi,%esi
  80508d:	39 d1                	cmp    %edx,%ecx
  80508f:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  805092:	83 ec 04             	sub    $0x4,%esp
  805095:	0f b7 c6             	movzwl %si,%eax
  805098:	50                   	push   %eax
  805099:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80509d:	03 43 04             	add    0x4(%ebx),%eax
  8050a0:	50                   	push   %eax
  8050a1:	0f b7 c7             	movzwl %di,%eax
  8050a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8050a7:	03 41 04             	add    0x4(%ecx),%eax
  8050aa:	50                   	push   %eax
  8050ab:	e8 9e a1 00 00       	call   80f24e <memcpy>
    offset_to += len;
  8050b0:	89 fa                	mov    %edi,%edx
  8050b2:	01 f2                	add    %esi,%edx
  8050b4:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  8050b8:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8050bc:	8b 45 08             	mov    0x8(%ebp),%eax
  8050bf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8050c3:	83 c4 10             	add    $0x10,%esp
  8050c6:	66 39 d0             	cmp    %dx,%ax
  8050c9:	0f 82 19 ff ff ff    	jb     804fe8 <pbuf_copy+0x4c>
    if (offset_to == p_to->len) {
  8050cf:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  8050d3:	0f 84 26 ff ff ff    	je     804fff <pbuf_copy+0x63>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8050d9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8050dd:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  8050e1:	0f 82 2b ff ff ff    	jb     805012 <pbuf_copy+0x76>
    if (offset_from >= p_from->len) {
  8050e7:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  8050eb:	0f 85 3e ff ff ff    	jne    80502f <pbuf_copy+0x93>
      p_from = p_from->next;
  8050f1:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  8050f3:	85 db                	test   %ebx,%ebx
  8050f5:	0f 85 2e ff ff ff    	jne    805029 <pbuf_copy+0x8d>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  8050fb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8050ff:	74 62                	je     805163 <pbuf_copy+0x1c7>
      offset_from = 0;
  805101:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805107:	e9 3b ff ff ff       	jmp    805047 <pbuf_copy+0xab>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80510c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80510f:	0f 84 28 ff ff ff    	je     80503d <pbuf_copy+0xa1>
  805115:	83 ec 04             	sub    $0x4,%esp
  805118:	68 28 22 81 00       	push   $0x812228
  80511d:	68 d2 02 00 00       	push   $0x2d2
  805122:	68 84 1f 81 00       	push   $0x811f84
  805127:	e8 dd 96 00 00       	call   80e809 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80512c:	83 39 00             	cmpl   $0x0,(%ecx)
  80512f:	0f 84 26 ff ff ff    	je     80505b <pbuf_copy+0xbf>
  805135:	83 ec 04             	sub    $0x4,%esp
  805138:	68 28 22 81 00       	push   $0x812228
  80513d:	68 d7 02 00 00       	push   $0x2d7
  805142:	68 84 1f 81 00       	push   $0x811f84
  805147:	e8 bd 96 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80514c:	83 ec 04             	sub    $0x4,%esp
  80514f:	68 f8 20 81 00       	push   $0x8120f8
  805154:	68 b6 02 00 00       	push   $0x2b6
  805159:	68 84 1f 81 00       	push   $0x811f84
  80515e:	e8 a6 96 00 00       	call   80e809 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  805163:	b8 00 00 00 00       	mov    $0x0,%eax
  805168:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80516b:	5b                   	pop    %ebx
  80516c:	5e                   	pop    %esi
  80516d:	5f                   	pop    %edi
  80516e:	5d                   	pop    %ebp
  80516f:	c3                   	ret    

00805170 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  805170:	55                   	push   %ebp
  805171:	89 e5                	mov    %esp,%ebp
  805173:	57                   	push   %edi
  805174:	56                   	push   %esi
  805175:	53                   	push   %ebx
  805176:	83 ec 1c             	sub    $0x1c,%esp
  805179:	8b 75 08             	mov    0x8(%ebp),%esi
  80517c:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  805180:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  805184:	85 f6                	test   %esi,%esi
  805186:	74 0e                	je     805196 <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805188:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80518c:	74 1f                	je     8051ad <pbuf_copy_partial+0x3d>

  left = 0;
  80518e:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805194:	eb 65                	jmp    8051fb <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  805196:	83 ec 04             	sub    $0x4,%esp
  805199:	68 54 22 81 00       	push   $0x812254
  80519e:	68 ef 02 00 00       	push   $0x2ef
  8051a3:	68 84 1f 81 00       	push   $0x811f84
  8051a8:	e8 5c 96 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  8051ad:	83 ec 04             	sub    $0x4,%esp
  8051b0:	68 78 22 81 00       	push   $0x812278
  8051b5:	68 f0 02 00 00       	push   $0x2f0
  8051ba:	68 84 1f 81 00       	push   $0x811f84
  8051bf:	e8 45 96 00 00       	call   80e809 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  8051c4:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  8051c8:	29 c3                	sub    %eax,%ebx
  8051ca:	66 39 df             	cmp    %bx,%di
  8051cd:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  8051d0:	83 ec 04             	sub    $0x4,%esp
  8051d3:	0f b7 d3             	movzwl %bx,%edx
  8051d6:	52                   	push   %edx
  8051d7:	0f b7 c0             	movzwl %ax,%eax
  8051da:	03 46 04             	add    0x4(%esi),%eax
  8051dd:	50                   	push   %eax
  8051de:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8051e2:	03 45 0c             	add    0xc(%ebp),%eax
  8051e5:	50                   	push   %eax
  8051e6:	e8 63 a0 00 00       	call   80f24e <memcpy>
      copied_total += buf_copy_len;
  8051eb:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  8051ef:	29 df                	sub    %ebx,%edi
  8051f1:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  8051f4:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8051f9:	8b 36                	mov    (%esi),%esi
  8051fb:	66 85 ff             	test   %di,%di
  8051fe:	74 16                	je     805216 <pbuf_copy_partial+0xa6>
  805200:	85 f6                	test   %esi,%esi
  805202:	74 12                	je     805216 <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  805204:	66 85 c0             	test   %ax,%ax
  805207:	74 bb                	je     8051c4 <pbuf_copy_partial+0x54>
  805209:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80520d:	66 39 c2             	cmp    %ax,%dx
  805210:	77 b2                	ja     8051c4 <pbuf_copy_partial+0x54>
      offset -= p->len;
  805212:	29 d0                	sub    %edx,%eax
  805214:	eb e3                	jmp    8051f9 <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  805216:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80521a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80521d:	5b                   	pop    %ebx
  80521e:	5e                   	pop    %esi
  80521f:	5f                   	pop    %edi
  805220:	5d                   	pop    %ebp
  805221:	c3                   	ret    

00805222 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  805222:	55                   	push   %ebp
  805223:	89 e5                	mov    %esp,%ebp
  805225:	83 ec 14             	sub    $0x14,%esp
  805228:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80522b:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  805230:	8b 40 04             	mov    0x4(%eax),%eax
  805233:	ff 30                	pushl  (%eax)
  805235:	e8 2a 50 00 00       	call   80a264 <sys_sem_signal>
}
  80523a:	83 c4 10             	add    $0x10,%esp
  80523d:	c9                   	leave  
  80523e:	c3                   	ret    

0080523f <sys_mbox_fetch>:
{
  80523f:	55                   	push   %ebp
  805240:	89 e5                	mov    %esp,%ebp
  805242:	57                   	push   %edi
  805243:	56                   	push   %esi
  805244:	53                   	push   %ebx
  805245:	83 ec 0c             	sub    $0xc,%esp
  805248:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80524b:	eb 40                	jmp    80528d <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80524d:	83 ec 04             	sub    $0x4,%esp
  805250:	6a 00                	push   $0x0
  805252:	57                   	push   %edi
  805253:	ff 75 08             	pushl  0x8(%ebp)
  805256:	e8 7e 52 00 00       	call   80a4d9 <sys_arch_mbox_fetch>
  80525b:	83 c4 10             	add    $0x10,%esp
}
  80525e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805261:	5b                   	pop    %ebx
  805262:	5e                   	pop    %esi
  805263:	5f                   	pop    %edi
  805264:	5d                   	pop    %ebp
  805265:	c3                   	ret    
      tmptimeout = timeouts->next;
  805266:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805268:	8b 10                	mov    (%eax),%edx
  80526a:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  80526c:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80526f:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805272:	83 ec 08             	sub    $0x8,%esp
  805275:	50                   	push   %eax
  805276:	6a 0b                	push   $0xb
  805278:	e8 2a f4 ff ff       	call   8046a7 <memp_free>
      if (h != NULL) {
  80527d:	83 c4 10             	add    $0x10,%esp
  805280:	85 db                	test   %ebx,%ebx
  805282:	74 09                	je     80528d <sys_mbox_fetch+0x4e>
        h(arg);
  805284:	83 ec 0c             	sub    $0xc,%esp
  805287:	56                   	push   %esi
  805288:	ff d3                	call   *%ebx
  80528a:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80528d:	e8 dc 53 00 00       	call   80a66e <sys_arch_timeouts>
  805292:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805294:	85 c0                	test   %eax,%eax
  805296:	74 b5                	je     80524d <sys_mbox_fetch+0xe>
  805298:	8b 00                	mov    (%eax),%eax
  80529a:	85 c0                	test   %eax,%eax
  80529c:	74 af                	je     80524d <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  80529e:	8b 40 04             	mov    0x4(%eax),%eax
  8052a1:	85 c0                	test   %eax,%eax
  8052a3:	74 c1                	je     805266 <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8052a5:	83 ec 04             	sub    $0x4,%esp
  8052a8:	50                   	push   %eax
  8052a9:	57                   	push   %edi
  8052aa:	ff 75 08             	pushl  0x8(%ebp)
  8052ad:	e8 27 52 00 00       	call   80a4d9 <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8052b2:	83 c4 10             	add    $0x10,%esp
  8052b5:	83 f8 ff             	cmp    $0xffffffff,%eax
  8052b8:	74 ac                	je     805266 <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  8052ba:	8b 1b                	mov    (%ebx),%ebx
  8052bc:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8052bf:	89 ca                	mov    %ecx,%edx
  8052c1:	29 c2                	sub    %eax,%edx
  8052c3:	39 c1                	cmp    %eax,%ecx
  8052c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8052ca:	0f 46 d0             	cmovbe %eax,%edx
  8052cd:	89 53 04             	mov    %edx,0x4(%ebx)
  8052d0:	eb 8c                	jmp    80525e <sys_mbox_fetch+0x1f>

008052d2 <sys_sem_wait>:
{
  8052d2:	55                   	push   %ebp
  8052d3:	89 e5                	mov    %esp,%ebp
  8052d5:	57                   	push   %edi
  8052d6:	56                   	push   %esi
  8052d7:	53                   	push   %ebx
  8052d8:	83 ec 0c             	sub    $0xc,%esp
  8052db:	8b 75 08             	mov    0x8(%ebp),%esi
  8052de:	eb 3d                	jmp    80531d <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  8052e0:	83 ec 08             	sub    $0x8,%esp
  8052e3:	6a 00                	push   $0x0
  8052e5:	56                   	push   %esi
  8052e6:	e8 e9 4f 00 00       	call   80a2d4 <sys_arch_sem_wait>
  8052eb:	83 c4 10             	add    $0x10,%esp
}
  8052ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8052f1:	5b                   	pop    %ebx
  8052f2:	5e                   	pop    %esi
  8052f3:	5f                   	pop    %edi
  8052f4:	5d                   	pop    %ebp
  8052f5:	c3                   	ret    
      tmptimeout = timeouts->next;
  8052f6:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8052f8:	8b 10                	mov    (%eax),%edx
  8052fa:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8052fc:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8052ff:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805302:	83 ec 08             	sub    $0x8,%esp
  805305:	50                   	push   %eax
  805306:	6a 0b                	push   $0xb
  805308:	e8 9a f3 ff ff       	call   8046a7 <memp_free>
      if (h != NULL) {
  80530d:	83 c4 10             	add    $0x10,%esp
  805310:	85 db                	test   %ebx,%ebx
  805312:	74 09                	je     80531d <sys_sem_wait+0x4b>
        h(arg);
  805314:	83 ec 0c             	sub    $0xc,%esp
  805317:	57                   	push   %edi
  805318:	ff d3                	call   *%ebx
  80531a:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  80531d:	e8 4c 53 00 00       	call   80a66e <sys_arch_timeouts>
  805322:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  805324:	85 c0                	test   %eax,%eax
  805326:	74 b8                	je     8052e0 <sys_sem_wait+0xe>
  805328:	8b 00                	mov    (%eax),%eax
  80532a:	85 c0                	test   %eax,%eax
  80532c:	74 b2                	je     8052e0 <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  80532e:	8b 40 04             	mov    0x4(%eax),%eax
  805331:	85 c0                	test   %eax,%eax
  805333:	74 c1                	je     8052f6 <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  805335:	83 ec 08             	sub    $0x8,%esp
  805338:	50                   	push   %eax
  805339:	56                   	push   %esi
  80533a:	e8 95 4f 00 00       	call   80a2d4 <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  80533f:	83 c4 10             	add    $0x10,%esp
  805342:	83 f8 ff             	cmp    $0xffffffff,%eax
  805345:	74 af                	je     8052f6 <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  805347:	8b 1b                	mov    (%ebx),%ebx
  805349:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  80534c:	89 ca                	mov    %ecx,%edx
  80534e:	29 c2                	sub    %eax,%edx
  805350:	39 c1                	cmp    %eax,%ecx
  805352:	b8 00 00 00 00       	mov    $0x0,%eax
  805357:	0f 46 d0             	cmovbe %eax,%edx
  80535a:	89 53 04             	mov    %edx,0x4(%ebx)
  80535d:	eb 8f                	jmp    8052ee <sys_sem_wait+0x1c>

0080535f <sys_timeout>:
{
  80535f:	55                   	push   %ebp
  805360:	89 e5                	mov    %esp,%ebp
  805362:	57                   	push   %edi
  805363:	56                   	push   %esi
  805364:	53                   	push   %ebx
  805365:	83 ec 28             	sub    $0x28,%esp
  805368:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80536b:	6a 0b                	push   $0xb
  80536d:	e8 df f2 ff ff       	call   804651 <memp_malloc>
  if (timeout == NULL) {
  805372:	83 c4 10             	add    $0x10,%esp
  805375:	85 c0                	test   %eax,%eax
  805377:	74 40                	je     8053b9 <sys_timeout+0x5a>
  805379:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  80537b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805381:	8b 45 0c             	mov    0xc(%ebp),%eax
  805384:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  805387:	8b 45 10             	mov    0x10(%ebp),%eax
  80538a:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  80538d:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  805390:	e8 d9 52 00 00       	call   80a66e <sys_arch_timeouts>
  if (timeouts == NULL) {
  805395:	85 c0                	test   %eax,%eax
  805397:	74 37                	je     8053d0 <sys_timeout+0x71>
  if (timeouts->next == NULL) {
  805399:	8b 10                	mov    (%eax),%edx
  80539b:	85 d2                	test   %edx,%edx
  80539d:	74 48                	je     8053e7 <sys_timeout+0x88>
  if (timeouts->next->time > msecs) {
  80539f:	8b 4a 04             	mov    0x4(%edx),%ecx
  8053a2:	39 f1                	cmp    %esi,%ecx
  8053a4:	76 47                	jbe    8053ed <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  8053a6:	29 f1                	sub    %esi,%ecx
  8053a8:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  8053ab:	8b 10                	mov    (%eax),%edx
  8053ad:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8053af:	89 18                	mov    %ebx,(%eax)
}
  8053b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8053b4:	5b                   	pop    %ebx
  8053b5:	5e                   	pop    %esi
  8053b6:	5f                   	pop    %edi
  8053b7:	5d                   	pop    %ebp
  8053b8:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  8053b9:	83 ec 04             	sub    $0x4,%esp
  8053bc:	68 9d 22 81 00       	push   $0x81229d
  8053c1:	68 c3 00 00 00       	push   $0xc3
  8053c6:	68 ba 22 81 00       	push   $0x8122ba
  8053cb:	e8 39 94 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8053d0:	83 ec 04             	sub    $0x4,%esp
  8053d3:	68 ce 22 81 00       	push   $0x8122ce
  8053d8:	68 d1 00 00 00       	push   $0xd1
  8053dd:	68 ba 22 81 00       	push   $0x8122ba
  8053e2:	e8 22 94 00 00       	call   80e809 <_panic>
    timeouts->next = timeout;
  8053e7:	89 18                	mov    %ebx,(%eax)
    return;
  8053e9:	eb c6                	jmp    8053b1 <sys_timeout+0x52>
      if (t->next == NULL || t->next->time > timeout->time) {
  8053eb:	89 c2                	mov    %eax,%edx
      timeout->time -= t->time;
  8053ed:	8b 7b 04             	mov    0x4(%ebx),%edi
  8053f0:	8b 42 04             	mov    0x4(%edx),%eax
  8053f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8053f6:	89 f9                	mov    %edi,%ecx
  8053f8:	29 c1                	sub    %eax,%ecx
  8053fa:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  8053fd:	8b 02                	mov    (%edx),%eax
  8053ff:	85 c0                	test   %eax,%eax
  805401:	74 17                	je     80541a <sys_timeout+0xbb>
  805403:	8b 70 04             	mov    0x4(%eax),%esi
  805406:	89 75 e0             	mov    %esi,-0x20(%ebp)
  805409:	39 f1                	cmp    %esi,%ecx
  80540b:	73 de                	jae    8053eb <sys_timeout+0x8c>
  80540d:	8b 75 e4             	mov    -0x1c(%ebp),%esi
          t->next->time -= timeout->time;
  805410:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  805413:	29 f9                	sub    %edi,%ecx
  805415:	01 ce                	add    %ecx,%esi
  805417:	89 70 04             	mov    %esi,0x4(%eax)
        timeout->next = t->next;
  80541a:	8b 02                	mov    (%edx),%eax
  80541c:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  80541e:	89 1a                	mov    %ebx,(%edx)
        break;
  805420:	eb 8f                	jmp    8053b1 <sys_timeout+0x52>

00805422 <sys_untimeout>:
{
  805422:	55                   	push   %ebp
  805423:	89 e5                	mov    %esp,%ebp
  805425:	57                   	push   %edi
  805426:	56                   	push   %esi
  805427:	53                   	push   %ebx
  805428:	83 ec 0c             	sub    $0xc,%esp
  80542b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80542e:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  805431:	e8 38 52 00 00       	call   80a66e <sys_arch_timeouts>
  if (timeouts == NULL) {
  805436:	85 c0                	test   %eax,%eax
  805438:	74 0d                	je     805447 <sys_untimeout+0x25>
  if (timeouts->next == NULL) {
  80543a:	8b 10                	mov    (%eax),%edx
  80543c:	85 d2                	test   %edx,%edx
  80543e:	74 5a                	je     80549a <sys_untimeout+0x78>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805440:	bf 00 00 00 00       	mov    $0x0,%edi
  805445:	eb 27                	jmp    80546e <sys_untimeout+0x4c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  805447:	83 ec 04             	sub    $0x4,%esp
  80544a:	68 ec 22 81 00       	push   $0x8122ec
  80544f:	68 00 01 00 00       	push   $0x100
  805454:	68 ba 22 81 00       	push   $0x8122ba
  805459:	e8 ab 93 00 00       	call   80e809 <_panic>
        timeouts->next = t->next;
  80545e:	8b 0a                	mov    (%edx),%ecx
  805460:	89 08                	mov    %ecx,(%eax)
  805462:	eb 1c                	jmp    805480 <sys_untimeout+0x5e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805464:	8b 0a                	mov    (%edx),%ecx
  805466:	89 d7                	mov    %edx,%edi
  805468:	85 c9                	test   %ecx,%ecx
  80546a:	74 2e                	je     80549a <sys_untimeout+0x78>
  80546c:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  80546e:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805471:	75 f1                	jne    805464 <sys_untimeout+0x42>
  805473:	39 72 0c             	cmp    %esi,0xc(%edx)
  805476:	75 ec                	jne    805464 <sys_untimeout+0x42>
      if (prev_t == NULL)
  805478:	85 ff                	test   %edi,%edi
  80547a:	74 e2                	je     80545e <sys_untimeout+0x3c>
        prev_t->next = t->next;
  80547c:	8b 02                	mov    (%edx),%eax
  80547e:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  805480:	8b 02                	mov    (%edx),%eax
  805482:	85 c0                	test   %eax,%eax
  805484:	74 06                	je     80548c <sys_untimeout+0x6a>
        t->next->time += t->time;
  805486:	8b 4a 04             	mov    0x4(%edx),%ecx
  805489:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80548c:	83 ec 08             	sub    $0x8,%esp
  80548f:	52                   	push   %edx
  805490:	6a 0b                	push   $0xb
  805492:	e8 10 f2 ff ff       	call   8046a7 <memp_free>
      return;
  805497:	83 c4 10             	add    $0x10,%esp
}
  80549a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80549d:	5b                   	pop    %ebx
  80549e:	5e                   	pop    %esi
  80549f:	5f                   	pop    %edi
  8054a0:	5d                   	pop    %ebp
  8054a1:	c3                   	ret    

008054a2 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8054a2:	55                   	push   %ebp
  8054a3:	89 e5                	mov    %esp,%ebp
  8054a5:	83 ec 18             	sub    $0x18,%esp
  8054a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8054ab:	8d 4d 08             	lea    0x8(%ebp),%ecx
  8054ae:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8054b1:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8054b7:	85 c0                	test   %eax,%eax
  8054b9:	75 1c                	jne    8054d7 <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  8054bb:	83 ec 0c             	sub    $0xc,%esp
  8054be:	ff 75 08             	pushl  0x8(%ebp)
  8054c1:	e8 0c fe ff ff       	call   8052d2 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  8054c6:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  8054c9:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  8054ce:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  8054d3:	74 19                	je     8054ee <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  8054d5:	c9                   	leave  
  8054d6:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8054d7:	83 ec 04             	sub    $0x4,%esp
  8054da:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8054dd:	52                   	push   %edx
  8054de:	68 22 52 80 00       	push   $0x805222
  8054e3:	50                   	push   %eax
  8054e4:	e8 76 fe ff ff       	call   80535f <sys_timeout>
  8054e9:	83 c4 10             	add    $0x10,%esp
  8054ec:	eb cd                	jmp    8054bb <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  8054ee:	83 ec 08             	sub    $0x8,%esp
  8054f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8054f4:	50                   	push   %eax
  8054f5:	68 22 52 80 00       	push   $0x805222
  8054fa:	e8 23 ff ff ff       	call   805422 <sys_untimeout>
    return 1;
  8054ff:	83 c4 10             	add    $0x10,%esp
  805502:	b8 01 00 00 00       	mov    $0x1,%eax
  805507:	eb cc                	jmp    8054d5 <sys_sem_wait_timeout+0x33>

00805509 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  805509:	55                   	push   %ebp
  80550a:	89 e5                	mov    %esp,%ebp
  80550c:	53                   	push   %ebx
  80550d:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805510:	6a 00                	push   $0x0
  805512:	e8 90 4a 00 00       	call   809fa7 <sys_sem_new>
  805517:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  805519:	83 c4 08             	add    $0x8,%esp
  80551c:	ff 75 08             	pushl  0x8(%ebp)
  80551f:	50                   	push   %eax
  805520:	e8 7d ff ff ff       	call   8054a2 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  805525:	89 1c 24             	mov    %ebx,(%esp)
  805528:	e8 fb 4a 00 00       	call   80a028 <sys_sem_free>
}
  80552d:	83 c4 10             	add    $0x10,%esp
  805530:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805533:	c9                   	leave  
  805534:	c3                   	ret    

00805535 <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  805535:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80553a:	c3                   	ret    

0080553b <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80553b:	55                   	push   %ebp
  80553c:	89 e5                	mov    %esp,%ebp
  80553e:	57                   	push   %edi
  80553f:	56                   	push   %esi
  805540:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805541:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805547:	8b 35 50 c2 b3 00    	mov    0xb3c250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80554d:	8b 3d 44 c2 b3 00    	mov    0xb3c244,%edi
  805553:	0f b7 05 0c 50 81 00 	movzwl 0x81500c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  80555a:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80555f:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  805563:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805566:	89 da                	mov    %ebx,%edx
  805568:	85 d2                	test   %edx,%edx
  80556a:	74 0b                	je     805577 <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  80556c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805570:	74 ed                	je     80555f <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805572:	8b 52 0c             	mov    0xc(%edx),%edx
  805575:	eb f1                	jmp    805568 <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805577:	89 f2                	mov    %esi,%edx
  805579:	85 d2                	test   %edx,%edx
  80557b:	74 0b                	je     805588 <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  80557d:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805581:	74 dc                	je     80555f <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805583:	8b 52 0c             	mov    0xc(%edx),%edx
  805586:	eb f1                	jmp    805579 <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805588:	89 fa                	mov    %edi,%edx
  80558a:	85 d2                	test   %edx,%edx
  80558c:	74 0b                	je     805599 <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  80558e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805592:	74 cb                	je     80555f <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805594:	8b 52 0c             	mov    0xc(%edx),%edx
  805597:	eb f1                	jmp    80558a <tcp_new_port+0x4f>
  805599:	66 a3 0c 50 81 00    	mov    %ax,0x81500c
      goto again;
    }
  }
  return port;
}
  80559f:	5b                   	pop    %ebx
  8055a0:	5e                   	pop    %esi
  8055a1:	5f                   	pop    %edi
  8055a2:	5d                   	pop    %ebp
  8055a3:	c3                   	ret    

008055a4 <tcp_bind>:
{
  8055a4:	55                   	push   %ebp
  8055a5:	89 e5                	mov    %esp,%ebp
  8055a7:	57                   	push   %edi
  8055a8:	56                   	push   %esi
  8055a9:	53                   	push   %ebx
  8055aa:	83 ec 0c             	sub    $0xc,%esp
  8055ad:	8b 75 08             	mov    0x8(%ebp),%esi
  8055b0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8055b3:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8055b6:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8055ba:	75 0f                	jne    8055cb <tcp_bind+0x27>
  8055bc:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  8055be:	66 85 d2             	test   %dx,%dx
  8055c1:	74 1f                	je     8055e2 <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8055c3:	8b 15 44 c2 b3 00    	mov    0xb3c244,%edx
  8055c9:	eb 21                	jmp    8055ec <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8055cb:	83 ec 04             	sub    $0x4,%esp
  8055ce:	68 0c 23 81 00       	push   $0x81230c
  8055d3:	68 05 01 00 00       	push   $0x105
  8055d8:	68 ee 24 81 00       	push   $0x8124ee
  8055dd:	e8 27 92 00 00       	call   80e809 <_panic>
    port = tcp_new_port();
  8055e2:	e8 54 ff ff ff       	call   80553b <tcp_new_port>
  8055e7:	eb da                	jmp    8055c3 <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  8055e9:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  8055ec:	85 d2                	test   %edx,%edx
  8055ee:	74 2c                	je     80561c <tcp_bind+0x78>
    if (cpcb->local_port == port) {
  8055f0:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8055f4:	75 f3                	jne    8055e9 <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8055f6:	8b 0a                	mov    (%edx),%ecx
  8055f8:	85 db                	test   %ebx,%ebx
  8055fa:	0f 84 d4 00 00 00    	je     8056d4 <tcp_bind+0x130>
  805600:	85 c9                	test   %ecx,%ecx
  805602:	0f 84 cc 00 00 00    	je     8056d4 <tcp_bind+0x130>
          ip_addr_isany(ipaddr) ||
  805608:	8b 3b                	mov    (%ebx),%edi
  80560a:	39 f9                	cmp    %edi,%ecx
  80560c:	74 04                	je     805612 <tcp_bind+0x6e>
  80560e:	85 ff                	test   %edi,%edi
  805610:	75 d7                	jne    8055e9 <tcp_bind+0x45>
        return ERR_USE;
  805612:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805617:	e9 bd 00 00 00       	jmp    8056d9 <tcp_bind+0x135>
  for(cpcb = tcp_active_pcbs;
  80561c:	8b 15 3c c2 b3 00    	mov    0xb3c23c,%edx
  805622:	eb 03                	jmp    805627 <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  805624:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  805627:	85 d2                	test   %edx,%edx
  805629:	74 2c                	je     805657 <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  80562b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80562f:	75 f3                	jne    805624 <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805631:	8b 0a                	mov    (%edx),%ecx
  805633:	85 db                	test   %ebx,%ebx
  805635:	0f 84 a6 00 00 00    	je     8056e1 <tcp_bind+0x13d>
  80563b:	85 c9                	test   %ecx,%ecx
  80563d:	0f 84 9e 00 00 00    	je     8056e1 <tcp_bind+0x13d>
          ip_addr_isany(ipaddr) ||
  805643:	8b 3b                	mov    (%ebx),%edi
  805645:	39 f9                	cmp    %edi,%ecx
  805647:	74 04                	je     80564d <tcp_bind+0xa9>
  805649:	85 ff                	test   %edi,%edi
  80564b:	75 d7                	jne    805624 <tcp_bind+0x80>
        return ERR_USE;
  80564d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805652:	e9 82 00 00 00       	jmp    8056d9 <tcp_bind+0x135>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805657:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  80565d:	eb 03                	jmp    805662 <tcp_bind+0xbe>
  80565f:	8b 52 0c             	mov    0xc(%edx),%edx
  805662:	85 d2                	test   %edx,%edx
  805664:	74 21                	je     805687 <tcp_bind+0xe3>
    if (cpcb->local_port == port) {
  805666:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80566a:	75 f3                	jne    80565f <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80566c:	8b 0a                	mov    (%edx),%ecx
  80566e:	85 db                	test   %ebx,%ebx
  805670:	74 76                	je     8056e8 <tcp_bind+0x144>
  805672:	85 c9                	test   %ecx,%ecx
  805674:	74 72                	je     8056e8 <tcp_bind+0x144>
          ip_addr_isany(ipaddr) ||
  805676:	8b 3b                	mov    (%ebx),%edi
  805678:	39 f9                	cmp    %edi,%ecx
  80567a:	74 04                	je     805680 <tcp_bind+0xdc>
  80567c:	85 ff                	test   %edi,%edi
  80567e:	75 df                	jne    80565f <tcp_bind+0xbb>
        return ERR_USE;
  805680:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805685:	eb 52                	jmp    8056d9 <tcp_bind+0x135>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805687:	8b 15 50 c2 b3 00    	mov    0xb3c250,%edx
  80568d:	eb 03                	jmp    805692 <tcp_bind+0xee>
  80568f:	8b 52 0c             	mov    0xc(%edx),%edx
  805692:	85 d2                	test   %edx,%edx
  805694:	74 13                	je     8056a9 <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  805696:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80569a:	75 f3                	jne    80568f <tcp_bind+0xeb>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80569c:	8b 3b                	mov    (%ebx),%edi
  80569e:	39 3a                	cmp    %edi,(%edx)
  8056a0:	75 ed                	jne    80568f <tcp_bind+0xeb>
        return ERR_USE;
  8056a2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056a7:	eb 30                	jmp    8056d9 <tcp_bind+0x135>
  if (!ip_addr_isany(ipaddr)) {
  8056a9:	85 db                	test   %ebx,%ebx
  8056ab:	74 09                	je     8056b6 <tcp_bind+0x112>
  8056ad:	83 3b 00             	cmpl   $0x0,(%ebx)
  8056b0:	74 04                	je     8056b6 <tcp_bind+0x112>
    pcb->local_ip = *ipaddr;
  8056b2:	8b 13                	mov    (%ebx),%edx
  8056b4:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  8056b6:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8056ba:	a1 4c c2 b3 00       	mov    0xb3c24c,%eax
  8056bf:	89 46 0c             	mov    %eax,0xc(%esi)
  8056c2:	89 35 4c c2 b3 00    	mov    %esi,0xb3c24c
  8056c8:	e8 fd cc ff ff       	call   8023ca <tcp_timer_needed>
  return ERR_OK;
  8056cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8056d2:	eb 05                	jmp    8056d9 <tcp_bind+0x135>
        return ERR_USE;
  8056d4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8056d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8056dc:	5b                   	pop    %ebx
  8056dd:	5e                   	pop    %esi
  8056de:	5f                   	pop    %edi
  8056df:	5d                   	pop    %ebp
  8056e0:	c3                   	ret    
        return ERR_USE;
  8056e1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056e6:	eb f1                	jmp    8056d9 <tcp_bind+0x135>
        return ERR_USE;
  8056e8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8056ed:	eb ea                	jmp    8056d9 <tcp_bind+0x135>

008056ef <tcp_listen_with_backlog>:
{
  8056ef:	55                   	push   %ebp
  8056f0:	89 e5                	mov    %esp,%ebp
  8056f2:	57                   	push   %edi
  8056f3:	56                   	push   %esi
  8056f4:	53                   	push   %ebx
  8056f5:	83 ec 1c             	sub    $0x1c,%esp
  8056f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8056fb:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8056ff:	0f 85 80 00 00 00    	jne    805785 <tcp_listen_with_backlog+0x96>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805705:	83 ec 0c             	sub    $0xc,%esp
  805708:	6a 03                	push   $0x3
  80570a:	e8 42 ef ff ff       	call   804651 <memp_malloc>
  80570f:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805711:	83 c4 10             	add    $0x10,%esp
  805714:	85 c0                	test   %eax,%eax
  805716:	0f 84 b7 00 00 00    	je     8057d3 <tcp_listen_with_backlog+0xe4>
  lpcb->callback_arg = pcb->callback_arg;
  80571c:	8b 43 18             	mov    0x18(%ebx),%eax
  80571f:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805722:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805726:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80572a:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  805731:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805735:	83 c8 02             	or     $0x2,%eax
  805738:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80573c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805740:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805743:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805747:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80574a:	8b 03                	mov    (%ebx),%eax
  80574c:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80574e:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  805754:	39 da                	cmp    %ebx,%edx
  805756:	74 44                	je     80579c <tcp_listen_with_backlog+0xad>
  805758:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  80575e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  805762:	89 df                	mov    %ebx,%edi
  805764:	85 d2                	test   %edx,%edx
  805766:	0f 84 87 00 00 00    	je     8057f3 <tcp_listen_with_backlog+0x104>
  80576c:	8b 42 0c             	mov    0xc(%edx),%eax
  80576f:	39 f8                	cmp    %edi,%eax
  805771:	0f 94 c3             	sete   %bl
  805774:	85 c0                	test   %eax,%eax
  805776:	0f 95 c1             	setne  %cl
  805779:	84 cb                	test   %cl,%bl
  80577b:	75 60                	jne    8057dd <tcp_listen_with_backlog+0xee>
  80577d:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805781:	89 c2                	mov    %eax,%edx
  805783:	eb df                	jmp    805764 <tcp_listen_with_backlog+0x75>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805785:	83 ec 04             	sub    $0x4,%esp
  805788:	68 38 23 81 00       	push   $0x812338
  80578d:	68 60 01 00 00       	push   $0x160
  805792:	68 ee 24 81 00       	push   $0x8124ee
  805797:	e8 6d 90 00 00       	call   80e809 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80579c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80579f:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  8057a4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8057ab:	83 ec 08             	sub    $0x8,%esp
  8057ae:	53                   	push   %ebx
  8057af:	6a 02                	push   $0x2
  8057b1:	e8 f1 ee ff ff       	call   8046a7 <memp_free>
  lpcb->accept = tcp_accept_null;
  8057b6:	c7 46 20 35 55 80 00 	movl   $0x805535,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8057bd:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  8057c2:	89 46 0c             	mov    %eax,0xc(%esi)
  8057c5:	89 35 44 c2 b3 00    	mov    %esi,0xb3c244
  8057cb:	e8 fa cb ff ff       	call   8023ca <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8057d0:	83 c4 10             	add    $0x10,%esp
}
  8057d3:	89 f0                	mov    %esi,%eax
  8057d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8057d8:	5b                   	pop    %ebx
  8057d9:	5e                   	pop    %esi
  8057da:	5f                   	pop    %edi
  8057db:	5d                   	pop    %ebp
  8057dc:	c3                   	ret    
  8057dd:	89 fb                	mov    %edi,%ebx
  8057df:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8057e3:	74 06                	je     8057eb <tcp_listen_with_backlog+0xfc>
  8057e5:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8057eb:	8b 43 0c             	mov    0xc(%ebx),%eax
  8057ee:	89 42 0c             	mov    %eax,0xc(%edx)
  8057f1:	eb b1                	jmp    8057a4 <tcp_listen_with_backlog+0xb5>
  8057f3:	89 fb                	mov    %edi,%ebx
  8057f5:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  8057f9:	74 a9                	je     8057a4 <tcp_listen_with_backlog+0xb5>
  8057fb:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805802:	00 00 00 
  805805:	eb 9d                	jmp    8057a4 <tcp_listen_with_backlog+0xb5>

00805807 <tcp_recved>:
{
  805807:	55                   	push   %ebp
  805808:	89 e5                	mov    %esp,%ebp
  80580a:	56                   	push   %esi
  80580b:	53                   	push   %ebx
  80580c:	8b 45 08             	mov    0x8(%ebp),%eax
  80580f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805812:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  805816:	0f b7 ca             	movzwl %dx,%ecx
  805819:	0f b7 f3             	movzwl %bx,%esi
  80581c:	01 f1                	add    %esi,%ecx
  80581e:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  805824:	76 27                	jbe    80584d <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  805826:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80582c:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  805832:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805836:	f6 c2 03             	test   $0x3,%dl
  805839:	75 3b                	jne    805876 <tcp_recved+0x6f>
    tcp_ack(pcb);
  80583b:	f6 c2 01             	test   $0x1,%dl
  80583e:	75 1f                	jne    80585f <tcp_recved+0x58>
  805840:	83 ca 01             	or     $0x1,%edx
  805843:	88 50 20             	mov    %dl,0x20(%eax)
}
  805846:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805849:	5b                   	pop    %ebx
  80584a:	5e                   	pop    %esi
  80584b:	5d                   	pop    %ebp
  80584c:	c3                   	ret    
    pcb->rcv_wnd += len;
  80584d:	01 da                	add    %ebx,%edx
  80584f:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805853:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805857:	72 d9                	jb     805832 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805859:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  80585d:	eb d3                	jmp    805832 <tcp_recved+0x2b>
    tcp_ack(pcb);
  80585f:	83 e2 fe             	and    $0xfffffffe,%edx
  805862:	83 ca 02             	or     $0x2,%edx
  805865:	88 50 20             	mov    %dl,0x20(%eax)
  805868:	83 ec 0c             	sub    $0xc,%esp
  80586b:	50                   	push   %eax
  80586c:	e8 be 29 00 00       	call   80822f <tcp_output>
  805871:	83 c4 10             	add    $0x10,%esp
  805874:	eb d0                	jmp    805846 <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805876:	f6 c2 01             	test   $0x1,%dl
  805879:	74 cb                	je     805846 <tcp_recved+0x3f>
  80587b:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805881:	76 c3                	jbe    805846 <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805883:	83 ca 02             	or     $0x2,%edx
  805886:	88 50 20             	mov    %dl,0x20(%eax)
  805889:	83 ec 0c             	sub    $0xc,%esp
  80588c:	50                   	push   %eax
  80588d:	e8 9d 29 00 00       	call   80822f <tcp_output>
  805892:	83 c4 10             	add    $0x10,%esp
}
  805895:	eb af                	jmp    805846 <tcp_recved+0x3f>

00805897 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805897:	55                   	push   %ebp
  805898:	89 e5                	mov    %esp,%ebp
  80589a:	53                   	push   %ebx
  80589b:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80589e:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
  8058a4:	eb 21                	jmp    8058c7 <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8058a6:	83 ec 0c             	sub    $0xc,%esp
  8058a9:	50                   	push   %eax
  8058aa:	e8 45 f1 ff ff       	call   8049f4 <pbuf_free>
  8058af:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  8058b2:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8058b9:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  8058bc:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8058c0:	a8 01                	test   $0x1,%al
  8058c2:	75 2d                	jne    8058f1 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8058c4:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8058c7:	85 db                	test   %ebx,%ebx
  8058c9:	74 3e                	je     805909 <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  8058cb:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8058d1:	85 c0                	test   %eax,%eax
  8058d3:	74 e7                	je     8058bc <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  8058d5:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  8058db:	85 d2                	test   %edx,%edx
  8058dd:	74 c7                	je     8058a6 <tcp_fasttmr+0xf>
  8058df:	6a 00                	push   $0x0
  8058e1:	50                   	push   %eax
  8058e2:	53                   	push   %ebx
  8058e3:	ff 73 18             	pushl  0x18(%ebx)
  8058e6:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  8058e8:	83 c4 10             	add    $0x10,%esp
  8058eb:	84 c0                	test   %al,%al
  8058ed:	74 c3                	je     8058b2 <tcp_fasttmr+0x1b>
  8058ef:	eb cb                	jmp    8058bc <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  8058f1:	83 c8 02             	or     $0x2,%eax
  8058f4:	88 43 20             	mov    %al,0x20(%ebx)
  8058f7:	83 ec 0c             	sub    $0xc,%esp
  8058fa:	53                   	push   %ebx
  8058fb:	e8 2f 29 00 00       	call   80822f <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805900:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  805904:	83 c4 10             	add    $0x10,%esp
  805907:	eb bb                	jmp    8058c4 <tcp_fasttmr+0x2d>
    }
  }
}
  805909:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80590c:	c9                   	leave  
  80590d:	c3                   	ret    

0080590e <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80590e:	55                   	push   %ebp
  80590f:	89 e5                	mov    %esp,%ebp
  805911:	56                   	push   %esi
  805912:	53                   	push   %ebx
  805913:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  805916:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  80591b:	85 db                	test   %ebx,%ebx
  80591d:	74 23                	je     805942 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  80591f:	8b 43 04             	mov    0x4(%ebx),%eax
  805922:	85 c0                	test   %eax,%eax
  805924:	74 0e                	je     805934 <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  805926:	83 ec 0c             	sub    $0xc,%esp
  805929:	50                   	push   %eax
  80592a:	e8 c5 f0 ff ff       	call   8049f4 <pbuf_free>
  80592f:	89 c6                	mov    %eax,%esi
  805931:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805934:	83 ec 08             	sub    $0x8,%esp
  805937:	53                   	push   %ebx
  805938:	6a 04                	push   $0x4
  80593a:	e8 68 ed ff ff       	call   8046a7 <memp_free>
  80593f:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  805942:	89 f0                	mov    %esi,%eax
  805944:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805947:	5b                   	pop    %ebx
  805948:	5e                   	pop    %esi
  805949:	5d                   	pop    %ebp
  80594a:	c3                   	ret    

0080594b <tcp_segs_free>:
{
  80594b:	55                   	push   %ebp
  80594c:	89 e5                	mov    %esp,%ebp
  80594e:	56                   	push   %esi
  80594f:	53                   	push   %ebx
  805950:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  805953:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  805958:	85 c0                	test   %eax,%eax
  80595a:	74 14                	je     805970 <tcp_segs_free+0x25>
    next = seg->next;
  80595c:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  80595e:	83 ec 0c             	sub    $0xc,%esp
  805961:	50                   	push   %eax
  805962:	e8 a7 ff ff ff       	call   80590e <tcp_seg_free>
  805967:	01 c3                	add    %eax,%ebx
    seg = next;
  805969:	83 c4 10             	add    $0x10,%esp
  80596c:	89 f0                	mov    %esi,%eax
  80596e:	eb e8                	jmp    805958 <tcp_segs_free+0xd>
}
  805970:	89 d8                	mov    %ebx,%eax
  805972:	8d 65 f8             	lea    -0x8(%ebp),%esp
  805975:	5b                   	pop    %ebx
  805976:	5e                   	pop    %esi
  805977:	5d                   	pop    %ebp
  805978:	c3                   	ret    

00805979 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805979:	55                   	push   %ebp
  80597a:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80597c:	8b 45 08             	mov    0x8(%ebp),%eax
  80597f:	8b 55 0c             	mov    0xc(%ebp),%edx
  805982:	88 50 14             	mov    %dl,0x14(%eax)
}
  805985:	5d                   	pop    %ebp
  805986:	c3                   	ret    

00805987 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805987:	55                   	push   %ebp
  805988:	89 e5                	mov    %esp,%ebp
  80598a:	53                   	push   %ebx
  80598b:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  80598e:	6a 04                	push   $0x4
  805990:	e8 bc ec ff ff       	call   804651 <memp_malloc>
  805995:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805997:	83 c4 10             	add    $0x10,%esp
  80599a:	85 c0                	test   %eax,%eax
  80599c:	74 1c                	je     8059ba <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80599e:	83 ec 04             	sub    $0x4,%esp
  8059a1:	6a 14                	push   $0x14
  8059a3:	ff 75 08             	pushl  0x8(%ebp)
  8059a6:	50                   	push   %eax
  8059a7:	e8 a2 98 00 00       	call   80f24e <memcpy>
  pbuf_ref(cseg->p);
  8059ac:	83 c4 04             	add    $0x4,%esp
  8059af:	ff 73 04             	pushl  0x4(%ebx)
  8059b2:	e8 9f f4 ff ff       	call   804e56 <pbuf_ref>
  return cseg;
  8059b7:	83 c4 10             	add    $0x10,%esp
}
  8059ba:	89 d8                	mov    %ebx,%eax
  8059bc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8059bf:	c9                   	leave  
  8059c0:	c3                   	ret    

008059c1 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8059c1:	55                   	push   %ebp
  8059c2:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8059c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8059c7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059ca:	89 50 18             	mov    %edx,0x18(%eax)
}
  8059cd:	5d                   	pop    %ebp
  8059ce:	c3                   	ret    

008059cf <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8059cf:	55                   	push   %ebp
  8059d0:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8059d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8059d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059d8:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8059de:	5d                   	pop    %ebp
  8059df:	c3                   	ret    

008059e0 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8059e0:	55                   	push   %ebp
  8059e1:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  8059e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8059e6:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059e9:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  8059ef:	5d                   	pop    %ebp
  8059f0:	c3                   	ret    

008059f1 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8059f1:	55                   	push   %ebp
  8059f2:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  8059f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8059f7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8059fa:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805a00:	5d                   	pop    %ebp
  805a01:	c3                   	ret    

00805a02 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805a02:	55                   	push   %ebp
  805a03:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805a05:	8b 45 08             	mov    0x8(%ebp),%eax
  805a08:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a0b:	89 50 20             	mov    %edx,0x20(%eax)
}
  805a0e:	5d                   	pop    %ebp
  805a0f:	c3                   	ret    

00805a10 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805a10:	55                   	push   %ebp
  805a11:	89 e5                	mov    %esp,%ebp
  805a13:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805a16:	8b 55 0c             	mov    0xc(%ebp),%edx
  805a19:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805a1f:	8b 55 10             	mov    0x10(%ebp),%edx
  805a22:	88 50 31             	mov    %dl,0x31(%eax)
}
  805a25:	5d                   	pop    %ebp
  805a26:	c3                   	ret    

00805a27 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805a27:	55                   	push   %ebp
  805a28:	89 e5                	mov    %esp,%ebp
  805a2a:	53                   	push   %ebx
  805a2b:	83 ec 04             	sub    $0x4,%esp
  805a2e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805a31:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  805a34:	83 f8 0a             	cmp    $0xa,%eax
  805a37:	74 05                	je     805a3e <tcp_pcb_purge+0x17>
  805a39:	83 f8 01             	cmp    $0x1,%eax
  805a3c:	77 05                	ja     805a43 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  805a3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805a41:	c9                   	leave  
  805a42:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  805a43:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805a49:	85 c0                	test   %eax,%eax
  805a4b:	74 16                	je     805a63 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  805a4d:	83 ec 0c             	sub    $0xc,%esp
  805a50:	50                   	push   %eax
  805a51:	e8 9e ef ff ff       	call   8049f4 <pbuf_free>
      pcb->refused_data = NULL;
  805a56:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805a5d:	00 00 00 
  805a60:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  805a63:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  805a69:	83 ec 0c             	sub    $0xc,%esp
  805a6c:	ff 73 7c             	pushl  0x7c(%ebx)
  805a6f:	e8 d7 fe ff ff       	call   80594b <tcp_segs_free>
    pcb->ooseq = NULL;
  805a74:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805a7b:	83 c4 04             	add    $0x4,%esp
  805a7e:	ff 73 74             	pushl  0x74(%ebx)
  805a81:	e8 c5 fe ff ff       	call   80594b <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805a86:	83 c4 04             	add    $0x4,%esp
  805a89:	ff 73 78             	pushl  0x78(%ebx)
  805a8c:	e8 ba fe ff ff       	call   80594b <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805a91:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805a98:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805a9f:	83 c4 10             	add    $0x10,%esp
}
  805aa2:	eb 9a                	jmp    805a3e <tcp_pcb_purge+0x17>

00805aa4 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805aa4:	55                   	push   %ebp
  805aa5:	89 e5                	mov    %esp,%ebp
  805aa7:	57                   	push   %edi
  805aa8:	56                   	push   %esi
  805aa9:	53                   	push   %ebx
  805aaa:	83 ec 0c             	sub    $0xc,%esp
  805aad:	8b 45 08             	mov    0x8(%ebp),%eax
  805ab0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805ab3:	8b 10                	mov    (%eax),%edx
  805ab5:	39 da                	cmp    %ebx,%edx
  805ab7:	74 2f                	je     805ae8 <tcp_pcb_remove+0x44>
  805ab9:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  805abf:	bf 00 00 00 00       	mov    $0x0,%edi
  805ac4:	89 de                	mov    %ebx,%esi
  805ac6:	85 d2                	test   %edx,%edx
  805ac8:	0f 84 82 00 00 00    	je     805b50 <tcp_pcb_remove+0xac>
  805ace:	8b 42 0c             	mov    0xc(%edx),%eax
  805ad1:	39 f0                	cmp    %esi,%eax
  805ad3:	0f 94 c3             	sete   %bl
  805ad6:	85 c0                	test   %eax,%eax
  805ad8:	0f 95 c1             	setne  %cl
  805adb:	84 cb                	test   %cl,%bl
  805add:	75 5b                	jne    805b3a <tcp_pcb_remove+0x96>
  805adf:	bf 01 00 00 00       	mov    $0x1,%edi
  805ae4:	89 c2                	mov    %eax,%edx
  805ae6:	eb de                	jmp    805ac6 <tcp_pcb_remove+0x22>
  805ae8:	8b 53 0c             	mov    0xc(%ebx),%edx
  805aeb:	89 10                	mov    %edx,(%eax)
  805aed:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805af4:	83 ec 0c             	sub    $0xc,%esp
  805af7:	53                   	push   %ebx
  805af8:	e8 2a ff ff ff       	call   805a27 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805afd:	8b 43 10             	mov    0x10(%ebx),%eax
  805b00:	83 c4 10             	add    $0x10,%esp
  805b03:	83 f8 0a             	cmp    $0xa,%eax
  805b06:	74 6e                	je     805b76 <tcp_pcb_remove+0xd2>
  805b08:	83 f8 01             	cmp    $0x1,%eax
  805b0b:	74 69                	je     805b76 <tcp_pcb_remove+0xd2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805b0d:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  805b11:	a8 01                	test   $0x1,%al
  805b13:	75 4f                	jne    805b64 <tcp_pcb_remove+0xc0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805b15:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  805b19:	75 63                	jne    805b7e <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805b1b:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805b1f:	75 74                	jne    805b95 <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805b21:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  805b25:	0f 85 81 00 00 00    	jne    805bac <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  805b2b:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  805b32:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805b35:	5b                   	pop    %ebx
  805b36:	5e                   	pop    %esi
  805b37:	5f                   	pop    %edi
  805b38:	5d                   	pop    %ebp
  805b39:	c3                   	ret    
  805b3a:	89 f3                	mov    %esi,%ebx
  805b3c:	89 f8                	mov    %edi,%eax
  805b3e:	84 c0                	test   %al,%al
  805b40:	74 06                	je     805b48 <tcp_pcb_remove+0xa4>
  805b42:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(pcblist, pcb);
  805b48:	8b 43 0c             	mov    0xc(%ebx),%eax
  805b4b:	89 42 0c             	mov    %eax,0xc(%edx)
  805b4e:	eb 9d                	jmp    805aed <tcp_pcb_remove+0x49>
  805b50:	89 f3                	mov    %esi,%ebx
  805b52:	89 f8                	mov    %edi,%eax
  805b54:	84 c0                	test   %al,%al
  805b56:	74 95                	je     805aed <tcp_pcb_remove+0x49>
  805b58:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805b5f:	00 00 00 
  805b62:	eb 89                	jmp    805aed <tcp_pcb_remove+0x49>
    pcb->flags |= TF_ACK_NOW;
  805b64:	83 c8 02             	or     $0x2,%eax
  805b67:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805b6a:	83 ec 0c             	sub    $0xc,%esp
  805b6d:	53                   	push   %ebx
  805b6e:	e8 bc 26 00 00       	call   80822f <tcp_output>
  805b73:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805b76:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805b7a:	74 af                	je     805b2b <tcp_pcb_remove+0x87>
  805b7c:	eb 97                	jmp    805b15 <tcp_pcb_remove+0x71>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805b7e:	83 ec 04             	sub    $0x4,%esp
  805b81:	68 02 25 81 00       	push   $0x812502
  805b86:	68 b4 04 00 00       	push   $0x4b4
  805b8b:	68 ee 24 81 00       	push   $0x8124ee
  805b90:	e8 74 8c 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805b95:	83 ec 04             	sub    $0x4,%esp
  805b98:	68 1a 25 81 00       	push   $0x81251a
  805b9d:	68 b5 04 00 00       	push   $0x4b5
  805ba2:	68 ee 24 81 00       	push   $0x8124ee
  805ba7:	e8 5d 8c 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805bac:	83 ec 04             	sub    $0x4,%esp
  805baf:	68 33 25 81 00       	push   $0x812533
  805bb4:	68 b7 04 00 00       	push   $0x4b7
  805bb9:	68 ee 24 81 00       	push   $0x8124ee
  805bbe:	e8 46 8c 00 00       	call   80e809 <_panic>

00805bc3 <tcp_close>:
{
  805bc3:	55                   	push   %ebp
  805bc4:	89 e5                	mov    %esp,%ebp
  805bc6:	57                   	push   %edi
  805bc7:	56                   	push   %esi
  805bc8:	53                   	push   %ebx
  805bc9:	83 ec 0c             	sub    $0xc,%esp
  805bcc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  805bcf:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805bd3:	0f 87 3e 01 00 00    	ja     805d17 <tcp_close+0x154>
  805bd9:	8b 43 10             	mov    0x10(%ebx),%eax
  805bdc:	ff 24 85 4c 25 81 00 	jmp    *0x81254c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805be3:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  805be9:	39 da                	cmp    %ebx,%edx
  805beb:	74 2b                	je     805c18 <tcp_close+0x55>
  805bed:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  805bf3:	bf 00 00 00 00       	mov    $0x0,%edi
  805bf8:	89 de                	mov    %ebx,%esi
  805bfa:	85 d2                	test   %edx,%edx
  805bfc:	74 57                	je     805c55 <tcp_close+0x92>
  805bfe:	8b 42 0c             	mov    0xc(%edx),%eax
  805c01:	39 f0                	cmp    %esi,%eax
  805c03:	0f 94 c3             	sete   %bl
  805c06:	85 c0                	test   %eax,%eax
  805c08:	0f 95 c1             	setne  %cl
  805c0b:	84 cb                	test   %cl,%bl
  805c0d:	75 30                	jne    805c3f <tcp_close+0x7c>
  805c0f:	bf 01 00 00 00       	mov    $0x1,%edi
  805c14:	89 c2                	mov    %eax,%edx
  805c16:	eb e2                	jmp    805bfa <tcp_close+0x37>
  805c18:	8b 43 0c             	mov    0xc(%ebx),%eax
  805c1b:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  805c20:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805c27:	83 ec 08             	sub    $0x8,%esp
  805c2a:	53                   	push   %ebx
  805c2b:	6a 02                	push   $0x2
  805c2d:	e8 75 ea ff ff       	call   8046a7 <memp_free>
    break;
  805c32:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805c35:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805c3a:	e9 9a 00 00 00       	jmp    805cd9 <tcp_close+0x116>
  805c3f:	89 f3                	mov    %esi,%ebx
  805c41:	89 f8                	mov    %edi,%eax
  805c43:	84 c0                	test   %al,%al
  805c45:	74 06                	je     805c4d <tcp_close+0x8a>
  805c47:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805c4d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805c50:	89 42 0c             	mov    %eax,0xc(%edx)
  805c53:	eb cb                	jmp    805c20 <tcp_close+0x5d>
  805c55:	89 f3                	mov    %esi,%ebx
  805c57:	89 f8                	mov    %edi,%eax
  805c59:	84 c0                	test   %al,%al
  805c5b:	74 c3                	je     805c20 <tcp_close+0x5d>
  805c5d:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  805c64:	00 00 00 
  805c67:	eb b7                	jmp    805c20 <tcp_close+0x5d>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805c69:	83 ec 08             	sub    $0x8,%esp
  805c6c:	53                   	push   %ebx
  805c6d:	68 44 c2 b3 00       	push   $0xb3c244
  805c72:	e8 2d fe ff ff       	call   805aa4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805c77:	83 c4 08             	add    $0x8,%esp
  805c7a:	53                   	push   %ebx
  805c7b:	6a 03                	push   $0x3
  805c7d:	e8 25 ea ff ff       	call   8046a7 <memp_free>
    break;
  805c82:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805c85:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805c8a:	eb 4d                	jmp    805cd9 <tcp_close+0x116>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c8c:	83 ec 08             	sub    $0x8,%esp
  805c8f:	53                   	push   %ebx
  805c90:	68 3c c2 b3 00       	push   $0xb3c23c
  805c95:	e8 0a fe ff ff       	call   805aa4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805c9a:	83 c4 08             	add    $0x8,%esp
  805c9d:	53                   	push   %ebx
  805c9e:	6a 02                	push   $0x2
  805ca0:	e8 02 ea ff ff       	call   8046a7 <memp_free>
    break;
  805ca5:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805ca8:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805cad:	eb 2a                	jmp    805cd9 <tcp_close+0x116>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805caf:	83 ec 08             	sub    $0x8,%esp
  805cb2:	6a 01                	push   $0x1
  805cb4:	53                   	push   %ebx
  805cb5:	e8 ff 24 00 00       	call   8081b9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805cba:	83 c4 10             	add    $0x10,%esp
  805cbd:	84 c0                	test   %al,%al
  805cbf:	75 18                	jne    805cd9 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805cc1:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805cc8:	83 ec 0c             	sub    $0xc,%esp
  805ccb:	53                   	push   %ebx
  805ccc:	e8 5e 25 00 00       	call   80822f <tcp_output>
  805cd1:	83 c4 10             	add    $0x10,%esp
  805cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805cd9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805cdc:	5b                   	pop    %ebx
  805cdd:	5e                   	pop    %esi
  805cde:	5f                   	pop    %edi
  805cdf:	5d                   	pop    %ebp
  805ce0:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805ce1:	83 ec 08             	sub    $0x8,%esp
  805ce4:	6a 01                	push   $0x1
  805ce6:	53                   	push   %ebx
  805ce7:	e8 cd 24 00 00       	call   8081b9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805cec:	83 c4 10             	add    $0x10,%esp
  805cef:	84 c0                	test   %al,%al
  805cf1:	75 e6                	jne    805cd9 <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805cf3:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805cfa:	eb cc                	jmp    805cc8 <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805cfc:	83 ec 08             	sub    $0x8,%esp
  805cff:	6a 01                	push   $0x1
  805d01:	53                   	push   %ebx
  805d02:	e8 b2 24 00 00       	call   8081b9 <tcp_send_ctrl>
    if (err == ERR_OK) {
  805d07:	83 c4 10             	add    $0x10,%esp
  805d0a:	84 c0                	test   %al,%al
  805d0c:	75 cb                	jne    805cd9 <tcp_close+0x116>
      pcb->state = LAST_ACK;
  805d0e:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805d15:	eb b1                	jmp    805cc8 <tcp_close+0x105>
    err = ERR_OK;
  805d17:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805d1c:	eb bb                	jmp    805cd9 <tcp_close+0x116>

00805d1e <tcp_recv_null>:
{
  805d1e:	55                   	push   %ebp
  805d1f:	89 e5                	mov    %esp,%ebp
  805d21:	83 ec 08             	sub    $0x8,%esp
  805d24:	8b 45 10             	mov    0x10(%ebp),%eax
  805d27:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805d2a:	85 c0                	test   %eax,%eax
  805d2c:	74 13                	je     805d41 <tcp_recv_null+0x23>
    pbuf_free(p);
  805d2e:	83 ec 0c             	sub    $0xc,%esp
  805d31:	50                   	push   %eax
  805d32:	e8 bd ec ff ff       	call   8049f4 <pbuf_free>
  805d37:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805d3a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805d3f:	c9                   	leave  
  805d40:	c3                   	ret    
  return ERR_OK;
  805d41:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805d46:	84 d2                	test   %dl,%dl
  805d48:	75 f5                	jne    805d3f <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805d4a:	83 ec 0c             	sub    $0xc,%esp
  805d4d:	ff 75 0c             	pushl  0xc(%ebp)
  805d50:	e8 6e fe ff ff       	call   805bc3 <tcp_close>
  805d55:	83 c4 10             	add    $0x10,%esp
  805d58:	eb e5                	jmp    805d3f <tcp_recv_null+0x21>

00805d5a <tcp_abort>:
{
  805d5a:	55                   	push   %ebp
  805d5b:	89 e5                	mov    %esp,%ebp
  805d5d:	57                   	push   %edi
  805d5e:	56                   	push   %esi
  805d5f:	53                   	push   %ebx
  805d60:	83 ec 2c             	sub    $0x2c,%esp
  805d63:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805d66:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805d6a:	0f 84 c2 00 00 00    	je     805e32 <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805d70:	8b 43 54             	mov    0x54(%ebx),%eax
  805d73:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805d76:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805d79:	8b 03                	mov    (%ebx),%eax
  805d7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805d7e:	8b 43 04             	mov    0x4(%ebx),%eax
  805d81:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805d84:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805d88:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805d8c:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805d90:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805d94:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805d9a:	8b 43 18             	mov    0x18(%ebx),%eax
  805d9d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805da0:	83 ec 08             	sub    $0x8,%esp
  805da3:	53                   	push   %ebx
  805da4:	68 3c c2 b3 00       	push   $0xb3c23c
  805da9:	e8 f6 fc ff ff       	call   805aa4 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805dae:	8b 43 78             	mov    0x78(%ebx),%eax
  805db1:	83 c4 10             	add    $0x10,%esp
  805db4:	85 c0                	test   %eax,%eax
  805db6:	74 0c                	je     805dc4 <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805db8:	83 ec 0c             	sub    $0xc,%esp
  805dbb:	50                   	push   %eax
  805dbc:	e8 8a fb ff ff       	call   80594b <tcp_segs_free>
  805dc1:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805dc4:	8b 43 74             	mov    0x74(%ebx),%eax
  805dc7:	85 c0                	test   %eax,%eax
  805dc9:	74 0c                	je     805dd7 <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805dcb:	83 ec 0c             	sub    $0xc,%esp
  805dce:	50                   	push   %eax
  805dcf:	e8 77 fb ff ff       	call   80594b <tcp_segs_free>
  805dd4:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805dd7:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805dda:	85 c0                	test   %eax,%eax
  805ddc:	74 0c                	je     805dea <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805dde:	83 ec 0c             	sub    $0xc,%esp
  805de1:	50                   	push   %eax
  805de2:	e8 64 fb ff ff       	call   80594b <tcp_segs_free>
  805de7:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805dea:	83 ec 08             	sub    $0x8,%esp
  805ded:	53                   	push   %ebx
  805dee:	6a 02                	push   $0x2
  805df0:	e8 b2 e8 ff ff       	call   8046a7 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805df5:	83 c4 10             	add    $0x10,%esp
  805df8:	85 f6                	test   %esi,%esi
  805dfa:	74 0d                	je     805e09 <tcp_abort+0xaf>
  805dfc:	83 ec 08             	sub    $0x8,%esp
  805dff:	6a fb                	push   $0xfffffffb
  805e01:	ff 75 cc             	pushl  -0x34(%ebp)
  805e04:	ff d6                	call   *%esi
  805e06:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805e09:	83 ec 08             	sub    $0x8,%esp
  805e0c:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805e10:	50                   	push   %eax
  805e11:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805e15:	50                   	push   %eax
  805e16:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805e19:	50                   	push   %eax
  805e1a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805e1d:	50                   	push   %eax
  805e1e:	57                   	push   %edi
  805e1f:	ff 75 d4             	pushl  -0x2c(%ebp)
  805e22:	e8 a8 28 00 00       	call   8086cf <tcp_rst>
  805e27:	83 c4 20             	add    $0x20,%esp
}
  805e2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805e2d:	5b                   	pop    %ebx
  805e2e:	5e                   	pop    %esi
  805e2f:	5f                   	pop    %edi
  805e30:	5d                   	pop    %ebp
  805e31:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805e32:	83 ec 08             	sub    $0x8,%esp
  805e35:	53                   	push   %ebx
  805e36:	68 50 c2 b3 00       	push   $0xb3c250
  805e3b:	e8 64 fc ff ff       	call   805aa4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805e40:	83 c4 08             	add    $0x8,%esp
  805e43:	53                   	push   %ebx
  805e44:	6a 02                	push   $0x2
  805e46:	e8 5c e8 ff ff       	call   8046a7 <memp_free>
  805e4b:	83 c4 10             	add    $0x10,%esp
  805e4e:	eb da                	jmp    805e2a <tcp_abort+0xd0>

00805e50 <tcp_slowtmr>:
{
  805e50:	55                   	push   %ebp
  805e51:	89 e5                	mov    %esp,%ebp
  805e53:	57                   	push   %edi
  805e54:	56                   	push   %esi
  805e55:	53                   	push   %ebx
  805e56:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805e59:	83 05 40 c2 b3 00 01 	addl   $0x1,0xb3c240
  pcb = tcp_active_pcbs;
  805e60:	8b 1d 3c c2 b3 00    	mov    0xb3c23c,%ebx
  err = ERR_OK;
  805e66:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805e6a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805e71:	e9 2a 02 00 00       	jmp    8060a0 <tcp_slowtmr+0x250>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805e76:	83 ec 04             	sub    $0x4,%esp
  805e79:	68 5c 23 81 00       	push   $0x81235c
  805e7e:	68 36 02 00 00       	push   $0x236
  805e83:	68 ee 24 81 00       	push   $0x8124ee
  805e88:	e8 7c 89 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805e8d:	83 ec 04             	sub    $0x4,%esp
  805e90:	68 88 23 81 00       	push   $0x812388
  805e95:	68 37 02 00 00       	push   $0x237
  805e9a:	68 ee 24 81 00       	push   $0x8124ee
  805e9f:	e8 65 89 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805ea4:	83 ec 04             	sub    $0x4,%esp
  805ea7:	68 b4 23 81 00       	push   $0x8123b4
  805eac:	68 38 02 00 00       	push   $0x238
  805eb1:	68 ee 24 81 00       	push   $0x8124ee
  805eb6:	e8 4e 89 00 00       	call   80e809 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805ebb:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805ebf:	80 fa 06             	cmp    $0x6,%dl
  805ec2:	0f 84 d0 00 00 00    	je     805f98 <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805ec8:	80 fa 0c             	cmp    $0xc,%dl
  805ecb:	0f 85 0b 02 00 00    	jne    8060dc <tcp_slowtmr+0x28c>
  805ed1:	be 01 00 00 00       	mov    $0x1,%esi
  805ed6:	e9 c2 00 00 00       	jmp    805f9d <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805edb:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805edf:	66 85 c9             	test   %cx,%cx
  805ee2:	78 07                	js     805eeb <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805ee4:	83 c1 01             	add    $0x1,%ecx
  805ee7:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805eeb:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805eef:	0f 84 45 02 00 00    	je     80613a <tcp_slowtmr+0x2ea>
  805ef5:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805ef9:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805efd:	0f 8c 37 02 00 00    	jl     80613a <tcp_slowtmr+0x2ea>
          if (pcb->state != SYN_SENT) {
  805f03:	83 f8 02             	cmp    $0x2,%eax
  805f06:	74 1f                	je     805f27 <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805f08:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805f0c:	66 c1 f8 03          	sar    $0x3,%ax
  805f10:	98                   	cwtl   
  805f11:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805f15:	01 c8                	add    %ecx,%eax
  805f17:	0f b6 d2             	movzbl %dl,%edx
  805f1a:	0f b6 8a 74 25 81 00 	movzbl 0x812574(%edx),%ecx
  805f21:	d3 e0                	shl    %cl,%eax
  805f23:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805f27:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805f2d:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805f31:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805f35:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805f3a:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805f3d:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805f41:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805f44:	66 39 d0             	cmp    %dx,%ax
  805f47:	0f 42 c1             	cmovb  %ecx,%eax
  805f4a:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805f4e:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805f52:	83 ec 0c             	sub    $0xc,%esp
  805f55:	53                   	push   %ebx
  805f56:	e8 9d 28 00 00       	call   8087f8 <tcp_rexmit_rto>
  805f5b:	83 c4 10             	add    $0x10,%esp
  805f5e:	e9 d7 01 00 00       	jmp    80613a <tcp_slowtmr+0x2ea>
    pcb_remove = 0;
  805f63:	be 00 00 00 00       	mov    $0x0,%esi
  805f68:	e9 cd 01 00 00       	jmp    80613a <tcp_slowtmr+0x2ea>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805f6d:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  805f72:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805f75:	83 f8 29             	cmp    $0x29,%eax
  805f78:	89 f0                	mov    %esi,%eax
  805f7a:	1c ff                	sbb    $0xff,%al
  805f7c:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805f7e:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805f81:	85 c9                	test   %ecx,%ecx
  805f83:	75 1f                	jne    805fa4 <tcp_slowtmr+0x154>
  805f85:	e9 d0 00 00 00       	jmp    80605a <tcp_slowtmr+0x20a>
        tcp_abort(pcb);
  805f8a:	83 ec 0c             	sub    $0xc,%esp
  805f8d:	53                   	push   %ebx
  805f8e:	e8 c7 fd ff ff       	call   805d5a <tcp_abort>
  805f93:	83 c4 10             	add    $0x10,%esp
  805f96:	eb 05                	jmp    805f9d <tcp_slowtmr+0x14d>
  805f98:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805f9d:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805fa0:	85 c9                	test   %ecx,%ecx
  805fa2:	74 16                	je     805fba <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805fa4:	8b 15 40 c2 b3 00    	mov    0xb3c240,%edx
  805faa:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805fad:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805fb1:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805fb4:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805fb6:	39 c2                	cmp    %eax,%edx
  805fb8:	73 7b                	jae    806035 <tcp_slowtmr+0x1e5>
    if (pcb->state == SYN_RCVD) {
  805fba:	8b 43 10             	mov    0x10(%ebx),%eax
  805fbd:	83 f8 03             	cmp    $0x3,%eax
  805fc0:	0f 84 87 00 00 00    	je     80604d <tcp_slowtmr+0x1fd>
    if (pcb->state == LAST_ACK) {
  805fc6:	83 f8 09             	cmp    $0x9,%eax
  805fc9:	0f 85 8b 00 00 00    	jne    80605a <tcp_slowtmr+0x20a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805fcf:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  805fd4:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805fd7:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805fdc:	76 7c                	jbe    80605a <tcp_slowtmr+0x20a>
      tcp_pcb_purge(pcb);      
  805fde:	83 ec 0c             	sub    $0xc,%esp
  805fe1:	53                   	push   %ebx
  805fe2:	e8 40 fa ff ff       	call   805a27 <tcp_pcb_purge>
      if (prev != NULL) {
  805fe7:	83 c4 10             	add    $0x10,%esp
  805fea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805fee:	0f 84 e1 01 00 00    	je     8061d5 <tcp_slowtmr+0x385>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805ff4:	3b 1d 3c c2 b3 00    	cmp    0xb3c23c,%ebx
  805ffa:	0f 84 be 01 00 00    	je     8061be <tcp_slowtmr+0x36e>
        prev->next = pcb->next;
  806000:	8b 43 0c             	mov    0xc(%ebx),%eax
  806003:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806006:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  806009:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80600f:	85 c0                	test   %eax,%eax
  806011:	74 0d                	je     806020 <tcp_slowtmr+0x1d0>
  806013:	83 ec 08             	sub    $0x8,%esp
  806016:	6a fb                	push   $0xfffffffb
  806018:	ff 73 18             	pushl  0x18(%ebx)
  80601b:	ff d0                	call   *%eax
  80601d:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  806020:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806023:	83 ec 08             	sub    $0x8,%esp
  806026:	53                   	push   %ebx
  806027:	6a 02                	push   $0x2
  806029:	e8 79 e6 ff ff       	call   8046a7 <memp_free>
  80602e:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806031:	89 f3                	mov    %esi,%ebx
  806033:	eb 6b                	jmp    8060a0 <tcp_slowtmr+0x250>
      tcp_segs_free(pcb->ooseq);
  806035:	83 ec 0c             	sub    $0xc,%esp
  806038:	51                   	push   %ecx
  806039:	e8 0d f9 ff ff       	call   80594b <tcp_segs_free>
      pcb->ooseq = NULL;
  80603e:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  806045:	83 c4 10             	add    $0x10,%esp
  806048:	e9 6d ff ff ff       	jmp    805fba <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80604d:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  806052:	2b 43 2c             	sub    0x2c(%ebx),%eax
  806055:	83 f8 28             	cmp    $0x28,%eax
  806058:	77 84                	ja     805fde <tcp_slowtmr+0x18e>
    if (pcb_remove) {
  80605a:	89 f0                	mov    %esi,%eax
  80605c:	84 c0                	test   %al,%al
  80605e:	0f 85 7a ff ff ff    	jne    805fde <tcp_slowtmr+0x18e>
      ++pcb->polltmr;
  806064:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806068:	83 c0 01             	add    $0x1,%eax
  80606b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80606e:	3a 43 31             	cmp    0x31(%ebx),%al
  806071:	72 27                	jb     80609a <tcp_slowtmr+0x24a>
        pcb->polltmr = 0;
  806073:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  806077:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80607d:	85 c0                	test   %eax,%eax
  80607f:	74 0f                	je     806090 <tcp_slowtmr+0x240>
  806081:	83 ec 08             	sub    $0x8,%esp
  806084:	53                   	push   %ebx
  806085:	ff 73 18             	pushl  0x18(%ebx)
  806088:	ff d0                	call   *%eax
  80608a:	88 45 e3             	mov    %al,-0x1d(%ebp)
  80608d:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  806090:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  806094:	0f 84 67 01 00 00    	je     806201 <tcp_slowtmr+0x3b1>
      prev = pcb;
  80609a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  80609d:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  8060a0:	85 db                	test   %ebx,%ebx
  8060a2:	0f 84 6a 01 00 00    	je     806212 <tcp_slowtmr+0x3c2>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  8060a8:	8b 43 10             	mov    0x10(%ebx),%eax
  8060ab:	85 c0                	test   %eax,%eax
  8060ad:	0f 84 c3 fd ff ff    	je     805e76 <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  8060b3:	83 f8 01             	cmp    $0x1,%eax
  8060b6:	0f 84 d1 fd ff ff    	je     805e8d <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8060bc:	83 f8 0a             	cmp    $0xa,%eax
  8060bf:	0f 84 df fd ff ff    	je     805ea4 <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8060c5:	83 f8 02             	cmp    $0x2,%eax
  8060c8:	0f 84 ed fd ff ff    	je     805ebb <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  8060ce:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  8060d2:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  8060d7:	80 fa 0c             	cmp    $0xc,%dl
  8060da:	74 5e                	je     80613a <tcp_slowtmr+0x2ea>
      if (pcb->persist_backoff > 0) {
  8060dc:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  8060e3:	89 f1                	mov    %esi,%ecx
  8060e5:	84 c9                	test   %cl,%cl
  8060e7:	0f 84 ee fd ff ff    	je     805edb <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  8060ed:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8060f3:	83 c0 01             	add    $0x1,%eax
  8060f6:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8060fc:	0f b6 d1             	movzbl %cl,%edx
  8060ff:	bf 6c 25 81 00       	mov    $0x81256c,%edi
  806104:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  806109:	39 d0                	cmp    %edx,%eax
  80610b:	0f 82 52 fe ff ff    	jb     805f63 <tcp_slowtmr+0x113>
          pcb->persist_cnt = 0;
  806111:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806118:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80611b:	80 f9 06             	cmp    $0x6,%cl
  80611e:	77 09                	ja     806129 <tcp_slowtmr+0x2d9>
            pcb->persist_backoff++;
  806120:	8d 46 01             	lea    0x1(%esi),%eax
  806123:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  806129:	83 ec 0c             	sub    $0xc,%esp
  80612c:	53                   	push   %ebx
  80612d:	e8 92 28 00 00       	call   8089c4 <tcp_zero_window_probe>
  806132:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  806135:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  80613a:	8b 43 10             	mov    0x10(%ebx),%eax
  80613d:	83 f8 06             	cmp    $0x6,%eax
  806140:	0f 84 27 fe ff ff    	je     805f6d <tcp_slowtmr+0x11d>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  806146:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80614a:	0f 84 4d fe ff ff    	je     805f9d <tcp_slowtmr+0x14d>
  806150:	83 f8 04             	cmp    $0x4,%eax
  806153:	74 09                	je     80615e <tcp_slowtmr+0x30e>
  806155:	83 f8 07             	cmp    $0x7,%eax
  806158:	0f 85 3f fe ff ff    	jne    805f9d <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80615e:	8b 0d 40 c2 b3 00    	mov    0xb3c240,%ecx
  806164:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  806167:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  80616d:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  806173:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806178:	f7 e2                	mul    %edx
  80617a:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80617d:	39 d1                	cmp    %edx,%ecx
  80617f:	0f 87 05 fe ff ff    	ja     805f8a <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806185:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80618c:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  806192:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  806194:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806199:	f7 e2                	mul    %edx
  80619b:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80619e:	39 d1                	cmp    %edx,%ecx
  8061a0:	0f 86 f7 fd ff ff    	jbe    805f9d <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  8061a6:	83 ec 0c             	sub    $0xc,%esp
  8061a9:	53                   	push   %ebx
  8061aa:	e8 ef 26 00 00       	call   80889e <tcp_keepalive>
        pcb->keep_cnt_sent++;
  8061af:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  8061b6:	83 c4 10             	add    $0x10,%esp
  8061b9:	e9 df fd ff ff       	jmp    805f9d <tcp_slowtmr+0x14d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8061be:	83 ec 04             	sub    $0x4,%esp
  8061c1:	68 e4 23 81 00       	push   $0x8123e4
  8061c6:	68 c1 02 00 00       	push   $0x2c1
  8061cb:	68 ee 24 81 00       	push   $0x8124ee
  8061d0:	e8 34 86 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8061d5:	3b 1d 3c c2 b3 00    	cmp    0xb3c23c,%ebx
  8061db:	75 0d                	jne    8061ea <tcp_slowtmr+0x39a>
        tcp_active_pcbs = pcb->next;
  8061dd:	8b 43 0c             	mov    0xc(%ebx),%eax
  8061e0:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
  8061e5:	e9 1f fe ff ff       	jmp    806009 <tcp_slowtmr+0x1b9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8061ea:	83 ec 04             	sub    $0x4,%esp
  8061ed:	68 10 24 81 00       	push   $0x812410
  8061f2:	68 c5 02 00 00       	push   $0x2c5
  8061f7:	68 ee 24 81 00       	push   $0x8124ee
  8061fc:	e8 08 86 00 00       	call   80e809 <_panic>
          tcp_output(pcb);
  806201:	83 ec 0c             	sub    $0xc,%esp
  806204:	53                   	push   %ebx
  806205:	e8 25 20 00 00       	call   80822f <tcp_output>
  80620a:	83 c4 10             	add    $0x10,%esp
  80620d:	e9 88 fe ff ff       	jmp    80609a <tcp_slowtmr+0x24a>
  pcb = tcp_tw_pcbs;
  806212:	8b 35 50 c2 b3 00    	mov    0xb3c250,%esi
  while (pcb != NULL) {
  806218:	eb 48                	jmp    806262 <tcp_slowtmr+0x412>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80621a:	83 ec 04             	sub    $0x4,%esp
  80621d:	68 3c 24 81 00       	push   $0x81243c
  806222:	68 e5 02 00 00       	push   $0x2e5
  806227:	68 ee 24 81 00       	push   $0x8124ee
  80622c:	e8 d8 85 00 00       	call   80e809 <_panic>
      tcp_pcb_purge(pcb);      
  806231:	83 ec 0c             	sub    $0xc,%esp
  806234:	56                   	push   %esi
  806235:	e8 ed f7 ff ff       	call   805a27 <tcp_pcb_purge>
      if (prev != NULL) {
  80623a:	83 c4 10             	add    $0x10,%esp
  80623d:	85 db                	test   %ebx,%ebx
  80623f:	74 58                	je     806299 <tcp_slowtmr+0x449>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806241:	3b 35 50 c2 b3 00    	cmp    0xb3c250,%esi
  806247:	74 39                	je     806282 <tcp_slowtmr+0x432>
        prev->next = pcb->next;
  806249:	8b 46 0c             	mov    0xc(%esi),%eax
  80624c:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  80624f:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806252:	83 ec 08             	sub    $0x8,%esp
  806255:	56                   	push   %esi
  806256:	6a 02                	push   $0x2
  806258:	e8 4a e4 ff ff       	call   8046a7 <memp_free>
  80625d:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  806260:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  806262:	85 f6                	test   %esi,%esi
  806264:	74 5c                	je     8062c2 <tcp_slowtmr+0x472>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  806266:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  80626a:	75 ae                	jne    80621a <tcp_slowtmr+0x3ca>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80626c:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  806271:	2b 46 2c             	sub    0x2c(%esi),%eax
  806274:	3d f0 00 00 00       	cmp    $0xf0,%eax
  806279:	77 b6                	ja     806231 <tcp_slowtmr+0x3e1>
      prev = pcb;
  80627b:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80627d:	8b 76 0c             	mov    0xc(%esi),%esi
  806280:	eb e0                	jmp    806262 <tcp_slowtmr+0x412>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806282:	83 ec 04             	sub    $0x4,%esp
  806285:	68 6c 24 81 00       	push   $0x81246c
  80628a:	68 f4 02 00 00       	push   $0x2f4
  80628f:	68 ee 24 81 00       	push   $0x8124ee
  806294:	e8 70 85 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806299:	3b 35 50 c2 b3 00    	cmp    0xb3c250,%esi
  80629f:	75 0a                	jne    8062ab <tcp_slowtmr+0x45b>
        tcp_tw_pcbs = pcb->next;
  8062a1:	8b 46 0c             	mov    0xc(%esi),%eax
  8062a4:	a3 50 c2 b3 00       	mov    %eax,0xb3c250
  8062a9:	eb a4                	jmp    80624f <tcp_slowtmr+0x3ff>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8062ab:	83 ec 04             	sub    $0x4,%esp
  8062ae:	68 94 24 81 00       	push   $0x812494
  8062b3:	68 f8 02 00 00       	push   $0x2f8
  8062b8:	68 ee 24 81 00       	push   $0x8124ee
  8062bd:	e8 47 85 00 00       	call   80e809 <_panic>
}
  8062c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8062c5:	5b                   	pop    %ebx
  8062c6:	5e                   	pop    %esi
  8062c7:	5f                   	pop    %edi
  8062c8:	5d                   	pop    %ebp
  8062c9:	c3                   	ret    

008062ca <tcp_tmr>:
{
  8062ca:	55                   	push   %ebp
  8062cb:	89 e5                	mov    %esp,%ebp
  8062cd:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  8062d0:	e8 c2 f5 ff ff       	call   805897 <tcp_fasttmr>
  if (++tcp_timer & 1) {
  8062d5:	0f b6 05 f9 53 b3 00 	movzbl 0xb353f9,%eax
  8062dc:	83 c0 01             	add    $0x1,%eax
  8062df:	a2 f9 53 b3 00       	mov    %al,0xb353f9
  8062e4:	a8 01                	test   $0x1,%al
  8062e6:	75 02                	jne    8062ea <tcp_tmr+0x20>
}
  8062e8:	c9                   	leave  
  8062e9:	c3                   	ret    
    tcp_slowtmr();
  8062ea:	e8 61 fb ff ff       	call   805e50 <tcp_slowtmr>
}
  8062ef:	eb f7                	jmp    8062e8 <tcp_tmr+0x1e>

008062f1 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8062f1:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  8062f6:	03 05 08 50 81 00    	add    0x815008,%eax
  8062fc:	a3 08 50 81 00       	mov    %eax,0x815008
  return iss;
}
  806301:	c3                   	ret    

00806302 <tcp_alloc>:
{
  806302:	55                   	push   %ebp
  806303:	89 e5                	mov    %esp,%ebp
  806305:	57                   	push   %edi
  806306:	56                   	push   %esi
  806307:	53                   	push   %ebx
  806308:	83 ec 28             	sub    $0x28,%esp
  80630b:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  80630f:	6a 02                	push   $0x2
  806311:	e8 3b e3 ff ff       	call   804651 <memp_malloc>
  806316:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  806318:	83 c4 10             	add    $0x10,%esp
  80631b:	85 c0                	test   %eax,%eax
  80631d:	0f 84 a0 00 00 00    	je     8063c3 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806323:	83 ec 04             	sub    $0x4,%esp
  806326:	68 a8 00 00 00       	push   $0xa8
  80632b:	6a 00                	push   $0x0
  80632d:	53                   	push   %ebx
  80632e:	e8 71 8e 00 00       	call   80f1a4 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806333:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  806337:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80633d:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  806343:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  806349:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  80634f:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  806353:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  806357:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80635d:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  806363:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  806369:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  80636f:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  806375:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80637b:	e8 71 ff ff ff       	call   8062f1 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806380:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806383:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  806386:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  806389:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  80638c:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80638f:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  806394:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  806397:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  80639b:	c7 83 88 00 00 00 1e 	movl   $0x805d1e,0x88(%ebx)
  8063a2:	5d 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8063a5:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  8063ac:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  8063af:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  8063b6:	83 c4 10             	add    $0x10,%esp
}
  8063b9:	89 d8                	mov    %ebx,%eax
  8063bb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8063be:	5b                   	pop    %ebx
  8063bf:	5e                   	pop    %esi
  8063c0:	5f                   	pop    %edi
  8063c1:	5d                   	pop    %ebp
  8063c2:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8063c3:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8063c8:	8b 3d 40 c2 b3 00    	mov    0xb3c240,%edi
  inactivity = 0;
  8063ce:	b9 00 00 00 00       	mov    $0x0,%ecx
  8063d3:	eb 03                	jmp    8063d8 <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8063d5:	8b 40 0c             	mov    0xc(%eax),%eax
  8063d8:	85 c0                	test   %eax,%eax
  8063da:	74 0f                	je     8063eb <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8063dc:	89 fa                	mov    %edi,%edx
  8063de:	2b 50 2c             	sub    0x2c(%eax),%edx
  8063e1:	39 ca                	cmp    %ecx,%edx
  8063e3:	72 f0                	jb     8063d5 <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  8063e5:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8063e7:	89 c3                	mov    %eax,%ebx
  8063e9:	eb ea                	jmp    8063d5 <tcp_alloc+0xd3>
  if (inactive != NULL) {
  8063eb:	85 db                	test   %ebx,%ebx
  8063ed:	74 0c                	je     8063fb <tcp_alloc+0xf9>
    tcp_abort(inactive);
  8063ef:	83 ec 0c             	sub    $0xc,%esp
  8063f2:	53                   	push   %ebx
  8063f3:	e8 62 f9 ff ff       	call   805d5a <tcp_abort>
  8063f8:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  8063fb:	83 ec 0c             	sub    $0xc,%esp
  8063fe:	6a 02                	push   $0x2
  806400:	e8 4c e2 ff ff       	call   804651 <memp_malloc>
  806405:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  806407:	83 c4 10             	add    $0x10,%esp
  80640a:	85 c0                	test   %eax,%eax
  80640c:	0f 85 11 ff ff ff    	jne    806323 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806412:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806417:	8b 3d 40 c2 b3 00    	mov    0xb3c240,%edi
  80641d:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  806420:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  806425:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80642c:	89 df                	mov    %ebx,%edi
  80642e:	89 f1                	mov    %esi,%ecx
  806430:	88 4d e7             	mov    %cl,-0x19(%ebp)
  806433:	eb 03                	jmp    806438 <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806435:	8b 40 0c             	mov    0xc(%eax),%eax
  806438:	85 c0                	test   %eax,%eax
  80643a:	74 29                	je     806465 <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  80643c:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  806440:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  806444:	38 d3                	cmp    %dl,%bl
  806446:	89 d6                	mov    %edx,%esi
  806448:	0f 46 f3             	cmovbe %ebx,%esi
  80644b:	89 f3                	mov    %esi,%ebx
  80644d:	38 cb                	cmp    %cl,%bl
  80644f:	72 e4                	jb     806435 <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806451:	8b 75 dc             	mov    -0x24(%ebp),%esi
  806454:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  806457:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  80645a:	72 d9                	jb     806435 <tcp_alloc+0x133>
      mprio = pcb->prio;
  80645c:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  80645e:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  806461:	89 c7                	mov    %eax,%edi
  806463:	eb d0                	jmp    806435 <tcp_alloc+0x133>
  if (inactive != NULL) {
  806465:	85 ff                	test   %edi,%edi
  806467:	74 0c                	je     806475 <tcp_alloc+0x173>
    tcp_abort(inactive);
  806469:	83 ec 0c             	sub    $0xc,%esp
  80646c:	57                   	push   %edi
  80646d:	e8 e8 f8 ff ff       	call   805d5a <tcp_abort>
  806472:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  806475:	83 ec 0c             	sub    $0xc,%esp
  806478:	6a 02                	push   $0x2
  80647a:	e8 d2 e1 ff ff       	call   804651 <memp_malloc>
  80647f:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806481:	83 c4 10             	add    $0x10,%esp
  806484:	85 c0                	test   %eax,%eax
  806486:	0f 84 2d ff ff ff    	je     8063b9 <tcp_alloc+0xb7>
  80648c:	e9 92 fe ff ff       	jmp    806323 <tcp_alloc+0x21>

00806491 <tcp_new>:
{
  806491:	55                   	push   %ebp
  806492:	89 e5                	mov    %esp,%ebp
  806494:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  806497:	6a 40                	push   $0x40
  806499:	e8 64 fe ff ff       	call   806302 <tcp_alloc>
}
  80649e:	c9                   	leave  
  80649f:	c3                   	ret    

008064a0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  8064a0:	55                   	push   %ebp
  8064a1:	89 e5                	mov    %esp,%ebp
  8064a3:	56                   	push   %esi
  8064a4:	53                   	push   %ebx
  8064a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8064a8:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  8064aa:	83 ec 0c             	sub    $0xc,%esp
  8064ad:	ff 75 0c             	pushl  0xc(%ebp)
  8064b0:	e8 f9 01 00 00       	call   8066ae <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  8064b5:	83 c4 10             	add    $0x10,%esp
  8064b8:	85 c0                	test   %eax,%eax
  8064ba:	74 14                	je     8064d0 <tcp_eff_send_mss+0x30>
  8064bc:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8064c0:	66 85 c0             	test   %ax,%ax
  8064c3:	74 0b                	je     8064d0 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  8064c5:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  8064c8:	66 39 c3             	cmp    %ax,%bx
  8064cb:	0f 46 c3             	cmovbe %ebx,%eax
  8064ce:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  8064d0:	89 f0                	mov    %esi,%eax
  8064d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8064d5:	5b                   	pop    %ebx
  8064d6:	5e                   	pop    %esi
  8064d7:	5d                   	pop    %ebp
  8064d8:	c3                   	ret    

008064d9 <tcp_connect>:
{
  8064d9:	55                   	push   %ebp
  8064da:	89 e5                	mov    %esp,%ebp
  8064dc:	57                   	push   %edi
  8064dd:	56                   	push   %esi
  8064de:	53                   	push   %ebx
  8064df:	83 ec 1c             	sub    $0x1c,%esp
  8064e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8064e5:	8b 75 0c             	mov    0xc(%ebp),%esi
  8064e8:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8064eb:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8064ef:	0f 85 bd 00 00 00    	jne    8065b2 <tcp_connect+0xd9>
  if (ipaddr != NULL) {
  8064f5:	85 f6                	test   %esi,%esi
  8064f7:	0f 84 67 01 00 00    	je     806664 <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  8064fd:	8b 16                	mov    (%esi),%edx
  8064ff:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  806502:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806506:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  80650b:	0f 84 b8 00 00 00    	je     8065c9 <tcp_connect+0xf0>
  iss = tcp_next_iss();
  806511:	e8 db fd ff ff       	call   8062f1 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  806516:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80651d:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  806520:	83 e8 01             	sub    $0x1,%eax
  806523:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  806526:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  806529:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  80652f:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  806535:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80653b:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  806541:	83 ec 08             	sub    $0x8,%esp
  806544:	56                   	push   %esi
  806545:	68 18 02 00 00       	push   $0x218
  80654a:	e8 51 ff ff ff       	call   8064a0 <tcp_eff_send_mss>
  80654f:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  806553:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  806559:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80655c:	01 c0                	add    %eax,%eax
  80655e:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  806562:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  806569:	8b 45 14             	mov    0x14(%ebp),%eax
  80656c:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806572:	8b 15 4c c2 b3 00    	mov    0xb3c24c,%edx
  806578:	83 c4 10             	add    $0x10,%esp
  80657b:	39 da                	cmp    %ebx,%edx
  80657d:	74 58                	je     8065d7 <tcp_connect+0xfe>
  80657f:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  806585:	bf 00 00 00 00       	mov    $0x0,%edi
  80658a:	89 de                	mov    %ebx,%esi
  80658c:	85 d2                	test   %edx,%edx
  80658e:	0f 84 ae 00 00 00    	je     806642 <tcp_connect+0x169>
  806594:	8b 42 0c             	mov    0xc(%edx),%eax
  806597:	39 f0                	cmp    %esi,%eax
  806599:	0f 94 c3             	sete   %bl
  80659c:	85 c0                	test   %eax,%eax
  80659e:	0f 95 c1             	setne  %cl
  8065a1:	84 cb                	test   %cl,%bl
  8065a3:	0f 85 83 00 00 00    	jne    80662c <tcp_connect+0x153>
  8065a9:	bf 01 00 00 00       	mov    $0x1,%edi
  8065ae:	89 c2                	mov    %eax,%edx
  8065b0:	eb da                	jmp    80658c <tcp_connect+0xb3>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8065b2:	83 ec 04             	sub    $0x4,%esp
  8065b5:	68 bc 24 81 00       	push   $0x8124bc
  8065ba:	68 ec 01 00 00       	push   $0x1ec
  8065bf:	68 ee 24 81 00       	push   $0x8124ee
  8065c4:	e8 40 82 00 00       	call   80e809 <_panic>
    pcb->local_port = tcp_new_port();
  8065c9:	e8 6d ef ff ff       	call   80553b <tcp_new_port>
  8065ce:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  8065d2:	e9 3a ff ff ff       	jmp    806511 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8065d7:	8b 43 0c             	mov    0xc(%ebx),%eax
  8065da:	a3 4c c2 b3 00       	mov    %eax,0xb3c24c
  TCP_REG(&tcp_active_pcbs, pcb);
  8065df:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  8065e4:	89 43 0c             	mov    %eax,0xc(%ebx)
  8065e7:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
  8065ed:	e8 d8 bd ff ff       	call   8023ca <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  8065f2:	83 ec 0c             	sub    $0xc,%esp
  8065f5:	68 b4 05 04 02       	push   $0x20405b4
  8065fa:	e8 e9 12 00 00       	call   8078e8 <htonl>
  8065ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806602:	83 c4 0c             	add    $0xc,%esp
  806605:	6a 04                	push   $0x4
  806607:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80660a:	50                   	push   %eax
  80660b:	6a 00                	push   $0x0
  80660d:	6a 02                	push   $0x2
  80660f:	6a 00                	push   $0x0
  806611:	6a 00                	push   $0x0
  806613:	53                   	push   %ebx
  806614:	e8 f9 14 00 00       	call   807b12 <tcp_enqueue>
  806619:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80661b:	83 c4 20             	add    $0x20,%esp
  80661e:	84 c0                	test   %al,%al
  806620:	74 34                	je     806656 <tcp_connect+0x17d>
} 
  806622:	89 f0                	mov    %esi,%eax
  806624:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806627:	5b                   	pop    %ebx
  806628:	5e                   	pop    %esi
  806629:	5f                   	pop    %edi
  80662a:	5d                   	pop    %ebp
  80662b:	c3                   	ret    
  80662c:	89 f3                	mov    %esi,%ebx
  80662e:	89 f8                	mov    %edi,%eax
  806630:	84 c0                	test   %al,%al
  806632:	74 06                	je     80663a <tcp_connect+0x161>
  806634:	89 15 48 c2 b3 00    	mov    %edx,0xb3c248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80663a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80663d:	89 42 0c             	mov    %eax,0xc(%edx)
  806640:	eb 9d                	jmp    8065df <tcp_connect+0x106>
  806642:	89 f3                	mov    %esi,%ebx
  806644:	89 f8                	mov    %edi,%eax
  806646:	84 c0                	test   %al,%al
  806648:	74 95                	je     8065df <tcp_connect+0x106>
  80664a:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  806651:	00 00 00 
  806654:	eb 89                	jmp    8065df <tcp_connect+0x106>
    tcp_output(pcb);
  806656:	83 ec 0c             	sub    $0xc,%esp
  806659:	53                   	push   %ebx
  80665a:	e8 d0 1b 00 00       	call   80822f <tcp_output>
  80665f:	83 c4 10             	add    $0x10,%esp
  806662:	eb be                	jmp    806622 <tcp_connect+0x149>
    return ERR_VAL;
  806664:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  806669:	eb b7                	jmp    806622 <tcp_connect+0x149>

0080666b <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80666b:	55                   	push   %ebp
  80666c:	89 e5                	mov    %esp,%ebp
  80666e:	53                   	push   %ebx
  80666f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806672:	8b 45 08             	mov    0x8(%ebp),%eax
  806675:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806677:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80667a:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80667f:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806682:	77 27                	ja     8066ab <ip_addr_isbroadcast+0x40>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806684:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  806688:	83 e0 02             	and    $0x2,%eax
  80668b:	74 1e                	je     8066ab <ip_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80668d:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  806690:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  806695:	39 d3                	cmp    %edx,%ebx
  806697:	74 12                	je     8066ab <ip_addr_isbroadcast+0x40>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806699:	8b 49 08             	mov    0x8(%ecx),%ecx
  80669c:	31 d3                	xor    %edx,%ebx
  80669e:	85 cb                	test   %ecx,%ebx
  8066a0:	75 09                	jne    8066ab <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8066a2:	f7 d1                	not    %ecx
  8066a4:	21 ca                	and    %ecx,%edx
  8066a6:	39 ca                	cmp    %ecx,%edx
  8066a8:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8066ab:	5b                   	pop    %ebx
  8066ac:	5d                   	pop    %ebp
  8066ad:	c3                   	ret    

008066ae <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  8066ae:	55                   	push   %ebp
  8066af:	89 e5                	mov    %esp,%ebp
  8066b1:	56                   	push   %esi
  8066b2:	53                   	push   %ebx
  8066b3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8066b6:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
  8066bc:	eb 02                	jmp    8066c0 <ip_route+0x12>
  8066be:	8b 1b                	mov    (%ebx),%ebx
  8066c0:	85 db                	test   %ebx,%ebx
  8066c2:	74 1c                	je     8066e0 <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  8066c4:	83 ec 0c             	sub    $0xc,%esp
  8066c7:	53                   	push   %ebx
  8066c8:	e8 4b e2 ff ff       	call   804918 <netif_is_up>
  8066cd:	83 c4 10             	add    $0x10,%esp
  8066d0:	84 c0                	test   %al,%al
  8066d2:	74 ea                	je     8066be <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  8066d4:	8b 06                	mov    (%esi),%eax
  8066d6:	33 43 04             	xor    0x4(%ebx),%eax
  8066d9:	85 43 08             	test   %eax,0x8(%ebx)
  8066dc:	75 e0                	jne    8066be <ip_route+0x10>
  8066de:	eb 1e                	jmp    8066fe <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8066e0:	a1 38 c2 b3 00       	mov    0xb3c238,%eax
  8066e5:	85 c0                	test   %eax,%eax
  8066e7:	74 1e                	je     806707 <ip_route+0x59>
  8066e9:	83 ec 0c             	sub    $0xc,%esp
  8066ec:	50                   	push   %eax
  8066ed:	e8 26 e2 ff ff       	call   804918 <netif_is_up>
  8066f2:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8066f5:	84 c0                	test   %al,%al
  8066f7:	0f 45 1d 38 c2 b3 00 	cmovne 0xb3c238,%ebx
}
  8066fe:	89 d8                	mov    %ebx,%eax
  806700:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806703:	5b                   	pop    %ebx
  806704:	5e                   	pop    %esi
  806705:	5d                   	pop    %ebp
  806706:	c3                   	ret    
    return NULL;
  806707:	89 c3                	mov    %eax,%ebx
  806709:	eb f3                	jmp    8066fe <ip_route+0x50>

0080670b <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80670b:	55                   	push   %ebp
  80670c:	89 e5                	mov    %esp,%ebp
  80670e:	57                   	push   %edi
  80670f:	56                   	push   %esi
  806710:	53                   	push   %ebx
  806711:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806714:	8b 45 08             	mov    0x8(%ebp),%eax
  806717:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  80671a:	0f b7 07             	movzwl (%edi),%eax
  80671d:	50                   	push   %eax
  80671e:	e8 b8 11 00 00       	call   8078db <ntohs>
  806723:	66 c1 e8 0c          	shr    $0xc,%ax
  806727:	83 c4 10             	add    $0x10,%esp
  80672a:	66 83 f8 04          	cmp    $0x4,%ax
  80672e:	74 1b                	je     80674b <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806730:	83 ec 0c             	sub    $0xc,%esp
  806733:	ff 75 08             	pushl  0x8(%ebp)
  806736:	e8 b9 e2 ff ff       	call   8049f4 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80673b:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80673e:	b8 00 00 00 00       	mov    $0x0,%eax
  806743:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806746:	5b                   	pop    %ebx
  806747:	5e                   	pop    %esi
  806748:	5f                   	pop    %edi
  806749:	5d                   	pop    %ebp
  80674a:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  80674b:	83 ec 0c             	sub    $0xc,%esp
  80674e:	0f b7 07             	movzwl (%edi),%eax
  806751:	50                   	push   %eax
  806752:	e8 84 11 00 00       	call   8078db <ntohs>
  806757:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  80675b:	83 e0 3c             	and    $0x3c,%eax
  80675e:	89 c6                	mov    %eax,%esi
  806760:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806764:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  806768:	89 04 24             	mov    %eax,(%esp)
  80676b:	e8 6b 11 00 00       	call   8078db <ntohs>
  806770:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806772:	83 c4 10             	add    $0x10,%esp
  806775:	8b 45 08             	mov    0x8(%ebp),%eax
  806778:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80677c:	72 06                	jb     806784 <ip_input+0x79>
  80677e:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806782:	73 10                	jae    806794 <ip_input+0x89>
    pbuf_free(p);
  806784:	83 ec 0c             	sub    $0xc,%esp
  806787:	ff 75 08             	pushl  0x8(%ebp)
  80678a:	e8 65 e2 ff ff       	call   8049f4 <pbuf_free>
    return ERR_OK;
  80678f:	83 c4 10             	add    $0x10,%esp
  806792:	eb aa                	jmp    80673e <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806794:	83 ec 08             	sub    $0x8,%esp
  806797:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80679b:	50                   	push   %eax
  80679c:	57                   	push   %edi
  80679d:	e8 fe 0f 00 00       	call   8077a0 <inet_chksum>
  8067a2:	83 c4 10             	add    $0x10,%esp
  8067a5:	66 85 c0             	test   %ax,%ax
  8067a8:	75 27                	jne    8067d1 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  8067aa:	83 ec 08             	sub    $0x8,%esp
  8067ad:	0f b7 db             	movzwl %bx,%ebx
  8067b0:	53                   	push   %ebx
  8067b1:	ff 75 08             	pushl  0x8(%ebp)
  8067b4:	e8 73 e5 ff ff       	call   804d2c <pbuf_realloc>
  8067b9:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  8067bc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  8067bf:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8067c4:	8d 47 10             	lea    0x10(%edi),%eax
  8067c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8067ca:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  8067cd:	89 df                	mov    %ebx,%edi
  8067cf:	eb 2e                	jmp    8067ff <ip_input+0xf4>
    pbuf_free(p);
  8067d1:	83 ec 0c             	sub    $0xc,%esp
  8067d4:	ff 75 08             	pushl  0x8(%ebp)
  8067d7:	e8 18 e2 ff ff       	call   8049f4 <pbuf_free>
    return ERR_OK;
  8067dc:	83 c4 10             	add    $0x10,%esp
  8067df:	e9 5a ff ff ff       	jmp    80673e <ip_input+0x33>
      if (first) {
  8067e4:	85 f6                	test   %esi,%esi
  8067e6:	74 56                	je     80683e <ip_input+0x133>
        netif = netif_list;
  8067e8:	8b 1d 34 c2 b3 00    	mov    0xb3c234,%ebx
      if (netif == inp) {
  8067ee:	39 df                	cmp    %ebx,%edi
  8067f0:	74 50                	je     806842 <ip_input+0x137>
  8067f2:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  8067f7:	85 db                	test   %ebx,%ebx
  8067f9:	0f 84 20 01 00 00    	je     80691f <ip_input+0x214>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8067ff:	83 ec 0c             	sub    $0xc,%esp
  806802:	53                   	push   %ebx
  806803:	e8 10 e1 ff ff       	call   804918 <netif_is_up>
  806808:	83 c4 10             	add    $0x10,%esp
  80680b:	84 c0                	test   %al,%al
  80680d:	74 d5                	je     8067e4 <ip_input+0xd9>
  80680f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806812:	74 d0                	je     8067e4 <ip_input+0xd9>
  806814:	8b 43 04             	mov    0x4(%ebx),%eax
  806817:	85 c0                	test   %eax,%eax
  806819:	74 c9                	je     8067e4 <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80681b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80681e:	3b 42 10             	cmp    0x10(%edx),%eax
  806821:	74 4a                	je     80686d <ip_input+0x162>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806823:	83 ec 08             	sub    $0x8,%esp
  806826:	53                   	push   %ebx
  806827:	ff 75 dc             	pushl  -0x24(%ebp)
  80682a:	e8 3c fe ff ff       	call   80666b <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80682f:	83 c4 10             	add    $0x10,%esp
  806832:	84 c0                	test   %al,%al
  806834:	74 ae                	je     8067e4 <ip_input+0xd9>
  806836:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806839:	e9 fc 00 00 00       	jmp    80693a <ip_input+0x22f>
        netif = netif->next;
  80683e:	8b 1b                	mov    (%ebx),%ebx
  806840:	eb ac                	jmp    8067ee <ip_input+0xe3>
        netif = netif->next;
  806842:	8b 1b                	mov    (%ebx),%ebx
  806844:	eb ac                	jmp    8067f2 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806846:	83 ec 0c             	sub    $0xc,%esp
  806849:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80684d:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  806852:	50                   	push   %eax
  806853:	e8 83 10 00 00       	call   8078db <ntohs>
  806858:	83 c4 10             	add    $0x10,%esp
  80685b:	66 83 f8 44          	cmp    $0x44,%ax
  80685f:	0f 85 d5 00 00 00    	jne    80693a <ip_input+0x22f>
        netif = inp;
  806865:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806868:	e9 10 01 00 00       	jmp    80697d <ip_input+0x272>
  80686d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806870:	e9 c5 00 00 00       	jmp    80693a <ip_input+0x22f>
      pbuf_free(p);
  806875:	83 ec 0c             	sub    $0xc,%esp
  806878:	ff 75 08             	pushl  0x8(%ebp)
  80687b:	e8 74 e1 ff ff       	call   8049f4 <pbuf_free>
      return ERR_OK;
  806880:	83 c4 10             	add    $0x10,%esp
  806883:	e9 b6 fe ff ff       	jmp    80673e <ip_input+0x33>
    pbuf_free(p);
  806888:	83 ec 0c             	sub    $0xc,%esp
  80688b:	ff 75 08             	pushl  0x8(%ebp)
  80688e:	e8 61 e1 ff ff       	call   8049f4 <pbuf_free>
    return ERR_OK;
  806893:	83 c4 10             	add    $0x10,%esp
  806896:	e9 a3 fe ff ff       	jmp    80673e <ip_input+0x33>
      udp_input(p, inp);
  80689b:	83 ec 08             	sub    $0x8,%esp
  80689e:	ff 75 0c             	pushl  0xc(%ebp)
  8068a1:	ff 75 08             	pushl  0x8(%ebp)
  8068a4:	e8 6b 22 00 00       	call   808b14 <udp_input>
      break;
  8068a9:	83 c4 10             	add    $0x10,%esp
  8068ac:	e9 8d fe ff ff       	jmp    80673e <ip_input+0x33>
      tcp_input(p, inp);
  8068b1:	83 ec 08             	sub    $0x8,%esp
  8068b4:	ff 75 0c             	pushl  0xc(%ebp)
  8068b7:	ff 75 08             	pushl  0x8(%ebp)
  8068ba:	e8 5d 69 00 00       	call   80d21c <tcp_input>
      break;
  8068bf:	83 c4 10             	add    $0x10,%esp
  8068c2:	e9 77 fe ff ff       	jmp    80673e <ip_input+0x33>
      icmp_input(p, inp);
  8068c7:	83 ec 08             	sub    $0x8,%esp
  8068ca:	ff 75 0c             	pushl  0xc(%ebp)
  8068cd:	ff 75 08             	pushl  0x8(%ebp)
  8068d0:	e8 47 79 00 00       	call   80e21c <icmp_input>
      break;
  8068d5:	83 c4 10             	add    $0x10,%esp
  8068d8:	e9 61 fe ff ff       	jmp    80673e <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8068dd:	8b 5f 10             	mov    0x10(%edi),%ebx
  8068e0:	83 ec 0c             	sub    $0xc,%esp
  8068e3:	68 00 00 00 f0       	push   $0xf0000000
  8068e8:	e8 12 12 00 00       	call   807aff <ntohl>
  8068ed:	21 c3                	and    %eax,%ebx
  8068ef:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8068f6:	e8 04 12 00 00       	call   807aff <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8068fb:	83 c4 10             	add    $0x10,%esp
  8068fe:	39 c3                	cmp    %eax,%ebx
  806900:	0f 84 18 01 00 00    	je     806a1e <ip_input+0x313>
        p->payload = iphdr;
  806906:	8b 45 08             	mov    0x8(%ebp),%eax
  806909:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80690c:	83 ec 08             	sub    $0x8,%esp
  80690f:	6a 02                	push   $0x2
  806911:	50                   	push   %eax
  806912:	e8 1f 7c 00 00       	call   80e536 <icmp_dest_unreach>
  806917:	83 c4 10             	add    $0x10,%esp
  80691a:	e9 ff 00 00 00       	jmp    806a1e <ip_input+0x313>
  80691f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806922:	83 ec 0c             	sub    $0xc,%esp
  806925:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806929:	50                   	push   %eax
  80692a:	e8 ac 0f 00 00       	call   8078db <ntohs>
  80692f:	83 c4 10             	add    $0x10,%esp
  806932:	3c 11                	cmp    $0x11,%al
  806934:	0f 84 0c ff ff ff    	je     806846 <ip_input+0x13b>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80693a:	83 ec 08             	sub    $0x8,%esp
  80693d:	ff 75 0c             	pushl  0xc(%ebp)
  806940:	8d 47 0c             	lea    0xc(%edi),%eax
  806943:	50                   	push   %eax
  806944:	e8 22 fd ff ff       	call   80666b <ip_addr_isbroadcast>
  806949:	83 c4 10             	add    $0x10,%esp
  80694c:	84 c0                	test   %al,%al
  80694e:	0f 85 21 ff ff ff    	jne    806875 <ip_input+0x16a>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806954:	8b 77 0c             	mov    0xc(%edi),%esi
  806957:	83 ec 0c             	sub    $0xc,%esp
  80695a:	68 00 00 00 f0       	push   $0xf0000000
  80695f:	e8 9b 11 00 00       	call   807aff <ntohl>
  806964:	21 c6                	and    %eax,%esi
  806966:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80696d:	e8 8d 11 00 00       	call   807aff <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806972:	83 c4 10             	add    $0x10,%esp
  806975:	39 c6                	cmp    %eax,%esi
  806977:	0f 84 f8 fe ff ff    	je     806875 <ip_input+0x16a>
  if (netif == NULL) {
  80697d:	85 db                	test   %ebx,%ebx
  80697f:	0f 84 03 ff ff ff    	je     806888 <ip_input+0x17d>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806985:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  806989:	83 ec 0c             	sub    $0xc,%esp
  80698c:	68 ff 3f 00 00       	push   $0x3fff
  806991:	e8 38 0f 00 00       	call   8078ce <htons>
  806996:	83 c4 10             	add    $0x10,%esp
  806999:	66 85 c3             	test   %ax,%bx
  80699c:	74 1c                	je     8069ba <ip_input+0x2af>
    p = ip_reass(p);
  80699e:	83 ec 0c             	sub    $0xc,%esp
  8069a1:	ff 75 08             	pushl  0x8(%ebp)
  8069a4:	e8 95 04 00 00       	call   806e3e <ip_reass>
  8069a9:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  8069ac:	83 c4 10             	add    $0x10,%esp
  8069af:	85 c0                	test   %eax,%eax
  8069b1:	0f 84 87 fd ff ff    	je     80673e <ip_input+0x33>
    iphdr = p->payload;
  8069b7:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  8069ba:	83 ec 08             	sub    $0x8,%esp
  8069bd:	ff 75 0c             	pushl  0xc(%ebp)
  8069c0:	ff 75 08             	pushl  0x8(%ebp)
  8069c3:	e8 ab 75 00 00       	call   80df73 <raw_input>
  8069c8:	83 c4 10             	add    $0x10,%esp
  8069cb:	84 c0                	test   %al,%al
  8069cd:	0f 85 6b fd ff ff    	jne    80673e <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  8069d3:	83 ec 0c             	sub    $0xc,%esp
  8069d6:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8069da:	50                   	push   %eax
  8069db:	e8 fb 0e 00 00       	call   8078db <ntohs>
  8069e0:	0f b6 c0             	movzbl %al,%eax
  8069e3:	83 c4 10             	add    $0x10,%esp
  8069e6:	66 83 f8 06          	cmp    $0x6,%ax
  8069ea:	0f 84 c1 fe ff ff    	je     8068b1 <ip_input+0x1a6>
  8069f0:	66 83 f8 11          	cmp    $0x11,%ax
  8069f4:	0f 84 a1 fe ff ff    	je     80689b <ip_input+0x190>
  8069fa:	66 83 f8 01          	cmp    $0x1,%ax
  8069fe:	0f 84 c3 fe ff ff    	je     8068c7 <ip_input+0x1bc>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806a04:	83 ec 08             	sub    $0x8,%esp
  806a07:	ff 75 0c             	pushl  0xc(%ebp)
  806a0a:	8d 47 10             	lea    0x10(%edi),%eax
  806a0d:	50                   	push   %eax
  806a0e:	e8 58 fc ff ff       	call   80666b <ip_addr_isbroadcast>
  806a13:	83 c4 10             	add    $0x10,%esp
  806a16:	84 c0                	test   %al,%al
  806a18:	0f 84 bf fe ff ff    	je     8068dd <ip_input+0x1d2>
      pbuf_free(p);
  806a1e:	83 ec 0c             	sub    $0xc,%esp
  806a21:	ff 75 08             	pushl  0x8(%ebp)
  806a24:	e8 cb df ff ff       	call   8049f4 <pbuf_free>
  806a29:	83 c4 10             	add    $0x10,%esp
  806a2c:	e9 0d fd ff ff       	jmp    80673e <ip_input+0x33>

00806a31 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806a31:	55                   	push   %ebp
  806a32:	89 e5                	mov    %esp,%ebp
  806a34:	57                   	push   %edi
  806a35:	56                   	push   %esi
  806a36:	53                   	push   %ebx
  806a37:	83 ec 1c             	sub    $0x1c,%esp
  806a3a:	8b 75 08             	mov    0x8(%ebp),%esi
  806a3d:	8b 7d 14             	mov    0x14(%ebp),%edi
  806a40:	8b 45 18             	mov    0x18(%ebp),%eax
  806a43:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806a46:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806a49:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806a4c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806a50:	0f 84 42 01 00 00    	je     806b98 <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806a56:	83 ec 08             	sub    $0x8,%esp
  806a59:	6a 14                	push   $0x14
  806a5b:	56                   	push   %esi
  806a5c:	e8 c6 de ff ff       	call   804927 <pbuf_header>
  806a61:	83 c4 10             	add    $0x10,%esp
  806a64:	84 c0                	test   %al,%al
  806a66:	0f 85 4b 01 00 00    	jne    806bb7 <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806a6c:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806a6f:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806a74:	0f 86 02 01 00 00    	jbe    806b7c <ip_output_if+0x14b>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806a7a:	83 ec 0c             	sub    $0xc,%esp
  806a7d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806a81:	50                   	push   %eax
  806a82:	e8 54 0e 00 00       	call   8078db <ntohs>
  806a87:	0f b6 c0             	movzbl %al,%eax
  806a8a:	c1 e7 08             	shl    $0x8,%edi
  806a8d:	09 c7                	or     %eax,%edi
  806a8f:	0f b7 ff             	movzwl %di,%edi
  806a92:	89 3c 24             	mov    %edi,(%esp)
  806a95:	e8 34 0e 00 00       	call   8078ce <htons>
  806a9a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806a9e:	0f b7 c0             	movzwl %ax,%eax
  806aa1:	89 04 24             	mov    %eax,(%esp)
  806aa4:	e8 32 0e 00 00       	call   8078db <ntohs>
  806aa9:	89 c2                	mov    %eax,%edx
  806aab:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806ab1:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  806ab5:	09 d0                	or     %edx,%eax
  806ab7:	0f b7 c0             	movzwl %ax,%eax
  806aba:	89 04 24             	mov    %eax,(%esp)
  806abd:	e8 0c 0e 00 00       	call   8078ce <htons>
  806ac2:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806ac6:	8b 45 10             	mov    0x10(%ebp),%eax
  806ac9:	8b 00                	mov    (%eax),%eax
  806acb:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806ace:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806ad2:	80 cc 45             	or     $0x45,%ah
  806ad5:	89 04 24             	mov    %eax,(%esp)
  806ad8:	e8 f1 0d 00 00       	call   8078ce <htons>
  806add:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806ae0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806ae4:	89 04 24             	mov    %eax,(%esp)
  806ae7:	e8 e2 0d 00 00       	call   8078ce <htons>
  806aec:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806af0:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806af6:	0f b7 05 fa 53 b3 00 	movzwl 0xb353fa,%eax
  806afd:	89 04 24             	mov    %eax,(%esp)
  806b00:	e8 c9 0d 00 00       	call   8078ce <htons>
  806b05:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806b09:	66 83 05 fa 53 b3 00 	addw   $0x1,0xb353fa
  806b10:	01 

    if (ip_addr_isany(src)) {
  806b11:	83 c4 10             	add    $0x10,%esp
  806b14:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806b18:	74 09                	je     806b23 <ip_output_if+0xf2>
  806b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
  806b1d:	8b 00                	mov    (%eax),%eax
  806b1f:	85 c0                	test   %eax,%eax
  806b21:	75 70                	jne    806b93 <ip_output_if+0x162>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806b23:	b8 00 00 00 00       	mov    $0x0,%eax
  806b28:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806b2c:	74 06                	je     806b34 <ip_output_if+0x103>
  806b2e:	8b 45 20             	mov    0x20(%ebp),%eax
  806b31:	8b 40 04             	mov    0x4(%eax),%eax
  806b34:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806b37:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806b3d:	83 ec 08             	sub    $0x8,%esp
  806b40:	6a 14                	push   $0x14
  806b42:	53                   	push   %ebx
  806b43:	e8 58 0c 00 00       	call   8077a0 <inet_chksum>
  806b48:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806b4c:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806b4f:	8b 45 20             	mov    0x20(%ebp),%eax
  806b52:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806b56:	66 85 c0             	test   %ax,%ax
  806b59:	74 06                	je     806b61 <ip_output_if+0x130>
  806b5b:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806b5f:	72 42                	jb     806ba3 <ip_output_if+0x172>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806b61:	83 ec 04             	sub    $0x4,%esp
  806b64:	ff 75 10             	pushl  0x10(%ebp)
  806b67:	56                   	push   %esi
  806b68:	ff 75 20             	pushl  0x20(%ebp)
  806b6b:	8b 45 20             	mov    0x20(%ebp),%eax
  806b6e:	ff 50 14             	call   *0x14(%eax)
  806b71:	83 c4 10             	add    $0x10,%esp
  }
}
  806b74:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806b77:	5b                   	pop    %ebx
  806b78:	5e                   	pop    %esi
  806b79:	5f                   	pop    %edi
  806b7a:	5d                   	pop    %ebp
  806b7b:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806b7c:	83 ec 04             	sub    $0x4,%esp
  806b7f:	68 8c 25 81 00       	push   $0x81258c
  806b84:	68 ee 01 00 00       	push   $0x1ee
  806b89:	68 b9 25 81 00       	push   $0x8125b9
  806b8e:	e8 76 7c 00 00       	call   80e809 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806b93:	89 43 0c             	mov    %eax,0xc(%ebx)
  806b96:	eb 9f                	jmp    806b37 <ip_output_if+0x106>
    dest = &(iphdr->dest);
  806b98:	8b 46 04             	mov    0x4(%esi),%eax
  806b9b:	83 c0 10             	add    $0x10,%eax
  806b9e:	89 45 10             	mov    %eax,0x10(%ebp)
  806ba1:	eb ac                	jmp    806b4f <ip_output_if+0x11e>
    return ip_frag(p,netif,dest);
  806ba3:	83 ec 04             	sub    $0x4,%esp
  806ba6:	ff 75 10             	pushl  0x10(%ebp)
  806ba9:	ff 75 20             	pushl  0x20(%ebp)
  806bac:	56                   	push   %esi
  806bad:	e8 5e 07 00 00       	call   807310 <ip_frag>
  806bb2:	83 c4 10             	add    $0x10,%esp
  806bb5:	eb bd                	jmp    806b74 <ip_output_if+0x143>
      return ERR_BUF;
  806bb7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806bbc:	eb b6                	jmp    806b74 <ip_output_if+0x143>

00806bbe <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806bbe:	55                   	push   %ebp
  806bbf:	89 e5                	mov    %esp,%ebp
  806bc1:	57                   	push   %edi
  806bc2:	56                   	push   %esi
  806bc3:	53                   	push   %ebx
  806bc4:	83 ec 18             	sub    $0x18,%esp
  806bc7:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806bca:	8b 75 18             	mov    0x18(%ebp),%esi
  806bcd:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806bd0:	ff 75 10             	pushl  0x10(%ebp)
  806bd3:	e8 d6 fa ff ff       	call   8066ae <ip_route>
  806bd8:	83 c4 10             	add    $0x10,%esp
  806bdb:	85 c0                	test   %eax,%eax
  806bdd:	74 2d                	je     806c0c <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806bdf:	83 ec 04             	sub    $0x4,%esp
  806be2:	50                   	push   %eax
  806be3:	89 f8                	mov    %edi,%eax
  806be5:	0f b6 f8             	movzbl %al,%edi
  806be8:	57                   	push   %edi
  806be9:	89 f0                	mov    %esi,%eax
  806beb:	0f b6 f0             	movzbl %al,%esi
  806bee:	56                   	push   %esi
  806bef:	0f b6 db             	movzbl %bl,%ebx
  806bf2:	53                   	push   %ebx
  806bf3:	ff 75 10             	pushl  0x10(%ebp)
  806bf6:	ff 75 0c             	pushl  0xc(%ebp)
  806bf9:	ff 75 08             	pushl  0x8(%ebp)
  806bfc:	e8 30 fe ff ff       	call   806a31 <ip_output_if>
  806c01:	83 c4 20             	add    $0x20,%esp
}
  806c04:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806c07:	5b                   	pop    %ebx
  806c08:	5e                   	pop    %esi
  806c09:	5f                   	pop    %edi
  806c0a:	5d                   	pop    %ebp
  806c0b:	c3                   	ret    
    return ERR_RTE;
  806c0c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806c11:	eb f1                	jmp    806c04 <ip_output+0x46>

00806c13 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806c13:	55                   	push   %ebp
  806c14:	89 e5                	mov    %esp,%ebp
  806c16:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806c19:	39 05 e0 59 b3 00    	cmp    %eax,0xb359e0
  806c1f:	74 18                	je     806c39 <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806c21:	85 d2                	test   %edx,%edx
  806c23:	74 1e                	je     806c43 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806c25:	8b 08                	mov    (%eax),%ecx
  806c27:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806c29:	83 ec 08             	sub    $0x8,%esp
  806c2c:	50                   	push   %eax
  806c2d:	6a 05                	push   $0x5
  806c2f:	e8 73 da ff ff       	call   8046a7 <memp_free>
}
  806c34:	83 c4 10             	add    $0x10,%esp
  806c37:	c9                   	leave  
  806c38:	c3                   	ret    
    reassdatagrams = ipr->next;
  806c39:	8b 10                	mov    (%eax),%edx
  806c3b:	89 15 e0 59 b3 00    	mov    %edx,0xb359e0
  806c41:	eb e6                	jmp    806c29 <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806c43:	83 ec 04             	sub    $0x4,%esp
  806c46:	68 d1 25 81 00       	push   $0x8125d1
  806c4b:	68 29 01 00 00       	push   $0x129
  806c50:	68 ea 25 81 00       	push   $0x8125ea
  806c55:	e8 af 7b 00 00       	call   80e809 <_panic>

00806c5a <ip_reass_free_complete_datagram>:
{
  806c5a:	55                   	push   %ebp
  806c5b:	89 e5                	mov    %esp,%ebp
  806c5d:	57                   	push   %edi
  806c5e:	56                   	push   %esi
  806c5f:	53                   	push   %ebx
  806c60:	83 ec 1c             	sub    $0x1c,%esp
  806c63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806c66:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806c69:	39 c2                	cmp    %eax,%edx
  806c6b:	74 53                	je     806cc0 <ip_reass_free_complete_datagram+0x66>
  if (prev != NULL) {
  806c6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806c70:	85 c0                	test   %eax,%eax
  806c72:	74 07                	je     806c7b <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806c74:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c77:	39 10                	cmp    %edx,(%eax)
  806c79:	75 5c                	jne    806cd7 <ip_reass_free_complete_datagram+0x7d>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806c7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c7e:	8b 58 04             	mov    0x4(%eax),%ebx
  806c81:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806c84:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806c89:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806c8e:	74 5e                	je     806cee <ip_reass_free_complete_datagram+0x94>
  p = ipr->p;
  806c90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806c93:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806c96:	85 db                	test   %ebx,%ebx
  806c98:	0f 84 8f 00 00 00    	je     806d2d <ip_reass_free_complete_datagram+0xd3>
    iprh = (struct ip_reass_helper *)p->payload;
  806c9e:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806ca1:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806ca3:	83 ec 0c             	sub    $0xc,%esp
  806ca6:	53                   	push   %ebx
  806ca7:	e8 92 e1 ff ff       	call   804e3e <pbuf_clen>
  806cac:	0f b6 c0             	movzbl %al,%eax
  806caf:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806cb1:	89 1c 24             	mov    %ebx,(%esp)
  806cb4:	e8 3b dd ff ff       	call   8049f4 <pbuf_free>
  806cb9:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806cbc:	89 fb                	mov    %edi,%ebx
  806cbe:	eb d6                	jmp    806c96 <ip_reass_free_complete_datagram+0x3c>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806cc0:	83 ec 04             	sub    $0x4,%esp
  806cc3:	68 07 26 81 00       	push   $0x812607
  806cc8:	68 99 00 00 00       	push   $0x99
  806ccd:	68 ea 25 81 00       	push   $0x8125ea
  806cd2:	e8 32 7b 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806cd7:	83 ec 04             	sub    $0x4,%esp
  806cda:	68 13 26 81 00       	push   $0x812613
  806cdf:	68 9b 00 00 00       	push   $0x9b
  806ce4:	68 ea 25 81 00       	push   $0x8125ea
  806ce9:	e8 1b 7b 00 00       	call   80e809 <_panic>
    ipr->p = iprh->next_pbuf;
  806cee:	8b 00                	mov    (%eax),%eax
  806cf0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806cf3:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806cf6:	83 ec 04             	sub    $0x4,%esp
  806cf9:	6a 14                	push   $0x14
  806cfb:	8d 41 08             	lea    0x8(%ecx),%eax
  806cfe:	50                   	push   %eax
  806cff:	ff 73 04             	pushl  0x4(%ebx)
  806d02:	e8 47 85 00 00       	call   80f24e <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806d07:	83 c4 08             	add    $0x8,%esp
  806d0a:	6a 01                	push   $0x1
  806d0c:	53                   	push   %ebx
  806d0d:	e8 07 79 00 00       	call   80e619 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806d12:	89 1c 24             	mov    %ebx,(%esp)
  806d15:	e8 24 e1 ff ff       	call   804e3e <pbuf_clen>
  806d1a:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806d1d:	89 1c 24             	mov    %ebx,(%esp)
  806d20:	e8 cf dc ff ff       	call   8049f4 <pbuf_free>
  806d25:	83 c4 10             	add    $0x10,%esp
  806d28:	e9 63 ff ff ff       	jmp    806c90 <ip_reass_free_complete_datagram+0x36>
  ip_reass_dequeue_datagram(ipr, prev);
  806d2d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806d30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806d33:	e8 db fe ff ff       	call   806c13 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806d38:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806d3f:	0f b7 d0             	movzwl %ax,%edx
  806d42:	39 f2                	cmp    %esi,%edx
  806d44:	7c 12                	jl     806d58 <ip_reass_free_complete_datagram+0xfe>
  ip_reass_pbufcount -= pbufs_freed;
  806d46:	29 f0                	sub    %esi,%eax
  806d48:	66 a3 dc 59 b3 00    	mov    %ax,0xb359dc
}
  806d4e:	89 f0                	mov    %esi,%eax
  806d50:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806d53:	5b                   	pop    %ebx
  806d54:	5e                   	pop    %esi
  806d55:	5f                   	pop    %edi
  806d56:	5d                   	pop    %ebp
  806d57:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806d58:	83 ec 04             	sub    $0x4,%esp
  806d5b:	68 25 26 81 00       	push   $0x812625
  806d60:	68 bc 00 00 00       	push   $0xbc
  806d65:	68 ea 25 81 00       	push   $0x8125ea
  806d6a:	e8 9a 7a 00 00       	call   80e809 <_panic>

00806d6f <ip_reass_remove_oldest_datagram>:
{
  806d6f:	55                   	push   %ebp
  806d70:	89 e5                	mov    %esp,%ebp
  806d72:	57                   	push   %edi
  806d73:	56                   	push   %esi
  806d74:	53                   	push   %ebx
  806d75:	83 ec 1c             	sub    $0x1c,%esp
  806d78:	89 c6                	mov    %eax,%esi
  806d7a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806d7d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806d84:	eb 5b                	jmp    806de1 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806d86:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806d8a:	85 c0                	test   %eax,%eax
  806d8c:	74 33                	je     806dc1 <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806d8e:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806d92:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806d95:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806d98:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806d9a:	85 ff                	test   %edi,%edi
  806d9c:	0f 45 d1             	cmovne %ecx,%edx
  806d9f:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806da1:	85 c9                	test   %ecx,%ecx
  806da3:	74 20                	je     806dc5 <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806da5:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806da8:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806dab:	75 d9                	jne    806d86 <ip_reass_remove_oldest_datagram+0x17>
  806dad:	8b 7e 10             	mov    0x10(%esi),%edi
  806db0:	39 79 18             	cmp    %edi,0x18(%ecx)
  806db3:	75 d1                	jne    806d86 <ip_reass_remove_oldest_datagram+0x17>
  806db5:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806db9:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806dbd:	75 c7                	jne    806d86 <ip_reass_remove_oldest_datagram+0x17>
  806dbf:	eb d7                	jmp    806d98 <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806dc1:	89 c8                	mov    %ecx,%eax
  806dc3:	eb d3                	jmp    806d98 <ip_reass_remove_oldest_datagram+0x29>
  806dc5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806dc8:	85 c0                	test   %eax,%eax
  806dca:	74 08                	je     806dd4 <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806dcc:	e8 89 fe ff ff       	call   806c5a <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806dd1:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806dd4:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806dd7:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806dda:	7d 1f                	jge    806dfb <ip_reass_remove_oldest_datagram+0x8c>
  806ddc:	83 fb 01             	cmp    $0x1,%ebx
  806ddf:	7e 1a                	jle    806dfb <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806de1:	8b 0d e0 59 b3 00    	mov    0xb359e0,%ecx
    other_datagrams = 0;
  806de7:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806dec:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806df1:	b8 00 00 00 00       	mov    $0x0,%eax
  806df6:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806df9:	eb a6                	jmp    806da1 <ip_reass_remove_oldest_datagram+0x32>
}
  806dfb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806dfe:	83 c4 1c             	add    $0x1c,%esp
  806e01:	5b                   	pop    %ebx
  806e02:	5e                   	pop    %esi
  806e03:	5f                   	pop    %edi
  806e04:	5d                   	pop    %ebp
  806e05:	c3                   	ret    

00806e06 <ip_reass_tmr>:
{
  806e06:	55                   	push   %ebp
  806e07:	89 e5                	mov    %esp,%ebp
  806e09:	56                   	push   %esi
  806e0a:	53                   	push   %ebx
  r = reassdatagrams;
  806e0b:	a1 e0 59 b3 00       	mov    0xb359e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806e10:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806e15:	eb 0b                	jmp    806e22 <ip_reass_tmr+0x1c>
      r = r->next;
  806e17:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806e19:	89 da                	mov    %ebx,%edx
  806e1b:	e8 3a fe ff ff       	call   806c5a <ip_reass_free_complete_datagram>
      r = r->next;
  806e20:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806e22:	85 c0                	test   %eax,%eax
  806e24:	74 14                	je     806e3a <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806e26:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806e2a:	84 d2                	test   %dl,%dl
  806e2c:	74 e9                	je     806e17 <ip_reass_tmr+0x11>
      r->timer--;
  806e2e:	83 ea 01             	sub    $0x1,%edx
  806e31:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806e34:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806e36:	8b 00                	mov    (%eax),%eax
  806e38:	eb e8                	jmp    806e22 <ip_reass_tmr+0x1c>
}
  806e3a:	5b                   	pop    %ebx
  806e3b:	5e                   	pop    %esi
  806e3c:	5d                   	pop    %ebp
  806e3d:	c3                   	ret    

00806e3e <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806e3e:	55                   	push   %ebp
  806e3f:	89 e5                	mov    %esp,%ebp
  806e41:	57                   	push   %edi
  806e42:	56                   	push   %esi
  806e43:	53                   	push   %ebx
  806e44:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806e47:	8b 45 08             	mov    0x8(%ebp),%eax
  806e4a:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806e4d:	0f b7 03             	movzwl (%ebx),%eax
  806e50:	50                   	push   %eax
  806e51:	e8 85 0a 00 00       	call   8078db <ntohs>
  806e56:	66 c1 e8 08          	shr    $0x8,%ax
  806e5a:	83 e0 0f             	and    $0xf,%eax
  806e5d:	83 c4 10             	add    $0x10,%esp
  806e60:	83 f8 05             	cmp    $0x5,%eax
  806e63:	0f 85 dc 01 00 00    	jne    807045 <ip_reass+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806e69:	83 ec 0c             	sub    $0xc,%esp
  806e6c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e70:	50                   	push   %eax
  806e71:	e8 65 0a 00 00       	call   8078db <ntohs>
  806e76:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e7a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e7e:	89 04 24             	mov    %eax,(%esp)
  806e81:	e8 55 0a 00 00       	call   8078db <ntohs>
  806e86:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806e8a:	0f b7 03             	movzwl (%ebx),%eax
  806e8d:	89 04 24             	mov    %eax,(%esp)
  806e90:	e8 46 0a 00 00       	call   8078db <ntohs>
  806e95:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806e99:	83 c4 04             	add    $0x4,%esp
  806e9c:	ff 75 08             	pushl  0x8(%ebp)
  806e9f:	e8 9a df ff ff       	call   804e3e <pbuf_clen>
  806ea4:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806ea7:	0f b6 f0             	movzbl %al,%esi
  806eaa:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806eb1:	01 f0                	add    %esi,%eax
  806eb3:	83 c4 10             	add    $0x10,%esp
  806eb6:	83 f8 0a             	cmp    $0xa,%eax
  806eb9:	7f 0d                	jg     806ec8 <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806ebb:	8b 3d e0 59 b3 00    	mov    0xb359e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806ec6:	eb 28                	jmp    806ef0 <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806ec8:	89 f2                	mov    %esi,%edx
  806eca:	89 d8                	mov    %ebx,%eax
  806ecc:	e8 9e fe ff ff       	call   806d6f <ip_reass_remove_oldest_datagram>
  806ed1:	85 c0                	test   %eax,%eax
  806ed3:	0f 84 6c 01 00 00    	je     807045 <ip_reass+0x207>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806ed9:	0f b7 05 dc 59 b3 00 	movzwl 0xb359dc,%eax
  806ee0:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806ee2:	83 f8 0a             	cmp    $0xa,%eax
  806ee5:	7e d4                	jle    806ebb <ip_reass+0x7d>
  806ee7:	e9 59 01 00 00       	jmp    807045 <ip_reass+0x207>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806eec:	89 f8                	mov    %edi,%eax
  806eee:	8b 3f                	mov    (%edi),%edi
  806ef0:	85 ff                	test   %edi,%edi
  806ef2:	0f 84 f5 00 00 00    	je     806fed <ip_reass+0x1af>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806ef8:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806efb:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806efe:	75 ec                	jne    806eec <ip_reass+0xae>
  806f00:	8b 53 10             	mov    0x10(%ebx),%edx
  806f03:	39 57 18             	cmp    %edx,0x18(%edi)
  806f06:	75 e4                	jne    806eec <ip_reass+0xae>
  806f08:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806f0c:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806f10:	75 da                	jne    806eec <ip_reass+0xae>
  806f12:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f15:	83 ec 0c             	sub    $0xc,%esp
  806f18:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806f1c:	50                   	push   %eax
  806f1d:	e8 b9 09 00 00       	call   8078db <ntohs>
  806f22:	83 c4 10             	add    $0x10,%esp
  806f25:	66 a9 ff 1f          	test   $0x1fff,%ax
  806f29:	0f 84 4b 01 00 00    	je     80707a <ip_reass+0x23c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806f2f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806f33:	66 01 05 dc 59 b3 00 	add    %ax,0xb359dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806f3a:	83 ec 0c             	sub    $0xc,%esp
  806f3d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806f41:	50                   	push   %eax
  806f42:	e8 94 09 00 00       	call   8078db <ntohs>
  806f47:	83 c4 10             	add    $0x10,%esp
  806f4a:	f6 c4 20             	test   $0x20,%ah
  806f4d:	75 20                	jne    806f6f <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806f4f:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806f53:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806f57:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806f5b:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806f5e:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806f62:	66 c1 ea 06          	shr    $0x6,%dx
  806f66:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806f69:	29 d0                	sub    %edx,%eax
  806f6b:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806f6f:	8b 45 08             	mov    0x8(%ebp),%eax
  806f72:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806f75:	83 ec 0c             	sub    $0xc,%esp
  806f78:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806f7c:	50                   	push   %eax
  806f7d:	e8 59 09 00 00       	call   8078db <ntohs>
  806f82:	89 c6                	mov    %eax,%esi
  806f84:	0f b7 03             	movzwl (%ebx),%eax
  806f87:	89 04 24             	mov    %eax,(%esp)
  806f8a:	e8 4c 09 00 00       	call   8078db <ntohs>
  806f8f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806f93:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806f97:	89 04 24             	mov    %eax,(%esp)
  806f9a:	e8 3c 09 00 00       	call   8078db <ntohs>
  806f9f:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806fa6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806fa9:	8b 51 04             	mov    0x4(%ecx),%edx
  806fac:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806faf:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806fb5:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806fb9:	01 de                	add    %ebx,%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806fbb:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806fbf:	66 c1 e8 06          	shr    $0x6,%ax
  806fc3:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806fc6:	29 c6                	sub    %eax,%esi
  806fc8:	66 89 75 de          	mov    %si,-0x22(%ebp)
  806fcc:	66 89 72 06          	mov    %si,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806fd0:	8b 47 04             	mov    0x4(%edi),%eax
  806fd3:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806fd6:	83 c4 10             	add    $0x10,%esp
  int valid = 1;
  806fd9:	b9 01 00 00 00       	mov    $0x1,%ecx
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806fde:	be 00 00 00 00       	mov    $0x0,%esi
  806fe3:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806fe6:	89 cf                	mov    %ecx,%edi
  806fe8:	e9 25 01 00 00       	jmp    807112 <ip_reass+0x2d4>
  806fed:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806ff0:	83 ec 0c             	sub    $0xc,%esp
  806ff3:	6a 05                	push   $0x5
  806ff5:	e8 57 d6 ff ff       	call   804651 <memp_malloc>
  806ffa:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806ffc:	83 c4 10             	add    $0x10,%esp
  806fff:	85 c0                	test   %eax,%eax
  807001:	74 35                	je     807038 <ip_reass+0x1fa>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807003:	83 ec 04             	sub    $0x4,%esp
  807006:	6a 20                	push   $0x20
  807008:	6a 00                	push   $0x0
  80700a:	57                   	push   %edi
  80700b:	e8 94 81 00 00       	call   80f1a4 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  807010:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  807014:	a1 e0 59 b3 00       	mov    0xb359e0,%eax
  807019:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  80701b:	89 3d e0 59 b3 00    	mov    %edi,0xb359e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  807021:	83 c4 0c             	add    $0xc,%esp
  807024:	6a 14                	push   $0x14
  807026:	53                   	push   %ebx
  807027:	8d 47 08             	lea    0x8(%edi),%eax
  80702a:	50                   	push   %eax
  80702b:	e8 1e 82 00 00       	call   80f24e <memcpy>
  807030:	83 c4 10             	add    $0x10,%esp
  807033:	e9 f7 fe ff ff       	jmp    806f2f <ip_reass+0xf1>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  807038:	89 f2                	mov    %esi,%edx
  80703a:	89 d8                	mov    %ebx,%eax
  80703c:	e8 2e fd ff ff       	call   806d6f <ip_reass_remove_oldest_datagram>
  807041:	39 c6                	cmp    %eax,%esi
  807043:	7e 20                	jle    807065 <ip_reass+0x227>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  807045:	83 ec 0c             	sub    $0xc,%esp
  807048:	ff 75 08             	pushl  0x8(%ebp)
  80704b:	e8 a4 d9 ff ff       	call   8049f4 <pbuf_free>
  return NULL;
  807050:	83 c4 10             	add    $0x10,%esp
  807053:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80705a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80705d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807060:	5b                   	pop    %ebx
  807061:	5e                   	pop    %esi
  807062:	5f                   	pop    %edi
  807063:	5d                   	pop    %ebp
  807064:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  807065:	83 ec 0c             	sub    $0xc,%esp
  807068:	6a 05                	push   $0x5
  80706a:	e8 e2 d5 ff ff       	call   804651 <memp_malloc>
  80706f:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  807071:	83 c4 10             	add    $0x10,%esp
  807074:	85 c0                	test   %eax,%eax
  807076:	75 8b                	jne    807003 <ip_reass+0x1c5>
  807078:	eb cb                	jmp    807045 <ip_reass+0x207>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80707a:	83 ec 0c             	sub    $0xc,%esp
  80707d:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  807081:	50                   	push   %eax
  807082:	e8 54 08 00 00       	call   8078db <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  807087:	83 c4 10             	add    $0x10,%esp
  80708a:	66 a9 ff 1f          	test   $0x1fff,%ax
  80708e:	0f 84 9b fe ff ff    	je     806f2f <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  807094:	83 ec 04             	sub    $0x4,%esp
  807097:	6a 14                	push   $0x14
  807099:	53                   	push   %ebx
  80709a:	8d 47 08             	lea    0x8(%edi),%eax
  80709d:	50                   	push   %eax
  80709e:	e8 ab 81 00 00       	call   80f24e <memcpy>
  8070a3:	83 c4 10             	add    $0x10,%esp
  8070a6:	e9 84 fe ff ff       	jmp    806f2f <ip_reass+0xf1>
  8070ab:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8070ae:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  8070b1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8070b4:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  8070b6:	85 f6                	test   %esi,%esi
  8070b8:	74 4c                	je     807106 <ip_reass+0x2c8>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  8070ba:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  8070be:	0f 82 c5 01 00 00    	jb     807289 <ip_reass+0x44b>
  8070c4:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  8070c8:	66 3b 42 04          	cmp    0x4(%edx),%ax
  8070cc:	0f 87 b7 01 00 00    	ja     807289 <ip_reass+0x44b>
        iprh_prev->next_pbuf = new_p;
  8070d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8070d5:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  8070d7:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  8070db:	0f 84 cb 01 00 00    	je     8072ac <ip_reass+0x46e>
    if (valid) {
  8070e1:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  8070e5:	0f 84 c1 01 00 00    	je     8072ac <ip_reass+0x46e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  8070eb:	8b 4f 04             	mov    0x4(%edi),%ecx
  8070ee:	8b 59 04             	mov    0x4(%ecx),%ebx
  8070f1:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  8070f6:	0f 85 b0 01 00 00    	jne    8072ac <ip_reass+0x46e>
        q = iprh->next_pbuf;
  8070fc:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8070ff:	8b 16                	mov    (%esi),%edx
  807101:	e9 85 00 00 00       	jmp    80718b <ip_reass+0x34d>
        ipr->p = new_p;
  807106:	8b 45 08             	mov    0x8(%ebp),%eax
  807109:	89 47 04             	mov    %eax,0x4(%edi)
  80710c:	eb c9                	jmp    8070d7 <ip_reass+0x299>
    q = iprh_tmp->next_pbuf;
  80710e:	8b 02                	mov    (%edx),%eax
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  807110:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  807112:	85 c0                	test   %eax,%eax
  807114:	0f 84 c8 01 00 00    	je     8072e2 <ip_reass+0x4a4>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80711a:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  80711d:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  807121:	66 39 cb             	cmp    %cx,%bx
  807124:	72 85                	jb     8070ab <ip_reass+0x26d>
    } else if(iprh->start == iprh_tmp->start) {
  807126:	0f 84 5d 01 00 00    	je     807289 <ip_reass+0x44b>
    } else if(iprh->start < iprh_tmp->end) {
  80712c:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  807130:	0f 82 53 01 00 00    	jb     807289 <ip_reass+0x44b>
      if (iprh_prev != NULL) {
  807136:	85 f6                	test   %esi,%esi
  807138:	74 d4                	je     80710e <ip_reass+0x2d0>
          valid = 0;
  80713a:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  80713e:	b8 00 00 00 00       	mov    $0x0,%eax
  807143:	0f 45 f8             	cmovne %eax,%edi
  807146:	eb c6                	jmp    80710e <ip_reass+0x2d0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807148:	83 ec 04             	sub    $0x4,%esp
  80714b:	68 40 26 81 00       	push   $0x812640
  807150:	68 83 01 00 00       	push   $0x183
  807155:	68 ea 25 81 00       	push   $0x8125ea
  80715a:	e8 aa 76 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80715f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  807163:	75 0b                	jne    807170 <ip_reass+0x332>
      ipr->p = new_p;
  807165:	8b 45 08             	mov    0x8(%ebp),%eax
  807168:	89 47 04             	mov    %eax,0x4(%edi)
  80716b:	e9 67 ff ff ff       	jmp    8070d7 <ip_reass+0x299>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807170:	83 ec 04             	sub    $0x4,%esp
  807173:	68 6c 26 81 00       	push   $0x81266c
  807178:	68 8c 01 00 00       	push   $0x18c
  80717d:	68 ea 25 81 00       	push   $0x8125ea
  807182:	e8 82 76 00 00       	call   80e809 <_panic>
          q = iprh->next_pbuf;
  807187:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  807189:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  80718b:	85 d2                	test   %edx,%edx
  80718d:	74 12                	je     8071a1 <ip_reass+0x363>
          iprh = (struct ip_reass_helper*)q->payload;
  80718f:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  807192:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  807196:	66 39 56 06          	cmp    %dx,0x6(%esi)
  80719a:	74 eb                	je     807187 <ip_reass+0x349>
  80719c:	e9 0b 01 00 00       	jmp    8072ac <ip_reass+0x46e>
  8071a1:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  8071a4:	39 f3                	cmp    %esi,%ebx
  8071a6:	0f 84 98 00 00 00    	je     807244 <ip_reass+0x406>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8071ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8071af:	83 38 00             	cmpl   $0x0,(%eax)
  8071b2:	0f 85 a3 00 00 00    	jne    80725b <ip_reass+0x41d>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  8071b8:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8071bc:	8b 75 e0             	mov    -0x20(%ebp),%esi
  8071bf:	66 39 46 06          	cmp    %ax,0x6(%esi)
  8071c3:	0f 85 a9 00 00 00    	jne    807272 <ip_reass+0x434>
    ipr->datagram_len += IP_HLEN;
  8071c9:	83 c0 14             	add    $0x14,%eax
  8071cc:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  8071d0:	8b 71 04             	mov    0x4(%ecx),%esi
  8071d3:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  8071d5:	83 ec 04             	sub    $0x4,%esp
  8071d8:	6a 14                	push   $0x14
  8071da:	8d 47 08             	lea    0x8(%edi),%eax
  8071dd:	50                   	push   %eax
  8071de:	56                   	push   %esi
  8071df:	e8 6a 80 00 00       	call   80f24e <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  8071e4:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8071e8:	89 04 24             	mov    %eax,(%esp)
  8071eb:	e8 de 06 00 00       	call   8078ce <htons>
  8071f0:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  8071f4:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  8071fa:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807200:	83 c4 08             	add    $0x8,%esp
  807203:	6a 14                	push   $0x14
  807205:	56                   	push   %esi
  807206:	e8 95 05 00 00       	call   8077a0 <inet_chksum>
  80720b:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  80720f:	8b 47 04             	mov    0x4(%edi),%eax
  807212:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  807215:	83 c4 10             	add    $0x10,%esp
  807218:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80721b:	89 c7                	mov    %eax,%edi
  80721d:	85 db                	test   %ebx,%ebx
  80721f:	0f 84 93 00 00 00    	je     8072b8 <ip_reass+0x47a>
      iprh = (struct ip_reass_helper*)r->payload;
  807225:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  807228:	83 ec 08             	sub    $0x8,%esp
  80722b:	6a ec                	push   $0xffffffec
  80722d:	53                   	push   %ebx
  80722e:	e8 f4 d6 ff ff       	call   804927 <pbuf_header>
      pbuf_cat(p, r);
  807233:	83 c4 08             	add    $0x8,%esp
  807236:	53                   	push   %ebx
  807237:	57                   	push   %edi
  807238:	e8 2a dc ff ff       	call   804e67 <pbuf_cat>
      r = iprh->next_pbuf;
  80723d:	8b 1e                	mov    (%esi),%ebx
  80723f:	83 c4 10             	add    $0x10,%esp
  807242:	eb d9                	jmp    80721d <ip_reass+0x3df>
          LWIP_ASSERT("sanity check",
  807244:	83 ec 04             	sub    $0x4,%esp
  807247:	68 5e 26 81 00       	push   $0x81265e
  80724c:	68 ae 01 00 00       	push   $0x1ae
  807251:	68 ea 25 81 00       	push   $0x8125ea
  807256:	e8 ae 75 00 00       	call   80e809 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80725b:	83 ec 04             	sub    $0x4,%esp
  80725e:	68 a4 26 81 00       	push   $0x8126a4
  807263:	68 b0 01 00 00       	push   $0x1b0
  807268:	68 ea 25 81 00       	push   $0x8125ea
  80726d:	e8 97 75 00 00       	call   80e809 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807272:	83 ec 04             	sub    $0x4,%esp
  807275:	68 c8 26 81 00       	push   $0x8126c8
  80727a:	68 b2 01 00 00       	push   $0x1b2
  80727f:	68 ea 25 81 00       	push   $0x8125ea
  807284:	e8 80 75 00 00       	call   80e809 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807289:	83 ec 0c             	sub    $0xc,%esp
  80728c:	ff 75 08             	pushl  0x8(%ebp)
  80728f:	e8 aa db ff ff       	call   804e3e <pbuf_clen>
  807294:	0f b6 c0             	movzbl %al,%eax
  807297:	66 29 05 dc 59 b3 00 	sub    %ax,0xb359dc
  pbuf_free(new_p);
  80729e:	83 c4 04             	add    $0x4,%esp
  8072a1:	ff 75 08             	pushl  0x8(%ebp)
  8072a4:	e8 4b d7 ff ff       	call   8049f4 <pbuf_free>
  8072a9:	83 c4 10             	add    $0x10,%esp
  return NULL;
  8072ac:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8072b3:	e9 a2 fd ff ff       	jmp    80705a <ip_reass+0x21c>
  8072b8:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  8072bb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8072be:	89 f8                	mov    %edi,%eax
  8072c0:	e8 4e f9 ff ff       	call   806c13 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  8072c5:	83 ec 0c             	sub    $0xc,%esp
  8072c8:	ff 75 e4             	pushl  -0x1c(%ebp)
  8072cb:	e8 6e db ff ff       	call   804e3e <pbuf_clen>
  8072d0:	0f b6 c0             	movzbl %al,%eax
  8072d3:	66 29 05 dc 59 b3 00 	sub    %ax,0xb359dc
    return p;
  8072da:	83 c4 10             	add    $0x10,%esp
  8072dd:	e9 78 fd ff ff       	jmp    80705a <ip_reass+0x21c>
  8072e2:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8072e5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  8072e8:	85 f6                	test   %esi,%esi
  8072ea:	0f 84 6f fe ff ff    	je     80715f <ip_reass+0x321>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  8072f0:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  8072f4:	66 39 c3             	cmp    %ax,%bx
  8072f7:	0f 82 4b fe ff ff    	jb     807148 <ip_reass+0x30a>
      iprh_prev->next_pbuf = new_p;
  8072fd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807300:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807302:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807305:	66 3b 46 04          	cmp    0x4(%esi),%ax
  807309:	75 a1                	jne    8072ac <ip_reass+0x46e>
  80730b:	e9 c7 fd ff ff       	jmp    8070d7 <ip_reass+0x299>

00807310 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  807310:	55                   	push   %ebp
  807311:	89 e5                	mov    %esp,%ebp
  807313:	57                   	push   %edi
  807314:	56                   	push   %esi
  807315:	53                   	push   %ebx
  807316:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  807319:	8b 45 0c             	mov    0xc(%ebp),%eax
  80731c:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  807320:	6a 02                	push   $0x2
  807322:	6a 00                	push   $0x0
  807324:	6a 02                	push   $0x2
  807326:	e8 8f d7 ff ff       	call   804aba <pbuf_alloc>
  80732b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  80732e:	83 c4 10             	add    $0x10,%esp
  807331:	85 c0                	test   %eax,%eax
  807333:	0f 84 c2 00 00 00    	je     8073fb <ip_frag+0xeb>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  807339:	66 89 70 0a          	mov    %si,0xa(%eax)
  80733d:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807341:	bb 03 54 b3 00       	mov    $0xb35403,%ebx
  807346:	83 e3 fc             	and    $0xfffffffc,%ebx
  807349:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80734c:	83 ec 04             	sub    $0x4,%esp
  80734f:	6a 14                	push   $0x14
  807351:	8b 45 08             	mov    0x8(%ebp),%eax
  807354:	ff 70 04             	pushl  0x4(%eax)
  807357:	53                   	push   %ebx
  807358:	e8 f1 7e 00 00       	call   80f24e <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80735d:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  807361:	89 04 24             	mov    %eax,(%esp)
  807364:	e8 72 05 00 00       	call   8078db <ntohs>
  ofo = tmp & IP_OFFMASK;
  807369:	89 c7                	mov    %eax,%edi
  80736b:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807370:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  807374:	66 25 00 20          	and    $0x2000,%ax
  807378:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  80737c:	8b 45 08             	mov    0x8(%ebp),%eax
  80737f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807383:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  807386:	0f b7 f6             	movzwl %si,%esi
  807389:	8d 46 f3             	lea    -0xd(%esi),%eax
  80738c:	83 c4 10             	add    $0x10,%esp
  80738f:	89 f2                	mov    %esi,%edx
  807391:	83 ea 14             	sub    $0x14,%edx
  807394:	0f 49 c2             	cmovns %edx,%eax
  807397:	c1 f8 03             	sar    $0x3,%eax
  80739a:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80739e:	c1 e0 03             	shl    $0x3,%eax
  8073a1:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8073a5:	0f b7 c8             	movzwl %ax,%ecx
  8073a8:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8073ab:	83 c0 14             	add    $0x14,%eax
  8073ae:	0f b7 c0             	movzwl %ax,%eax
  8073b1:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  8073b4:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  8073ba:	8d 46 ed             	lea    -0x13(%esi),%eax
  8073bd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8073c0:	8d 43 14             	lea    0x14(%ebx),%eax
  8073c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  8073c6:	e9 e3 00 00 00       	jmp    8074ae <ip_frag+0x19e>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  8073cb:	83 ec 0c             	sub    $0xc,%esp
  8073ce:	ff 75 dc             	pushl  -0x24(%ebp)
  8073d1:	e8 1e d6 ff ff       	call   8049f4 <pbuf_free>
      return ERR_MEM;
  8073d6:	83 c4 10             	add    $0x10,%esp
  8073d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8073de:	eb 13                	jmp    8073f3 <ip_frag+0xe3>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8073e0:	83 ec 0c             	sub    $0xc,%esp
  8073e3:	ff 75 dc             	pushl  -0x24(%ebp)
  8073e6:	e8 09 d6 ff ff       	call   8049f4 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8073eb:	83 c4 10             	add    $0x10,%esp
  8073ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8073f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8073f6:	5b                   	pop    %ebx
  8073f7:	5e                   	pop    %esi
  8073f8:	5f                   	pop    %edi
  8073f9:	5d                   	pop    %ebp
  8073fa:	c3                   	ret    
    return ERR_MEM;
  8073fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807400:	eb f1                	jmp    8073f3 <ip_frag+0xe3>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807402:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  807406:	52                   	push   %edx
  807407:	50                   	push   %eax
  807408:	ff 75 d4             	pushl  -0x2c(%ebp)
  80740b:	ff 75 08             	pushl  0x8(%ebp)
  80740e:	e8 5d dd ff ff       	call   805170 <pbuf_copy_partial>
  807413:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807417:	0f b7 f6             	movzwl %si,%esi
  80741a:	89 34 24             	mov    %esi,(%esp)
  80741d:	e8 ac 04 00 00       	call   8078ce <htons>
  807422:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807426:	8d 77 14             	lea    0x14(%edi),%esi
  807429:	0f b7 f6             	movzwl %si,%esi
  80742c:	89 34 24             	mov    %esi,(%esp)
  80742f:	e8 9a 04 00 00       	call   8078ce <htons>
  807434:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807438:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80743e:	83 c4 08             	add    $0x8,%esp
  807441:	6a 14                	push   $0x14
  807443:	53                   	push   %ebx
  807444:	e8 57 03 00 00       	call   8077a0 <inet_chksum>
  807449:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      pbuf_realloc(rambuf, left + IP_HLEN);
  80744d:	83 c4 08             	add    $0x8,%esp
  807450:	56                   	push   %esi
  807451:	ff 75 dc             	pushl  -0x24(%ebp)
  807454:	e8 d3 d8 ff ff       	call   804d2c <pbuf_realloc>
  807459:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  80745c:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  807460:	83 ec 04             	sub    $0x4,%esp
  807463:	6a 00                	push   $0x0
  807465:	6a 00                	push   $0x0
  807467:	6a 02                	push   $0x2
  807469:	e8 4c d6 ff ff       	call   804aba <pbuf_alloc>
  80746e:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  807470:	83 c4 10             	add    $0x10,%esp
  807473:	85 c0                	test   %eax,%eax
  807475:	0f 84 50 ff ff ff    	je     8073cb <ip_frag+0xbb>
      pbuf_chain(header, rambuf);
  80747b:	83 ec 08             	sub    $0x8,%esp
  80747e:	ff 75 dc             	pushl  -0x24(%ebp)
  807481:	50                   	push   %eax
  807482:	e8 4e da ff ff       	call   804ed5 <pbuf_chain>
      netif->output(netif, header, dest);
  807487:	83 c4 0c             	add    $0xc,%esp
  80748a:	ff 75 10             	pushl  0x10(%ebp)
  80748d:	56                   	push   %esi
  80748e:	ff 75 0c             	pushl  0xc(%ebp)
  807491:	8b 45 0c             	mov    0xc(%ebp),%eax
  807494:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  807497:	89 34 24             	mov    %esi,(%esp)
  80749a:	e8 55 d5 ff ff       	call   8049f4 <pbuf_free>
    left -= cop;
  80749f:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  8074a3:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  8074a7:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  8074ab:	83 c4 10             	add    $0x10,%esp
  while (left) {
  8074ae:	66 85 ff             	test   %di,%di
  8074b1:	0f 84 29 ff ff ff    	je     8073e0 <ip_frag+0xd0>
    last = (left <= mtu - IP_HLEN);
  8074b7:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  8074ba:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  8074be:	66 81 e6 ff 1f       	and    $0x1fff,%si
  8074c3:	66 0b 75 e0          	or     -0x20(%ebp),%si
    if (!last)
  8074c7:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8074ca:	0f 8f 32 ff ff ff    	jg     807402 <ip_frag+0xf2>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8074d0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8074d4:	50                   	push   %eax
  8074d5:	ff 75 cc             	pushl  -0x34(%ebp)
  8074d8:	ff 75 d4             	pushl  -0x2c(%ebp)
  8074db:	ff 75 08             	pushl  0x8(%ebp)
  8074de:	e8 8d dc ff ff       	call   805170 <pbuf_copy_partial>
  8074e3:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  8074e7:	66 81 ce 00 20       	or     $0x2000,%si
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8074ec:	0f b7 f6             	movzwl %si,%esi
  8074ef:	89 34 24             	mov    %esi,(%esp)
  8074f2:	e8 d7 03 00 00       	call   8078ce <htons>
  8074f7:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8074fb:	83 c4 04             	add    $0x4,%esp
  8074fe:	ff 75 c8             	pushl  -0x38(%ebp)
  807501:	e8 c8 03 00 00       	call   8078ce <htons>
  807506:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  80750a:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  807510:	83 c4 08             	add    $0x8,%esp
  807513:	6a 14                	push   $0x14
  807515:	53                   	push   %ebx
  807516:	e8 85 02 00 00       	call   8077a0 <inet_chksum>
  80751b:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  80751f:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  807522:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  807526:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  80752a:	e9 31 ff ff ff       	jmp    807460 <ip_frag+0x150>

0080752f <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80752f:	55                   	push   %ebp
  807530:	89 e5                	mov    %esp,%ebp
  807532:	57                   	push   %edi
  807533:	56                   	push   %esi
  807534:	53                   	push   %ebx
  807535:	83 ec 1c             	sub    $0x1c,%esp
  807538:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80753b:	89 d7                	mov    %edx,%edi
  80753d:	66 d1 ef             	shr    %di
  807540:	0f b7 d7             	movzwl %di,%edx
  807543:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  807546:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80754b:	39 f0                	cmp    %esi,%eax
  80754d:	74 18                	je     807567 <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80754f:	0f b6 10             	movzbl (%eax),%edx
  807552:	89 d1                	mov    %edx,%ecx
  807554:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  807557:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80755b:	09 ca                	or     %ecx,%edx
  80755d:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  807560:	0f b7 d2             	movzwl %dx,%edx
  807563:	01 d3                	add    %edx,%ebx
  807565:	eb e4                	jmp    80754b <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  807567:	01 ff                	add    %edi,%edi
  807569:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  80756d:	74 0b                	je     80757a <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80756f:	0f b6 00             	movzbl (%eax),%eax
  807572:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807575:	0f b7 c0             	movzwl %ax,%eax
  807578:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80757a:	89 d8                	mov    %ebx,%eax
  80757c:	c1 e8 10             	shr    $0x10,%eax
  80757f:	0f b7 db             	movzwl %bx,%ebx
  807582:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807584:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  80758a:	74 0a                	je     807596 <lwip_standard_chksum+0x67>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80758c:	89 d8                	mov    %ebx,%eax
  80758e:	c1 e8 10             	shr    $0x10,%eax
  807591:	0f b7 db             	movzwl %bx,%ebx
  807594:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807596:	83 ec 0c             	sub    $0xc,%esp
  807599:	0f b7 db             	movzwl %bx,%ebx
  80759c:	53                   	push   %ebx
  80759d:	e8 2c 03 00 00       	call   8078ce <htons>
}
  8075a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8075a5:	5b                   	pop    %ebx
  8075a6:	5e                   	pop    %esi
  8075a7:	5f                   	pop    %edi
  8075a8:	5d                   	pop    %ebp
  8075a9:	c3                   	ret    

008075aa <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  8075aa:	55                   	push   %ebp
  8075ab:	89 e5                	mov    %esp,%ebp
  8075ad:	57                   	push   %edi
  8075ae:	56                   	push   %esi
  8075af:	53                   	push   %ebx
  8075b0:	83 ec 1c             	sub    $0x1c,%esp
  8075b3:	8b 75 08             	mov    0x8(%ebp),%esi
  8075b6:	8b 45 14             	mov    0x14(%ebp),%eax
  8075b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8075bc:	8b 45 18             	mov    0x18(%ebp),%eax
  8075bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8075c2:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8075c7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8075cc:	89 f8                	mov    %edi,%eax
  8075ce:	89 df                	mov    %ebx,%edi
  8075d0:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8075d2:	eb 02                	jmp    8075d6 <inet_chksum_pseudo+0x2c>
  8075d4:	8b 36                	mov    (%esi),%esi
  8075d6:	85 f6                	test   %esi,%esi
  8075d8:	74 3d                	je     807617 <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  8075da:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8075de:	8b 46 04             	mov    0x4(%esi),%eax
  8075e1:	e8 49 ff ff ff       	call   80752f <lwip_standard_chksum>
  8075e6:	0f b7 c0             	movzwl %ax,%eax
  8075e9:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  8075eb:	89 c7                	mov    %eax,%edi
  8075ed:	c1 ef 10             	shr    $0x10,%edi
  8075f0:	0f b7 c0             	movzwl %ax,%eax
  8075f3:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  8075f5:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8075f9:	74 d9                	je     8075d4 <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  8075fb:	b8 01 00 00 00       	mov    $0x1,%eax
  807600:	29 d8                	sub    %ebx,%eax
  807602:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  807604:	89 fa                	mov    %edi,%edx
  807606:	c1 e2 08             	shl    $0x8,%edx
  807609:	0f b7 d2             	movzwl %dx,%edx
  80760c:	89 f8                	mov    %edi,%eax
  80760e:	0f b6 c4             	movzbl %ah,%eax
  807611:	09 c2                	or     %eax,%edx
  807613:	89 d7                	mov    %edx,%edi
  807615:	eb bd                	jmp    8075d4 <inet_chksum_pseudo+0x2a>
  807617:	89 d8                	mov    %ebx,%eax
  807619:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80761b:	84 c0                	test   %al,%al
  80761d:	74 0d                	je     80762c <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  80761f:	89 f8                	mov    %edi,%eax
  807621:	c1 e0 08             	shl    $0x8,%eax
  807624:	0f b7 c0             	movzwl %ax,%eax
  807627:	0f b6 df             	movzbl %bh,%ebx
  80762a:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  80762c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80762f:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807631:	8b 55 10             	mov    0x10(%ebp),%edx
  807634:	8b 12                	mov    (%edx),%edx
  807636:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807639:	c1 ea 10             	shr    $0x10,%edx
  80763c:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  80763e:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807641:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  807643:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807646:	01 d0                	add    %edx,%eax
  807648:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  80764a:	83 ec 0c             	sub    $0xc,%esp
  80764d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807651:	50                   	push   %eax
  807652:	e8 77 02 00 00       	call   8078ce <htons>
  807657:	0f b7 c0             	movzwl %ax,%eax
  80765a:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80765c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807660:	89 04 24             	mov    %eax,(%esp)
  807663:	e8 66 02 00 00       	call   8078ce <htons>
  807668:	0f b7 c0             	movzwl %ax,%eax
  80766b:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80766d:	89 d8                	mov    %ebx,%eax
  80766f:	c1 e8 10             	shr    $0x10,%eax
  807672:	0f b7 db             	movzwl %bx,%ebx
  807675:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807677:	89 d8                	mov    %ebx,%eax
  807679:	c1 e8 10             	shr    $0x10,%eax
  80767c:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80767e:	f7 d0                	not    %eax
}
  807680:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807683:	5b                   	pop    %ebx
  807684:	5e                   	pop    %esi
  807685:	5f                   	pop    %edi
  807686:	5d                   	pop    %ebp
  807687:	c3                   	ret    

00807688 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807688:	55                   	push   %ebp
  807689:	89 e5                	mov    %esp,%ebp
  80768b:	57                   	push   %edi
  80768c:	56                   	push   %esi
  80768d:	53                   	push   %ebx
  80768e:	83 ec 1c             	sub    $0x1c,%esp
  807691:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807694:	8b 45 14             	mov    0x14(%ebp),%eax
  807697:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80769a:	8b 45 18             	mov    0x18(%ebp),%eax
  80769d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  8076a0:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  8076a4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  8076a8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8076af:	eb 19                	jmp    8076ca <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8076b1:	83 ec 04             	sub    $0x4,%esp
  8076b4:	68 f5 26 81 00       	push   $0x8126f5
  8076b9:	68 60 01 00 00       	push   $0x160
  8076be:	68 00 27 81 00       	push   $0x812700
  8076c3:	e8 41 71 00 00       	call   80e809 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8076c8:	8b 1b                	mov    (%ebx),%ebx
  8076ca:	85 db                	test   %ebx,%ebx
  8076cc:	74 5c                	je     80772a <inet_chksum_pseudo_partial+0xa2>
  8076ce:	66 85 f6             	test   %si,%si
  8076d1:	74 57                	je     80772a <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  8076d3:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  8076d7:	66 39 fe             	cmp    %di,%si
  8076da:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  8076dd:	0f b7 d7             	movzwl %di,%edx
  8076e0:	8b 43 04             	mov    0x4(%ebx),%eax
  8076e3:	e8 47 fe ff ff       	call   80752f <lwip_standard_chksum>
  8076e8:	0f b7 c0             	movzwl %ax,%eax
  8076eb:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  8076ee:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  8076f0:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  8076f5:	77 ba                	ja     8076b1 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  8076f7:	89 c2                	mov    %eax,%edx
  8076f9:	c1 ea 10             	shr    $0x10,%edx
  8076fc:	0f b7 c0             	movzwl %ax,%eax
  8076ff:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  807702:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807705:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807709:	74 bd                	je     8076c8 <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  80770b:	b8 01 00 00 00       	mov    $0x1,%eax
  807710:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807713:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807716:	89 fa                	mov    %edi,%edx
  807718:	c1 e2 08             	shl    $0x8,%edx
  80771b:	0f b7 d2             	movzwl %dx,%edx
  80771e:	89 f8                	mov    %edi,%eax
  807720:	0f b6 c4             	movzbl %ah,%eax
  807723:	09 c2                	or     %eax,%edx
  807725:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  807728:	eb 9e                	jmp    8076c8 <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80772a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80772e:	74 13                	je     807743 <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  807730:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807733:	89 c8                	mov    %ecx,%eax
  807735:	c1 e0 08             	shl    $0x8,%eax
  807738:	0f b7 c0             	movzwl %ax,%eax
  80773b:	0f b6 d5             	movzbl %ch,%edx
  80773e:	09 d0                	or     %edx,%eax
  807740:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807743:	8b 45 0c             	mov    0xc(%ebp),%eax
  807746:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807748:	8b 45 10             	mov    0x10(%ebp),%eax
  80774b:	8b 00                	mov    (%eax),%eax
  80774d:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807750:	c1 e8 10             	shr    $0x10,%eax
  807753:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  807755:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  807758:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  80775a:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80775d:	01 c3                	add    %eax,%ebx
  80775f:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  807762:	83 ec 0c             	sub    $0xc,%esp
  807765:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807769:	50                   	push   %eax
  80776a:	e8 5f 01 00 00       	call   8078ce <htons>
  80776f:	0f b7 f0             	movzwl %ax,%esi
  807772:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  807774:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807778:	89 04 24             	mov    %eax,(%esp)
  80777b:	e8 4e 01 00 00       	call   8078ce <htons>
  807780:	0f b7 d8             	movzwl %ax,%ebx
  807783:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807785:	89 d8                	mov    %ebx,%eax
  807787:	c1 e8 10             	shr    $0x10,%eax
  80778a:	0f b7 db             	movzwl %bx,%ebx
  80778d:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80778f:	89 d8                	mov    %ebx,%eax
  807791:	c1 e8 10             	shr    $0x10,%eax
  807794:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807796:	f7 d0                	not    %eax
}
  807798:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80779b:	5b                   	pop    %ebx
  80779c:	5e                   	pop    %esi
  80779d:	5f                   	pop    %edi
  80779e:	5d                   	pop    %ebp
  80779f:	c3                   	ret    

008077a0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  8077a0:	55                   	push   %ebp
  8077a1:	89 e5                	mov    %esp,%ebp
  8077a3:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  8077a6:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  8077aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8077ad:	e8 7d fd ff ff       	call   80752f <lwip_standard_chksum>
  8077b2:	f7 d0                	not    %eax
}
  8077b4:	c9                   	leave  
  8077b5:	c3                   	ret    

008077b6 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8077b6:	55                   	push   %ebp
  8077b7:	89 e5                	mov    %esp,%ebp
  8077b9:	57                   	push   %edi
  8077ba:	56                   	push   %esi
  8077bb:	53                   	push   %ebx
  8077bc:	83 ec 0c             	sub    $0xc,%esp
  8077bf:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  8077c2:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  8077c7:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  8077cc:	eb 02                	jmp    8077d0 <inet_chksum_pbuf+0x1a>
  8077ce:	8b 36                	mov    (%esi),%esi
  8077d0:	85 f6                	test   %esi,%esi
  8077d2:	74 3b                	je     80780f <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8077d4:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8077d8:	8b 46 04             	mov    0x4(%esi),%eax
  8077db:	e8 4f fd ff ff       	call   80752f <lwip_standard_chksum>
  8077e0:	0f b7 c0             	movzwl %ax,%eax
  8077e3:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  8077e5:	89 d8                	mov    %ebx,%eax
  8077e7:	c1 e8 10             	shr    $0x10,%eax
  8077ea:	0f b7 db             	movzwl %bx,%ebx
  8077ed:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  8077ef:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  8077f3:	74 d9                	je     8077ce <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  8077f5:	b8 01 00 00 00       	mov    $0x1,%eax
  8077fa:	89 f9                	mov    %edi,%ecx
  8077fc:	29 c8                	sub    %ecx,%eax
  8077fe:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807800:	89 da                	mov    %ebx,%edx
  807802:	c1 e2 08             	shl    $0x8,%edx
  807805:	0f b7 d2             	movzwl %dx,%edx
  807808:	0f b6 df             	movzbl %bh,%ebx
  80780b:	09 d3                	or     %edx,%ebx
  80780d:	eb bf                	jmp    8077ce <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  80780f:	89 f8                	mov    %edi,%eax
  807811:	84 c0                	test   %al,%al
  807813:	74 0d                	je     807822 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  807815:	89 da                	mov    %ebx,%edx
  807817:	c1 e2 08             	shl    $0x8,%edx
  80781a:	0f b7 d2             	movzwl %dx,%edx
  80781d:	0f b6 df             	movzbl %bh,%ebx
  807820:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  807822:	89 d8                	mov    %ebx,%eax
  807824:	f7 d0                	not    %eax
}
  807826:	83 c4 0c             	add    $0xc,%esp
  807829:	5b                   	pop    %ebx
  80782a:	5e                   	pop    %esi
  80782b:	5f                   	pop    %edi
  80782c:	5d                   	pop    %ebp
  80782d:	c3                   	ret    

0080782e <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80782e:	55                   	push   %ebp
  80782f:	89 e5                	mov    %esp,%ebp
  807831:	57                   	push   %edi
  807832:	56                   	push   %esi
  807833:	53                   	push   %ebx
  807834:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807837:	8b 45 08             	mov    0x8(%ebp),%eax
  80783a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80783d:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  807841:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  807844:	bf e4 59 b3 00       	mov    $0xb359e4,%edi
  807849:	eb 1a                	jmp    807865 <inet_ntoa+0x37>
  80784b:	0f b6 db             	movzbl %bl,%ebx
  80784e:	01 fb                	add    %edi,%ebx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807850:	8d 7b 01             	lea    0x1(%ebx),%edi
  807853:	c6 03 2e             	movb   $0x2e,(%ebx)
  807856:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  807859:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  80785d:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  807861:	3c 04                	cmp    $0x4,%al
  807863:	74 59                	je     8078be <inet_ntoa+0x90>
  rp = str;
  807865:	ba 00 00 00 00       	mov    $0x0,%edx
      rem = *ap % (u8_t)10;
  80786a:	0f b6 0e             	movzbl (%esi),%ecx
      *ap /= (u8_t)10;
  80786d:	0f b6 d9             	movzbl %cl,%ebx
  807870:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807873:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  807876:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807879:	66 c1 e8 0b          	shr    $0xb,%ax
  80787d:	88 06                	mov    %al,(%esi)
      inv[i++] = '0' + rem;
  80787f:	8d 5a 01             	lea    0x1(%edx),%ebx
  807882:	0f b6 d2             	movzbl %dl,%edx
  807885:	89 55 e0             	mov    %edx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  807888:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80788b:	01 c0                	add    %eax,%eax
  80788d:	89 ca                	mov    %ecx,%edx
  80788f:	29 c2                	sub    %eax,%edx
  807891:	89 d0                	mov    %edx,%eax
      inv[i++] = '0' + rem;
  807893:	83 c0 30             	add    $0x30,%eax
  807896:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807899:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  80789d:	89 da                	mov    %ebx,%edx
    } while(*ap);
  80789f:	80 f9 09             	cmp    $0x9,%cl
  8078a2:	77 c6                	ja     80786a <inet_ntoa+0x3c>
  8078a4:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  8078a6:	89 d8                	mov    %ebx,%eax
    while(i--)
  8078a8:	83 e8 01             	sub    $0x1,%eax
  8078ab:	3c ff                	cmp    $0xff,%al
  8078ad:	74 9c                	je     80784b <inet_ntoa+0x1d>
      *rp++ = inv[i];
  8078af:	0f b6 c8             	movzbl %al,%ecx
  8078b2:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  8078b7:	88 0a                	mov    %cl,(%edx)
  8078b9:	83 c2 01             	add    $0x1,%edx
  8078bc:	eb ea                	jmp    8078a8 <inet_ntoa+0x7a>
    ap++;
  }
  *--rp = 0;
  8078be:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  8078c1:	b8 e4 59 b3 00       	mov    $0xb359e4,%eax
  8078c6:	83 c4 18             	add    $0x18,%esp
  8078c9:	5b                   	pop    %ebx
  8078ca:	5e                   	pop    %esi
  8078cb:	5f                   	pop    %edi
  8078cc:	5d                   	pop    %ebp
  8078cd:	c3                   	ret    

008078ce <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  8078ce:	55                   	push   %ebp
  8078cf:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8078d1:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8078d5:	66 c1 c0 08          	rol    $0x8,%ax
}
  8078d9:	5d                   	pop    %ebp
  8078da:	c3                   	ret    

008078db <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  8078db:	55                   	push   %ebp
  8078dc:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  8078de:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  8078e2:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  8078e6:	5d                   	pop    %ebp
  8078e7:	c3                   	ret    

008078e8 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  8078e8:	55                   	push   %ebp
  8078e9:	89 e5                	mov    %esp,%ebp
  8078eb:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  8078ee:	89 d0                	mov    %edx,%eax
  8078f0:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  8078f3:	89 d1                	mov    %edx,%ecx
  8078f5:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  8078f8:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  8078fa:	89 d1                	mov    %edx,%ecx
  8078fc:	c1 e1 08             	shl    $0x8,%ecx
  8078ff:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  807905:	09 c8                	or     %ecx,%eax
  807907:	c1 ea 08             	shr    $0x8,%edx
  80790a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  807910:	09 d0                	or     %edx,%eax
}
  807912:	5d                   	pop    %ebp
  807913:	c3                   	ret    

00807914 <inet_aton>:
{
  807914:	55                   	push   %ebp
  807915:	89 e5                	mov    %esp,%ebp
  807917:	57                   	push   %edi
  807918:	56                   	push   %esi
  807919:	53                   	push   %ebx
  80791a:	83 ec 2c             	sub    $0x2c,%esp
  80791d:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  807920:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  807923:	8d 75 d8             	lea    -0x28(%ebp),%esi
  807926:	89 75 cc             	mov    %esi,-0x34(%ebp)
  807929:	e9 a7 00 00 00       	jmp    8079d5 <inet_aton+0xc1>
      c = *++cp;
  80792e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807932:	89 d1                	mov    %edx,%ecx
  807934:	83 e1 df             	and    $0xffffffdf,%ecx
  807937:	80 f9 58             	cmp    $0x58,%cl
  80793a:	74 10                	je     80794c <inet_aton+0x38>
      c = *++cp;
  80793c:	83 c0 01             	add    $0x1,%eax
  80793f:	0f be d2             	movsbl %dl,%edx
        base = 8;
  807942:	be 08 00 00 00       	mov    $0x8,%esi
  807947:	e9 a3 00 00 00       	jmp    8079ef <inet_aton+0xdb>
        c = *++cp;
  80794c:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807950:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  807953:	be 10 00 00 00       	mov    $0x10,%esi
  807958:	e9 92 00 00 00       	jmp    8079ef <inet_aton+0xdb>
      } else if (base == 16 && isxdigit(c)) {
  80795d:	83 fe 10             	cmp    $0x10,%esi
  807960:	75 4d                	jne    8079af <inet_aton+0x9b>
  807962:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  807965:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  807968:	89 d1                	mov    %edx,%ecx
  80796a:	83 e1 df             	and    $0xffffffdf,%ecx
  80796d:	83 e9 41             	sub    $0x41,%ecx
  807970:	80 f9 05             	cmp    $0x5,%cl
  807973:	77 3a                	ja     8079af <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807975:	c1 e3 04             	shl    $0x4,%ebx
  807978:	83 c2 0a             	add    $0xa,%edx
  80797b:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80797f:	19 c9                	sbb    %ecx,%ecx
  807981:	83 e1 20             	and    $0x20,%ecx
  807984:	83 c1 41             	add    $0x41,%ecx
  807987:	29 ca                	sub    %ecx,%edx
  807989:	09 d3                	or     %edx,%ebx
        c = *++cp;
  80798b:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  80798e:	0f be 57 01          	movsbl 0x1(%edi),%edx
  807992:	83 c0 01             	add    $0x1,%eax
  807995:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (isdigit(c)) {
  807998:	89 d7                	mov    %edx,%edi
  80799a:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80799d:	80 f9 09             	cmp    $0x9,%cl
  8079a0:	77 bb                	ja     80795d <inet_aton+0x49>
        val = (val * base) + (int)(c - '0');
  8079a2:	0f af de             	imul   %esi,%ebx
  8079a5:	8d 5c 1a d0          	lea    -0x30(%edx,%ebx,1),%ebx
        c = *++cp;
  8079a9:	0f be 50 01          	movsbl 0x1(%eax),%edx
  8079ad:	eb e3                	jmp    807992 <inet_aton+0x7e>
    if (c == '.') {
  8079af:	83 fa 2e             	cmp    $0x2e,%edx
  8079b2:	75 42                	jne    8079f6 <inet_aton+0xe2>
      if (pp >= parts + 3)
  8079b4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8079b7:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8079ba:	39 c6                	cmp    %eax,%esi
  8079bc:	0f 84 0e 01 00 00    	je     807ad0 <inet_aton+0x1bc>
      *pp++ = val;
  8079c2:	83 c6 04             	add    $0x4,%esi
  8079c5:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8079c8:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  8079cb:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8079ce:	8d 46 01             	lea    0x1(%esi),%eax
  8079d1:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  8079d5:	8d 4a d0             	lea    -0x30(%edx),%ecx
  8079d8:	80 f9 09             	cmp    $0x9,%cl
  8079db:	0f 87 e8 00 00 00    	ja     807ac9 <inet_aton+0x1b5>
    base = 10;
  8079e1:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  8079e6:	83 fa 30             	cmp    $0x30,%edx
  8079e9:	0f 84 3f ff ff ff    	je     80792e <inet_aton+0x1a>
    base = 10;
  8079ef:	bb 00 00 00 00       	mov    $0x0,%ebx
  8079f4:	eb 9f                	jmp    807995 <inet_aton+0x81>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8079f6:	85 d2                	test   %edx,%edx
  8079f8:	74 26                	je     807a20 <inet_aton+0x10c>
    return (0);
  8079fa:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  8079ff:	89 f9                	mov    %edi,%ecx
  807a01:	80 f9 1f             	cmp    $0x1f,%cl
  807a04:	0f 86 cb 00 00 00    	jbe    807ad5 <inet_aton+0x1c1>
  807a0a:	84 d2                	test   %dl,%dl
  807a0c:	0f 88 c3 00 00 00    	js     807ad5 <inet_aton+0x1c1>
  807a12:	83 fa 20             	cmp    $0x20,%edx
  807a15:	74 09                	je     807a20 <inet_aton+0x10c>
  807a17:	83 fa 0c             	cmp    $0xc,%edx
  807a1a:	0f 85 b5 00 00 00    	jne    807ad5 <inet_aton+0x1c1>
  n = pp - parts + 1;
  807a20:	8d 45 d8             	lea    -0x28(%ebp),%eax
  807a23:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807a26:	29 c6                	sub    %eax,%esi
  807a28:	89 f0                	mov    %esi,%eax
  807a2a:	c1 f8 02             	sar    $0x2,%eax
  807a2d:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  807a30:	83 f8 02             	cmp    $0x2,%eax
  807a33:	74 5e                	je     807a93 <inet_aton+0x17f>
  807a35:	7e 35                	jle    807a6c <inet_aton+0x158>
  807a37:	83 f8 03             	cmp    $0x3,%eax
  807a3a:	74 6e                	je     807aaa <inet_aton+0x196>
  807a3c:	83 f8 04             	cmp    $0x4,%eax
  807a3f:	75 2f                	jne    807a70 <inet_aton+0x15c>
      return (0);
  807a41:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  807a46:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  807a4c:	0f 87 83 00 00 00    	ja     807ad5 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807a52:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807a55:	c1 e0 18             	shl    $0x18,%eax
  807a58:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807a5b:	c1 e2 10             	shl    $0x10,%edx
  807a5e:	09 d0                	or     %edx,%eax
  807a60:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807a63:	c1 e2 08             	shl    $0x8,%edx
  807a66:	09 d0                	or     %edx,%eax
  807a68:	09 c3                	or     %eax,%ebx
    break;
  807a6a:	eb 04                	jmp    807a70 <inet_aton+0x15c>
  switch (n) {
  807a6c:	85 c0                	test   %eax,%eax
  807a6e:	74 65                	je     807ad5 <inet_aton+0x1c1>
  return (1);
  807a70:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  807a75:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807a79:	74 5a                	je     807ad5 <inet_aton+0x1c1>
    addr->s_addr = htonl(val);
  807a7b:	83 ec 0c             	sub    $0xc,%esp
  807a7e:	53                   	push   %ebx
  807a7f:	e8 64 fe ff ff       	call   8078e8 <htonl>
  807a84:	83 c4 10             	add    $0x10,%esp
  807a87:	8b 75 0c             	mov    0xc(%ebp),%esi
  807a8a:	89 06                	mov    %eax,(%esi)
  return (1);
  807a8c:	b8 01 00 00 00       	mov    $0x1,%eax
  807a91:	eb 42                	jmp    807ad5 <inet_aton+0x1c1>
      return (0);
  807a93:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  807a98:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  807a9e:	77 35                	ja     807ad5 <inet_aton+0x1c1>
    val |= parts[0] << 24;
  807aa0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807aa3:	c1 e0 18             	shl    $0x18,%eax
  807aa6:	09 c3                	or     %eax,%ebx
    break;
  807aa8:	eb c6                	jmp    807a70 <inet_aton+0x15c>
      return (0);
  807aaa:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  807aaf:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  807ab5:	77 1e                	ja     807ad5 <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16);
  807ab7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807aba:	c1 e0 18             	shl    $0x18,%eax
  807abd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807ac0:	c1 e2 10             	shl    $0x10,%edx
  807ac3:	09 d0                	or     %edx,%eax
  807ac5:	09 c3                	or     %eax,%ebx
    break;
  807ac7:	eb a7                	jmp    807a70 <inet_aton+0x15c>
      return (0);
  807ac9:	b8 00 00 00 00       	mov    $0x0,%eax
  807ace:	eb 05                	jmp    807ad5 <inet_aton+0x1c1>
        return (0);
  807ad0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807ad5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807ad8:	5b                   	pop    %ebx
  807ad9:	5e                   	pop    %esi
  807ada:	5f                   	pop    %edi
  807adb:	5d                   	pop    %ebp
  807adc:	c3                   	ret    

00807add <inet_addr>:
{
  807add:	55                   	push   %ebp
  807ade:	89 e5                	mov    %esp,%ebp
  807ae0:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  807ae3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  807ae6:	50                   	push   %eax
  807ae7:	ff 75 08             	pushl  0x8(%ebp)
  807aea:	e8 25 fe ff ff       	call   807914 <inet_aton>
  807aef:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807af2:	85 c0                	test   %eax,%eax
  807af4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807af9:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807afd:	c9                   	leave  
  807afe:	c3                   	ret    

00807aff <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807aff:	55                   	push   %ebp
  807b00:	89 e5                	mov    %esp,%ebp
  807b02:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  807b05:	ff 75 08             	pushl  0x8(%ebp)
  807b08:	e8 db fd ff ff       	call   8078e8 <htonl>
  807b0d:	83 c4 10             	add    $0x10,%esp
}
  807b10:	c9                   	leave  
  807b11:	c3                   	ret    

00807b12 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  807b12:	55                   	push   %ebp
  807b13:	89 e5                	mov    %esp,%ebp
  807b15:	57                   	push   %edi
  807b16:	56                   	push   %esi
  807b17:	53                   	push   %ebx
  807b18:	83 ec 3c             	sub    $0x3c,%esp
  807b1b:	8b 7d 08             	mov    0x8(%ebp),%edi
  807b1e:	8b 75 10             	mov    0x10(%ebp),%esi
  807b21:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  807b24:	8b 55 14             	mov    0x14(%ebp),%edx
  807b27:	89 55 bc             	mov    %edx,-0x44(%ebp)
  807b2a:	8b 5d 18             	mov    0x18(%ebp),%ebx
  807b2d:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  807b30:	8b 45 20             	mov    0x20(%ebp),%eax
  807b33:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  807b37:	88 55 dd             	mov    %dl,-0x23(%ebp)
  807b3a:	89 da                	mov    %ebx,%edx
  807b3c:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807b3f:	66 85 f6             	test   %si,%si
  807b42:	74 04                	je     807b48 <tcp_enqueue+0x36>
  807b44:	84 c0                	test   %al,%al
  807b46:	75 54                	jne    807b9c <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807b48:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807b4c:	74 06                	je     807b54 <tcp_enqueue+0x42>
  807b4e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b52:	75 5f                	jne    807bb3 <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  807b54:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  807b58:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  807b5c:	72 6c                	jb     807bca <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  807b5e:	8b 4f 68             	mov    0x68(%edi),%ecx
  807b61:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  807b64:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  807b68:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b6c:	66 83 f9 1f          	cmp    $0x1f,%cx
  807b70:	77 66                	ja     807bd8 <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807b72:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807b77:	74 6d                	je     807be6 <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807b79:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807b7d:	75 7b                	jne    807bfa <tcp_enqueue+0xe8>
  807b7f:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807b83:	75 75                	jne    807bfa <tcp_enqueue+0xe8>
  807b85:	83 ec 04             	sub    $0x4,%esp
  807b88:	68 ac 27 81 00       	push   $0x8127ac
  807b8d:	68 ae 00 00 00       	push   $0xae
  807b92:	68 c6 28 81 00       	push   $0x8128c6
  807b97:	e8 6d 6c 00 00       	call   80e809 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807b9c:	83 ec 04             	sub    $0x4,%esp
  807b9f:	68 24 27 81 00       	push   $0x812724
  807ba4:	68 90 00 00 00       	push   $0x90
  807ba9:	68 c6 28 81 00       	push   $0x8128c6
  807bae:	e8 56 6c 00 00       	call   80e809 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807bb3:	83 ec 04             	sub    $0x4,%esp
  807bb6:	68 64 27 81 00       	push   $0x812764
  807bbb:	68 92 00 00 00       	push   $0x92
  807bc0:	68 c6 28 81 00       	push   $0x8128c6
  807bc5:	e8 3f 6c 00 00       	call   80e809 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807bca:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807bce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807bd3:	e9 a4 03 00 00       	jmp    807f7c <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  807bd8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807bdc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807be1:	e9 96 03 00 00       	jmp    807f7c <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807be6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807bea:	0f 85 05 02 00 00    	jne    807df5 <tcp_enqueue+0x2e3>
  807bf0:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807bf4:	0f 85 fb 01 00 00    	jne    807df5 <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807bfa:	c0 e8 02             	shr    $0x2,%al
  807bfd:	c1 e0 0c             	shl    $0xc,%eax
  807c00:	66 05 00 50          	add    $0x5000,%ax
  807c04:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807c08:	8b 45 0c             	mov    0xc(%ebp),%eax
  807c0b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807c0e:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807c12:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807c16:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807c1b:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c1f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807c26:	83 e2 01             	and    $0x1,%edx
  807c29:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807c2c:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807c30:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807c33:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807c37:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807c3b:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807c40:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807c44:	83 ec 0c             	sub    $0xc,%esp
  807c47:	6a 04                	push   $0x4
  807c49:	e8 03 ca ff ff       	call   804651 <memp_malloc>
  807c4e:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807c50:	83 c4 10             	add    $0x10,%esp
  807c53:	85 c0                	test   %eax,%eax
  807c55:	0f 84 e6 02 00 00    	je     807f41 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807c5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807c61:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807c68:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807c6c:	0f 85 b1 01 00 00    	jne    807e23 <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807c72:	85 f6                	test   %esi,%esi
  807c74:	0f 84 92 01 00 00    	je     807e0c <tcp_enqueue+0x2fa>
      useg->next = seg;
  807c7a:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807c7c:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c80:	0f 84 bc 01 00 00    	je     807e42 <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807c86:	83 ec 04             	sub    $0x4,%esp
  807c89:	6a 00                	push   $0x0
  807c8b:	ff 75 cc             	pushl  -0x34(%ebp)
  807c8e:	6a 00                	push   $0x0
  807c90:	e8 25 ce ff ff       	call   804aba <pbuf_alloc>
  807c95:	89 43 04             	mov    %eax,0x4(%ebx)
  807c98:	83 c4 10             	add    $0x10,%esp
  807c9b:	85 c0                	test   %eax,%eax
  807c9d:	0f 84 9e 02 00 00    	je     807f41 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807ca3:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807ca7:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807cab:	0f 82 7a 01 00 00    	jb     807e2b <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807cb1:	83 ec 0c             	sub    $0xc,%esp
  807cb4:	50                   	push   %eax
  807cb5:	e8 84 d1 ff ff       	call   804e3e <pbuf_clen>
  807cba:	0f b6 c0             	movzbl %al,%eax
  807cbd:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807cc1:	8b 43 04             	mov    0x4(%ebx),%eax
  807cc4:	8b 40 04             	mov    0x4(%eax),%eax
  807cc7:	89 43 08             	mov    %eax,0x8(%ebx)
  807cca:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807ccd:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807cd2:	0f 87 69 02 00 00    	ja     807f41 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807cd8:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807cdc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807ce0:	83 ec 08             	sub    $0x8,%esp
  807ce3:	6a 14                	push   $0x14
  807ce5:	ff 73 04             	pushl  0x4(%ebx)
  807ce8:	e8 3a cc ff ff       	call   804927 <pbuf_header>
  807ced:	83 c4 10             	add    $0x10,%esp
  807cf0:	84 c0                	test   %al,%al
  807cf2:	0f 85 49 02 00 00    	jne    807f41 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807cf8:	8b 43 04             	mov    0x4(%ebx),%eax
  807cfb:	8b 70 04             	mov    0x4(%eax),%esi
  807cfe:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807d01:	83 ec 0c             	sub    $0xc,%esp
  807d04:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807d08:	50                   	push   %eax
  807d09:	e8 c0 fb ff ff       	call   8078ce <htons>
  807d0e:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807d11:	8b 73 10             	mov    0x10(%ebx),%esi
  807d14:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807d18:	89 04 24             	mov    %eax,(%esp)
  807d1b:	e8 ae fb ff ff       	call   8078ce <htons>
  807d20:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807d24:	8b 73 10             	mov    0x10(%ebx),%esi
  807d27:	83 c4 04             	add    $0x4,%esp
  807d2a:	ff 75 d8             	pushl  -0x28(%ebp)
  807d2d:	e8 b6 fb ff ff       	call   8078e8 <htonl>
  807d32:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807d35:	8b 43 10             	mov    0x10(%ebx),%eax
  807d38:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807d3e:	8b 43 10             	mov    0x10(%ebx),%eax
  807d41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d45:	89 04 24             	mov    %eax,(%esp)
  807d48:	e8 8e fb ff ff       	call   8078db <ntohs>
  807d4d:	8b 73 10             	mov    0x10(%ebx),%esi
  807d50:	83 e0 c0             	and    $0xffffffc0,%eax
  807d53:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807d57:	09 d0                	or     %edx,%eax
  807d59:	0f b7 c0             	movzwl %ax,%eax
  807d5c:	89 04 24             	mov    %eax,(%esp)
  807d5f:	e8 6a fb ff ff       	call   8078ce <htons>
  807d64:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807d68:	83 c4 10             	add    $0x10,%esp
  807d6b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807d6f:	0f 84 0f 02 00 00    	je     807f84 <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807d75:	83 ec 0c             	sub    $0xc,%esp
  807d78:	8b 43 10             	mov    0x10(%ebx),%eax
  807d7b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807d7f:	50                   	push   %eax
  807d80:	e8 56 fb ff ff       	call   8078db <ntohs>
  807d85:	8b 73 10             	mov    0x10(%ebx),%esi
  807d88:	83 e0 3f             	and    $0x3f,%eax
  807d8b:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807d8f:	0f b7 c0             	movzwl %ax,%eax
  807d92:	89 04 24             	mov    %eax,(%esp)
  807d95:	e8 34 fb ff ff       	call   8078ce <htons>
  807d9a:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807d9e:	83 c4 0c             	add    $0xc,%esp
  807da1:	ff 75 cc             	pushl  -0x34(%ebp)
  807da4:	ff 75 1c             	pushl  0x1c(%ebp)
  807da7:	ff 73 08             	pushl  0x8(%ebx)
  807daa:	e8 9f 74 00 00       	call   80f24e <memcpy>
  807daf:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807db2:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807db6:	0f b7 c1             	movzwl %cx,%eax
  807db9:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807dbc:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807dbf:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807dc3:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807dc7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807dcb:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807dcd:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807dd1:	0f 85 5c fe ff ff    	jne    807c33 <tcp_enqueue+0x121>
  807dd7:	84 c0                	test   %al,%al
  807dd9:	0f 85 54 fe ff ff    	jne    807c33 <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807ddf:	8b 47 74             	mov    0x74(%edi),%eax
  807de2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807de5:	85 c0                	test   %eax,%eax
  807de7:	0f 84 c1 03 00 00    	je     8081ae <tcp_enqueue+0x69c>
  807ded:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807df0:	e9 be 01 00 00       	jmp    807fb3 <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807df5:	83 ec 04             	sub    $0x4,%esp
  807df8:	68 e8 27 81 00       	push   $0x8127e8
  807dfd:	68 b1 00 00 00       	push   $0xb1
  807e02:	68 c6 28 81 00       	push   $0x8128c6
  807e07:	e8 fd 69 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807e0c:	83 ec 04             	sub    $0x4,%esp
  807e0f:	68 de 28 81 00       	push   $0x8128de
  807e14:	68 ce 00 00 00       	push   $0xce
  807e19:	68 c6 28 81 00       	push   $0x8128c6
  807e1e:	e8 e6 69 00 00       	call   80e809 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807e23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807e26:	e9 51 fe ff ff       	jmp    807c7c <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807e2b:	83 ec 04             	sub    $0x4,%esp
  807e2e:	68 1c 28 81 00       	push   $0x81281c
  807e33:	68 df 00 00 00       	push   $0xdf
  807e38:	68 c6 28 81 00       	push   $0x8128c6
  807e3d:	e8 c7 69 00 00       	call   80e809 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807e42:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807e46:	74 7f                	je     807ec7 <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807e48:	83 ec 04             	sub    $0x4,%esp
  807e4b:	6a 00                	push   $0x0
  807e4d:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807e51:	0f b7 c6             	movzwl %si,%eax
  807e54:	50                   	push   %eax
  807e55:	6a 00                	push   $0x0
  807e57:	e8 5e cc ff ff       	call   804aba <pbuf_alloc>
  807e5c:	89 43 04             	mov    %eax,0x4(%ebx)
  807e5f:	83 c4 10             	add    $0x10,%esp
  807e62:	85 c0                	test   %eax,%eax
  807e64:	0f 84 d7 00 00 00    	je     807f41 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807e6a:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807e6e:	72 40                	jb     807eb0 <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807e70:	83 ec 0c             	sub    $0xc,%esp
  807e73:	50                   	push   %eax
  807e74:	e8 c5 cf ff ff       	call   804e3e <pbuf_clen>
  807e79:	0f b6 c0             	movzbl %al,%eax
  807e7c:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807e80:	83 c4 10             	add    $0x10,%esp
  807e83:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807e87:	74 19                	je     807ea2 <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807e89:	83 ec 04             	sub    $0x4,%esp
  807e8c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807e90:	50                   	push   %eax
  807e91:	ff 75 d0             	pushl  -0x30(%ebp)
  807e94:	8b 43 04             	mov    0x4(%ebx),%eax
  807e97:	ff 70 04             	pushl  0x4(%eax)
  807e9a:	e8 af 73 00 00       	call   80f24e <memcpy>
  807e9f:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807ea2:	8b 43 04             	mov    0x4(%ebx),%eax
  807ea5:	8b 40 04             	mov    0x4(%eax),%eax
  807ea8:	89 43 08             	mov    %eax,0x8(%ebx)
  807eab:	e9 1d fe ff ff       	jmp    807ccd <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807eb0:	83 ec 04             	sub    $0x4,%esp
  807eb3:	68 44 28 81 00       	push   $0x812844
  807eb8:	68 ea 00 00 00       	push   $0xea
  807ebd:	68 c6 28 81 00       	push   $0x8128c6
  807ec2:	e8 42 69 00 00       	call   80e809 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807ec7:	83 ec 04             	sub    $0x4,%esp
  807eca:	6a 01                	push   $0x1
  807ecc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807ed0:	50                   	push   %eax
  807ed1:	6a 00                	push   $0x0
  807ed3:	e8 e2 cb ff ff       	call   804aba <pbuf_alloc>
  807ed8:	89 c6                	mov    %eax,%esi
  807eda:	83 c4 10             	add    $0x10,%esp
  807edd:	85 c0                	test   %eax,%eax
  807edf:	74 60                	je     807f41 <tcp_enqueue+0x42f>
      ++queuelen;
  807ee1:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807ee5:	83 c0 01             	add    $0x1,%eax
  807ee8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807eec:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807eef:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807ef2:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807ef5:	83 ec 04             	sub    $0x4,%esp
  807ef8:	6a 00                	push   $0x0
  807efa:	6a 00                	push   $0x0
  807efc:	6a 00                	push   $0x0
  807efe:	e8 b7 cb ff ff       	call   804aba <pbuf_alloc>
  807f03:	89 43 04             	mov    %eax,0x4(%ebx)
  807f06:	83 c4 10             	add    $0x10,%esp
  807f09:	85 c0                	test   %eax,%eax
  807f0b:	74 28                	je     807f35 <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807f0d:	83 ec 0c             	sub    $0xc,%esp
  807f10:	50                   	push   %eax
  807f11:	e8 28 cf ff ff       	call   804e3e <pbuf_clen>
  807f16:	0f b6 c0             	movzbl %al,%eax
  807f19:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807f1d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807f21:	83 c4 08             	add    $0x8,%esp
  807f24:	56                   	push   %esi
  807f25:	ff 73 04             	pushl  0x4(%ebx)
  807f28:	e8 3a cf ff ff       	call   804e67 <pbuf_cat>
  807f2d:	83 c4 10             	add    $0x10,%esp
  807f30:	e9 98 fd ff ff       	jmp    807ccd <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807f35:	83 ec 0c             	sub    $0xc,%esp
  807f38:	56                   	push   %esi
  807f39:	e8 b6 ca ff ff       	call   8049f4 <pbuf_free>
        goto memerr;
  807f3e:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807f41:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807f45:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807f48:	85 c0                	test   %eax,%eax
  807f4a:	74 0c                	je     807f58 <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807f4c:	83 ec 0c             	sub    $0xc,%esp
  807f4f:	50                   	push   %eax
  807f50:	e8 f6 d9 ff ff       	call   80594b <tcp_segs_free>
  807f55:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807f58:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807f5d:	0f 84 37 02 00 00    	je     80819a <tcp_enqueue+0x688>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807f63:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807f67:	0f 85 37 02 00 00    	jne    8081a4 <tcp_enqueue+0x692>
  807f6d:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807f71:	0f 84 02 02 00 00    	je     808179 <tcp_enqueue+0x667>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807f77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807f7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807f7f:	5b                   	pop    %ebx
  807f80:	5e                   	pop    %esi
  807f81:	5f                   	pop    %edi
  807f82:	5d                   	pop    %ebp
  807f83:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807f84:	83 ec 0c             	sub    $0xc,%esp
  807f87:	8b 43 10             	mov    0x10(%ebx),%eax
  807f8a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f8e:	50                   	push   %eax
  807f8f:	e8 47 f9 ff ff       	call   8078db <ntohs>
  807f94:	8b 73 10             	mov    0x10(%ebx),%esi
  807f97:	83 e0 3f             	and    $0x3f,%eax
  807f9a:	80 cc 50             	or     $0x50,%ah
  807f9d:	89 04 24             	mov    %eax,(%esp)
  807fa0:	e8 29 f9 ff ff       	call   8078ce <htons>
  807fa5:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807fa9:	83 c4 10             	add    $0x10,%esp
  807fac:	e9 01 fe ff ff       	jmp    807db2 <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807fb1:	89 f0                	mov    %esi,%eax
  807fb3:	8b 30                	mov    (%eax),%esi
  807fb5:	85 f6                	test   %esi,%esi
  807fb7:	75 f8                	jne    807fb1 <tcp_enqueue+0x49f>
  807fb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  807fbc:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807fc0:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807fc4:	83 ec 0c             	sub    $0xc,%esp
  807fc7:	8b 40 10             	mov    0x10(%eax),%eax
  807fca:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807fce:	50                   	push   %eax
  807fcf:	e8 07 f9 ff ff       	call   8078db <ntohs>
  807fd4:	83 c4 10             	add    $0x10,%esp
  807fd7:	a8 01                	test   $0x1,%al
  807fd9:	0f 84 96 00 00 00    	je     808075 <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807fdf:	83 ec 0c             	sub    $0xc,%esp
  807fe2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807fe5:	8b 40 10             	mov    0x10(%eax),%eax
  807fe8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807fec:	50                   	push   %eax
  807fed:	e8 e9 f8 ff ff       	call   8078db <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807ff2:	83 c4 10             	add    $0x10,%esp
  807ff5:	a8 03                	test   $0x3,%al
  807ff7:	0f 85 a0 00 00 00    	jne    80809d <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807ffd:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  808001:	0f 85 96 00 00 00    	jne    80809d <tcp_enqueue+0x58b>
    useg->len + queue->len <= pcb->mss) {
  808007:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80800a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80800e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  808011:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  808015:	01 d0                	add    %edx,%eax
  808017:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  80801b:	39 d0                	cmp    %edx,%eax
  80801d:	7f 7e                	jg     80809d <tcp_enqueue+0x58b>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80801f:	83 ec 08             	sub    $0x8,%esp
  808022:	6a ec                	push   $0xffffffec
  808024:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808027:	ff 70 04             	pushl  0x4(%eax)
  80802a:	e8 f8 c8 ff ff       	call   804927 <pbuf_header>
  80802f:	83 c4 10             	add    $0x10,%esp
  808032:	84 c0                	test   %al,%al
  808034:	0f 85 0b 01 00 00    	jne    808145 <tcp_enqueue+0x633>
    pbuf_cat(useg->p, queue->p);
  80803a:	83 ec 08             	sub    $0x8,%esp
  80803d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  808040:	ff 72 04             	pushl  0x4(%edx)
  808043:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808046:	ff 71 04             	pushl  0x4(%ecx)
  808049:	e8 19 ce ff ff       	call   804e67 <pbuf_cat>
    useg->len += queue->len;
  80804e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  808051:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  808055:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808058:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  80805c:	8b 02                	mov    (%edx),%eax
  80805e:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  808060:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  808063:	39 da                	cmp    %ebx,%edx
  808065:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  808068:	52                   	push   %edx
  808069:	6a 04                	push   $0x4
  80806b:	e8 37 c6 ff ff       	call   8046a7 <memp_free>
  808070:	83 c4 10             	add    $0x10,%esp
  808073:	eb 49                	jmp    8080be <tcp_enqueue+0x5ac>
    TCP_TCPLEN(useg) != 0 &&
  808075:	83 ec 0c             	sub    $0xc,%esp
  808078:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80807b:	8b 40 10             	mov    0x10(%eax),%eax
  80807e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808082:	50                   	push   %eax
  808083:	e8 53 f8 ff ff       	call   8078db <ntohs>
  808088:	66 d1 e8             	shr    %ax
  80808b:	83 e0 01             	and    $0x1,%eax
  80808e:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  808092:	83 c4 10             	add    $0x10,%esp
  808095:	01 d0                	add    %edx,%eax
  808097:	0f 85 42 ff ff ff    	jne    807fdf <tcp_enqueue+0x4cd>
      useg->next = queue;
  80809d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8080a0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8080a3:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  8080a5:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  8080a9:	83 e2 03             	and    $0x3,%edx
    ++len;
  8080ac:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8080b0:	83 c0 01             	add    $0x1,%eax
  8080b3:	84 d2                	test   %dl,%dl
  8080b5:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  8080ba:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  8080be:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  8080c2:	74 04                	je     8080c8 <tcp_enqueue+0x5b6>
    pcb->flags |= TF_FIN;
  8080c4:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  8080c8:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  8080cc:	0f b7 c2             	movzwl %dx,%eax
  8080cf:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  8080d2:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  8080d6:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8080da:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  8080de:	66 85 c0             	test   %ax,%ax
  8080e1:	74 06                	je     8080e9 <tcp_enqueue+0x5d7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  8080e3:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080e7:	74 73                	je     80815c <tcp_enqueue+0x64a>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8080e9:	85 db                	test   %ebx,%ebx
  8080eb:	0f 84 9f 00 00 00    	je     808190 <tcp_enqueue+0x67e>
  8080f1:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  8080f6:	0f 84 94 00 00 00    	je     808190 <tcp_enqueue+0x67e>
  8080fc:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  8080ff:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  808104:	85 d2                	test   %edx,%edx
  808106:	0f 84 70 fe ff ff    	je     807f7c <tcp_enqueue+0x46a>
  80810c:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  808110:	0f 85 66 fe ff ff    	jne    807f7c <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  808116:	83 ec 0c             	sub    $0xc,%esp
  808119:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80811d:	50                   	push   %eax
  80811e:	e8 b8 f7 ff ff       	call   8078db <ntohs>
  808123:	8b 5b 10             	mov    0x10(%ebx),%ebx
  808126:	83 c8 08             	or     $0x8,%eax
  808129:	0f b7 c0             	movzwl %ax,%eax
  80812c:	89 04 24             	mov    %eax,(%esp)
  80812f:	e8 9a f7 ff ff       	call   8078ce <htons>
  808134:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  808138:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  80813b:	b8 00 00 00 00       	mov    $0x0,%eax
  808140:	e9 37 fe ff ff       	jmp    807f7c <tcp_enqueue+0x46a>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808145:	83 ec 04             	sub    $0x4,%esp
  808148:	68 eb 28 81 00       	push   $0x8128eb
  80814d:	68 52 01 00 00       	push   $0x152
  808152:	68 c6 28 81 00       	push   $0x8128c6
  808157:	e8 ad 66 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80815c:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808160:	75 87                	jne    8080e9 <tcp_enqueue+0x5d7>
  808162:	83 ec 04             	sub    $0x4,%esp
  808165:	68 78 28 81 00       	push   $0x812878
  80816a:	68 7a 01 00 00       	push   $0x17a
  80816f:	68 c6 28 81 00       	push   $0x8128c6
  808174:	e8 90 66 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808179:	83 ec 04             	sub    $0x4,%esp
  80817c:	68 78 28 81 00       	push   $0x812878
  808181:	68 8d 01 00 00       	push   $0x18d
  808186:	68 c6 28 81 00       	push   $0x8128c6
  80818b:	e8 79 66 00 00       	call   80e809 <_panic>
  return ERR_OK;
  808190:	b8 00 00 00 00       	mov    $0x0,%eax
  808195:	e9 e2 fd ff ff       	jmp    807f7c <tcp_enqueue+0x46a>
  return ERR_MEM;
  80819a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80819f:	e9 d8 fd ff ff       	jmp    807f7c <tcp_enqueue+0x46a>
  8081a4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8081a9:	e9 ce fd ff ff       	jmp    807f7c <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  8081ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8081b1:	89 47 74             	mov    %eax,0x74(%edi)
  8081b4:	e9 ec fe ff ff       	jmp    8080a5 <tcp_enqueue+0x593>

008081b9 <tcp_send_ctrl>:
{
  8081b9:	55                   	push   %ebp
  8081ba:	89 e5                	mov    %esp,%ebp
  8081bc:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8081bf:	6a 00                	push   $0x0
  8081c1:	6a 00                	push   $0x0
  8081c3:	6a 01                	push   $0x1
  8081c5:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  8081c9:	50                   	push   %eax
  8081ca:	6a 00                	push   $0x0
  8081cc:	6a 00                	push   $0x0
  8081ce:	ff 75 08             	pushl  0x8(%ebp)
  8081d1:	e8 3c f9 ff ff       	call   807b12 <tcp_enqueue>
}
  8081d6:	c9                   	leave  
  8081d7:	c3                   	ret    

008081d8 <tcp_write>:
{
  8081d8:	55                   	push   %ebp
  8081d9:	89 e5                	mov    %esp,%ebp
  8081db:	56                   	push   %esi
  8081dc:	53                   	push   %ebx
  8081dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8081e0:	8b 55 10             	mov    0x10(%ebp),%edx
  8081e3:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  8081e6:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  8081e9:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  8081ec:	83 fb 02             	cmp    $0x2,%ebx
  8081ef:	76 05                	jbe    8081f6 <tcp_write+0x1e>
  8081f1:	83 f8 07             	cmp    $0x7,%eax
  8081f4:	75 32                	jne    808228 <tcp_write+0x50>
    return ERR_OK;
  8081f6:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  8081fb:	66 85 d2             	test   %dx,%dx
  8081fe:	75 07                	jne    808207 <tcp_write+0x2f>
}
  808200:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808203:	5b                   	pop    %ebx
  808204:	5e                   	pop    %esi
  808205:	5d                   	pop    %ebp
  808206:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  808207:	83 ec 04             	sub    $0x4,%esp
  80820a:	6a 00                	push   $0x0
  80820c:	6a 00                	push   $0x0
  80820e:	89 f0                	mov    %esi,%eax
  808210:	0f b6 f0             	movzbl %al,%esi
  808213:	56                   	push   %esi
  808214:	6a 00                	push   $0x0
  808216:	0f b7 d2             	movzwl %dx,%edx
  808219:	52                   	push   %edx
  80821a:	ff 75 0c             	pushl  0xc(%ebp)
  80821d:	51                   	push   %ecx
  80821e:	e8 ef f8 ff ff       	call   807b12 <tcp_enqueue>
  808223:	83 c4 20             	add    $0x20,%esp
  808226:	eb d8                	jmp    808200 <tcp_write+0x28>
    return ERR_CONN;
  808228:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80822d:	eb d1                	jmp    808200 <tcp_write+0x28>

0080822f <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80822f:	55                   	push   %ebp
  808230:	89 e5                	mov    %esp,%ebp
  808232:	57                   	push   %edi
  808233:	56                   	push   %esi
  808234:	53                   	push   %ebx
  808235:	83 ec 1c             	sub    $0x1c,%esp
  808238:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80823b:	39 3d 58 c2 b3 00    	cmp    %edi,0xb3c258
  808241:	0f 84 60 04 00 00    	je     8086a7 <tcp_output+0x478>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  808247:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80824b:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  80824f:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  808254:	0f b7 c0             	movzwl %ax,%eax
  808257:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  80825a:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80825d:	8b 47 78             	mov    0x78(%edi),%eax
  808260:	89 45 dc             	mov    %eax,-0x24(%ebp)
  808263:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  808266:	85 c0                	test   %eax,%eax
  808268:	75 04                	jne    80826e <tcp_output+0x3f>
  80826a:	eb 0b                	jmp    808277 <tcp_output+0x48>
    for (; useg->next != NULL; useg = useg->next);
  80826c:	89 c2                	mov    %eax,%edx
  80826e:	8b 02                	mov    (%edx),%eax
  808270:	85 c0                	test   %eax,%eax
  808272:	75 f8                	jne    80826c <tcp_output+0x3d>
  808274:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  808277:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  80827b:	0f 84 e6 03 00 00    	je     808667 <tcp_output+0x438>
  808281:	85 db                	test   %ebx,%ebx
  808283:	74 23                	je     8082a8 <tcp_output+0x79>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  808285:	83 ec 0c             	sub    $0xc,%esp
  808288:	8b 43 10             	mov    0x10(%ebx),%eax
  80828b:	ff 70 04             	pushl  0x4(%eax)
  80828e:	e8 6c f8 ff ff       	call   807aff <ntohl>
  808293:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808297:	2b 57 48             	sub    0x48(%edi),%edx
  80829a:	01 c2                	add    %eax,%edx
     (seg == NULL ||
  80829c:	83 c4 10             	add    $0x10,%esp
  80829f:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  8082a2:	0f 86 bf 03 00 00    	jbe    808667 <tcp_output+0x438>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8082a8:	83 ec 04             	sub    $0x4,%esp
  8082ab:	6a 00                	push   $0x0
  8082ad:	6a 14                	push   $0x14
  8082af:	6a 01                	push   $0x1
  8082b1:	e8 04 c8 ff ff       	call   804aba <pbuf_alloc>
  8082b6:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8082b8:	83 c4 10             	add    $0x10,%esp
  8082bb:	85 c0                	test   %eax,%eax
  8082bd:	0f 84 eb 03 00 00    	je     8086ae <tcp_output+0x47f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8082c3:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  8082c7:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  8082ca:	83 ec 0c             	sub    $0xc,%esp
  8082cd:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8082d1:	50                   	push   %eax
  8082d2:	e8 f7 f5 ff ff       	call   8078ce <htons>
  8082d7:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  8082da:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  8082de:	89 04 24             	mov    %eax,(%esp)
  8082e1:	e8 e8 f5 ff ff       	call   8078ce <htons>
  8082e6:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  8082ea:	83 c4 04             	add    $0x4,%esp
  8082ed:	ff 77 54             	pushl  0x54(%edi)
  8082f0:	e8 f3 f5 ff ff       	call   8078e8 <htonl>
  8082f5:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  8082f8:	83 c4 04             	add    $0x4,%esp
  8082fb:	ff 77 24             	pushl  0x24(%edi)
  8082fe:	e8 e5 f5 ff ff       	call   8078e8 <htonl>
  808303:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808306:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80830a:	89 04 24             	mov    %eax,(%esp)
  80830d:	e8 c9 f5 ff ff       	call   8078db <ntohs>
  808312:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808317:	83 c8 10             	or     $0x10,%eax
  80831a:	89 04 24             	mov    %eax,(%esp)
  80831d:	e8 ac f5 ff ff       	call   8078ce <htons>
  808322:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808326:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80832a:	89 04 24             	mov    %eax,(%esp)
  80832d:	e8 9c f5 ff ff       	call   8078ce <htons>
  808332:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  808336:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80833c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808340:	89 04 24             	mov    %eax,(%esp)
  808343:	e8 93 f5 ff ff       	call   8078db <ntohs>
  808348:	83 e0 3f             	and    $0x3f,%eax
  80834b:	80 cc 50             	or     $0x50,%ah
  80834e:	89 04 24             	mov    %eax,(%esp)
  808351:	e8 78 f5 ff ff       	call   8078ce <htons>
  808356:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80835a:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  808360:	8d 47 04             	lea    0x4(%edi),%eax
  808363:	89 c1                	mov    %eax,%ecx
  808365:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808369:	89 04 24             	mov    %eax,(%esp)
  80836c:	6a 06                	push   $0x6
  80836e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808371:	51                   	push   %ecx
  808372:	57                   	push   %edi
  808373:	56                   	push   %esi
  808374:	e8 31 f2 ff ff       	call   8075aa <inet_chksum_pseudo>
  808379:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80837d:	83 c4 18             	add    $0x18,%esp
  808380:	6a 06                	push   $0x6
  808382:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808386:	50                   	push   %eax
  808387:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80838b:	50                   	push   %eax
  80838c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80838f:	57                   	push   %edi
  808390:	56                   	push   %esi
  808391:	e8 28 e8 ff ff       	call   806bbe <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808396:	83 c4 14             	add    $0x14,%esp
  808399:	56                   	push   %esi
  80839a:	e8 55 c6 ff ff       	call   8049f4 <pbuf_free>

    return ERR_OK;
  80839f:	83 c4 10             	add    $0x10,%esp
  8083a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8083a7:	e9 1b 03 00 00       	jmp    8086c7 <tcp_output+0x498>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  8083ac:	83 ec 04             	sub    $0x4,%esp
  8083af:	68 ff 28 81 00       	push   $0x8128ff
  8083b4:	68 05 02 00 00       	push   $0x205
  8083b9:	68 c6 28 81 00       	push   $0x8128c6
  8083be:	e8 46 64 00 00       	call   80e809 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  8083c3:	83 ec 0c             	sub    $0xc,%esp
  8083c6:	8b 43 10             	mov    0x10(%ebx),%eax
  8083c9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8083cd:	50                   	push   %eax
  8083ce:	e8 08 f5 ff ff       	call   8078db <ntohs>
  8083d3:	8b 73 10             	mov    0x10(%ebx),%esi
  8083d6:	83 c8 10             	or     $0x10,%eax
  8083d9:	0f b7 c0             	movzwl %ax,%eax
  8083dc:	89 04 24             	mov    %eax,(%esp)
  8083df:	e8 ea f4 ff ff       	call   8078ce <htons>
  8083e4:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8083e8:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  8083ec:	83 c4 10             	add    $0x10,%esp
  8083ef:	e9 06 01 00 00       	jmp    8084fa <tcp_output+0x2cb>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  8083f4:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  8083fa:	e9 49 01 00 00       	jmp    808548 <tcp_output+0x319>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  8083ff:	a1 40 c2 b3 00       	mov    0xb3c240,%eax
  808404:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808407:	83 ec 0c             	sub    $0xc,%esp
  80840a:	8b 43 10             	mov    0x10(%ebx),%eax
  80840d:	ff 70 04             	pushl  0x4(%eax)
  808410:	e8 ea f6 ff ff       	call   807aff <ntohl>
  808415:	89 47 3c             	mov    %eax,0x3c(%edi)
  808418:	83 c4 10             	add    $0x10,%esp
  80841b:	e9 32 01 00 00       	jmp    808552 <tcp_output+0x323>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808420:	83 ec 0c             	sub    $0xc,%esp
  808423:	8b 43 10             	mov    0x10(%ebx),%eax
  808426:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80842a:	50                   	push   %eax
  80842b:	e8 ab f4 ff ff       	call   8078db <ntohs>
  808430:	66 d1 e8             	shr    %ax
  808433:	89 c2                	mov    %eax,%edx
  808435:	83 e2 01             	and    $0x1,%edx
  808438:	83 c4 10             	add    $0x10,%esp
  80843b:	e9 a5 01 00 00       	jmp    8085e5 <tcp_output+0x3b6>
      pcb->snd_max = pcb->snd_nxt;
  808440:	89 77 58             	mov    %esi,0x58(%edi)
  808443:	e9 ae 01 00 00       	jmp    8085f6 <tcp_output+0x3c7>
    if (TCP_TCPLEN(seg) > 0) {
  808448:	83 ec 0c             	sub    $0xc,%esp
  80844b:	8b 43 10             	mov    0x10(%ebx),%eax
  80844e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808452:	50                   	push   %eax
  808453:	e8 83 f4 ff ff       	call   8078db <ntohs>
  808458:	66 d1 e8             	shr    %ax
  80845b:	83 e0 01             	and    $0x1,%eax
  80845e:	0f b7 f6             	movzwl %si,%esi
  808461:	83 c4 10             	add    $0x10,%esp
  808464:	01 f0                	add    %esi,%eax
  808466:	0f 85 a9 01 00 00    	jne    808615 <tcp_output+0x3e6>
      tcp_seg_free(seg);
  80846c:	83 ec 0c             	sub    $0xc,%esp
  80846f:	53                   	push   %ebx
  808470:	e8 99 d4 ff ff       	call   80590e <tcp_seg_free>
  808475:	83 c4 10             	add    $0x10,%esp
  808478:	eb 06                	jmp    808480 <tcp_output+0x251>
        pcb->unacked = seg;
  80847a:	89 5f 78             	mov    %ebx,0x78(%edi)
  80847d:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808480:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808483:	85 db                	test   %ebx,%ebx
  808485:	0f 84 33 02 00 00    	je     8086be <tcp_output+0x48f>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80848b:	83 ec 0c             	sub    $0xc,%esp
  80848e:	8b 43 10             	mov    0x10(%ebx),%eax
  808491:	ff 70 04             	pushl  0x4(%eax)
  808494:	e8 66 f6 ff ff       	call   807aff <ntohl>
  808499:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80849d:	2b 57 48             	sub    0x48(%edi),%edx
  8084a0:	01 c2                	add    %eax,%edx
  while (seg != NULL &&
  8084a2:	83 c4 10             	add    $0x10,%esp
  8084a5:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  8084a8:	0f 87 07 02 00 00    	ja     8086b5 <tcp_output+0x486>
    LWIP_ASSERT("RST not expected here!", 
  8084ae:	83 ec 0c             	sub    $0xc,%esp
  8084b1:	8b 43 10             	mov    0x10(%ebx),%eax
  8084b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084b8:	50                   	push   %eax
  8084b9:	e8 1d f4 ff ff       	call   8078db <ntohs>
  8084be:	83 c4 10             	add    $0x10,%esp
  8084c1:	a8 04                	test   $0x4,%al
  8084c3:	0f 85 e3 fe ff ff    	jne    8083ac <tcp_output+0x17d>
    if((tcp_do_output_nagle(pcb) == 0) &&
  8084c9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8084cd:	74 1c                	je     8084eb <tcp_output+0x2bc>
  8084cf:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  8084d3:	a8 40                	test   $0x40,%al
  8084d5:	75 14                	jne    8084eb <tcp_output+0x2bc>
  8084d7:	8b 57 74             	mov    0x74(%edi),%edx
  8084da:	85 d2                	test   %edx,%edx
  8084dc:	74 05                	je     8084e3 <tcp_output+0x2b4>
  8084de:	83 3a 00             	cmpl   $0x0,(%edx)
  8084e1:	75 08                	jne    8084eb <tcp_output+0x2bc>
  8084e3:	a8 a0                	test   $0xa0,%al
  8084e5:	0f 84 ca 01 00 00    	je     8086b5 <tcp_output+0x486>
    pcb->unsent = seg->next;
  8084eb:	8b 03                	mov    (%ebx),%eax
  8084ed:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  8084f0:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  8084f4:	0f 85 c9 fe ff ff    	jne    8083c3 <tcp_output+0x194>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8084fa:	8b 73 10             	mov    0x10(%ebx),%esi
  8084fd:	83 ec 0c             	sub    $0xc,%esp
  808500:	ff 77 24             	pushl  0x24(%edi)
  808503:	e8 e0 f3 ff ff       	call   8078e8 <htonl>
  808508:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80850b:	8b 73 10             	mov    0x10(%ebx),%esi
  80850e:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808512:	89 04 24             	mov    %eax,(%esp)
  808515:	e8 b4 f3 ff ff       	call   8078ce <htons>
  80851a:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  80851e:	83 c4 10             	add    $0x10,%esp
  808521:	83 3f 00             	cmpl   $0x0,(%edi)
  808524:	75 17                	jne    80853d <tcp_output+0x30e>
    netif = ip_route(&(pcb->remote_ip));
  808526:	83 ec 0c             	sub    $0xc,%esp
  808529:	ff 75 e4             	pushl  -0x1c(%ebp)
  80852c:	e8 7d e1 ff ff       	call   8066ae <ip_route>
    if (netif == NULL) {
  808531:	83 c4 10             	add    $0x10,%esp
  808534:	85 c0                	test   %eax,%eax
  808536:	74 79                	je     8085b1 <tcp_output+0x382>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  808538:	8b 40 04             	mov    0x4(%eax),%eax
  80853b:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  80853d:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808542:	0f 84 ac fe ff ff    	je     8083f4 <tcp_output+0x1c5>
  if (pcb->rttest == 0) {
  808548:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  80854c:	0f 84 ad fe ff ff    	je     8083ff <tcp_output+0x1d0>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808552:	8b 53 04             	mov    0x4(%ebx),%edx
  808555:	8b 43 10             	mov    0x10(%ebx),%eax
  808558:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  80855b:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  80855f:	8b 53 04             	mov    0x4(%ebx),%edx
  808562:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  808566:	8b 53 04             	mov    0x4(%ebx),%edx
  808569:	8b 43 10             	mov    0x10(%ebx),%eax
  80856c:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  80856f:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808575:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808578:	8b 73 10             	mov    0x10(%ebx),%esi
  80857b:	83 ec 0c             	sub    $0xc,%esp
  80857e:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808582:	52                   	push   %edx
  808583:	6a 06                	push   $0x6
  808585:	ff 75 e4             	pushl  -0x1c(%ebp)
  808588:	57                   	push   %edi
  808589:	50                   	push   %eax
  80858a:	e8 1b f0 ff ff       	call   8075aa <inet_chksum_pseudo>
  80858f:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808593:	83 c4 18             	add    $0x18,%esp
  808596:	6a 06                	push   $0x6
  808598:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80859c:	50                   	push   %eax
  80859d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  8085a1:	50                   	push   %eax
  8085a2:	ff 75 e4             	pushl  -0x1c(%ebp)
  8085a5:	57                   	push   %edi
  8085a6:	ff 73 04             	pushl  0x4(%ebx)
  8085a9:	e8 10 e6 ff ff       	call   806bbe <ip_output>
  8085ae:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8085b1:	83 ec 0c             	sub    $0xc,%esp
  8085b4:	8b 43 10             	mov    0x10(%ebx),%eax
  8085b7:	ff 70 04             	pushl  0x4(%eax)
  8085ba:	e8 40 f5 ff ff       	call   807aff <ntohl>
  8085bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8085c2:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8085c6:	8b 43 10             	mov    0x10(%ebx),%eax
  8085c9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8085cd:	89 04 24             	mov    %eax,(%esp)
  8085d0:	e8 06 f3 ff ff       	call   8078db <ntohs>
  8085d5:	83 c4 10             	add    $0x10,%esp
  8085d8:	ba 01 00 00 00       	mov    $0x1,%edx
  8085dd:	a8 01                	test   $0x1,%al
  8085df:	0f 84 3b fe ff ff    	je     808420 <tcp_output+0x1f1>
  8085e5:	01 d6                	add    %edx,%esi
  8085e7:	03 75 e0             	add    -0x20(%ebp),%esi
  8085ea:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  8085ed:	39 77 58             	cmp    %esi,0x58(%edi)
  8085f0:	0f 88 4a fe ff ff    	js     808440 <tcp_output+0x211>
    if (TCP_TCPLEN(seg) > 0) {
  8085f6:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  8085fa:	83 ec 0c             	sub    $0xc,%esp
  8085fd:	8b 43 10             	mov    0x10(%ebx),%eax
  808600:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808604:	50                   	push   %eax
  808605:	e8 d1 f2 ff ff       	call   8078db <ntohs>
  80860a:	83 c4 10             	add    $0x10,%esp
  80860d:	a8 01                	test   $0x1,%al
  80860f:	0f 84 33 fe ff ff    	je     808448 <tcp_output+0x219>
      seg->next = NULL;
  808615:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  80861b:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80861f:	0f 84 55 fe ff ff    	je     80847a <tcp_output+0x24b>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808625:	83 ec 0c             	sub    $0xc,%esp
  808628:	8b 43 10             	mov    0x10(%ebx),%eax
  80862b:	ff 70 04             	pushl  0x4(%eax)
  80862e:	e8 cc f4 ff ff       	call   807aff <ntohl>
  808633:	89 c6                	mov    %eax,%esi
  808635:	83 c4 04             	add    $0x4,%esp
  808638:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80863b:	8b 40 10             	mov    0x10(%eax),%eax
  80863e:	ff 70 04             	pushl  0x4(%eax)
  808641:	e8 b9 f4 ff ff       	call   807aff <ntohl>
  808646:	83 c4 10             	add    $0x10,%esp
  808649:	39 c6                	cmp    %eax,%esi
  80864b:	78 0d                	js     80865a <tcp_output+0x42b>
          useg->next = seg;
  80864d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808650:	89 18                	mov    %ebx,(%eax)
  808652:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808655:	e9 26 fe ff ff       	jmp    808480 <tcp_output+0x251>
          seg->next = pcb->unacked;
  80865a:	8b 47 78             	mov    0x78(%edi),%eax
  80865d:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80865f:	89 5f 78             	mov    %ebx,0x78(%edi)
  808662:	e9 19 fe ff ff       	jmp    808480 <tcp_output+0x251>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808667:	8d 47 04             	lea    0x4(%edi),%eax
  80866a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80866d:	e9 11 fe ff ff       	jmp    808483 <tcp_output+0x254>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808672:	83 ec 0c             	sub    $0xc,%esp
  808675:	8b 43 10             	mov    0x10(%ebx),%eax
  808678:	ff 70 04             	pushl  0x4(%eax)
  80867b:	e8 7f f4 ff ff       	call   807aff <ntohl>
  808680:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808684:	2b 57 48             	sub    0x48(%edi),%edx
  808687:	01 c2                	add    %eax,%edx
  808689:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80868d:	83 c4 10             	add    $0x10,%esp
  808690:	39 c2                	cmp    %eax,%edx
  808692:	76 2a                	jbe    8086be <tcp_output+0x48f>
    pcb->persist_cnt = 0;
  808694:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  80869b:	00 00 00 
    pcb->persist_backoff = 1;
  80869e:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  8086a5:	eb 17                	jmp    8086be <tcp_output+0x48f>
    return ERR_OK;
  8086a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8086ac:	eb 19                	jmp    8086c7 <tcp_output+0x498>
      return ERR_BUF;
  8086ae:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8086b3:	eb 12                	jmp    8086c7 <tcp_output+0x498>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  8086b5:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  8086bc:	74 b4                	je     808672 <tcp_output+0x443>
  pcb->flags &= ~TF_NAGLEMEMERR;
  8086be:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  8086c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8086c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8086ca:	5b                   	pop    %ebx
  8086cb:	5e                   	pop    %esi
  8086cc:	5f                   	pop    %edi
  8086cd:	5d                   	pop    %ebp
  8086ce:	c3                   	ret    

008086cf <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8086cf:	55                   	push   %ebp
  8086d0:	89 e5                	mov    %esp,%ebp
  8086d2:	57                   	push   %edi
  8086d3:	56                   	push   %esi
  8086d4:	53                   	push   %ebx
  8086d5:	83 ec 20             	sub    $0x20,%esp
  8086d8:	8b 7d 18             	mov    0x18(%ebp),%edi
  8086db:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8086de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8086e1:	6a 00                	push   $0x0
  8086e3:	6a 14                	push   $0x14
  8086e5:	6a 01                	push   $0x1
  8086e7:	e8 ce c3 ff ff       	call   804aba <pbuf_alloc>
  if (p == NULL) {
  8086ec:	83 c4 10             	add    $0x10,%esp
  8086ef:	85 c0                	test   %eax,%eax
  8086f1:	0f 84 e2 00 00 00    	je     8087d9 <tcp_rst+0x10a>
  8086f7:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8086f9:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8086fe:	0f 86 dd 00 00 00    	jbe    8087e1 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808704:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808707:	83 ec 0c             	sub    $0xc,%esp
  80870a:	0f b7 ff             	movzwl %di,%edi
  80870d:	57                   	push   %edi
  80870e:	e8 bb f1 ff ff       	call   8078ce <htons>
  808713:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808716:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80871a:	89 04 24             	mov    %eax,(%esp)
  80871d:	e8 ac f1 ff ff       	call   8078ce <htons>
  808722:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808726:	83 c4 04             	add    $0x4,%esp
  808729:	ff 75 08             	pushl  0x8(%ebp)
  80872c:	e8 b7 f1 ff ff       	call   8078e8 <htonl>
  808731:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808734:	83 c4 04             	add    $0x4,%esp
  808737:	ff 75 0c             	pushl  0xc(%ebp)
  80873a:	e8 a9 f1 ff ff       	call   8078e8 <htonl>
  80873f:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808742:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808746:	89 04 24             	mov    %eax,(%esp)
  808749:	e8 8d f1 ff ff       	call   8078db <ntohs>
  80874e:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808753:	83 c8 14             	or     $0x14,%eax
  808756:	89 04 24             	mov    %eax,(%esp)
  808759:	e8 70 f1 ff ff       	call   8078ce <htons>
  80875e:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808762:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808769:	e8 60 f1 ff ff       	call   8078ce <htons>
  80876e:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808772:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808778:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80877c:	89 04 24             	mov    %eax,(%esp)
  80877f:	e8 57 f1 ff ff       	call   8078db <ntohs>
  808784:	83 e0 3f             	and    $0x3f,%eax
  808787:	80 cc 50             	or     $0x50,%ah
  80878a:	89 04 24             	mov    %eax,(%esp)
  80878d:	e8 3c f1 ff ff       	call   8078ce <htons>
  808792:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808796:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80879c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8087a0:	89 04 24             	mov    %eax,(%esp)
  8087a3:	6a 06                	push   $0x6
  8087a5:	ff 75 14             	pushl  0x14(%ebp)
  8087a8:	ff 75 10             	pushl  0x10(%ebp)
  8087ab:	56                   	push   %esi
  8087ac:	e8 f9 ed ff ff       	call   8075aa <inet_chksum_pseudo>
  8087b1:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8087b5:	83 c4 18             	add    $0x18,%esp
  8087b8:	6a 06                	push   $0x6
  8087ba:	6a 00                	push   $0x0
  8087bc:	68 ff 00 00 00       	push   $0xff
  8087c1:	ff 75 14             	pushl  0x14(%ebp)
  8087c4:	ff 75 10             	pushl  0x10(%ebp)
  8087c7:	56                   	push   %esi
  8087c8:	e8 f1 e3 ff ff       	call   806bbe <ip_output>
  pbuf_free(p);
  8087cd:	83 c4 14             	add    $0x14,%esp
  8087d0:	56                   	push   %esi
  8087d1:	e8 1e c2 ff ff       	call   8049f4 <pbuf_free>
  8087d6:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8087d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8087dc:	5b                   	pop    %ebx
  8087dd:	5e                   	pop    %esi
  8087de:	5f                   	pop    %edi
  8087df:	5d                   	pop    %ebp
  8087e0:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8087e1:	83 ec 04             	sub    $0x4,%esp
  8087e4:	68 98 28 81 00       	push   $0x812898
  8087e9:	68 be 02 00 00       	push   $0x2be
  8087ee:	68 c6 28 81 00       	push   $0x8128c6
  8087f3:	e8 11 60 00 00       	call   80e809 <_panic>

008087f8 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8087f8:	55                   	push   %ebp
  8087f9:	89 e5                	mov    %esp,%ebp
  8087fb:	53                   	push   %ebx
  8087fc:	83 ec 04             	sub    $0x4,%esp
  8087ff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808802:	8b 53 78             	mov    0x78(%ebx),%edx
  808805:	85 d2                	test   %edx,%edx
  808807:	75 04                	jne    80880d <tcp_rexmit_rto+0x15>
  808809:	eb 41                	jmp    80884c <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80880b:	89 c2                	mov    %eax,%edx
  80880d:	8b 02                	mov    (%edx),%eax
  80880f:	85 c0                	test   %eax,%eax
  808811:	75 f8                	jne    80880b <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808813:	8b 43 74             	mov    0x74(%ebx),%eax
  808816:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808818:	8b 43 78             	mov    0x78(%ebx),%eax
  80881b:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80881e:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808825:	83 ec 0c             	sub    $0xc,%esp
  808828:	8b 40 10             	mov    0x10(%eax),%eax
  80882b:	ff 70 04             	pushl  0x4(%eax)
  80882e:	e8 cc f2 ff ff       	call   807aff <ntohl>
  808833:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808836:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80883a:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808841:	89 1c 24             	mov    %ebx,(%esp)
  808844:	e8 e6 f9 ff ff       	call   80822f <tcp_output>
  808849:	83 c4 10             	add    $0x10,%esp
}
  80884c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80884f:	c9                   	leave  
  808850:	c3                   	ret    

00808851 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808851:	55                   	push   %ebp
  808852:	89 e5                	mov    %esp,%ebp
  808854:	53                   	push   %ebx
  808855:	83 ec 04             	sub    $0x4,%esp
  808858:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80885b:	8b 43 78             	mov    0x78(%ebx),%eax
  80885e:	85 c0                	test   %eax,%eax
  808860:	74 37                	je     808899 <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808862:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808864:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808867:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808869:	8b 43 78             	mov    0x78(%ebx),%eax
  80886c:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80886f:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808872:	83 ec 0c             	sub    $0xc,%esp
  808875:	8b 40 10             	mov    0x10(%eax),%eax
  808878:	ff 70 04             	pushl  0x4(%eax)
  80887b:	e8 7f f2 ff ff       	call   807aff <ntohl>
  808880:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808883:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808887:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80888e:	89 1c 24             	mov    %ebx,(%esp)
  808891:	e8 99 f9 ff ff       	call   80822f <tcp_output>
  808896:	83 c4 10             	add    $0x10,%esp
}
  808899:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80889c:	c9                   	leave  
  80889d:	c3                   	ret    

0080889e <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80889e:	55                   	push   %ebp
  80889f:	89 e5                	mov    %esp,%ebp
  8088a1:	57                   	push   %edi
  8088a2:	56                   	push   %esi
  8088a3:	53                   	push   %ebx
  8088a4:	83 ec 20             	sub    $0x20,%esp
  8088a7:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8088aa:	6a 00                	push   $0x0
  8088ac:	6a 14                	push   $0x14
  8088ae:	6a 01                	push   $0x1
  8088b0:	e8 05 c2 ff ff       	call   804aba <pbuf_alloc>
   
  if(p == NULL) {
  8088b5:	83 c4 10             	add    $0x10,%esp
  8088b8:	85 c0                	test   %eax,%eax
  8088ba:	0f 84 e5 00 00 00    	je     8089a5 <tcp_keepalive+0x107>
  8088c0:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8088c2:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8088c7:	0f 86 e0 00 00 00    	jbe    8089ad <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8088cd:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  8088d0:	83 ec 0c             	sub    $0xc,%esp
  8088d3:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8088d7:	50                   	push   %eax
  8088d8:	e8 f1 ef ff ff       	call   8078ce <htons>
  8088dd:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8088e0:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8088e4:	89 04 24             	mov    %eax,(%esp)
  8088e7:	e8 e2 ef ff ff       	call   8078ce <htons>
  8088ec:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  8088f0:	8b 46 54             	mov    0x54(%esi),%eax
  8088f3:	83 e8 01             	sub    $0x1,%eax
  8088f6:	89 04 24             	mov    %eax,(%esp)
  8088f9:	e8 ea ef ff ff       	call   8078e8 <htonl>
  8088fe:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808901:	83 c4 04             	add    $0x4,%esp
  808904:	ff 76 24             	pushl  0x24(%esi)
  808907:	e8 dc ef ff ff       	call   8078e8 <htonl>
  80890c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80890f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808913:	89 04 24             	mov    %eax,(%esp)
  808916:	e8 c0 ef ff ff       	call   8078db <ntohs>
  80891b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808920:	89 04 24             	mov    %eax,(%esp)
  808923:	e8 a6 ef ff ff       	call   8078ce <htons>
  808928:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80892c:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808930:	89 04 24             	mov    %eax,(%esp)
  808933:	e8 96 ef ff ff       	call   8078ce <htons>
  808938:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80893c:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808942:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808946:	89 04 24             	mov    %eax,(%esp)
  808949:	e8 8d ef ff ff       	call   8078db <ntohs>
  80894e:	83 e0 3f             	and    $0x3f,%eax
  808951:	80 cc 50             	or     $0x50,%ah
  808954:	89 04 24             	mov    %eax,(%esp)
  808957:	e8 72 ef ff ff       	call   8078ce <htons>
  80895c:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808960:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808966:	8d 46 04             	lea    0x4(%esi),%eax
  808969:	89 c2                	mov    %eax,%edx
  80896b:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80896f:	89 04 24             	mov    %eax,(%esp)
  808972:	6a 06                	push   $0x6
  808974:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808977:	52                   	push   %edx
  808978:	56                   	push   %esi
  808979:	57                   	push   %edi
  80897a:	e8 2b ec ff ff       	call   8075aa <inet_chksum_pseudo>
  80897f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808983:	83 c4 18             	add    $0x18,%esp
  808986:	6a 06                	push   $0x6
  808988:	6a 00                	push   $0x0
  80898a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80898e:	50                   	push   %eax
  80898f:	ff 75 e4             	pushl  -0x1c(%ebp)
  808992:	56                   	push   %esi
  808993:	57                   	push   %edi
  808994:	e8 25 e2 ff ff       	call   806bbe <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808999:	83 c4 14             	add    $0x14,%esp
  80899c:	57                   	push   %edi
  80899d:	e8 52 c0 ff ff       	call   8049f4 <pbuf_free>
  8089a2:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8089a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8089a8:	5b                   	pop    %ebx
  8089a9:	5e                   	pop    %esi
  8089aa:	5f                   	pop    %edi
  8089ab:	5d                   	pop    %ebp
  8089ac:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8089ad:	83 ec 04             	sub    $0x4,%esp
  8089b0:	68 98 28 81 00       	push   $0x812898
  8089b5:	68 3a 03 00 00       	push   $0x33a
  8089ba:	68 c6 28 81 00       	push   $0x8128c6
  8089bf:	e8 45 5e 00 00       	call   80e809 <_panic>

008089c4 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8089c4:	55                   	push   %ebp
  8089c5:	89 e5                	mov    %esp,%ebp
  8089c7:	57                   	push   %edi
  8089c8:	56                   	push   %esi
  8089c9:	53                   	push   %ebx
  8089ca:	83 ec 1c             	sub    $0x1c,%esp
  8089cd:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8089d0:	8b 46 78             	mov    0x78(%esi),%eax
  8089d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  8089d6:	85 c0                	test   %eax,%eax
  8089d8:	0f 84 10 01 00 00    	je     808aee <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8089de:	83 ec 04             	sub    $0x4,%esp
  8089e1:	6a 00                	push   $0x0
  8089e3:	6a 15                	push   $0x15
  8089e5:	6a 01                	push   $0x1
  8089e7:	e8 ce c0 ff ff       	call   804aba <pbuf_alloc>
  8089ec:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  8089ee:	83 c4 10             	add    $0x10,%esp
  8089f1:	85 c0                	test   %eax,%eax
  8089f3:	0f 84 ed 00 00 00    	je     808ae6 <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8089f9:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  8089fe:	0f 86 f9 00 00 00    	jbe    808afd <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808a04:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808a07:	83 ec 0c             	sub    $0xc,%esp
  808a0a:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808a0e:	50                   	push   %eax
  808a0f:	e8 ba ee ff ff       	call   8078ce <htons>
  808a14:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808a17:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808a1b:	89 04 24             	mov    %eax,(%esp)
  808a1e:	e8 ab ee ff ff       	call   8078ce <htons>
  808a23:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  808a27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808a2a:	8b 40 10             	mov    0x10(%eax),%eax
  808a2d:	8b 40 04             	mov    0x4(%eax),%eax
  808a30:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808a33:	83 c4 04             	add    $0x4,%esp
  808a36:	ff 76 24             	pushl  0x24(%esi)
  808a39:	e8 aa ee ff ff       	call   8078e8 <htonl>
  808a3e:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808a41:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a45:	89 04 24             	mov    %eax,(%esp)
  808a48:	e8 8e ee ff ff       	call   8078db <ntohs>
  808a4d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808a52:	89 04 24             	mov    %eax,(%esp)
  808a55:	e8 74 ee ff ff       	call   8078ce <htons>
  808a5a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808a5e:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808a62:	89 04 24             	mov    %eax,(%esp)
  808a65:	e8 64 ee ff ff       	call   8078ce <htons>
  808a6a:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808a6e:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808a74:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808a78:	89 04 24             	mov    %eax,(%esp)
  808a7b:	e8 5b ee ff ff       	call   8078db <ntohs>
  808a80:	83 e0 3f             	and    $0x3f,%eax
  808a83:	80 cc 50             	or     $0x50,%ah
  808a86:	89 04 24             	mov    %eax,(%esp)
  808a89:	e8 40 ee ff ff       	call   8078ce <htons>
  808a8e:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808a92:	8b 47 04             	mov    0x4(%edi),%eax
  808a95:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a98:	8b 51 08             	mov    0x8(%ecx),%edx
  808a9b:	0f b6 12             	movzbl (%edx),%edx
  808a9e:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808aa1:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808aa7:	8d 46 04             	lea    0x4(%esi),%eax
  808aaa:	89 c1                	mov    %eax,%ecx
  808aac:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808ab0:	89 04 24             	mov    %eax,(%esp)
  808ab3:	6a 06                	push   $0x6
  808ab5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808ab8:	51                   	push   %ecx
  808ab9:	56                   	push   %esi
  808aba:	57                   	push   %edi
  808abb:	e8 ea ea ff ff       	call   8075aa <inet_chksum_pseudo>
  808ac0:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808ac4:	83 c4 18             	add    $0x18,%esp
  808ac7:	6a 06                	push   $0x6
  808ac9:	6a 00                	push   $0x0
  808acb:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808acf:	50                   	push   %eax
  808ad0:	ff 75 e4             	pushl  -0x1c(%ebp)
  808ad3:	56                   	push   %esi
  808ad4:	57                   	push   %edi
  808ad5:	e8 e4 e0 ff ff       	call   806bbe <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808ada:	83 c4 14             	add    $0x14,%esp
  808add:	57                   	push   %edi
  808ade:	e8 11 bf ff ff       	call   8049f4 <pbuf_free>
  808ae3:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808ae6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ae9:	5b                   	pop    %ebx
  808aea:	5e                   	pop    %esi
  808aeb:	5f                   	pop    %edi
  808aec:	5d                   	pop    %ebp
  808aed:	c3                   	ret    
    seg = pcb->unsent;
  808aee:	8b 46 74             	mov    0x74(%esi),%eax
  808af1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  808af4:	85 c0                	test   %eax,%eax
  808af6:	74 ee                	je     808ae6 <tcp_zero_window_probe+0x122>
  808af8:	e9 e1 fe ff ff       	jmp    8089de <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808afd:	83 ec 04             	sub    $0x4,%esp
  808b00:	68 98 28 81 00       	push   $0x812898
  808b05:	68 8d 03 00 00       	push   $0x38d
  808b0a:	68 c6 28 81 00       	push   $0x8128c6
  808b0f:	e8 f5 5c 00 00       	call   80e809 <_panic>

00808b14 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  808b14:	55                   	push   %ebp
  808b15:	89 e5                	mov    %esp,%ebp
  808b17:	57                   	push   %edi
  808b18:	56                   	push   %esi
  808b19:	53                   	push   %ebx
  808b1a:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  808b1d:	8b 45 08             	mov    0x8(%ebp),%eax
  808b20:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  808b23:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  808b27:	0f b7 07             	movzwl (%edi),%eax
  808b2a:	50                   	push   %eax
  808b2b:	e8 ab ed ff ff       	call   8078db <ntohs>
  808b30:	66 c1 e8 08          	shr    $0x8,%ax
  808b34:	83 e0 0f             	and    $0xf,%eax
  808b37:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808b3e:	83 c4 10             	add    $0x10,%esp
  808b41:	39 c3                	cmp    %eax,%ebx
  808b43:	7c 29                	jl     808b6e <udp_input+0x5a>
  808b45:	83 ec 0c             	sub    $0xc,%esp
  808b48:	0f b7 07             	movzwl (%edi),%eax
  808b4b:	50                   	push   %eax
  808b4c:	e8 8a ed ff ff       	call   8078db <ntohs>
  808b51:	83 c4 08             	add    $0x8,%esp
  808b54:	66 c1 e8 06          	shr    $0x6,%ax
  808b58:	83 e0 3c             	and    $0x3c,%eax
  808b5b:	f7 d8                	neg    %eax
  808b5d:	98                   	cwtl   
  808b5e:	50                   	push   %eax
  808b5f:	ff 75 08             	pushl  0x8(%ebp)
  808b62:	e8 c0 bd ff ff       	call   804927 <pbuf_header>
  808b67:	83 c4 10             	add    $0x10,%esp
  808b6a:	84 c0                	test   %al,%al
  808b6c:	74 16                	je     808b84 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808b6e:	83 ec 0c             	sub    $0xc,%esp
  808b71:	ff 75 08             	pushl  0x8(%ebp)
  808b74:	e8 7b be ff ff       	call   8049f4 <pbuf_free>
    goto end;
  808b79:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808b7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808b7f:	5b                   	pop    %ebx
  808b80:	5e                   	pop    %esi
  808b81:	5f                   	pop    %edi
  808b82:	5d                   	pop    %ebp
  808b83:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808b84:	8b 45 08             	mov    0x8(%ebp),%eax
  808b87:	8b 70 04             	mov    0x4(%eax),%esi
  808b8a:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808b8d:	83 ec 0c             	sub    $0xc,%esp
  808b90:	0f b7 06             	movzwl (%esi),%eax
  808b93:	50                   	push   %eax
  808b94:	e8 42 ed ff ff       	call   8078db <ntohs>
  808b99:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808b9d:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808ba1:	89 04 24             	mov    %eax,(%esp)
  808ba4:	e8 32 ed ff ff       	call   8078db <ntohs>
  808ba9:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808bab:	83 c4 10             	add    $0x10,%esp
  808bae:	66 83 f8 44          	cmp    $0x44,%ax
  808bb2:	74 1f                	je     808bd3 <udp_input+0xbf>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808bb4:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
    uncon_pcb = NULL;
  808bba:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808bbf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808bc6:	8d 47 10             	lea    0x10(%edi),%eax
  808bc9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808bcc:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808bcf:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808bd1:	eb 51                	jmp    808c24 <udp_input+0x110>
    if (src == DHCP_SERVER_PORT) {
  808bd3:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808bd8:	0f 85 c8 01 00 00    	jne    808da6 <udp_input+0x292>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808bde:	8b 45 0c             	mov    0xc(%ebp),%eax
  808be1:	8b 40 20             	mov    0x20(%eax),%eax
  808be4:	85 c0                	test   %eax,%eax
  808be6:	0f 84 ba 01 00 00    	je     808da6 <udp_input+0x292>
  808bec:	8b 58 08             	mov    0x8(%eax),%ebx
  808bef:	85 db                	test   %ebx,%ebx
  808bf1:	0f 84 af 01 00 00    	je     808da6 <udp_input+0x292>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808bf7:	8b 43 04             	mov    0x4(%ebx),%eax
  808bfa:	85 c0                	test   %eax,%eax
  808bfc:	0f 84 b4 01 00 00    	je     808db6 <udp_input+0x2a2>
  808c02:	3b 47 0c             	cmp    0xc(%edi),%eax
  808c05:	0f 85 9b 01 00 00    	jne    808da6 <udp_input+0x292>
  808c0b:	e9 a6 01 00 00       	jmp    808db6 <udp_input+0x2a2>
        if ((uncon_pcb == NULL) && 
  808c10:	85 ff                	test   %edi,%edi
  808c12:	74 43                	je     808c57 <udp_input+0x143>
      if ((local_match != 0) &&
  808c14:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808c18:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808c1c:	74 45                	je     808c63 <udp_input+0x14f>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808c1e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808c21:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808c24:	85 db                	test   %ebx,%ebx
  808c26:	0f 84 6d 01 00 00    	je     808d99 <udp_input+0x285>
      if ((pcb->local_port == dest) &&
  808c2c:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808c30:	75 ec                	jne    808c1e <udp_input+0x10a>
          (ip_addr_isany(&pcb->local_ip) ||
  808c32:	8b 03                	mov    (%ebx),%eax
  808c34:	85 c0                	test   %eax,%eax
  808c36:	74 d8                	je     808c10 <udp_input+0xfc>
  808c38:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808c3b:	3b 41 10             	cmp    0x10(%ecx),%eax
  808c3e:	74 d0                	je     808c10 <udp_input+0xfc>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808c40:	83 ec 08             	sub    $0x8,%esp
  808c43:	ff 75 0c             	pushl  0xc(%ebp)
  808c46:	ff 75 d4             	pushl  -0x2c(%ebp)
  808c49:	e8 1d da ff ff       	call   80666b <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808c4e:	83 c4 10             	add    $0x10,%esp
  808c51:	84 c0                	test   %al,%al
  808c53:	74 c9                	je     808c1e <udp_input+0x10a>
  808c55:	eb b9                	jmp    808c10 <udp_input+0xfc>
        if ((uncon_pcb == NULL) && 
  808c57:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808c5b:	83 e0 04             	and    $0x4,%eax
  808c5e:	0f 44 fb             	cmove  %ebx,%edi
  808c61:	eb b1                	jmp    808c14 <udp_input+0x100>
          (ip_addr_isany(&pcb->remote_ip) ||
  808c63:	8b 43 04             	mov    0x4(%ebx),%eax
  808c66:	85 c0                	test   %eax,%eax
  808c68:	74 08                	je     808c72 <udp_input+0x15e>
  808c6a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808c6d:	3b 42 0c             	cmp    0xc(%edx),%eax
  808c70:	75 ac                	jne    808c1e <udp_input+0x10a>
  808c72:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808c75:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808c78:	85 d2                	test   %edx,%edx
  808c7a:	0f 84 36 01 00 00    	je     808db6 <udp_input+0x2a2>
          prev->next = pcb->next;
  808c80:	8b 43 0c             	mov    0xc(%ebx),%eax
  808c83:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808c86:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  808c8b:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808c8e:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  808c94:	e9 1d 01 00 00       	jmp    808db6 <udp_input+0x2a2>
  808c99:	89 c3                	mov    %eax,%ebx
  808c9b:	e9 16 01 00 00       	jmp    808db6 <udp_input+0x2a2>
          pbuf_free(p);
  808ca0:	83 ec 0c             	sub    $0xc,%esp
  808ca3:	ff 75 08             	pushl  0x8(%ebp)
  808ca6:	e8 49 bd ff ff       	call   8049f4 <pbuf_free>
          goto end;
  808cab:	83 c4 10             	add    $0x10,%esp
  808cae:	e9 c9 fe ff ff       	jmp    808b7c <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808cb3:	83 ec 04             	sub    $0x4,%esp
  808cb6:	68 eb 28 81 00       	push   $0x8128eb
  808cbb:	68 0a 01 00 00       	push   $0x10a
  808cc0:	68 16 29 81 00       	push   $0x812916
  808cc5:	e8 3f 5b 00 00       	call   80e809 <_panic>
        pbuf_free(p);
  808cca:	83 ec 0c             	sub    $0xc,%esp
  808ccd:	ff 75 08             	pushl  0x8(%ebp)
  808cd0:	e8 1f bd ff ff       	call   8049f4 <pbuf_free>
        goto end;
  808cd5:	83 c4 10             	add    $0x10,%esp
  808cd8:	e9 9f fe ff ff       	jmp    808b7c <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808cdd:	83 ec 08             	sub    $0x8,%esp
  808ce0:	ff 75 0c             	pushl  0xc(%ebp)
  808ce3:	8d 47 10             	lea    0x10(%edi),%eax
  808ce6:	50                   	push   %eax
  808ce7:	e8 7f d9 ff ff       	call   80666b <ip_addr_isbroadcast>
  808cec:	83 c4 10             	add    $0x10,%esp
  808cef:	84 c0                	test   %al,%al
  808cf1:	75 25                	jne    808d18 <udp_input+0x204>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808cf3:	8b 5f 10             	mov    0x10(%edi),%ebx
  808cf6:	83 ec 0c             	sub    $0xc,%esp
  808cf9:	68 00 00 00 f0       	push   $0xf0000000
  808cfe:	e8 fc ed ff ff       	call   807aff <ntohl>
  808d03:	21 c3                	and    %eax,%ebx
  808d05:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808d0c:	e8 ee ed ff ff       	call   807aff <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808d11:	83 c4 10             	add    $0x10,%esp
  808d14:	39 c3                	cmp    %eax,%ebx
  808d16:	75 13                	jne    808d2b <udp_input+0x217>
      pbuf_free(p);
  808d18:	83 ec 0c             	sub    $0xc,%esp
  808d1b:	ff 75 08             	pushl  0x8(%ebp)
  808d1e:	e8 d1 bc ff ff       	call   8049f4 <pbuf_free>
  808d23:	83 c4 10             	add    $0x10,%esp
  808d26:	e9 51 fe ff ff       	jmp    808b7c <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808d2b:	83 ec 0c             	sub    $0xc,%esp
  808d2e:	0f b7 07             	movzwl (%edi),%eax
  808d31:	50                   	push   %eax
  808d32:	e8 a4 eb ff ff       	call   8078db <ntohs>
  808d37:	83 c4 08             	add    $0x8,%esp
  808d3a:	66 c1 e8 08          	shr    $0x8,%ax
  808d3e:	83 e0 0f             	and    $0xf,%eax
  808d41:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808d48:	98                   	cwtl   
  808d49:	50                   	push   %eax
  808d4a:	ff 75 08             	pushl  0x8(%ebp)
  808d4d:	e8 d5 bb ff ff       	call   804927 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808d52:	83 c4 10             	add    $0x10,%esp
  808d55:	8b 45 08             	mov    0x8(%ebp),%eax
  808d58:	3b 78 04             	cmp    0x4(%eax),%edi
  808d5b:	75 12                	jne    808d6f <udp_input+0x25b>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808d5d:	83 ec 08             	sub    $0x8,%esp
  808d60:	6a 03                	push   $0x3
  808d62:	ff 75 08             	pushl  0x8(%ebp)
  808d65:	e8 cc 57 00 00       	call   80e536 <icmp_dest_unreach>
  808d6a:	83 c4 10             	add    $0x10,%esp
  808d6d:	eb a9                	jmp    808d18 <udp_input+0x204>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808d6f:	83 ec 04             	sub    $0x4,%esp
  808d72:	68 2a 29 81 00       	push   $0x81292a
  808d77:	68 25 01 00 00       	push   $0x125
  808d7c:	68 16 29 81 00       	push   $0x812916
  808d81:	e8 83 5a 00 00       	call   80e809 <_panic>
    pbuf_free(p);
  808d86:	83 ec 0c             	sub    $0xc,%esp
  808d89:	ff 75 08             	pushl  0x8(%ebp)
  808d8c:	e8 63 bc ff ff       	call   8049f4 <pbuf_free>
  808d91:	83 c4 10             	add    $0x10,%esp
}
  808d94:	e9 e3 fd ff ff       	jmp    808b7c <udp_input+0x68>
  808d99:	89 f8                	mov    %edi,%eax
  808d9b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808d9e:	85 c0                	test   %eax,%eax
  808da0:	0f 85 f3 fe ff ff    	jne    808c99 <udp_input+0x185>
  808da6:	8b 45 0c             	mov    0xc(%ebp),%eax
  808da9:	8b 57 10             	mov    0x10(%edi),%edx
  808dac:	bb 00 00 00 00       	mov    $0x0,%ebx
  808db1:	39 50 04             	cmp    %edx,0x4(%eax)
  808db4:	75 d0                	jne    808d86 <udp_input+0x272>
      if (udphdr->chksum != 0) {
  808db6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808db9:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808dbe:	74 29                	je     808de9 <udp_input+0x2d5>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808dc0:	83 ec 0c             	sub    $0xc,%esp
  808dc3:	8b 45 08             	mov    0x8(%ebp),%eax
  808dc6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808dca:	50                   	push   %eax
  808dcb:	6a 11                	push   $0x11
  808dcd:	8d 47 10             	lea    0x10(%edi),%eax
  808dd0:	50                   	push   %eax
  808dd1:	8d 47 0c             	lea    0xc(%edi),%eax
  808dd4:	50                   	push   %eax
  808dd5:	ff 75 08             	pushl  0x8(%ebp)
  808dd8:	e8 cd e7 ff ff       	call   8075aa <inet_chksum_pseudo>
  808ddd:	83 c4 20             	add    $0x20,%esp
  808de0:	66 85 c0             	test   %ax,%ax
  808de3:	0f 85 b7 fe ff ff    	jne    808ca0 <udp_input+0x18c>
    if(pbuf_header(p, -UDP_HLEN)) {
  808de9:	83 ec 08             	sub    $0x8,%esp
  808dec:	6a f8                	push   $0xfffffff8
  808dee:	ff 75 08             	pushl  0x8(%ebp)
  808df1:	e8 31 bb ff ff       	call   804927 <pbuf_header>
  808df6:	83 c4 10             	add    $0x10,%esp
  808df9:	84 c0                	test   %al,%al
  808dfb:	0f 85 b2 fe ff ff    	jne    808cb3 <udp_input+0x19f>
    if (pcb != NULL) {
  808e01:	85 db                	test   %ebx,%ebx
  808e03:	0f 84 d4 fe ff ff    	je     808cdd <udp_input+0x1c9>
      if (pcb->recv != NULL) {
  808e09:	8b 43 18             	mov    0x18(%ebx),%eax
  808e0c:	85 c0                	test   %eax,%eax
  808e0e:	0f 84 b6 fe ff ff    	je     808cca <udp_input+0x1b6>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808e14:	83 ec 0c             	sub    $0xc,%esp
  808e17:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808e1b:	52                   	push   %edx
  808e1c:	83 c7 0c             	add    $0xc,%edi
  808e1f:	57                   	push   %edi
  808e20:	ff 75 08             	pushl  0x8(%ebp)
  808e23:	53                   	push   %ebx
  808e24:	ff 73 1c             	pushl  0x1c(%ebx)
  808e27:	ff d0                	call   *%eax
  808e29:	83 c4 20             	add    $0x20,%esp
  808e2c:	e9 4b fd ff ff       	jmp    808b7c <udp_input+0x68>

00808e31 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808e31:	55                   	push   %ebp
  808e32:	89 e5                	mov    %esp,%ebp
  808e34:	57                   	push   %edi
  808e35:	56                   	push   %esi
  808e36:	53                   	push   %ebx
  808e37:	83 ec 0c             	sub    $0xc,%esp
  808e3a:	8b 55 08             	mov    0x8(%ebp),%edx
  808e3d:	8b 7d 10             	mov    0x10(%ebp),%edi
  808e40:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e42:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  rebind = 0;
  808e47:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808e4c:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e51:	eb 1a                	jmp    808e6d <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808e53:	83 ec 04             	sub    $0x4,%esp
  808e56:	68 3e 29 81 00       	push   $0x81293e
  808e5b:	68 41 02 00 00       	push   $0x241
  808e60:	68 16 29 81 00       	push   $0x812916
  808e65:	e8 9f 59 00 00       	call   80e809 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808e6a:	8b 40 0c             	mov    0xc(%eax),%eax
  808e6d:	85 c0                	test   %eax,%eax
  808e6f:	74 0c                	je     808e7d <udp_bind+0x4c>
    if (pcb == ipcb) {
  808e71:	39 d0                	cmp    %edx,%eax
  808e73:	75 f5                	jne    808e6a <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808e75:	84 db                	test   %bl,%bl
  808e77:	75 da                	jne    808e53 <udp_bind+0x22>
      rebind = 1;
  808e79:	89 f3                	mov    %esi,%ebx
  808e7b:	eb ed                	jmp    808e6a <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808e7d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808e81:	74 05                	je     808e88 <udp_bind+0x57>
  808e83:	8b 45 0c             	mov    0xc(%ebp),%eax
  808e86:	8b 00                	mov    (%eax),%eax
  808e88:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808e8a:	66 85 ff             	test   %di,%di
  808e8d:	75 2e                	jne    808ebd <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808e8f:	8b 35 54 c2 b3 00    	mov    0xb3c254,%esi
  808e95:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808e97:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808e9c:	eb 03                	jmp    808ea1 <udp_bind+0x70>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808e9e:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808ea1:	85 c0                	test   %eax,%eax
  808ea3:	74 14                	je     808eb9 <udp_bind+0x88>
  808ea5:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808eaa:	74 0d                	je     808eb9 <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808eac:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808eb0:	75 ec                	jne    808e9e <udp_bind+0x6d>
        port++;
  808eb2:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808eb5:	89 f0                	mov    %esi,%eax
  808eb7:	eb e8                	jmp    808ea1 <udp_bind+0x70>
    }
    if (ipcb != NULL) {
  808eb9:	85 c0                	test   %eax,%eax
  808ebb:	75 28                	jne    808ee5 <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808ebd:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808ec6:	84 db                	test   %bl,%bl
  808ec8:	75 13                	jne    808edd <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808eca:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  808ecf:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808ed2:	89 15 54 c2 b3 00    	mov    %edx,0xb3c254
  return ERR_OK;
  808ed8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808edd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808ee0:	5b                   	pop    %ebx
  808ee1:	5e                   	pop    %esi
  808ee2:	5f                   	pop    %edi
  808ee3:	5d                   	pop    %ebp
  808ee4:	c3                   	ret    
      return ERR_USE;
  808ee5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808eea:	eb f1                	jmp    808edd <udp_bind+0xac>

00808eec <udp_sendto_if>:
{
  808eec:	55                   	push   %ebp
  808eed:	89 e5                	mov    %esp,%ebp
  808eef:	57                   	push   %edi
  808ef0:	56                   	push   %esi
  808ef1:	53                   	push   %ebx
  808ef2:	83 ec 1c             	sub    $0x1c,%esp
  808ef5:	8b 75 08             	mov    0x8(%ebp),%esi
  808ef8:	8b 45 14             	mov    0x14(%ebp),%eax
  808efb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808efe:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  808f03:	75 19                	jne    808f1e <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808f05:	83 ec 04             	sub    $0x4,%esp
  808f08:	6a 00                	push   $0x0
  808f0a:	56                   	push   %esi
  808f0b:	56                   	push   %esi
  808f0c:	e8 20 ff ff ff       	call   808e31 <udp_bind>
  808f11:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808f13:	83 c4 10             	add    $0x10,%esp
  808f16:	84 c0                	test   %al,%al
  808f18:	0f 85 b7 00 00 00    	jne    808fd5 <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808f1e:	83 ec 08             	sub    $0x8,%esp
  808f21:	6a 08                	push   $0x8
  808f23:	ff 75 0c             	pushl  0xc(%ebp)
  808f26:	e8 fc b9 ff ff       	call   804927 <pbuf_header>
  808f2b:	83 c4 10             	add    $0x10,%esp
    q = p;
  808f2e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808f31:	84 c0                	test   %al,%al
  808f33:	0f 85 a6 00 00 00    	jne    808fdf <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808f39:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808f3e:	0f 86 ca 00 00 00    	jbe    80900e <udp_sendto_if+0x122>
  udphdr = q->payload;
  808f44:	8b 7b 04             	mov    0x4(%ebx),%edi
  udphdr->src = htons(pcb->local_port);
  808f47:	83 ec 0c             	sub    $0xc,%esp
  808f4a:	0f b7 46 12          	movzwl 0x12(%esi),%eax
  808f4e:	50                   	push   %eax
  808f4f:	e8 7a e9 ff ff       	call   8078ce <htons>
  808f54:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808f57:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808f5b:	89 04 24             	mov    %eax,(%esp)
  808f5e:	e8 6b e9 ff ff       	call   8078ce <htons>
  808f63:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808f67:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808f6d:	8b 06                	mov    (%esi),%eax
  808f6f:	83 c4 10             	add    $0x10,%esp
  808f72:	85 c0                	test   %eax,%eax
  808f74:	0f 85 ab 00 00 00    	jne    809025 <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808f7a:	8b 45 18             	mov    0x18(%ebp),%eax
  808f7d:	83 c0 04             	add    $0x4,%eax
  808f80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808f83:	83 ec 0c             	sub    $0xc,%esp
  808f86:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808f8a:	50                   	push   %eax
  808f8b:	e8 3e e9 ff ff       	call   8078ce <htons>
  808f90:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808f94:	83 c4 10             	add    $0x10,%esp
  808f97:	f6 46 10 01          	testb  $0x1,0x10(%esi)
  808f9b:	0f 84 ac 00 00 00    	je     80904d <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808fa1:	83 ec 04             	sub    $0x4,%esp
  808fa4:	ff 75 18             	pushl  0x18(%ebp)
  808fa7:	6a 11                	push   $0x11
  808fa9:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808fad:	50                   	push   %eax
  808fae:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808fb2:	50                   	push   %eax
  808fb3:	ff 75 10             	pushl  0x10(%ebp)
  808fb6:	ff 75 e4             	pushl  -0x1c(%ebp)
  808fb9:	53                   	push   %ebx
  808fba:	e8 72 da ff ff       	call   806a31 <ip_output_if>
  808fbf:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808fc1:	83 c4 20             	add    $0x20,%esp
  808fc4:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808fc7:	74 0c                	je     808fd5 <udp_sendto_if+0xe9>
    pbuf_free(q);
  808fc9:	83 ec 0c             	sub    $0xc,%esp
  808fcc:	53                   	push   %ebx
  808fcd:	e8 22 ba ff ff       	call   8049f4 <pbuf_free>
  808fd2:	83 c4 10             	add    $0x10,%esp
}
  808fd5:	89 f8                	mov    %edi,%eax
  808fd7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808fda:	5b                   	pop    %ebx
  808fdb:	5e                   	pop    %esi
  808fdc:	5f                   	pop    %edi
  808fdd:	5d                   	pop    %ebp
  808fde:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808fdf:	83 ec 04             	sub    $0x4,%esp
  808fe2:	6a 00                	push   $0x0
  808fe4:	6a 08                	push   $0x8
  808fe6:	6a 01                	push   $0x1
  808fe8:	e8 cd ba ff ff       	call   804aba <pbuf_alloc>
  808fed:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808fef:	83 c4 10             	add    $0x10,%esp
  808ff2:	85 c0                	test   %eax,%eax
  808ff4:	0f 84 80 00 00 00    	je     80907a <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808ffa:	83 ec 08             	sub    $0x8,%esp
  808ffd:	ff 75 0c             	pushl  0xc(%ebp)
  809000:	50                   	push   %eax
  809001:	e8 cf be ff ff       	call   804ed5 <pbuf_chain>
  809006:	83 c4 10             	add    $0x10,%esp
  809009:	e9 2b ff ff ff       	jmp    808f39 <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80900e:	83 ec 04             	sub    $0x4,%esp
  809011:	68 4c 29 81 00       	push   $0x81294c
  809016:	68 b2 01 00 00       	push   $0x1b2
  80901b:	68 16 29 81 00       	push   $0x812916
  809020:	e8 e4 57 00 00       	call   80e809 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  809025:	8b 4d 18             	mov    0x18(%ebp),%ecx
  809028:	3b 41 04             	cmp    0x4(%ecx),%eax
  80902b:	75 08                	jne    809035 <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  80902d:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  809030:	e9 4e ff ff ff       	jmp    808f83 <udp_sendto_if+0x97>
      return ERR_VAL;
  809035:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  80903a:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  80903d:	74 96                	je     808fd5 <udp_sendto_if+0xe9>
        pbuf_free(q);
  80903f:	83 ec 0c             	sub    $0xc,%esp
  809042:	53                   	push   %ebx
  809043:	e8 ac b9 ff ff       	call   8049f4 <pbuf_free>
  809048:	83 c4 10             	add    $0x10,%esp
  80904b:	eb 88                	jmp    808fd5 <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80904d:	83 ec 0c             	sub    $0xc,%esp
  809050:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809054:	50                   	push   %eax
  809055:	6a 11                	push   $0x11
  809057:	ff 75 10             	pushl  0x10(%ebp)
  80905a:	ff 75 e4             	pushl  -0x1c(%ebp)
  80905d:	53                   	push   %ebx
  80905e:	e8 47 e5 ff ff       	call   8075aa <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  809063:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  809066:	66 85 c0             	test   %ax,%ax
  809069:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80906e:	0f 44 c2             	cmove  %edx,%eax
  809071:	66 89 47 06          	mov    %ax,0x6(%edi)
  809075:	e9 27 ff ff ff       	jmp    808fa1 <udp_sendto_if+0xb5>
      return ERR_MEM;
  80907a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80907f:	e9 51 ff ff ff       	jmp    808fd5 <udp_sendto_if+0xe9>

00809084 <udp_sendto>:
{
  809084:	55                   	push   %ebp
  809085:	89 e5                	mov    %esp,%ebp
  809087:	56                   	push   %esi
  809088:	53                   	push   %ebx
  809089:	8b 75 10             	mov    0x10(%ebp),%esi
  80908c:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  80908f:	83 ec 0c             	sub    $0xc,%esp
  809092:	56                   	push   %esi
  809093:	e8 16 d6 ff ff       	call   8066ae <ip_route>
  if (netif == NULL) {
  809098:	83 c4 10             	add    $0x10,%esp
  80909b:	85 c0                	test   %eax,%eax
  80909d:	74 1e                	je     8090bd <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80909f:	83 ec 0c             	sub    $0xc,%esp
  8090a2:	50                   	push   %eax
  8090a3:	0f b7 db             	movzwl %bx,%ebx
  8090a6:	53                   	push   %ebx
  8090a7:	56                   	push   %esi
  8090a8:	ff 75 0c             	pushl  0xc(%ebp)
  8090ab:	ff 75 08             	pushl  0x8(%ebp)
  8090ae:	e8 39 fe ff ff       	call   808eec <udp_sendto_if>
  8090b3:	83 c4 20             	add    $0x20,%esp
}
  8090b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8090b9:	5b                   	pop    %ebx
  8090ba:	5e                   	pop    %esi
  8090bb:	5d                   	pop    %ebp
  8090bc:	c3                   	ret    
    return ERR_RTE;
  8090bd:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8090c2:	eb f2                	jmp    8090b6 <udp_sendto+0x32>

008090c4 <udp_send>:
{
  8090c4:	55                   	push   %ebp
  8090c5:	89 e5                	mov    %esp,%ebp
  8090c7:	83 ec 08             	sub    $0x8,%esp
  8090ca:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  8090cd:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  8090d1:	52                   	push   %edx
  8090d2:	8d 50 04             	lea    0x4(%eax),%edx
  8090d5:	52                   	push   %edx
  8090d6:	ff 75 0c             	pushl  0xc(%ebp)
  8090d9:	50                   	push   %eax
  8090da:	e8 a5 ff ff ff       	call   809084 <udp_sendto>
}
  8090df:	c9                   	leave  
  8090e0:	c3                   	ret    

008090e1 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8090e1:	55                   	push   %ebp
  8090e2:	89 e5                	mov    %esp,%ebp
  8090e4:	57                   	push   %edi
  8090e5:	56                   	push   %esi
  8090e6:	53                   	push   %ebx
  8090e7:	83 ec 0c             	sub    $0xc,%esp
  8090ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8090ed:	8b 75 0c             	mov    0xc(%ebp),%esi
  8090f0:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8090f3:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  8090f8:	74 2b                	je     809125 <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  8090fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8090ff:	85 f6                	test   %esi,%esi
  809101:	74 02                	je     809105 <udp_connect+0x24>
  809103:	8b 06                	mov    (%esi),%eax
  809105:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  809108:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80910c:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809110:	8b 15 54 c2 b3 00    	mov    0xb3c254,%edx
  809116:	89 d0                	mov    %edx,%eax
  809118:	85 c0                	test   %eax,%eax
  80911a:	74 1e                	je     80913a <udp_connect+0x59>
    if (pcb == ipcb) {
  80911c:	39 d8                	cmp    %ebx,%eax
  80911e:	74 2b                	je     80914b <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809120:	8b 40 0c             	mov    0xc(%eax),%eax
  809123:	eb f3                	jmp    809118 <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809125:	83 ec 04             	sub    $0x4,%esp
  809128:	6a 00                	push   $0x0
  80912a:	53                   	push   %ebx
  80912b:	53                   	push   %ebx
  80912c:	e8 00 fd ff ff       	call   808e31 <udp_bind>
    if (err != ERR_OK)
  809131:	83 c4 10             	add    $0x10,%esp
  809134:	84 c0                	test   %al,%al
  809136:	74 c2                	je     8090fa <udp_connect+0x19>
  809138:	eb 09                	jmp    809143 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80913a:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80913d:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  return ERR_OK;
}
  809143:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809146:	5b                   	pop    %ebx
  809147:	5e                   	pop    %esi
  809148:	5f                   	pop    %edi
  809149:	5d                   	pop    %ebp
  80914a:	c3                   	ret    
      return ERR_OK;
  80914b:	b8 00 00 00 00       	mov    $0x0,%eax
  809150:	eb f1                	jmp    809143 <udp_connect+0x62>

00809152 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  809152:	55                   	push   %ebp
  809153:	89 e5                	mov    %esp,%ebp
  809155:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  809158:	8b 15 88 25 81 00    	mov    0x812588,%edx
  80915e:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  809161:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  809167:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80916b:	5d                   	pop    %ebp
  80916c:	c3                   	ret    

0080916d <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80916d:	55                   	push   %ebp
  80916e:	89 e5                	mov    %esp,%ebp
  809170:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809173:	8b 55 0c             	mov    0xc(%ebp),%edx
  809176:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809179:	8b 55 10             	mov    0x10(%ebp),%edx
  80917c:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80917f:	5d                   	pop    %ebp
  809180:	c3                   	ret    

00809181 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809181:	55                   	push   %ebp
  809182:	89 e5                	mov    %esp,%ebp
  809184:	83 ec 08             	sub    $0x8,%esp
  809187:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80918a:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  80918f:	39 c8                	cmp    %ecx,%eax
  809191:	75 1b                	jne    8091ae <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809193:	8b 41 0c             	mov    0xc(%ecx),%eax
  809196:	a3 54 c2 b3 00       	mov    %eax,0xb3c254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80919b:	83 ec 08             	sub    $0x8,%esp
  80919e:	51                   	push   %ecx
  80919f:	6a 01                	push   $0x1
  8091a1:	e8 01 b5 ff ff       	call   8046a7 <memp_free>
}
  8091a6:	83 c4 10             	add    $0x10,%esp
  8091a9:	c9                   	leave  
  8091aa:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8091ab:	8b 40 0c             	mov    0xc(%eax),%eax
  8091ae:	85 c0                	test   %eax,%eax
  8091b0:	74 e9                	je     80919b <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  8091b2:	8b 50 0c             	mov    0xc(%eax),%edx
  8091b5:	39 ca                	cmp    %ecx,%edx
  8091b7:	75 f2                	jne    8091ab <udp_remove+0x2a>
  8091b9:	85 d2                	test   %edx,%edx
  8091bb:	74 ee                	je     8091ab <udp_remove+0x2a>
        pcb2->next = pcb->next;
  8091bd:	8b 51 0c             	mov    0xc(%ecx),%edx
  8091c0:	89 50 0c             	mov    %edx,0xc(%eax)
  8091c3:	eb e6                	jmp    8091ab <udp_remove+0x2a>

008091c5 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8091c5:	55                   	push   %ebp
  8091c6:	89 e5                	mov    %esp,%ebp
  8091c8:	53                   	push   %ebx
  8091c9:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8091cc:	6a 01                	push   $0x1
  8091ce:	e8 7e b4 ff ff       	call   804651 <memp_malloc>
  8091d3:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  8091d5:	83 c4 10             	add    $0x10,%esp
  8091d8:	85 c0                	test   %eax,%eax
  8091da:	74 14                	je     8091f0 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  8091dc:	83 ec 04             	sub    $0x4,%esp
  8091df:	6a 20                	push   $0x20
  8091e1:	6a 00                	push   $0x0
  8091e3:	50                   	push   %eax
  8091e4:	e8 bb 5f 00 00       	call   80f1a4 <memset>
    pcb->ttl = UDP_TTL;
  8091e9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  8091ed:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  8091f0:	89 d8                	mov    %ebx,%eax
  8091f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8091f5:	c9                   	leave  
  8091f6:	c3                   	ret    

008091f7 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8091f7:	55                   	push   %ebp
  8091f8:	89 e5                	mov    %esp,%ebp
  8091fa:	56                   	push   %esi
  8091fb:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8091fc:	85 c0                	test   %eax,%eax
  8091fe:	74 35                	je     809235 <free_etharp_q+0x3e>
  809200:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809202:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  809206:	74 44                	je     80924c <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  809208:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80920a:	8b 43 04             	mov    0x4(%ebx),%eax
  80920d:	85 c0                	test   %eax,%eax
  80920f:	74 52                	je     809263 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  809211:	83 ec 0c             	sub    $0xc,%esp
  809214:	50                   	push   %eax
  809215:	e8 da b7 ff ff       	call   8049f4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80921a:	83 c4 08             	add    $0x8,%esp
  80921d:	53                   	push   %ebx
  80921e:	6a 0a                	push   $0xa
  809220:	e8 82 b4 ff ff       	call   8046a7 <memp_free>
    q = q->next;
  809225:	89 f3                	mov    %esi,%ebx
  while (q) {
  809227:	83 c4 10             	add    $0x10,%esp
  80922a:	85 f6                	test   %esi,%esi
  80922c:	75 da                	jne    809208 <free_etharp_q+0x11>
  }
}
  80922e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809231:	5b                   	pop    %ebx
  809232:	5e                   	pop    %esi
  809233:	5d                   	pop    %ebp
  809234:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  809235:	83 ec 04             	sub    $0x4,%esp
  809238:	68 8c 20 81 00       	push   $0x81208c
  80923d:	68 93 00 00 00       	push   $0x93
  809242:	68 7a 29 81 00       	push   $0x81297a
  809247:	e8 bd 55 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80924c:	83 ec 04             	sub    $0x4,%esp
  80924f:	68 92 29 81 00       	push   $0x812992
  809254:	68 94 00 00 00       	push   $0x94
  809259:	68 7a 29 81 00       	push   $0x81297a
  80925e:	e8 a6 55 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  809263:	83 ec 04             	sub    $0x4,%esp
  809266:	68 9f 29 81 00       	push   $0x81299f
  80926b:	68 98 00 00 00       	push   $0x98
  809270:	68 7a 29 81 00       	push   $0x81297a
  809275:	e8 8f 55 00 00       	call   80e809 <_panic>

0080927a <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80927a:	55                   	push   %ebp
  80927b:	89 e5                	mov    %esp,%ebp
  80927d:	57                   	push   %edi
  80927e:	56                   	push   %esi
  80927f:	53                   	push   %ebx
  809280:	83 ec 1c             	sub    $0x1c,%esp
  809283:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809286:	85 c0                	test   %eax,%eax
  809288:	0f 84 e9 00 00 00    	je     809377 <find_entry+0xfd>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80928e:	0f b6 15 00 5a b3 00 	movzbl 0xb35a00,%edx
  809295:	0f b6 ca             	movzbl %dl,%ecx
  809298:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  80929b:	83 bb 30 5a b3 00 02 	cmpl   $0x2,0xb35a30(%ebx)
  8092a2:	0f 84 9f 00 00 00    	je     809347 <find_entry+0xcd>
  8092a8:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8092ac:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  8092b0:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8092b4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8092b8:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8092bc:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8092c0:	ba 00 00 00 00       	mov    $0x0,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8092c5:	0f b6 ca             	movzbl %dl,%ecx
  8092c8:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  8092cb:	83 b9 30 5a b3 00 00 	cmpl   $0x0,0xb35a30(%ecx)
  8092d2:	0f 85 c1 00 00 00    	jne    809399 <find_entry+0x11f>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8092d8:	89 d1                	mov    %edx,%ecx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8092da:	83 c2 01             	add    $0x1,%edx
  8092dd:	80 fa 09             	cmp    $0x9,%dl
  8092e0:	0f 86 02 01 00 00    	jbe    8093e8 <find_entry+0x16e>
  8092e6:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8092e9:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8092eb:	80 f9 0a             	cmp    $0xa,%cl
  8092ee:	0f 84 69 01 00 00    	je     80945d <find_entry+0x1e3>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8092f4:	f6 c2 02             	test   $0x2,%dl
  8092f7:	0f 85 ff 01 00 00    	jne    8094fc <find_entry+0x282>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  8092fd:	89 ce                	mov    %ecx,%esi
  if (empty < ARP_TABLE_SIZE) {
  8092ff:	80 f9 09             	cmp    $0x9,%cl
  809302:	0f 8f 67 01 00 00    	jg     80946f <find_entry+0x1f5>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809308:	89 f0                	mov    %esi,%eax
  80930a:	3c 09                	cmp    $0x9,%al
  80930c:	0f 87 c9 01 00 00    	ja     8094db <find_entry+0x261>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  809312:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809315:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809318:	c7 82 30 5a b3 00 00 	movl   $0x0,0xb35a30(%edx)
  80931f:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809322:	85 db                	test   %ebx,%ebx
  809324:	74 08                	je     80932e <find_entry+0xb4>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809326:	8b 0b                	mov    (%ebx),%ecx
  809328:	89 8a 24 5a b3 00    	mov    %ecx,0xb35a24(%edx)
  }
  arp_table[i].ctime = 0;
  80932e:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809331:	c6 80 34 5a b3 00 00 	movb   $0x0,0xb35a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809338:	89 f0                	mov    %esi,%eax
  80933a:	a2 00 5a b3 00       	mov    %al,0xb35a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80933f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809342:	5b                   	pop    %ebx
  809343:	5e                   	pop    %esi
  809344:	5f                   	pop    %edi
  809345:	5d                   	pop    %ebp
  809346:	c3                   	ret    
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  809347:	8b bb 24 5a b3 00    	mov    0xb35a24(%ebx),%edi
  80934d:	39 38                	cmp    %edi,(%eax)
  80934f:	74 22                	je     809373 <find_entry+0xf9>
  809351:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809355:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809359:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80935d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809361:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809365:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809369:	ba 00 00 00 00       	mov    $0x0,%edx
  80936e:	e9 52 ff ff ff       	jmp    8092c5 <find_entry+0x4b>
        return etharp_cached_entry;
  809373:	89 d0                	mov    %edx,%eax
  809375:	eb c8                	jmp    80933f <find_entry+0xc5>
  809377:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80937b:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80937f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809383:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  809387:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  80938b:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80938f:	ba 00 00 00 00       	mov    $0x0,%edx
  809394:	e9 2c ff ff ff       	jmp    8092c5 <find_entry+0x4b>
  809399:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80939e:	eb 48                	jmp    8093e8 <find_entry+0x16e>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8093a0:	85 c0                	test   %eax,%eax
  8093a2:	74 0d                	je     8093b1 <find_entry+0x137>
  8093a4:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8093a7:	8b be 24 5a b3 00    	mov    0xb35a24(%esi),%edi
  8093ad:	39 38                	cmp    %edi,(%eax)
  8093af:	74 79                	je     80942a <find_entry+0x1b0>
      } else if (arp_table[i].q != NULL) {
  8093b1:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8093b4:	83 be 20 5a b3 00 00 	cmpl   $0x0,0xb35a20(%esi)
  8093bb:	74 7a                	je     809437 <find_entry+0x1bd>
        if (arp_table[i].ctime >= age_queue) {
  8093bd:	0f b6 9e 34 5a b3 00 	movzbl 0xb35a34(%esi),%ebx
  8093c4:	89 cf                	mov    %ecx,%edi
  8093c6:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  8093c9:	72 06                	jb     8093d1 <find_entry+0x157>
          old_queue = i;
  8093cb:	88 55 e3             	mov    %dl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  8093ce:	88 5d e7             	mov    %bl,-0x19(%ebp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8093d1:	83 c2 01             	add    $0x1,%edx
  8093d4:	80 fa 09             	cmp    $0x9,%dl
  8093d7:	0f 87 09 ff ff ff    	ja     8092e6 <find_entry+0x6c>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8093dd:	80 f9 0a             	cmp    $0xa,%cl
  8093e0:	0f 84 df fe ff ff    	je     8092c5 <find_entry+0x4b>
  8093e6:	89 f9                	mov    %edi,%ecx
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8093e8:	0f b6 da             	movzbl %dl,%ebx
  8093eb:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  8093ee:	8b b6 30 5a b3 00    	mov    0xb35a30(%esi),%esi
  8093f4:	83 fe 01             	cmp    $0x1,%esi
  8093f7:	74 a7                	je     8093a0 <find_entry+0x126>
  8093f9:	89 cf                	mov    %ecx,%edi
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8093fb:	83 fe 02             	cmp    $0x2,%esi
  8093fe:	75 d1                	jne    8093d1 <find_entry+0x157>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809400:	85 c0                	test   %eax,%eax
  809402:	74 0d                	je     809411 <find_entry+0x197>
  809404:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809407:	8b be 24 5a b3 00    	mov    0xb35a24(%esi),%edi
  80940d:	39 38                	cmp    %edi,(%eax)
  80940f:	74 3f                	je     809450 <find_entry+0x1d6>
      } else if (arp_table[i].ctime >= age_stable) {
  809411:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  809414:	0f b6 9b 34 5a b3 00 	movzbl 0xb35a34(%ebx),%ebx
  80941b:	89 cf                	mov    %ecx,%edi
  80941d:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  809420:	72 af                	jb     8093d1 <find_entry+0x157>
        old_stable = i;
  809422:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  809425:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  809428:	eb a7                	jmp    8093d1 <find_entry+0x157>
        etharp_cached_entry = i;
  80942a:	88 15 00 5a b3 00    	mov    %dl,0xb35a00
        return i;
  809430:	89 d0                	mov    %edx,%eax
  809432:	e9 08 ff ff ff       	jmp    80933f <find_entry+0xc5>
        if (arp_table[i].ctime >= age_pending) {
  809437:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80943a:	0f b6 9b 34 5a b3 00 	movzbl 0xb35a34(%ebx),%ebx
  809441:	89 cf                	mov    %ecx,%edi
  809443:	3a 5d e4             	cmp    -0x1c(%ebp),%bl
  809446:	72 89                	jb     8093d1 <find_entry+0x157>
          old_pending = i;
  809448:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  80944b:	88 5d e4             	mov    %bl,-0x1c(%ebp)
  80944e:	eb 81                	jmp    8093d1 <find_entry+0x157>
        etharp_cached_entry = i;
  809450:	88 15 00 5a b3 00    	mov    %dl,0xb35a00
        return i;
  809456:	89 d0                	mov    %edx,%eax
  809458:	e9 e2 fe ff ff       	jmp    80933f <find_entry+0xc5>
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80945d:	f6 c2 01             	test   $0x1,%dl
  809460:	0f 84 8c 00 00 00    	je     8094f2 <find_entry+0x278>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809466:	f6 c2 02             	test   $0x2,%dl
  809469:	0f 85 a1 00 00 00    	jne    809510 <find_entry+0x296>
  else if (old_stable < ARP_TABLE_SIZE) {
  80946f:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809473:	3c 09                	cmp    $0x9,%al
  809475:	7f 2c                	jg     8094a3 <find_entry+0x229>
    i = old_stable;
  809477:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809479:	0f b6 c0             	movzbl %al,%eax
  80947c:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80947f:	83 b8 20 5a b3 00 00 	cmpl   $0x0,0xb35a20(%eax)
  809486:	0f 84 7c fe ff ff    	je     809308 <find_entry+0x8e>
  80948c:	83 ec 04             	sub    $0x4,%esp
  80948f:	68 ac 29 81 00       	push   $0x8129ac
  809494:	68 75 01 00 00       	push   $0x175
  809499:	68 7a 29 81 00       	push   $0x81297a
  80949e:	e8 66 53 00 00       	call   80e809 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  8094a3:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    i = old_pending;
  8094a7:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  8094a9:	3c 09                	cmp    $0x9,%al
  8094ab:	0f 8e 57 fe ff ff    	jle    809308 <find_entry+0x8e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  8094b1:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  8094b5:	3c 09                	cmp    $0x9,%al
  8094b7:	7f 4d                	jg     809506 <find_entry+0x28c>
    i = old_queue;
  8094b9:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  8094bb:	0f b6 f8             	movzbl %al,%edi
  8094be:	6b ff 1c             	imul   $0x1c,%edi,%edi
  8094c1:	8b 87 20 5a b3 00    	mov    0xb35a20(%edi),%eax
  8094c7:	e8 2b fd ff ff       	call   8091f7 <free_etharp_q>
    arp_table[i].q = NULL;
  8094cc:	c7 87 20 5a b3 00 00 	movl   $0x0,0xb35a20(%edi)
  8094d3:	00 00 00 
  8094d6:	e9 2d fe ff ff       	jmp    809308 <find_entry+0x8e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  8094db:	83 ec 04             	sub    $0x4,%esp
  8094de:	68 c3 29 81 00       	push   $0x8129c3
  8094e3:	68 8b 01 00 00       	push   $0x18b
  8094e8:	68 7a 29 81 00       	push   $0x81297a
  8094ed:	e8 17 53 00 00       	call   80e809 <_panic>
    return (s8_t)ERR_MEM;
  8094f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8094f7:	e9 43 fe ff ff       	jmp    80933f <find_entry+0xc5>
  8094fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809501:	e9 39 fe ff ff       	jmp    80933f <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  809506:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80950b:	e9 2f fe ff ff       	jmp    80933f <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  809510:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809515:	e9 25 fe ff ff       	jmp    80933f <find_entry+0xc5>

0080951a <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80951a:	55                   	push   %ebp
  80951b:	89 e5                	mov    %esp,%ebp
  80951d:	57                   	push   %edi
  80951e:	56                   	push   %esi
  80951f:	53                   	push   %ebx
  809520:	83 ec 1c             	sub    $0x1c,%esp
  809523:	89 d7                	mov    %edx,%edi
  809525:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  809528:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80952b:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80952f:	75 45                	jne    809576 <etharp_send_ip+0x5c>
  809531:	89 c6                	mov    %eax,%esi
  809533:	b8 05 00 00 00       	mov    $0x5,%eax
  809538:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  80953b:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  80953f:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809542:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809545:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809549:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  80954d:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809550:	83 f8 ff             	cmp    $0xffffffff,%eax
  809553:	75 e6                	jne    80953b <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809555:	83 ec 0c             	sub    $0xc,%esp
  809558:	68 00 08 00 00       	push   $0x800
  80955d:	e8 6c e3 ff ff       	call   8078ce <htons>
  809562:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809566:	83 c4 08             	add    $0x8,%esp
  809569:	57                   	push   %edi
  80956a:	56                   	push   %esi
  80956b:	ff 56 18             	call   *0x18(%esi)
}
  80956e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809571:	5b                   	pop    %ebx
  809572:	5e                   	pop    %esi
  809573:	5f                   	pop    %edi
  809574:	5d                   	pop    %ebp
  809575:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809576:	83 ec 04             	sub    $0x4,%esp
  809579:	68 f0 29 81 00       	push   $0x8129f0
  80957e:	68 b3 01 00 00       	push   $0x1b3
  809583:	68 7a 29 81 00       	push   $0x81297a
  809588:	e8 7c 52 00 00       	call   80e809 <_panic>

0080958d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80958d:	55                   	push   %ebp
  80958e:	89 e5                	mov    %esp,%ebp
  809590:	57                   	push   %edi
  809591:	56                   	push   %esi
  809592:	53                   	push   %ebx
  809593:	83 ec 1c             	sub    $0x1c,%esp
  809596:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809599:	89 cb                	mov    %ecx,%ebx
  80959b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80959e:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  8095a1:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8095a5:	0f 85 e9 00 00 00    	jne    809694 <update_arp_entry+0x107>
  8095ab:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  8095ad:	85 d2                	test   %edx,%edx
  8095af:	0f 84 f6 00 00 00    	je     8096ab <update_arp_entry+0x11e>
  8095b5:	83 3a 00             	cmpl   $0x0,(%edx)
  8095b8:	0f 84 f4 00 00 00    	je     8096b2 <update_arp_entry+0x125>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8095be:	83 ec 08             	sub    $0x8,%esp
  8095c1:	ff 75 e4             	pushl  -0x1c(%ebp)
  8095c4:	52                   	push   %edx
  8095c5:	e8 a1 d0 ff ff       	call   80666b <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  8095ca:	83 c4 10             	add    $0x10,%esp
  8095cd:	84 c0                	test   %al,%al
  8095cf:	0f 85 ea 00 00 00    	jne    8096bf <update_arp_entry+0x132>
      ip_addr_ismulticast(ipaddr)) {
  8095d5:	8b 3e                	mov    (%esi),%edi
  8095d7:	83 ec 0c             	sub    $0xc,%esp
  8095da:	68 00 00 00 f0       	push   $0xf0000000
  8095df:	e8 1b e5 ff ff       	call   807aff <ntohl>
  8095e4:	21 c7                	and    %eax,%edi
  8095e6:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8095ed:	e8 0d e5 ff ff       	call   807aff <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  8095f2:	83 c4 10             	add    $0x10,%esp
  8095f5:	39 c7                	cmp    %eax,%edi
  8095f7:	0f 84 c9 00 00 00    	je     8096c6 <update_arp_entry+0x139>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  8095fd:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809601:	89 f0                	mov    %esi,%eax
  809603:	e8 72 fc ff ff       	call   80927a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809608:	84 c0                	test   %al,%al
  80960a:	0f 88 a7 00 00 00    	js     8096b7 <update_arp_entry+0x12a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809610:	0f be c0             	movsbl %al,%eax
  809613:	6b f0 1c             	imul   $0x1c,%eax,%esi
  809616:	c7 86 30 5a b3 00 02 	movl   $0x2,0xb35a30(%esi)
  80961d:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809620:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809623:	89 8e 38 5a b3 00    	mov    %ecx,0xb35a38(%esi)
  809629:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80962e:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  809633:	88 8c 16 2d 5a b3 00 	mov    %cl,0xb35a2d(%esi,%edx,1)
  80963a:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  80963d:	83 fa fa             	cmp    $0xfffffffa,%edx
  809640:	75 ec                	jne    80962e <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809642:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809645:	c6 82 34 5a b3 00 00 	movb   $0x0,0xb35a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80964c:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80964e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809651:	83 c0 25             	add    $0x25,%eax
  809654:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  809657:	8b 86 20 5a b3 00    	mov    0xb35a20(%esi),%eax
  80965d:	85 c0                	test   %eax,%eax
  80965f:	74 56                	je     8096b7 <update_arp_entry+0x12a>
    arp_table[i].q = q->next;
  809661:	8b 10                	mov    (%eax),%edx
  809663:	89 96 20 5a b3 00    	mov    %edx,0xb35a20(%esi)
    p = q->p;
  809669:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  80966c:	83 ec 08             	sub    $0x8,%esp
  80966f:	50                   	push   %eax
  809670:	6a 0a                	push   $0xa
  809672:	e8 30 b0 ff ff       	call   8046a7 <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809677:	89 1c 24             	mov    %ebx,(%esp)
  80967a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80967d:	89 fa                	mov    %edi,%edx
  80967f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809682:	e8 93 fe ff ff       	call   80951a <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809687:	89 3c 24             	mov    %edi,(%esp)
  80968a:	e8 65 b3 ff ff       	call   8049f4 <pbuf_free>
  80968f:	83 c4 10             	add    $0x10,%esp
  809692:	eb c3                	jmp    809657 <update_arp_entry+0xca>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809694:	83 ec 04             	sub    $0x4,%esp
  809697:	68 34 2a 81 00       	push   $0x812a34
  80969c:	68 d9 01 00 00       	push   $0x1d9
  8096a1:	68 7a 29 81 00       	push   $0x81297a
  8096a6:	e8 5e 51 00 00       	call   80e809 <_panic>
    return ERR_ARG;
  8096ab:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8096b0:	eb 05                	jmp    8096b7 <update_arp_entry+0x12a>
  8096b2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  }
#endif
  return ERR_OK;
}
  8096b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8096ba:	5b                   	pop    %ebx
  8096bb:	5e                   	pop    %esi
  8096bc:	5f                   	pop    %edi
  8096bd:	5d                   	pop    %ebp
  8096be:	c3                   	ret    
    return ERR_ARG;
  8096bf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8096c4:	eb f1                	jmp    8096b7 <update_arp_entry+0x12a>
  8096c6:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8096cb:	eb ea                	jmp    8096b7 <update_arp_entry+0x12a>

008096cd <etharp_tmr>:
{
  8096cd:	55                   	push   %ebp
  8096ce:	89 e5                	mov    %esp,%ebp
  8096d0:	57                   	push   %edi
  8096d1:	56                   	push   %esi
  8096d2:	53                   	push   %ebx
  8096d3:	83 ec 0c             	sub    $0xc,%esp
  8096d6:	bb 20 5a b3 00       	mov    $0xb35a20,%ebx
  8096db:	bf 38 5b b3 00       	mov    $0xb35b38,%edi
  8096e0:	eb 1f                	jmp    809701 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  8096e2:	8b 06                	mov    (%esi),%eax
  8096e4:	85 c0                	test   %eax,%eax
  8096e6:	74 0b                	je     8096f3 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  8096e8:	e8 0a fb ff ff       	call   8091f7 <free_etharp_q>
        arp_table[i].q = NULL;
  8096ed:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8096f3:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  8096fa:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8096fd:	39 fb                	cmp    %edi,%ebx
  8096ff:	74 23                	je     809724 <etharp_tmr+0x57>
  809701:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  809703:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  809707:	83 c0 01             	add    $0x1,%eax
  80970a:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80970d:	8b 53 10             	mov    0x10(%ebx),%edx
  809710:	3c ef                	cmp    $0xef,%al
  809712:	76 05                	jbe    809719 <etharp_tmr+0x4c>
  809714:	83 fa 02             	cmp    $0x2,%edx
  809717:	74 c9                	je     8096e2 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809719:	3c 01                	cmp    $0x1,%al
  80971b:	76 dd                	jbe    8096fa <etharp_tmr+0x2d>
  80971d:	83 fa 01             	cmp    $0x1,%edx
  809720:	75 d8                	jne    8096fa <etharp_tmr+0x2d>
  809722:	eb be                	jmp    8096e2 <etharp_tmr+0x15>
}
  809724:	83 c4 0c             	add    $0xc,%esp
  809727:	5b                   	pop    %ebx
  809728:	5e                   	pop    %esi
  809729:	5f                   	pop    %edi
  80972a:	5d                   	pop    %ebp
  80972b:	c3                   	ret    

0080972c <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80972c:	55                   	push   %ebp
  80972d:	89 e5                	mov    %esp,%ebp
  80972f:	53                   	push   %ebx
  809730:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809733:	ba 02 00 00 00       	mov    $0x2,%edx
  809738:	8b 45 0c             	mov    0xc(%ebp),%eax
  80973b:	e8 3a fb ff ff       	call   80927a <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809740:	84 c0                	test   %al,%al
  809742:	78 31                	js     809775 <etharp_find_addr+0x49>
  809744:	0f be d0             	movsbl %al,%edx
  809747:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80974a:	83 ba 30 5a b3 00 02 	cmpl   $0x2,0xb35a30(%edx)
  809751:	75 29                	jne    80977c <etharp_find_addr+0x50>
  809753:	0f be d0             	movsbl %al,%edx
  809756:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  809759:	8d 9a 28 5a b3 00    	lea    0xb35a28(%edx),%ebx
  80975f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809762:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809764:	81 c2 24 5a b3 00    	add    $0xb35a24,%edx
  80976a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80976d:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  80976f:	83 c4 04             	add    $0x4,%esp
  809772:	5b                   	pop    %ebx
  809773:	5d                   	pop    %ebp
  809774:	c3                   	ret    
  return -1;
  809775:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80977a:	eb f3                	jmp    80976f <etharp_find_addr+0x43>
  80977c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809781:	eb ec                	jmp    80976f <etharp_find_addr+0x43>

00809783 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809783:	55                   	push   %ebp
  809784:	89 e5                	mov    %esp,%ebp
  809786:	83 ec 08             	sub    $0x8,%esp
  809789:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80978c:	85 c0                	test   %eax,%eax
  80978e:	74 13                	je     8097a3 <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809790:	8b 55 0c             	mov    0xc(%ebp),%edx
  809793:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809796:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  809799:	33 48 04             	xor    0x4(%eax),%ecx
  80979c:	85 48 08             	test   %ecx,0x8(%eax)
  80979f:	74 19                	je     8097ba <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  8097a1:	c9                   	leave  
  8097a2:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8097a3:	83 ec 04             	sub    $0x4,%esp
  8097a6:	68 02 1d 81 00       	push   $0x811d02
  8097ab:	68 48 02 00 00       	push   $0x248
  8097b0:	68 7a 29 81 00       	push   $0x81297a
  8097b5:	e8 4f 50 00 00       	call   80e809 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  8097ba:	8d 4a 06             	lea    0x6(%edx),%ecx
  8097bd:	83 c2 1c             	add    $0x1c,%edx
  8097c0:	83 ec 0c             	sub    $0xc,%esp
  8097c3:	6a 00                	push   $0x0
  8097c5:	e8 c3 fd ff ff       	call   80958d <update_arp_entry>
  8097ca:	83 c4 10             	add    $0x10,%esp
  8097cd:	eb d2                	jmp    8097a1 <etharp_ip_input+0x1e>

008097cf <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8097cf:	55                   	push   %ebp
  8097d0:	89 e5                	mov    %esp,%ebp
  8097d2:	57                   	push   %edi
  8097d3:	56                   	push   %esi
  8097d4:	53                   	push   %ebx
  8097d5:	83 ec 1c             	sub    $0x1c,%esp
  8097d8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8097db:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  8097df:	74 4d                	je     80982e <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8097e1:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  8097e6:	76 5d                	jbe    809845 <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  8097e8:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8097eb:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  8097ef:	83 ec 0c             	sub    $0xc,%esp
  8097f2:	6a 01                	push   $0x1
  8097f4:	e8 d5 e0 ff ff       	call   8078ce <htons>
  8097f9:	83 c4 10             	add    $0x10,%esp
  8097fc:	66 39 c7             	cmp    %ax,%di
  8097ff:	75 19                	jne    80981a <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809801:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809805:	83 ec 0c             	sub    $0xc,%esp
  809808:	68 04 06 00 00       	push   $0x604
  80980d:	e8 bc e0 ff ff       	call   8078ce <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809812:	83 c4 10             	add    $0x10,%esp
  809815:	66 39 c7             	cmp    %ax,%di
  809818:	74 39                	je     809853 <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80981a:	83 ec 0c             	sub    $0xc,%esp
  80981d:	53                   	push   %ebx
  80981e:	e8 d1 b1 ff ff       	call   8049f4 <pbuf_free>
    return;
  809823:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  809826:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809829:	5b                   	pop    %ebx
  80982a:	5e                   	pop    %esi
  80982b:	5f                   	pop    %edi
  80982c:	5d                   	pop    %ebp
  80982d:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80982e:	83 ec 04             	sub    $0x4,%esp
  809831:	68 02 1d 81 00       	push   $0x811d02
  809836:	68 75 02 00 00       	push   $0x275
  80983b:	68 7a 29 81 00       	push   $0x81297a
  809840:	e8 c4 4f 00 00       	call   80e809 <_panic>
    pbuf_free(p);
  809845:	83 ec 0c             	sub    $0xc,%esp
  809848:	53                   	push   %ebx
  809849:	e8 a6 b1 ff ff       	call   8049f4 <pbuf_free>
    return;
  80984e:	83 c4 10             	add    $0x10,%esp
  809851:	eb d3                	jmp    809826 <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809853:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809857:	83 ec 0c             	sub    $0xc,%esp
  80985a:	68 00 08 00 00       	push   $0x800
  80985f:	e8 6a e0 ff ff       	call   8078ce <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809864:	83 c4 10             	add    $0x10,%esp
  809867:	66 39 c7             	cmp    %ax,%di
  80986a:	75 ae                	jne    80981a <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80986c:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809870:	83 ec 0c             	sub    $0xc,%esp
  809873:	68 06 08 00 00       	push   $0x806
  809878:	e8 51 e0 ff ff       	call   8078ce <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80987d:	83 c4 10             	add    $0x10,%esp
  809880:	66 39 c7             	cmp    %ax,%di
  809883:	75 95                	jne    80981a <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809885:	83 ec 04             	sub    $0x4,%esp
  809888:	6a 04                	push   $0x4
  80988a:	8d 46 1c             	lea    0x1c(%esi),%eax
  80988d:	50                   	push   %eax
  80988e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809891:	50                   	push   %eax
  809892:	e8 b7 59 00 00       	call   80f24e <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809897:	83 c4 0c             	add    $0xc,%esp
  80989a:	6a 04                	push   $0x4
  80989c:	8d 46 26             	lea    0x26(%esi),%eax
  80989f:	50                   	push   %eax
  8098a0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8098a3:	50                   	push   %eax
  8098a4:	e8 a5 59 00 00       	call   80f24e <memcpy>
  if (netif->ip_addr.addr == 0) {
  8098a9:	8b 45 08             	mov    0x8(%ebp),%eax
  8098ac:	8b 40 04             	mov    0x4(%eax),%eax
  8098af:	83 c4 10             	add    $0x10,%esp
  8098b2:	85 c0                	test   %eax,%eax
  8098b4:	74 05                	je     8098bb <etharp_arp_input+0xec>
  if (for_us) {
  8098b6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  8098b9:	74 39                	je     8098f4 <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  8098bb:	8d 4e 16             	lea    0x16(%esi),%ecx
  8098be:	83 ec 0c             	sub    $0xc,%esp
  8098c1:	6a 00                	push   $0x0
  8098c3:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8098c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8098c9:	e8 bf fc ff ff       	call   80958d <update_arp_entry>
  switch (htons(hdr->opcode)) {
  8098ce:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8098d2:	89 04 24             	mov    %eax,(%esp)
  8098d5:	e8 f4 df ff ff       	call   8078ce <htons>
  8098da:	83 c4 10             	add    $0x10,%esp
  8098dd:	66 83 f8 02          	cmp    $0x2,%ax
  8098e1:	74 3f                	je     809922 <etharp_arp_input+0x153>
  pbuf_free(p);
  8098e3:	83 ec 0c             	sub    $0xc,%esp
  8098e6:	53                   	push   %ebx
  8098e7:	e8 08 b1 ff ff       	call   8049f4 <pbuf_free>
  8098ec:	83 c4 10             	add    $0x10,%esp
  8098ef:	e9 32 ff ff ff       	jmp    809826 <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  8098f4:	8d 4e 16             	lea    0x16(%esi),%ecx
  8098f7:	83 ec 0c             	sub    $0xc,%esp
  8098fa:	6a 01                	push   $0x1
  8098fc:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8098ff:	8b 45 08             	mov    0x8(%ebp),%eax
  809902:	e8 86 fc ff ff       	call   80958d <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809907:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80990b:	89 04 24             	mov    %eax,(%esp)
  80990e:	e8 bb df ff ff       	call   8078ce <htons>
  809913:	83 c4 10             	add    $0x10,%esp
  809916:	66 83 f8 01          	cmp    $0x1,%ax
  80991a:	74 1a                	je     809936 <etharp_arp_input+0x167>
  80991c:	66 83 f8 02          	cmp    $0x2,%ax
  809920:	75 c1                	jne    8098e3 <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  809922:	83 ec 08             	sub    $0x8,%esp
  809925:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809928:	50                   	push   %eax
  809929:	ff 75 08             	pushl  0x8(%ebp)
  80992c:	e8 70 a1 ff ff       	call   803aa1 <dhcp_arp_reply>
    break;
  809931:	83 c4 10             	add    $0x10,%esp
  809934:	eb ad                	jmp    8098e3 <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  809936:	83 ec 0c             	sub    $0xc,%esp
  809939:	6a 02                	push   $0x2
  80993b:	e8 8e df ff ff       	call   8078ce <htons>
  809940:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  809944:	8b 46 1c             	mov    0x1c(%esi),%eax
  809947:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80994a:	8b 45 08             	mov    0x8(%ebp),%eax
  80994d:	8b 40 04             	mov    0x4(%eax),%eax
  809950:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809953:	83 c4 10             	add    $0x10,%esp
  809956:	8b 45 08             	mov    0x8(%ebp),%eax
  809959:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80995d:	75 0b                	jne    80996a <etharp_arp_input+0x19b>
  80995f:	8d 46 05             	lea    0x5(%esi),%eax
  809962:	8b 55 0c             	mov    0xc(%ebp),%edx
  809965:	83 c2 05             	add    $0x5,%edx
  809968:	eb 19                	jmp    809983 <etharp_arp_input+0x1b4>
  80996a:	83 ec 04             	sub    $0x4,%esp
  80996d:	68 f0 29 81 00       	push   $0x8129f0
  809972:	68 c7 02 00 00       	push   $0x2c7
  809977:	68 7a 29 81 00       	push   $0x81297a
  80997c:	e8 88 4e 00 00       	call   80e809 <_panic>
  809981:	89 c8                	mov    %ecx,%eax
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809983:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  809987:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80998a:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80998c:	0f b6 0a             	movzbl (%edx),%ecx
  80998f:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809992:	88 48 06             	mov    %cl,0x6(%eax)
  809995:	8d 48 ff             	lea    -0x1(%eax),%ecx
  809998:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  80999b:	39 f0                	cmp    %esi,%eax
  80999d:	75 e2                	jne    809981 <etharp_arp_input+0x1b2>
      netif->linkoutput(netif, p);
  80999f:	83 ec 08             	sub    $0x8,%esp
  8099a2:	53                   	push   %ebx
  8099a3:	ff 75 08             	pushl  0x8(%ebp)
  8099a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8099a9:	ff 50 18             	call   *0x18(%eax)
  8099ac:	83 c4 10             	add    $0x10,%esp
  8099af:	e9 2f ff ff ff       	jmp    8098e3 <etharp_arp_input+0x114>

008099b4 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  8099b4:	55                   	push   %ebp
  8099b5:	89 e5                	mov    %esp,%ebp
  8099b7:	57                   	push   %edi
  8099b8:	56                   	push   %esi
  8099b9:	53                   	push   %ebx
  8099ba:	83 ec 10             	sub    $0x10,%esp
  8099bd:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  8099c0:	6a 00                	push   $0x0
  8099c2:	6a 2a                	push   $0x2a
  8099c4:	6a 02                	push   $0x2
  8099c6:	e8 ef b0 ff ff       	call   804aba <pbuf_alloc>
  if (p == NULL) {
  8099cb:	83 c4 10             	add    $0x10,%esp
  8099ce:	85 c0                	test   %eax,%eax
  8099d0:	0f 84 f8 00 00 00    	je     809ace <etharp_request+0x11a>
  8099d6:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  8099d8:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  8099dd:	0f 86 bd 00 00 00    	jbe    809aa0 <etharp_request+0xec>
  hdr = p->payload;
  8099e3:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  8099e6:	83 ec 0c             	sub    $0xc,%esp
  8099e9:	6a 01                	push   $0x1
  8099eb:	e8 de de ff ff       	call   8078ce <htons>
  8099f0:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8099f4:	83 c4 10             	add    $0x10,%esp
  8099f7:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  8099fb:	0f 85 b6 00 00 00    	jne    809ab7 <etharp_request+0x103>
  809a01:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  809a06:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809a0b:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  809a0f:	0f b6 90 dc 2a 81 00 	movzbl 0x812adc(%eax),%edx
  809a16:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  809a1a:	0f b6 90 e4 2a 81 00 	movzbl 0x812ae4(%eax),%edx
  809a21:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  809a24:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  809a29:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  809a2d:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  809a30:	83 f8 ff             	cmp    $0xffffffff,%eax
  809a33:	75 d1                	jne    809a06 <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  809a35:	8b 46 04             	mov    0x4(%esi),%eax
  809a38:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  809a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  809a3e:	8b 00                	mov    (%eax),%eax
  809a40:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  809a43:	83 ec 0c             	sub    $0xc,%esp
  809a46:	6a 01                	push   $0x1
  809a48:	e8 81 de ff ff       	call   8078ce <htons>
  809a4d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  809a51:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809a58:	e8 71 de ff ff       	call   8078ce <htons>
  809a5d:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  809a61:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809a68:	e8 61 de ff ff       	call   8078ce <htons>
  809a6d:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809a71:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809a78:	e8 51 de ff ff       	call   8078ce <htons>
  809a7d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809a81:	83 c4 08             	add    $0x8,%esp
  809a84:	57                   	push   %edi
  809a85:	56                   	push   %esi
  809a86:	ff 56 18             	call   *0x18(%esi)
  809a89:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809a8b:	89 3c 24             	mov    %edi,(%esp)
  809a8e:	e8 61 af ff ff       	call   8049f4 <pbuf_free>
  809a93:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  809a96:	89 d8                	mov    %ebx,%eax
  809a98:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a9b:	5b                   	pop    %ebx
  809a9c:	5e                   	pop    %esi
  809a9d:	5f                   	pop    %edi
  809a9e:	5d                   	pop    %ebp
  809a9f:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809aa0:	83 ec 04             	sub    $0x4,%esp
  809aa3:	68 5c 2a 81 00       	push   $0x812a5c
  809aa8:	68 1c 04 00 00       	push   $0x41c
  809aad:	68 7a 29 81 00       	push   $0x81297a
  809ab2:	e8 52 4d 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809ab7:	83 ec 04             	sub    $0x4,%esp
  809aba:	68 f0 29 81 00       	push   $0x8129f0
  809abf:	68 23 04 00 00       	push   $0x423
  809ac4:	68 7a 29 81 00       	push   $0x81297a
  809ac9:	e8 3b 4d 00 00       	call   80e809 <_panic>
    return ERR_MEM;
  809ace:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809ad3:	eb c1                	jmp    809a96 <etharp_request+0xe2>

00809ad5 <etharp_query>:
{
  809ad5:	55                   	push   %ebp
  809ad6:	89 e5                	mov    %esp,%ebp
  809ad8:	57                   	push   %edi
  809ad9:	56                   	push   %esi
  809ada:	53                   	push   %ebx
  809adb:	83 ec 14             	sub    $0x14,%esp
  809ade:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809ae1:	ff 75 08             	pushl  0x8(%ebp)
  809ae4:	53                   	push   %ebx
  809ae5:	e8 81 cb ff ff       	call   80666b <ip_addr_isbroadcast>
  809aea:	83 c4 10             	add    $0x10,%esp
  809aed:	84 c0                	test   %al,%al
  809aef:	0f 85 a2 01 00 00    	jne    809c97 <etharp_query+0x1c2>
      ip_addr_ismulticast(ipaddr) ||
  809af5:	8b 33                	mov    (%ebx),%esi
  809af7:	83 ec 0c             	sub    $0xc,%esp
  809afa:	68 00 00 00 f0       	push   $0xf0000000
  809aff:	e8 fb df ff ff       	call   807aff <ntohl>
  809b04:	21 c6                	and    %eax,%esi
  809b06:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809b0d:	e8 ed df ff ff       	call   807aff <ntohl>
  809b12:	83 c4 10             	add    $0x10,%esp
  809b15:	39 c6                	cmp    %eax,%esi
  809b17:	0f 84 84 01 00 00    	je     809ca1 <etharp_query+0x1cc>
      ip_addr_isany(ipaddr)) {
  809b1d:	83 3b 00             	cmpl   $0x0,(%ebx)
  809b20:	0f 84 85 01 00 00    	je     809cab <etharp_query+0x1d6>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  809b26:	ba 01 00 00 00       	mov    $0x1,%edx
  809b2b:	89 d8                	mov    %ebx,%eax
  809b2d:	e8 48 f7 ff ff       	call   80927a <find_entry>
  809b32:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  809b34:	84 c0                	test   %al,%al
  809b36:	0f 88 79 01 00 00    	js     809cb5 <etharp_query+0x1e0>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  809b3c:	0f be f8             	movsbl %al,%edi
  809b3f:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b42:	8b 80 30 5a b3 00    	mov    0xb35a30(%eax),%eax
  809b48:	85 c0                	test   %eax,%eax
  809b4a:	75 26                	jne    809b72 <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  809b4c:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b4f:	c7 80 30 5a b3 00 01 	movl   $0x1,0xb35a30(%eax)
  809b56:	00 00 00 
    result = etharp_request(netif, ipaddr);
  809b59:	83 ec 08             	sub    $0x8,%esp
  809b5c:	53                   	push   %ebx
  809b5d:	ff 75 08             	pushl  0x8(%ebp)
  809b60:	e8 4f fe ff ff       	call   8099b4 <etharp_request>
  809b65:	89 c3                	mov    %eax,%ebx
  if (q != NULL) {
  809b67:	83 c4 10             	add    $0x10,%esp
  809b6a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809b6e:	74 2d                	je     809b9d <etharp_query+0xc8>
  809b70:	eb 18                	jmp    809b8a <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809b72:	8d 50 ff             	lea    -0x1(%eax),%edx
  809b75:	83 fa 01             	cmp    $0x1,%edx
  809b78:	77 2d                	ja     809ba7 <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809b7a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809b7e:	74 d9                	je     809b59 <etharp_query+0x84>
  809b80:	83 f8 01             	cmp    $0x1,%eax
  809b83:	74 d4                	je     809b59 <etharp_query+0x84>
  err_t result = ERR_MEM;
  809b85:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809b8a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809b8d:	8b 80 30 5a b3 00    	mov    0xb35a30(%eax),%eax
  809b93:	83 f8 02             	cmp    $0x2,%eax
  809b96:	74 26                	je     809bbe <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809b98:	83 f8 01             	cmp    $0x1,%eax
  809b9b:	74 4a                	je     809be7 <etharp_query+0x112>
}
  809b9d:	89 d8                	mov    %ebx,%eax
  809b9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809ba2:	5b                   	pop    %ebx
  809ba3:	5e                   	pop    %esi
  809ba4:	5f                   	pop    %edi
  809ba5:	5d                   	pop    %ebp
  809ba6:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809ba7:	83 ec 04             	sub    $0x4,%esp
  809baa:	68 90 2a 81 00       	push   $0x812a90
  809baf:	68 92 03 00 00       	push   $0x392
  809bb4:	68 7a 29 81 00       	push   $0x81297a
  809bb9:	e8 4b 4c 00 00       	call   80e809 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809bbe:	8b 45 08             	mov    0x8(%ebp),%eax
  809bc1:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809bc4:	83 ec 0c             	sub    $0xc,%esp
  809bc7:	89 f0                	mov    %esi,%eax
  809bc9:	0f be c0             	movsbl %al,%eax
  809bcc:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809bcf:	05 28 5a b3 00       	add    $0xb35a28,%eax
  809bd4:	50                   	push   %eax
  809bd5:	8b 55 10             	mov    0x10(%ebp),%edx
  809bd8:	8b 45 08             	mov    0x8(%ebp),%eax
  809bdb:	e8 3a f9 ff ff       	call   80951a <etharp_send_ip>
  809be0:	89 c3                	mov    %eax,%ebx
  809be2:	83 c4 10             	add    $0x10,%esp
  809be5:	eb b6                	jmp    809b9d <etharp_query+0xc8>
      p = q;
  809be7:	8b 45 10             	mov    0x10(%ebp),%eax
  809bea:	eb 27                	jmp    809c13 <etharp_query+0x13e>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809bec:	83 ec 04             	sub    $0x4,%esp
  809bef:	68 d6 29 81 00       	push   $0x8129d6
  809bf4:	68 b1 03 00 00       	push   $0x3b1
  809bf9:	68 7a 29 81 00       	push   $0x81297a
  809bfe:	e8 06 4c 00 00       	call   80e809 <_panic>
        if(p->type != PBUF_ROM) {
  809c03:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809c07:	75 23                	jne    809c2c <etharp_query+0x157>
        p = p->next;
  809c09:	8b 00                	mov    (%eax),%eax
      while (p) {
  809c0b:	85 c0                	test   %eax,%eax
  809c0d:	0f 84 a9 00 00 00    	je     809cbc <etharp_query+0x1e7>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809c13:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809c17:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809c1b:	75 e6                	jne    809c03 <etharp_query+0x12e>
  809c1d:	83 38 00             	cmpl   $0x0,(%eax)
  809c20:	75 ca                	jne    809bec <etharp_query+0x117>
        if(p->type != PBUF_ROM) {
  809c22:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809c26:	0f 84 90 00 00 00    	je     809cbc <etharp_query+0x1e7>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809c2c:	83 ec 04             	sub    $0x4,%esp
  809c2f:	6a 00                	push   $0x0
  809c31:	0f b7 d2             	movzwl %dx,%edx
  809c34:	52                   	push   %edx
  809c35:	6a 03                	push   $0x3
  809c37:	e8 7e ae ff ff       	call   804aba <pbuf_alloc>
  809c3c:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809c3e:	83 c4 10             	add    $0x10,%esp
  809c41:	85 c0                	test   %eax,%eax
  809c43:	0f 84 54 ff ff ff    	je     809b9d <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  809c49:	83 ec 08             	sub    $0x8,%esp
  809c4c:	ff 75 10             	pushl  0x10(%ebp)
  809c4f:	56                   	push   %esi
  809c50:	e8 47 b3 ff ff       	call   804f9c <pbuf_copy>
  809c55:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809c58:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809c5b:	84 c0                	test   %al,%al
  809c5d:	74 6b                	je     809cca <etharp_query+0x1f5>
            pbuf_free(p);
  809c5f:	83 ec 0c             	sub    $0xc,%esp
  809c62:	56                   	push   %esi
  809c63:	e8 8c ad ff ff       	call   8049f4 <pbuf_free>
  809c68:	83 c4 10             	add    $0x10,%esp
  809c6b:	e9 2d ff ff ff       	jmp    809b9d <etharp_query+0xc8>
              r = r->next;
  809c70:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809c72:	8b 11                	mov    (%ecx),%edx
  809c74:	85 d2                	test   %edx,%edx
  809c76:	75 f8                	jne    809c70 <etharp_query+0x19b>
            r->next = new_entry;
  809c78:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809c7a:	bb 00 00 00 00       	mov    $0x0,%ebx
  809c7f:	e9 19 ff ff ff       	jmp    809b9d <etharp_query+0xc8>
          pbuf_free(p);
  809c84:	83 ec 0c             	sub    $0xc,%esp
  809c87:	ff 75 10             	pushl  0x10(%ebp)
  809c8a:	e8 65 ad ff ff       	call   8049f4 <pbuf_free>
  809c8f:	83 c4 10             	add    $0x10,%esp
  809c92:	e9 06 ff ff ff       	jmp    809b9d <etharp_query+0xc8>
    return ERR_ARG;
  809c97:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809c9c:	e9 fc fe ff ff       	jmp    809b9d <etharp_query+0xc8>
  809ca1:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809ca6:	e9 f2 fe ff ff       	jmp    809b9d <etharp_query+0xc8>
  809cab:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809cb0:	e9 e8 fe ff ff       	jmp    809b9d <etharp_query+0xc8>
    return (err_t)i;
  809cb5:	89 c3                	mov    %eax,%ebx
  809cb7:	e9 e1 fe ff ff       	jmp    809b9d <etharp_query+0xc8>
        pbuf_ref(p);
  809cbc:	83 ec 0c             	sub    $0xc,%esp
  809cbf:	ff 75 10             	pushl  0x10(%ebp)
  809cc2:	e8 8f b1 ff ff       	call   804e56 <pbuf_ref>
  809cc7:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809cca:	83 ec 0c             	sub    $0xc,%esp
  809ccd:	6a 0a                	push   $0xa
  809ccf:	e8 7d a9 ff ff       	call   804651 <memp_malloc>
        if (new_entry != NULL) {
  809cd4:	83 c4 10             	add    $0x10,%esp
  809cd7:	85 c0                	test   %eax,%eax
  809cd9:	74 a9                	je     809c84 <etharp_query+0x1af>
          new_entry->next = 0;
  809cdb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809ce1:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809ce4:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809ce7:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809cea:	8b 8a 20 5a b3 00    	mov    0xb35a20(%edx),%ecx
  809cf0:	85 c9                	test   %ecx,%ecx
  809cf2:	0f 85 7a ff ff ff    	jne    809c72 <etharp_query+0x19d>
            arp_table[i].q = new_entry;
  809cf8:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809cfb:	89 87 20 5a b3 00    	mov    %eax,0xb35a20(%edi)
          result = ERR_OK;
  809d01:	bb 00 00 00 00       	mov    $0x0,%ebx
  809d06:	e9 92 fe ff ff       	jmp    809b9d <etharp_query+0xc8>

00809d0b <etharp_output>:
{
  809d0b:	55                   	push   %ebp
  809d0c:	89 e5                	mov    %esp,%ebp
  809d0e:	57                   	push   %edi
  809d0f:	56                   	push   %esi
  809d10:	53                   	push   %ebx
  809d11:	83 ec 24             	sub    $0x24,%esp
  809d14:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809d17:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809d1a:	6a 0e                	push   $0xe
  809d1c:	ff 75 0c             	pushl  0xc(%ebp)
  809d1f:	e8 03 ac ff ff       	call   804927 <pbuf_header>
  809d24:	83 c4 10             	add    $0x10,%esp
  809d27:	84 c0                	test   %al,%al
  809d29:	0f 85 c0 00 00 00    	jne    809def <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809d2f:	83 ec 08             	sub    $0x8,%esp
  809d32:	53                   	push   %ebx
  809d33:	56                   	push   %esi
  809d34:	e8 32 c9 ff ff       	call   80666b <ip_addr_isbroadcast>
  809d39:	83 c4 10             	add    $0x10,%esp
  809d3c:	84 c0                	test   %al,%al
  809d3e:	0f 85 8a 00 00 00    	jne    809dce <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809d44:	8b 3e                	mov    (%esi),%edi
  809d46:	83 ec 0c             	sub    $0xc,%esp
  809d49:	68 00 00 00 f0       	push   $0xf0000000
  809d4e:	e8 ac dd ff ff       	call   807aff <ntohl>
  809d53:	21 c7                	and    %eax,%edi
  809d55:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809d5c:	e8 9e dd ff ff       	call   807aff <ntohl>
  809d61:	83 c4 10             	add    $0x10,%esp
  809d64:	39 c7                	cmp    %eax,%edi
  809d66:	74 25                	je     809d8d <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809d68:	8b 06                	mov    (%esi),%eax
  809d6a:	33 43 04             	xor    0x4(%ebx),%eax
  809d6d:	85 43 08             	test   %eax,0x8(%ebx)
  809d70:	74 09                	je     809d7b <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809d72:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809d76:	74 7e                	je     809df6 <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809d78:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809d7b:	83 ec 04             	sub    $0x4,%esp
  809d7e:	ff 75 0c             	pushl  0xc(%ebp)
  809d81:	56                   	push   %esi
  809d82:	53                   	push   %ebx
  809d83:	e8 4d fd ff ff       	call   809ad5 <etharp_query>
  809d88:	83 c4 10             	add    $0x10,%esp
  809d8b:	eb 5a                	jmp    809de7 <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809d8d:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809d91:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809d95:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809d99:	83 ec 0c             	sub    $0xc,%esp
  809d9c:	ff 36                	pushl  (%esi)
  809d9e:	e8 5c dd ff ff       	call   807aff <ntohl>
  809da3:	c1 e8 10             	shr    $0x10,%eax
  809da6:	83 e0 7f             	and    $0x7f,%eax
  809da9:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809dac:	83 c4 04             	add    $0x4,%esp
  809daf:	ff 36                	pushl  (%esi)
  809db1:	e8 49 dd ff ff       	call   807aff <ntohl>
  809db6:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809db9:	83 c4 04             	add    $0x4,%esp
  809dbc:	ff 36                	pushl  (%esi)
  809dbe:	e8 3c dd ff ff       	call   807aff <ntohl>
  809dc3:	88 45 e7             	mov    %al,-0x19(%ebp)
  809dc6:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809dc9:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809dcc:	eb 05                	jmp    809dd3 <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809dce:	b8 e4 2a 81 00       	mov    $0x812ae4,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809dd3:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809dd6:	83 ec 0c             	sub    $0xc,%esp
  809dd9:	50                   	push   %eax
  809dda:	8b 55 0c             	mov    0xc(%ebp),%edx
  809ddd:	89 d8                	mov    %ebx,%eax
  809ddf:	e8 36 f7 ff ff       	call   80951a <etharp_send_ip>
  809de4:	83 c4 10             	add    $0x10,%esp
}
  809de7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809dea:	5b                   	pop    %ebx
  809deb:	5e                   	pop    %esi
  809dec:	5f                   	pop    %edi
  809ded:	5d                   	pop    %ebp
  809dee:	c3                   	ret    
    return ERR_BUF;
  809def:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809df4:	eb f1                	jmp    809de7 <etharp_output+0xdc>
        return ERR_RTE;
  809df6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809dfb:	eb ea                	jmp    809de7 <etharp_output+0xdc>

00809dfd <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809dfd:	55                   	push   %ebp
  809dfe:	89 e5                	mov    %esp,%ebp
  809e00:	56                   	push   %esi
  809e01:	53                   	push   %ebx
  809e02:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809e05:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809e08:	83 ec 0c             	sub    $0xc,%esp
  809e0b:	8b 43 04             	mov    0x4(%ebx),%eax
  809e0e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809e12:	50                   	push   %eax
  809e13:	e8 b6 da ff ff       	call   8078ce <htons>
  809e18:	83 c4 10             	add    $0x10,%esp
  809e1b:	66 3d 00 08          	cmp    $0x800,%ax
  809e1f:	74 14                	je     809e35 <ethernet_input+0x38>
  809e21:	66 3d 06 08          	cmp    $0x806,%ax
  809e25:	74 50                	je     809e77 <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809e27:	83 ec 0c             	sub    $0xc,%esp
  809e2a:	53                   	push   %ebx
  809e2b:	e8 c4 ab ff ff       	call   8049f4 <pbuf_free>
      p = NULL;
      break;
  809e30:	83 c4 10             	add    $0x10,%esp
  809e33:	eb 53                	jmp    809e88 <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809e35:	83 ec 08             	sub    $0x8,%esp
  809e38:	53                   	push   %ebx
  809e39:	56                   	push   %esi
  809e3a:	e8 44 f9 ff ff       	call   809783 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809e3f:	83 c4 08             	add    $0x8,%esp
  809e42:	6a f2                	push   $0xfffffff2
  809e44:	53                   	push   %ebx
  809e45:	e8 dd aa ff ff       	call   804927 <pbuf_header>
  809e4a:	83 c4 10             	add    $0x10,%esp
  809e4d:	84 c0                	test   %al,%al
  809e4f:	75 0f                	jne    809e60 <ethernet_input+0x63>
        ip_input(p, netif);
  809e51:	83 ec 08             	sub    $0x8,%esp
  809e54:	56                   	push   %esi
  809e55:	53                   	push   %ebx
  809e56:	e8 b0 c8 ff ff       	call   80670b <ip_input>
      break;
  809e5b:	83 c4 10             	add    $0x10,%esp
  809e5e:	eb 28                	jmp    809e88 <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809e60:	83 ec 04             	sub    $0x4,%esp
  809e63:	68 b8 2a 81 00       	push   $0x812ab8
  809e68:	68 7e 04 00 00       	push   $0x47e
  809e6d:	68 7a 29 81 00       	push   $0x81297a
  809e72:	e8 92 49 00 00       	call   80e809 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809e77:	83 ec 04             	sub    $0x4,%esp
  809e7a:	53                   	push   %ebx
  809e7b:	8d 46 25             	lea    0x25(%esi),%eax
  809e7e:	50                   	push   %eax
  809e7f:	56                   	push   %esi
  809e80:	e8 4a f9 ff ff       	call   8097cf <etharp_arp_input>
      break;
  809e85:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809e88:	b8 00 00 00 00       	mov    $0x0,%eax
  809e8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809e90:	5b                   	pop    %ebx
  809e91:	5e                   	pop    %esi
  809e92:	5d                   	pop    %ebp
  809e93:	c3                   	ret    

00809e94 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809e94:	55                   	push   %ebp
  809e95:	89 e5                	mov    %esp,%ebp
  809e97:	53                   	push   %ebx
  809e98:	83 ec 10             	sub    $0x10,%esp
  809e9b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809e9e:	ff 73 04             	pushl  0x4(%ebx)
  809ea1:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809ea3:	89 1c 24             	mov    %ebx,(%esp)
  809ea6:	e8 f0 6a 00 00       	call   81099b <free>
}
  809eab:	83 c4 10             	add    $0x10,%esp
  809eae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809eb1:	c9                   	leave  
  809eb2:	c3                   	ret    

00809eb3 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809eb3:	55                   	push   %ebp
  809eb4:	89 e5                	mov    %esp,%ebp
  809eb6:	83 ec 08             	sub    $0x8,%esp
  809eb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809ebc:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809ec1:	89 c8                	mov    %ecx,%eax
  809ec3:	f7 e2                	mul    %edx
  809ec5:	c1 ea 08             	shr    $0x8,%edx
  809ec8:	89 d0                	mov    %edx,%eax
  809eca:	c1 e0 08             	shl    $0x8,%eax
  809ecd:	01 c2                	add    %eax,%edx
  809ecf:	89 c8                	mov    %ecx,%eax
  809ed1:	29 d0                	sub    %edx,%eax
  809ed3:	8b 04 85 40 5b b3 00 	mov    0xb35b40(,%eax,4),%eax
  809eda:	85 c0                	test   %eax,%eax
  809edc:	74 2a                	je     809f08 <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809ede:	39 08                	cmp    %ecx,(%eax)
  809ee0:	74 05                	je     809ee7 <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809ee2:	8b 40 08             	mov    0x8(%eax),%eax
  809ee5:	eb f3                	jmp    809eda <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809ee7:	8b 50 08             	mov    0x8(%eax),%edx
  809eea:	85 d2                	test   %edx,%edx
  809eec:	74 06                	je     809ef4 <timeout_cleanup+0x41>
  809eee:	8b 48 0c             	mov    0xc(%eax),%ecx
  809ef1:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809ef4:	8b 50 0c             	mov    0xc(%eax),%edx
  809ef7:	8b 48 08             	mov    0x8(%eax),%ecx
  809efa:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809efc:	83 ec 0c             	sub    $0xc,%esp
  809eff:	50                   	push   %eax
  809f00:	e8 96 6a 00 00       	call   81099b <free>
	    goto done;
  809f05:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809f08:	c9                   	leave  
  809f09:	c3                   	ret    

00809f0a <sys_init>:
{
  809f0a:	55                   	push   %ebp
  809f0b:	89 e5                	mov    %esp,%ebp
  809f0d:	56                   	push   %esi
  809f0e:	53                   	push   %ebx
  809f0f:	8b 15 60 ad b3 00    	mov    0xb3ad60,%edx
  809f15:	b8 80 ad b3 00       	mov    $0xb3ad80,%eax
  809f1a:	be 80 c1 b3 00       	mov    $0xb3c180,%esi
  809f1f:	eb 10                	jmp    809f31 <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809f21:	c7 41 10 60 ad b3 00 	movl   $0xb3ad60,0x10(%ecx)
  809f28:	83 c0 14             	add    $0x14,%eax
  809f2b:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809f2d:	39 f0                	cmp    %esi,%eax
  809f2f:	74 17                	je     809f48 <sys_init+0x3e>
  809f31:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809f33:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809f39:	89 50 0c             	mov    %edx,0xc(%eax)
  809f3c:	85 d2                	test   %edx,%edx
  809f3e:	74 e1                	je     809f21 <sys_init+0x17>
  809f40:	8d 58 0c             	lea    0xc(%eax),%ebx
  809f43:	89 5a 10             	mov    %ebx,0x10(%edx)
  809f46:	eb d9                	jmp    809f21 <sys_init+0x17>
  809f48:	c7 05 60 ad b3 00 6c 	movl   $0xb3c16c,0xb3ad60
  809f4f:	c1 b3 00 
  809f52:	8b 15 44 5f b3 00    	mov    0xb35f44,%edx
  809f58:	b8 60 5f b3 00       	mov    $0xb35f60,%eax
  809f5d:	be 60 ad b3 00       	mov    $0xb3ad60,%esi
  809f62:	eb 15                	jmp    809f79 <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809f64:	c7 81 98 00 00 00 44 	movl   $0xb35f44,0x98(%ecx)
  809f6b:	5f b3 00 
  809f6e:	05 9c 00 00 00       	add    $0x9c,%eax
  809f73:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809f75:	39 f0                	cmp    %esi,%eax
  809f77:	74 20                	je     809f99 <sys_init+0x8f>
  809f79:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809f7b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809f81:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809f87:	85 d2                	test   %edx,%edx
  809f89:	74 d9                	je     809f64 <sys_init+0x5a>
  809f8b:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809f91:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809f97:	eb cb                	jmp    809f64 <sys_init+0x5a>
  809f99:	c7 05 44 5f b3 00 c4 	movl   $0xb3acc4,0xb35f44
  809fa0:	ac b3 00 
}
  809fa3:	5b                   	pop    %ebx
  809fa4:	5e                   	pop    %esi
  809fa5:	5d                   	pop    %ebp
  809fa6:	c3                   	ret    

00809fa7 <sys_sem_new>:
{
  809fa7:	55                   	push   %ebp
  809fa8:	89 e5                	mov    %esp,%ebp
  809faa:	53                   	push   %ebx
  809fab:	83 ec 04             	sub    $0x4,%esp
  809fae:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809fb1:	a1 60 ad b3 00       	mov    0xb3ad60,%eax
    if (!se) {
  809fb6:	85 c0                	test   %eax,%eax
  809fb8:	74 3e                	je     809ff8 <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809fba:	8b 48 0c             	mov    0xc(%eax),%ecx
  809fbd:	85 c9                	test   %ecx,%ecx
  809fbf:	74 06                	je     809fc7 <sys_sem_new+0x20>
  809fc1:	8b 58 10             	mov    0x10(%eax),%ebx
  809fc4:	89 59 10             	mov    %ebx,0x10(%ecx)
  809fc7:	8b 48 10             	mov    0x10(%eax),%ecx
  809fca:	8b 58 0c             	mov    0xc(%eax),%ebx
  809fcd:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809fcf:	83 38 00             	cmpl   $0x0,(%eax)
  809fd2:	74 3b                	je     80a00f <sys_sem_new+0x68>
    se->freed = 0;
  809fd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809fda:	0f b6 d2             	movzbl %dl,%edx
  809fdd:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809fe1:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809fe5:	2d 80 ad b3 00       	sub    $0xb3ad80,%eax
  809fea:	c1 f8 02             	sar    $0x2,%eax
  809fed:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809ff3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809ff6:	c9                   	leave  
  809ff7:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809ff8:	83 ec 0c             	sub    $0xc,%esp
  809ffb:	68 ec 2a 81 00       	push   $0x812aec
  80a000:	e8 fa 48 00 00       	call   80e8ff <cprintf>
	return SYS_SEM_NULL;
  80a005:	83 c4 10             	add    $0x10,%esp
  80a008:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a00d:	eb e4                	jmp    809ff3 <sys_sem_new+0x4c>
    assert(se->freed);
  80a00f:	68 61 2c 81 00       	push   $0x812c61
  80a014:	68 6b 2c 81 00       	push   $0x812c6b
  80a019:	68 8d 00 00 00       	push   $0x8d
  80a01e:	68 80 2c 81 00       	push   $0x812c80
  80a023:	e8 e1 47 00 00       	call   80e809 <_panic>

0080a028 <sys_sem_free>:
{
  80a028:	55                   	push   %ebp
  80a029:	89 e5                	mov    %esp,%ebp
  80a02b:	83 ec 08             	sub    $0x8,%esp
  80a02e:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a031:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a034:	83 3c 95 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%edx,4)
  80a03b:	00 
  80a03c:	75 5a                	jne    80a098 <sys_sem_free+0x70>
    sems[sem].freed = 1;
  80a03e:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a041:	c1 e2 02             	shl    $0x2,%edx
  80a044:	8d 8a 80 ad b3 00    	lea    0xb3ad80(%edx),%ecx
  80a04a:	c7 82 80 ad b3 00 01 	movl   $0x1,0xb3ad80(%edx)
  80a051:	00 00 00 
    sems[sem].gen++;
  80a054:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a058:	8b 15 60 ad b3 00    	mov    0xb3ad60,%edx
  80a05e:	89 51 0c             	mov    %edx,0xc(%ecx)
  80a061:	85 d2                	test   %edx,%edx
  80a063:	74 0d                	je     80a072 <sys_sem_free+0x4a>
  80a065:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80a068:	8d 0c 8d 8c ad b3 00 	lea    0xb3ad8c(,%ecx,4),%ecx
  80a06f:	89 4a 10             	mov    %ecx,0x10(%edx)
  80a072:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a079:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a07c:	8d 0c 8d 80 ad b3 00 	lea    0xb3ad80(,%ecx,4),%ecx
  80a083:	89 0d 60 ad b3 00    	mov    %ecx,0xb3ad60
  80a089:	01 d0                	add    %edx,%eax
  80a08b:	c7 04 85 90 ad b3 00 	movl   $0xb3ad60,0xb3ad90(,%eax,4)
  80a092:	60 ad b3 00 
}
  80a096:	c9                   	leave  
  80a097:	c3                   	ret    
    assert(!sems[sem].freed);
  80a098:	68 9d 2c 81 00       	push   $0x812c9d
  80a09d:	68 6b 2c 81 00       	push   $0x812c6b
  80a0a2:	68 98 00 00 00       	push   $0x98
  80a0a7:	68 80 2c 81 00       	push   $0x812c80
  80a0ac:	e8 58 47 00 00       	call   80e809 <_panic>

0080a0b1 <sys_mbox_free>:
{
  80a0b1:	55                   	push   %ebp
  80a0b2:	89 e5                	mov    %esp,%ebp
  80a0b4:	56                   	push   %esi
  80a0b5:	53                   	push   %ebx
  80a0b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a0b9:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a0bf:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a0c6:	75 72                	jne    80a13a <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a0c8:	83 ec 0c             	sub    $0xc,%esp
  80a0cb:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a0d1:	ff b6 ec 5f b3 00    	pushl  0xb35fec(%esi)
  80a0d7:	e8 4c ff ff ff       	call   80a028 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a0dc:	83 c4 04             	add    $0x4,%esp
  80a0df:	ff b6 f0 5f b3 00    	pushl  0xb35ff0(%esi)
  80a0e5:	e8 3e ff ff ff       	call   80a028 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a0ea:	a1 44 5f b3 00       	mov    0xb35f44,%eax
  80a0ef:	89 86 f4 5f b3 00    	mov    %eax,0xb35ff4(%esi)
  80a0f5:	83 c4 10             	add    $0x10,%esp
  80a0f8:	85 c0                	test   %eax,%eax
  80a0fa:	74 12                	je     80a10e <sys_mbox_free+0x5d>
  80a0fc:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a102:	81 c2 f4 5f b3 00    	add    $0xb35ff4,%edx
  80a108:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a10e:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a114:	8d 83 60 5f b3 00    	lea    0xb35f60(%ebx),%eax
  80a11a:	a3 44 5f b3 00       	mov    %eax,0xb35f44
  80a11f:	c7 83 f8 5f b3 00 44 	movl   $0xb35f44,0xb35ff8(%ebx)
  80a126:	5f b3 00 
    mboxes[mbox].freed = 1;
  80a129:	c7 83 60 5f b3 00 01 	movl   $0x1,0xb35f60(%ebx)
  80a130:	00 00 00 
}
  80a133:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a136:	5b                   	pop    %ebx
  80a137:	5e                   	pop    %esi
  80a138:	5d                   	pop    %ebp
  80a139:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a13a:	68 ae 2c 81 00       	push   $0x812cae
  80a13f:	68 6b 2c 81 00       	push   $0x812c6b
  80a144:	6a 62                	push   $0x62
  80a146:	68 80 2c 81 00       	push   $0x812c80
  80a14b:	e8 b9 46 00 00       	call   80e809 <_panic>

0080a150 <sys_mbox_new>:
{
  80a150:	55                   	push   %ebp
  80a151:	89 e5                	mov    %esp,%ebp
  80a153:	57                   	push   %edi
  80a154:	56                   	push   %esi
  80a155:	53                   	push   %ebx
  80a156:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  80a159:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a15d:	0f 8f 9f 00 00 00    	jg     80a202 <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a163:	8b 1d 44 5f b3 00    	mov    0xb35f44,%ebx
    if (!mbe) {
  80a169:	85 db                	test   %ebx,%ebx
  80a16b:	0f 84 a7 00 00 00    	je     80a218 <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  80a171:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a177:	85 c0                	test   %eax,%eax
  80a179:	74 0c                	je     80a187 <sys_mbox_new+0x37>
  80a17b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a181:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a187:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a18d:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a193:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a195:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a198:	0f 84 91 00 00 00    	je     80a22f <sys_mbox_new+0xdf>
    mbe->freed = 0;
  80a19e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a1a4:	89 de                	mov    %ebx,%esi
  80a1a6:	81 ee 60 5f b3 00    	sub    $0xb35f60,%esi
  80a1ac:	c1 fe 02             	sar    $0x2,%esi
  80a1af:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a1b5:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a1b7:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a1be:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a1c5:	83 ec 0c             	sub    $0xc,%esp
  80a1c8:	6a 00                	push   $0x0
  80a1ca:	e8 d8 fd ff ff       	call   809fa7 <sys_sem_new>
  80a1cf:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a1d5:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a1dc:	e8 c6 fd ff ff       	call   809fa7 <sys_sem_new>
  80a1e1:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a1e7:	83 c4 10             	add    $0x10,%esp
  80a1ea:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a1f1:	74 52                	je     80a245 <sys_mbox_new+0xf5>
  80a1f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a1f6:	74 4d                	je     80a245 <sys_mbox_new+0xf5>
}
  80a1f8:	89 f8                	mov    %edi,%eax
  80a1fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a1fd:	5b                   	pop    %ebx
  80a1fe:	5e                   	pop    %esi
  80a1ff:	5f                   	pop    %edi
  80a200:	5d                   	pop    %ebp
  80a201:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a202:	68 c2 2c 81 00       	push   $0x812cc2
  80a207:	68 6b 2c 81 00       	push   $0x812c6b
  80a20c:	6a 45                	push   $0x45
  80a20e:	68 80 2c 81 00       	push   $0x812c80
  80a213:	e8 f1 45 00 00       	call   80e809 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a218:	83 ec 0c             	sub    $0xc,%esp
  80a21b:	68 14 2b 81 00       	push   $0x812b14
  80a220:	e8 da 46 00 00       	call   80e8ff <cprintf>
	return SYS_MBOX_NULL;
  80a225:	83 c4 10             	add    $0x10,%esp
  80a228:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a22d:	eb c9                	jmp    80a1f8 <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a22f:	68 d3 2c 81 00       	push   $0x812cd3
  80a234:	68 6b 2c 81 00       	push   $0x812c6b
  80a239:	6a 4c                	push   $0x4c
  80a23b:	68 80 2c 81 00       	push   $0x812c80
  80a240:	e8 c4 45 00 00       	call   80e809 <_panic>
	sys_mbox_free(i);
  80a245:	83 ec 0c             	sub    $0xc,%esp
  80a248:	56                   	push   %esi
  80a249:	e8 63 fe ff ff       	call   80a0b1 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a24e:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  80a255:	e8 a5 46 00 00       	call   80e8ff <cprintf>
	return SYS_MBOX_NULL;
  80a25a:	83 c4 10             	add    $0x10,%esp
  80a25d:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a262:	eb 94                	jmp    80a1f8 <sys_mbox_new+0xa8>

0080a264 <sys_sem_signal>:
{
  80a264:	55                   	push   %ebp
  80a265:	89 e5                	mov    %esp,%ebp
  80a267:	83 ec 08             	sub    $0x8,%esp
  80a26a:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a26d:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a270:	83 3c 95 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%edx,4)
  80a277:	00 
  80a278:	75 18                	jne    80a292 <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a27a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a27d:	8d 14 95 80 ad b3 00 	lea    0xb3ad80(,%edx,4),%edx
  80a284:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a289:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a28e:	75 1b                	jne    80a2ab <sys_sem_signal+0x47>
}
  80a290:	c9                   	leave  
  80a291:	c3                   	ret    
    assert(!sems[sem].freed);
  80a292:	68 9d 2c 81 00       	push   $0x812c9d
  80a297:	68 6b 2c 81 00       	push   $0x812c6b
  80a29c:	68 a1 00 00 00       	push   $0xa1
  80a2a1:	68 80 2c 81 00       	push   $0x812c80
  80a2a6:	e8 5e 45 00 00       	call   80e809 <_panic>
	sems[sem].waiters = 0;
  80a2ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a2b2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a2b5:	66 c7 04 8d 8a ad b3 	movw   $0x0,0xb3ad8a(,%ecx,4)
  80a2bc:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a2bf:	83 ec 0c             	sub    $0xc,%esp
  80a2c2:	8d 04 8d 88 ad b3 00 	lea    0xb3ad88(,%ecx,4),%eax
  80a2c9:	50                   	push   %eax
  80a2ca:	e8 a4 04 00 00       	call   80a773 <thread_wakeup>
  80a2cf:	83 c4 10             	add    $0x10,%esp
}
  80a2d2:	eb bc                	jmp    80a290 <sys_sem_signal+0x2c>

0080a2d4 <sys_arch_sem_wait>:
{
  80a2d4:	55                   	push   %ebp
  80a2d5:	89 e5                	mov    %esp,%ebp
  80a2d7:	57                   	push   %edi
  80a2d8:	56                   	push   %esi
  80a2d9:	53                   	push   %ebx
  80a2da:	83 ec 1c             	sub    $0x1c,%esp
  80a2dd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a2e0:	8b 45 08             	mov    0x8(%ebp),%eax
  80a2e3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a2e6:	83 3c 85 80 ad b3 00 	cmpl   $0x0,0xb3ad80(,%eax,4)
  80a2ed:	00 
  80a2ee:	75 2c                	jne    80a31c <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a2f0:	8b 45 08             	mov    0x8(%ebp),%eax
  80a2f3:	c1 e0 02             	shl    $0x2,%eax
  80a2f6:	89 c2                	mov    %eax,%edx
  80a2f8:	03 55 08             	add    0x8(%ebp),%edx
  80a2fb:	8b 3c 95 84 ad b3 00 	mov    0xb3ad84(,%edx,4),%edi
  80a302:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a305:	8d 04 95 88 ad b3 00 	lea    0xb3ad88(,%edx,4),%eax
  80a30c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a30f:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a314:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a317:	e9 80 00 00 00       	jmp    80a39c <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a31c:	68 9d 2c 81 00       	push   $0x812c9d
  80a321:	68 6b 2c 81 00       	push   $0x812c6b
  80a326:	68 ac 00 00 00       	push   $0xac
  80a32b:	68 80 2c 81 00       	push   $0x812c80
  80a330:	e8 d4 44 00 00       	call   80e809 <_panic>
	if (sems[sem].counter > 0) {
  80a335:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a338:	0f b7 04 85 88 ad b3 	movzwl 0xb3ad88(,%eax,4),%eax
  80a33f:	00 
  80a340:	66 85 c0             	test   %ax,%ax
  80a343:	75 6e                	jne    80a3b3 <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a345:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a348:	0f 84 8f 00 00 00    	je     80a3dd <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a34e:	e8 2f 53 00 00       	call   80f682 <sys_time_msec>
  80a353:	89 c1                	mov    %eax,%ecx
  80a355:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a358:	89 d8                	mov    %ebx,%eax
  80a35a:	29 f8                	sub    %edi,%eax
  80a35c:	01 c8                	add    %ecx,%eax
  80a35e:	85 db                	test   %ebx,%ebx
  80a360:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a365:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a368:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a36b:	8d 34 95 80 ad b3 00 	lea    0xb3ad80(,%edx,4),%esi
  80a372:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a378:	83 ec 04             	sub    $0x4,%esp
  80a37b:	50                   	push   %eax
  80a37c:	ff 76 08             	pushl  0x8(%esi)
  80a37f:	ff 75 dc             	pushl  -0x24(%ebp)
  80a382:	e8 02 06 00 00       	call   80a989 <thread_wait>
	    if (gen != sems[sem].gen) {
  80a387:	83 c4 10             	add    $0x10,%esp
  80a38a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a38d:	39 46 04             	cmp    %eax,0x4(%esi)
  80a390:	75 34                	jne    80a3c6 <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a392:	e8 eb 52 00 00       	call   80f682 <sys_time_msec>
	    waited += (b - a);
  80a397:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a39a:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a39c:	85 db                	test   %ebx,%ebx
  80a39e:	74 95                	je     80a335 <sys_arch_sem_wait+0x61>
  80a3a0:	39 df                	cmp    %ebx,%edi
  80a3a2:	72 91                	jb     80a335 <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a3a4:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a3a9:	89 f8                	mov    %edi,%eax
  80a3ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a3ae:	5b                   	pop    %ebx
  80a3af:	5e                   	pop    %esi
  80a3b0:	5f                   	pop    %edi
  80a3b1:	5d                   	pop    %ebp
  80a3b2:	c3                   	ret    
	    sems[sem].counter--;
  80a3b3:	8b 55 08             	mov    0x8(%ebp),%edx
  80a3b6:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a3b9:	83 e8 01             	sub    $0x1,%eax
  80a3bc:	66 89 04 95 88 ad b3 	mov    %ax,0xb3ad88(,%edx,4)
  80a3c3:	00 
	    return waited;
  80a3c4:	eb e3                	jmp    80a3a9 <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a3c6:	83 ec 0c             	sub    $0xc,%esp
  80a3c9:	68 68 2b 81 00       	push   $0x812b68
  80a3ce:	e8 2c 45 00 00       	call   80e8ff <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a3d3:	83 c4 10             	add    $0x10,%esp
  80a3d6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a3db:	eb cc                	jmp    80a3a9 <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a3dd:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a3e2:	eb c5                	jmp    80a3a9 <sys_arch_sem_wait+0xd5>

0080a3e4 <sys_mbox_trypost>:
{
  80a3e4:	55                   	push   %ebp
  80a3e5:	89 e5                	mov    %esp,%ebp
  80a3e7:	57                   	push   %edi
  80a3e8:	56                   	push   %esi
  80a3e9:	53                   	push   %ebx
  80a3ea:	83 ec 0c             	sub    $0xc,%esp
  80a3ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a3f0:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3f6:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a3fd:	75 7f                	jne    80a47e <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a3ff:	83 ec 08             	sub    $0x8,%esp
  80a402:	6a 00                	push   $0x0
  80a404:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a40a:	ff b6 f0 5f b3 00    	pushl  0xb35ff0(%esi)
  80a410:	e8 bf fe ff ff       	call   80a2d4 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a415:	8b 96 68 5f b3 00    	mov    0xb35f68(%esi),%edx
  80a41b:	8b 8e 64 5f b3 00    	mov    0xb35f64(%esi),%ecx
  80a421:	83 c4 10             	add    $0x10,%esp
  80a424:	39 ca                	cmp    %ecx,%edx
  80a426:	74 7a                	je     80a4a2 <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a428:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a42e:	8d 42 01             	lea    0x1(%edx),%eax
  80a431:	89 c7                	mov    %eax,%edi
  80a433:	c1 ff 1f             	sar    $0x1f,%edi
  80a436:	c1 ef 1b             	shr    $0x1b,%edi
  80a439:	01 f8                	add    %edi,%eax
  80a43b:	83 e0 1f             	and    $0x1f,%eax
  80a43e:	29 f8                	sub    %edi,%eax
  80a440:	89 86 68 5f b3 00    	mov    %eax,0xb35f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a446:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a449:	01 d0                	add    %edx,%eax
  80a44b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a44e:	89 34 85 6c 5f b3 00 	mov    %esi,0xb35f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a455:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a458:	74 3a                	je     80a494 <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a45a:	83 ec 0c             	sub    $0xc,%esp
  80a45d:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a463:	ff b3 ec 5f b3 00    	pushl  0xb35fec(%ebx)
  80a469:	e8 f6 fd ff ff       	call   80a264 <sys_sem_signal>
    return ERR_OK;
  80a46e:	83 c4 10             	add    $0x10,%esp
  80a471:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a476:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a479:	5b                   	pop    %ebx
  80a47a:	5e                   	pop    %esi
  80a47b:	5f                   	pop    %edi
  80a47c:	5d                   	pop    %ebp
  80a47d:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a47e:	68 ae 2c 81 00       	push   $0x812cae
  80a483:	68 6b 2c 81 00       	push   $0x812c6b
  80a488:	6a 72                	push   $0x72
  80a48a:	68 80 2c 81 00       	push   $0x812c80
  80a48f:	e8 75 43 00 00       	call   80e809 <_panic>
	mboxes[mbox].head = slot;
  80a494:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a49a:	89 90 64 5f b3 00    	mov    %edx,0xb35f64(%eax)
  80a4a0:	eb b8                	jmp    80a45a <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a4a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a4a7:	eb cd                	jmp    80a476 <sys_mbox_trypost+0x92>

0080a4a9 <sys_mbox_post>:
{
  80a4a9:	55                   	push   %ebp
  80a4aa:	89 e5                	mov    %esp,%ebp
  80a4ac:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a4af:	ff 75 0c             	pushl  0xc(%ebp)
  80a4b2:	ff 75 08             	pushl  0x8(%ebp)
  80a4b5:	e8 2a ff ff ff       	call   80a3e4 <sys_mbox_trypost>
  80a4ba:	83 c4 10             	add    $0x10,%esp
  80a4bd:	84 c0                	test   %al,%al
  80a4bf:	75 02                	jne    80a4c3 <sys_mbox_post+0x1a>
}
  80a4c1:	c9                   	leave  
  80a4c2:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a4c3:	68 94 2b 81 00       	push   $0x812b94
  80a4c8:	68 6b 2c 81 00       	push   $0x812c6b
  80a4cd:	6a 6c                	push   $0x6c
  80a4cf:	68 80 2c 81 00       	push   $0x812c80
  80a4d4:	e8 30 43 00 00       	call   80e809 <_panic>

0080a4d9 <sys_arch_mbox_fetch>:
{
  80a4d9:	55                   	push   %ebp
  80a4da:	89 e5                	mov    %esp,%ebp
  80a4dc:	57                   	push   %edi
  80a4dd:	56                   	push   %esi
  80a4de:	53                   	push   %ebx
  80a4df:	83 ec 0c             	sub    $0xc,%esp
  80a4e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a4e5:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a4e8:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a4ee:	83 b8 60 5f b3 00 00 	cmpl   $0x0,0xb35f60(%eax)
  80a4f5:	0f 85 8a 00 00 00    	jne    80a585 <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a4fb:	83 ec 08             	sub    $0x8,%esp
  80a4fe:	ff 75 10             	pushl  0x10(%ebp)
  80a501:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a507:	ff b0 ec 5f b3 00    	pushl  0xb35fec(%eax)
  80a50d:	e8 c2 fd ff ff       	call   80a2d4 <sys_arch_sem_wait>
  80a512:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a514:	83 c4 10             	add    $0x10,%esp
  80a517:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a51a:	74 5f                	je     80a57b <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a51c:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a522:	8b 80 64 5f b3 00    	mov    0xb35f64(%eax),%eax
    if (slot == -1)
  80a528:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a52b:	74 71                	je     80a59e <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a52d:	85 ff                	test   %edi,%edi
  80a52f:	74 0e                	je     80a53f <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a531:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a534:	01 c2                	add    %eax,%edx
  80a536:	8b 14 95 6c 5f b3 00 	mov    0xb35f6c(,%edx,4),%edx
  80a53d:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a53f:	83 c0 01             	add    $0x1,%eax
  80a542:	99                   	cltd   
  80a543:	c1 ea 1b             	shr    $0x1b,%edx
  80a546:	01 d0                	add    %edx,%eax
  80a548:	83 e0 1f             	and    $0x1f,%eax
  80a54b:	29 d0                	sub    %edx,%eax
  80a54d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a553:	89 82 64 5f b3 00    	mov    %eax,0xb35f64(%edx)
  80a559:	81 c2 60 5f b3 00    	add    $0xb35f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a55f:	3b 42 08             	cmp    0x8(%edx),%eax
  80a562:	74 51                	je     80a5b5 <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a564:	83 ec 0c             	sub    $0xc,%esp
  80a567:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a56d:	ff b3 f0 5f b3 00    	pushl  0xb35ff0(%ebx)
  80a573:	e8 ec fc ff ff       	call   80a264 <sys_sem_signal>
    return waited;
  80a578:	83 c4 10             	add    $0x10,%esp
}
  80a57b:	89 f0                	mov    %esi,%eax
  80a57d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a580:	5b                   	pop    %ebx
  80a581:	5e                   	pop    %esi
  80a582:	5f                   	pop    %edi
  80a583:	5d                   	pop    %ebp
  80a584:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a585:	68 ae 2c 81 00       	push   $0x812cae
  80a58a:	68 6b 2c 81 00       	push   $0x812c6b
  80a58f:	68 ce 00 00 00       	push   $0xce
  80a594:	68 80 2c 81 00       	push   $0x812c80
  80a599:	e8 6b 42 00 00       	call   80e809 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a59e:	83 ec 04             	sub    $0x4,%esp
  80a5a1:	68 bc 2b 81 00       	push   $0x812bbc
  80a5a6:	68 d6 00 00 00       	push   $0xd6
  80a5ab:	68 80 2c 81 00       	push   $0x812c80
  80a5b0:	e8 54 42 00 00       	call   80e809 <_panic>
	mboxes[mbox].head = -1;
  80a5b5:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a5bb:	c7 80 64 5f b3 00 ff 	movl   $0xffffffff,0xb35f64(%eax)
  80a5c2:	ff ff ff 
  80a5c5:	eb 9d                	jmp    80a564 <sys_arch_mbox_fetch+0x8b>

0080a5c7 <sys_arch_mbox_tryfetch>:
{
  80a5c7:	55                   	push   %ebp
  80a5c8:	89 e5                	mov    %esp,%ebp
  80a5ca:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a5cd:	6a fe                	push   $0xfffffffe
  80a5cf:	ff 75 0c             	pushl  0xc(%ebp)
  80a5d2:	ff 75 08             	pushl  0x8(%ebp)
  80a5d5:	e8 ff fe ff ff       	call   80a4d9 <sys_arch_mbox_fetch>
}
  80a5da:	c9                   	leave  
  80a5db:	c3                   	ret    

0080a5dc <sys_thread_new>:
{
  80a5dc:	55                   	push   %ebp
  80a5dd:	89 e5                	mov    %esp,%ebp
  80a5df:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a5e2:	6a 08                	push   $0x8
  80a5e4:	e8 5e 64 00 00       	call   810a47 <malloc>
    if (lt == 0)
  80a5e9:	83 c4 10             	add    $0x10,%esp
  80a5ec:	85 c0                	test   %eax,%eax
  80a5ee:	74 32                	je     80a622 <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a5f0:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a5f7:	7f 40                	jg     80a639 <sys_thread_new+0x5d>
    lt->func = thread;
  80a5f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a5fc:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a5fe:	8b 55 10             	mov    0x10(%ebp),%edx
  80a601:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a604:	50                   	push   %eax
  80a605:	68 94 9e 80 00       	push   $0x809e94
  80a60a:	ff 75 08             	pushl  0x8(%ebp)
  80a60d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a610:	50                   	push   %eax
  80a611:	e8 c7 01 00 00       	call   80a7dd <thread_create>
    if (r < 0)
  80a616:	83 c4 10             	add    $0x10,%esp
  80a619:	85 c0                	test   %eax,%eax
  80a61b:	78 33                	js     80a650 <sys_thread_new+0x74>
}
  80a61d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a620:	c9                   	leave  
  80a621:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a622:	83 ec 04             	sub    $0x4,%esp
  80a625:	68 e4 2b 81 00       	push   $0x812be4
  80a62a:	68 fd 00 00 00       	push   $0xfd
  80a62f:	68 80 2c 81 00       	push   $0x812c80
  80a634:	e8 d0 41 00 00       	call   80e809 <_panic>
	panic("large stack %d", stacksize);
  80a639:	ff 75 14             	pushl  0x14(%ebp)
  80a63c:	68 de 2c 81 00       	push   $0x812cde
  80a641:	68 00 01 00 00       	push   $0x100
  80a646:	68 80 2c 81 00       	push   $0x812c80
  80a64b:	e8 b9 41 00 00       	call   80e809 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a650:	83 ec 0c             	sub    $0xc,%esp
  80a653:	50                   	push   %eax
  80a654:	e8 c0 04 00 00       	call   80ab19 <e2s>
  80a659:	50                   	push   %eax
  80a65a:	68 14 2c 81 00       	push   $0x812c14
  80a65f:	68 09 01 00 00       	push   $0x109
  80a664:	68 80 2c 81 00       	push   $0x812c80
  80a669:	e8 9b 41 00 00       	call   80e809 <_panic>

0080a66e <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a66e:	55                   	push   %ebp
  80a66f:	89 e5                	mov    %esp,%ebp
  80a671:	57                   	push   %edi
  80a672:	56                   	push   %esi
  80a673:	53                   	push   %ebx
  80a674:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a677:	e8 ef 00 00 00       	call   80a76b <thread_id>
  80a67c:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a67e:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a683:	f7 e2                	mul    %edx
  80a685:	c1 ea 08             	shr    $0x8,%edx
  80a688:	89 d7                	mov    %edx,%edi
  80a68a:	c1 e2 08             	shl    $0x8,%edx
  80a68d:	01 d7                	add    %edx,%edi
  80a68f:	89 f0                	mov    %esi,%eax
  80a691:	29 f8                	sub    %edi,%eax
  80a693:	89 c7                	mov    %eax,%edi
  80a695:	8b 1c 85 40 5b b3 00 	mov    0xb35b40(,%eax,4),%ebx
  80a69c:	85 db                	test   %ebx,%ebx
  80a69e:	74 09                	je     80a6a9 <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a6a0:	39 33                	cmp    %esi,(%ebx)
  80a6a2:	74 66                	je     80a70a <sys_arch_timeouts+0x9c>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a6a4:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a6a7:	eb f3                	jmp    80a69c <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a6a9:	83 ec 0c             	sub    $0xc,%esp
  80a6ac:	6a 10                	push   $0x10
  80a6ae:	e8 94 63 00 00       	call   810a47 <malloc>
  80a6b3:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a6b5:	83 c4 10             	add    $0x10,%esp
  80a6b8:	85 c0                	test   %eax,%eax
  80a6ba:	74 59                	je     80a715 <sys_arch_timeouts+0xa7>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a6bc:	83 ec 0c             	sub    $0xc,%esp
  80a6bf:	68 b3 9e 80 00       	push   $0x809eb3
  80a6c4:	e8 ea 00 00 00       	call   80a7b3 <thread_onhalt>
    if (r < 0)
  80a6c9:	83 c4 10             	add    $0x10,%esp
  80a6cc:	85 c0                	test   %eax,%eax
  80a6ce:	78 5c                	js     80a72c <sys_arch_timeouts+0xbe>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a6d0:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a6d2:	83 ec 04             	sub    $0x4,%esp
  80a6d5:	6a 04                	push   $0x4
  80a6d7:	6a 00                	push   $0x0
  80a6d9:	8d 43 04             	lea    0x4(%ebx),%eax
  80a6dc:	50                   	push   %eax
  80a6dd:	e8 c2 4a 00 00       	call   80f1a4 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a6e2:	8b 04 bd 40 5b b3 00 	mov    0xb35b40(,%edi,4),%eax
  80a6e9:	89 43 08             	mov    %eax,0x8(%ebx)
  80a6ec:	83 c4 10             	add    $0x10,%esp
  80a6ef:	85 c0                	test   %eax,%eax
  80a6f1:	74 06                	je     80a6f9 <sys_arch_timeouts+0x8b>
  80a6f3:	8d 53 08             	lea    0x8(%ebx),%edx
  80a6f6:	89 50 0c             	mov    %edx,0xc(%eax)
  80a6f9:	89 1c bd 40 5b b3 00 	mov    %ebx,0xb35b40(,%edi,4)
  80a700:	8d 04 bd 40 5b b3 00 	lea    0xb35b40(,%edi,4),%eax
  80a707:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a70a:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a70d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a710:	5b                   	pop    %ebx
  80a711:	5e                   	pop    %esi
  80a712:	5f                   	pop    %edi
  80a713:	5d                   	pop    %ebp
  80a714:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a715:	83 ec 04             	sub    $0x4,%esp
  80a718:	68 40 2c 81 00       	push   $0x812c40
  80a71d:	68 2c 01 00 00       	push   $0x12c
  80a722:	68 80 2c 81 00       	push   $0x812c80
  80a727:	e8 dd 40 00 00       	call   80e809 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a72c:	83 ec 0c             	sub    $0xc,%esp
  80a72f:	50                   	push   %eax
  80a730:	e8 e4 03 00 00       	call   80ab19 <e2s>
  80a735:	50                   	push   %eax
  80a736:	68 ed 2c 81 00       	push   $0x812ced
  80a73b:	68 30 01 00 00       	push   $0x130
  80a740:	68 80 2c 81 00       	push   $0x812c80
  80a745:	e8 bf 40 00 00       	call   80e809 <_panic>

0080a74a <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a74a:	c3                   	ret    

0080a74b <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a74b:	c3                   	ret    

0080a74c <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a74c:	c7 05 88 c1 b3 00 00 	movl   $0x0,0xb3c188
  80a753:	00 00 00 
    tq->tq_last = 0;
  80a756:	c7 05 8c c1 b3 00 00 	movl   $0x0,0xb3c18c
  80a75d:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a760:	c7 05 94 c1 b3 00 00 	movl   $0x0,0xb3c194
  80a767:	00 00 00 
}
  80a76a:	c3                   	ret    

0080a76b <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a76b:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a770:	8b 00                	mov    (%eax),%eax
}
  80a772:	c3                   	ret    

0080a773 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a773:	55                   	push   %ebp
  80a774:	89 e5                	mov    %esp,%ebp
  80a776:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a779:	a1 88 c1 b3 00       	mov    0xb3c188,%eax
    while (tc) {
  80a77e:	eb 07                	jmp    80a787 <thread_wakeup+0x14>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a780:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a784:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a787:	85 c0                	test   %eax,%eax
  80a789:	74 07                	je     80a792 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a78b:	39 50 48             	cmp    %edx,0x48(%eax)
  80a78e:	75 f4                	jne    80a784 <thread_wakeup+0x11>
  80a790:	eb ee                	jmp    80a780 <thread_wakeup+0xd>
    }
}
  80a792:	5d                   	pop    %ebp
  80a793:	c3                   	ret    

0080a794 <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a794:	8b 15 88 c1 b3 00    	mov    0xb3c188,%edx
    int n = 0;
  80a79a:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a79f:	85 d2                	test   %edx,%edx
  80a7a1:	74 0f                	je     80a7b2 <thread_wakeups_pending+0x1e>
	if (tc->tc_wakeup)
  80a7a3:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a7a7:	80 f9 01             	cmp    $0x1,%cl
  80a7aa:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a7ad:	8b 52 64             	mov    0x64(%edx),%edx
  80a7b0:	eb ed                	jmp    80a79f <thread_wakeups_pending+0xb>
    }
    return n;
}
  80a7b2:	c3                   	ret    

0080a7b3 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a7b3:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a7b8:	8b 50 60             	mov    0x60(%eax),%edx
  80a7bb:	83 fa 03             	cmp    $0x3,%edx
  80a7be:	7f 17                	jg     80a7d7 <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a7c0:	55                   	push   %ebp
  80a7c1:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a7c3:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a7c6:	89 48 60             	mov    %ecx,0x60(%eax)
  80a7c9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a7cc:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a7d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a7d5:	5d                   	pop    %ebp
  80a7d6:	c3                   	ret    
	return -E_NO_MEM;
  80a7d7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a7dc:	c3                   	ret    

0080a7dd <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a7dd:	55                   	push   %ebp
  80a7de:	89 e5                	mov    %esp,%ebp
  80a7e0:	57                   	push   %edi
  80a7e1:	56                   	push   %esi
  80a7e2:	53                   	push   %ebx
  80a7e3:	83 ec 18             	sub    $0x18,%esp
  80a7e6:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a7e9:	6a 68                	push   $0x68
  80a7eb:	e8 57 62 00 00       	call   810a47 <malloc>
    if (!tc)
  80a7f0:	83 c4 10             	add    $0x10,%esp
  80a7f3:	85 c0                	test   %eax,%eax
  80a7f5:	0f 84 04 01 00 00    	je     80a8ff <thread_create+0x122>
  80a7fb:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a7fd:	83 ec 04             	sub    $0x4,%esp
  80a800:	6a 68                	push   $0x68
  80a802:	6a 00                	push   $0x0
  80a804:	50                   	push   %eax
  80a805:	e8 9a 49 00 00       	call   80f1a4 <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a80a:	83 c4 0c             	add    $0xc,%esp
  80a80d:	6a 1f                	push   $0x1f
  80a80f:	ff 75 0c             	pushl  0xc(%ebp)
  80a812:	8d 43 08             	lea    0x8(%ebx),%eax
  80a815:	50                   	push   %eax
  80a816:	e8 88 48 00 00       	call   80f0a3 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a81b:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a81f:	a1 94 c1 b3 00       	mov    0xb3c194,%eax
  80a824:	8d 50 01             	lea    0x1(%eax),%edx
  80a827:	89 15 94 c1 b3 00    	mov    %edx,0xb3c194
    if (max_tid == (uint32_t)~0)
  80a82d:	83 c4 10             	add    $0x10,%esp
  80a830:	83 fa ff             	cmp    $0xffffffff,%edx
  80a833:	0f 84 91 00 00 00    	je     80a8ca <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a839:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a83b:	83 ec 0c             	sub    $0xc,%esp
  80a83e:	68 00 10 00 00       	push   $0x1000
  80a843:	e8 ff 61 00 00       	call   810a47 <malloc>
  80a848:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a84b:	83 c4 10             	add    $0x10,%esp
  80a84e:	85 c0                	test   %eax,%eax
  80a850:	0f 84 88 00 00 00    	je     80a8de <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a856:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a85c:	83 ec 04             	sub    $0x4,%esp
  80a85f:	6a 04                	push   $0x4
  80a861:	6a 00                	push   $0x0
  80a863:	57                   	push   %edi
  80a864:	e8 3b 49 00 00       	call   80f1a4 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a869:	83 c4 0c             	add    $0xc,%esp
  80a86c:	6a 18                	push   $0x18
  80a86e:	6a 00                	push   $0x0
  80a870:	8d 43 30             	lea    0x30(%ebx),%eax
  80a873:	50                   	push   %eax
  80a874:	e8 2b 49 00 00       	call   80f1a4 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a879:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a87c:	c7 43 30 8a aa 80 00 	movl   $0x80aa8a,0x30(%ebx)
    tc->tc_entry = entry;
  80a883:	8b 45 10             	mov    0x10(%ebp),%eax
  80a886:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a889:	8b 45 14             	mov    0x14(%ebp),%eax
  80a88c:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a88f:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a896:	83 c4 10             	add    $0x10,%esp
  80a899:	83 3d 88 c1 b3 00 00 	cmpl   $0x0,0xb3c188
  80a8a0:	74 4f                	je     80a8f1 <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a8a2:	a1 8c c1 b3 00       	mov    0xb3c18c,%eax
  80a8a7:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a8aa:	89 1d 8c c1 b3 00    	mov    %ebx,0xb3c18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a8b0:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a8b5:	85 f6                	test   %esi,%esi
  80a8b7:	74 09                	je     80a8c2 <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a8b9:	8b 03                	mov    (%ebx),%eax
  80a8bb:	89 06                	mov    %eax,(%esi)
    return 0;
  80a8bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a8c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a8c5:	5b                   	pop    %ebx
  80a8c6:	5e                   	pop    %esi
  80a8c7:	5f                   	pop    %edi
  80a8c8:	5d                   	pop    %ebp
  80a8c9:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a8ca:	83 ec 04             	sub    $0x4,%esp
  80a8cd:	68 06 2d 81 00       	push   $0x812d06
  80a8d2:	6a 54                	push   $0x54
  80a8d4:	68 24 2d 81 00       	push   $0x812d24
  80a8d9:	e8 2b 3f 00 00       	call   80e809 <_panic>
	free(tc);
  80a8de:	83 ec 0c             	sub    $0xc,%esp
  80a8e1:	53                   	push   %ebx
  80a8e2:	e8 b4 60 00 00       	call   81099b <free>
	return -E_NO_MEM;
  80a8e7:	83 c4 10             	add    $0x10,%esp
  80a8ea:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a8ef:	eb d1                	jmp    80a8c2 <thread_create+0xe5>
	tq->tq_first = tc;
  80a8f1:	89 1d 88 c1 b3 00    	mov    %ebx,0xb3c188
	tq->tq_last = tc;
  80a8f7:	89 1d 8c c1 b3 00    	mov    %ebx,0xb3c18c
  80a8fd:	eb b1                	jmp    80a8b0 <thread_create+0xd3>
	return -E_NO_MEM;
  80a8ff:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a904:	eb bc                	jmp    80a8c2 <thread_create+0xe5>

0080a906 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a906:	55                   	push   %ebp
  80a907:	89 e5                	mov    %esp,%ebp
  80a909:	53                   	push   %ebx
  80a90a:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a90d:	8b 1d 88 c1 b3 00    	mov    0xb3c188,%ebx
  80a913:	85 db                	test   %ebx,%ebx
  80a915:	74 2b                	je     80a942 <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a917:	8b 43 64             	mov    0x64(%ebx),%eax
  80a91a:	a3 88 c1 b3 00       	mov    %eax,0xb3c188
    tc->tc_queue_link = 0;
  80a91f:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a926:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a92b:	85 c0                	test   %eax,%eax
  80a92d:	74 3b                	je     80a96a <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a92f:	83 ec 0c             	sub    $0xc,%esp
  80a932:	83 c0 30             	add    $0x30,%eax
  80a935:	50                   	push   %eax
  80a936:	e8 75 01 00 00       	call   80aab0 <jos_setjmp>
  80a93b:	83 c4 10             	add    $0x10,%esp
  80a93e:	85 c0                	test   %eax,%eax
  80a940:	74 05                	je     80a947 <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a942:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a945:	c9                   	leave  
  80a946:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a947:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
    tc->tc_queue_link = 0;
  80a94c:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a953:	83 3d 88 c1 b3 00 00 	cmpl   $0x0,0xb3c188
  80a95a:	74 21                	je     80a97d <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a95c:	8b 15 8c c1 b3 00    	mov    0xb3c18c,%edx
  80a962:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a965:	a3 8c c1 b3 00       	mov    %eax,0xb3c18c
    cur_tc = next_tc;
  80a96a:	89 1d 90 c1 b3 00    	mov    %ebx,0xb3c190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a970:	8d 43 30             	lea    0x30(%ebx),%eax
  80a973:	ba 01 00 00 00       	mov    $0x1,%edx
  80a978:	e8 63 01 00 00       	call   80aae0 <jos_longjmp>
	tq->tq_first = tc;
  80a97d:	a3 88 c1 b3 00       	mov    %eax,0xb3c188
	tq->tq_last = tc;
  80a982:	a3 8c c1 b3 00       	mov    %eax,0xb3c18c
  80a987:	eb e1                	jmp    80a96a <thread_yield+0x64>

0080a989 <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a989:	55                   	push   %ebp
  80a98a:	89 e5                	mov    %esp,%ebp
  80a98c:	57                   	push   %edi
  80a98d:	56                   	push   %esi
  80a98e:	53                   	push   %ebx
  80a98f:	83 ec 0c             	sub    $0xc,%esp
  80a992:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a995:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a998:	e8 e5 4c 00 00       	call   80f682 <sys_time_msec>
  80a99d:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a99f:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a9a4:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a9a7:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a9ab:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a9ad:	eb 17                	jmp    80a9c6 <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a9af:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a9b4:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a9b8:	84 c0                	test   %al,%al
  80a9ba:	75 1d                	jne    80a9d9 <thread_wait+0x50>
	thread_yield();
  80a9bc:	e8 45 ff ff ff       	call   80a906 <thread_yield>
	p = sys_time_msec();
  80a9c1:	e8 bc 4c 00 00       	call   80f682 <sys_time_msec>
	if (p < s)
  80a9c6:	39 f0                	cmp    %esi,%eax
  80a9c8:	72 0f                	jb     80a9d9 <thread_wait+0x50>
  80a9ca:	39 f8                	cmp    %edi,%eax
  80a9cc:	73 0b                	jae    80a9d9 <thread_wait+0x50>
	if (addr && *addr != val)
  80a9ce:	85 db                	test   %ebx,%ebx
  80a9d0:	74 dd                	je     80a9af <thread_wait+0x26>
  80a9d2:	8b 03                	mov    (%ebx),%eax
  80a9d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a9d7:	74 d6                	je     80a9af <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a9d9:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80a9de:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a9e5:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a9e9:	83 c4 0c             	add    $0xc,%esp
  80a9ec:	5b                   	pop    %ebx
  80a9ed:	5e                   	pop    %esi
  80a9ee:	5f                   	pop    %edi
  80a9ef:	5d                   	pop    %ebp
  80a9f0:	c3                   	ret    

0080a9f1 <thread_halt>:
thread_halt() {
  80a9f1:	55                   	push   %ebp
  80a9f2:	89 e5                	mov    %esp,%ebp
  80a9f4:	56                   	push   %esi
  80a9f5:	53                   	push   %ebx
    if (!tq->tq_first)
  80a9f6:	8b 1d 80 c1 b3 00    	mov    0xb3c180,%ebx
  80a9fc:	85 db                	test   %ebx,%ebx
  80a9fe:	74 40                	je     80aa40 <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80aa00:	8b 43 64             	mov    0x64(%ebx),%eax
  80aa03:	a3 80 c1 b3 00       	mov    %eax,0xb3c180
    tc->tc_queue_link = 0;
  80aa08:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80aa0f:	be 00 00 00 00       	mov    $0x0,%esi
  80aa14:	eb 0f                	jmp    80aa25 <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80aa16:	83 ec 0c             	sub    $0xc,%esp
  80aa19:	ff 33                	pushl  (%ebx)
  80aa1b:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80aa1f:	83 c6 01             	add    $0x1,%esi
  80aa22:	83 c4 10             	add    $0x10,%esp
  80aa25:	3b 73 60             	cmp    0x60(%ebx),%esi
  80aa28:	7c ec                	jl     80aa16 <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80aa2a:	83 ec 0c             	sub    $0xc,%esp
  80aa2d:	ff 73 04             	pushl  0x4(%ebx)
  80aa30:	e8 66 5f 00 00       	call   81099b <free>
    free(tc);
  80aa35:	89 1c 24             	mov    %ebx,(%esp)
  80aa38:	e8 5e 5f 00 00       	call   81099b <free>
  80aa3d:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80aa40:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
    tc->tc_queue_link = 0;
  80aa45:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80aa4c:	83 3d 80 c1 b3 00 00 	cmpl   $0x0,0xb3c180
  80aa53:	74 29                	je     80aa7e <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80aa55:	8b 15 84 c1 b3 00    	mov    0xb3c184,%edx
  80aa5b:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80aa5e:	a3 84 c1 b3 00       	mov    %eax,0xb3c184
    cur_tc = NULL;
  80aa63:	c7 05 90 c1 b3 00 00 	movl   $0x0,0xb3c190
  80aa6a:	00 00 00 
    thread_yield();
  80aa6d:	e8 94 fe ff ff       	call   80a906 <thread_yield>
    exit();
  80aa72:	e8 5e 3d 00 00       	call   80e7d5 <exit>
}
  80aa77:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80aa7a:	5b                   	pop    %ebx
  80aa7b:	5e                   	pop    %esi
  80aa7c:	5d                   	pop    %ebp
  80aa7d:	c3                   	ret    
	tq->tq_first = tc;
  80aa7e:	a3 80 c1 b3 00       	mov    %eax,0xb3c180
	tq->tq_last = tc;
  80aa83:	a3 84 c1 b3 00       	mov    %eax,0xb3c184
  80aa88:	eb d9                	jmp    80aa63 <thread_halt+0x72>

0080aa8a <thread_entry>:
thread_entry(void) {
  80aa8a:	55                   	push   %ebp
  80aa8b:	89 e5                	mov    %esp,%ebp
  80aa8d:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80aa90:	a1 90 c1 b3 00       	mov    0xb3c190,%eax
  80aa95:	ff 70 2c             	pushl  0x2c(%eax)
  80aa98:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80aa9b:	e8 51 ff ff ff       	call   80a9f1 <thread_halt>
}
  80aaa0:	83 c4 10             	add    $0x10,%esp
  80aaa3:	c9                   	leave  
  80aaa4:	c3                   	ret    
  80aaa5:	66 90                	xchg   %ax,%ax
  80aaa7:	66 90                	xchg   %ax,%ax
  80aaa9:	66 90                	xchg   %ax,%ax
  80aaab:	66 90                	xchg   %ax,%ax
  80aaad:	66 90                	xchg   %ax,%ax
  80aaaf:	90                   	nop

0080aab0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80aab0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80aab4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80aab7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80aab9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80aabd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80aac0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80aac3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80aac6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80aac9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80aacc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80aad1:	c3                   	ret    
  80aad2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80aad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080aae0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80aae0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80aae2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80aae5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80aae8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80aaeb:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80aaee:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80aaf1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80aaf3:	ff e1                	jmp    *%ecx

0080aaf5 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80aaf5:	55                   	push   %ebp
  80aaf6:	89 e5                	mov    %esp,%ebp
  80aaf8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80aafb:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80ab00:	ff 34 85 20 50 81 00 	pushl  0x815020(,%eax,4)
  80ab07:	ff 75 08             	pushl  0x8(%ebp)
  80ab0a:	68 3f 2d 81 00       	push   $0x812d3f
  80ab0f:	e8 eb 3d 00 00       	call   80e8ff <cprintf>
}
  80ab14:	83 c4 10             	add    $0x10,%esp
  80ab17:	c9                   	leave  
  80ab18:	c3                   	ret    

0080ab19 <e2s>:
e2s(int err) {
  80ab19:	55                   	push   %ebp
  80ab1a:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80ab1c:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab1f:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80ab26:	5d                   	pop    %ebp
  80ab27:	c3                   	ret    

0080ab28 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80ab28:	55                   	push   %ebp
  80ab29:	89 e5                	mov    %esp,%ebp
  80ab2b:	57                   	push   %edi
  80ab2c:	56                   	push   %esi
  80ab2d:	53                   	push   %ebx
  80ab2e:	83 ec 20             	sub    $0x20,%esp
  80ab31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80ab34:	6a 07                	push   $0x7
  80ab36:	68 00 00 00 10       	push   $0x10000000
  80ab3b:	6a 00                	push   $0x0
  80ab3d:	e8 0e 49 00 00       	call   80f450 <sys_page_alloc>
    if (r < 0)
  80ab42:	83 c4 10             	add    $0x10,%esp
  80ab45:	85 c0                	test   %eax,%eax
  80ab47:	78 49                	js     80ab92 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80ab49:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab4c:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ab4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80ab52:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80ab57:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80ab5c:	85 db                	test   %ebx,%ebx
  80ab5e:	74 5c                	je     80abbc <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80ab60:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ab64:	0f b7 d0             	movzwl %ax,%edx
  80ab67:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80ab6a:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80ab70:	7f 34                	jg     80aba6 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80ab72:	83 ec 04             	sub    $0x4,%esp
  80ab75:	0f b7 c0             	movzwl %ax,%eax
  80ab78:	50                   	push   %eax
  80ab79:	ff 73 04             	pushl  0x4(%ebx)
  80ab7c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80ab7f:	50                   	push   %eax
  80ab80:	e8 c9 46 00 00       	call   80f24e <memcpy>
	txsize += q->len;
  80ab85:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ab89:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80ab8b:	8b 1b                	mov    (%ebx),%ebx
  80ab8d:	83 c4 10             	add    $0x10,%esp
  80ab90:	eb ca                	jmp    80ab5c <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80ab92:	83 ec 04             	sub    $0x4,%esp
  80ab95:	68 24 32 81 00       	push   $0x813224
  80ab9a:	6a 55                	push   $0x55
  80ab9c:	68 75 32 81 00       	push   $0x813275
  80aba1:	e8 63 3c 00 00       	call   80e809 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80aba6:	83 ec 0c             	sub    $0xc,%esp
  80aba9:	56                   	push   %esi
  80abaa:	52                   	push   %edx
  80abab:	68 4c 32 81 00       	push   $0x81324c
  80abb0:	6a 64                	push   $0x64
  80abb2:	68 75 32 81 00       	push   $0x813275
  80abb7:	e8 4d 3c 00 00       	call   80e809 <_panic>
    }

    pkt->jp_len = txsize;
  80abbc:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80abc2:	6a 07                	push   $0x7
  80abc4:	68 00 00 00 10       	push   $0x10000000
  80abc9:	6a 0b                	push   $0xb
  80abcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80abce:	ff 70 04             	pushl  0x4(%eax)
  80abd1:	e8 9f 50 00 00       	call   80fc75 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80abd6:	83 c4 08             	add    $0x8,%esp
  80abd9:	68 00 00 00 10       	push   $0x10000000
  80abde:	6a 00                	push   $0x0
  80abe0:	e8 f0 48 00 00       	call   80f4d5 <sys_page_unmap>

    return ERR_OK;
}
  80abe5:	b8 00 00 00 00       	mov    $0x0,%eax
  80abea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80abed:	5b                   	pop    %ebx
  80abee:	5e                   	pop    %esi
  80abef:	5f                   	pop    %edi
  80abf0:	5d                   	pop    %ebp
  80abf1:	c3                   	ret    

0080abf2 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80abf2:	55                   	push   %ebp
  80abf3:	89 e5                	mov    %esp,%ebp
  80abf5:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80abf8:	ff 75 10             	pushl  0x10(%ebp)
  80abfb:	ff 75 0c             	pushl  0xc(%ebp)
  80abfe:	ff 75 08             	pushl  0x8(%ebp)
  80ac01:	e8 05 f1 ff ff       	call   809d0b <etharp_output>
}
  80ac06:	c9                   	leave  
  80ac07:	c3                   	ret    

0080ac08 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80ac08:	55                   	push   %ebp
  80ac09:	89 e5                	mov    %esp,%ebp
  80ac0b:	57                   	push   %edi
  80ac0c:	56                   	push   %esi
  80ac0d:	53                   	push   %ebx
  80ac0e:	83 ec 20             	sub    $0x20,%esp
  80ac11:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80ac14:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac17:	8b 40 1c             	mov    0x1c(%eax),%eax
  80ac1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80ac1d:	8b 06                	mov    (%esi),%eax
  80ac1f:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80ac21:	6a 03                	push   $0x3
  80ac23:	0f b7 c0             	movzwl %ax,%eax
  80ac26:	50                   	push   %eax
  80ac27:	6a 03                	push   $0x3
  80ac29:	e8 8c 9e ff ff       	call   804aba <pbuf_alloc>
    if (p == 0)
  80ac2e:	83 c4 10             	add    $0x10,%esp
  80ac31:	85 c0                	test   %eax,%eax
  80ac33:	0f 84 9c 00 00 00    	je     80acd5 <jif_input+0xcd>
  80ac39:	89 c7                	mov    %eax,%edi
    void *rxbuf = (void *) pkt->jp_data;
  80ac3b:	8d 46 04             	lea    0x4(%esi),%eax
  80ac3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80ac41:	89 fe                	mov    %edi,%esi
    int copied = 0;
  80ac43:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80ac48:	0f bf c3             	movswl %bx,%eax
  80ac4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ac4e:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80ac51:	89 d7                	mov    %edx,%edi
	int bytes = q->len;
  80ac53:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80ac57:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80ac5a:	29 fb                	sub    %edi,%ebx
  80ac5c:	39 c3                	cmp    %eax,%ebx
  80ac5e:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80ac61:	83 ec 04             	sub    $0x4,%esp
  80ac64:	53                   	push   %ebx
  80ac65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac68:	01 f8                	add    %edi,%eax
  80ac6a:	50                   	push   %eax
  80ac6b:	ff 76 04             	pushl  0x4(%esi)
  80ac6e:	e8 db 45 00 00       	call   80f24e <memcpy>
	copied += bytes;
  80ac73:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80ac75:	8b 36                	mov    (%esi),%esi
  80ac77:	83 c4 10             	add    $0x10,%esp
  80ac7a:	85 f6                	test   %esi,%esi
  80ac7c:	75 d5                	jne    80ac53 <jif_input+0x4b>
  80ac7e:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80ac81:	83 ec 0c             	sub    $0xc,%esp
  80ac84:	8b 47 04             	mov    0x4(%edi),%eax
  80ac87:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ac8b:	50                   	push   %eax
  80ac8c:	e8 3d cc ff ff       	call   8078ce <htons>
  80ac91:	83 c4 10             	add    $0x10,%esp
  80ac94:	66 3d 00 08          	cmp    $0x800,%ax
  80ac98:	74 14                	je     80acae <jif_input+0xa6>
  80ac9a:	66 3d 06 08          	cmp    $0x806,%ax
  80ac9e:	74 3d                	je     80acdd <jif_input+0xd5>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80aca0:	83 ec 0c             	sub    $0xc,%esp
  80aca3:	57                   	push   %edi
  80aca4:	e8 4b 9d ff ff       	call   8049f4 <pbuf_free>
  80aca9:	83 c4 10             	add    $0x10,%esp
  80acac:	eb 27                	jmp    80acd5 <jif_input+0xcd>
	etharp_ip_input(netif, p);
  80acae:	83 ec 08             	sub    $0x8,%esp
  80acb1:	57                   	push   %edi
  80acb2:	ff 75 08             	pushl  0x8(%ebp)
  80acb5:	e8 c9 ea ff ff       	call   809783 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80acba:	83 c4 08             	add    $0x8,%esp
  80acbd:	6a f2                	push   $0xfffffff2
  80acbf:	57                   	push   %edi
  80acc0:	e8 62 9c ff ff       	call   804927 <pbuf_header>
	netif->input(p, netif);
  80acc5:	83 c4 08             	add    $0x8,%esp
  80acc8:	ff 75 08             	pushl  0x8(%ebp)
  80accb:	57                   	push   %edi
  80accc:	8b 45 08             	mov    0x8(%ebp),%eax
  80accf:	ff 50 10             	call   *0x10(%eax)
	break;
  80acd2:	83 c4 10             	add    $0x10,%esp
    }
}
  80acd5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80acd8:	5b                   	pop    %ebx
  80acd9:	5e                   	pop    %esi
  80acda:	5f                   	pop    %edi
  80acdb:	5d                   	pop    %ebp
  80acdc:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80acdd:	83 ec 04             	sub    $0x4,%esp
  80ace0:	57                   	push   %edi
  80ace1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ace4:	ff 30                	pushl  (%eax)
  80ace6:	ff 75 08             	pushl  0x8(%ebp)
  80ace9:	e8 e1 ea ff ff       	call   8097cf <etharp_arp_input>
	break;
  80acee:	83 c4 10             	add    $0x10,%esp
  80acf1:	eb e2                	jmp    80acd5 <jif_input+0xcd>

0080acf3 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80acf3:	55                   	push   %ebp
  80acf4:	89 e5                	mov    %esp,%ebp
  80acf6:	57                   	push   %edi
  80acf7:	56                   	push   %esi
  80acf8:	53                   	push   %ebx
  80acf9:	83 ec 28             	sub    $0x28,%esp
  80acfc:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80acff:	6a 08                	push   $0x8
  80ad01:	e8 f7 96 ff ff       	call   8043fd <mem_malloc>

    if (jif == NULL) {
  80ad06:	83 c4 10             	add    $0x10,%esp
  80ad09:	85 c0                	test   %eax,%eax
  80ad0b:	0f 84 87 00 00 00    	je     80ad98 <jif_init+0xa5>
  80ad11:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80ad13:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80ad16:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80ad19:	c7 43 14 f2 ab 80 00 	movl   $0x80abf2,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ad20:	c7 43 18 28 ab 80 00 	movl   $0x80ab28,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ad27:	83 ec 04             	sub    $0x4,%esp
  80ad2a:	6a 02                	push   $0x2
  80ad2c:	68 90 40 81 00       	push   $0x814090
  80ad31:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ad34:	50                   	push   %eax
  80ad35:	e8 14 45 00 00       	call   80f24e <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ad3a:	8d 43 25             	lea    0x25(%ebx),%eax
  80ad3d:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ad3f:	8b 07                	mov    (%edi),%eax
  80ad41:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80ad44:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ad48:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ad4e:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80ad52:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ad56:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ad5a:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ad5e:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ad62:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ad66:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ad6a:	c7 04 24 cb 15 81 00 	movl   $0x8115cb,(%esp)
  80ad71:	e8 67 cd ff ff       	call   807add <inet_addr>
  80ad76:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ad79:	83 c4 0c             	add    $0xc,%esp
  80ad7c:	6a 00                	push   $0x0
  80ad7e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad81:	50                   	push   %eax
  80ad82:	53                   	push   %ebx
  80ad83:	e8 4d ed ff ff       	call   809ad5 <etharp_query>

    return ERR_OK;
  80ad88:	83 c4 10             	add    $0x10,%esp
  80ad8b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ad90:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ad93:	5b                   	pop    %ebx
  80ad94:	5e                   	pop    %esi
  80ad95:	5f                   	pop    %edi
  80ad96:	5d                   	pop    %ebp
  80ad97:	c3                   	ret    
	return ERR_MEM;
  80ad98:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ad9d:	eb f1                	jmp    80ad90 <jif_init+0x9d>

0080ad9f <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ad9f:	55                   	push   %ebp
  80ada0:	89 e5                	mov    %esp,%ebp
  80ada2:	56                   	push   %esi
  80ada3:	53                   	push   %ebx
  80ada4:	83 ec 28             	sub    $0x28,%esp
  80ada7:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80adaa:	ff 75 10             	pushl  0x10(%ebp)
  80adad:	ff 75 08             	pushl  0x8(%ebp)
  80adb0:	e8 47 0f 00 00       	call   80bcfc <netconn_alloc>
  80adb5:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80adb7:	83 c4 10             	add    $0x10,%esp
  80adba:	85 c0                	test   %eax,%eax
  80adbc:	74 63                	je     80ae21 <netconn_new_with_proto_and_callback+0x82>
    msg.function = do_newconn;
  80adbe:	c7 45 e4 f3 bb 80 00 	movl   $0x80bbf3,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80adc5:	89 f0                	mov    %esi,%eax
  80adc7:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80adca:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80adcd:	83 ec 0c             	sub    $0xc,%esp
  80add0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80add3:	50                   	push   %eax
  80add4:	e8 92 77 ff ff       	call   80256b <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80add9:	83 c4 10             	add    $0x10,%esp
  80addc:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ade0:	74 3f                	je     80ae21 <netconn_new_with_proto_and_callback+0x82>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ade2:	8b 73 08             	mov    0x8(%ebx),%esi
  80ade5:	85 f6                	test   %esi,%esi
  80ade7:	75 41                	jne    80ae2a <netconn_new_with_proto_and_callback+0x8b>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ade9:	8b 43 10             	mov    0x10(%ebx),%eax
  80adec:	83 f8 ff             	cmp    $0xffffffff,%eax
  80adef:	74 4d                	je     80ae3e <netconn_new_with_proto_and_callback+0x9f>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80adf1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80adf5:	74 5b                	je     80ae52 <netconn_new_with_proto_and_callback+0xb3>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80adf7:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80adfb:	75 69                	jne    80ae66 <netconn_new_with_proto_and_callback+0xc7>
      sys_sem_free(conn->op_completed);
  80adfd:	83 ec 0c             	sub    $0xc,%esp
  80ae00:	50                   	push   %eax
  80ae01:	e8 22 f2 ff ff       	call   80a028 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ae06:	83 c4 04             	add    $0x4,%esp
  80ae09:	ff 73 14             	pushl  0x14(%ebx)
  80ae0c:	e8 a0 f2 ff ff       	call   80a0b1 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ae11:	83 c4 08             	add    $0x8,%esp
  80ae14:	53                   	push   %ebx
  80ae15:	6a 07                	push   $0x7
  80ae17:	e8 8b 98 ff ff       	call   8046a7 <memp_free>
      return NULL;
  80ae1c:	83 c4 10             	add    $0x10,%esp
  80ae1f:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80ae21:	89 d8                	mov    %ebx,%eax
  80ae23:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ae26:	5b                   	pop    %ebx
  80ae27:	5e                   	pop    %esi
  80ae28:	5d                   	pop    %ebp
  80ae29:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ae2a:	83 ec 04             	sub    $0x4,%esp
  80ae2d:	68 8c 32 81 00       	push   $0x81328c
  80ae32:	6a 52                	push   $0x52
  80ae34:	68 3e 33 81 00       	push   $0x81333e
  80ae39:	e8 cb 39 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ae3e:	83 ec 04             	sub    $0x4,%esp
  80ae41:	68 55 33 81 00       	push   $0x813355
  80ae46:	6a 53                	push   $0x53
  80ae48:	68 3e 33 81 00       	push   $0x81333e
  80ae4d:	e8 b7 39 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ae52:	83 ec 04             	sub    $0x4,%esp
  80ae55:	68 6e 33 81 00       	push   $0x81336e
  80ae5a:	6a 54                	push   $0x54
  80ae5c:	68 3e 33 81 00       	push   $0x81333e
  80ae61:	e8 a3 39 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ae66:	83 ec 04             	sub    $0x4,%esp
  80ae69:	68 b0 32 81 00       	push   $0x8132b0
  80ae6e:	6a 55                	push   $0x55
  80ae70:	68 3e 33 81 00       	push   $0x81333e
  80ae75:	e8 8f 39 00 00       	call   80e809 <_panic>

0080ae7a <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ae7a:	55                   	push   %ebp
  80ae7b:	89 e5                	mov    %esp,%ebp
  80ae7d:	53                   	push   %ebx
  80ae7e:	83 ec 24             	sub    $0x24,%esp
  80ae81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ae84:	85 db                	test   %ebx,%ebx
  80ae86:	74 28                	je     80aeb0 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ae88:	c7 45 e4 3b bf 80 00 	movl   $0x80bf3b,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae8f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ae92:	83 ec 0c             	sub    $0xc,%esp
  80ae95:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae98:	50                   	push   %eax
  80ae99:	e8 cd 76 ff ff       	call   80256b <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ae9e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80aea5:	89 1c 24             	mov    %ebx,(%esp)
  80aea8:	e8 fd 0e 00 00       	call   80bdaa <netconn_free>

  return ERR_OK;
  80aead:	83 c4 10             	add    $0x10,%esp
}
  80aeb0:	b8 00 00 00 00       	mov    $0x0,%eax
  80aeb5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aeb8:	c9                   	leave  
  80aeb9:	c3                   	ret    

0080aeba <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80aeba:	55                   	push   %ebp
  80aebb:	89 e5                	mov    %esp,%ebp
  80aebd:	83 ec 08             	sub    $0x8,%esp
  80aec0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80aec3:	85 c0                	test   %eax,%eax
  80aec5:	74 04                	je     80aecb <netconn_type+0x11>
  80aec7:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80aec9:	c9                   	leave  
  80aeca:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80aecb:	83 ec 04             	sub    $0x4,%esp
  80aece:	68 83 33 81 00       	push   $0x813383
  80aed3:	68 84 00 00 00       	push   $0x84
  80aed8:	68 3e 33 81 00       	push   $0x81333e
  80aedd:	e8 27 39 00 00       	call   80e809 <_panic>

0080aee2 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80aee2:	55                   	push   %ebp
  80aee3:	89 e5                	mov    %esp,%ebp
  80aee5:	53                   	push   %ebx
  80aee6:	83 ec 24             	sub    $0x24,%esp
  80aee9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aeec:	8b 55 0c             	mov    0xc(%ebp),%edx
  80aeef:	8b 45 10             	mov    0x10(%ebp),%eax
  80aef2:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80aef5:	85 db                	test   %ebx,%ebx
  80aef7:	74 30                	je     80af29 <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80aef9:	85 d2                	test   %edx,%edx
  80aefb:	74 43                	je     80af40 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80aefd:	85 c0                	test   %eax,%eax
  80aeff:	74 56                	je     80af57 <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80af01:	c7 45 e4 8a c3 80 00 	movl   $0x80c38a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af08:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80af0b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80af0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80af11:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80af14:	83 ec 0c             	sub    $0xc,%esp
  80af17:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af1a:	50                   	push   %eax
  80af1b:	e8 4b 76 ff ff       	call   80256b <tcpip_apimsg>

  return conn->err;
  80af20:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af24:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af27:	c9                   	leave  
  80af28:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80af29:	83 ec 04             	sub    $0x4,%esp
  80af2c:	68 9e 33 81 00       	push   $0x81339e
  80af31:	68 98 00 00 00       	push   $0x98
  80af36:	68 3e 33 81 00       	push   $0x81333e
  80af3b:	e8 c9 38 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80af40:	83 ec 04             	sub    $0x4,%esp
  80af43:	68 bc 33 81 00       	push   $0x8133bc
  80af48:	68 99 00 00 00       	push   $0x99
  80af4d:	68 3e 33 81 00       	push   $0x81333e
  80af52:	e8 b2 38 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80af57:	83 ec 04             	sub    $0x4,%esp
  80af5a:	68 da 33 81 00       	push   $0x8133da
  80af5f:	68 9a 00 00 00       	push   $0x9a
  80af64:	68 3e 33 81 00       	push   $0x81333e
  80af69:	e8 9b 38 00 00       	call   80e809 <_panic>

0080af6e <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80af6e:	55                   	push   %ebp
  80af6f:	89 e5                	mov    %esp,%ebp
  80af71:	53                   	push   %ebx
  80af72:	83 ec 24             	sub    $0x24,%esp
  80af75:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80af78:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80af7b:	85 db                	test   %ebx,%ebx
  80af7d:	74 29                	je     80afa8 <netconn_bind+0x3a>

  msg.function = do_bind;
  80af7f:	c7 45 e4 e4 bf 80 00 	movl   $0x80bfe4,-0x1c(%ebp)
  msg.msg.conn = conn;
  80af86:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80af89:	8b 55 0c             	mov    0xc(%ebp),%edx
  80af8c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80af8f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80af93:	83 ec 0c             	sub    $0xc,%esp
  80af96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af99:	50                   	push   %eax
  80af9a:	e8 cc 75 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80af9f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80afa3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80afa6:	c9                   	leave  
  80afa7:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80afa8:	83 ec 04             	sub    $0x4,%esp
  80afab:	68 f8 33 81 00       	push   $0x8133f8
  80afb0:	68 b5 00 00 00       	push   $0xb5
  80afb5:	68 3e 33 81 00       	push   $0x81333e
  80afba:	e8 4a 38 00 00       	call   80e809 <_panic>

0080afbf <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80afbf:	55                   	push   %ebp
  80afc0:	89 e5                	mov    %esp,%ebp
  80afc2:	53                   	push   %ebx
  80afc3:	83 ec 24             	sub    $0x24,%esp
  80afc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80afc9:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80afcc:	85 db                	test   %ebx,%ebx
  80afce:	74 29                	je     80aff9 <netconn_connect+0x3a>

  msg.function = do_connect;
  80afd0:	c7 45 e4 74 c0 80 00 	movl   $0x80c074,-0x1c(%ebp)
  msg.msg.conn = conn;
  80afd7:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80afda:	8b 55 0c             	mov    0xc(%ebp),%edx
  80afdd:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80afe0:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80afe4:	83 ec 0c             	sub    $0xc,%esp
  80afe7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80afea:	50                   	push   %eax
  80afeb:	e8 7b 75 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80aff0:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80aff4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aff7:	c9                   	leave  
  80aff8:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aff9:	83 ec 04             	sub    $0x4,%esp
  80affc:	68 13 34 81 00       	push   $0x813413
  80b001:	68 cc 00 00 00       	push   $0xcc
  80b006:	68 3e 33 81 00       	push   $0x81333e
  80b00b:	e8 f9 37 00 00       	call   80e809 <_panic>

0080b010 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b010:	55                   	push   %ebp
  80b011:	89 e5                	mov    %esp,%ebp
  80b013:	53                   	push   %ebx
  80b014:	83 ec 24             	sub    $0x24,%esp
  80b017:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b01a:	85 db                	test   %ebx,%ebx
  80b01c:	74 1f                	je     80b03d <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80b01e:	c7 45 e4 29 c1 80 00 	movl   $0x80c129,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b025:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b028:	83 ec 0c             	sub    $0xc,%esp
  80b02b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b02e:	50                   	push   %eax
  80b02f:	e8 37 75 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80b034:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b038:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b03b:	c9                   	leave  
  80b03c:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b03d:	83 ec 04             	sub    $0x4,%esp
  80b040:	68 d4 32 81 00       	push   $0x8132d4
  80b045:	68 e2 00 00 00       	push   $0xe2
  80b04a:	68 3e 33 81 00       	push   $0x81333e
  80b04f:	e8 b5 37 00 00       	call   80e809 <_panic>

0080b054 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b054:	55                   	push   %ebp
  80b055:	89 e5                	mov    %esp,%ebp
  80b057:	53                   	push   %ebx
  80b058:	83 ec 24             	sub    $0x24,%esp
  80b05b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b05e:	85 db                	test   %ebx,%ebx
  80b060:	74 1f                	je     80b081 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80b062:	c7 45 e4 66 c1 80 00 	movl   $0x80c166,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b069:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b06c:	83 ec 0c             	sub    $0xc,%esp
  80b06f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b072:	50                   	push   %eax
  80b073:	e8 f3 74 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80b078:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b07c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b07f:	c9                   	leave  
  80b080:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b081:	83 ec 04             	sub    $0x4,%esp
  80b084:	68 31 34 81 00       	push   $0x813431
  80b089:	68 fa 00 00 00       	push   $0xfa
  80b08e:	68 3e 33 81 00       	push   $0x81333e
  80b093:	e8 71 37 00 00       	call   80e809 <_panic>

0080b098 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b098:	55                   	push   %ebp
  80b099:	89 e5                	mov    %esp,%ebp
  80b09b:	53                   	push   %ebx
  80b09c:	83 ec 14             	sub    $0x14,%esp
  80b09f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b0a2:	85 db                	test   %ebx,%ebx
  80b0a4:	74 36                	je     80b0dc <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b0a6:	8b 43 18             	mov    0x18(%ebx),%eax
  80b0a9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b0ac:	74 45                	je     80b0f3 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b0ae:	83 ec 04             	sub    $0x4,%esp
  80b0b1:	6a 00                	push   $0x0
  80b0b3:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b0b6:	52                   	push   %edx
  80b0b7:	50                   	push   %eax
  80b0b8:	e8 1c f4 ff ff       	call   80a4d9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b0bd:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b0c0:	83 c4 10             	add    $0x10,%esp
  80b0c3:	85 c0                	test   %eax,%eax
  80b0c5:	74 0d                	je     80b0d4 <netconn_accept+0x3c>
  80b0c7:	83 ec 04             	sub    $0x4,%esp
  80b0ca:	6a 00                	push   $0x0
  80b0cc:	6a 01                	push   $0x1
  80b0ce:	53                   	push   %ebx
  80b0cf:	ff d0                	call   *%eax
  80b0d1:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b0d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b0d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b0da:	c9                   	leave  
  80b0db:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b0dc:	83 ec 04             	sub    $0x4,%esp
  80b0df:	68 4e 34 81 00       	push   $0x81344e
  80b0e4:	68 10 01 00 00       	push   $0x110
  80b0e9:	68 3e 33 81 00       	push   $0x81333e
  80b0ee:	e8 16 37 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b0f3:	83 ec 04             	sub    $0x4,%esp
  80b0f6:	68 f8 32 81 00       	push   $0x8132f8
  80b0fb:	68 11 01 00 00       	push   $0x111
  80b100:	68 3e 33 81 00       	push   $0x81333e
  80b105:	e8 ff 36 00 00       	call   80e809 <_panic>

0080b10a <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b10a:	55                   	push   %ebp
  80b10b:	89 e5                	mov    %esp,%ebp
  80b10d:	53                   	push   %ebx
  80b10e:	83 ec 24             	sub    $0x24,%esp
  80b111:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b114:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b11b:	85 db                	test   %ebx,%ebx
  80b11d:	0f 84 cc 00 00 00    	je     80b1ef <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b123:	8b 43 14             	mov    0x14(%ebx),%eax
  80b126:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b129:	0f 84 d7 00 00 00    	je     80b206 <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b12f:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b133:	0f 8c 27 01 00 00    	jl     80b260 <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b139:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b13c:	0f 85 e0 00 00 00    	jne    80b222 <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b142:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b146:	0f 84 c5 00 00 00    	je     80b211 <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b14c:	83 ec 0c             	sub    $0xc,%esp
  80b14f:	6a 06                	push   $0x6
  80b151:	e8 fb 94 ff ff       	call   804651 <memp_malloc>
  80b156:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b159:	83 c4 10             	add    $0x10,%esp
  80b15c:	85 c0                	test   %eax,%eax
  80b15e:	0f 84 b8 00 00 00    	je     80b21c <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b164:	83 ec 04             	sub    $0x4,%esp
  80b167:	6a 00                	push   $0x0
  80b169:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80b16c:	50                   	push   %eax
  80b16d:	ff 73 14             	pushl  0x14(%ebx)
  80b170:	e8 64 f3 ff ff       	call   80a4d9 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b175:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b178:	83 c4 10             	add    $0x10,%esp
  80b17b:	85 c0                	test   %eax,%eax
  80b17d:	0f 84 e4 00 00 00    	je     80b267 <netconn_recv+0x15d>
      len = p->tot_len;
  80b183:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b187:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b18b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b18e:	85 c9                	test   %ecx,%ecx
  80b190:	74 1a                	je     80b1ac <netconn_recv+0xa2>
  80b192:	83 ec 04             	sub    $0x4,%esp
  80b195:	0f b7 d2             	movzwl %dx,%edx
  80b198:	52                   	push   %edx
  80b199:	6a 01                	push   $0x1
  80b19b:	53                   	push   %ebx
  80b19c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b19e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b1a1:	83 c4 10             	add    $0x10,%esp
  80b1a4:	85 c0                	test   %eax,%eax
  80b1a6:	0f 84 cb 00 00 00    	je     80b277 <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b1ac:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b1af:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b1b1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b1b4:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b1b7:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b1bd:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b1c4:	c7 45 e4 f4 c2 80 00 	movl   $0x80c2f4,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b1cb:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b1ce:	8b 02                	mov    (%edx),%eax
  80b1d0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b1d4:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b1d8:	83 ec 0c             	sub    $0xc,%esp
  80b1db:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1de:	50                   	push   %eax
  80b1df:	e8 87 73 ff ff       	call   80256b <tcpip_apimsg>
  80b1e4:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b1e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b1ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1ed:	c9                   	leave  
  80b1ee:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b1ef:	83 ec 04             	sub    $0x4,%esp
  80b1f2:	68 6b 34 81 00       	push   $0x81346b
  80b1f7:	68 3a 01 00 00       	push   $0x13a
  80b1fc:	68 3e 33 81 00       	push   $0x81333e
  80b201:	e8 03 36 00 00       	call   80e809 <_panic>
    conn->err = ERR_CONN;
  80b206:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b20a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b20f:	eb d9                	jmp    80b1ea <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80b211:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b215:	b8 00 00 00 00       	mov    $0x0,%eax
  80b21a:	eb ce                	jmp    80b1ea <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80b21c:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b220:	eb c8                	jmp    80b1ea <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b222:	83 ec 04             	sub    $0x4,%esp
  80b225:	6a 00                	push   $0x0
  80b227:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b22a:	52                   	push   %edx
  80b22b:	50                   	push   %eax
  80b22c:	e8 a8 f2 ff ff       	call   80a4d9 <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b231:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b234:	83 c4 10             	add    $0x10,%esp
  80b237:	85 c0                	test   %eax,%eax
  80b239:	74 ac                	je     80b1e7 <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b23b:	8b 10                	mov    (%eax),%edx
  80b23d:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b241:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b245:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b248:	85 d2                	test   %edx,%edx
  80b24a:	74 9b                	je     80b1e7 <netconn_recv+0xdd>
  80b24c:	83 ec 04             	sub    $0x4,%esp
  80b24f:	8b 00                	mov    (%eax),%eax
  80b251:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b255:	50                   	push   %eax
  80b256:	6a 01                	push   $0x1
  80b258:	53                   	push   %ebx
  80b259:	ff d2                	call   *%edx
  80b25b:	83 c4 10             	add    $0x10,%esp
  80b25e:	eb 87                	jmp    80b1e7 <netconn_recv+0xdd>
    return NULL;
  80b260:	b8 00 00 00 00       	mov    $0x0,%eax
  80b265:	eb 83                	jmp    80b1ea <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b267:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b26a:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b26f:	85 c9                	test   %ecx,%ecx
  80b271:	0f 85 1b ff ff ff    	jne    80b192 <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b277:	83 ec 08             	sub    $0x8,%esp
  80b27a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b27d:	6a 06                	push   $0x6
  80b27f:	e8 23 94 ff ff       	call   8046a7 <memp_free>
      if (conn->err == ERR_OK) {
  80b284:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b287:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b28c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b290:	0f 85 54 ff ff ff    	jne    80b1ea <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b296:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b29a:	e9 4b ff ff ff       	jmp    80b1ea <netconn_recv+0xe0>

0080b29f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b29f:	55                   	push   %ebp
  80b2a0:	89 e5                	mov    %esp,%ebp
  80b2a2:	53                   	push   %ebx
  80b2a3:	83 ec 24             	sub    $0x24,%esp
  80b2a6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b2a9:	85 db                	test   %ebx,%ebx
  80b2ab:	74 25                	je     80b2d2 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b2ad:	c7 45 e4 4e c2 80 00 	movl   $0x80c24e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b2b4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b2b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b2bd:	83 ec 0c             	sub    $0xc,%esp
  80b2c0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b2c3:	50                   	push   %eax
  80b2c4:	e8 a2 72 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80b2c9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b2cd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b2d0:	c9                   	leave  
  80b2d1:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b2d2:	83 ec 04             	sub    $0x4,%esp
  80b2d5:	68 86 34 81 00       	push   $0x813486
  80b2da:	68 b9 01 00 00       	push   $0x1b9
  80b2df:	68 3e 33 81 00       	push   $0x81333e
  80b2e4:	e8 20 35 00 00       	call   80e809 <_panic>

0080b2e9 <netconn_sendto>:
{
  80b2e9:	55                   	push   %ebp
  80b2ea:	89 e5                	mov    %esp,%ebp
  80b2ec:	83 ec 08             	sub    $0x8,%esp
  80b2ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2f2:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b2f5:	85 c0                	test   %eax,%eax
  80b2f7:	74 1b                	je     80b314 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b2f9:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b2fc:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b2ff:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b303:	83 ec 08             	sub    $0x8,%esp
  80b306:	50                   	push   %eax
  80b307:	ff 75 08             	pushl  0x8(%ebp)
  80b30a:	e8 90 ff ff ff       	call   80b29f <netconn_send>
  80b30f:	83 c4 10             	add    $0x10,%esp
}
  80b312:	c9                   	leave  
  80b313:	c3                   	ret    
  return ERR_VAL;
  80b314:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b319:	eb f7                	jmp    80b312 <netconn_sendto+0x29>

0080b31b <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b31b:	55                   	push   %ebp
  80b31c:	89 e5                	mov    %esp,%ebp
  80b31e:	53                   	push   %ebx
  80b31f:	83 ec 24             	sub    $0x24,%esp
  80b322:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b325:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b328:	85 db                	test   %ebx,%ebx
  80b32a:	74 33                	je     80b35f <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b32c:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b32f:	75 45                	jne    80b376 <netconn_write+0x5b>

  msg.function = do_write;
  80b331:	c7 45 e4 3a c3 80 00 	movl   $0x80c33a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b338:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b33b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b33e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b341:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b344:	8b 45 10             	mov    0x10(%ebp),%eax
  80b347:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b34a:	83 ec 0c             	sub    $0xc,%esp
  80b34d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b350:	50                   	push   %eax
  80b351:	e8 15 72 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80b356:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b35a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b35d:	c9                   	leave  
  80b35e:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b35f:	83 ec 04             	sub    $0x4,%esp
  80b362:	68 a1 34 81 00       	push   $0x8134a1
  80b367:	68 d3 01 00 00       	push   $0x1d3
  80b36c:	68 3e 33 81 00       	push   $0x81333e
  80b371:	e8 93 34 00 00       	call   80e809 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b376:	83 ec 04             	sub    $0x4,%esp
  80b379:	68 1c 33 81 00       	push   $0x81331c
  80b37e:	68 d4 01 00 00       	push   $0x1d4
  80b383:	68 3e 33 81 00       	push   $0x81333e
  80b388:	e8 7c 34 00 00       	call   80e809 <_panic>

0080b38d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b38d:	55                   	push   %ebp
  80b38e:	89 e5                	mov    %esp,%ebp
  80b390:	53                   	push   %ebx
  80b391:	83 ec 24             	sub    $0x24,%esp
  80b394:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b397:	85 db                	test   %ebx,%ebx
  80b399:	74 1f                	je     80b3ba <netconn_close+0x2d>

  msg.function = do_close;
  80b39b:	c7 45 e4 51 c4 80 00 	movl   $0x80c451,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b3a2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b3a5:	83 ec 0c             	sub    $0xc,%esp
  80b3a8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b3ab:	50                   	push   %eax
  80b3ac:	e8 ba 71 ff ff       	call   80256b <tcpip_apimsg>
  return conn->err;
  80b3b1:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b3b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b3b8:	c9                   	leave  
  80b3b9:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b3ba:	83 ec 04             	sub    $0x4,%esp
  80b3bd:	68 bd 34 81 00       	push   $0x8134bd
  80b3c2:	68 ed 01 00 00       	push   $0x1ed
  80b3c7:	68 3e 33 81 00       	push   $0x81333e
  80b3cc:	e8 38 34 00 00       	call   80e809 <_panic>

0080b3d1 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b3d1:	55                   	push   %ebp
  80b3d2:	89 e5                	mov    %esp,%ebp
  80b3d4:	56                   	push   %esi
  80b3d5:	53                   	push   %ebx
  80b3d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b3d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3dc:	8b 75 10             	mov    0x10(%ebp),%esi
  80b3df:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b3e2:	85 c0                	test   %eax,%eax
  80b3e4:	74 5a                	je     80b440 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b3e6:	85 db                	test   %ebx,%ebx
  80b3e8:	74 6d                	je     80b457 <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b3ea:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b3ed:	75 7f                	jne    80b46e <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b3ef:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b3f3:	0f 84 8c 00 00 00    	je     80b485 <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b3f9:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b3fc:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b401:	85 f6                	test   %esi,%esi
  80b403:	74 08                	je     80b40d <recv_tcp+0x3c>
    len = p->tot_len;
  80b405:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b409:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b40d:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b410:	85 d2                	test   %edx,%edx
  80b412:	74 0f                	je     80b423 <recv_tcp+0x52>
  80b414:	83 ec 04             	sub    $0x4,%esp
  80b417:	0f b7 c0             	movzwl %ax,%eax
  80b41a:	50                   	push   %eax
  80b41b:	6a 00                	push   $0x0
  80b41d:	53                   	push   %ebx
  80b41e:	ff d2                	call   *%edx
  80b420:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b423:	83 ec 08             	sub    $0x8,%esp
  80b426:	56                   	push   %esi
  80b427:	ff 73 14             	pushl  0x14(%ebx)
  80b42a:	e8 b5 ef ff ff       	call   80a3e4 <sys_mbox_trypost>
  80b42f:	83 c4 10             	add    $0x10,%esp
  80b432:	84 c0                	test   %al,%al
  80b434:	0f 95 c0             	setne  %al
  80b437:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b439:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b43c:	5b                   	pop    %ebx
  80b43d:	5e                   	pop    %esi
  80b43e:	5d                   	pop    %ebp
  80b43f:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b440:	83 ec 04             	sub    $0x4,%esp
  80b443:	68 dc 34 81 00       	push   $0x8134dc
  80b448:	68 c1 00 00 00       	push   $0xc1
  80b44d:	68 26 36 81 00       	push   $0x813626
  80b452:	e8 b2 33 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b457:	83 ec 04             	sub    $0x4,%esp
  80b45a:	68 00 35 81 00       	push   $0x813500
  80b45f:	68 c2 00 00 00       	push   $0xc2
  80b464:	68 26 36 81 00       	push   $0x813626
  80b469:	e8 9b 33 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b46e:	83 ec 04             	sub    $0x4,%esp
  80b471:	68 3d 36 81 00       	push   $0x81363d
  80b476:	68 c4 00 00 00       	push   $0xc4
  80b47b:	68 26 36 81 00       	push   $0x813626
  80b480:	e8 84 33 00 00       	call   80e809 <_panic>
    return ERR_VAL;
  80b485:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b48a:	eb ad                	jmp    80b439 <recv_tcp+0x68>

0080b48c <recv_udp>:
{
  80b48c:	55                   	push   %ebp
  80b48d:	89 e5                	mov    %esp,%ebp
  80b48f:	57                   	push   %edi
  80b490:	56                   	push   %esi
  80b491:	53                   	push   %ebx
  80b492:	83 ec 1c             	sub    $0x1c,%esp
  80b495:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b498:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b49b:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b49e:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b4a1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b4a4:	85 c0                	test   %eax,%eax
  80b4a6:	74 7f                	je     80b527 <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b4a8:	85 db                	test   %ebx,%ebx
  80b4aa:	0f 84 8e 00 00 00    	je     80b53e <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b4b0:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b4b3:	0f 85 9c 00 00 00    	jne    80b555 <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b4b9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b4bd:	0f 84 a9 00 00 00    	je     80b56c <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b4c3:	83 ec 0c             	sub    $0xc,%esp
  80b4c6:	6a 06                	push   $0x6
  80b4c8:	e8 84 91 ff ff       	call   804651 <memp_malloc>
  80b4cd:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b4cf:	83 c4 10             	add    $0x10,%esp
  80b4d2:	85 c0                	test   %eax,%eax
  80b4d4:	0f 84 a0 00 00 00    	je     80b57a <recv_udp+0xee>
    buf->p = p;
  80b4da:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b4dc:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b4df:	8b 45 14             	mov    0x14(%ebp),%eax
  80b4e2:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b4e5:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b4e9:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b4ed:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b4f1:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b4f5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4f8:	85 c0                	test   %eax,%eax
  80b4fa:	74 10                	je     80b50c <recv_udp+0x80>
  80b4fc:	83 ec 04             	sub    $0x4,%esp
  80b4ff:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b503:	52                   	push   %edx
  80b504:	6a 00                	push   $0x0
  80b506:	53                   	push   %ebx
  80b507:	ff d0                	call   *%eax
  80b509:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b50c:	83 ec 08             	sub    $0x8,%esp
  80b50f:	56                   	push   %esi
  80b510:	ff 73 14             	pushl  0x14(%ebx)
  80b513:	e8 cc ee ff ff       	call   80a3e4 <sys_mbox_trypost>
  80b518:	83 c4 10             	add    $0x10,%esp
  80b51b:	84 c0                	test   %al,%al
  80b51d:	75 69                	jne    80b588 <recv_udp+0xfc>
}
  80b51f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b522:	5b                   	pop    %ebx
  80b523:	5e                   	pop    %esi
  80b524:	5f                   	pop    %edi
  80b525:	5d                   	pop    %ebp
  80b526:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b527:	83 ec 04             	sub    $0x4,%esp
  80b52a:	68 20 35 81 00       	push   $0x813520
  80b52f:	68 8e 00 00 00       	push   $0x8e
  80b534:	68 26 36 81 00       	push   $0x813626
  80b539:	e8 cb 32 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b53e:	83 ec 04             	sub    $0x4,%esp
  80b541:	68 44 35 81 00       	push   $0x813544
  80b546:	68 8f 00 00 00       	push   $0x8f
  80b54b:	68 26 36 81 00       	push   $0x813626
  80b550:	e8 b4 32 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b555:	83 ec 04             	sub    $0x4,%esp
  80b558:	68 5b 36 81 00       	push   $0x81365b
  80b55d:	68 91 00 00 00       	push   $0x91
  80b562:	68 26 36 81 00       	push   $0x813626
  80b567:	e8 9d 32 00 00       	call   80e809 <_panic>
    pbuf_free(p);
  80b56c:	83 ec 0c             	sub    $0xc,%esp
  80b56f:	57                   	push   %edi
  80b570:	e8 7f 94 ff ff       	call   8049f4 <pbuf_free>
    return;
  80b575:	83 c4 10             	add    $0x10,%esp
  80b578:	eb a5                	jmp    80b51f <recv_udp+0x93>
    pbuf_free(p);
  80b57a:	83 ec 0c             	sub    $0xc,%esp
  80b57d:	57                   	push   %edi
  80b57e:	e8 71 94 ff ff       	call   8049f4 <pbuf_free>
    return;
  80b583:	83 c4 10             	add    $0x10,%esp
  80b586:	eb 97                	jmp    80b51f <recv_udp+0x93>
    netbuf_delete(buf);
  80b588:	83 ec 0c             	sub    $0xc,%esp
  80b58b:	56                   	push   %esi
  80b58c:	e8 ca 70 ff ff       	call   80265b <netbuf_delete>
    return;
  80b591:	83 c4 10             	add    $0x10,%esp
  80b594:	eb 89                	jmp    80b51f <recv_udp+0x93>

0080b596 <recv_raw>:
{
  80b596:	55                   	push   %ebp
  80b597:	89 e5                	mov    %esp,%ebp
  80b599:	57                   	push   %edi
  80b59a:	56                   	push   %esi
  80b59b:	53                   	push   %ebx
  80b59c:	83 ec 0c             	sub    $0xc,%esp
  80b59f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b5a2:	85 db                	test   %ebx,%ebx
  80b5a4:	74 06                	je     80b5ac <recv_raw+0x16>
  80b5a6:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b5aa:	75 0d                	jne    80b5b9 <recv_raw+0x23>
}
  80b5ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80b5b1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b5b4:	5b                   	pop    %ebx
  80b5b5:	5e                   	pop    %esi
  80b5b6:	5f                   	pop    %edi
  80b5b7:	5d                   	pop    %ebp
  80b5b8:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b5b9:	83 ec 04             	sub    $0x4,%esp
  80b5bc:	6a 00                	push   $0x0
  80b5be:	8b 45 10             	mov    0x10(%ebp),%eax
  80b5c1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b5c5:	50                   	push   %eax
  80b5c6:	6a 03                	push   $0x3
  80b5c8:	e8 ed 94 ff ff       	call   804aba <pbuf_alloc>
  80b5cd:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b5cf:	83 c4 10             	add    $0x10,%esp
  80b5d2:	85 c0                	test   %eax,%eax
  80b5d4:	74 d6                	je     80b5ac <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b5d6:	83 ec 08             	sub    $0x8,%esp
  80b5d9:	ff 75 10             	pushl  0x10(%ebp)
  80b5dc:	50                   	push   %eax
  80b5dd:	e8 ba 99 ff ff       	call   804f9c <pbuf_copy>
  80b5e2:	83 c4 10             	add    $0x10,%esp
  80b5e5:	84 c0                	test   %al,%al
  80b5e7:	75 73                	jne    80b65c <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b5e9:	83 ec 0c             	sub    $0xc,%esp
  80b5ec:	6a 06                	push   $0x6
  80b5ee:	e8 5e 90 ff ff       	call   804651 <memp_malloc>
  80b5f3:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b5f5:	83 c4 10             	add    $0x10,%esp
  80b5f8:	85 c0                	test   %eax,%eax
  80b5fa:	74 71                	je     80b66d <recv_raw+0xd7>
      buf->p = q;
  80b5fc:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b5fe:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b601:	8b 46 04             	mov    0x4(%esi),%eax
  80b604:	83 c0 0c             	add    $0xc,%eax
  80b607:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b60a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b60d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b611:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b615:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b619:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b61d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b620:	85 c0                	test   %eax,%eax
  80b622:	74 10                	je     80b634 <recv_raw+0x9e>
  80b624:	83 ec 04             	sub    $0x4,%esp
  80b627:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b62b:	52                   	push   %edx
  80b62c:	6a 00                	push   $0x0
  80b62e:	53                   	push   %ebx
  80b62f:	ff d0                	call   *%eax
  80b631:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b634:	83 ec 08             	sub    $0x8,%esp
  80b637:	57                   	push   %edi
  80b638:	ff 73 14             	pushl  0x14(%ebx)
  80b63b:	e8 a4 ed ff ff       	call   80a3e4 <sys_mbox_trypost>
  80b640:	83 c4 10             	add    $0x10,%esp
  80b643:	84 c0                	test   %al,%al
  80b645:	0f 84 61 ff ff ff    	je     80b5ac <recv_raw+0x16>
        netbuf_delete(buf);
  80b64b:	83 ec 0c             	sub    $0xc,%esp
  80b64e:	57                   	push   %edi
  80b64f:	e8 07 70 ff ff       	call   80265b <netbuf_delete>
  80b654:	83 c4 10             	add    $0x10,%esp
  80b657:	e9 50 ff ff ff       	jmp    80b5ac <recv_raw+0x16>
        pbuf_free(q);
  80b65c:	83 ec 0c             	sub    $0xc,%esp
  80b65f:	56                   	push   %esi
  80b660:	e8 8f 93 ff ff       	call   8049f4 <pbuf_free>
  80b665:	83 c4 10             	add    $0x10,%esp
  80b668:	e9 3f ff ff ff       	jmp    80b5ac <recv_raw+0x16>
        pbuf_free(q);
  80b66d:	83 ec 0c             	sub    $0xc,%esp
  80b670:	56                   	push   %esi
  80b671:	e8 7e 93 ff ff       	call   8049f4 <pbuf_free>
        return 0;
  80b676:	83 c4 10             	add    $0x10,%esp
  80b679:	e9 2e ff ff ff       	jmp    80b5ac <recv_raw+0x16>

0080b67e <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b67e:	55                   	push   %ebp
  80b67f:	89 e5                	mov    %esp,%ebp
  80b681:	53                   	push   %ebx
  80b682:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b685:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b688:	50                   	push   %eax
  80b689:	53                   	push   %ebx
  80b68a:	e8 32 a3 ff ff       	call   8059c1 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b68f:	83 c4 08             	add    $0x8,%esp
  80b692:	68 d1 b3 80 00       	push   $0x80b3d1
  80b697:	53                   	push   %ebx
  80b698:	e8 32 a3 ff ff       	call   8059cf <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b69d:	83 c4 08             	add    $0x8,%esp
  80b6a0:	68 60 bb 80 00       	push   $0x80bb60
  80b6a5:	53                   	push   %ebx
  80b6a6:	e8 35 a3 ff ff       	call   8059e0 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b6ab:	83 c4 0c             	add    $0xc,%esp
  80b6ae:	6a 04                	push   $0x4
  80b6b0:	68 1a bb 80 00       	push   $0x80bb1a
  80b6b5:	53                   	push   %ebx
  80b6b6:	e8 55 a3 ff ff       	call   805a10 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b6bb:	83 c4 08             	add    $0x8,%esp
  80b6be:	68 1d b7 80 00       	push   $0x80b71d
  80b6c3:	53                   	push   %ebx
  80b6c4:	e8 28 a3 ff ff       	call   8059f1 <tcp_err>
}
  80b6c9:	83 c4 10             	add    $0x10,%esp
  80b6cc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b6cf:	c9                   	leave  
  80b6d0:	c3                   	ret    

0080b6d1 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b6d1:	55                   	push   %ebp
  80b6d2:	89 e5                	mov    %esp,%ebp
  80b6d4:	53                   	push   %ebx
  80b6d5:	83 ec 04             	sub    $0x4,%esp
  80b6d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b6db:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b6de:	85 db                	test   %ebx,%ebx
  80b6e0:	74 34                	je     80b716 <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b6e2:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b6e5:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b6e8:	75 04                	jne    80b6ee <do_connected+0x1d>
  80b6ea:	84 c0                	test   %al,%al
  80b6ec:	74 1f                	je     80b70d <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b6ee:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b6f5:	83 ec 0c             	sub    $0xc,%esp
  80b6f8:	ff 73 10             	pushl  0x10(%ebx)
  80b6fb:	e8 64 eb ff ff       	call   80a264 <sys_sem_signal>
  return ERR_OK;
  80b700:	83 c4 10             	add    $0x10,%esp
  80b703:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b708:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b70b:	c9                   	leave  
  80b70c:	c3                   	ret    
    setup_tcp(conn);
  80b70d:	89 d8                	mov    %ebx,%eax
  80b70f:	e8 6a ff ff ff       	call   80b67e <setup_tcp>
  80b714:	eb d8                	jmp    80b6ee <do_connected+0x1d>
    return ERR_VAL;
  80b716:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b71b:	eb eb                	jmp    80b708 <do_connected+0x37>

0080b71d <err_tcp>:
{
  80b71d:	55                   	push   %ebp
  80b71e:	89 e5                	mov    %esp,%ebp
  80b720:	53                   	push   %ebx
  80b721:	83 ec 04             	sub    $0x4,%esp
  80b724:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b727:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b72a:	85 db                	test   %ebx,%ebx
  80b72c:	74 7e                	je     80b7ac <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b72e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b735:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b738:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b73c:	74 24                	je     80b762 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b73e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b741:	85 c0                	test   %eax,%eax
  80b743:	74 0d                	je     80b752 <err_tcp+0x35>
  80b745:	83 ec 04             	sub    $0x4,%esp
  80b748:	6a 00                	push   $0x0
  80b74a:	6a 00                	push   $0x0
  80b74c:	53                   	push   %ebx
  80b74d:	ff d0                	call   *%eax
  80b74f:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b752:	83 ec 08             	sub    $0x8,%esp
  80b755:	6a 00                	push   $0x0
  80b757:	ff 73 14             	pushl  0x14(%ebx)
  80b75a:	e8 4a ed ff ff       	call   80a4a9 <sys_mbox_post>
  80b75f:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b762:	8b 43 10             	mov    0x10(%ebx),%eax
  80b765:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b768:	74 06                	je     80b770 <err_tcp+0x53>
  80b76a:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b76e:	74 53                	je     80b7c3 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b770:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b774:	74 24                	je     80b79a <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b776:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b779:	85 c0                	test   %eax,%eax
  80b77b:	74 0d                	je     80b78a <err_tcp+0x6d>
  80b77d:	83 ec 04             	sub    $0x4,%esp
  80b780:	6a 00                	push   $0x0
  80b782:	6a 00                	push   $0x0
  80b784:	53                   	push   %ebx
  80b785:	ff d0                	call   *%eax
  80b787:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b78a:	83 ec 08             	sub    $0x8,%esp
  80b78d:	6a 00                	push   $0x0
  80b78f:	ff 73 18             	pushl  0x18(%ebx)
  80b792:	e8 12 ed ff ff       	call   80a4a9 <sys_mbox_post>
  80b797:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b79a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b79d:	83 f8 01             	cmp    $0x1,%eax
  80b7a0:	74 36                	je     80b7d8 <err_tcp+0xbb>
  80b7a2:	83 f8 04             	cmp    $0x4,%eax
  80b7a5:	74 31                	je     80b7d8 <err_tcp+0xbb>
}
  80b7a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b7aa:	c9                   	leave  
  80b7ab:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b7ac:	83 ec 04             	sub    $0x4,%esp
  80b7af:	68 79 36 81 00       	push   $0x813679
  80b7b4:	68 22 01 00 00       	push   $0x122
  80b7b9:	68 26 36 81 00       	push   $0x813626
  80b7be:	e8 46 30 00 00       	call   80e809 <_panic>
    conn->state = NETCONN_NONE;
  80b7c3:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b7ca:	83 ec 0c             	sub    $0xc,%esp
  80b7cd:	50                   	push   %eax
  80b7ce:	e8 91 ea ff ff       	call   80a264 <sys_sem_signal>
  80b7d3:	83 c4 10             	add    $0x10,%esp
  80b7d6:	eb 98                	jmp    80b770 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b7d8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b7df:	83 ec 0c             	sub    $0xc,%esp
  80b7e2:	ff 73 10             	pushl  0x10(%ebx)
  80b7e5:	e8 7a ea ff ff       	call   80a264 <sys_sem_signal>
  80b7ea:	83 c4 10             	add    $0x10,%esp
}
  80b7ed:	eb b8                	jmp    80b7a7 <err_tcp+0x8a>

0080b7ef <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b7ef:	55                   	push   %ebp
  80b7f0:	89 e5                	mov    %esp,%ebp
  80b7f2:	57                   	push   %edi
  80b7f3:	56                   	push   %esi
  80b7f4:	53                   	push   %ebx
  80b7f5:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b7f8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b7fc:	0f 85 c9 00 00 00    	jne    80b8cb <do_writemore+0xdc>
  80b802:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b804:	8b 40 24             	mov    0x24(%eax),%eax
  80b807:	8b 7e 28             	mov    0x28(%esi),%edi
  80b80a:	89 fa                	mov    %edi,%edx
  80b80c:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b80f:	8b 58 08             	mov    0x8(%eax),%ebx
  80b812:	89 d9                	mov    %ebx,%ecx
  80b814:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b816:	29 fb                	sub    %edi,%ebx
  80b818:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b81e:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b823:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b826:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b829:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b82d:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b832:	0f b7 db             	movzwl %bx,%ebx
  80b835:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b839:	50                   	push   %eax
  80b83a:	53                   	push   %ebx
  80b83b:	52                   	push   %edx
  80b83c:	51                   	push   %ecx
  80b83d:	e8 96 c9 ff ff       	call   8081d8 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b842:	89 da                	mov    %ebx,%edx
  80b844:	03 56 28             	add    0x28(%esi),%edx
  80b847:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b84a:	83 c4 10             	add    $0x10,%esp
  80b84d:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b850:	0f 8f 8c 00 00 00    	jg     80b8e2 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b856:	84 c0                	test   %al,%al
  80b858:	0f 85 bf 00 00 00    	jne    80b91d <do_writemore+0x12e>
    conn->write_offset += len;
  80b85e:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b861:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b866:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b869:	0f 84 8a 00 00 00    	je     80b8f9 <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b86f:	8b 46 08             	mov    0x8(%esi),%eax
  80b872:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b876:	74 1a                	je     80b892 <do_writemore+0xa3>
  80b878:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b87c:	75 14                	jne    80b892 <do_writemore+0xa3>
  80b87e:	8b 50 74             	mov    0x74(%eax),%edx
  80b881:	85 d2                	test   %edx,%edx
  80b883:	0f 84 88 00 00 00    	je     80b911 <do_writemore+0x122>
  80b889:	83 3a 00             	cmpl   $0x0,(%edx)
  80b88c:	0f 84 85 00 00 00    	je     80b917 <do_writemore+0x128>
  80b892:	83 ec 0c             	sub    $0xc,%esp
  80b895:	50                   	push   %eax
  80b896:	e8 94 c9 ff ff       	call   80822f <tcp_output>
    conn->err = err;
  80b89b:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b89e:	83 c4 10             	add    $0x10,%esp
  80b8a1:	84 c0                	test   %al,%al
  80b8a3:	75 1e                	jne    80b8c3 <do_writemore+0xd4>
  80b8a5:	8b 46 08             	mov    0x8(%esi),%eax
  80b8a8:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b8ae:	77 13                	ja     80b8c3 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b8b0:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b8b3:	85 c0                	test   %eax,%eax
  80b8b5:	74 0c                	je     80b8c3 <do_writemore+0xd4>
  80b8b7:	83 ec 04             	sub    $0x4,%esp
  80b8ba:	53                   	push   %ebx
  80b8bb:	6a 03                	push   $0x3
  80b8bd:	56                   	push   %esi
  80b8be:	ff d0                	call   *%eax
  80b8c0:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b8c3:	89 f8                	mov    %edi,%eax
  80b8c5:	84 c0                	test   %al,%al
  80b8c7:	74 70                	je     80b939 <do_writemore+0x14a>
  80b8c9:	eb 59                	jmp    80b924 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b8cb:	83 ec 04             	sub    $0x4,%esp
  80b8ce:	68 86 36 81 00       	push   $0x813686
  80b8d3:	68 b8 03 00 00       	push   $0x3b8
  80b8d8:	68 26 36 81 00       	push   $0x813626
  80b8dd:	e8 27 2f 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b8e2:	83 ec 04             	sub    $0x4,%esp
  80b8e5:	68 a3 36 81 00       	push   $0x8136a3
  80b8ea:	68 cd 03 00 00       	push   $0x3cd
  80b8ef:	68 26 36 81 00       	push   $0x813626
  80b8f4:	e8 10 2f 00 00       	call   80e809 <_panic>
      conn->write_msg = NULL;
  80b8f9:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b900:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b907:	bf 01 00 00 00       	mov    $0x1,%edi
  80b90c:	e9 5e ff ff ff       	jmp    80b86f <do_writemore+0x80>
    conn->err = err;
  80b911:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b915:	eb 8e                	jmp    80b8a5 <do_writemore+0xb6>
  80b917:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b91b:	eb 88                	jmp    80b8a5 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b91d:	3c ff                	cmp    $0xff,%al
  80b91f:	74 25                	je     80b946 <do_writemore+0x157>
    conn->err = err;
  80b921:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b924:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b92b:	83 ec 0c             	sub    $0xc,%esp
  80b92e:	ff 76 10             	pushl  0x10(%esi)
  80b931:	e8 2e e9 ff ff       	call   80a264 <sys_sem_signal>
  80b936:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b939:	b8 00 00 00 00       	mov    $0x0,%eax
  80b93e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b941:	5b                   	pop    %ebx
  80b942:	5e                   	pop    %esi
  80b943:	5f                   	pop    %edi
  80b944:	5d                   	pop    %ebp
  80b945:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b946:	83 ec 0c             	sub    $0xc,%esp
  80b949:	ff 76 08             	pushl  0x8(%esi)
  80b94c:	e8 de c8 ff ff       	call   80822f <tcp_output>
  80b951:	83 c4 10             	add    $0x10,%esp
  80b954:	eb e3                	jmp    80b939 <do_writemore+0x14a>

0080b956 <do_close_internal>:
{
  80b956:	55                   	push   %ebp
  80b957:	89 e5                	mov    %esp,%ebp
  80b959:	53                   	push   %ebx
  80b95a:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b95d:	85 c0                	test   %eax,%eax
  80b95f:	0f 84 e2 00 00 00    	je     80ba47 <do_close_internal+0xf1>
  80b965:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b967:	83 38 10             	cmpl   $0x10,(%eax)
  80b96a:	0f 85 ee 00 00 00    	jne    80ba5e <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b970:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b974:	0f 85 fb 00 00 00    	jne    80ba75 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b97a:	8b 40 08             	mov    0x8(%eax),%eax
  80b97d:	85 c0                	test   %eax,%eax
  80b97f:	0f 84 07 01 00 00    	je     80ba8c <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b985:	83 ec 08             	sub    $0x8,%esp
  80b988:	6a 00                	push   $0x0
  80b98a:	50                   	push   %eax
  80b98b:	e8 31 a0 ff ff       	call   8059c1 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b990:	8b 43 08             	mov    0x8(%ebx),%eax
  80b993:	83 c4 10             	add    $0x10,%esp
  80b996:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b99a:	0f 84 03 01 00 00    	je     80baa3 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b9a0:	83 ec 08             	sub    $0x8,%esp
  80b9a3:	6a 00                	push   $0x0
  80b9a5:	50                   	push   %eax
  80b9a6:	e8 24 a0 ff ff       	call   8059cf <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b9ab:	83 c4 08             	add    $0x8,%esp
  80b9ae:	6a 00                	push   $0x0
  80b9b0:	ff 73 08             	pushl  0x8(%ebx)
  80b9b3:	e8 4a a0 ff ff       	call   805a02 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b9b8:	83 c4 08             	add    $0x8,%esp
  80b9bb:	6a 00                	push   $0x0
  80b9bd:	ff 73 08             	pushl  0x8(%ebx)
  80b9c0:	e8 1b a0 ff ff       	call   8059e0 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b9c5:	83 c4 0c             	add    $0xc,%esp
  80b9c8:	6a 04                	push   $0x4
  80b9ca:	6a 00                	push   $0x0
  80b9cc:	ff 73 08             	pushl  0x8(%ebx)
  80b9cf:	e8 3c a0 ff ff       	call   805a10 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b9d4:	83 c4 08             	add    $0x8,%esp
  80b9d7:	6a 00                	push   $0x0
  80b9d9:	ff 73 08             	pushl  0x8(%ebx)
  80b9dc:	e8 10 a0 ff ff       	call   8059f1 <tcp_err>
  80b9e1:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b9e4:	83 ec 0c             	sub    $0xc,%esp
  80b9e7:	ff 73 08             	pushl  0x8(%ebx)
  80b9ea:	e8 d4 a1 ff ff       	call   805bc3 <tcp_close>
  if (err == ERR_OK) {
  80b9ef:	83 c4 10             	add    $0x10,%esp
  80b9f2:	84 c0                	test   %al,%al
  80b9f4:	0f 85 bc 00 00 00    	jne    80bab6 <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b9fa:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80ba01:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80ba08:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80ba0c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba0f:	85 c0                	test   %eax,%eax
  80ba11:	74 21                	je     80ba34 <do_close_internal+0xde>
  80ba13:	83 ec 04             	sub    $0x4,%esp
  80ba16:	6a 00                	push   $0x0
  80ba18:	6a 00                	push   $0x0
  80ba1a:	53                   	push   %ebx
  80ba1b:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80ba1d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba20:	83 c4 10             	add    $0x10,%esp
  80ba23:	85 c0                	test   %eax,%eax
  80ba25:	74 0d                	je     80ba34 <do_close_internal+0xde>
  80ba27:	83 ec 04             	sub    $0x4,%esp
  80ba2a:	6a 00                	push   $0x0
  80ba2c:	6a 02                	push   $0x2
  80ba2e:	53                   	push   %ebx
  80ba2f:	ff d0                	call   *%eax
  80ba31:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80ba34:	83 ec 0c             	sub    $0xc,%esp
  80ba37:	ff 73 10             	pushl  0x10(%ebx)
  80ba3a:	e8 25 e8 ff ff       	call   80a264 <sys_sem_signal>
  80ba3f:	83 c4 10             	add    $0x10,%esp
}
  80ba42:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ba45:	c9                   	leave  
  80ba46:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80ba47:	83 ec 04             	sub    $0x4,%esp
  80ba4a:	68 94 34 81 00       	push   $0x813494
  80ba4f:	68 53 02 00 00       	push   $0x253
  80ba54:	68 26 36 81 00       	push   $0x813626
  80ba59:	e8 ab 2d 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80ba5e:	83 ec 04             	sub    $0x4,%esp
  80ba61:	68 c1 36 81 00       	push   $0x8136c1
  80ba66:	68 54 02 00 00       	push   $0x254
  80ba6b:	68 26 36 81 00       	push   $0x813626
  80ba70:	e8 94 2d 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ba75:	83 ec 04             	sub    $0x4,%esp
  80ba78:	68 64 35 81 00       	push   $0x813564
  80ba7d:	68 55 02 00 00       	push   $0x255
  80ba82:	68 26 36 81 00       	push   $0x813626
  80ba87:	e8 7d 2d 00 00       	call   80e809 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80ba8c:	83 ec 04             	sub    $0x4,%esp
  80ba8f:	68 df 36 81 00       	push   $0x8136df
  80ba94:	68 56 02 00 00       	push   $0x256
  80ba99:	68 26 36 81 00       	push   $0x813626
  80ba9e:	e8 66 2d 00 00       	call   80e809 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80baa3:	83 ec 08             	sub    $0x8,%esp
  80baa6:	6a 00                	push   $0x0
  80baa8:	50                   	push   %eax
  80baa9:	e8 54 9f ff ff       	call   805a02 <tcp_accept>
  80baae:	83 c4 10             	add    $0x10,%esp
  80bab1:	e9 2e ff ff ff       	jmp    80b9e4 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bab6:	8b 43 08             	mov    0x8(%ebx),%eax
  80bab9:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80babd:	74 44                	je     80bb03 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80babf:	83 ec 08             	sub    $0x8,%esp
  80bac2:	68 60 bb 80 00       	push   $0x80bb60
  80bac7:	50                   	push   %eax
  80bac8:	e8 13 9f ff ff       	call   8059e0 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80bacd:	83 c4 0c             	add    $0xc,%esp
  80bad0:	6a 04                	push   $0x4
  80bad2:	68 1a bb 80 00       	push   $0x80bb1a
  80bad7:	ff 73 08             	pushl  0x8(%ebx)
  80bada:	e8 31 9f ff ff       	call   805a10 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80badf:	83 c4 08             	add    $0x8,%esp
  80bae2:	68 1d b7 80 00       	push   $0x80b71d
  80bae7:	ff 73 08             	pushl  0x8(%ebx)
  80baea:	e8 02 9f ff ff       	call   8059f1 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80baef:	83 c4 08             	add    $0x8,%esp
  80baf2:	53                   	push   %ebx
  80baf3:	ff 73 08             	pushl  0x8(%ebx)
  80baf6:	e8 c6 9e ff ff       	call   8059c1 <tcp_arg>
  80bafb:	83 c4 10             	add    $0x10,%esp
}
  80bafe:	e9 3f ff ff ff       	jmp    80ba42 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80bb03:	83 ec 04             	sub    $0x4,%esp
  80bb06:	68 88 35 81 00       	push   $0x813588
  80bb0b:	68 75 02 00 00       	push   $0x275
  80bb10:	68 26 36 81 00       	push   $0x813626
  80bb15:	e8 ef 2c 00 00       	call   80e809 <_panic>

0080bb1a <poll_tcp>:
{
  80bb1a:	55                   	push   %ebp
  80bb1b:	89 e5                	mov    %esp,%ebp
  80bb1d:	83 ec 08             	sub    $0x8,%esp
  80bb20:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bb23:	85 c0                	test   %eax,%eax
  80bb25:	74 14                	je     80bb3b <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80bb27:	8b 50 04             	mov    0x4(%eax),%edx
  80bb2a:	83 fa 01             	cmp    $0x1,%edx
  80bb2d:	74 23                	je     80bb52 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80bb2f:	83 fa 04             	cmp    $0x4,%edx
  80bb32:	74 25                	je     80bb59 <poll_tcp+0x3f>
}
  80bb34:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb39:	c9                   	leave  
  80bb3a:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bb3b:	83 ec 04             	sub    $0x4,%esp
  80bb3e:	68 79 36 81 00       	push   $0x813679
  80bb43:	68 eb 00 00 00       	push   $0xeb
  80bb48:	68 26 36 81 00       	push   $0x813626
  80bb4d:	e8 b7 2c 00 00       	call   80e809 <_panic>
    do_writemore(conn);
  80bb52:	e8 98 fc ff ff       	call   80b7ef <do_writemore>
  80bb57:	eb db                	jmp    80bb34 <poll_tcp+0x1a>
    do_close_internal(conn);
  80bb59:	e8 f8 fd ff ff       	call   80b956 <do_close_internal>
  80bb5e:	eb d4                	jmp    80bb34 <poll_tcp+0x1a>

0080bb60 <sent_tcp>:
{
  80bb60:	55                   	push   %ebp
  80bb61:	89 e5                	mov    %esp,%ebp
  80bb63:	56                   	push   %esi
  80bb64:	53                   	push   %ebx
  80bb65:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb68:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bb6b:	85 db                	test   %ebx,%ebx
  80bb6d:	74 3e                	je     80bbad <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80bb6f:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb72:	83 f8 01             	cmp    $0x1,%eax
  80bb75:	74 4d                	je     80bbc4 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80bb77:	83 f8 04             	cmp    $0x4,%eax
  80bb7a:	74 6e                	je     80bbea <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80bb7c:	8b 43 08             	mov    0x8(%ebx),%eax
  80bb7f:	85 c0                	test   %eax,%eax
  80bb81:	74 1e                	je     80bba1 <sent_tcp+0x41>
  80bb83:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80bb89:	76 16                	jbe    80bba1 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80bb8b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bb8e:	85 c0                	test   %eax,%eax
  80bb90:	74 0f                	je     80bba1 <sent_tcp+0x41>
  80bb92:	83 ec 04             	sub    $0x4,%esp
  80bb95:	0f b7 f6             	movzwl %si,%esi
  80bb98:	56                   	push   %esi
  80bb99:	6a 02                	push   $0x2
  80bb9b:	53                   	push   %ebx
  80bb9c:	ff d0                	call   *%eax
  80bb9e:	83 c4 10             	add    $0x10,%esp
}
  80bba1:	b8 00 00 00 00       	mov    $0x0,%eax
  80bba6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bba9:	5b                   	pop    %ebx
  80bbaa:	5e                   	pop    %esi
  80bbab:	5d                   	pop    %ebp
  80bbac:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bbad:	83 ec 04             	sub    $0x4,%esp
  80bbb0:	68 79 36 81 00       	push   $0x813679
  80bbb5:	68 03 01 00 00       	push   $0x103
  80bbba:	68 26 36 81 00       	push   $0x813626
  80bbbf:	e8 45 2c 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bbc4:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bbc8:	74 09                	je     80bbd3 <sent_tcp+0x73>
    do_writemore(conn);
  80bbca:	89 d8                	mov    %ebx,%eax
  80bbcc:	e8 1e fc ff ff       	call   80b7ef <do_writemore>
  80bbd1:	eb a9                	jmp    80bb7c <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80bbd3:	83 ec 04             	sub    $0x4,%esp
  80bbd6:	68 f2 36 81 00       	push   $0x8136f2
  80bbdb:	68 06 01 00 00       	push   $0x106
  80bbe0:	68 26 36 81 00       	push   $0x813626
  80bbe5:	e8 1f 2c 00 00       	call   80e809 <_panic>
    do_close_internal(conn);
  80bbea:	89 d8                	mov    %ebx,%eax
  80bbec:	e8 65 fd ff ff       	call   80b956 <do_close_internal>
  80bbf1:	eb 89                	jmp    80bb7c <sent_tcp+0x1c>

0080bbf3 <do_newconn>:
{
  80bbf3:	55                   	push   %ebp
  80bbf4:	89 e5                	mov    %esp,%ebp
  80bbf6:	56                   	push   %esi
  80bbf7:	53                   	push   %ebx
  80bbf8:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80bbfb:	8b 03                	mov    (%ebx),%eax
  80bbfd:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bc01:	74 17                	je     80bc1a <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80bc03:	83 ec 0c             	sub    $0xc,%esp
  80bc06:	8b 03                	mov    (%ebx),%eax
  80bc08:	ff 70 10             	pushl  0x10(%eax)
  80bc0b:	e8 54 e6 ff ff       	call   80a264 <sys_sem_signal>
}
  80bc10:	83 c4 10             	add    $0x10,%esp
  80bc13:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bc16:	5b                   	pop    %ebx
  80bc17:	5e                   	pop    %esi
  80bc18:	5d                   	pop    %ebp
  80bc19:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80bc1a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bc1e:	8b 33                	mov    (%ebx),%esi
  80bc20:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bc24:	75 20                	jne    80bc46 <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bc26:	8b 06                	mov    (%esi),%eax
  80bc28:	25 f0 00 00 00       	and    $0xf0,%eax
  80bc2d:	83 f8 20             	cmp    $0x20,%eax
  80bc30:	74 67                	je     80bc99 <do_newconn+0xa6>
  80bc32:	83 f8 40             	cmp    $0x40,%eax
  80bc35:	74 26                	je     80bc5d <do_newconn+0x6a>
  80bc37:	83 f8 10             	cmp    $0x10,%eax
  80bc3a:	0f 84 99 00 00 00    	je     80bcd9 <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80bc40:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bc44:	eb bd                	jmp    80bc03 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bc46:	83 ec 04             	sub    $0x4,%esp
  80bc49:	68 ac 35 81 00       	push   $0x8135ac
  80bc4e:	68 8a 01 00 00       	push   $0x18a
  80bc53:	68 26 36 81 00       	push   $0x813626
  80bc58:	e8 ac 2b 00 00       	call   80e809 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80bc5d:	83 ec 0c             	sub    $0xc,%esp
  80bc60:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80bc64:	50                   	push   %eax
  80bc65:	e8 67 25 00 00       	call   80e1d1 <raw_new>
  80bc6a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80bc6d:	8b 03                	mov    (%ebx),%eax
  80bc6f:	8b 50 08             	mov    0x8(%eax),%edx
  80bc72:	83 c4 10             	add    $0x10,%esp
  80bc75:	85 d2                	test   %edx,%edx
  80bc77:	74 17                	je     80bc90 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80bc79:	83 ec 04             	sub    $0x4,%esp
  80bc7c:	50                   	push   %eax
  80bc7d:	68 96 b5 80 00       	push   $0x80b596
  80bc82:	52                   	push   %edx
  80bc83:	e8 cd 23 00 00       	call   80e055 <raw_recv>
  80bc88:	83 c4 10             	add    $0x10,%esp
  80bc8b:	e9 73 ff ff ff       	jmp    80bc03 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bc90:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bc94:	e9 6a ff ff ff       	jmp    80bc03 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80bc99:	e8 27 d5 ff ff       	call   8091c5 <udp_new>
  80bc9e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80bca1:	8b 03                	mov    (%ebx),%eax
  80bca3:	8b 50 08             	mov    0x8(%eax),%edx
  80bca6:	85 d2                	test   %edx,%edx
  80bca8:	74 20                	je     80bcca <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80bcaa:	83 38 22             	cmpl   $0x22,(%eax)
  80bcad:	74 24                	je     80bcd3 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80bcaf:	8b 03                	mov    (%ebx),%eax
  80bcb1:	83 ec 04             	sub    $0x4,%esp
  80bcb4:	50                   	push   %eax
  80bcb5:	68 8c b4 80 00       	push   $0x80b48c
  80bcba:	ff 70 08             	pushl  0x8(%eax)
  80bcbd:	e8 ab d4 ff ff       	call   80916d <udp_recv>
  80bcc2:	83 c4 10             	add    $0x10,%esp
  80bcc5:	e9 39 ff ff ff       	jmp    80bc03 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bcca:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bcce:	e9 30 ff ff ff       	jmp    80bc03 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bcd3:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bcd7:	eb d6                	jmp    80bcaf <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bcd9:	e8 b3 a7 ff ff       	call   806491 <tcp_new>
  80bcde:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bce1:	8b 03                	mov    (%ebx),%eax
  80bce3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bce7:	74 0a                	je     80bcf3 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bce9:	e8 90 f9 ff ff       	call   80b67e <setup_tcp>
  80bcee:	e9 10 ff ff ff       	jmp    80bc03 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bcf3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bcf7:	e9 07 ff ff ff       	jmp    80bc03 <do_newconn+0x10>

0080bcfc <netconn_alloc>:
{
  80bcfc:	55                   	push   %ebp
  80bcfd:	89 e5                	mov    %esp,%ebp
  80bcff:	53                   	push   %ebx
  80bd00:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bd03:	6a 07                	push   $0x7
  80bd05:	e8 47 89 ff ff       	call   804651 <memp_malloc>
  80bd0a:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bd0c:	83 c4 10             	add    $0x10,%esp
  80bd0f:	85 c0                	test   %eax,%eax
  80bd11:	74 5b                	je     80bd6e <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bd13:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bd17:	8b 45 08             	mov    0x8(%ebp),%eax
  80bd1a:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bd1c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bd23:	83 ec 0c             	sub    $0xc,%esp
  80bd26:	6a 00                	push   $0x0
  80bd28:	e8 7a e2 ff ff       	call   809fa7 <sys_sem_new>
  80bd2d:	89 43 10             	mov    %eax,0x10(%ebx)
  80bd30:	83 c4 10             	add    $0x10,%esp
  80bd33:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd36:	74 3d                	je     80bd75 <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bd38:	83 ec 0c             	sub    $0xc,%esp
  80bd3b:	6a 00                	push   $0x0
  80bd3d:	e8 0e e4 ff ff       	call   80a150 <sys_mbox_new>
  80bd42:	89 43 14             	mov    %eax,0x14(%ebx)
  80bd45:	83 c4 10             	add    $0x10,%esp
  80bd48:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bd4b:	74 3d                	je     80bd8a <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bd4d:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bd54:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bd5b:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bd62:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd65:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bd68:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bd6e:	89 d8                	mov    %ebx,%eax
  80bd70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bd73:	c9                   	leave  
  80bd74:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bd75:	83 ec 08             	sub    $0x8,%esp
  80bd78:	53                   	push   %ebx
  80bd79:	6a 07                	push   $0x7
  80bd7b:	e8 27 89 ff ff       	call   8046a7 <memp_free>
    return NULL;
  80bd80:	83 c4 10             	add    $0x10,%esp
  80bd83:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bd88:	eb e4                	jmp    80bd6e <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bd8a:	83 ec 0c             	sub    $0xc,%esp
  80bd8d:	ff 73 10             	pushl  0x10(%ebx)
  80bd90:	e8 93 e2 ff ff       	call   80a028 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bd95:	83 c4 08             	add    $0x8,%esp
  80bd98:	53                   	push   %ebx
  80bd99:	6a 07                	push   $0x7
  80bd9b:	e8 07 89 ff ff       	call   8046a7 <memp_free>
    return NULL;
  80bda0:	83 c4 10             	add    $0x10,%esp
  80bda3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bda8:	eb c4                	jmp    80bd6e <netconn_alloc+0x72>

0080bdaa <netconn_free>:
{
  80bdaa:	55                   	push   %ebp
  80bdab:	89 e5                	mov    %esp,%ebp
  80bdad:	56                   	push   %esi
  80bdae:	53                   	push   %ebx
  80bdaf:	83 ec 10             	sub    $0x10,%esp
  80bdb2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bdb5:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bdb9:	75 0b                	jne    80bdc6 <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bdbb:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bdbe:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bdc2:	75 27                	jne    80bdeb <netconn_free+0x41>
  80bdc4:	eb 68                	jmp    80be2e <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bdc6:	83 ec 04             	sub    $0x4,%esp
  80bdc9:	68 cc 35 81 00       	push   $0x8135cc
  80bdce:	68 26 02 00 00       	push   $0x226
  80bdd3:	68 26 36 81 00       	push   $0x813626
  80bdd8:	e8 2c 2a 00 00       	call   80e809 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bddd:	83 ec 0c             	sub    $0xc,%esp
  80bde0:	ff 75 f4             	pushl  -0xc(%ebp)
  80bde3:	e8 73 68 ff ff       	call   80265b <netbuf_delete>
  80bde8:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bdeb:	83 ec 08             	sub    $0x8,%esp
  80bdee:	56                   	push   %esi
  80bdef:	ff 73 14             	pushl  0x14(%ebx)
  80bdf2:	e8 d0 e7 ff ff       	call   80a5c7 <sys_arch_mbox_tryfetch>
  80bdf7:	83 c4 10             	add    $0x10,%esp
  80bdfa:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bdfd:	74 1a                	je     80be19 <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bdff:	83 3b 10             	cmpl   $0x10,(%ebx)
  80be02:	75 d9                	jne    80bddd <netconn_free+0x33>
        if(mem != NULL) {
  80be04:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80be07:	85 c0                	test   %eax,%eax
  80be09:	74 e0                	je     80bdeb <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80be0b:	83 ec 0c             	sub    $0xc,%esp
  80be0e:	50                   	push   %eax
  80be0f:	e8 e0 8b ff ff       	call   8049f4 <pbuf_free>
  80be14:	83 c4 10             	add    $0x10,%esp
  80be17:	eb d2                	jmp    80bdeb <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80be19:	83 ec 0c             	sub    $0xc,%esp
  80be1c:	ff 73 14             	pushl  0x14(%ebx)
  80be1f:	e8 8d e2 ff ff       	call   80a0b1 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80be24:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80be2b:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80be2e:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80be31:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80be35:	74 39                	je     80be70 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80be37:	83 ec 08             	sub    $0x8,%esp
  80be3a:	56                   	push   %esi
  80be3b:	ff 73 18             	pushl  0x18(%ebx)
  80be3e:	e8 84 e7 ff ff       	call   80a5c7 <sys_arch_mbox_tryfetch>
  80be43:	83 c4 10             	add    $0x10,%esp
  80be46:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be49:	74 10                	je     80be5b <netconn_free+0xb1>
      netconn_delete((struct netconn *)mem);
  80be4b:	83 ec 0c             	sub    $0xc,%esp
  80be4e:	ff 75 f4             	pushl  -0xc(%ebp)
  80be51:	e8 24 f0 ff ff       	call   80ae7a <netconn_delete>
  80be56:	83 c4 10             	add    $0x10,%esp
  80be59:	eb dc                	jmp    80be37 <netconn_free+0x8d>
    sys_mbox_free(conn->acceptmbox);
  80be5b:	83 ec 0c             	sub    $0xc,%esp
  80be5e:	ff 73 18             	pushl  0x18(%ebx)
  80be61:	e8 4b e2 ff ff       	call   80a0b1 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80be66:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80be6d:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80be70:	83 ec 0c             	sub    $0xc,%esp
  80be73:	ff 73 10             	pushl  0x10(%ebx)
  80be76:	e8 ad e1 ff ff       	call   80a028 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80be7b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80be82:	83 c4 08             	add    $0x8,%esp
  80be85:	53                   	push   %ebx
  80be86:	6a 07                	push   $0x7
  80be88:	e8 1a 88 ff ff       	call   8046a7 <memp_free>
}
  80be8d:	83 c4 10             	add    $0x10,%esp
  80be90:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80be93:	5b                   	pop    %ebx
  80be94:	5e                   	pop    %esi
  80be95:	5d                   	pop    %ebp
  80be96:	c3                   	ret    

0080be97 <accept_function>:
{
  80be97:	55                   	push   %ebp
  80be98:	89 e5                	mov    %esp,%ebp
  80be9a:	57                   	push   %edi
  80be9b:	56                   	push   %esi
  80be9c:	53                   	push   %ebx
  80be9d:	83 ec 0c             	sub    $0xc,%esp
  80bea0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bea3:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bea6:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80beaa:	74 57                	je     80bf03 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80beac:	83 ec 08             	sub    $0x8,%esp
  80beaf:	ff 73 2c             	pushl  0x2c(%ebx)
  80beb2:	ff 33                	pushl  (%ebx)
  80beb4:	e8 43 fe ff ff       	call   80bcfc <netconn_alloc>
  80beb9:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bebb:	83 c4 10             	add    $0x10,%esp
  80bebe:	85 c0                	test   %eax,%eax
  80bec0:	74 72                	je     80bf34 <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bec2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bec5:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bec8:	89 f0                	mov    %esi,%eax
  80beca:	e8 af f7 ff ff       	call   80b67e <setup_tcp>
  newconn->err = err;
  80becf:	89 f8                	mov    %edi,%eax
  80bed1:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bed4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bed7:	85 c0                	test   %eax,%eax
  80bed9:	74 0d                	je     80bee8 <accept_function+0x51>
  80bedb:	83 ec 04             	sub    $0x4,%esp
  80bede:	6a 00                	push   $0x0
  80bee0:	6a 00                	push   $0x0
  80bee2:	53                   	push   %ebx
  80bee3:	ff d0                	call   *%eax
  80bee5:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bee8:	83 ec 08             	sub    $0x8,%esp
  80beeb:	56                   	push   %esi
  80beec:	ff 73 18             	pushl  0x18(%ebx)
  80beef:	e8 f0 e4 ff ff       	call   80a3e4 <sys_mbox_trypost>
  80bef4:	83 c4 10             	add    $0x10,%esp
  80bef7:	84 c0                	test   %al,%al
  80bef9:	75 1f                	jne    80bf1a <accept_function+0x83>
}
  80befb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80befe:	5b                   	pop    %ebx
  80beff:	5e                   	pop    %esi
  80bf00:	5f                   	pop    %edi
  80bf01:	5d                   	pop    %ebp
  80bf02:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bf03:	83 ec 04             	sub    $0x4,%esp
  80bf06:	68 fc 35 81 00       	push   $0x8135fc
  80bf0b:	68 65 01 00 00       	push   $0x165
  80bf10:	68 26 36 81 00       	push   $0x813626
  80bf15:	e8 ef 28 00 00       	call   80e809 <_panic>
    newconn->pcb.tcp = NULL;
  80bf1a:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bf21:	83 ec 0c             	sub    $0xc,%esp
  80bf24:	56                   	push   %esi
  80bf25:	e8 80 fe ff ff       	call   80bdaa <netconn_free>
    return ERR_MEM;
  80bf2a:	83 c4 10             	add    $0x10,%esp
  80bf2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bf32:	eb c7                	jmp    80befb <accept_function+0x64>
    return ERR_MEM;
  80bf34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bf39:	eb c0                	jmp    80befb <accept_function+0x64>

0080bf3b <do_delconn>:
{
  80bf3b:	55                   	push   %ebp
  80bf3c:	89 e5                	mov    %esp,%ebp
  80bf3e:	53                   	push   %ebx
  80bf3f:	83 ec 04             	sub    $0x4,%esp
  80bf42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bf45:	8b 13                	mov    (%ebx),%edx
  80bf47:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bf4a:	85 c9                	test   %ecx,%ecx
  80bf4c:	74 16                	je     80bf64 <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bf4e:	8b 02                	mov    (%edx),%eax
  80bf50:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf55:	83 f8 20             	cmp    $0x20,%eax
  80bf58:	74 53                	je     80bfad <do_delconn+0x72>
  80bf5a:	83 f8 40             	cmp    $0x40,%eax
  80bf5d:	74 40                	je     80bf9f <do_delconn+0x64>
  80bf5f:	83 f8 10             	cmp    $0x10,%eax
  80bf62:	74 62                	je     80bfc6 <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bf64:	8b 13                	mov    (%ebx),%edx
  80bf66:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bf69:	85 c0                	test   %eax,%eax
  80bf6b:	74 23                	je     80bf90 <do_delconn+0x55>
  80bf6d:	83 ec 04             	sub    $0x4,%esp
  80bf70:	6a 00                	push   $0x0
  80bf72:	6a 00                	push   $0x0
  80bf74:	52                   	push   %edx
  80bf75:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80bf77:	8b 13                	mov    (%ebx),%edx
  80bf79:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bf7c:	83 c4 10             	add    $0x10,%esp
  80bf7f:	85 c0                	test   %eax,%eax
  80bf81:	74 0d                	je     80bf90 <do_delconn+0x55>
  80bf83:	83 ec 04             	sub    $0x4,%esp
  80bf86:	6a 00                	push   $0x0
  80bf88:	6a 02                	push   $0x2
  80bf8a:	52                   	push   %edx
  80bf8b:	ff d0                	call   *%eax
  80bf8d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80bf90:	8b 03                	mov    (%ebx),%eax
  80bf92:	8b 40 10             	mov    0x10(%eax),%eax
  80bf95:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bf98:	75 3c                	jne    80bfd6 <do_delconn+0x9b>
}
  80bf9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bf9d:	c9                   	leave  
  80bf9e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80bf9f:	83 ec 0c             	sub    $0xc,%esp
  80bfa2:	51                   	push   %ecx
  80bfa3:	e8 e5 21 00 00       	call   80e18d <raw_remove>
      break;
  80bfa8:	83 c4 10             	add    $0x10,%esp
  80bfab:	eb b7                	jmp    80bf64 <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80bfad:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80bfb4:	83 ec 0c             	sub    $0xc,%esp
  80bfb7:	8b 03                	mov    (%ebx),%eax
  80bfb9:	ff 70 08             	pushl  0x8(%eax)
  80bfbc:	e8 c0 d1 ff ff       	call   809181 <udp_remove>
      break;
  80bfc1:	83 c4 10             	add    $0x10,%esp
  80bfc4:	eb 9e                	jmp    80bf64 <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80bfc6:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80bfcd:	8b 03                	mov    (%ebx),%eax
  80bfcf:	e8 82 f9 ff ff       	call   80b956 <do_close_internal>
      return;
  80bfd4:	eb c4                	jmp    80bf9a <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80bfd6:	83 ec 0c             	sub    $0xc,%esp
  80bfd9:	50                   	push   %eax
  80bfda:	e8 85 e2 ff ff       	call   80a264 <sys_sem_signal>
  80bfdf:	83 c4 10             	add    $0x10,%esp
  80bfe2:	eb b6                	jmp    80bf9a <do_delconn+0x5f>

0080bfe4 <do_bind>:
{
  80bfe4:	55                   	push   %ebp
  80bfe5:	89 e5                	mov    %esp,%ebp
  80bfe7:	56                   	push   %esi
  80bfe8:	53                   	push   %ebx
  80bfe9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80bfec:	8b 33                	mov    (%ebx),%esi
  80bfee:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80bff2:	7c 1d                	jl     80c011 <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80bff4:	8b 56 08             	mov    0x8(%esi),%edx
  80bff7:	85 d2                	test   %edx,%edx
  80bff9:	74 73                	je     80c06e <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bffb:	8b 06                	mov    (%esi),%eax
  80bffd:	25 f0 00 00 00       	and    $0xf0,%eax
  80c002:	83 f8 20             	cmp    $0x20,%eax
  80c005:	74 35                	je     80c03c <do_bind+0x58>
  80c007:	83 f8 40             	cmp    $0x40,%eax
  80c00a:	74 1c                	je     80c028 <do_bind+0x44>
  80c00c:	83 f8 10             	cmp    $0x10,%eax
  80c00f:	74 44                	je     80c055 <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80c011:	83 ec 0c             	sub    $0xc,%esp
  80c014:	8b 03                	mov    (%ebx),%eax
  80c016:	ff 70 10             	pushl  0x10(%eax)
  80c019:	e8 46 e2 ff ff       	call   80a264 <sys_sem_signal>
}
  80c01e:	83 c4 10             	add    $0x10,%esp
  80c021:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c024:	5b                   	pop    %ebx
  80c025:	5e                   	pop    %esi
  80c026:	5d                   	pop    %ebp
  80c027:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c028:	83 ec 08             	sub    $0x8,%esp
  80c02b:	ff 73 04             	pushl  0x4(%ebx)
  80c02e:	52                   	push   %edx
  80c02f:	e8 e6 1f 00 00       	call   80e01a <raw_bind>
  80c034:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c037:	83 c4 10             	add    $0x10,%esp
  80c03a:	eb d5                	jmp    80c011 <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c03c:	83 ec 04             	sub    $0x4,%esp
  80c03f:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c043:	50                   	push   %eax
  80c044:	ff 73 04             	pushl  0x4(%ebx)
  80c047:	52                   	push   %edx
  80c048:	e8 e4 cd ff ff       	call   808e31 <udp_bind>
  80c04d:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c050:	83 c4 10             	add    $0x10,%esp
  80c053:	eb bc                	jmp    80c011 <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c055:	83 ec 04             	sub    $0x4,%esp
  80c058:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c05c:	50                   	push   %eax
  80c05d:	ff 73 04             	pushl  0x4(%ebx)
  80c060:	52                   	push   %edx
  80c061:	e8 3e 95 ff ff       	call   8055a4 <tcp_bind>
  80c066:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c069:	83 c4 10             	add    $0x10,%esp
  80c06c:	eb a3                	jmp    80c011 <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80c06e:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80c072:	eb 9d                	jmp    80c011 <do_bind+0x2d>

0080c074 <do_connect>:
{
  80c074:	55                   	push   %ebp
  80c075:	89 e5                	mov    %esp,%ebp
  80c077:	56                   	push   %esi
  80c078:	53                   	push   %ebx
  80c079:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c07c:	8b 33                	mov    (%ebx),%esi
  80c07e:	8b 56 08             	mov    0x8(%esi),%edx
  80c081:	85 d2                	test   %edx,%edx
  80c083:	74 1d                	je     80c0a2 <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c085:	8b 06                	mov    (%esi),%eax
  80c087:	25 f0 00 00 00       	and    $0xf0,%eax
  80c08c:	83 f8 20             	cmp    $0x20,%eax
  80c08f:	74 42                	je     80c0d3 <do_connect+0x5f>
  80c091:	83 f8 40             	cmp    $0x40,%eax
  80c094:	74 1c                	je     80c0b2 <do_connect+0x3e>
  80c096:	83 f8 10             	cmp    $0x10,%eax
  80c099:	74 5e                	je     80c0f9 <do_connect+0x85>
}
  80c09b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80c09e:	5b                   	pop    %ebx
  80c09f:	5e                   	pop    %esi
  80c0a0:	5d                   	pop    %ebp
  80c0a1:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80c0a2:	83 ec 0c             	sub    $0xc,%esp
  80c0a5:	ff 76 10             	pushl  0x10(%esi)
  80c0a8:	e8 b7 e1 ff ff       	call   80a264 <sys_sem_signal>
    return;
  80c0ad:	83 c4 10             	add    $0x10,%esp
  80c0b0:	eb e9                	jmp    80c09b <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c0b2:	83 ec 08             	sub    $0x8,%esp
  80c0b5:	ff 73 04             	pushl  0x4(%ebx)
  80c0b8:	52                   	push   %edx
  80c0b9:	e8 79 1f 00 00       	call   80e037 <raw_connect>
  80c0be:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c0c1:	83 c4 04             	add    $0x4,%esp
  80c0c4:	8b 03                	mov    (%ebx),%eax
  80c0c6:	ff 70 10             	pushl  0x10(%eax)
  80c0c9:	e8 96 e1 ff ff       	call   80a264 <sys_sem_signal>
    break;
  80c0ce:	83 c4 10             	add    $0x10,%esp
  80c0d1:	eb c8                	jmp    80c09b <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c0d3:	83 ec 04             	sub    $0x4,%esp
  80c0d6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c0da:	50                   	push   %eax
  80c0db:	ff 73 04             	pushl  0x4(%ebx)
  80c0de:	52                   	push   %edx
  80c0df:	e8 fd cf ff ff       	call   8090e1 <udp_connect>
  80c0e4:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c0e7:	83 c4 04             	add    $0x4,%esp
  80c0ea:	8b 03                	mov    (%ebx),%eax
  80c0ec:	ff 70 10             	pushl  0x10(%eax)
  80c0ef:	e8 70 e1 ff ff       	call   80a264 <sys_sem_signal>
    break;
  80c0f4:	83 c4 10             	add    $0x10,%esp
  80c0f7:	eb a2                	jmp    80c09b <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80c0f9:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80c100:	8b 03                	mov    (%ebx),%eax
  80c102:	e8 77 f5 ff ff       	call   80b67e <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80c107:	8b 33                	mov    (%ebx),%esi
  80c109:	68 d1 b6 80 00       	push   $0x80b6d1
  80c10e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c112:	50                   	push   %eax
  80c113:	ff 73 04             	pushl  0x4(%ebx)
  80c116:	ff 76 08             	pushl  0x8(%esi)
  80c119:	e8 bb a3 ff ff       	call   8064d9 <tcp_connect>
  80c11e:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80c121:	83 c4 10             	add    $0x10,%esp
  80c124:	e9 72 ff ff ff       	jmp    80c09b <do_connect+0x27>

0080c129 <do_disconnect>:
{
  80c129:	55                   	push   %ebp
  80c12a:	89 e5                	mov    %esp,%ebp
  80c12c:	53                   	push   %ebx
  80c12d:	83 ec 04             	sub    $0x4,%esp
  80c130:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80c133:	8b 13                	mov    (%ebx),%edx
  80c135:	8b 02                	mov    (%edx),%eax
  80c137:	25 f0 00 00 00       	and    $0xf0,%eax
  80c13c:	83 f8 20             	cmp    $0x20,%eax
  80c13f:	74 15                	je     80c156 <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80c141:	83 ec 0c             	sub    $0xc,%esp
  80c144:	8b 03                	mov    (%ebx),%eax
  80c146:	ff 70 10             	pushl  0x10(%eax)
  80c149:	e8 16 e1 ff ff       	call   80a264 <sys_sem_signal>
}
  80c14e:	83 c4 10             	add    $0x10,%esp
  80c151:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c154:	c9                   	leave  
  80c155:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80c156:	83 ec 0c             	sub    $0xc,%esp
  80c159:	ff 72 08             	pushl  0x8(%edx)
  80c15c:	e8 f1 cf ff ff       	call   809152 <udp_disconnect>
  80c161:	83 c4 10             	add    $0x10,%esp
  80c164:	eb db                	jmp    80c141 <do_disconnect+0x18>

0080c166 <do_listen>:
{
  80c166:	55                   	push   %ebp
  80c167:	89 e5                	mov    %esp,%ebp
  80c169:	57                   	push   %edi
  80c16a:	56                   	push   %esi
  80c16b:	53                   	push   %ebx
  80c16c:	83 ec 0c             	sub    $0xc,%esp
  80c16f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c172:	8b 03                	mov    (%ebx),%eax
  80c174:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c178:	7c 0c                	jl     80c186 <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80c17a:	8b 50 08             	mov    0x8(%eax),%edx
  80c17d:	85 d2                	test   %edx,%edx
  80c17f:	74 05                	je     80c186 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80c181:	83 38 10             	cmpl   $0x10,(%eax)
  80c184:	74 18                	je     80c19e <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80c186:	83 ec 0c             	sub    $0xc,%esp
  80c189:	8b 03                	mov    (%ebx),%eax
  80c18b:	ff 70 10             	pushl  0x10(%eax)
  80c18e:	e8 d1 e0 ff ff       	call   80a264 <sys_sem_signal>
}
  80c193:	83 c4 10             	add    $0x10,%esp
  80c196:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c199:	5b                   	pop    %ebx
  80c19a:	5e                   	pop    %esi
  80c19b:	5f                   	pop    %edi
  80c19c:	5d                   	pop    %ebp
  80c19d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c19e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c1a2:	74 06                	je     80c1aa <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80c1a4:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c1a8:	eb dc                	jmp    80c186 <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c1aa:	83 ec 08             	sub    $0x8,%esp
  80c1ad:	68 ff 00 00 00       	push   $0xff
  80c1b2:	52                   	push   %edx
  80c1b3:	e8 37 95 ff ff       	call   8056ef <tcp_listen_with_backlog>
  80c1b8:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c1ba:	83 c4 10             	add    $0x10,%esp
  80c1bd:	85 c0                	test   %eax,%eax
  80c1bf:	74 4e                	je     80c20f <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c1c1:	8b 03                	mov    (%ebx),%eax
  80c1c3:	8b 40 14             	mov    0x14(%eax),%eax
  80c1c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c1c9:	75 4f                	jne    80c21a <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c1cb:	8b 3b                	mov    (%ebx),%edi
  80c1cd:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c1d1:	74 5e                	je     80c231 <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80c1d3:	8b 03                	mov    (%ebx),%eax
  80c1d5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c1d9:	75 ab                	jne    80c186 <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80c1db:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c1e2:	8b 03                	mov    (%ebx),%eax
  80c1e4:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c1e7:	8b 03                	mov    (%ebx),%eax
  80c1e9:	83 ec 08             	sub    $0x8,%esp
  80c1ec:	50                   	push   %eax
  80c1ed:	ff 70 08             	pushl  0x8(%eax)
  80c1f0:	e8 cc 97 ff ff       	call   8059c1 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c1f5:	83 c4 08             	add    $0x8,%esp
  80c1f8:	68 97 be 80 00       	push   $0x80be97
  80c1fd:	8b 03                	mov    (%ebx),%eax
  80c1ff:	ff 70 08             	pushl  0x8(%eax)
  80c202:	e8 fb 97 ff ff       	call   805a02 <tcp_accept>
  80c207:	83 c4 10             	add    $0x10,%esp
  80c20a:	e9 77 ff ff ff       	jmp    80c186 <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80c20f:	8b 03                	mov    (%ebx),%eax
  80c211:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c215:	e9 6c ff ff ff       	jmp    80c186 <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c21a:	83 ec 0c             	sub    $0xc,%esp
  80c21d:	50                   	push   %eax
  80c21e:	e8 8e de ff ff       	call   80a0b1 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c223:	8b 03                	mov    (%ebx),%eax
  80c225:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c22c:	83 c4 10             	add    $0x10,%esp
  80c22f:	eb 9a                	jmp    80c1cb <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c231:	83 ec 0c             	sub    $0xc,%esp
  80c234:	6a 00                	push   $0x0
  80c236:	e8 15 df ff ff       	call   80a150 <sys_mbox_new>
  80c23b:	89 47 18             	mov    %eax,0x18(%edi)
  80c23e:	83 c4 10             	add    $0x10,%esp
  80c241:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c244:	75 8d                	jne    80c1d3 <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c246:	8b 03                	mov    (%ebx),%eax
  80c248:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c24c:	eb 85                	jmp    80c1d3 <do_listen+0x6d>

0080c24e <do_send>:
{
  80c24e:	55                   	push   %ebp
  80c24f:	89 e5                	mov    %esp,%ebp
  80c251:	57                   	push   %edi
  80c252:	56                   	push   %esi
  80c253:	53                   	push   %ebx
  80c254:	83 ec 0c             	sub    $0xc,%esp
  80c257:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c25a:	8b 33                	mov    (%ebx),%esi
  80c25c:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c260:	7c 34                	jl     80c296 <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c262:	8b 56 08             	mov    0x8(%esi),%edx
  80c265:	85 d2                	test   %edx,%edx
  80c267:	74 2d                	je     80c296 <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c269:	8b 06                	mov    (%esi),%eax
  80c26b:	25 f0 00 00 00       	and    $0xf0,%eax
  80c270:	83 f8 20             	cmp    $0x20,%eax
  80c273:	74 4c                	je     80c2c1 <do_send+0x73>
  80c275:	83 f8 40             	cmp    $0x40,%eax
  80c278:	75 1c                	jne    80c296 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c27a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c27d:	8b 48 08             	mov    0x8(%eax),%ecx
  80c280:	85 c9                	test   %ecx,%ecx
  80c282:	74 2a                	je     80c2ae <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c284:	83 ec 04             	sub    $0x4,%esp
  80c287:	51                   	push   %ecx
  80c288:	ff 30                	pushl  (%eax)
  80c28a:	52                   	push   %edx
  80c28b:	e8 d9 1d 00 00       	call   80e069 <raw_sendto>
  80c290:	88 46 0c             	mov    %al,0xc(%esi)
  80c293:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c296:	83 ec 0c             	sub    $0xc,%esp
  80c299:	8b 03                	mov    (%ebx),%eax
  80c29b:	ff 70 10             	pushl  0x10(%eax)
  80c29e:	e8 c1 df ff ff       	call   80a264 <sys_sem_signal>
}
  80c2a3:	83 c4 10             	add    $0x10,%esp
  80c2a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c2a9:	5b                   	pop    %ebx
  80c2aa:	5e                   	pop    %esi
  80c2ab:	5f                   	pop    %edi
  80c2ac:	5d                   	pop    %ebp
  80c2ad:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c2ae:	83 ec 08             	sub    $0x8,%esp
  80c2b1:	ff 30                	pushl  (%eax)
  80c2b3:	52                   	push   %edx
  80c2b4:	e8 bc 1e 00 00       	call   80e175 <raw_send>
  80c2b9:	88 46 0c             	mov    %al,0xc(%esi)
  80c2bc:	83 c4 10             	add    $0x10,%esp
  80c2bf:	eb d5                	jmp    80c296 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c2c1:	8b 43 04             	mov    0x4(%ebx),%eax
  80c2c4:	8b 48 08             	mov    0x8(%eax),%ecx
  80c2c7:	85 c9                	test   %ecx,%ecx
  80c2c9:	74 16                	je     80c2e1 <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c2cb:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c2cf:	57                   	push   %edi
  80c2d0:	51                   	push   %ecx
  80c2d1:	ff 30                	pushl  (%eax)
  80c2d3:	52                   	push   %edx
  80c2d4:	e8 ab cd ff ff       	call   809084 <udp_sendto>
  80c2d9:	88 46 0c             	mov    %al,0xc(%esi)
  80c2dc:	83 c4 10             	add    $0x10,%esp
  80c2df:	eb b5                	jmp    80c296 <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c2e1:	83 ec 08             	sub    $0x8,%esp
  80c2e4:	ff 30                	pushl  (%eax)
  80c2e6:	52                   	push   %edx
  80c2e7:	e8 d8 cd ff ff       	call   8090c4 <udp_send>
  80c2ec:	88 46 0c             	mov    %al,0xc(%esi)
  80c2ef:	83 c4 10             	add    $0x10,%esp
  80c2f2:	eb a2                	jmp    80c296 <do_send+0x48>

0080c2f4 <do_recv>:
{
  80c2f4:	55                   	push   %ebp
  80c2f5:	89 e5                	mov    %esp,%ebp
  80c2f7:	53                   	push   %ebx
  80c2f8:	83 ec 04             	sub    $0x4,%esp
  80c2fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c2fe:	8b 03                	mov    (%ebx),%eax
  80c300:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c304:	7c 0c                	jl     80c312 <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c306:	8b 50 08             	mov    0x8(%eax),%edx
  80c309:	85 d2                	test   %edx,%edx
  80c30b:	74 05                	je     80c312 <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c30d:	83 38 10             	cmpl   $0x10,(%eax)
  80c310:	74 15                	je     80c327 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c312:	83 ec 0c             	sub    $0xc,%esp
  80c315:	8b 03                	mov    (%ebx),%eax
  80c317:	ff 70 10             	pushl  0x10(%eax)
  80c31a:	e8 45 df ff ff       	call   80a264 <sys_sem_signal>
}
  80c31f:	83 c4 10             	add    $0x10,%esp
  80c322:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c325:	c9                   	leave  
  80c326:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c327:	83 ec 08             	sub    $0x8,%esp
  80c32a:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c32e:	50                   	push   %eax
  80c32f:	52                   	push   %edx
  80c330:	e8 d2 94 ff ff       	call   805807 <tcp_recved>
  80c335:	83 c4 10             	add    $0x10,%esp
  80c338:	eb d8                	jmp    80c312 <do_recv+0x1e>

0080c33a <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c33a:	55                   	push   %ebp
  80c33b:	89 e5                	mov    %esp,%ebp
  80c33d:	83 ec 08             	sub    $0x8,%esp
  80c340:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c343:	8b 02                	mov    (%edx),%eax
  80c345:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c349:	7c 0f                	jl     80c35a <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c34b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c34f:	74 05                	je     80c356 <do_write+0x1c>
  80c351:	83 38 10             	cmpl   $0x10,(%eax)
  80c354:	74 16                	je     80c36c <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c356:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c35a:	83 ec 0c             	sub    $0xc,%esp
  80c35d:	8b 02                	mov    (%edx),%eax
  80c35f:	ff 70 10             	pushl  0x10(%eax)
  80c362:	e8 fd de ff ff       	call   80a264 <sys_sem_signal>
  80c367:	83 c4 10             	add    $0x10,%esp
}
  80c36a:	c9                   	leave  
  80c36b:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c36c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c373:	8b 02                	mov    (%edx),%eax
  80c375:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c378:	8b 02                	mov    (%edx),%eax
  80c37a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c381:	8b 02                	mov    (%edx),%eax
  80c383:	e8 67 f4 ff ff       	call   80b7ef <do_writemore>
      return;
  80c388:	eb e0                	jmp    80c36a <do_write+0x30>

0080c38a <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c38a:	55                   	push   %ebp
  80c38b:	89 e5                	mov    %esp,%ebp
  80c38d:	83 ec 08             	sub    $0x8,%esp
  80c390:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c393:	8b 08                	mov    (%eax),%ecx
  80c395:	8b 51 08             	mov    0x8(%ecx),%edx
  80c398:	85 d2                	test   %edx,%edx
  80c39a:	0f 84 a8 00 00 00    	je     80c448 <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c3a0:	8b 48 04             	mov    0x4(%eax),%ecx
  80c3a3:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c3a7:	74 2f                	je     80c3d8 <do_getaddr+0x4e>
  80c3a9:	8b 12                	mov    (%edx),%edx
  80c3ab:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c3ad:	8b 08                	mov    (%eax),%ecx
  80c3af:	8b 11                	mov    (%ecx),%edx
  80c3b1:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c3b7:	83 fa 20             	cmp    $0x20,%edx
  80c3ba:	74 3e                	je     80c3fa <do_getaddr+0x70>
  80c3bc:	83 fa 40             	cmp    $0x40,%edx
  80c3bf:	74 1e                	je     80c3df <do_getaddr+0x55>
  80c3c1:	83 fa 10             	cmp    $0x10,%edx
  80c3c4:	74 64                	je     80c42a <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c3c6:	83 ec 0c             	sub    $0xc,%esp
  80c3c9:	8b 00                	mov    (%eax),%eax
  80c3cb:	ff 70 10             	pushl  0x10(%eax)
  80c3ce:	e8 91 de ff ff       	call   80a264 <sys_sem_signal>
}
  80c3d3:	83 c4 10             	add    $0x10,%esp
  80c3d6:	c9                   	leave  
  80c3d7:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c3d8:	8b 52 04             	mov    0x4(%edx),%edx
  80c3db:	89 11                	mov    %edx,(%ecx)
  80c3dd:	eb ce                	jmp    80c3ad <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c3df:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c3e3:	74 0f                	je     80c3f4 <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c3e5:	8b 50 08             	mov    0x8(%eax),%edx
  80c3e8:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c3eb:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c3ef:	66 89 0a             	mov    %cx,(%edx)
  80c3f2:	eb d2                	jmp    80c3c6 <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c3f4:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c3f8:	eb cc                	jmp    80c3c6 <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c3fa:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c3fe:	74 0f                	je     80c40f <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c400:	8b 50 08             	mov    0x8(%eax),%edx
  80c403:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c406:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c40a:	66 89 0a             	mov    %cx,(%edx)
  80c40d:	eb b7                	jmp    80c3c6 <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c40f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c412:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c416:	75 06                	jne    80c41e <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c418:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c41c:	eb a8                	jmp    80c3c6 <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c41e:	8b 48 08             	mov    0x8(%eax),%ecx
  80c421:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c425:	66 89 11             	mov    %dx,(%ecx)
  80c428:	eb 9c                	jmp    80c3c6 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c42a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c42e:	74 0f                	je     80c43f <do_getaddr+0xb5>
  80c430:	8b 51 08             	mov    0x8(%ecx),%edx
  80c433:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c437:	8b 50 08             	mov    0x8(%eax),%edx
  80c43a:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c43d:	eb 87                	jmp    80c3c6 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c43f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c442:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c446:	eb ef                	jmp    80c437 <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c448:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c44c:	e9 75 ff ff ff       	jmp    80c3c6 <do_getaddr+0x3c>

0080c451 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c451:	55                   	push   %ebp
  80c452:	89 e5                	mov    %esp,%ebp
  80c454:	83 ec 08             	sub    $0x8,%esp
  80c457:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c45a:	8b 02                	mov    (%edx),%eax
  80c45c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c460:	74 05                	je     80c467 <do_close+0x16>
  80c462:	83 38 10             	cmpl   $0x10,(%eax)
  80c465:	74 16                	je     80c47d <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c467:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c46b:	83 ec 0c             	sub    $0xc,%esp
  80c46e:	8b 02                	mov    (%edx),%eax
  80c470:	ff 70 10             	pushl  0x10(%eax)
  80c473:	e8 ec dd ff ff       	call   80a264 <sys_sem_signal>
  80c478:	83 c4 10             	add    $0x10,%esp
  }
}
  80c47b:	c9                   	leave  
  80c47c:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c47d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c484:	8b 02                	mov    (%edx),%eax
  80c486:	e8 cb f4 ff ff       	call   80b956 <do_close_internal>
  80c48b:	eb ee                	jmp    80c47b <do_close+0x2a>

0080c48d <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c48d:	55                   	push   %ebp
  80c48e:	89 e5                	mov    %esp,%ebp
  80c490:	57                   	push   %edi
  80c491:	56                   	push   %esi
  80c492:	53                   	push   %ebx
  80c493:	83 ec 18             	sub    $0x18,%esp
  80c496:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c498:	8b 35 b0 c1 b3 00    	mov    0xb3c1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c49e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c4a2:	50                   	push   %eax
  80c4a3:	e8 33 b4 ff ff       	call   8078db <ntohs>
  80c4a8:	83 c4 10             	add    $0x10,%esp
  80c4ab:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c4af:	0f 86 84 00 00 00    	jbe    80c539 <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c4b5:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c4b8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c4bd:	eb 10                	jmp    80c4cf <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c4bf:	83 c3 01             	add    $0x1,%ebx
  80c4c2:	eb 0b                	jmp    80c4cf <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c4c4:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c4c9:	84 c0                	test   %al,%al
  80c4cb:	74 6c                	je     80c539 <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c4cd:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c4cf:	83 ec 0c             	sub    $0xc,%esp
  80c4d2:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80c4d7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c4db:	50                   	push   %eax
  80c4dc:	e8 fa b3 ff ff       	call   8078db <ntohs>
  80c4e1:	0f b6 d3             	movzbl %bl,%edx
  80c4e4:	66 c1 e8 0c          	shr    $0xc,%ax
  80c4e8:	0f b7 c0             	movzwl %ax,%eax
  80c4eb:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c4f2:	83 c4 10             	add    $0x10,%esp
  80c4f5:	39 c2                	cmp    %eax,%edx
  80c4f7:	7d 40                	jge    80c539 <tcp_parseopt+0xac>
      opt = opts[c];
  80c4f9:	0f b6 d3             	movzbl %bl,%edx
  80c4fc:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c500:	84 c0                	test   %al,%al
  80c502:	74 35                	je     80c539 <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c504:	3c 01                	cmp    $0x1,%al
  80c506:	74 b7                	je     80c4bf <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c508:	3c 02                	cmp    $0x2,%al
  80c50a:	75 b8                	jne    80c4c4 <tcp_parseopt+0x37>
  80c50c:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c511:	75 b1                	jne    80c4c4 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c513:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c518:	c1 e1 08             	shl    $0x8,%ecx
  80c51b:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c520:	89 d0                	mov    %edx,%eax
  80c522:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c524:	83 e8 01             	sub    $0x1,%eax
  80c527:	09 d1                	or     %edx,%ecx
  80c529:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c52d:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c532:	0f 42 c1             	cmovb  %ecx,%eax
  80c535:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c539:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c53c:	5b                   	pop    %ebx
  80c53d:	5e                   	pop    %esi
  80c53e:	5f                   	pop    %edi
  80c53f:	5d                   	pop    %ebp
  80c540:	c3                   	ret    

0080c541 <tcp_receive>:
{
  80c541:	55                   	push   %ebp
  80c542:	89 e5                	mov    %esp,%ebp
  80c544:	57                   	push   %edi
  80c545:	56                   	push   %esi
  80c546:	53                   	push   %ebx
  80c547:	83 ec 1c             	sub    $0x1c,%esp
  80c54a:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c54c:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80c553:	0f 84 22 04 00 00    	je     80c97b <tcp_receive+0x43a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c559:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c55d:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c560:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80c565:	39 c2                	cmp    %eax,%edx
  80c567:	78 53                	js     80c5bc <tcp_receive+0x7b>
  80c569:	39 c2                	cmp    %eax,%edx
  80c56b:	74 36                	je     80c5a3 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c56d:	8b 35 a4 c1 b3 00    	mov    0xb3c1a4,%esi
  80c573:	39 77 64             	cmp    %esi,0x64(%edi)
  80c576:	74 38                	je     80c5b0 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c578:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c57b:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c580:	39 c3                	cmp    %eax,%ebx
  80c582:	74 68                	je     80c5ec <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c584:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c587:	39 da                	cmp    %ebx,%edx
  80c589:	78 0d                	js     80c598 <tcp_receive+0x57>
  80c58b:	89 c2                	mov    %eax,%edx
  80c58d:	2b 57 58             	sub    0x58(%edi),%edx
  80c590:	85 d2                	test   %edx,%edx
  80c592:	0f 8e fa 00 00 00    	jle    80c692 <tcp_receive+0x151>
      pcb->acked = 0;
  80c598:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c59e:	e9 c2 02 00 00       	jmp    80c865 <tcp_receive+0x324>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c5a3:	8b 35 a4 c1 b3 00    	mov    0xb3c1a4,%esi
  80c5a9:	39 77 64             	cmp    %esi,0x64(%edi)
  80c5ac:	79 bf                	jns    80c56d <tcp_receive+0x2c>
  80c5ae:	eb 0c                	jmp    80c5bc <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c5b0:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80c5b6:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c5ba:	73 bc                	jae    80c578 <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c5bc:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80c5c2:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c5c6:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c5ca:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c5cd:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c5d2:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c5d5:	66 85 db             	test   %bx,%bx
  80c5d8:	74 9e                	je     80c578 <tcp_receive+0x37>
  80c5da:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c5e1:	74 95                	je     80c578 <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c5e3:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c5ea:	eb 8c                	jmp    80c578 <tcp_receive+0x37>
      pcb->acked = 0;
  80c5ec:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c5f2:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c5f6:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c5f9:	0f b7 c9             	movzwl %cx,%ecx
  80c5fc:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c5fe:	39 d0                	cmp    %edx,%eax
  80c600:	0f 85 5f 02 00 00    	jne    80c865 <tcp_receive+0x324>
        ++pcb->dupacks;
  80c606:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c60a:	83 c0 01             	add    $0x1,%eax
  80c60d:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c610:	3c 02                	cmp    $0x2,%al
  80c612:	0f 86 4d 02 00 00    	jbe    80c865 <tcp_receive+0x324>
  80c618:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c61c:	0f 84 43 02 00 00    	je     80c865 <tcp_receive+0x324>
          if (!(pcb->flags & TF_INFR)) {
  80c622:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c626:	74 1c                	je     80c644 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c628:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c62c:	89 d0                	mov    %edx,%eax
  80c62e:	66 03 47 34          	add    0x34(%edi),%ax
  80c632:	66 39 c2             	cmp    %ax,%dx
  80c635:	0f 83 2a 02 00 00    	jae    80c865 <tcp_receive+0x324>
              pcb->cwnd += pcb->mss;
  80c63b:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c63f:	e9 21 02 00 00       	jmp    80c865 <tcp_receive+0x324>
            tcp_rexmit(pcb);
  80c644:	83 ec 0c             	sub    $0xc,%esp
  80c647:	57                   	push   %edi
  80c648:	e8 04 c2 ff ff       	call   808851 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c64d:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c651:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c655:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c658:	89 c2                	mov    %eax,%edx
  80c65a:	66 d1 ea             	shr    %dx
  80c65d:	89 d9                	mov    %ebx,%ecx
  80c65f:	66 d1 e9             	shr    %cx
  80c662:	66 39 c3             	cmp    %ax,%bx
  80c665:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c668:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c66c:	0f b7 f1             	movzwl %cx,%esi
  80c66f:	0f b7 d8             	movzwl %ax,%ebx
  80c672:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c674:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c677:	39 de                	cmp    %ebx,%esi
  80c679:	0f 4d d1             	cmovge %ecx,%edx
  80c67c:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c680:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c683:	01 d0                	add    %edx,%eax
  80c685:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c689:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c68d:	e9 d3 01 00 00       	jmp    80c865 <tcp_receive+0x324>
      if (pcb->flags & TF_INFR) {
  80c692:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c696:	f6 c2 04             	test   $0x4,%dl
  80c699:	74 0e                	je     80c6a9 <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c69b:	83 e2 fb             	and    $0xfffffffb,%edx
  80c69e:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c6a1:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c6a5:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c6a9:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c6ad:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c6b1:	66 c1 fa 03          	sar    $0x3,%dx
  80c6b5:	66 03 57 42          	add    0x42(%edi),%dx
  80c6b9:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c6bd:	89 c2                	mov    %eax,%edx
  80c6bf:	29 da                	sub    %ebx,%edx
  80c6c1:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c6c5:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c6c9:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c6cd:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c6d0:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c6d4:	76 1d                	jbe    80c6f3 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c6d6:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c6da:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c6de:	0f 83 d7 00 00 00    	jae    80c7bb <tcp_receive+0x27a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c6e4:	89 c8                	mov    %ecx,%eax
  80c6e6:	66 03 47 34          	add    0x34(%edi),%ax
  80c6ea:	66 39 c1             	cmp    %ax,%cx
  80c6ed:	73 04                	jae    80c6f3 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c6ef:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c6f3:	8b 47 78             	mov    0x78(%edi),%eax
  80c6f6:	85 c0                	test   %eax,%eax
  80c6f8:	0f 84 18 01 00 00    	je     80c816 <tcp_receive+0x2d5>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c6fe:	83 ec 0c             	sub    $0xc,%esp
  80c701:	8b 40 10             	mov    0x10(%eax),%eax
  80c704:	ff 70 04             	pushl  0x4(%eax)
  80c707:	e8 f3 b3 ff ff       	call   807aff <ntohl>
  80c70c:	89 c3                	mov    %eax,%ebx
  80c70e:	8b 47 78             	mov    0x78(%edi),%eax
  80c711:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c715:	8b 40 10             	mov    0x10(%eax),%eax
  80c718:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c71c:	89 04 24             	mov    %eax,(%esp)
  80c71f:	e8 b7 b1 ff ff       	call   8078db <ntohs>
  80c724:	83 c4 10             	add    $0x10,%esp
  80c727:	ba 01 00 00 00       	mov    $0x1,%edx
  80c72c:	a8 01                	test   $0x1,%al
  80c72e:	0f 84 bf 00 00 00    	je     80c7f3 <tcp_receive+0x2b2>
  80c734:	2b 1d a4 c1 b3 00    	sub    0xb3c1a4,%ebx
  80c73a:	01 d6                	add    %edx,%esi
  80c73c:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c73e:	85 db                	test   %ebx,%ebx
  80c740:	0f 8f d0 00 00 00    	jg     80c816 <tcp_receive+0x2d5>
        next = pcb->unacked;
  80c746:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c749:	8b 03                	mov    (%ebx),%eax
  80c74b:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c74e:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c752:	83 ec 0c             	sub    $0xc,%esp
  80c755:	ff 73 04             	pushl  0x4(%ebx)
  80c758:	e8 e1 86 ff ff       	call   804e3e <pbuf_clen>
  80c75d:	0f b6 c0             	movzbl %al,%eax
  80c760:	83 c4 10             	add    $0x10,%esp
  80c763:	66 39 c6             	cmp    %ax,%si
  80c766:	72 74                	jb     80c7dc <tcp_receive+0x29b>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c768:	83 ec 0c             	sub    $0xc,%esp
  80c76b:	ff 73 04             	pushl  0x4(%ebx)
  80c76e:	e8 cb 86 ff ff       	call   804e3e <pbuf_clen>
  80c773:	0f b6 c0             	movzbl %al,%eax
  80c776:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c77a:	89 1c 24             	mov    %ebx,(%esp)
  80c77d:	e8 8c 91 ff ff       	call   80590e <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c782:	83 c4 10             	add    $0x10,%esp
  80c785:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c78a:	0f 84 63 ff ff ff    	je     80c6f3 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c790:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c794:	0f 85 59 ff ff ff    	jne    80c6f3 <tcp_receive+0x1b2>
  80c79a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c79e:	0f 85 4f ff ff ff    	jne    80c6f3 <tcp_receive+0x1b2>
  80c7a4:	83 ec 04             	sub    $0x4,%esp
  80c7a7:	68 30 37 81 00       	push   $0x813730
  80c7ac:	68 5c 03 00 00       	push   $0x35c
  80c7b1:	68 74 38 81 00       	push   $0x813874
  80c7b6:	e8 4e 20 00 00       	call   80e809 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c7bb:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c7bf:	0f af c0             	imul   %eax,%eax
  80c7c2:	0f b7 d9             	movzwl %cx,%ebx
  80c7c5:	99                   	cltd   
  80c7c6:	f7 fb                	idiv   %ebx
  80c7c8:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c7ca:	66 39 c1             	cmp    %ax,%cx
  80c7cd:	0f 83 20 ff ff ff    	jae    80c6f3 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c7d3:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c7d7:	e9 17 ff ff ff       	jmp    80c6f3 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c7dc:	83 ec 04             	sub    $0x4,%esp
  80c7df:	68 08 37 81 00       	push   $0x813708
  80c7e4:	68 55 03 00 00       	push   $0x355
  80c7e9:	68 74 38 81 00       	push   $0x813874
  80c7ee:	e8 16 20 00 00       	call   80e809 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c7f3:	83 ec 0c             	sub    $0xc,%esp
  80c7f6:	8b 47 78             	mov    0x78(%edi),%eax
  80c7f9:	8b 40 10             	mov    0x10(%eax),%eax
  80c7fc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c800:	50                   	push   %eax
  80c801:	e8 d5 b0 ff ff       	call   8078db <ntohs>
  80c806:	66 d1 e8             	shr    %ax
  80c809:	89 c2                	mov    %eax,%edx
  80c80b:	83 e2 01             	and    $0x1,%edx
  80c80e:	83 c4 10             	add    $0x10,%esp
  80c811:	e9 1e ff ff ff       	jmp    80c734 <tcp_receive+0x1f3>
      if(pcb->unacked == NULL)
  80c816:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c81a:	0f 94 c0             	sete   %al
  80c81d:	0f b6 c0             	movzbl %al,%eax
  80c820:	f7 d8                	neg    %eax
  80c822:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c826:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c82a:	eb 39                	jmp    80c865 <tcp_receive+0x324>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c82c:	83 ec 04             	sub    $0x4,%esp
  80c82f:	68 08 37 81 00       	push   $0x813708
  80c834:	68 7f 03 00 00       	push   $0x37f
  80c839:	68 74 38 81 00       	push   $0x813874
  80c83e:	e8 c6 1f 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c843:	83 ec 04             	sub    $0x4,%esp
  80c846:	68 30 37 81 00       	push   $0x813730
  80c84b:	68 85 03 00 00       	push   $0x385
  80c850:	68 74 38 81 00       	push   $0x813874
  80c855:	e8 af 1f 00 00       	call   80e809 <_panic>
      if (pcb->unsent != NULL) {
  80c85a:	8b 47 74             	mov    0x74(%edi),%eax
  80c85d:	85 c0                	test   %eax,%eax
  80c85f:	0f 85 c8 00 00 00    	jne    80c92d <tcp_receive+0x3ec>
    while (pcb->unsent != NULL &&
  80c865:	8b 47 74             	mov    0x74(%edi),%eax
  80c868:	85 c0                	test   %eax,%eax
  80c86a:	0f 84 f9 00 00 00    	je     80c969 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c870:	8b 1d a4 c1 b3 00    	mov    0xb3c1a4,%ebx
  80c876:	83 ec 0c             	sub    $0xc,%esp
  80c879:	8b 40 10             	mov    0x10(%eax),%eax
  80c87c:	ff 70 04             	pushl  0x4(%eax)
  80c87f:	e8 7b b2 ff ff       	call   807aff <ntohl>
  80c884:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c887:	8b 47 74             	mov    0x74(%edi),%eax
  80c88a:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c88e:	8b 40 10             	mov    0x10(%eax),%eax
  80c891:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c895:	89 04 24             	mov    %eax,(%esp)
  80c898:	e8 3e b0 ff ff       	call   8078db <ntohs>
  80c89d:	83 c4 10             	add    $0x10,%esp
  80c8a0:	ba 01 00 00 00       	mov    $0x1,%edx
  80c8a5:	a8 01                	test   $0x1,%al
  80c8a7:	0f 84 99 00 00 00    	je     80c946 <tcp_receive+0x405>
  80c8ad:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c8b0:	01 d6                	add    %edx,%esi
    while (pcb->unsent != NULL &&
  80c8b2:	39 f3                	cmp    %esi,%ebx
  80c8b4:	0f 88 af 00 00 00    	js     80c969 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c8ba:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80c8bf:	2b 47 58             	sub    0x58(%edi),%eax
  80c8c2:	85 c0                	test   %eax,%eax
  80c8c4:	0f 8f 9f 00 00 00    	jg     80c969 <tcp_receive+0x428>
      next = pcb->unsent;
  80c8ca:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c8cd:	8b 03                	mov    (%ebx),%eax
  80c8cf:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c8d2:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c8d6:	83 ec 0c             	sub    $0xc,%esp
  80c8d9:	ff 73 04             	pushl  0x4(%ebx)
  80c8dc:	e8 5d 85 ff ff       	call   804e3e <pbuf_clen>
  80c8e1:	0f b6 c0             	movzbl %al,%eax
  80c8e4:	83 c4 10             	add    $0x10,%esp
  80c8e7:	66 39 c6             	cmp    %ax,%si
  80c8ea:	0f 82 3c ff ff ff    	jb     80c82c <tcp_receive+0x2eb>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c8f0:	83 ec 0c             	sub    $0xc,%esp
  80c8f3:	ff 73 04             	pushl  0x4(%ebx)
  80c8f6:	e8 43 85 ff ff       	call   804e3e <pbuf_clen>
  80c8fb:	0f b6 c0             	movzbl %al,%eax
  80c8fe:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c902:	89 1c 24             	mov    %ebx,(%esp)
  80c905:	e8 04 90 ff ff       	call   80590e <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c90a:	83 c4 10             	add    $0x10,%esp
  80c90d:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c912:	0f 84 42 ff ff ff    	je     80c85a <tcp_receive+0x319>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c918:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c91c:	0f 85 38 ff ff ff    	jne    80c85a <tcp_receive+0x319>
  80c922:	8b 47 74             	mov    0x74(%edi),%eax
  80c925:	85 c0                	test   %eax,%eax
  80c927:	0f 84 16 ff ff ff    	je     80c843 <tcp_receive+0x302>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c92d:	83 ec 0c             	sub    $0xc,%esp
  80c930:	8b 40 10             	mov    0x10(%eax),%eax
  80c933:	ff 70 04             	pushl  0x4(%eax)
  80c936:	e8 ad af ff ff       	call   8078e8 <htonl>
  80c93b:	89 47 54             	mov    %eax,0x54(%edi)
  80c93e:	83 c4 10             	add    $0x10,%esp
  80c941:	e9 1f ff ff ff       	jmp    80c865 <tcp_receive+0x324>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c946:	83 ec 0c             	sub    $0xc,%esp
  80c949:	8b 47 74             	mov    0x74(%edi),%eax
  80c94c:	8b 40 10             	mov    0x10(%eax),%eax
  80c94f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c953:	50                   	push   %eax
  80c954:	e8 82 af ff ff       	call   8078db <ntohs>
  80c959:	66 d1 e8             	shr    %ax
  80c95c:	89 c2                	mov    %eax,%edx
  80c95e:	83 e2 01             	and    $0x1,%edx
  80c961:	83 c4 10             	add    $0x10,%esp
  80c964:	e9 44 ff ff ff       	jmp    80c8ad <tcp_receive+0x36c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c969:	8b 47 38             	mov    0x38(%edi),%eax
  80c96c:	85 c0                	test   %eax,%eax
  80c96e:	74 0b                	je     80c97b <tcp_receive+0x43a>
  80c970:	8b 0d a4 c1 b3 00    	mov    0xb3c1a4,%ecx
  80c976:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c979:	78 70                	js     80c9eb <tcp_receive+0x4aa>
  if (tcplen > 0) {
  80c97b:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80c982:	66 85 c0             	test   %ax,%ax
  80c985:	0f 84 52 08 00 00    	je     80d1dd <tcp_receive+0xc9c>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c98b:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c98e:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
  80c994:	89 d9                	mov    %ebx,%ecx
  80c996:	29 d1                	sub    %edx,%ecx
  80c998:	89 ce                	mov    %ecx,%esi
  80c99a:	83 ee 01             	sub    $0x1,%esi
  80c99d:	78 16                	js     80c9b5 <tcp_receive+0x474>
  80c99f:	be 01 00 00 00       	mov    $0x1,%esi
  80c9a4:	29 d6                	sub    %edx,%esi
  80c9a6:	0f b7 c0             	movzwl %ax,%eax
  80c9a9:	29 c6                	sub    %eax,%esi
  80c9ab:	01 de                	add    %ebx,%esi
  80c9ad:	85 f6                	test   %esi,%esi
  80c9af:	0f 8e 84 00 00 00    	jle    80ca39 <tcp_receive+0x4f8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c9b5:	39 da                	cmp    %ebx,%edx
  80c9b7:	0f 88 bd 01 00 00    	js     80cb7a <tcp_receive+0x639>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c9bd:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c9c1:	89 d1                	mov    %edx,%ecx
  80c9c3:	29 c1                	sub    %eax,%ecx
  80c9c5:	8d 41 01             	lea    0x1(%ecx),%eax
  80c9c8:	29 d8                	sub    %ebx,%eax
  80c9ca:	85 c0                	test   %eax,%eax
  80c9cc:	0f 8e bd 01 00 00    	jle    80cb8f <tcp_receive+0x64e>
      tcp_ack_now(pcb);
  80c9d2:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c9d6:	83 ec 0c             	sub    $0xc,%esp
  80c9d9:	57                   	push   %edi
  80c9da:	e8 50 b8 ff ff       	call   80822f <tcp_output>
  80c9df:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c9e2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80c9e6:	e9 25 08 00 00       	jmp    80d210 <tcp_receive+0xccf>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c9eb:	8b 35 40 c2 b3 00    	mov    0xb3c240,%esi
      m = m - (pcb->sa >> 3);
  80c9f1:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c9f5:	89 d3                	mov    %edx,%ebx
  80c9f7:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c9fb:	89 f1                	mov    %esi,%ecx
  80c9fd:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c9ff:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80ca01:	01 ca                	add    %ecx,%edx
  80ca03:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80ca07:	29 f0                	sub    %esi,%eax
  80ca09:	01 d8                	add    %ebx,%eax
  80ca0b:	66 85 c9             	test   %cx,%cx
  80ca0e:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80ca11:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80ca15:	89 cb                	mov    %ecx,%ebx
  80ca17:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80ca1b:	29 d9                	sub    %ebx,%ecx
  80ca1d:	01 c8                	add    %ecx,%eax
  80ca1f:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80ca23:	66 c1 fa 03          	sar    $0x3,%dx
  80ca27:	01 d0                	add    %edx,%eax
  80ca29:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80ca2d:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80ca34:	e9 42 ff ff ff       	jmp    80c97b <tcp_receive+0x43a>
      off = pcb->rcv_nxt - seqno;
  80ca39:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80ca3b:	8b 1d b8 c1 b3 00    	mov    0xb3c1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80ca41:	85 db                	test   %ebx,%ebx
  80ca43:	0f 84 a4 00 00 00    	je     80caed <tcp_receive+0x5ac>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80ca49:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80ca4f:	0f 8f af 00 00 00    	jg     80cb04 <tcp_receive+0x5c3>
      if (inseg.p->len < off) {
  80ca55:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80ca59:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80ca5c:	39 ca                	cmp    %ecx,%edx
  80ca5e:	0f 8d e5 00 00 00    	jge    80cb49 <tcp_receive+0x608>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80ca64:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80ca68:	0f b7 d6             	movzwl %si,%edx
  80ca6b:	39 ca                	cmp    %ecx,%edx
  80ca6d:	0f 8c a8 00 00 00    	jl     80cb1b <tcp_receive+0x5da>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80ca73:	29 ce                	sub    %ecx,%esi
  80ca75:	89 f1                	mov    %esi,%ecx
  80ca77:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80ca7a:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80ca7c:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80ca80:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80ca86:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80ca88:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80ca8c:	39 c2                	cmp    %eax,%edx
  80ca8e:	7c ea                	jl     80ca7a <tcp_receive+0x539>
        if(pbuf_header(p, (s16_t)-off)) {
  80ca90:	83 ec 08             	sub    $0x8,%esp
  80ca93:	f7 d8                	neg    %eax
  80ca95:	98                   	cwtl   
  80ca96:	50                   	push   %eax
  80ca97:	53                   	push   %ebx
  80ca98:	e8 8a 7e ff ff       	call   804927 <pbuf_header>
  80ca9d:	83 c4 10             	add    $0x10,%esp
  80caa0:	84 c0                	test   %al,%al
  80caa2:	0f 85 8a 00 00 00    	jne    80cb32 <tcp_receive+0x5f1>
      inseg.dataptr = p->payload;
  80caa8:	8b 43 04             	mov    0x4(%ebx),%eax
  80caab:	a3 bc c1 b3 00       	mov    %eax,0xb3c1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80cab0:	8b 57 24             	mov    0x24(%edi),%edx
  80cab3:	0f b7 05 c0 c1 b3 00 	movzwl 0xb3c1c0,%eax
  80caba:	66 03 05 a8 c1 b3 00 	add    0xb3c1a8,%ax
  80cac1:	29 d0                	sub    %edx,%eax
  80cac3:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80cac9:	89 15 a8 c1 b3 00    	mov    %edx,0xb3c1a8
  80cacf:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cad4:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80cad7:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
  80cadd:	8b 5f 24             	mov    0x24(%edi),%ebx
  80cae0:	39 da                	cmp    %ebx,%edx
  80cae2:	0f 88 ea fe ff ff    	js     80c9d2 <tcp_receive+0x491>
  80cae8:	e9 d0 fe ff ff       	jmp    80c9bd <tcp_receive+0x47c>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80caed:	83 ec 04             	sub    $0x4,%esp
  80caf0:	68 8b 38 81 00       	push   $0x81388b
  80caf5:	68 e5 03 00 00       	push   $0x3e5
  80cafa:	68 74 38 81 00       	push   $0x813874
  80caff:	e8 05 1d 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80cb04:	83 ec 04             	sub    $0x4,%esp
  80cb07:	68 9b 38 81 00       	push   $0x81389b
  80cb0c:	68 e6 03 00 00       	push   $0x3e6
  80cb11:	68 74 38 81 00       	push   $0x813874
  80cb16:	e8 ee 1c 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80cb1b:	83 ec 04             	sub    $0x4,%esp
  80cb1e:	68 aa 38 81 00       	push   $0x8138aa
  80cb23:	68 e8 03 00 00       	push   $0x3e8
  80cb28:	68 74 38 81 00       	push   $0x813874
  80cb2d:	e8 d7 1c 00 00       	call   80e809 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cb32:	83 ec 04             	sub    $0x4,%esp
  80cb35:	68 ba 38 81 00       	push   $0x8138ba
  80cb3a:	68 f5 03 00 00       	push   $0x3f5
  80cb3f:	68 74 38 81 00       	push   $0x813874
  80cb44:	e8 c0 1c 00 00       	call   80e809 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80cb49:	83 ec 08             	sub    $0x8,%esp
  80cb4c:	f7 d9                	neg    %ecx
  80cb4e:	0f bf c1             	movswl %cx,%eax
  80cb51:	50                   	push   %eax
  80cb52:	53                   	push   %ebx
  80cb53:	e8 cf 7d ff ff       	call   804927 <pbuf_header>
  80cb58:	83 c4 10             	add    $0x10,%esp
  80cb5b:	84 c0                	test   %al,%al
  80cb5d:	0f 84 45 ff ff ff    	je     80caa8 <tcp_receive+0x567>
          LWIP_ASSERT("pbuf_header failed", 0);
  80cb63:	83 ec 04             	sub    $0x4,%esp
  80cb66:	68 ba 38 81 00       	push   $0x8138ba
  80cb6b:	68 fa 03 00 00       	push   $0x3fa
  80cb70:	68 74 38 81 00       	push   $0x813874
  80cb75:	e8 8f 1c 00 00       	call   80e809 <_panic>
        tcp_ack_now(pcb);
  80cb7a:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cb7e:	83 ec 0c             	sub    $0xc,%esp
  80cb81:	57                   	push   %edi
  80cb82:	e8 a8 b6 ff ff       	call   80822f <tcp_output>
  80cb87:	83 c4 10             	add    $0x10,%esp
  80cb8a:	e9 48 ff ff ff       	jmp    80cad7 <tcp_receive+0x596>
      if (pcb->rcv_nxt == seqno) {
  80cb8f:	39 da                	cmp    %ebx,%edx
  80cb91:	0f 85 d2 03 00 00    	jne    80cf69 <tcp_receive+0xa28>
        if (pcb->ooseq != NULL &&
  80cb97:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cb9a:	85 c0                	test   %eax,%eax
  80cb9c:	74 1d                	je     80cbbb <tcp_receive+0x67a>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80cb9e:	8b 48 10             	mov    0x10(%eax),%ecx
  80cba1:	8b 59 04             	mov    0x4(%ecx),%ebx
  80cba4:	0f b7 0d c0 c1 b3 00 	movzwl 0xb3c1c0,%ecx
  80cbab:	89 de                	mov    %ebx,%esi
  80cbad:	29 ce                	sub    %ecx,%esi
  80cbaf:	89 f1                	mov    %esi,%ecx
  80cbb1:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80cbb3:	85 c9                	test   %ecx,%ecx
  80cbb5:	0f 8e b0 00 00 00    	jle    80cc6b <tcp_receive+0x72a>
        tcplen = TCP_TCPLEN(&inseg);
  80cbbb:	0f b7 1d c0 c1 b3 00 	movzwl 0xb3c1c0,%ebx
  80cbc2:	83 ec 0c             	sub    $0xc,%esp
  80cbc5:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cbca:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbce:	50                   	push   %eax
  80cbcf:	e8 07 ad ff ff       	call   8078db <ntohs>
  80cbd4:	83 c4 10             	add    $0x10,%esp
  80cbd7:	ba 01 00 00 00       	mov    $0x1,%edx
  80cbdc:	a8 01                	test   $0x1,%al
  80cbde:	0f 84 00 01 00 00    	je     80cce4 <tcp_receive+0x7a3>
  80cbe4:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80cbe7:	66 a3 9e c1 b3 00    	mov    %ax,0xb3c19e
        if (pcb->state != CLOSE_WAIT) {
  80cbed:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80cbf1:	74 06                	je     80cbf9 <tcp_receive+0x6b8>
          pcb->rcv_nxt += tcplen;
  80cbf3:	0f b7 d0             	movzwl %ax,%edx
  80cbf6:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80cbf9:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80cbfd:	89 ca                	mov    %ecx,%edx
  80cbff:	29 c2                	sub    %eax,%edx
  80cc01:	66 39 c8             	cmp    %cx,%ax
  80cc04:	b9 00 00 00 00       	mov    $0x0,%ecx
  80cc09:	0f 47 d1             	cmova  %ecx,%edx
  80cc0c:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80cc10:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80cc14:	89 ca                	mov    %ecx,%edx
  80cc16:	29 c2                	sub    %eax,%edx
  80cc18:	66 39 c8             	cmp    %cx,%ax
  80cc1b:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc20:	0f 46 c2             	cmovbe %edx,%eax
  80cc23:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80cc27:	a1 b8 c1 b3 00       	mov    0xb3c1b8,%eax
  80cc2c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cc31:	74 0f                	je     80cc42 <tcp_receive+0x701>
          recv_data = inseg.p;
  80cc33:	a3 98 c1 b3 00       	mov    %eax,0xb3c198
          inseg.p = NULL;
  80cc38:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80cc3f:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80cc42:	83 ec 0c             	sub    $0xc,%esp
  80cc45:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cc4a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc4e:	50                   	push   %eax
  80cc4f:	e8 87 ac ff ff       	call   8078db <ntohs>
  80cc54:	83 c4 10             	add    $0x10,%esp
  80cc57:	a8 01                	test   $0x1,%al
  80cc59:	0f 84 e4 01 00 00    	je     80ce43 <tcp_receive+0x902>
          recv_flags = TF_GOT_FIN;
  80cc5f:	c6 05 9c c1 b3 00 20 	movb   $0x20,0xb3c19c
  80cc66:	e9 d8 01 00 00       	jmp    80ce43 <tcp_receive+0x902>
          if (pcb->ooseq->len > 0) {
  80cc6b:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80cc70:	74 23                	je     80cc95 <tcp_receive+0x754>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80cc72:	29 d3                	sub    %edx,%ebx
  80cc74:	66 89 1d c0 c1 b3 00 	mov    %bx,0xb3c1c0
            pbuf_realloc(inseg.p, inseg.len);
  80cc7b:	83 ec 08             	sub    $0x8,%esp
  80cc7e:	0f b7 db             	movzwl %bx,%ebx
  80cc81:	53                   	push   %ebx
  80cc82:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80cc88:	e8 9f 80 ff ff       	call   804d2c <pbuf_realloc>
  80cc8d:	83 c4 10             	add    $0x10,%esp
  80cc90:	e9 26 ff ff ff       	jmp    80cbbb <tcp_receive+0x67a>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cc95:	83 ec 0c             	sub    $0xc,%esp
  80cc98:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cc9d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cca1:	50                   	push   %eax
  80cca2:	e8 34 ac ff ff       	call   8078db <ntohs>
  80cca7:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cca9:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ccac:	8b 40 10             	mov    0x10(%eax),%eax
  80ccaf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccb3:	89 04 24             	mov    %eax,(%esp)
  80ccb6:	e8 20 ac ff ff       	call   8078db <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80ccbb:	31 c3                	xor    %eax,%ebx
  80ccbd:	83 c4 10             	add    $0x10,%esp
  80ccc0:	f6 c3 03             	test   $0x3,%bl
  80ccc3:	0f 85 f2 fe ff ff    	jne    80cbbb <tcp_receive+0x67a>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80ccc9:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cccc:	8b 10                	mov    (%eax),%edx
  80ccce:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80ccd1:	83 ec 08             	sub    $0x8,%esp
  80ccd4:	50                   	push   %eax
  80ccd5:	6a 04                	push   $0x4
  80ccd7:	e8 cb 79 ff ff       	call   8046a7 <memp_free>
  80ccdc:	83 c4 10             	add    $0x10,%esp
  80ccdf:	e9 d7 fe ff ff       	jmp    80cbbb <tcp_receive+0x67a>
        tcplen = TCP_TCPLEN(&inseg);
  80cce4:	83 ec 0c             	sub    $0xc,%esp
  80cce7:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ccec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ccf0:	50                   	push   %eax
  80ccf1:	e8 e5 ab ff ff       	call   8078db <ntohs>
  80ccf6:	66 d1 e8             	shr    %ax
  80ccf9:	89 c2                	mov    %eax,%edx
  80ccfb:	83 e2 01             	and    $0x1,%edx
  80ccfe:	83 c4 10             	add    $0x10,%esp
  80cd01:	e9 de fe ff ff       	jmp    80cbe4 <tcp_receive+0x6a3>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cd06:	83 ec 0c             	sub    $0xc,%esp
  80cd09:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd0c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd10:	50                   	push   %eax
  80cd11:	e8 c5 ab ff ff       	call   8078db <ntohs>
  80cd16:	66 d1 e8             	shr    %ax
  80cd19:	89 c2                	mov    %eax,%edx
  80cd1b:	83 e2 01             	and    $0x1,%edx
  80cd1e:	83 c4 10             	add    $0x10,%esp
  80cd21:	e9 5d 01 00 00       	jmp    80ce83 <tcp_receive+0x942>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cd26:	83 ec 0c             	sub    $0xc,%esp
  80cd29:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd2c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd30:	50                   	push   %eax
  80cd31:	e8 a5 ab ff ff       	call   8078db <ntohs>
  80cd36:	66 d1 e8             	shr    %ax
  80cd39:	89 c2                	mov    %eax,%edx
  80cd3b:	83 e2 01             	and    $0x1,%edx
  80cd3e:	83 c4 10             	add    $0x10,%esp
  80cd41:	e9 6d 01 00 00       	jmp    80ceb3 <tcp_receive+0x972>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cd46:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd4a:	83 ec 0c             	sub    $0xc,%esp
  80cd4d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd50:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd54:	50                   	push   %eax
  80cd55:	e8 81 ab ff ff       	call   8078db <ntohs>
  80cd5a:	83 c4 10             	add    $0x10,%esp
  80cd5d:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd62:	a8 01                	test   $0x1,%al
  80cd64:	74 0b                	je     80cd71 <tcp_receive+0x830>
  80cd66:	01 d6                	add    %edx,%esi
  80cd68:	66 29 77 28          	sub    %si,0x28(%edi)
  80cd6c:	e9 53 01 00 00       	jmp    80cec4 <tcp_receive+0x983>
  80cd71:	83 ec 0c             	sub    $0xc,%esp
  80cd74:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd77:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd7b:	50                   	push   %eax
  80cd7c:	e8 5a ab ff ff       	call   8078db <ntohs>
  80cd81:	66 d1 e8             	shr    %ax
  80cd84:	89 c2                	mov    %eax,%edx
  80cd86:	83 e2 01             	and    $0x1,%edx
  80cd89:	83 c4 10             	add    $0x10,%esp
  80cd8c:	eb d8                	jmp    80cd66 <tcp_receive+0x825>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cd8e:	83 ec 0c             	sub    $0xc,%esp
  80cd91:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd94:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd98:	50                   	push   %eax
  80cd99:	e8 3d ab ff ff       	call   8078db <ntohs>
  80cd9e:	66 d1 e8             	shr    %ax
  80cda1:	89 c2                	mov    %eax,%edx
  80cda3:	83 e2 01             	and    $0x1,%edx
  80cda6:	83 c4 10             	add    $0x10,%esp
  80cda9:	e9 41 01 00 00       	jmp    80ceef <tcp_receive+0x9ae>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cdae:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cdb2:	83 ec 0c             	sub    $0xc,%esp
  80cdb5:	8b 43 10             	mov    0x10(%ebx),%eax
  80cdb8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cdbc:	50                   	push   %eax
  80cdbd:	e8 19 ab ff ff       	call   8078db <ntohs>
  80cdc2:	83 c4 10             	add    $0x10,%esp
  80cdc5:	ba 01 00 00 00       	mov    $0x1,%edx
  80cdca:	a8 01                	test   $0x1,%al
  80cdcc:	74 0b                	je     80cdd9 <tcp_receive+0x898>
  80cdce:	01 d6                	add    %edx,%esi
  80cdd0:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cdd4:	e9 27 01 00 00       	jmp    80cf00 <tcp_receive+0x9bf>
  80cdd9:	83 ec 0c             	sub    $0xc,%esp
  80cddc:	8b 43 10             	mov    0x10(%ebx),%eax
  80cddf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cde3:	50                   	push   %eax
  80cde4:	e8 f2 aa ff ff       	call   8078db <ntohs>
  80cde9:	66 d1 e8             	shr    %ax
  80cdec:	89 c2                	mov    %eax,%edx
  80cdee:	83 e2 01             	and    $0x1,%edx
  80cdf1:	83 c4 10             	add    $0x10,%esp
  80cdf4:	eb d8                	jmp    80cdce <tcp_receive+0x88d>
              pbuf_cat(recv_data, cseg->p);
  80cdf6:	83 ec 08             	sub    $0x8,%esp
  80cdf9:	50                   	push   %eax
  80cdfa:	52                   	push   %edx
  80cdfb:	e8 67 80 ff ff       	call   804e67 <pbuf_cat>
  80ce00:	83 c4 10             	add    $0x10,%esp
            cseg->p = NULL;
  80ce03:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80ce0a:	83 ec 0c             	sub    $0xc,%esp
  80ce0d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce10:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce14:	50                   	push   %eax
  80ce15:	e8 c1 aa ff ff       	call   8078db <ntohs>
  80ce1a:	83 c4 10             	add    $0x10,%esp
  80ce1d:	a8 01                	test   $0x1,%al
  80ce1f:	74 11                	je     80ce32 <tcp_receive+0x8f1>
            recv_flags = TF_GOT_FIN;
  80ce21:	c6 05 9c c1 b3 00 20 	movb   $0x20,0xb3c19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80ce28:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80ce2c:	0f 84 f4 00 00 00    	je     80cf26 <tcp_receive+0x9e5>
          pcb->ooseq = cseg->next;
  80ce32:	8b 03                	mov    (%ebx),%eax
  80ce34:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80ce37:	83 ec 0c             	sub    $0xc,%esp
  80ce3a:	53                   	push   %ebx
  80ce3b:	e8 ce 8a ff ff       	call   80590e <tcp_seg_free>
  80ce40:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80ce43:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80ce46:	85 db                	test   %ebx,%ebx
  80ce48:	0f 84 e4 00 00 00    	je     80cf32 <tcp_receive+0x9f1>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80ce4e:	8b 53 10             	mov    0x10(%ebx),%edx
  80ce51:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80ce54:	3b 47 24             	cmp    0x24(%edi),%eax
  80ce57:	0f 85 d5 00 00 00    	jne    80cf32 <tcp_receive+0x9f1>
          seqno = pcb->ooseq->tcphdr->seqno;
  80ce5d:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80ce62:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ce66:	83 ec 0c             	sub    $0xc,%esp
  80ce69:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80ce6d:	50                   	push   %eax
  80ce6e:	e8 68 aa ff ff       	call   8078db <ntohs>
  80ce73:	83 c4 10             	add    $0x10,%esp
  80ce76:	ba 01 00 00 00       	mov    $0x1,%edx
  80ce7b:	a8 01                	test   $0x1,%al
  80ce7d:	0f 84 83 fe ff ff    	je     80cd06 <tcp_receive+0x7c5>
  80ce83:	01 d6                	add    %edx,%esi
  80ce85:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80ce88:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80ce8c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ce8f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ce93:	83 ec 0c             	sub    $0xc,%esp
  80ce96:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce99:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce9d:	50                   	push   %eax
  80ce9e:	e8 38 aa ff ff       	call   8078db <ntohs>
  80cea3:	83 c4 10             	add    $0x10,%esp
  80cea6:	ba 01 00 00 00       	mov    $0x1,%edx
  80ceab:	a8 01                	test   $0x1,%al
  80cead:	0f 84 73 fe ff ff    	je     80cd26 <tcp_receive+0x7e5>
  80ceb3:	01 d6                	add    %edx,%esi
  80ceb5:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80ceb8:	0f 8d 88 fe ff ff    	jge    80cd46 <tcp_receive+0x805>
            pcb->rcv_wnd = 0;
  80cebe:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cec4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80cec8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cecb:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cecf:	83 ec 0c             	sub    $0xc,%esp
  80ced2:	8b 43 10             	mov    0x10(%ebx),%eax
  80ced5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ced9:	50                   	push   %eax
  80ceda:	e8 fc a9 ff ff       	call   8078db <ntohs>
  80cedf:	83 c4 10             	add    $0x10,%esp
  80cee2:	ba 01 00 00 00       	mov    $0x1,%edx
  80cee7:	a8 01                	test   $0x1,%al
  80cee9:	0f 84 9f fe ff ff    	je     80cd8e <tcp_receive+0x84d>
  80ceef:	01 d6                	add    %edx,%esi
  80cef1:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cef4:	0f 8d b4 fe ff ff    	jge    80cdae <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80cefa:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80cf00:	8b 43 04             	mov    0x4(%ebx),%eax
  80cf03:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cf08:	0f 84 fc fe ff ff    	je     80ce0a <tcp_receive+0x8c9>
            if (recv_data) {
  80cf0e:	8b 15 98 c1 b3 00    	mov    0xb3c198,%edx
  80cf14:	85 d2                	test   %edx,%edx
  80cf16:	0f 85 da fe ff ff    	jne    80cdf6 <tcp_receive+0x8b5>
              recv_data = cseg->p;
  80cf1c:	a3 98 c1 b3 00       	mov    %eax,0xb3c198
  80cf21:	e9 dd fe ff ff       	jmp    80ce03 <tcp_receive+0x8c2>
              pcb->state = CLOSE_WAIT;
  80cf26:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80cf2d:	e9 00 ff ff ff       	jmp    80ce32 <tcp_receive+0x8f1>
        tcp_ack(pcb);
  80cf32:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cf36:	89 c1                	mov    %eax,%ecx
  80cf38:	83 e1 01             	and    $0x1,%ecx
  80cf3b:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80cf3e:	75 0f                	jne    80cf4f <tcp_receive+0xa0e>
  80cf40:	83 c8 01             	or     $0x1,%eax
  80cf43:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80cf46:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80cf4a:	e9 c1 02 00 00       	jmp    80d210 <tcp_receive+0xccf>
        tcp_ack(pcb);
  80cf4f:	83 e0 fe             	and    $0xfffffffe,%eax
  80cf52:	83 c8 02             	or     $0x2,%eax
  80cf55:	88 47 20             	mov    %al,0x20(%edi)
  80cf58:	83 ec 0c             	sub    $0xc,%esp
  80cf5b:	57                   	push   %edi
  80cf5c:	e8 ce b2 ff ff       	call   80822f <tcp_output>
  80cf61:	83 c4 10             	add    $0x10,%esp
  80cf64:	e9 a7 02 00 00       	jmp    80d210 <tcp_receive+0xccf>
        tcp_ack_now(pcb);
  80cf69:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cf6d:	83 ec 0c             	sub    $0xc,%esp
  80cf70:	57                   	push   %edi
  80cf71:	e8 b9 b2 ff ff       	call   80822f <tcp_output>
        if (pcb->ooseq == NULL) {
  80cf76:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80cf79:	83 c4 10             	add    $0x10,%esp
  80cf7c:	85 db                	test   %ebx,%ebx
  80cf7e:	74 1e                	je     80cf9e <tcp_receive+0xa5d>
            if (seqno == next->tcphdr->seqno) {
  80cf80:	8b 0d a8 c1 b3 00    	mov    0xb3c1a8,%ecx
  80cf86:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80cf89:	8d 51 01             	lea    0x1(%ecx),%edx
  80cf8c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80cf8f:	be 00 00 00 00       	mov    $0x0,%esi
  80cf94:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80cf97:	89 c7                	mov    %eax,%edi
  80cf99:	e9 d7 00 00 00       	jmp    80d075 <tcp_receive+0xb34>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80cf9e:	83 ec 0c             	sub    $0xc,%esp
  80cfa1:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80cfa6:	e8 dc 89 ff ff       	call   805987 <tcp_seg_copy>
  80cfab:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cfae:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfb1:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cfb5:	e9 56 02 00 00       	jmp    80d210 <tcp_receive+0xccf>
  80cfba:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80cfbd:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80cfc1:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cfc5:	66 39 05 c0 c1 b3 00 	cmp    %ax,0xb3c1c0
  80cfcc:	0f 86 3e 02 00 00    	jbe    80d210 <tcp_receive+0xccf>
                cseg = tcp_seg_copy(&inseg);
  80cfd2:	83 ec 0c             	sub    $0xc,%esp
  80cfd5:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80cfda:	e8 a8 89 ff ff       	call   805987 <tcp_seg_copy>
  80cfdf:	89 c1                	mov    %eax,%ecx
  80cfe1:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80cfe4:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfe7:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cfeb:	85 c0                	test   %eax,%eax
  80cfed:	0f 84 1d 02 00 00    	je     80d210 <tcp_receive+0xccf>
                  cseg->next = next->next;
  80cff3:	8b 03                	mov    (%ebx),%eax
  80cff5:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80cff7:	85 f6                	test   %esi,%esi
  80cff9:	74 5c                	je     80d057 <tcp_receive+0xb16>
                    prev->next = cseg;
  80cffb:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80cffd:	83 ec 0c             	sub    $0xc,%esp
  80d000:	53                   	push   %ebx
  80d001:	e8 08 89 ff ff       	call   80590e <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d006:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80d009:	8b 06                	mov    (%esi),%eax
  80d00b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d00e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80d012:	85 c0                	test   %eax,%eax
  80d014:	0f 84 f6 01 00 00    	je     80d210 <tcp_receive+0xccf>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d01a:	8b 0d a8 c1 b3 00    	mov    0xb3c1a8,%ecx
  80d020:	8b 40 10             	mov    0x10(%eax),%eax
  80d023:	8b 40 04             	mov    0x4(%eax),%eax
  80d026:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d02a:	01 ca                	add    %ecx,%edx
  80d02c:	29 c2                	sub    %eax,%edx
  80d02e:	85 d2                	test   %edx,%edx
  80d030:	0f 8e da 01 00 00    	jle    80d210 <tcp_receive+0xccf>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d036:	29 c8                	sub    %ecx,%eax
  80d038:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d03c:	83 ec 08             	sub    $0x8,%esp
  80d03f:	0f b7 c0             	movzwl %ax,%eax
  80d042:	50                   	push   %eax
  80d043:	ff 76 04             	pushl  0x4(%esi)
  80d046:	e8 e1 7c ff ff       	call   804d2c <pbuf_realloc>
  80d04b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d04e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d052:	e9 b9 01 00 00       	jmp    80d210 <tcp_receive+0xccf>
                    pcb->ooseq = cseg;
  80d057:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d05a:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d05d:	eb 9e                	jmp    80cffd <tcp_receive+0xabc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d05f:	39 c1                	cmp    %eax,%ecx
  80d061:	0f 88 a0 00 00 00    	js     80d107 <tcp_receive+0xbc6>
              if (next->next == NULL &&
  80d067:	8b 13                	mov    (%ebx),%edx
  80d069:	89 de                	mov    %ebx,%esi
  80d06b:	85 d2                	test   %edx,%edx
  80d06d:	0f 84 0d 01 00 00    	je     80d180 <tcp_receive+0xc3f>
  80d073:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80d075:	8b 43 10             	mov    0x10(%ebx),%eax
  80d078:	8b 40 04             	mov    0x4(%eax),%eax
  80d07b:	39 c8                	cmp    %ecx,%eax
  80d07d:	0f 84 37 ff ff ff    	je     80cfba <tcp_receive+0xa79>
              if (prev == NULL) {
  80d083:	85 f6                	test   %esi,%esi
  80d085:	74 d8                	je     80d05f <tcp_receive+0xb1e>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d087:	8b 56 10             	mov    0x10(%esi),%edx
  80d08a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d08d:	78 d8                	js     80d067 <tcp_receive+0xb26>
  80d08f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d092:	29 c2                	sub    %eax,%edx
  80d094:	85 d2                	test   %edx,%edx
  80d096:	7f cf                	jg     80d067 <tcp_receive+0xb26>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d098:	0f b7 15 c0 c1 b3 00 	movzwl 0xb3c1c0,%edx
  80d09f:	01 ca                	add    %ecx,%edx
  80d0a1:	29 c2                	sub    %eax,%edx
  80d0a3:	85 d2                	test   %edx,%edx
  80d0a5:	0f 8f b3 00 00 00    	jg     80d15e <tcp_receive+0xc1d>
                cseg = tcp_seg_copy(&inseg);
  80d0ab:	83 ec 0c             	sub    $0xc,%esp
  80d0ae:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d0b3:	e8 cf 88 ff ff       	call   805987 <tcp_seg_copy>
                if (cseg != NULL) {
  80d0b8:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d0bb:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80d0bf:	85 c0                	test   %eax,%eax
  80d0c1:	0f 84 49 01 00 00    	je     80d210 <tcp_receive+0xccf>
                  cseg->next = next;
  80d0c7:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d0c9:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d0cb:	8b 46 10             	mov    0x10(%esi),%eax
  80d0ce:	8b 48 04             	mov    0x4(%eax),%ecx
  80d0d1:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d0d6:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80d0da:	01 ca                	add    %ecx,%edx
  80d0dc:	29 c2                	sub    %eax,%edx
  80d0de:	85 d2                	test   %edx,%edx
  80d0e0:	0f 8e 2a 01 00 00    	jle    80d210 <tcp_receive+0xccf>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d0e6:	29 c8                	sub    %ecx,%eax
  80d0e8:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d0ec:	83 ec 08             	sub    $0x8,%esp
  80d0ef:	0f b7 c0             	movzwl %ax,%eax
  80d0f2:	50                   	push   %eax
  80d0f3:	ff 76 04             	pushl  0x4(%esi)
  80d0f6:	e8 31 7c ff ff       	call   804d2c <pbuf_realloc>
  80d0fb:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d0fe:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d102:	e9 09 01 00 00       	jmp    80d210 <tcp_receive+0xccf>
  80d107:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d10a:	0f b7 15 c0 c1 b3 00 	movzwl 0xb3c1c0,%edx
  80d111:	01 ca                	add    %ecx,%edx
  80d113:	29 c2                	sub    %eax,%edx
  80d115:	85 d2                	test   %edx,%edx
  80d117:	7f 26                	jg     80d13f <tcp_receive+0xbfe>
                  cseg = tcp_seg_copy(&inseg);
  80d119:	83 ec 0c             	sub    $0xc,%esp
  80d11c:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d121:	e8 61 88 ff ff       	call   805987 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d126:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d129:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80d12d:	85 c0                	test   %eax,%eax
  80d12f:	0f 84 db 00 00 00    	je     80d210 <tcp_receive+0xccf>
                    cseg->next = next;
  80d135:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d137:	89 47 7c             	mov    %eax,0x7c(%edi)
  80d13a:	e9 d1 00 00 00       	jmp    80d210 <tcp_receive+0xccf>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d13f:	29 c8                	sub    %ecx,%eax
  80d141:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80d147:	83 ec 08             	sub    $0x8,%esp
  80d14a:	0f b7 c0             	movzwl %ax,%eax
  80d14d:	50                   	push   %eax
  80d14e:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80d154:	e8 d3 7b ff ff       	call   804d2c <pbuf_realloc>
  80d159:	83 c4 10             	add    $0x10,%esp
  80d15c:	eb bb                	jmp    80d119 <tcp_receive+0xbd8>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d15e:	29 c8                	sub    %ecx,%eax
  80d160:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80d166:	83 ec 08             	sub    $0x8,%esp
  80d169:	0f b7 c0             	movzwl %ax,%eax
  80d16c:	50                   	push   %eax
  80d16d:	ff 35 b8 c1 b3 00    	pushl  0xb3c1b8
  80d173:	e8 b4 7b ff ff       	call   804d2c <pbuf_realloc>
  80d178:	83 c4 10             	add    $0x10,%esp
  80d17b:	e9 2b ff ff ff       	jmp    80d0ab <tcp_receive+0xb6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d180:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d182:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d186:	85 c9                	test   %ecx,%ecx
  80d188:	0f 8e 82 00 00 00    	jle    80d210 <tcp_receive+0xccf>
                next->next = tcp_seg_copy(&inseg);
  80d18e:	83 ec 0c             	sub    $0xc,%esp
  80d191:	68 b4 c1 b3 00       	push   $0xb3c1b4
  80d196:	e8 ec 87 ff ff       	call   805987 <tcp_seg_copy>
  80d19b:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d19d:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1a0:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d1a4:	85 c0                	test   %eax,%eax
  80d1a6:	74 68                	je     80d210 <tcp_receive+0xccf>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d1a8:	8b 43 10             	mov    0x10(%ebx),%eax
  80d1ab:	8b 48 04             	mov    0x4(%eax),%ecx
  80d1ae:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d1b3:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d1b7:	01 ca                	add    %ecx,%edx
  80d1b9:	29 c2                	sub    %eax,%edx
  80d1bb:	85 d2                	test   %edx,%edx
  80d1bd:	7e 51                	jle    80d210 <tcp_receive+0xccf>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d1bf:	29 c8                	sub    %ecx,%eax
  80d1c1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d1c5:	83 ec 08             	sub    $0x8,%esp
  80d1c8:	0f b7 c0             	movzwl %ax,%eax
  80d1cb:	50                   	push   %eax
  80d1cc:	ff 73 04             	pushl  0x4(%ebx)
  80d1cf:	e8 58 7b ff ff       	call   804d2c <pbuf_realloc>
  80d1d4:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d1d7:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d1db:	eb 33                	jmp    80d210 <tcp_receive+0xccf>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d1dd:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d1e2:	8b 57 24             	mov    0x24(%edi),%edx
  80d1e5:	39 d0                	cmp    %edx,%eax
  80d1e7:	78 13                	js     80d1fc <tcp_receive+0xcbb>
  80d1e9:	83 c0 01             	add    $0x1,%eax
  80d1ec:	29 d0                	sub    %edx,%eax
  80d1ee:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d1f2:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d1f4:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d1f8:	85 c0                	test   %eax,%eax
  80d1fa:	7e 14                	jle    80d210 <tcp_receive+0xccf>
      tcp_ack_now(pcb);
  80d1fc:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d200:	83 ec 0c             	sub    $0xc,%esp
  80d203:	57                   	push   %edi
  80d204:	e8 26 b0 ff ff       	call   80822f <tcp_output>
  80d209:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d20c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d210:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d214:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d217:	5b                   	pop    %ebx
  80d218:	5e                   	pop    %esi
  80d219:	5f                   	pop    %edi
  80d21a:	5d                   	pop    %ebp
  80d21b:	c3                   	ret    

0080d21c <tcp_input>:
{
  80d21c:	55                   	push   %ebp
  80d21d:	89 e5                	mov    %esp,%ebp
  80d21f:	57                   	push   %edi
  80d220:	56                   	push   %esi
  80d221:	53                   	push   %ebx
  80d222:	83 ec 38             	sub    $0x38,%esp
  80d225:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d228:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d22b:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d231:	0f b7 03             	movzwl (%ebx),%eax
  80d234:	50                   	push   %eax
  80d235:	e8 a1 a6 ff ff       	call   8078db <ntohs>
  80d23a:	66 c1 e8 08          	shr    $0x8,%ax
  80d23e:	83 e0 0f             	and    $0xf,%eax
  80d241:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d244:	a3 b0 c1 b3 00       	mov    %eax,0xb3c1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d249:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d24e:	0f b7 00             	movzwl (%eax),%eax
  80d251:	89 04 24             	mov    %eax,(%esp)
  80d254:	e8 82 a6 ff ff       	call   8078db <ntohs>
  80d259:	83 c4 08             	add    $0x8,%esp
  80d25c:	66 c1 e8 06          	shr    $0x6,%ax
  80d260:	83 e0 3c             	and    $0x3c,%eax
  80d263:	f7 d8                	neg    %eax
  80d265:	98                   	cwtl   
  80d266:	50                   	push   %eax
  80d267:	56                   	push   %esi
  80d268:	e8 ba 76 ff ff       	call   804927 <pbuf_header>
  80d26d:	83 c4 10             	add    $0x10,%esp
  80d270:	84 c0                	test   %al,%al
  80d272:	75 07                	jne    80d27b <tcp_input+0x5f>
  80d274:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d279:	77 14                	ja     80d28f <tcp_input+0x73>
    pbuf_free(p);
  80d27b:	83 ec 0c             	sub    $0xc,%esp
  80d27e:	56                   	push   %esi
  80d27f:	e8 70 77 ff ff       	call   8049f4 <pbuf_free>
    return;
  80d284:	83 c4 10             	add    $0x10,%esp
}
  80d287:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d28a:	5b                   	pop    %ebx
  80d28b:	5e                   	pop    %esi
  80d28c:	5f                   	pop    %edi
  80d28d:	5d                   	pop    %ebp
  80d28e:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d28f:	83 ec 08             	sub    $0x8,%esp
  80d292:	ff 75 0c             	pushl  0xc(%ebp)
  80d295:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d29a:	83 c0 10             	add    $0x10,%eax
  80d29d:	50                   	push   %eax
  80d29e:	e8 c8 93 ff ff       	call   80666b <ip_addr_isbroadcast>
  80d2a3:	83 c4 10             	add    $0x10,%esp
  80d2a6:	84 c0                	test   %al,%al
  80d2a8:	0f 85 54 01 00 00    	jne    80d402 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d2ae:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d2b3:	8b 58 10             	mov    0x10(%eax),%ebx
  80d2b6:	83 ec 0c             	sub    $0xc,%esp
  80d2b9:	68 00 00 00 f0       	push   $0xf0000000
  80d2be:	e8 3c a8 ff ff       	call   807aff <ntohl>
  80d2c3:	21 c3                	and    %eax,%ebx
  80d2c5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d2cc:	e8 2e a8 ff ff       	call   807aff <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d2d1:	83 c4 10             	add    $0x10,%esp
  80d2d4:	39 c3                	cmp    %eax,%ebx
  80d2d6:	0f 84 26 01 00 00    	je     80d402 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d2dc:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d2e1:	83 ec 0c             	sub    $0xc,%esp
  80d2e4:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d2e8:	52                   	push   %edx
  80d2e9:	6a 06                	push   $0x6
  80d2eb:	8d 50 10             	lea    0x10(%eax),%edx
  80d2ee:	52                   	push   %edx
  80d2ef:	83 c0 0c             	add    $0xc,%eax
  80d2f2:	50                   	push   %eax
  80d2f3:	56                   	push   %esi
  80d2f4:	e8 b1 a2 ff ff       	call   8075aa <inet_chksum_pseudo>
  80d2f9:	83 c4 20             	add    $0x20,%esp
  80d2fc:	66 85 c0             	test   %ax,%ax
  80d2ff:	0f 85 0e 01 00 00    	jne    80d413 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d305:	83 ec 0c             	sub    $0xc,%esp
  80d308:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80d30d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d311:	50                   	push   %eax
  80d312:	e8 c4 a5 ff ff       	call   8078db <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d317:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d31a:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d31e:	f7 d8                	neg    %eax
  80d320:	c1 e0 02             	shl    $0x2,%eax
  80d323:	98                   	cwtl   
  80d324:	50                   	push   %eax
  80d325:	56                   	push   %esi
  80d326:	e8 fc 75 ff ff       	call   804927 <pbuf_header>
  80d32b:	83 c4 10             	add    $0x10,%esp
  80d32e:	84 c0                	test   %al,%al
  80d330:	0f 85 ee 00 00 00    	jne    80d424 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d336:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d33c:	83 ec 0c             	sub    $0xc,%esp
  80d33f:	0f b7 03             	movzwl (%ebx),%eax
  80d342:	50                   	push   %eax
  80d343:	e8 93 a5 ff ff       	call   8078db <ntohs>
  80d348:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d34b:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d351:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d355:	89 04 24             	mov    %eax,(%esp)
  80d358:	e8 7e a5 ff ff       	call   8078db <ntohs>
  80d35d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d361:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d367:	83 c4 04             	add    $0x4,%esp
  80d36a:	ff 73 04             	pushl  0x4(%ebx)
  80d36d:	e8 8d a7 ff ff       	call   807aff <ntohl>
  80d372:	89 43 04             	mov    %eax,0x4(%ebx)
  80d375:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d37a:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d380:	83 c4 04             	add    $0x4,%esp
  80d383:	ff 73 08             	pushl  0x8(%ebx)
  80d386:	e8 74 a7 ff ff       	call   807aff <ntohl>
  80d38b:	89 43 08             	mov    %eax,0x8(%ebx)
  80d38e:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d393:	8b 1d b0 c1 b3 00    	mov    0xb3c1b0,%ebx
  80d399:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d39d:	89 04 24             	mov    %eax,(%esp)
  80d3a0:	e8 36 a5 ff ff       	call   8078db <ntohs>
  80d3a5:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d3a9:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80d3ae:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d3b2:	89 04 24             	mov    %eax,(%esp)
  80d3b5:	e8 21 a5 ff ff       	call   8078db <ntohs>
  80d3ba:	89 c1                	mov    %eax,%ecx
  80d3bc:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d3c0:	83 e0 3f             	and    $0x3f,%eax
  80d3c3:	a2 a0 c1 b3 00       	mov    %al,0xb3c1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d3c8:	83 c4 10             	add    $0x10,%esp
  80d3cb:	f6 c1 03             	test   $0x3,%cl
  80d3ce:	0f 95 c0             	setne  %al
  80d3d1:	0f b6 c0             	movzbl %al,%eax
  80d3d4:	66 03 46 08          	add    0x8(%esi),%ax
  80d3d8:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d3dc:	66 a3 9e c1 b3 00    	mov    %ax,0xb3c19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d3e2:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80d3e7:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d3ea:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d3f0:	8b 0d ac c1 b3 00    	mov    0xb3c1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d3f6:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d3f8:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d3fd:	e9 ab 00 00 00       	jmp    80d4ad <tcp_input+0x291>
    pbuf_free(p);
  80d402:	83 ec 0c             	sub    $0xc,%esp
  80d405:	56                   	push   %esi
  80d406:	e8 e9 75 ff ff       	call   8049f4 <pbuf_free>
    return;
  80d40b:	83 c4 10             	add    $0x10,%esp
  80d40e:	e9 74 fe ff ff       	jmp    80d287 <tcp_input+0x6b>
    pbuf_free(p);
  80d413:	83 ec 0c             	sub    $0xc,%esp
  80d416:	56                   	push   %esi
  80d417:	e8 d8 75 ff ff       	call   8049f4 <pbuf_free>
    return;
  80d41c:	83 c4 10             	add    $0x10,%esp
  80d41f:	e9 63 fe ff ff       	jmp    80d287 <tcp_input+0x6b>
    pbuf_free(p);
  80d424:	83 ec 0c             	sub    $0xc,%esp
  80d427:	56                   	push   %esi
  80d428:	e8 c7 75 ff ff       	call   8049f4 <pbuf_free>
    return;
  80d42d:	83 c4 10             	add    $0x10,%esp
  80d430:	e9 52 fe ff ff       	jmp    80d287 <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d435:	83 ec 04             	sub    $0x4,%esp
  80d438:	68 50 37 81 00       	push   $0x813750
  80d43d:	68 b5 00 00 00       	push   $0xb5
  80d442:	68 74 38 81 00       	push   $0x813874
  80d447:	e8 bd 13 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d44c:	83 ec 04             	sub    $0x4,%esp
  80d44f:	68 78 37 81 00       	push   $0x813778
  80d454:	68 b6 00 00 00       	push   $0xb6
  80d459:	68 74 38 81 00       	push   $0x813874
  80d45e:	e8 a6 13 00 00       	call   80e809 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d463:	83 ec 04             	sub    $0x4,%esp
  80d466:	68 a4 37 81 00       	push   $0x8137a4
  80d46b:	68 b7 00 00 00       	push   $0xb7
  80d470:	68 74 38 81 00       	push   $0x813874
  80d475:	e8 8f 13 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d47a:	83 ec 04             	sub    $0x4,%esp
  80d47d:	68 cc 37 81 00       	push   $0x8137cc
  80d482:	68 c0 00 00 00       	push   $0xc0
  80d487:	68 74 38 81 00       	push   $0x813874
  80d48c:	e8 78 13 00 00       	call   80e809 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d491:	83 ec 04             	sub    $0x4,%esp
  80d494:	68 f8 37 81 00       	push   $0x8137f8
  80d499:	68 c6 00 00 00       	push   $0xc6
  80d49e:	68 74 38 81 00       	push   $0x813874
  80d4a3:	e8 61 13 00 00       	call   80e809 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d4a8:	89 df                	mov    %ebx,%edi
  80d4aa:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d4ad:	85 db                	test   %ebx,%ebx
  80d4af:	0f 84 b3 0a 00 00    	je     80df68 <tcp_input+0xd4c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d4b5:	8b 43 10             	mov    0x10(%ebx),%eax
  80d4b8:	85 c0                	test   %eax,%eax
  80d4ba:	0f 84 75 ff ff ff    	je     80d435 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d4c0:	83 f8 0a             	cmp    $0xa,%eax
  80d4c3:	74 87                	je     80d44c <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d4c5:	83 f8 01             	cmp    $0x1,%eax
  80d4c8:	74 99                	je     80d463 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d4ca:	0f b7 02             	movzwl (%edx),%eax
  80d4cd:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d4d1:	75 d5                	jne    80d4a8 <tcp_input+0x28c>
  80d4d3:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d4d7:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d4db:	75 cb                	jne    80d4a8 <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d4dd:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d4e0:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d4e3:	75 c3                	jne    80d4a8 <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d4e5:	8b 41 10             	mov    0x10(%ecx),%eax
  80d4e8:	39 03                	cmp    %eax,(%ebx)
  80d4ea:	75 bc                	jne    80d4a8 <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d4ec:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d4ef:	39 c3                	cmp    %eax,%ebx
  80d4f1:	74 87                	je     80d47a <tcp_input+0x25e>
      if (prev != NULL) {
  80d4f3:	85 ff                	test   %edi,%edi
  80d4f5:	74 13                	je     80d50a <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d4f7:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d4fa:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d4fd:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d500:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d506:	39 c3                	cmp    %eax,%ebx
  80d508:	74 87                	je     80d491 <tcp_input+0x275>
    inseg.next = NULL;
  80d50a:	c7 05 b4 c1 b3 00 00 	movl   $0x0,0xb3c1b4
  80d511:	00 00 00 
    inseg.len = p->tot_len;
  80d514:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d518:	66 a3 c0 c1 b3 00    	mov    %ax,0xb3c1c0
    inseg.dataptr = p->payload;
  80d51e:	8b 46 04             	mov    0x4(%esi),%eax
  80d521:	a3 bc c1 b3 00       	mov    %eax,0xb3c1bc
    inseg.p = p;
  80d526:	89 35 b8 c1 b3 00    	mov    %esi,0xb3c1b8
    inseg.tcphdr = tcphdr;
  80d52c:	89 15 c4 c1 b3 00    	mov    %edx,0xb3c1c4
    recv_data = NULL;
  80d532:	c7 05 98 c1 b3 00 00 	movl   $0x0,0xb3c198
  80d539:	00 00 00 
    recv_flags = 0;
  80d53c:	c6 05 9c c1 b3 00 00 	movb   $0x0,0xb3c19c
    if (pcb->refused_data != NULL) {
  80d543:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d549:	85 c0                	test   %eax,%eax
  80d54b:	74 2c                	je     80d579 <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d54d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d553:	85 d2                	test   %edx,%edx
  80d555:	0f 84 07 03 00 00    	je     80d862 <tcp_input+0x646>
  80d55b:	6a 00                	push   $0x0
  80d55d:	50                   	push   %eax
  80d55e:	53                   	push   %ebx
  80d55f:	ff 73 18             	pushl  0x18(%ebx)
  80d562:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d564:	83 c4 10             	add    $0x10,%esp
  80d567:	84 c0                	test   %al,%al
  80d569:	0f 85 04 03 00 00    	jne    80d873 <tcp_input+0x657>
        pcb->refused_data = NULL;
  80d56f:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d576:	00 00 00 
    tcp_input_pcb = pcb;
  80d579:	89 1d 58 c2 b3 00    	mov    %ebx,0xb3c258
  if (flags & TCP_RST) {
  80d57f:	0f b6 05 a0 c1 b3 00 	movzbl 0xb3c1a0,%eax
  80d586:	a8 04                	test   $0x4,%al
  80d588:	0f 84 20 03 00 00    	je     80d8ae <tcp_input+0x692>
    if (pcb->state == SYN_SENT) {
  80d58e:	8b 53 10             	mov    0x10(%ebx),%edx
  80d591:	83 fa 02             	cmp    $0x2,%edx
  80d594:	0f 84 ea 02 00 00    	je     80d884 <tcp_input+0x668>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d59a:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d59f:	2b 43 24             	sub    0x24(%ebx),%eax
  80d5a2:	78 1d                	js     80d5c1 <tcp_input+0x3a5>
  80d5a4:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d5a8:	29 c8                	sub    %ecx,%eax
  80d5aa:	85 c0                	test   %eax,%eax
  80d5ac:	7f 13                	jg     80d5c1 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d5ae:	85 d2                	test   %edx,%edx
  80d5b0:	0f 84 e1 02 00 00    	je     80d897 <tcp_input+0x67b>
      recv_flags = TF_RESET;
  80d5b6:	c6 05 9c c1 b3 00 08 	movb   $0x8,0xb3c19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d5bd:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d5c1:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80d5c8:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d5cb:	0f b6 05 9c c1 b3 00 	movzbl 0xb3c19c,%eax
  80d5d2:	a8 08                	test   $0x8,%al
  80d5d4:	0f 84 37 08 00 00    	je     80de11 <tcp_input+0xbf5>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d5da:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d5e0:	85 c0                	test   %eax,%eax
  80d5e2:	74 0d                	je     80d5f1 <tcp_input+0x3d5>
  80d5e4:	83 ec 08             	sub    $0x8,%esp
  80d5e7:	6a fa                	push   $0xfffffffa
  80d5e9:	ff 73 18             	pushl  0x18(%ebx)
  80d5ec:	ff d0                	call   *%eax
  80d5ee:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d5f1:	83 ec 08             	sub    $0x8,%esp
  80d5f4:	53                   	push   %ebx
  80d5f5:	68 3c c2 b3 00       	push   $0xb3c23c
  80d5fa:	e8 a5 84 ff ff       	call   805aa4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d5ff:	83 c4 08             	add    $0x8,%esp
  80d602:	53                   	push   %ebx
  80d603:	6a 02                	push   $0x2
  80d605:	e8 9d 70 ff ff       	call   8046a7 <memp_free>
  80d60a:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d60d:	a1 b8 c1 b3 00       	mov    0xb3c1b8,%eax
  80d612:	85 c0                	test   %eax,%eax
  80d614:	0f 84 6d fc ff ff    	je     80d287 <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d61a:	83 ec 0c             	sub    $0xc,%esp
  80d61d:	50                   	push   %eax
  80d61e:	e8 d1 73 ff ff       	call   8049f4 <pbuf_free>
      inseg.p = NULL;
  80d623:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80d62a:	00 00 00 
  80d62d:	83 c4 10             	add    $0x10,%esp
  80d630:	e9 52 fc ff ff       	jmp    80d287 <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d635:	83 ec 04             	sub    $0x4,%esp
  80d638:	68 24 38 81 00       	push   $0x813824
  80d63d:	68 d0 00 00 00       	push   $0xd0
  80d642:	68 74 38 81 00       	push   $0x813874
  80d647:	e8 bd 11 00 00       	call   80e809 <_panic>
    tcp_ack_now(pcb);
  80d64c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d650:	83 ec 0c             	sub    $0xc,%esp
  80d653:	53                   	push   %ebx
  80d654:	e8 d6 ab ff ff       	call   80822f <tcp_output>
  80d659:	83 c4 10             	add    $0x10,%esp
  80d65c:	eb 4c                	jmp    80d6aa <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d65e:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d661:	85 db                	test   %ebx,%ebx
  80d663:	74 5e                	je     80d6c3 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d665:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d669:	75 ca                	jne    80d635 <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d66b:	0f b7 02             	movzwl (%edx),%eax
  80d66e:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d672:	75 ea                	jne    80d65e <tcp_input+0x442>
  80d674:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d678:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d67c:	75 e0                	jne    80d65e <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d67e:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d681:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d684:	75 d8                	jne    80d65e <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d686:	8b 41 10             	mov    0x10(%ecx),%eax
  80d689:	39 03                	cmp    %eax,(%ebx)
  80d68b:	75 d1                	jne    80d65e <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d68d:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d691:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d697:	89 c2                	mov    %eax,%edx
  80d699:	2b 53 24             	sub    0x24(%ebx),%edx
  80d69c:	85 d2                	test   %edx,%edx
  80d69e:	7e 03                	jle    80d6a3 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d6a0:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d6a3:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d6a8:	75 a2                	jne    80d64c <tcp_input+0x430>
  return tcp_output(pcb);
  80d6aa:	83 ec 0c             	sub    $0xc,%esp
  80d6ad:	53                   	push   %ebx
  80d6ae:	e8 7c ab ff ff       	call   80822f <tcp_output>
        pbuf_free(p);
  80d6b3:	89 34 24             	mov    %esi,(%esp)
  80d6b6:	e8 39 73 ff ff       	call   8049f4 <pbuf_free>
        return;
  80d6bb:	83 c4 10             	add    $0x10,%esp
  80d6be:	e9 c4 fb ff ff       	jmp    80d287 <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d6c3:	a1 44 c2 b3 00       	mov    0xb3c244,%eax
  80d6c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d6cb:	89 c7                	mov    %eax,%edi
  80d6cd:	eb 0f                	jmp    80d6de <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d6cf:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d6d3:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d6d7:	74 1a                	je     80d6f3 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d6d9:	89 fb                	mov    %edi,%ebx
  80d6db:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d6de:	85 ff                	test   %edi,%edi
  80d6e0:	0f 84 5d 08 00 00    	je     80df43 <tcp_input+0xd27>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d6e6:	8b 07                	mov    (%edi),%eax
  80d6e8:	85 c0                	test   %eax,%eax
  80d6ea:	74 e3                	je     80d6cf <tcp_input+0x4b3>
  80d6ec:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d6ef:	75 e8                	jne    80d6d9 <tcp_input+0x4bd>
  80d6f1:	eb dc                	jmp    80d6cf <tcp_input+0x4b3>
        if (prev != NULL) {
  80d6f3:	85 db                	test   %ebx,%ebx
  80d6f5:	74 12                	je     80d709 <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d6f7:	8b 47 0c             	mov    0xc(%edi),%eax
  80d6fa:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d6fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d700:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d703:	89 3d 44 c2 b3 00    	mov    %edi,0xb3c244
  if (flags & TCP_ACK) {
  80d709:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d70d:	75 17                	jne    80d726 <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d70f:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d713:	75 43                	jne    80d758 <tcp_input+0x53c>
        pbuf_free(p);
  80d715:	83 ec 0c             	sub    $0xc,%esp
  80d718:	56                   	push   %esi
  80d719:	e8 d6 72 ff ff       	call   8049f4 <pbuf_free>
        return;
  80d71e:	83 c4 10             	add    $0x10,%esp
  80d721:	e9 61 fb ff ff       	jmp    80d287 <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d726:	83 ec 08             	sub    $0x8,%esp
  80d729:	0f b7 02             	movzwl (%edx),%eax
  80d72c:	50                   	push   %eax
  80d72d:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d731:	50                   	push   %eax
  80d732:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d735:	50                   	push   %eax
  80d736:	83 c1 10             	add    $0x10,%ecx
  80d739:	51                   	push   %ecx
  80d73a:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d73e:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d744:	50                   	push   %eax
  80d745:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80d74a:	83 c0 01             	add    $0x1,%eax
  80d74d:	50                   	push   %eax
  80d74e:	e8 7c af ff ff       	call   8086cf <tcp_rst>
  80d753:	83 c4 20             	add    $0x20,%esp
  80d756:	eb bd                	jmp    80d715 <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d758:	83 ec 0c             	sub    $0xc,%esp
  80d75b:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d75f:	50                   	push   %eax
  80d760:	e8 9d 8b ff ff       	call   806302 <tcp_alloc>
  80d765:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d767:	83 c4 10             	add    $0x10,%esp
  80d76a:	85 c0                	test   %eax,%eax
  80d76c:	74 a7                	je     80d715 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d76e:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d773:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d776:	0f 84 c5 00 00 00    	je     80d841 <tcp_input+0x625>
  80d77c:	8b 50 10             	mov    0x10(%eax),%edx
  80d77f:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d781:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d785:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d789:	8b 50 0c             	mov    0xc(%eax),%edx
  80d78c:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d78f:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
  80d795:	0f b7 02             	movzwl (%edx),%eax
  80d798:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d79c:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d7a3:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d7a8:	8d 48 01             	lea    0x1(%eax),%ecx
  80d7ab:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d7ae:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d7b2:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d7b6:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d7ba:	83 e8 01             	sub    $0x1,%eax
  80d7bd:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d7c0:	8b 47 18             	mov    0x18(%edi),%eax
  80d7c3:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d7c6:	8b 47 20             	mov    0x20(%edi),%eax
  80d7c9:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d7cf:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d7d3:	66 25 99 01          	and    $0x199,%ax
  80d7d7:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d7db:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80d7e0:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d7e3:	89 1d 3c c2 b3 00    	mov    %ebx,0xb3c23c
  80d7e9:	e8 dc 4b ff ff       	call   8023ca <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d7ee:	89 d8                	mov    %ebx,%eax
  80d7f0:	e8 98 ec ff ff       	call   80c48d <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d7f5:	83 ec 08             	sub    $0x8,%esp
  80d7f8:	8d 43 04             	lea    0x4(%ebx),%eax
  80d7fb:	50                   	push   %eax
  80d7fc:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d800:	50                   	push   %eax
  80d801:	e8 9a 8c ff ff       	call   8064a0 <tcp_eff_send_mss>
  80d806:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d80a:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d811:	e8 d2 a0 ff ff       	call   8078e8 <htonl>
  80d816:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d819:	83 c4 0c             	add    $0xc,%esp
  80d81c:	6a 04                	push   $0x4
  80d81e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d821:	50                   	push   %eax
  80d822:	6a 00                	push   $0x0
  80d824:	6a 12                	push   $0x12
  80d826:	6a 00                	push   $0x0
  80d828:	6a 00                	push   $0x0
  80d82a:	53                   	push   %ebx
  80d82b:	e8 e2 a2 ff ff       	call   807b12 <tcp_enqueue>
    return tcp_output(npcb);
  80d830:	83 c4 14             	add    $0x14,%esp
  80d833:	53                   	push   %ebx
  80d834:	e8 f6 a9 ff ff       	call   80822f <tcp_output>
  80d839:	83 c4 10             	add    $0x10,%esp
  80d83c:	e9 d4 fe ff ff       	jmp    80d715 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d841:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    npcb->local_port = pcb->local_port;
  80d847:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d84b:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d84f:	ba 00 00 00 00       	mov    $0x0,%edx
  80d854:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d857:	0f 84 2f ff ff ff    	je     80d78c <tcp_input+0x570>
  80d85d:	e9 27 ff ff ff       	jmp    80d789 <tcp_input+0x56d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d862:	83 ec 0c             	sub    $0xc,%esp
  80d865:	50                   	push   %eax
  80d866:	e8 89 71 ff ff       	call   8049f4 <pbuf_free>
  80d86b:	83 c4 10             	add    $0x10,%esp
  80d86e:	e9 fc fc ff ff       	jmp    80d56f <tcp_input+0x353>
        pbuf_free(p);
  80d873:	83 ec 0c             	sub    $0xc,%esp
  80d876:	56                   	push   %esi
  80d877:	e8 78 71 ff ff       	call   8049f4 <pbuf_free>
        return;
  80d87c:	83 c4 10             	add    $0x10,%esp
  80d87f:	e9 03 fa ff ff       	jmp    80d287 <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d884:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80d889:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d88c:	0f 84 24 fd ff ff    	je     80d5b6 <tcp_input+0x39a>
  80d892:	e9 2a fd ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d897:	83 ec 04             	sub    $0x4,%esp
  80d89a:	68 54 38 81 00       	push   $0x813854
  80d89f:	68 09 02 00 00       	push   $0x209
  80d8a4:	68 74 38 81 00       	push   $0x813874
  80d8a9:	e8 5b 0f 00 00       	call   80e809 <_panic>
  pcb->tmr = tcp_ticks;
  80d8ae:	8b 15 40 c2 b3 00    	mov    0xb3c240,%edx
  80d8b4:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d8b7:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d8be:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d8c2:	0f 87 3a 05 00 00    	ja     80de02 <tcp_input+0xbe6>
  80d8c8:	8b 53 10             	mov    0x10(%ebx),%edx
  80d8cb:	ff 24 95 f8 38 81 00 	jmp    *0x8138f8(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d8d2:	83 e0 12             	and    $0x12,%eax
  80d8d5:	3c 12                	cmp    $0x12,%al
  80d8d7:	74 4d                	je     80d926 <tcp_input+0x70a>
    else if (flags & TCP_ACK) {
  80d8d9:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80d8e0:	0f 84 db fc ff ff    	je     80d5c1 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d8e6:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d8ec:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80d8f1:	83 ec 08             	sub    $0x8,%esp
  80d8f4:	0f b7 0a             	movzwl (%edx),%ecx
  80d8f7:	51                   	push   %ecx
  80d8f8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d8fc:	52                   	push   %edx
  80d8fd:	8d 50 0c             	lea    0xc(%eax),%edx
  80d900:	52                   	push   %edx
  80d901:	83 c0 10             	add    $0x10,%eax
  80d904:	50                   	push   %eax
  80d905:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80d90c:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80d912:	50                   	push   %eax
  80d913:	ff 35 a4 c1 b3 00    	pushl  0xb3c1a4
  80d919:	e8 b1 ad ff ff       	call   8086cf <tcp_rst>
  80d91e:	83 c4 20             	add    $0x20,%esp
  80d921:	e9 9b fc ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d926:	83 ec 0c             	sub    $0xc,%esp
  80d929:	8b 43 78             	mov    0x78(%ebx),%eax
  80d92c:	8b 40 10             	mov    0x10(%eax),%eax
  80d92f:	ff 70 04             	pushl  0x4(%eax)
  80d932:	e8 c8 a1 ff ff       	call   807aff <ntohl>
  80d937:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80d93d:	83 c0 01             	add    $0x1,%eax
  80d940:	83 c4 10             	add    $0x10,%esp
  80d943:	39 d0                	cmp    %edx,%eax
  80d945:	75 92                	jne    80d8d9 <tcp_input+0x6bd>
      pcb->snd_buf++;
  80d947:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d94c:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
  80d951:	8d 48 01             	lea    0x1(%eax),%ecx
  80d954:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d957:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d95a:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
  80d960:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d964:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d968:	83 e8 01             	sub    $0x1,%eax
  80d96b:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d96e:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d975:	89 d8                	mov    %ebx,%eax
  80d977:	e8 11 eb ff ff       	call   80c48d <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d97c:	83 ec 08             	sub    $0x8,%esp
  80d97f:	8d 43 04             	lea    0x4(%ebx),%eax
  80d982:	50                   	push   %eax
  80d983:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d987:	50                   	push   %eax
  80d988:	e8 13 8b ff ff       	call   8064a0 <tcp_eff_send_mss>
  80d98d:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d991:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d994:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d998:	83 c4 10             	add    $0x10,%esp
  80d99b:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d9a0:	74 63                	je     80da05 <tcp_input+0x7e9>
  80d9a2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d9a6:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d9aa:	66 85 c0             	test   %ax,%ax
  80d9ad:	74 5a                	je     80da09 <tcp_input+0x7ed>
      --pcb->snd_queuelen;
  80d9af:	83 e8 01             	sub    $0x1,%eax
  80d9b2:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d9b6:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d9b9:	8b 10                	mov    (%eax),%edx
  80d9bb:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d9be:	85 d2                	test   %edx,%edx
  80d9c0:	74 5e                	je     80da20 <tcp_input+0x804>
        pcb->rtime = 0;
  80d9c2:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d9c8:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d9cc:	83 ec 0c             	sub    $0xc,%esp
  80d9cf:	50                   	push   %eax
  80d9d0:	e8 39 7f ff ff       	call   80590e <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d9d5:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d9db:	83 c4 10             	add    $0x10,%esp
  80d9de:	85 c0                	test   %eax,%eax
  80d9e0:	74 0e                	je     80d9f0 <tcp_input+0x7d4>
  80d9e2:	83 ec 04             	sub    $0x4,%esp
  80d9e5:	6a 00                	push   $0x0
  80d9e7:	53                   	push   %ebx
  80d9e8:	ff 73 18             	pushl  0x18(%ebx)
  80d9eb:	ff d0                	call   *%eax
  80d9ed:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d9f0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9f4:	83 ec 0c             	sub    $0xc,%esp
  80d9f7:	53                   	push   %ebx
  80d9f8:	e8 32 a8 ff ff       	call   80822f <tcp_output>
  80d9fd:	83 c4 10             	add    $0x10,%esp
  80da00:	e9 bc fb ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80da05:	01 c0                	add    %eax,%eax
  80da07:	eb 99                	jmp    80d9a2 <tcp_input+0x786>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80da09:	83 ec 04             	sub    $0x4,%esp
  80da0c:	68 cd 38 81 00       	push   $0x8138cd
  80da11:	68 35 02 00 00       	push   $0x235
  80da16:	68 74 38 81 00       	push   $0x813874
  80da1b:	e8 e9 0d 00 00       	call   80e809 <_panic>
        pcb->rtime = -1;
  80da20:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80da26:	eb a4                	jmp    80d9cc <tcp_input+0x7b0>
    if (flags & TCP_ACK &&
  80da28:	83 e0 14             	and    $0x14,%eax
  80da2b:	3c 10                	cmp    $0x10,%al
  80da2d:	0f 85 8e fb ff ff    	jne    80d5c1 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80da33:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80da39:	8d 42 ff             	lea    -0x1(%edx),%eax
  80da3c:	3b 43 48             	cmp    0x48(%ebx),%eax
  80da3f:	78 09                	js     80da4a <tcp_input+0x82e>
  80da41:	89 d0                	mov    %edx,%eax
  80da43:	2b 43 54             	sub    0x54(%ebx),%eax
  80da46:	85 c0                	test   %eax,%eax
  80da48:	7e 3b                	jle    80da85 <tcp_input+0x869>
                tcphdr->dest, tcphdr->src);
  80da4a:	8b 0d b0 c1 b3 00    	mov    0xb3c1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80da50:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80da55:	83 ec 08             	sub    $0x8,%esp
  80da58:	0f b7 31             	movzwl (%ecx),%esi
  80da5b:	56                   	push   %esi
  80da5c:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80da60:	51                   	push   %ecx
  80da61:	8d 48 0c             	lea    0xc(%eax),%ecx
  80da64:	51                   	push   %ecx
  80da65:	83 c0 10             	add    $0x10,%eax
  80da68:	50                   	push   %eax
  80da69:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80da70:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80da76:	50                   	push   %eax
  80da77:	52                   	push   %edx
  80da78:	e8 52 ac ff ff       	call   8086cf <tcp_rst>
  80da7d:	83 c4 20             	add    $0x20,%esp
  80da80:	e9 3c fb ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80da85:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80da8c:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80da92:	85 c0                	test   %eax,%eax
  80da94:	74 5c                	je     80daf2 <tcp_input+0x8d6>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80da96:	83 ec 04             	sub    $0x4,%esp
  80da99:	6a 00                	push   $0x0
  80da9b:	53                   	push   %ebx
  80da9c:	ff 73 18             	pushl  0x18(%ebx)
  80da9f:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80daa1:	83 c4 10             	add    $0x10,%esp
  80daa4:	84 c0                	test   %al,%al
  80daa6:	75 61                	jne    80db09 <tcp_input+0x8ed>
        old_cwnd = pcb->cwnd;
  80daa8:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80daac:	89 d8                	mov    %ebx,%eax
  80daae:	e8 8e ea ff ff       	call   80c541 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80dab3:	66 83 fe 01          	cmp    $0x1,%si
  80dab7:	74 6b                	je     80db24 <tcp_input+0x908>
  80dab9:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80dabd:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80dac1:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80dac8:	0f 84 f3 fa ff ff    	je     80d5c1 <tcp_input+0x3a5>
  80dace:	84 c0                	test   %al,%al
  80dad0:	0f 84 eb fa ff ff    	je     80d5c1 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80dad6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dada:	83 ec 0c             	sub    $0xc,%esp
  80dadd:	53                   	push   %ebx
  80dade:	e8 4c a7 ff ff       	call   80822f <tcp_output>
          pcb->state = CLOSE_WAIT;
  80dae3:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80daea:	83 c4 10             	add    $0x10,%esp
  80daed:	e9 cf fa ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80daf2:	83 ec 04             	sub    $0x4,%esp
  80daf5:	68 e3 38 81 00       	push   $0x8138e3
  80dafa:	68 5b 02 00 00       	push   $0x25b
  80daff:	68 74 38 81 00       	push   $0x813874
  80db04:	e8 00 0d 00 00       	call   80e809 <_panic>
          tcp_abort(pcb);
  80db09:	83 ec 0c             	sub    $0xc,%esp
  80db0c:	53                   	push   %ebx
  80db0d:	e8 48 82 ff ff       	call   805d5a <tcp_abort>
    tcp_input_pcb = NULL;
  80db12:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80db19:	00 00 00 
  80db1c:	83 c4 10             	add    $0x10,%esp
  80db1f:	e9 e9 fa ff ff       	jmp    80d60d <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80db24:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80db28:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80db2b:	eb 90                	jmp    80dabd <tcp_input+0x8a1>
    accepted_inseq = tcp_receive(pcb);
  80db2d:	89 d8                	mov    %ebx,%eax
  80db2f:	e8 0d ea ff ff       	call   80c541 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80db34:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80db3b:	0f 84 80 fa ff ff    	je     80d5c1 <tcp_input+0x3a5>
  80db41:	84 c0                	test   %al,%al
  80db43:	0f 84 78 fa ff ff    	je     80d5c1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80db49:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db4d:	83 ec 0c             	sub    $0xc,%esp
  80db50:	53                   	push   %ebx
  80db51:	e8 d9 a6 ff ff       	call   80822f <tcp_output>
      pcb->state = CLOSE_WAIT;
  80db56:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80db5d:	83 c4 10             	add    $0x10,%esp
  80db60:	e9 5c fa ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80db65:	89 d8                	mov    %ebx,%eax
  80db67:	e8 d5 e9 ff ff       	call   80c541 <tcp_receive>
    if (flags & TCP_FIN) {
  80db6c:	0f b6 05 a0 c1 b3 00 	movzbl 0xb3c1a0,%eax
  80db73:	a8 01                	test   $0x1,%al
  80db75:	0f 84 c7 00 00 00    	je     80dc42 <tcp_input+0xa26>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80db7b:	a8 10                	test   $0x10,%al
  80db7d:	74 0a                	je     80db89 <tcp_input+0x96d>
  80db7f:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80db84:	39 43 54             	cmp    %eax,0x54(%ebx)
  80db87:	74 1c                	je     80dba5 <tcp_input+0x989>
        tcp_ack_now(pcb);
  80db89:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db8d:	83 ec 0c             	sub    $0xc,%esp
  80db90:	53                   	push   %ebx
  80db91:	e8 99 a6 ff ff       	call   80822f <tcp_output>
        pcb->state = CLOSING;
  80db96:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80db9d:	83 c4 10             	add    $0x10,%esp
  80dba0:	e9 1c fa ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80dba5:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dba9:	83 ec 0c             	sub    $0xc,%esp
  80dbac:	53                   	push   %ebx
  80dbad:	e8 7d a6 ff ff       	call   80822f <tcp_output>
        tcp_pcb_purge(pcb);
  80dbb2:	89 1c 24             	mov    %ebx,(%esp)
  80dbb5:	e8 6d 7e ff ff       	call   805a27 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dbba:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80dbbf:	83 c4 10             	add    $0x10,%esp
  80dbc2:	39 c3                	cmp    %eax,%ebx
  80dbc4:	74 2c                	je     80dbf2 <tcp_input+0x9d6>
  80dbc6:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80dbcb:	ba 00 00 00 00       	mov    $0x0,%edx
  80dbd0:	89 de                	mov    %ebx,%esi
  80dbd2:	89 d7                	mov    %edx,%edi
  80dbd4:	85 c0                	test   %eax,%eax
  80dbd6:	74 56                	je     80dc2e <tcp_input+0xa12>
  80dbd8:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dbdb:	39 ce                	cmp    %ecx,%esi
  80dbdd:	0f 94 c3             	sete   %bl
  80dbe0:	85 c9                	test   %ecx,%ecx
  80dbe2:	0f 95 c2             	setne  %dl
  80dbe5:	84 d3                	test   %dl,%bl
  80dbe7:	75 30                	jne    80dc19 <tcp_input+0x9fd>
  80dbe9:	bf 01 00 00 00       	mov    $0x1,%edi
  80dbee:	89 c8                	mov    %ecx,%eax
  80dbf0:	eb e2                	jmp    80dbd4 <tcp_input+0x9b8>
  80dbf2:	8b 40 0c             	mov    0xc(%eax),%eax
  80dbf5:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
        pcb->state = TIME_WAIT;
  80dbfa:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80dc01:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80dc06:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dc09:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80dc0f:	e8 b6 47 ff ff       	call   8023ca <tcp_timer_needed>
  80dc14:	e9 a8 f9 ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
  80dc19:	89 f3                	mov    %esi,%ebx
  80dc1b:	89 fa                	mov    %edi,%edx
  80dc1d:	84 d2                	test   %dl,%dl
  80dc1f:	74 05                	je     80dc26 <tcp_input+0xa0a>
  80dc21:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dc26:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dc29:	89 50 0c             	mov    %edx,0xc(%eax)
  80dc2c:	eb cc                	jmp    80dbfa <tcp_input+0x9de>
  80dc2e:	89 f3                	mov    %esi,%ebx
  80dc30:	89 fa                	mov    %edi,%edx
  80dc32:	84 d2                	test   %dl,%dl
  80dc34:	74 c4                	je     80dbfa <tcp_input+0x9de>
  80dc36:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80dc3d:	00 00 00 
  80dc40:	eb b8                	jmp    80dbfa <tcp_input+0x9de>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dc42:	a8 10                	test   $0x10,%al
  80dc44:	0f 84 77 f9 ff ff    	je     80d5c1 <tcp_input+0x3a5>
  80dc4a:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dc4f:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dc52:	0f 85 69 f9 ff ff    	jne    80d5c1 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80dc58:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80dc5f:	e9 5d f9 ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80dc64:	89 d8                	mov    %ebx,%eax
  80dc66:	e8 d6 e8 ff ff       	call   80c541 <tcp_receive>
    if (flags & TCP_FIN) {
  80dc6b:	f6 05 a0 c1 b3 00 01 	testb  $0x1,0xb3c1a0
  80dc72:	0f 84 49 f9 ff ff    	je     80d5c1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dc78:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dc7c:	83 ec 0c             	sub    $0xc,%esp
  80dc7f:	53                   	push   %ebx
  80dc80:	e8 aa a5 ff ff       	call   80822f <tcp_output>
      tcp_pcb_purge(pcb);
  80dc85:	89 1c 24             	mov    %ebx,(%esp)
  80dc88:	e8 9a 7d ff ff       	call   805a27 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dc8d:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80dc92:	83 c4 10             	add    $0x10,%esp
  80dc95:	39 c3                	cmp    %eax,%ebx
  80dc97:	74 2c                	je     80dcc5 <tcp_input+0xaa9>
  80dc99:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80dc9e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80dca3:	89 de                	mov    %ebx,%esi
  80dca5:	89 cf                	mov    %ecx,%edi
  80dca7:	85 c0                	test   %eax,%eax
  80dca9:	74 56                	je     80dd01 <tcp_input+0xae5>
  80dcab:	8b 50 0c             	mov    0xc(%eax),%edx
  80dcae:	85 d2                	test   %edx,%edx
  80dcb0:	0f 95 c3             	setne  %bl
  80dcb3:	39 d6                	cmp    %edx,%esi
  80dcb5:	0f 94 c1             	sete   %cl
  80dcb8:	84 cb                	test   %cl,%bl
  80dcba:	75 30                	jne    80dcec <tcp_input+0xad0>
  80dcbc:	bf 01 00 00 00       	mov    $0x1,%edi
  80dcc1:	89 d0                	mov    %edx,%eax
  80dcc3:	eb e2                	jmp    80dca7 <tcp_input+0xa8b>
  80dcc5:	8b 40 0c             	mov    0xc(%eax),%eax
  80dcc8:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
      pcb->state = TIME_WAIT;
  80dccd:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dcd4:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80dcd9:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dcdc:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80dce2:	e8 e3 46 ff ff       	call   8023ca <tcp_timer_needed>
  80dce7:	e9 d5 f8 ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
  80dcec:	89 f3                	mov    %esi,%ebx
  80dcee:	89 f9                	mov    %edi,%ecx
  80dcf0:	84 c9                	test   %cl,%cl
  80dcf2:	74 05                	je     80dcf9 <tcp_input+0xadd>
  80dcf4:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dcf9:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dcfc:	89 50 0c             	mov    %edx,0xc(%eax)
  80dcff:	eb cc                	jmp    80dccd <tcp_input+0xab1>
  80dd01:	89 f3                	mov    %esi,%ebx
  80dd03:	89 f9                	mov    %edi,%ecx
  80dd05:	84 c9                	test   %cl,%cl
  80dd07:	74 c4                	je     80dccd <tcp_input+0xab1>
  80dd09:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80dd10:	00 00 00 
  80dd13:	eb b8                	jmp    80dccd <tcp_input+0xab1>
    tcp_receive(pcb);
  80dd15:	89 d8                	mov    %ebx,%eax
  80dd17:	e8 25 e8 ff ff       	call   80c541 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dd1c:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80dd23:	0f 84 98 f8 ff ff    	je     80d5c1 <tcp_input+0x3a5>
  80dd29:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dd2e:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dd31:	0f 85 8a f8 ff ff    	jne    80d5c1 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dd37:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dd3b:	83 ec 0c             	sub    $0xc,%esp
  80dd3e:	53                   	push   %ebx
  80dd3f:	e8 eb a4 ff ff       	call   80822f <tcp_output>
      tcp_pcb_purge(pcb);
  80dd44:	89 1c 24             	mov    %ebx,(%esp)
  80dd47:	e8 db 7c ff ff       	call   805a27 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dd4c:	a1 3c c2 b3 00       	mov    0xb3c23c,%eax
  80dd51:	83 c4 10             	add    $0x10,%esp
  80dd54:	39 c3                	cmp    %eax,%ebx
  80dd56:	74 2c                	je     80dd84 <tcp_input+0xb68>
  80dd58:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
  80dd5d:	ba 00 00 00 00       	mov    $0x0,%edx
  80dd62:	89 de                	mov    %ebx,%esi
  80dd64:	89 d7                	mov    %edx,%edi
  80dd66:	85 c0                	test   %eax,%eax
  80dd68:	74 56                	je     80ddc0 <tcp_input+0xba4>
  80dd6a:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dd6d:	85 c9                	test   %ecx,%ecx
  80dd6f:	0f 95 c3             	setne  %bl
  80dd72:	39 ce                	cmp    %ecx,%esi
  80dd74:	0f 94 c2             	sete   %dl
  80dd77:	84 d3                	test   %dl,%bl
  80dd79:	75 30                	jne    80ddab <tcp_input+0xb8f>
  80dd7b:	bf 01 00 00 00       	mov    $0x1,%edi
  80dd80:	89 c8                	mov    %ecx,%eax
  80dd82:	eb e2                	jmp    80dd66 <tcp_input+0xb4a>
  80dd84:	8b 40 0c             	mov    0xc(%eax),%eax
  80dd87:	a3 3c c2 b3 00       	mov    %eax,0xb3c23c
      pcb->state = TIME_WAIT;
  80dd8c:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dd93:	a1 50 c2 b3 00       	mov    0xb3c250,%eax
  80dd98:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dd9b:	89 1d 50 c2 b3 00    	mov    %ebx,0xb3c250
  80dda1:	e8 24 46 ff ff       	call   8023ca <tcp_timer_needed>
  80dda6:	e9 16 f8 ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
  80ddab:	89 f3                	mov    %esi,%ebx
  80ddad:	89 fa                	mov    %edi,%edx
  80ddaf:	84 d2                	test   %dl,%dl
  80ddb1:	74 05                	je     80ddb8 <tcp_input+0xb9c>
  80ddb3:	a3 48 c2 b3 00       	mov    %eax,0xb3c248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80ddb8:	8b 53 0c             	mov    0xc(%ebx),%edx
  80ddbb:	89 50 0c             	mov    %edx,0xc(%eax)
  80ddbe:	eb cc                	jmp    80dd8c <tcp_input+0xb70>
  80ddc0:	89 f3                	mov    %esi,%ebx
  80ddc2:	89 fa                	mov    %edi,%edx
  80ddc4:	84 d2                	test   %dl,%dl
  80ddc6:	74 c4                	je     80dd8c <tcp_input+0xb70>
  80ddc8:	c7 05 48 c2 b3 00 00 	movl   $0x0,0xb3c248
  80ddcf:	00 00 00 
  80ddd2:	eb b8                	jmp    80dd8c <tcp_input+0xb70>
    tcp_receive(pcb);
  80ddd4:	89 d8                	mov    %ebx,%eax
  80ddd6:	e8 66 e7 ff ff       	call   80c541 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dddb:	f6 05 a0 c1 b3 00 10 	testb  $0x10,0xb3c1a0
  80dde2:	0f 84 d9 f7 ff ff    	je     80d5c1 <tcp_input+0x3a5>
  80dde8:	a1 a4 c1 b3 00       	mov    0xb3c1a4,%eax
  80dded:	39 43 54             	cmp    %eax,0x54(%ebx)
  80ddf0:	0f 85 cb f7 ff ff    	jne    80d5c1 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80ddf6:	c6 05 9c c1 b3 00 10 	movb   $0x10,0xb3c19c
  80ddfd:	e9 bf f7 ff ff       	jmp    80d5c1 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80de02:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  80de09:	00 00 00 
  80de0c:	e9 ba f7 ff ff       	jmp    80d5cb <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80de11:	a8 10                	test   $0x10,%al
  80de13:	0f 85 96 00 00 00    	jne    80deaf <tcp_input+0xc93>
        if (pcb->acked > 0) {
  80de19:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80de1d:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80de22:	66 85 d2             	test   %dx,%dx
  80de25:	74 1a                	je     80de41 <tcp_input+0xc25>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80de27:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80de2d:	85 c9                	test   %ecx,%ecx
  80de2f:	74 10                	je     80de41 <tcp_input+0xc25>
  80de31:	83 ec 04             	sub    $0x4,%esp
  80de34:	0f b7 d2             	movzwl %dx,%edx
  80de37:	52                   	push   %edx
  80de38:	53                   	push   %ebx
  80de39:	ff 73 18             	pushl  0x18(%ebx)
  80de3c:	ff d1                	call   *%ecx
  80de3e:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80de41:	8b 15 98 c1 b3 00    	mov    0xb3c198,%edx
  80de47:	85 d2                	test   %edx,%edx
  80de49:	0f 84 a9 00 00 00    	je     80def8 <tcp_input+0xcdc>
          if(flags & TCP_PSH) {
  80de4f:	f6 05 a0 c1 b3 00 08 	testb  $0x8,0xb3c1a0
  80de56:	74 04                	je     80de5c <tcp_input+0xc40>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80de58:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80de5c:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80de62:	85 c0                	test   %eax,%eax
  80de64:	74 6a                	je     80ded0 <tcp_input+0xcb4>
  80de66:	6a 00                	push   $0x0
  80de68:	52                   	push   %edx
  80de69:	53                   	push   %ebx
  80de6a:	ff 73 18             	pushl  0x18(%ebx)
  80de6d:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80de6f:	83 c4 10             	add    $0x10,%esp
  80de72:	84 c0                	test   %al,%al
  80de74:	75 68                	jne    80dede <tcp_input+0xcc2>
        if (recv_flags & TF_GOT_FIN) {
  80de76:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80de7d:	74 1f                	je     80de9e <tcp_input+0xc82>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80de7f:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80de85:	85 c0                	test   %eax,%eax
  80de87:	74 15                	je     80de9e <tcp_input+0xc82>
  80de89:	6a 00                	push   $0x0
  80de8b:	6a 00                	push   $0x0
  80de8d:	53                   	push   %ebx
  80de8e:	ff 73 18             	pushl  0x18(%ebx)
  80de91:	ff d0                	call   *%eax
  80de93:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80de96:	84 c0                	test   %al,%al
  80de98:	0f 85 6f f7 ff ff    	jne    80d60d <tcp_input+0x3f1>
          tcp_output(pcb);
  80de9e:	83 ec 0c             	sub    $0xc,%esp
  80dea1:	53                   	push   %ebx
  80dea2:	e8 88 a3 ff ff       	call   80822f <tcp_output>
  80dea7:	83 c4 10             	add    $0x10,%esp
  80deaa:	e9 5e f7 ff ff       	jmp    80d60d <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80deaf:	83 ec 08             	sub    $0x8,%esp
  80deb2:	53                   	push   %ebx
  80deb3:	68 3c c2 b3 00       	push   $0xb3c23c
  80deb8:	e8 e7 7b ff ff       	call   805aa4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80debd:	83 c4 08             	add    $0x8,%esp
  80dec0:	53                   	push   %ebx
  80dec1:	6a 02                	push   $0x2
  80dec3:	e8 df 67 ff ff       	call   8046a7 <memp_free>
  80dec8:	83 c4 10             	add    $0x10,%esp
  80decb:	e9 3d f7 ff ff       	jmp    80d60d <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80ded0:	83 ec 0c             	sub    $0xc,%esp
  80ded3:	52                   	push   %edx
  80ded4:	e8 1b 6b ff ff       	call   8049f4 <pbuf_free>
  80ded9:	83 c4 10             	add    $0x10,%esp
  80dedc:	eb 98                	jmp    80de76 <tcp_input+0xc5a>
            pcb->refused_data = recv_data;
  80dede:	a1 98 c1 b3 00       	mov    0xb3c198,%eax
  80dee3:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dee9:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80def0:	0f 84 17 f7 ff ff    	je     80d60d <tcp_input+0x3f1>
  80def6:	eb 87                	jmp    80de7f <tcp_input+0xc63>
  80def8:	f6 05 9c c1 b3 00 20 	testb  $0x20,0xb3c19c
  80deff:	74 95                	je     80de96 <tcp_input+0xc7a>
  80df01:	e9 79 ff ff ff       	jmp    80de7f <tcp_input+0xc63>
        tcphdr->dest, tcphdr->src);
  80df06:	8b 15 b0 c1 b3 00    	mov    0xb3c1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80df0c:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80df11:	83 ec 08             	sub    $0x8,%esp
  80df14:	0f b7 0a             	movzwl (%edx),%ecx
  80df17:	51                   	push   %ecx
  80df18:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80df1c:	52                   	push   %edx
  80df1d:	8d 50 0c             	lea    0xc(%eax),%edx
  80df20:	52                   	push   %edx
  80df21:	83 c0 10             	add    $0x10,%eax
  80df24:	50                   	push   %eax
  80df25:	0f b7 05 9e c1 b3 00 	movzwl 0xb3c19e,%eax
  80df2c:	03 05 a8 c1 b3 00    	add    0xb3c1a8,%eax
  80df32:	50                   	push   %eax
  80df33:	ff 35 a4 c1 b3 00    	pushl  0xb3c1a4
  80df39:	e8 91 a7 ff ff       	call   8086cf <tcp_rst>
  80df3e:	83 c4 20             	add    $0x20,%esp
  80df41:	eb 14                	jmp    80df57 <tcp_input+0xd3b>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80df43:	83 ec 0c             	sub    $0xc,%esp
  80df46:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80df4a:	50                   	push   %eax
  80df4b:	e8 8b 99 ff ff       	call   8078db <ntohs>
  80df50:	83 c4 10             	add    $0x10,%esp
  80df53:	a8 04                	test   $0x4,%al
  80df55:	74 af                	je     80df06 <tcp_input+0xcea>
    pbuf_free(p);
  80df57:	83 ec 0c             	sub    $0xc,%esp
  80df5a:	56                   	push   %esi
  80df5b:	e8 94 6a ff ff       	call   8049f4 <pbuf_free>
  80df60:	83 c4 10             	add    $0x10,%esp
  80df63:	e9 1f f3 ff ff       	jmp    80d287 <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80df68:	8b 1d 50 c2 b3 00    	mov    0xb3c250,%ebx
  80df6e:	e9 ee f6 ff ff       	jmp    80d661 <tcp_input+0x445>

0080df73 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80df73:	55                   	push   %ebp
  80df74:	89 e5                	mov    %esp,%ebp
  80df76:	57                   	push   %edi
  80df77:	56                   	push   %esi
  80df78:	53                   	push   %ebx
  80df79:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80df7c:	8b 45 08             	mov    0x8(%ebp),%eax
  80df7f:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80df82:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80df86:	50                   	push   %eax
  80df87:	e8 4f 99 ff ff       	call   8078db <ntohs>
  80df8c:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80df8e:	8b 1d c8 c1 b3 00    	mov    0xb3c1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80df94:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80df97:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80df9c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80dfa3:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80dfa6:	eb 11                	jmp    80dfb9 <raw_input+0x46>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80dfa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dfab:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80dfae:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80dfb3:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80dfb6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80dfb9:	84 c0                	test   %al,%al
  80dfbb:	75 55                	jne    80e012 <raw_input+0x9f>
  80dfbd:	85 db                	test   %ebx,%ebx
  80dfbf:	74 51                	je     80e012 <raw_input+0x9f>
    if (pcb->protocol == proto) {
  80dfc1:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80dfc5:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfca:	39 f2                	cmp    %esi,%edx
  80dfcc:	75 e5                	jne    80dfb3 <raw_input+0x40>
      if (pcb->recv != NULL) {
  80dfce:	8b 53 14             	mov    0x14(%ebx),%edx
  80dfd1:	85 d2                	test   %edx,%edx
  80dfd3:	74 de                	je     80dfb3 <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80dfd5:	8d 47 0c             	lea    0xc(%edi),%eax
  80dfd8:	50                   	push   %eax
  80dfd9:	ff 75 08             	pushl  0x8(%ebp)
  80dfdc:	53                   	push   %ebx
  80dfdd:	ff 73 18             	pushl  0x18(%ebx)
  80dfe0:	ff d2                	call   *%edx
  80dfe2:	83 c4 10             	add    $0x10,%esp
  80dfe5:	84 c0                	test   %al,%al
  80dfe7:	74 ca                	je     80dfb3 <raw_input+0x40>
          if (prev != NULL) {
  80dfe9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80dfec:	85 c9                	test   %ecx,%ecx
  80dfee:	74 b8                	je     80dfa8 <raw_input+0x35>
            prev->next = pcb->next;
  80dff0:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dff3:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80dff6:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dffb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80dffe:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
          eaten = 1;
  80e004:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80e009:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e010:	eb a1                	jmp    80dfb3 <raw_input+0x40>
  }
  return eaten;
}
  80e012:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e015:	5b                   	pop    %ebx
  80e016:	5e                   	pop    %esi
  80e017:	5f                   	pop    %edi
  80e018:	5d                   	pop    %ebp
  80e019:	c3                   	ret    

0080e01a <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e01a:	55                   	push   %ebp
  80e01b:	89 e5                	mov    %esp,%ebp
  80e01d:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e020:	b8 00 00 00 00       	mov    $0x0,%eax
  80e025:	85 d2                	test   %edx,%edx
  80e027:	74 02                	je     80e02b <raw_bind+0x11>
  80e029:	8b 02                	mov    (%edx),%eax
  80e02b:	8b 55 08             	mov    0x8(%ebp),%edx
  80e02e:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80e030:	b8 00 00 00 00       	mov    $0x0,%eax
  80e035:	5d                   	pop    %ebp
  80e036:	c3                   	ret    

0080e037 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e037:	55                   	push   %ebp
  80e038:	89 e5                	mov    %esp,%ebp
  80e03a:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e03d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e042:	85 d2                	test   %edx,%edx
  80e044:	74 02                	je     80e048 <raw_connect+0x11>
  80e046:	8b 02                	mov    (%edx),%eax
  80e048:	8b 55 08             	mov    0x8(%ebp),%edx
  80e04b:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80e04e:	b8 00 00 00 00       	mov    $0x0,%eax
  80e053:	5d                   	pop    %ebp
  80e054:	c3                   	ret    

0080e055 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e055:	55                   	push   %ebp
  80e056:	89 e5                	mov    %esp,%ebp
  80e058:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e05b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e05e:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e061:	8b 55 10             	mov    0x10(%ebp),%edx
  80e064:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e067:	5d                   	pop    %ebp
  80e068:	c3                   	ret    

0080e069 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e069:	55                   	push   %ebp
  80e06a:	89 e5                	mov    %esp,%ebp
  80e06c:	57                   	push   %edi
  80e06d:	56                   	push   %esi
  80e06e:	53                   	push   %ebx
  80e06f:	83 ec 14             	sub    $0x14,%esp
  80e072:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e075:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e078:	6a 14                	push   $0x14
  80e07a:	57                   	push   %edi
  80e07b:	e8 a7 68 ff ff       	call   804927 <pbuf_header>
  80e080:	83 c4 10             	add    $0x10,%esp
  80e083:	84 c0                	test   %al,%al
  80e085:	74 52                	je     80e0d9 <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e087:	83 ec 04             	sub    $0x4,%esp
  80e08a:	6a 00                	push   $0x0
  80e08c:	6a 00                	push   $0x0
  80e08e:	6a 01                	push   $0x1
  80e090:	e8 25 6a ff ff       	call   804aba <pbuf_alloc>
  80e095:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e097:	83 c4 10             	add    $0x10,%esp
  80e09a:	85 c0                	test   %eax,%eax
  80e09c:	0f 84 be 00 00 00    	je     80e160 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e0a2:	83 ec 08             	sub    $0x8,%esp
  80e0a5:	57                   	push   %edi
  80e0a6:	50                   	push   %eax
  80e0a7:	e8 29 6e ff ff       	call   804ed5 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e0ac:	83 c4 04             	add    $0x4,%esp
  80e0af:	ff 75 10             	pushl  0x10(%ebp)
  80e0b2:	e8 f7 85 ff ff       	call   8066ae <ip_route>
  80e0b7:	83 c4 10             	add    $0x10,%esp
  80e0ba:	85 c0                	test   %eax,%eax
  80e0bc:	75 41                	jne    80e0ff <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e0be:	39 f7                	cmp    %esi,%edi
  80e0c0:	0f 84 a1 00 00 00    	je     80e167 <raw_sendto+0xfe>
      pbuf_free(q);
  80e0c6:	83 ec 0c             	sub    $0xc,%esp
  80e0c9:	56                   	push   %esi
  80e0ca:	e8 25 69 ff ff       	call   8049f4 <pbuf_free>
  80e0cf:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80e0d2:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e0d7:	eb 66                	jmp    80e13f <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80e0d9:	83 ec 08             	sub    $0x8,%esp
  80e0dc:	6a ec                	push   $0xffffffec
  80e0de:	57                   	push   %edi
  80e0df:	e8 43 68 ff ff       	call   804927 <pbuf_header>
  80e0e4:	83 c4 10             	add    $0x10,%esp
  80e0e7:	84 c0                	test   %al,%al
  80e0e9:	75 5e                	jne    80e149 <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e0eb:	83 ec 0c             	sub    $0xc,%esp
  80e0ee:	ff 75 10             	pushl  0x10(%ebp)
  80e0f1:	e8 b8 85 ff ff       	call   8066ae <ip_route>
  80e0f6:	83 c4 10             	add    $0x10,%esp
  80e0f9:	85 c0                	test   %eax,%eax
  80e0fb:	74 71                	je     80e16e <raw_sendto+0x105>
    q = p;
  80e0fd:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e0ff:	89 da                	mov    %ebx,%edx
  80e101:	85 db                	test   %ebx,%ebx
  80e103:	74 05                	je     80e10a <raw_sendto+0xa1>
  80e105:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e108:	75 03                	jne    80e10d <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e10a:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e10d:	83 ec 04             	sub    $0x4,%esp
  80e110:	50                   	push   %eax
  80e111:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e115:	50                   	push   %eax
  80e116:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e11a:	50                   	push   %eax
  80e11b:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e11f:	50                   	push   %eax
  80e120:	ff 75 10             	pushl  0x10(%ebp)
  80e123:	52                   	push   %edx
  80e124:	56                   	push   %esi
  80e125:	e8 07 89 ff ff       	call   806a31 <ip_output_if>
  80e12a:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e12c:	83 c4 20             	add    $0x20,%esp
  80e12f:	39 f7                	cmp    %esi,%edi
  80e131:	74 0c                	je     80e13f <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80e133:	83 ec 0c             	sub    $0xc,%esp
  80e136:	56                   	push   %esi
  80e137:	e8 b8 68 ff ff       	call   8049f4 <pbuf_free>
  80e13c:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80e13f:	89 d8                	mov    %ebx,%eax
  80e141:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e144:	5b                   	pop    %ebx
  80e145:	5e                   	pop    %esi
  80e146:	5f                   	pop    %edi
  80e147:	5d                   	pop    %ebp
  80e148:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e149:	83 ec 04             	sub    $0x4,%esp
  80e14c:	68 20 39 81 00       	push   $0x813920
  80e151:	68 e3 00 00 00       	push   $0xe3
  80e156:	68 46 39 81 00       	push   $0x813946
  80e15b:	e8 a9 06 00 00       	call   80e809 <_panic>
      return ERR_MEM;
  80e160:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80e165:	eb d8                	jmp    80e13f <raw_sendto+0xd6>
    return ERR_RTE;
  80e167:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e16c:	eb d1                	jmp    80e13f <raw_sendto+0xd6>
  80e16e:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e173:	eb ca                	jmp    80e13f <raw_sendto+0xd6>

0080e175 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e175:	55                   	push   %ebp
  80e176:	89 e5                	mov    %esp,%ebp
  80e178:	83 ec 0c             	sub    $0xc,%esp
  80e17b:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e17e:	8d 50 04             	lea    0x4(%eax),%edx
  80e181:	52                   	push   %edx
  80e182:	ff 75 0c             	pushl  0xc(%ebp)
  80e185:	50                   	push   %eax
  80e186:	e8 de fe ff ff       	call   80e069 <raw_sendto>
}
  80e18b:	c9                   	leave  
  80e18c:	c3                   	ret    

0080e18d <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e18d:	55                   	push   %ebp
  80e18e:	89 e5                	mov    %esp,%ebp
  80e190:	83 ec 08             	sub    $0x8,%esp
  80e193:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e196:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e19b:	39 c8                	cmp    %ecx,%eax
  80e19d:	75 1b                	jne    80e1ba <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e19f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e1a2:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e1a7:	83 ec 08             	sub    $0x8,%esp
  80e1aa:	51                   	push   %ecx
  80e1ab:	6a 00                	push   $0x0
  80e1ad:	e8 f5 64 ff ff       	call   8046a7 <memp_free>
}
  80e1b2:	83 c4 10             	add    $0x10,%esp
  80e1b5:	c9                   	leave  
  80e1b6:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e1b7:	8b 40 0c             	mov    0xc(%eax),%eax
  80e1ba:	85 c0                	test   %eax,%eax
  80e1bc:	74 e9                	je     80e1a7 <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e1be:	8b 50 0c             	mov    0xc(%eax),%edx
  80e1c1:	39 ca                	cmp    %ecx,%edx
  80e1c3:	75 f2                	jne    80e1b7 <raw_remove+0x2a>
  80e1c5:	85 d2                	test   %edx,%edx
  80e1c7:	74 ee                	je     80e1b7 <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80e1c9:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e1cc:	89 50 0c             	mov    %edx,0xc(%eax)
  80e1cf:	eb e6                	jmp    80e1b7 <raw_remove+0x2a>

0080e1d1 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e1d1:	55                   	push   %ebp
  80e1d2:	89 e5                	mov    %esp,%ebp
  80e1d4:	56                   	push   %esi
  80e1d5:	53                   	push   %ebx
  80e1d6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e1d9:	83 ec 0c             	sub    $0xc,%esp
  80e1dc:	6a 00                	push   $0x0
  80e1de:	e8 6e 64 ff ff       	call   804651 <memp_malloc>
  80e1e3:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e1e5:	83 c4 10             	add    $0x10,%esp
  80e1e8:	85 c0                	test   %eax,%eax
  80e1ea:	74 27                	je     80e213 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e1ec:	83 ec 04             	sub    $0x4,%esp
  80e1ef:	6a 1c                	push   $0x1c
  80e1f1:	6a 00                	push   $0x0
  80e1f3:	50                   	push   %eax
  80e1f4:	e8 ab 0f 00 00       	call   80f1a4 <memset>
    pcb->protocol = proto;
  80e1f9:	89 f0                	mov    %esi,%eax
  80e1fb:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e1fe:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e202:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e207:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e20a:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
  80e210:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e213:	89 d8                	mov    %ebx,%eax
  80e215:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e218:	5b                   	pop    %ebx
  80e219:	5e                   	pop    %esi
  80e21a:	5d                   	pop    %ebp
  80e21b:	c3                   	ret    

0080e21c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e21c:	55                   	push   %ebp
  80e21d:	89 e5                	mov    %esp,%ebp
  80e21f:	57                   	push   %edi
  80e220:	56                   	push   %esi
  80e221:	53                   	push   %ebx
  80e222:	83 ec 28             	sub    $0x28,%esp
  80e225:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e228:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e22b:	0f b7 07             	movzwl (%edi),%eax
  80e22e:	50                   	push   %eax
  80e22f:	e8 a7 96 ff ff       	call   8078db <ntohs>
  80e234:	66 c1 e8 06          	shr    $0x6,%ax
  80e238:	83 e0 3c             	and    $0x3c,%eax
  80e23b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e23f:	89 c6                	mov    %eax,%esi
  80e241:	f7 de                	neg    %esi
  80e243:	0f bf f6             	movswl %si,%esi
  80e246:	83 c4 08             	add    $0x8,%esp
  80e249:	56                   	push   %esi
  80e24a:	53                   	push   %ebx
  80e24b:	e8 d7 66 ff ff       	call   804927 <pbuf_header>
  80e250:	83 c4 10             	add    $0x10,%esp
  80e253:	84 c0                	test   %al,%al
  80e255:	75 67                	jne    80e2be <icmp_input+0xa2>
  80e257:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e25c:	76 60                	jbe    80e2be <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e25e:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e261:	80 38 08             	cmpb   $0x8,(%eax)
  80e264:	74 0e                	je     80e274 <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e266:	83 ec 0c             	sub    $0xc,%esp
  80e269:	53                   	push   %ebx
  80e26a:	e8 85 67 ff ff       	call   8049f4 <pbuf_free>
  return;
  80e26f:	83 c4 10             	add    $0x10,%esp
  80e272:	eb 56                	jmp    80e2ca <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e274:	83 ec 08             	sub    $0x8,%esp
  80e277:	ff 75 0c             	pushl  0xc(%ebp)
  80e27a:	8d 47 10             	lea    0x10(%edi),%eax
  80e27d:	50                   	push   %eax
  80e27e:	e8 e8 83 ff ff       	call   80666b <ip_addr_isbroadcast>
  80e283:	83 c4 10             	add    $0x10,%esp
  80e286:	84 c0                	test   %al,%al
  80e288:	75 48                	jne    80e2d2 <icmp_input+0xb6>
  80e28a:	8b 47 10             	mov    0x10(%edi),%eax
  80e28d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e290:	83 ec 0c             	sub    $0xc,%esp
  80e293:	68 00 00 00 f0       	push   $0xf0000000
  80e298:	e8 62 98 ff ff       	call   807aff <ntohl>
  80e29d:	23 45 e0             	and    -0x20(%ebp),%eax
  80e2a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e2a3:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e2aa:	e8 50 98 ff ff       	call   807aff <ntohl>
  80e2af:	83 c4 10             	add    $0x10,%esp
  80e2b2:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e2b5:	74 1b                	je     80e2d2 <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e2b7:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e2bc:	77 22                	ja     80e2e0 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e2be:	83 ec 0c             	sub    $0xc,%esp
  80e2c1:	53                   	push   %ebx
  80e2c2:	e8 2d 67 ff ff       	call   8049f4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e2c7:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e2ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e2cd:	5b                   	pop    %ebx
  80e2ce:	5e                   	pop    %esi
  80e2cf:	5f                   	pop    %edi
  80e2d0:	5d                   	pop    %ebp
  80e2d1:	c3                   	ret    
      pbuf_free(p);
  80e2d2:	83 ec 0c             	sub    $0xc,%esp
  80e2d5:	53                   	push   %ebx
  80e2d6:	e8 19 67 ff ff       	call   8049f4 <pbuf_free>
      return;
  80e2db:	83 c4 10             	add    $0x10,%esp
  80e2de:	eb ea                	jmp    80e2ca <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e2e0:	83 ec 0c             	sub    $0xc,%esp
  80e2e3:	53                   	push   %ebx
  80e2e4:	e8 cd 94 ff ff       	call   8077b6 <inet_chksum_pbuf>
  80e2e9:	83 c4 10             	add    $0x10,%esp
  80e2ec:	66 85 c0             	test   %ax,%ax
  80e2ef:	0f 85 96 00 00 00    	jne    80e38b <icmp_input+0x16f>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e2f5:	83 ec 08             	sub    $0x8,%esp
  80e2f8:	6a 22                	push   $0x22
  80e2fa:	53                   	push   %ebx
  80e2fb:	e8 27 66 ff ff       	call   804927 <pbuf_header>
  80e300:	83 c4 10             	add    $0x10,%esp
  80e303:	84 c0                	test   %al,%al
  80e305:	0f 84 fb 00 00 00    	je     80e406 <icmp_input+0x1ea>
      if (pbuf_header(p, hlen)) {
  80e30b:	83 ec 08             	sub    $0x8,%esp
  80e30e:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e312:	50                   	push   %eax
  80e313:	53                   	push   %ebx
  80e314:	e8 0e 66 ff ff       	call   804927 <pbuf_header>
  80e319:	83 c4 10             	add    $0x10,%esp
  80e31c:	84 c0                	test   %al,%al
  80e31e:	75 7c                	jne    80e39c <icmp_input+0x180>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e320:	83 ec 04             	sub    $0x4,%esp
  80e323:	6a 00                	push   $0x0
  80e325:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e329:	50                   	push   %eax
  80e32a:	6a 02                	push   $0x2
  80e32c:	e8 89 67 ff ff       	call   804aba <pbuf_alloc>
  80e331:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e334:	83 c4 10             	add    $0x10,%esp
  80e337:	85 c0                	test   %eax,%eax
  80e339:	74 75                	je     80e3b0 <icmp_input+0x194>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e33b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e33e:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e342:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e346:	83 c0 08             	add    $0x8,%eax
  80e349:	39 c2                	cmp    %eax,%edx
  80e34b:	72 74                	jb     80e3c1 <icmp_input+0x1a5>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e34d:	83 ec 08             	sub    $0x8,%esp
  80e350:	53                   	push   %ebx
  80e351:	ff 75 e0             	pushl  -0x20(%ebp)
  80e354:	e8 43 6c ff ff       	call   804f9c <pbuf_copy>
  80e359:	83 c4 10             	add    $0x10,%esp
  80e35c:	84 c0                	test   %al,%al
  80e35e:	75 78                	jne    80e3d8 <icmp_input+0x1bc>
      iphdr = r->payload;
  80e360:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e363:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e366:	83 ec 08             	sub    $0x8,%esp
  80e369:	56                   	push   %esi
  80e36a:	50                   	push   %eax
  80e36b:	e8 b7 65 ff ff       	call   804927 <pbuf_header>
  80e370:	83 c4 10             	add    $0x10,%esp
  80e373:	84 c0                	test   %al,%al
  80e375:	75 78                	jne    80e3ef <icmp_input+0x1d3>
      pbuf_free(p);
  80e377:	83 ec 0c             	sub    $0xc,%esp
  80e37a:	53                   	push   %ebx
  80e37b:	e8 74 66 ff ff       	call   8049f4 <pbuf_free>
  80e380:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e383:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e386:	e9 91 00 00 00       	jmp    80e41c <icmp_input+0x200>
      pbuf_free(p);
  80e38b:	83 ec 0c             	sub    $0xc,%esp
  80e38e:	53                   	push   %ebx
  80e38f:	e8 60 66 ff ff       	call   8049f4 <pbuf_free>
      return;
  80e394:	83 c4 10             	add    $0x10,%esp
  80e397:	e9 2e ff ff ff       	jmp    80e2ca <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e39c:	83 ec 04             	sub    $0x4,%esp
  80e39f:	68 5c 39 81 00       	push   $0x81395c
  80e3a4:	6a 7b                	push   $0x7b
  80e3a6:	68 50 3a 81 00       	push   $0x813a50
  80e3ab:	e8 59 04 00 00       	call   80e809 <_panic>
  pbuf_free(p);
  80e3b0:	83 ec 0c             	sub    $0xc,%esp
  80e3b3:	53                   	push   %ebx
  80e3b4:	e8 3b 66 ff ff       	call   8049f4 <pbuf_free>
  return;
  80e3b9:	83 c4 10             	add    $0x10,%esp
  80e3bc:	e9 09 ff ff ff       	jmp    80e2ca <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e3c1:	83 ec 04             	sub    $0x4,%esp
  80e3c4:	68 90 39 81 00       	push   $0x813990
  80e3c9:	68 85 00 00 00       	push   $0x85
  80e3ce:	68 50 3a 81 00       	push   $0x813a50
  80e3d3:	e8 31 04 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e3d8:	83 ec 04             	sub    $0x4,%esp
  80e3db:	68 c8 39 81 00       	push   $0x8139c8
  80e3e0:	68 88 00 00 00       	push   $0x88
  80e3e5:	68 50 3a 81 00       	push   $0x813a50
  80e3ea:	e8 1a 04 00 00       	call   80e809 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e3ef:	83 ec 04             	sub    $0x4,%esp
  80e3f2:	68 f0 39 81 00       	push   $0x8139f0
  80e3f7:	68 8e 00 00 00       	push   $0x8e
  80e3fc:	68 50 3a 81 00       	push   $0x813a50
  80e401:	e8 03 04 00 00       	call   80e809 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e406:	83 ec 08             	sub    $0x8,%esp
  80e409:	6a de                	push   $0xffffffde
  80e40b:	53                   	push   %ebx
  80e40c:	e8 16 65 ff ff       	call   804927 <pbuf_header>
  80e411:	83 c4 10             	add    $0x10,%esp
  80e414:	84 c0                	test   %al,%al
  80e416:	0f 85 d3 00 00 00    	jne    80e4ef <icmp_input+0x2d3>
    iecho = p->payload;
  80e41c:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e41f:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e422:	8b 57 10             	mov    0x10(%edi),%edx
  80e425:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e428:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e42b:	83 ec 0c             	sub    $0xc,%esp
  80e42e:	0f b7 06             	movzwl (%esi),%eax
  80e431:	50                   	push   %eax
  80e432:	e8 a4 94 ff ff       	call   8078db <ntohs>
  80e437:	0f b6 c0             	movzbl %al,%eax
  80e43a:	89 04 24             	mov    %eax,(%esp)
  80e43d:	e8 8c 94 ff ff       	call   8078ce <htons>
  80e442:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e445:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e449:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e44d:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e454:	e8 75 94 ff ff       	call   8078ce <htons>
  80e459:	83 c4 10             	add    $0x10,%esp
  80e45c:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e460:	0f 82 a0 00 00 00    	jb     80e506 <icmp_input+0x2ea>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e466:	83 ec 0c             	sub    $0xc,%esp
  80e469:	68 00 08 00 00       	push   $0x800
  80e46e:	e8 5b 94 ff ff       	call   8078ce <htons>
  80e473:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e477:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e47b:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e47f:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e482:	83 ec 0c             	sub    $0xc,%esp
  80e485:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e489:	50                   	push   %eax
  80e48a:	e8 4c 94 ff ff       	call   8078db <ntohs>
  80e48f:	66 0d 00 ff          	or     $0xff00,%ax
  80e493:	0f b7 c0             	movzwl %ax,%eax
  80e496:	89 04 24             	mov    %eax,(%esp)
  80e499:	e8 30 94 ff ff       	call   8078ce <htons>
  80e49e:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e4a2:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e4a8:	83 c4 08             	add    $0x8,%esp
  80e4ab:	6a 14                	push   $0x14
  80e4ad:	57                   	push   %edi
  80e4ae:	e8 ed 92 ff ff       	call   8077a0 <inet_chksum>
  80e4b3:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e4b7:	83 c4 08             	add    $0x8,%esp
  80e4ba:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e4be:	50                   	push   %eax
  80e4bf:	53                   	push   %ebx
  80e4c0:	e8 62 64 ff ff       	call   804927 <pbuf_header>
  80e4c5:	83 c4 10             	add    $0x10,%esp
  80e4c8:	84 c0                	test   %al,%al
  80e4ca:	75 53                	jne    80e51f <icmp_input+0x303>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e4cc:	83 ec 04             	sub    $0x4,%esp
  80e4cf:	ff 75 0c             	pushl  0xc(%ebp)
  80e4d2:	6a 01                	push   $0x1
  80e4d4:	6a 00                	push   $0x0
  80e4d6:	68 ff 00 00 00       	push   $0xff
  80e4db:	6a 00                	push   $0x0
  80e4dd:	83 c7 0c             	add    $0xc,%edi
  80e4e0:	57                   	push   %edi
  80e4e1:	53                   	push   %ebx
  80e4e2:	e8 4a 85 ff ff       	call   806a31 <ip_output_if>
  80e4e7:	83 c4 20             	add    $0x20,%esp
  80e4ea:	e9 77 fd ff ff       	jmp    80e266 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e4ef:	83 ec 04             	sub    $0x4,%esp
  80e4f2:	68 f0 39 81 00       	push   $0x8139f0
  80e4f7:	68 98 00 00 00       	push   $0x98
  80e4fc:	68 50 3a 81 00       	push   $0x813a50
  80e501:	e8 03 03 00 00       	call   80e809 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e506:	83 ec 0c             	sub    $0xc,%esp
  80e509:	68 00 08 00 00       	push   $0x800
  80e50e:	e8 bb 93 ff ff       	call   8078ce <htons>
  80e513:	66 01 46 02          	add    %ax,0x2(%esi)
  80e517:	83 c4 10             	add    $0x10,%esp
  80e51a:	e9 63 ff ff ff       	jmp    80e482 <icmp_input+0x266>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e51f:	83 ec 04             	sub    $0x4,%esp
  80e522:	68 b8 2a 81 00       	push   $0x812ab8
  80e527:	68 b9 00 00 00       	push   $0xb9
  80e52c:	68 50 3a 81 00       	push   $0x813a50
  80e531:	e8 d3 02 00 00       	call   80e809 <_panic>

0080e536 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e536:	55                   	push   %ebp
  80e537:	89 e5                	mov    %esp,%ebp
  80e539:	57                   	push   %edi
  80e53a:	56                   	push   %esi
  80e53b:	53                   	push   %ebx
  80e53c:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e53f:	6a 00                	push   $0x0
  80e541:	6a 24                	push   $0x24
  80e543:	6a 01                	push   $0x1
  80e545:	e8 70 65 ff ff       	call   804aba <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e54a:	83 c4 10             	add    $0x10,%esp
  80e54d:	85 c0                	test   %eax,%eax
  80e54f:	0f 84 a5 00 00 00    	je     80e5fa <icmp_dest_unreach+0xc4>
  80e555:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e557:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e55c:	0f 86 a0 00 00 00    	jbe    80e602 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e562:	8b 45 08             	mov    0x8(%ebp),%eax
  80e565:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e568:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e56b:	83 ec 0c             	sub    $0xc,%esp
  80e56e:	0f b7 06             	movzwl (%esi),%eax
  80e571:	50                   	push   %eax
  80e572:	e8 64 93 ff ff       	call   8078db <ntohs>
  80e577:	0f b6 c0             	movzbl %al,%eax
  80e57a:	80 cc 03             	or     $0x3,%ah
  80e57d:	89 04 24             	mov    %eax,(%esp)
  80e580:	e8 49 93 ff ff       	call   8078ce <htons>
  80e585:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e588:	0f b7 c0             	movzwl %ax,%eax
  80e58b:	89 04 24             	mov    %eax,(%esp)
  80e58e:	e8 48 93 ff ff       	call   8078db <ntohs>
  80e593:	b0 00                	mov    $0x0,%al
  80e595:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e599:	0f b7 c0             	movzwl %ax,%eax
  80e59c:	89 04 24             	mov    %eax,(%esp)
  80e59f:	e8 2a 93 ff ff       	call   8078ce <htons>
  80e5a4:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e5a7:	83 c4 0c             	add    $0xc,%esp
  80e5aa:	6a 1c                	push   $0x1c
  80e5ac:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5af:	ff 70 04             	pushl  0x4(%eax)
  80e5b2:	8b 43 04             	mov    0x4(%ebx),%eax
  80e5b5:	83 c0 08             	add    $0x8,%eax
  80e5b8:	50                   	push   %eax
  80e5b9:	e8 90 0c 00 00       	call   80f24e <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e5be:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e5c4:	83 c4 08             	add    $0x8,%esp
  80e5c7:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e5cb:	50                   	push   %eax
  80e5cc:	56                   	push   %esi
  80e5cd:	e8 ce 91 ff ff       	call   8077a0 <inet_chksum>
  80e5d2:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e5d6:	83 c4 08             	add    $0x8,%esp
  80e5d9:	6a 01                	push   $0x1
  80e5db:	6a 00                	push   $0x0
  80e5dd:	68 ff 00 00 00       	push   $0xff
  80e5e2:	83 c7 0c             	add    $0xc,%edi
  80e5e5:	57                   	push   %edi
  80e5e6:	6a 00                	push   $0x0
  80e5e8:	53                   	push   %ebx
  80e5e9:	e8 d0 85 ff ff       	call   806bbe <ip_output>
  pbuf_free(q);
  80e5ee:	83 c4 14             	add    $0x14,%esp
  80e5f1:	53                   	push   %ebx
  80e5f2:	e8 fd 63 ff ff       	call   8049f4 <pbuf_free>
  80e5f7:	83 c4 10             	add    $0x10,%esp
}
  80e5fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e5fd:	5b                   	pop    %ebx
  80e5fe:	5e                   	pop    %esi
  80e5ff:	5f                   	pop    %edi
  80e600:	5d                   	pop    %ebp
  80e601:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e602:	83 ec 04             	sub    $0x4,%esp
  80e605:	68 24 3a 81 00       	push   $0x813a24
  80e60a:	68 ef 00 00 00       	push   $0xef
  80e60f:	68 50 3a 81 00       	push   $0x813a50
  80e614:	e8 f0 01 00 00       	call   80e809 <_panic>

0080e619 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e619:	55                   	push   %ebp
  80e61a:	89 e5                	mov    %esp,%ebp
  80e61c:	57                   	push   %edi
  80e61d:	56                   	push   %esi
  80e61e:	53                   	push   %ebx
  80e61f:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e622:	6a 00                	push   $0x0
  80e624:	6a 24                	push   $0x24
  80e626:	6a 01                	push   $0x1
  80e628:	e8 8d 64 ff ff       	call   804aba <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e62d:	83 c4 10             	add    $0x10,%esp
  80e630:	85 c0                	test   %eax,%eax
  80e632:	0f 84 a5 00 00 00    	je     80e6dd <icmp_time_exceeded+0xc4>
  80e638:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e63a:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e63f:	0f 86 a0 00 00 00    	jbe    80e6e5 <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e645:	8b 45 08             	mov    0x8(%ebp),%eax
  80e648:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e64b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e64e:	83 ec 0c             	sub    $0xc,%esp
  80e651:	0f b7 06             	movzwl (%esi),%eax
  80e654:	50                   	push   %eax
  80e655:	e8 81 92 ff ff       	call   8078db <ntohs>
  80e65a:	0f b6 c0             	movzbl %al,%eax
  80e65d:	80 cc 0b             	or     $0xb,%ah
  80e660:	89 04 24             	mov    %eax,(%esp)
  80e663:	e8 66 92 ff ff       	call   8078ce <htons>
  80e668:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e66b:	0f b7 c0             	movzwl %ax,%eax
  80e66e:	89 04 24             	mov    %eax,(%esp)
  80e671:	e8 65 92 ff ff       	call   8078db <ntohs>
  80e676:	b0 00                	mov    $0x0,%al
  80e678:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e67c:	0f b7 c0             	movzwl %ax,%eax
  80e67f:	89 04 24             	mov    %eax,(%esp)
  80e682:	e8 47 92 ff ff       	call   8078ce <htons>
  80e687:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e68a:	83 c4 0c             	add    $0xc,%esp
  80e68d:	6a 1c                	push   $0x1c
  80e68f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e692:	ff 70 04             	pushl  0x4(%eax)
  80e695:	8b 43 04             	mov    0x4(%ebx),%eax
  80e698:	83 c0 08             	add    $0x8,%eax
  80e69b:	50                   	push   %eax
  80e69c:	e8 ad 0b 00 00       	call   80f24e <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e6a1:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e6a7:	83 c4 08             	add    $0x8,%esp
  80e6aa:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e6ae:	50                   	push   %eax
  80e6af:	56                   	push   %esi
  80e6b0:	e8 eb 90 ff ff       	call   8077a0 <inet_chksum>
  80e6b5:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e6b9:	83 c4 08             	add    $0x8,%esp
  80e6bc:	6a 01                	push   $0x1
  80e6be:	6a 00                	push   $0x0
  80e6c0:	68 ff 00 00 00       	push   $0xff
  80e6c5:	83 c7 0c             	add    $0xc,%edi
  80e6c8:	57                   	push   %edi
  80e6c9:	6a 00                	push   $0x0
  80e6cb:	53                   	push   %ebx
  80e6cc:	e8 ed 84 ff ff       	call   806bbe <ip_output>
  pbuf_free(q);
  80e6d1:	83 c4 14             	add    $0x14,%esp
  80e6d4:	53                   	push   %ebx
  80e6d5:	e8 1a 63 ff ff       	call   8049f4 <pbuf_free>
  80e6da:	83 c4 10             	add    $0x10,%esp
}
  80e6dd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e6e0:	5b                   	pop    %ebx
  80e6e1:	5e                   	pop    %esi
  80e6e2:	5f                   	pop    %edi
  80e6e3:	5d                   	pop    %ebp
  80e6e4:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e6e5:	83 ec 04             	sub    $0x4,%esp
  80e6e8:	68 24 3a 81 00       	push   $0x813a24
  80e6ed:	68 1e 01 00 00       	push   $0x11e
  80e6f2:	68 50 3a 81 00       	push   $0x813a50
  80e6f7:	e8 0d 01 00 00       	call   80e809 <_panic>

0080e6fc <libmain>:
        return &envs[ENVX(sys_getenvid())];
} 

void
libmain(int argc, char **argv)
{
  80e6fc:	55                   	push   %ebp
  80e6fd:	89 e5                	mov    %esp,%ebp
  80e6ff:	57                   	push   %edi
  80e700:	56                   	push   %esi
  80e701:	53                   	push   %ebx
  80e702:	83 ec 0c             	sub    $0xc,%esp
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.

	thisenv = 0;
  80e705:	c7 05 5c c2 b3 00 00 	movl   $0x0,0xb3c25c
  80e70c:	00 00 00 
	envid_t find = sys_getenvid();
  80e70f:	e8 fe 0c 00 00       	call   80f412 <sys_getenvid>
  80e714:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  80e71a:	be 00 00 00 00       	mov    $0x0,%esi
	for(int i = 0; i < NENV; i++){
  80e71f:	ba 00 00 00 00       	mov    $0x0,%edx
		if(envs[i].env_id == find)
  80e724:	bf 01 00 00 00       	mov    $0x1,%edi
  80e729:	eb 0b                	jmp    80e736 <libmain+0x3a>
	for(int i = 0; i < NENV; i++){
  80e72b:	83 c2 01             	add    $0x1,%edx
  80e72e:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  80e734:	74 21                	je     80e757 <libmain+0x5b>
		if(envs[i].env_id == find)
  80e736:	89 d1                	mov    %edx,%ecx
  80e738:	c1 e1 07             	shl    $0x7,%ecx
  80e73b:	81 c1 00 00 c0 ee    	add    $0xeec00000,%ecx
  80e741:	8b 49 48             	mov    0x48(%ecx),%ecx
  80e744:	39 c1                	cmp    %eax,%ecx
  80e746:	75 e3                	jne    80e72b <libmain+0x2f>
  80e748:	89 d3                	mov    %edx,%ebx
  80e74a:	c1 e3 07             	shl    $0x7,%ebx
  80e74d:	81 c3 00 00 c0 ee    	add    $0xeec00000,%ebx
  80e753:	89 fe                	mov    %edi,%esi
  80e755:	eb d4                	jmp    80e72b <libmain+0x2f>
  80e757:	89 f0                	mov    %esi,%eax
  80e759:	84 c0                	test   %al,%al
  80e75b:	74 06                	je     80e763 <libmain+0x67>
  80e75d:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
			thisenv = &envs[i];
	}

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e763:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80e767:	7e 0a                	jle    80e773 <libmain+0x77>
		binaryname = argv[0];
  80e769:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e76c:	8b 00                	mov    (%eax),%eax
  80e76e:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	cprintf("%d: in libmain.c call umain!\n", thisenv->env_id);
  80e773:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e778:	8b 40 48             	mov    0x48(%eax),%eax
  80e77b:	83 ec 08             	sub    $0x8,%esp
  80e77e:	50                   	push   %eax
  80e77f:	68 6a 3a 81 00       	push   $0x813a6a
  80e784:	e8 76 01 00 00       	call   80e8ff <cprintf>
	cprintf("before umain\n");
  80e789:	c7 04 24 88 3a 81 00 	movl   $0x813a88,(%esp)
  80e790:	e8 6a 01 00 00       	call   80e8ff <cprintf>
	// call user main routine
	umain(argc, argv);
  80e795:	83 c4 08             	add    $0x8,%esp
  80e798:	ff 75 0c             	pushl  0xc(%ebp)
  80e79b:	ff 75 08             	pushl  0x8(%ebp)
  80e79e:	e8 d9 1d ff ff       	call   80057c <umain>
	cprintf("after umain\n");
  80e7a3:	c7 04 24 96 3a 81 00 	movl   $0x813a96,(%esp)
  80e7aa:	e8 50 01 00 00       	call   80e8ff <cprintf>
	cprintf("%d: limain.c exit()\n", thisenv->env_id);
  80e7af:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e7b4:	8b 40 48             	mov    0x48(%eax),%eax
  80e7b7:	83 c4 08             	add    $0x8,%esp
  80e7ba:	50                   	push   %eax
  80e7bb:	68 a3 3a 81 00       	push   $0x813aa3
  80e7c0:	e8 3a 01 00 00       	call   80e8ff <cprintf>
	// exit gracefully
	exit();
  80e7c5:	e8 0b 00 00 00       	call   80e7d5 <exit>
}
  80e7ca:	83 c4 10             	add    $0x10,%esp
  80e7cd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e7d0:	5b                   	pop    %ebx
  80e7d1:	5e                   	pop    %esi
  80e7d2:	5f                   	pop    %edi
  80e7d3:	5d                   	pop    %ebp
  80e7d4:	c3                   	ret    

0080e7d5 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e7d5:	55                   	push   %ebp
  80e7d6:	89 e5                	mov    %esp,%ebp
  80e7d8:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e7db:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e7e0:	8b 40 48             	mov    0x48(%eax),%eax
  80e7e3:	68 d0 3a 81 00       	push   $0x813ad0
  80e7e8:	50                   	push   %eax
  80e7e9:	68 c2 3a 81 00       	push   $0x813ac2
  80e7ee:	e8 0c 01 00 00       	call   80e8ff <cprintf>
	close_all();
  80e7f3:	e8 e8 16 00 00       	call   80fee0 <close_all>
	sys_env_destroy(0);
  80e7f8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e7ff:	e8 cd 0b 00 00       	call   80f3d1 <sys_env_destroy>
}
  80e804:	83 c4 10             	add    $0x10,%esp
  80e807:	c9                   	leave  
  80e808:	c3                   	ret    

0080e809 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e809:	55                   	push   %ebp
  80e80a:	89 e5                	mov    %esp,%ebp
  80e80c:	56                   	push   %esi
  80e80d:	53                   	push   %ebx
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e80e:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e813:	8b 40 48             	mov    0x48(%eax),%eax
  80e816:	83 ec 04             	sub    $0x4,%esp
  80e819:	68 fc 3a 81 00       	push   $0x813afc
  80e81e:	50                   	push   %eax
  80e81f:	68 c2 3a 81 00       	push   $0x813ac2
  80e824:	e8 d6 00 00 00       	call   80e8ff <cprintf>
	va_list ap;

	va_start(ap, fmt);
  80e829:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	// cprintf("[%08x] user panic in %s at %s:%d: ",
	// 	sys_getenvid(), binaryname, file, line);
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e82c:	8b 35 e8 52 81 00    	mov    0x8152e8,%esi
  80e832:	e8 db 0b 00 00       	call   80f412 <sys_getenvid>
  80e837:	83 c4 04             	add    $0x4,%esp
  80e83a:	ff 75 0c             	pushl  0xc(%ebp)
  80e83d:	ff 75 08             	pushl  0x8(%ebp)
  80e840:	56                   	push   %esi
  80e841:	50                   	push   %eax
  80e842:	68 d8 3a 81 00       	push   $0x813ad8
  80e847:	e8 b3 00 00 00       	call   80e8ff <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e84c:	83 c4 18             	add    $0x18,%esp
  80e84f:	53                   	push   %ebx
  80e850:	ff 75 10             	pushl  0x10(%ebp)
  80e853:	e8 56 00 00 00       	call   80e8ae <vcprintf>
	cprintf("\n");
  80e858:	c7 04 24 57 17 81 00 	movl   $0x811757,(%esp)
  80e85f:	e8 9b 00 00 00       	call   80e8ff <cprintf>
  80e864:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e867:	cc                   	int3   
  80e868:	eb fd                	jmp    80e867 <_panic+0x5e>

0080e86a <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e86a:	55                   	push   %ebp
  80e86b:	89 e5                	mov    %esp,%ebp
  80e86d:	53                   	push   %ebx
  80e86e:	83 ec 04             	sub    $0x4,%esp
  80e871:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e874:	8b 13                	mov    (%ebx),%edx
  80e876:	8d 42 01             	lea    0x1(%edx),%eax
  80e879:	89 03                	mov    %eax,(%ebx)
  80e87b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e87e:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e882:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e887:	74 09                	je     80e892 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e889:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e88d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e890:	c9                   	leave  
  80e891:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e892:	83 ec 08             	sub    $0x8,%esp
  80e895:	68 ff 00 00 00       	push   $0xff
  80e89a:	8d 43 08             	lea    0x8(%ebx),%eax
  80e89d:	50                   	push   %eax
  80e89e:	e8 f1 0a 00 00       	call   80f394 <sys_cputs>
		b->idx = 0;
  80e8a3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e8a9:	83 c4 10             	add    $0x10,%esp
  80e8ac:	eb db                	jmp    80e889 <putch+0x1f>

0080e8ae <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e8ae:	55                   	push   %ebp
  80e8af:	89 e5                	mov    %esp,%ebp
  80e8b1:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e8b7:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e8be:	00 00 00 
	b.cnt = 0;
  80e8c1:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e8c8:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e8cb:	ff 75 0c             	pushl  0xc(%ebp)
  80e8ce:	ff 75 08             	pushl  0x8(%ebp)
  80e8d1:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e8d7:	50                   	push   %eax
  80e8d8:	68 6a e8 80 00       	push   $0x80e86a
  80e8dd:	e8 4a 01 00 00       	call   80ea2c <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e8e2:	83 c4 08             	add    $0x8,%esp
  80e8e5:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e8eb:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e8f1:	50                   	push   %eax
  80e8f2:	e8 9d 0a 00 00       	call   80f394 <sys_cputs>

	return b.cnt;
}
  80e8f7:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e8fd:	c9                   	leave  
  80e8fe:	c3                   	ret    

0080e8ff <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e8ff:	55                   	push   %ebp
  80e900:	89 e5                	mov    %esp,%ebp
  80e902:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e905:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e908:	50                   	push   %eax
  80e909:	ff 75 08             	pushl  0x8(%ebp)
  80e90c:	e8 9d ff ff ff       	call   80e8ae <vcprintf>
	va_end(ap);

	return cnt;
}
  80e911:	c9                   	leave  
  80e912:	c3                   	ret    

0080e913 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e913:	55                   	push   %ebp
  80e914:	89 e5                	mov    %esp,%ebp
  80e916:	57                   	push   %edi
  80e917:	56                   	push   %esi
  80e918:	53                   	push   %ebx
  80e919:	83 ec 1c             	sub    $0x1c,%esp
  80e91c:	89 c6                	mov    %eax,%esi
  80e91e:	89 d7                	mov    %edx,%edi
  80e920:	8b 45 08             	mov    0x8(%ebp),%eax
  80e923:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e926:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e929:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e92c:	8b 45 10             	mov    0x10(%ebp),%eax
  80e92f:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// if cprintf'parameter includes pattern of the form "%-", padding
	// space on the right side if neccesary.
	// you can add helper function if needed.
	// your code here:
	if(padc == '-'){
  80e932:	83 7d 18 2d          	cmpl   $0x2d,0x18(%ebp)
  80e936:	74 2c                	je     80e964 <printnum+0x51>
		while (--width > 0)
			putch(padc, putdat);
	}
	else {
		// first recursively print all preceding (more significant) digits
		if (num >= base) {
  80e938:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e93b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80e942:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e945:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e948:	39 c2                	cmp    %eax,%edx
  80e94a:	1b 4d dc             	sbb    -0x24(%ebp),%ecx
  80e94d:	73 43                	jae    80e992 <printnum+0x7f>
			printnum(putch, putdat, num / base, base, width - 1, padc);
		} else {
			// print any needed pad characters before first digit
			while (--width > 0)
  80e94f:	83 eb 01             	sub    $0x1,%ebx
  80e952:	85 db                	test   %ebx,%ebx
  80e954:	7e 6c                	jle    80e9c2 <printnum+0xaf>
				putch(padc, putdat);
  80e956:	83 ec 08             	sub    $0x8,%esp
  80e959:	57                   	push   %edi
  80e95a:	ff 75 18             	pushl  0x18(%ebp)
  80e95d:	ff d6                	call   *%esi
  80e95f:	83 c4 10             	add    $0x10,%esp
  80e962:	eb eb                	jmp    80e94f <printnum+0x3c>
		printnum(putch, putdat, num, base, 0, padc);
  80e964:	83 ec 0c             	sub    $0xc,%esp
  80e967:	6a 20                	push   $0x20
  80e969:	6a 00                	push   $0x0
  80e96b:	50                   	push   %eax
  80e96c:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e96f:	ff 75 e0             	pushl  -0x20(%ebp)
  80e972:	89 fa                	mov    %edi,%edx
  80e974:	89 f0                	mov    %esi,%eax
  80e976:	e8 98 ff ff ff       	call   80e913 <printnum>
		while (--width > 0)
  80e97b:	83 c4 20             	add    $0x20,%esp
  80e97e:	83 eb 01             	sub    $0x1,%ebx
  80e981:	85 db                	test   %ebx,%ebx
  80e983:	7e 65                	jle    80e9ea <printnum+0xd7>
			putch(padc, putdat);
  80e985:	83 ec 08             	sub    $0x8,%esp
  80e988:	57                   	push   %edi
  80e989:	6a 20                	push   $0x20
  80e98b:	ff d6                	call   *%esi
  80e98d:	83 c4 10             	add    $0x10,%esp
  80e990:	eb ec                	jmp    80e97e <printnum+0x6b>
			printnum(putch, putdat, num / base, base, width - 1, padc);
  80e992:	83 ec 0c             	sub    $0xc,%esp
  80e995:	ff 75 18             	pushl  0x18(%ebp)
  80e998:	83 eb 01             	sub    $0x1,%ebx
  80e99b:	53                   	push   %ebx
  80e99c:	50                   	push   %eax
  80e99d:	83 ec 08             	sub    $0x8,%esp
  80e9a0:	ff 75 dc             	pushl  -0x24(%ebp)
  80e9a3:	ff 75 d8             	pushl  -0x28(%ebp)
  80e9a6:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e9a9:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9ac:	e8 1f 28 00 00       	call   8111d0 <__udivdi3>
  80e9b1:	83 c4 18             	add    $0x18,%esp
  80e9b4:	52                   	push   %edx
  80e9b5:	50                   	push   %eax
  80e9b6:	89 fa                	mov    %edi,%edx
  80e9b8:	89 f0                	mov    %esi,%eax
  80e9ba:	e8 54 ff ff ff       	call   80e913 <printnum>
  80e9bf:	83 c4 20             	add    $0x20,%esp
		}

		// then print this (the least significant) digit
		putch("0123456789abcdef"[num % base], putdat);
  80e9c2:	83 ec 08             	sub    $0x8,%esp
  80e9c5:	57                   	push   %edi
  80e9c6:	83 ec 04             	sub    $0x4,%esp
  80e9c9:	ff 75 dc             	pushl  -0x24(%ebp)
  80e9cc:	ff 75 d8             	pushl  -0x28(%ebp)
  80e9cf:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e9d2:	ff 75 e0             	pushl  -0x20(%ebp)
  80e9d5:	e8 06 29 00 00       	call   8112e0 <__umoddi3>
  80e9da:	83 c4 14             	add    $0x14,%esp
  80e9dd:	0f be 80 03 3b 81 00 	movsbl 0x813b03(%eax),%eax
  80e9e4:	50                   	push   %eax
  80e9e5:	ff d6                	call   *%esi
  80e9e7:	83 c4 10             	add    $0x10,%esp
	}
}
  80e9ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e9ed:	5b                   	pop    %ebx
  80e9ee:	5e                   	pop    %esi
  80e9ef:	5f                   	pop    %edi
  80e9f0:	5d                   	pop    %ebp
  80e9f1:	c3                   	ret    

0080e9f2 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e9f2:	55                   	push   %ebp
  80e9f3:	89 e5                	mov    %esp,%ebp
  80e9f5:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e9f8:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e9fc:	8b 10                	mov    (%eax),%edx
  80e9fe:	3b 50 04             	cmp    0x4(%eax),%edx
  80ea01:	73 0a                	jae    80ea0d <sprintputch+0x1b>
		*b->buf++ = ch;
  80ea03:	8d 4a 01             	lea    0x1(%edx),%ecx
  80ea06:	89 08                	mov    %ecx,(%eax)
  80ea08:	8b 45 08             	mov    0x8(%ebp),%eax
  80ea0b:	88 02                	mov    %al,(%edx)
}
  80ea0d:	5d                   	pop    %ebp
  80ea0e:	c3                   	ret    

0080ea0f <printfmt>:
{
  80ea0f:	55                   	push   %ebp
  80ea10:	89 e5                	mov    %esp,%ebp
  80ea12:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80ea15:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80ea18:	50                   	push   %eax
  80ea19:	ff 75 10             	pushl  0x10(%ebp)
  80ea1c:	ff 75 0c             	pushl  0xc(%ebp)
  80ea1f:	ff 75 08             	pushl  0x8(%ebp)
  80ea22:	e8 05 00 00 00       	call   80ea2c <vprintfmt>
}
  80ea27:	83 c4 10             	add    $0x10,%esp
  80ea2a:	c9                   	leave  
  80ea2b:	c3                   	ret    

0080ea2c <vprintfmt>:
{
  80ea2c:	55                   	push   %ebp
  80ea2d:	89 e5                	mov    %esp,%ebp
  80ea2f:	57                   	push   %edi
  80ea30:	56                   	push   %esi
  80ea31:	53                   	push   %ebx
  80ea32:	83 ec 3c             	sub    $0x3c,%esp
  80ea35:	8b 75 08             	mov    0x8(%ebp),%esi
  80ea38:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80ea3b:	8b 7d 10             	mov    0x10(%ebp),%edi
  80ea3e:	e9 32 04 00 00       	jmp    80ee75 <vprintfmt+0x449>
		padc = ' ';
  80ea43:	c6 45 cf 20          	movb   $0x20,-0x31(%ebp)
		plusflag = 0;
  80ea47:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		altflag = 0;
  80ea4e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		precision = -1;
  80ea55:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80ea5c:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80ea63:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80ea6a:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80ea6f:	8d 47 01             	lea    0x1(%edi),%eax
  80ea72:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ea75:	0f b6 17             	movzbl (%edi),%edx
  80ea78:	8d 42 dd             	lea    -0x23(%edx),%eax
  80ea7b:	3c 55                	cmp    $0x55,%al
  80ea7d:	0f 87 12 05 00 00    	ja     80ef95 <vprintfmt+0x569>
  80ea83:	0f b6 c0             	movzbl %al,%eax
  80ea86:	ff 24 85 e0 3c 81 00 	jmp    *0x813ce0(,%eax,4)
  80ea8d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80ea90:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
  80ea94:	eb d9                	jmp    80ea6f <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80ea96:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80ea99:	c6 45 cf 30          	movb   $0x30,-0x31(%ebp)
  80ea9d:	eb d0                	jmp    80ea6f <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80ea9f:	0f b6 d2             	movzbl %dl,%edx
  80eaa2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80eaa5:	b8 00 00 00 00       	mov    $0x0,%eax
  80eaaa:	89 75 08             	mov    %esi,0x8(%ebp)
  80eaad:	eb 03                	jmp    80eab2 <vprintfmt+0x86>
  80eaaf:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80eab2:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80eab5:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80eab9:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80eabc:	8d 72 d0             	lea    -0x30(%edx),%esi
  80eabf:	83 fe 09             	cmp    $0x9,%esi
  80eac2:	76 eb                	jbe    80eaaf <vprintfmt+0x83>
  80eac4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eac7:	8b 75 08             	mov    0x8(%ebp),%esi
  80eaca:	eb 14                	jmp    80eae0 <vprintfmt+0xb4>
			precision = va_arg(ap, int);
  80eacc:	8b 45 14             	mov    0x14(%ebp),%eax
  80eacf:	8b 00                	mov    (%eax),%eax
  80ead1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ead4:	8b 45 14             	mov    0x14(%ebp),%eax
  80ead7:	8d 40 04             	lea    0x4(%eax),%eax
  80eada:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80eadd:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80eae0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80eae4:	79 89                	jns    80ea6f <vprintfmt+0x43>
				width = precision, precision = -1;
  80eae6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80eae9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eaec:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80eaf3:	e9 77 ff ff ff       	jmp    80ea6f <vprintfmt+0x43>
  80eaf8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eafb:	85 c0                	test   %eax,%eax
  80eafd:	0f 48 c1             	cmovs  %ecx,%eax
  80eb00:	89 45 e0             	mov    %eax,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80eb03:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80eb06:	e9 64 ff ff ff       	jmp    80ea6f <vprintfmt+0x43>
  80eb0b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80eb0e:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
			goto reswitch;
  80eb15:	e9 55 ff ff ff       	jmp    80ea6f <vprintfmt+0x43>
			lflag++;
  80eb1a:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80eb1e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80eb21:	e9 49 ff ff ff       	jmp    80ea6f <vprintfmt+0x43>
			putch(va_arg(ap, int), putdat);
  80eb26:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb29:	8d 78 04             	lea    0x4(%eax),%edi
  80eb2c:	83 ec 08             	sub    $0x8,%esp
  80eb2f:	53                   	push   %ebx
  80eb30:	ff 30                	pushl  (%eax)
  80eb32:	ff d6                	call   *%esi
			break;
  80eb34:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80eb37:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80eb3a:	e9 33 03 00 00       	jmp    80ee72 <vprintfmt+0x446>
			err = va_arg(ap, int);
  80eb3f:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb42:	8d 78 04             	lea    0x4(%eax),%edi
  80eb45:	8b 00                	mov    (%eax),%eax
  80eb47:	99                   	cltd   
  80eb48:	31 d0                	xor    %edx,%eax
  80eb4a:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80eb4c:	83 f8 11             	cmp    $0x11,%eax
  80eb4f:	7f 23                	jg     80eb74 <vprintfmt+0x148>
  80eb51:	8b 14 85 40 3e 81 00 	mov    0x813e40(,%eax,4),%edx
  80eb58:	85 d2                	test   %edx,%edx
  80eb5a:	74 18                	je     80eb74 <vprintfmt+0x148>
				printfmt(putch, putdat, "%s", p);
  80eb5c:	52                   	push   %edx
  80eb5d:	68 7d 2c 81 00       	push   $0x812c7d
  80eb62:	53                   	push   %ebx
  80eb63:	56                   	push   %esi
  80eb64:	e8 a6 fe ff ff       	call   80ea0f <printfmt>
  80eb69:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80eb6c:	89 7d 14             	mov    %edi,0x14(%ebp)
  80eb6f:	e9 fe 02 00 00       	jmp    80ee72 <vprintfmt+0x446>
				printfmt(putch, putdat, "error %d", err);
  80eb74:	50                   	push   %eax
  80eb75:	68 1b 3b 81 00       	push   $0x813b1b
  80eb7a:	53                   	push   %ebx
  80eb7b:	56                   	push   %esi
  80eb7c:	e8 8e fe ff ff       	call   80ea0f <printfmt>
  80eb81:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80eb84:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80eb87:	e9 e6 02 00 00       	jmp    80ee72 <vprintfmt+0x446>
			if ((p = va_arg(ap, char *)) == NULL)
  80eb8c:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb8f:	83 c0 04             	add    $0x4,%eax
  80eb92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80eb95:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb98:	8b 08                	mov    (%eax),%ecx
				p = "(null)";
  80eb9a:	85 c9                	test   %ecx,%ecx
  80eb9c:	b8 14 3b 81 00       	mov    $0x813b14,%eax
  80eba1:	0f 45 c1             	cmovne %ecx,%eax
  80eba4:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (width > 0 && padc != '-')
  80eba7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ebab:	7e 06                	jle    80ebb3 <vprintfmt+0x187>
  80ebad:	80 7d cf 2d          	cmpb   $0x2d,-0x31(%ebp)
  80ebb1:	75 0d                	jne    80ebc0 <vprintfmt+0x194>
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebb3:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80ebb6:	89 c7                	mov    %eax,%edi
  80ebb8:	03 45 e0             	add    -0x20(%ebp),%eax
  80ebbb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ebbe:	eb 53                	jmp    80ec13 <vprintfmt+0x1e7>
  80ebc0:	83 ec 08             	sub    $0x8,%esp
  80ebc3:	ff 75 d8             	pushl  -0x28(%ebp)
  80ebc6:	50                   	push   %eax
  80ebc7:	e8 71 04 00 00       	call   80f03d <strnlen>
  80ebcc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ebcf:	29 c1                	sub    %eax,%ecx
  80ebd1:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80ebd4:	83 c4 10             	add    $0x10,%esp
  80ebd7:	89 cf                	mov    %ecx,%edi
					putch(padc, putdat);
  80ebd9:	0f be 45 cf          	movsbl -0x31(%ebp),%eax
  80ebdd:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebe0:	eb 0f                	jmp    80ebf1 <vprintfmt+0x1c5>
					putch(padc, putdat);
  80ebe2:	83 ec 08             	sub    $0x8,%esp
  80ebe5:	53                   	push   %ebx
  80ebe6:	ff 75 e0             	pushl  -0x20(%ebp)
  80ebe9:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80ebeb:	83 ef 01             	sub    $0x1,%edi
  80ebee:	83 c4 10             	add    $0x10,%esp
  80ebf1:	85 ff                	test   %edi,%edi
  80ebf3:	7f ed                	jg     80ebe2 <vprintfmt+0x1b6>
  80ebf5:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80ebf8:	85 c9                	test   %ecx,%ecx
  80ebfa:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebff:	0f 49 c1             	cmovns %ecx,%eax
  80ec02:	29 c1                	sub    %eax,%ecx
  80ec04:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80ec07:	eb aa                	jmp    80ebb3 <vprintfmt+0x187>
					putch(ch, putdat);
  80ec09:	83 ec 08             	sub    $0x8,%esp
  80ec0c:	53                   	push   %ebx
  80ec0d:	52                   	push   %edx
  80ec0e:	ff d6                	call   *%esi
  80ec10:	83 c4 10             	add    $0x10,%esp
  80ec13:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ec16:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80ec18:	83 c7 01             	add    $0x1,%edi
  80ec1b:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ec1f:	0f be d0             	movsbl %al,%edx
  80ec22:	85 d2                	test   %edx,%edx
  80ec24:	74 4b                	je     80ec71 <vprintfmt+0x245>
  80ec26:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80ec2a:	78 06                	js     80ec32 <vprintfmt+0x206>
  80ec2c:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80ec30:	78 1e                	js     80ec50 <vprintfmt+0x224>
				if (altflag && (ch < ' ' || ch > '~'))
  80ec32:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80ec36:	74 d1                	je     80ec09 <vprintfmt+0x1dd>
  80ec38:	0f be c0             	movsbl %al,%eax
  80ec3b:	83 e8 20             	sub    $0x20,%eax
  80ec3e:	83 f8 5e             	cmp    $0x5e,%eax
  80ec41:	76 c6                	jbe    80ec09 <vprintfmt+0x1dd>
					putch('?', putdat);
  80ec43:	83 ec 08             	sub    $0x8,%esp
  80ec46:	53                   	push   %ebx
  80ec47:	6a 3f                	push   $0x3f
  80ec49:	ff d6                	call   *%esi
  80ec4b:	83 c4 10             	add    $0x10,%esp
  80ec4e:	eb c3                	jmp    80ec13 <vprintfmt+0x1e7>
  80ec50:	89 cf                	mov    %ecx,%edi
  80ec52:	eb 0e                	jmp    80ec62 <vprintfmt+0x236>
				putch(' ', putdat);
  80ec54:	83 ec 08             	sub    $0x8,%esp
  80ec57:	53                   	push   %ebx
  80ec58:	6a 20                	push   $0x20
  80ec5a:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80ec5c:	83 ef 01             	sub    $0x1,%edi
  80ec5f:	83 c4 10             	add    $0x10,%esp
  80ec62:	85 ff                	test   %edi,%edi
  80ec64:	7f ee                	jg     80ec54 <vprintfmt+0x228>
			if ((p = va_arg(ap, char *)) == NULL)
  80ec66:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80ec69:	89 45 14             	mov    %eax,0x14(%ebp)
  80ec6c:	e9 01 02 00 00       	jmp    80ee72 <vprintfmt+0x446>
  80ec71:	89 cf                	mov    %ecx,%edi
  80ec73:	eb ed                	jmp    80ec62 <vprintfmt+0x236>
		switch (ch = *(unsigned char *) fmt++) {
  80ec75:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			plusflag = 1;
  80ec78:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
			goto reswitch;
  80ec7f:	e9 eb fd ff ff       	jmp    80ea6f <vprintfmt+0x43>
	if (lflag >= 2)
  80ec84:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ec88:	7f 21                	jg     80ecab <vprintfmt+0x27f>
	else if (lflag)
  80ec8a:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ec8e:	74 68                	je     80ecf8 <vprintfmt+0x2cc>
		return va_arg(*ap, long);
  80ec90:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec93:	8b 00                	mov    (%eax),%eax
  80ec95:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ec98:	89 c1                	mov    %eax,%ecx
  80ec9a:	c1 f9 1f             	sar    $0x1f,%ecx
  80ec9d:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80eca0:	8b 45 14             	mov    0x14(%ebp),%eax
  80eca3:	8d 40 04             	lea    0x4(%eax),%eax
  80eca6:	89 45 14             	mov    %eax,0x14(%ebp)
  80eca9:	eb 17                	jmp    80ecc2 <vprintfmt+0x296>
		return va_arg(*ap, long long);
  80ecab:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecae:	8b 50 04             	mov    0x4(%eax),%edx
  80ecb1:	8b 00                	mov    (%eax),%eax
  80ecb3:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ecb6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80ecb9:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecbc:	8d 40 08             	lea    0x8(%eax),%eax
  80ecbf:	89 45 14             	mov    %eax,0x14(%ebp)
			num = getint(&ap, lflag);
  80ecc2:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ecc5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ecc8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eccb:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if ((long long) num < 0) {
  80ecce:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80ecd2:	78 3f                	js     80ed13 <vprintfmt+0x2e7>
			base = 10;
  80ecd4:	b8 0a 00 00 00       	mov    $0xa,%eax
			else if(plusflag){
  80ecd9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  80ecdd:	0f 84 71 01 00 00    	je     80ee54 <vprintfmt+0x428>
				putch('+', putdat);
  80ece3:	83 ec 08             	sub    $0x8,%esp
  80ece6:	53                   	push   %ebx
  80ece7:	6a 2b                	push   $0x2b
  80ece9:	ff d6                	call   *%esi
  80eceb:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ecee:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ecf3:	e9 5c 01 00 00       	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, int);
  80ecf8:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecfb:	8b 00                	mov    (%eax),%eax
  80ecfd:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ed00:	89 c1                	mov    %eax,%ecx
  80ed02:	c1 f9 1f             	sar    $0x1f,%ecx
  80ed05:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80ed08:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed0b:	8d 40 04             	lea    0x4(%eax),%eax
  80ed0e:	89 45 14             	mov    %eax,0x14(%ebp)
  80ed11:	eb af                	jmp    80ecc2 <vprintfmt+0x296>
				putch('-', putdat);
  80ed13:	83 ec 08             	sub    $0x8,%esp
  80ed16:	53                   	push   %ebx
  80ed17:	6a 2d                	push   $0x2d
  80ed19:	ff d6                	call   *%esi
				num = -(long long) num;
  80ed1b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ed1e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ed21:	f7 d8                	neg    %eax
  80ed23:	83 d2 00             	adc    $0x0,%edx
  80ed26:	f7 da                	neg    %edx
  80ed28:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed2b:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed2e:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ed31:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ed36:	e9 19 01 00 00       	jmp    80ee54 <vprintfmt+0x428>
	if (lflag >= 2)
  80ed3b:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ed3f:	7f 29                	jg     80ed6a <vprintfmt+0x33e>
	else if (lflag)
  80ed41:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ed45:	74 44                	je     80ed8b <vprintfmt+0x35f>
		return va_arg(*ap, unsigned long);
  80ed47:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed4a:	8b 00                	mov    (%eax),%eax
  80ed4c:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed51:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed54:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed57:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed5a:	8d 40 04             	lea    0x4(%eax),%eax
  80ed5d:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed60:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ed65:	e9 ea 00 00 00       	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ed6a:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed6d:	8b 50 04             	mov    0x4(%eax),%edx
  80ed70:	8b 00                	mov    (%eax),%eax
  80ed72:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed75:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed78:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed7b:	8d 40 08             	lea    0x8(%eax),%eax
  80ed7e:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ed81:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ed86:	e9 c9 00 00 00       	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ed8b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed8e:	8b 00                	mov    (%eax),%eax
  80ed90:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed95:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed98:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed9b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed9e:	8d 40 04             	lea    0x4(%eax),%eax
  80eda1:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80eda4:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eda9:	e9 a6 00 00 00       	jmp    80ee54 <vprintfmt+0x428>
			putch('0', putdat);
  80edae:	83 ec 08             	sub    $0x8,%esp
  80edb1:	53                   	push   %ebx
  80edb2:	6a 30                	push   $0x30
  80edb4:	ff d6                	call   *%esi
	if (lflag >= 2)
  80edb6:	83 c4 10             	add    $0x10,%esp
  80edb9:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80edbd:	7f 26                	jg     80ede5 <vprintfmt+0x3b9>
	else if (lflag)
  80edbf:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80edc3:	74 3e                	je     80ee03 <vprintfmt+0x3d7>
		return va_arg(*ap, unsigned long);
  80edc5:	8b 45 14             	mov    0x14(%ebp),%eax
  80edc8:	8b 00                	mov    (%eax),%eax
  80edca:	ba 00 00 00 00       	mov    $0x0,%edx
  80edcf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80edd2:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80edd5:	8b 45 14             	mov    0x14(%ebp),%eax
  80edd8:	8d 40 04             	lea    0x4(%eax),%eax
  80eddb:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80edde:	b8 08 00 00 00       	mov    $0x8,%eax
  80ede3:	eb 6f                	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ede5:	8b 45 14             	mov    0x14(%ebp),%eax
  80ede8:	8b 50 04             	mov    0x4(%eax),%edx
  80edeb:	8b 00                	mov    (%eax),%eax
  80eded:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80edf0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80edf3:	8b 45 14             	mov    0x14(%ebp),%eax
  80edf6:	8d 40 08             	lea    0x8(%eax),%eax
  80edf9:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80edfc:	b8 08 00 00 00       	mov    $0x8,%eax
  80ee01:	eb 51                	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ee03:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee06:	8b 00                	mov    (%eax),%eax
  80ee08:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee10:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ee13:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee16:	8d 40 04             	lea    0x4(%eax),%eax
  80ee19:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ee1c:	b8 08 00 00 00       	mov    $0x8,%eax
  80ee21:	eb 31                	jmp    80ee54 <vprintfmt+0x428>
			putch('0', putdat);
  80ee23:	83 ec 08             	sub    $0x8,%esp
  80ee26:	53                   	push   %ebx
  80ee27:	6a 30                	push   $0x30
  80ee29:	ff d6                	call   *%esi
			putch('x', putdat);
  80ee2b:	83 c4 08             	add    $0x8,%esp
  80ee2e:	53                   	push   %ebx
  80ee2f:	6a 78                	push   $0x78
  80ee31:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ee33:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee36:	8b 00                	mov    (%eax),%eax
  80ee38:	ba 00 00 00 00       	mov    $0x0,%edx
  80ee3d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ee40:	89 55 dc             	mov    %edx,-0x24(%ebp)
			goto number;
  80ee43:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80ee46:	8b 45 14             	mov    0x14(%ebp),%eax
  80ee49:	8d 40 04             	lea    0x4(%eax),%eax
  80ee4c:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ee4f:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80ee54:	83 ec 0c             	sub    $0xc,%esp
  80ee57:	0f be 55 cf          	movsbl -0x31(%ebp),%edx
  80ee5b:	52                   	push   %edx
  80ee5c:	ff 75 e0             	pushl  -0x20(%ebp)
  80ee5f:	50                   	push   %eax
  80ee60:	ff 75 dc             	pushl  -0x24(%ebp)
  80ee63:	ff 75 d8             	pushl  -0x28(%ebp)
  80ee66:	89 da                	mov    %ebx,%edx
  80ee68:	89 f0                	mov    %esi,%eax
  80ee6a:	e8 a4 fa ff ff       	call   80e913 <printnum>
			break;
  80ee6f:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80ee72:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80ee75:	83 c7 01             	add    $0x1,%edi
  80ee78:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ee7c:	83 f8 25             	cmp    $0x25,%eax
  80ee7f:	0f 84 be fb ff ff    	je     80ea43 <vprintfmt+0x17>
			if (ch == '\0')
  80ee85:	85 c0                	test   %eax,%eax
  80ee87:	0f 84 28 01 00 00    	je     80efb5 <vprintfmt+0x589>
			putch(ch, putdat);
  80ee8d:	83 ec 08             	sub    $0x8,%esp
  80ee90:	53                   	push   %ebx
  80ee91:	50                   	push   %eax
  80ee92:	ff d6                	call   *%esi
  80ee94:	83 c4 10             	add    $0x10,%esp
  80ee97:	eb dc                	jmp    80ee75 <vprintfmt+0x449>
	if (lflag >= 2)
  80ee99:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ee9d:	7f 26                	jg     80eec5 <vprintfmt+0x499>
	else if (lflag)
  80ee9f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80eea3:	74 41                	je     80eee6 <vprintfmt+0x4ba>
		return va_arg(*ap, unsigned long);
  80eea5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eea8:	8b 00                	mov    (%eax),%eax
  80eeaa:	ba 00 00 00 00       	mov    $0x0,%edx
  80eeaf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eeb2:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eeb5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eeb8:	8d 40 04             	lea    0x4(%eax),%eax
  80eebb:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eebe:	b8 10 00 00 00       	mov    $0x10,%eax
  80eec3:	eb 8f                	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80eec5:	8b 45 14             	mov    0x14(%ebp),%eax
  80eec8:	8b 50 04             	mov    0x4(%eax),%edx
  80eecb:	8b 00                	mov    (%eax),%eax
  80eecd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eed0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eed3:	8b 45 14             	mov    0x14(%ebp),%eax
  80eed6:	8d 40 08             	lea    0x8(%eax),%eax
  80eed9:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eedc:	b8 10 00 00 00       	mov    $0x10,%eax
  80eee1:	e9 6e ff ff ff       	jmp    80ee54 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80eee6:	8b 45 14             	mov    0x14(%ebp),%eax
  80eee9:	8b 00                	mov    (%eax),%eax
  80eeeb:	ba 00 00 00 00       	mov    $0x0,%edx
  80eef0:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eef3:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eef6:	8b 45 14             	mov    0x14(%ebp),%eax
  80eef9:	8d 40 04             	lea    0x4(%eax),%eax
  80eefc:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80eeff:	b8 10 00 00 00       	mov    $0x10,%eax
  80ef04:	e9 4b ff ff ff       	jmp    80ee54 <vprintfmt+0x428>
					if ((p = va_arg(ap, char *)) == NULL){
  80ef09:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef0c:	83 c0 04             	add    $0x4,%eax
  80ef0f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ef12:	8b 45 14             	mov    0x14(%ebp),%eax
  80ef15:	8b 00                	mov    (%eax),%eax
  80ef17:	85 c0                	test   %eax,%eax
  80ef19:	74 14                	je     80ef2f <vprintfmt+0x503>
					}else if(*(int *)putdat > 127){
  80ef1b:	8b 13                	mov    (%ebx),%edx
  80ef1d:	83 fa 7f             	cmp    $0x7f,%edx
  80ef20:	7f 37                	jg     80ef59 <vprintfmt+0x52d>
						*(char *)p = *(int *)putdat;
  80ef22:	88 10                	mov    %dl,(%eax)
					if ((p = va_arg(ap, char *)) == NULL){
  80ef24:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ef27:	89 45 14             	mov    %eax,0x14(%ebp)
  80ef2a:	e9 43 ff ff ff       	jmp    80ee72 <vprintfmt+0x446>
						for (; (ch = *tmp++) != '\0';){
  80ef2f:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ef34:	bf 39 3c 81 00       	mov    $0x813c39,%edi
							putch(ch, putdat);
  80ef39:	83 ec 08             	sub    $0x8,%esp
  80ef3c:	53                   	push   %ebx
  80ef3d:	50                   	push   %eax
  80ef3e:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80ef40:	83 c7 01             	add    $0x1,%edi
  80ef43:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80ef47:	83 c4 10             	add    $0x10,%esp
  80ef4a:	85 c0                	test   %eax,%eax
  80ef4c:	75 eb                	jne    80ef39 <vprintfmt+0x50d>
					if ((p = va_arg(ap, char *)) == NULL){
  80ef4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ef51:	89 45 14             	mov    %eax,0x14(%ebp)
  80ef54:	e9 19 ff ff ff       	jmp    80ee72 <vprintfmt+0x446>
						*(char *)p = *(int *)putdat;
  80ef59:	88 10                	mov    %dl,(%eax)
						for (; (ch = *tmp++) != '\0';){
  80ef5b:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ef60:	bf 71 3c 81 00       	mov    $0x813c71,%edi
							putch(ch, putdat);
  80ef65:	83 ec 08             	sub    $0x8,%esp
  80ef68:	53                   	push   %ebx
  80ef69:	50                   	push   %eax
  80ef6a:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80ef6c:	83 c7 01             	add    $0x1,%edi
  80ef6f:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80ef73:	83 c4 10             	add    $0x10,%esp
  80ef76:	85 c0                	test   %eax,%eax
  80ef78:	75 eb                	jne    80ef65 <vprintfmt+0x539>
					if ((p = va_arg(ap, char *)) == NULL){
  80ef7a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ef7d:	89 45 14             	mov    %eax,0x14(%ebp)
  80ef80:	e9 ed fe ff ff       	jmp    80ee72 <vprintfmt+0x446>
			putch(ch, putdat);
  80ef85:	83 ec 08             	sub    $0x8,%esp
  80ef88:	53                   	push   %ebx
  80ef89:	6a 25                	push   $0x25
  80ef8b:	ff d6                	call   *%esi
			break;
  80ef8d:	83 c4 10             	add    $0x10,%esp
  80ef90:	e9 dd fe ff ff       	jmp    80ee72 <vprintfmt+0x446>
			putch('%', putdat);
  80ef95:	83 ec 08             	sub    $0x8,%esp
  80ef98:	53                   	push   %ebx
  80ef99:	6a 25                	push   $0x25
  80ef9b:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ef9d:	83 c4 10             	add    $0x10,%esp
  80efa0:	89 f8                	mov    %edi,%eax
  80efa2:	eb 03                	jmp    80efa7 <vprintfmt+0x57b>
  80efa4:	83 e8 01             	sub    $0x1,%eax
  80efa7:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80efab:	75 f7                	jne    80efa4 <vprintfmt+0x578>
  80efad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80efb0:	e9 bd fe ff ff       	jmp    80ee72 <vprintfmt+0x446>
}
  80efb5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80efb8:	5b                   	pop    %ebx
  80efb9:	5e                   	pop    %esi
  80efba:	5f                   	pop    %edi
  80efbb:	5d                   	pop    %ebp
  80efbc:	c3                   	ret    

0080efbd <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80efbd:	55                   	push   %ebp
  80efbe:	89 e5                	mov    %esp,%ebp
  80efc0:	83 ec 18             	sub    $0x18,%esp
  80efc3:	8b 45 08             	mov    0x8(%ebp),%eax
  80efc6:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80efc9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80efcc:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80efd0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80efd3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80efda:	85 c0                	test   %eax,%eax
  80efdc:	74 26                	je     80f004 <vsnprintf+0x47>
  80efde:	85 d2                	test   %edx,%edx
  80efe0:	7e 22                	jle    80f004 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80efe2:	ff 75 14             	pushl  0x14(%ebp)
  80efe5:	ff 75 10             	pushl  0x10(%ebp)
  80efe8:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80efeb:	50                   	push   %eax
  80efec:	68 f2 e9 80 00       	push   $0x80e9f2
  80eff1:	e8 36 fa ff ff       	call   80ea2c <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80eff6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80eff9:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80effc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80efff:	83 c4 10             	add    $0x10,%esp
}
  80f002:	c9                   	leave  
  80f003:	c3                   	ret    
		return -E_INVAL;
  80f004:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80f009:	eb f7                	jmp    80f002 <vsnprintf+0x45>

0080f00b <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f00b:	55                   	push   %ebp
  80f00c:	89 e5                	mov    %esp,%ebp
  80f00e:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f011:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f014:	50                   	push   %eax
  80f015:	ff 75 10             	pushl  0x10(%ebp)
  80f018:	ff 75 0c             	pushl  0xc(%ebp)
  80f01b:	ff 75 08             	pushl  0x8(%ebp)
  80f01e:	e8 9a ff ff ff       	call   80efbd <vsnprintf>
	va_end(ap);

	return rc;
}
  80f023:	c9                   	leave  
  80f024:	c3                   	ret    

0080f025 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f025:	55                   	push   %ebp
  80f026:	89 e5                	mov    %esp,%ebp
  80f028:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f02b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f030:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f034:	74 05                	je     80f03b <strlen+0x16>
		n++;
  80f036:	83 c0 01             	add    $0x1,%eax
  80f039:	eb f5                	jmp    80f030 <strlen+0xb>
	return n;
}
  80f03b:	5d                   	pop    %ebp
  80f03c:	c3                   	ret    

0080f03d <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f03d:	55                   	push   %ebp
  80f03e:	89 e5                	mov    %esp,%ebp
  80f040:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f043:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f046:	ba 00 00 00 00       	mov    $0x0,%edx
  80f04b:	39 c2                	cmp    %eax,%edx
  80f04d:	74 0d                	je     80f05c <strnlen+0x1f>
  80f04f:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80f053:	74 05                	je     80f05a <strnlen+0x1d>
		n++;
  80f055:	83 c2 01             	add    $0x1,%edx
  80f058:	eb f1                	jmp    80f04b <strnlen+0xe>
  80f05a:	89 d0                	mov    %edx,%eax
	return n;
}
  80f05c:	5d                   	pop    %ebp
  80f05d:	c3                   	ret    

0080f05e <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f05e:	55                   	push   %ebp
  80f05f:	89 e5                	mov    %esp,%ebp
  80f061:	53                   	push   %ebx
  80f062:	8b 45 08             	mov    0x8(%ebp),%eax
  80f065:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f068:	ba 00 00 00 00       	mov    $0x0,%edx
  80f06d:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80f071:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80f074:	83 c2 01             	add    $0x1,%edx
  80f077:	84 c9                	test   %cl,%cl
  80f079:	75 f2                	jne    80f06d <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80f07b:	5b                   	pop    %ebx
  80f07c:	5d                   	pop    %ebp
  80f07d:	c3                   	ret    

0080f07e <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f07e:	55                   	push   %ebp
  80f07f:	89 e5                	mov    %esp,%ebp
  80f081:	53                   	push   %ebx
  80f082:	83 ec 10             	sub    $0x10,%esp
  80f085:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f088:	53                   	push   %ebx
  80f089:	e8 97 ff ff ff       	call   80f025 <strlen>
  80f08e:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80f091:	ff 75 0c             	pushl  0xc(%ebp)
  80f094:	01 d8                	add    %ebx,%eax
  80f096:	50                   	push   %eax
  80f097:	e8 c2 ff ff ff       	call   80f05e <strcpy>
	return dst;
}
  80f09c:	89 d8                	mov    %ebx,%eax
  80f09e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f0a1:	c9                   	leave  
  80f0a2:	c3                   	ret    

0080f0a3 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f0a3:	55                   	push   %ebp
  80f0a4:	89 e5                	mov    %esp,%ebp
  80f0a6:	56                   	push   %esi
  80f0a7:	53                   	push   %ebx
  80f0a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0ab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0ae:	89 c6                	mov    %eax,%esi
  80f0b0:	03 75 10             	add    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f0b3:	89 c2                	mov    %eax,%edx
  80f0b5:	39 f2                	cmp    %esi,%edx
  80f0b7:	74 11                	je     80f0ca <strncpy+0x27>
		*dst++ = *src;
  80f0b9:	83 c2 01             	add    $0x1,%edx
  80f0bc:	0f b6 19             	movzbl (%ecx),%ebx
  80f0bf:	88 5a ff             	mov    %bl,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f0c2:	80 fb 01             	cmp    $0x1,%bl
  80f0c5:	83 d9 ff             	sbb    $0xffffffff,%ecx
  80f0c8:	eb eb                	jmp    80f0b5 <strncpy+0x12>
	}
	return ret;
}
  80f0ca:	5b                   	pop    %ebx
  80f0cb:	5e                   	pop    %esi
  80f0cc:	5d                   	pop    %ebp
  80f0cd:	c3                   	ret    

0080f0ce <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f0ce:	55                   	push   %ebp
  80f0cf:	89 e5                	mov    %esp,%ebp
  80f0d1:	56                   	push   %esi
  80f0d2:	53                   	push   %ebx
  80f0d3:	8b 75 08             	mov    0x8(%ebp),%esi
  80f0d6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f0d9:	8b 55 10             	mov    0x10(%ebp),%edx
  80f0dc:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f0de:	85 d2                	test   %edx,%edx
  80f0e0:	74 21                	je     80f103 <strlcpy+0x35>
  80f0e2:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80f0e6:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80f0e8:	39 c2                	cmp    %eax,%edx
  80f0ea:	74 14                	je     80f100 <strlcpy+0x32>
  80f0ec:	0f b6 19             	movzbl (%ecx),%ebx
  80f0ef:	84 db                	test   %bl,%bl
  80f0f1:	74 0b                	je     80f0fe <strlcpy+0x30>
			*dst++ = *src++;
  80f0f3:	83 c1 01             	add    $0x1,%ecx
  80f0f6:	83 c2 01             	add    $0x1,%edx
  80f0f9:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f0fc:	eb ea                	jmp    80f0e8 <strlcpy+0x1a>
  80f0fe:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80f100:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80f103:	29 f0                	sub    %esi,%eax
}
  80f105:	5b                   	pop    %ebx
  80f106:	5e                   	pop    %esi
  80f107:	5d                   	pop    %ebp
  80f108:	c3                   	ret    

0080f109 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f109:	55                   	push   %ebp
  80f10a:	89 e5                	mov    %esp,%ebp
  80f10c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f10f:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f112:	0f b6 01             	movzbl (%ecx),%eax
  80f115:	84 c0                	test   %al,%al
  80f117:	74 0c                	je     80f125 <strcmp+0x1c>
  80f119:	3a 02                	cmp    (%edx),%al
  80f11b:	75 08                	jne    80f125 <strcmp+0x1c>
		p++, q++;
  80f11d:	83 c1 01             	add    $0x1,%ecx
  80f120:	83 c2 01             	add    $0x1,%edx
  80f123:	eb ed                	jmp    80f112 <strcmp+0x9>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f125:	0f b6 c0             	movzbl %al,%eax
  80f128:	0f b6 12             	movzbl (%edx),%edx
  80f12b:	29 d0                	sub    %edx,%eax
}
  80f12d:	5d                   	pop    %ebp
  80f12e:	c3                   	ret    

0080f12f <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f12f:	55                   	push   %ebp
  80f130:	89 e5                	mov    %esp,%ebp
  80f132:	53                   	push   %ebx
  80f133:	8b 45 08             	mov    0x8(%ebp),%eax
  80f136:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f139:	89 c3                	mov    %eax,%ebx
  80f13b:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f13e:	eb 06                	jmp    80f146 <strncmp+0x17>
		n--, p++, q++;
  80f140:	83 c0 01             	add    $0x1,%eax
  80f143:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80f146:	39 d8                	cmp    %ebx,%eax
  80f148:	74 16                	je     80f160 <strncmp+0x31>
  80f14a:	0f b6 08             	movzbl (%eax),%ecx
  80f14d:	84 c9                	test   %cl,%cl
  80f14f:	74 04                	je     80f155 <strncmp+0x26>
  80f151:	3a 0a                	cmp    (%edx),%cl
  80f153:	74 eb                	je     80f140 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f155:	0f b6 00             	movzbl (%eax),%eax
  80f158:	0f b6 12             	movzbl (%edx),%edx
  80f15b:	29 d0                	sub    %edx,%eax
}
  80f15d:	5b                   	pop    %ebx
  80f15e:	5d                   	pop    %ebp
  80f15f:	c3                   	ret    
		return 0;
  80f160:	b8 00 00 00 00       	mov    $0x0,%eax
  80f165:	eb f6                	jmp    80f15d <strncmp+0x2e>

0080f167 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f167:	55                   	push   %ebp
  80f168:	89 e5                	mov    %esp,%ebp
  80f16a:	8b 45 08             	mov    0x8(%ebp),%eax
  80f16d:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f171:	0f b6 10             	movzbl (%eax),%edx
  80f174:	84 d2                	test   %dl,%dl
  80f176:	74 09                	je     80f181 <strchr+0x1a>
		if (*s == c)
  80f178:	38 ca                	cmp    %cl,%dl
  80f17a:	74 0a                	je     80f186 <strchr+0x1f>
	for (; *s; s++)
  80f17c:	83 c0 01             	add    $0x1,%eax
  80f17f:	eb f0                	jmp    80f171 <strchr+0xa>
			return (char *) s;
	return 0;
  80f181:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f186:	5d                   	pop    %ebp
  80f187:	c3                   	ret    

0080f188 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f188:	55                   	push   %ebp
  80f189:	89 e5                	mov    %esp,%ebp
  80f18b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f18e:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f192:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f195:	38 ca                	cmp    %cl,%dl
  80f197:	74 09                	je     80f1a2 <strfind+0x1a>
  80f199:	84 d2                	test   %dl,%dl
  80f19b:	74 05                	je     80f1a2 <strfind+0x1a>
	for (; *s; s++)
  80f19d:	83 c0 01             	add    $0x1,%eax
  80f1a0:	eb f0                	jmp    80f192 <strfind+0xa>
			break;
	return (char *) s;
}
  80f1a2:	5d                   	pop    %ebp
  80f1a3:	c3                   	ret    

0080f1a4 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f1a4:	55                   	push   %ebp
  80f1a5:	89 e5                	mov    %esp,%ebp
  80f1a7:	57                   	push   %edi
  80f1a8:	56                   	push   %esi
  80f1a9:	53                   	push   %ebx
  80f1aa:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f1ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f1b0:	85 c9                	test   %ecx,%ecx
  80f1b2:	74 31                	je     80f1e5 <memset+0x41>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f1b4:	89 f8                	mov    %edi,%eax
  80f1b6:	09 c8                	or     %ecx,%eax
  80f1b8:	a8 03                	test   $0x3,%al
  80f1ba:	75 23                	jne    80f1df <memset+0x3b>
		c &= 0xFF;
  80f1bc:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f1c0:	89 d3                	mov    %edx,%ebx
  80f1c2:	c1 e3 08             	shl    $0x8,%ebx
  80f1c5:	89 d0                	mov    %edx,%eax
  80f1c7:	c1 e0 18             	shl    $0x18,%eax
  80f1ca:	89 d6                	mov    %edx,%esi
  80f1cc:	c1 e6 10             	shl    $0x10,%esi
  80f1cf:	09 f0                	or     %esi,%eax
  80f1d1:	09 c2                	or     %eax,%edx
  80f1d3:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f1d5:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f1d8:	89 d0                	mov    %edx,%eax
  80f1da:	fc                   	cld    
  80f1db:	f3 ab                	rep stos %eax,%es:(%edi)
  80f1dd:	eb 06                	jmp    80f1e5 <memset+0x41>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f1df:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f1e2:	fc                   	cld    
  80f1e3:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f1e5:	89 f8                	mov    %edi,%eax
  80f1e7:	5b                   	pop    %ebx
  80f1e8:	5e                   	pop    %esi
  80f1e9:	5f                   	pop    %edi
  80f1ea:	5d                   	pop    %ebp
  80f1eb:	c3                   	ret    

0080f1ec <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f1ec:	55                   	push   %ebp
  80f1ed:	89 e5                	mov    %esp,%ebp
  80f1ef:	57                   	push   %edi
  80f1f0:	56                   	push   %esi
  80f1f1:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1f4:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f1f7:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f1fa:	39 c6                	cmp    %eax,%esi
  80f1fc:	73 32                	jae    80f230 <memmove+0x44>
  80f1fe:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f201:	39 c2                	cmp    %eax,%edx
  80f203:	76 2b                	jbe    80f230 <memmove+0x44>
		s += n;
		d += n;
  80f205:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f208:	89 fe                	mov    %edi,%esi
  80f20a:	09 ce                	or     %ecx,%esi
  80f20c:	09 d6                	or     %edx,%esi
  80f20e:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f214:	75 0e                	jne    80f224 <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f216:	83 ef 04             	sub    $0x4,%edi
  80f219:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f21c:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f21f:	fd                   	std    
  80f220:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f222:	eb 09                	jmp    80f22d <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f224:	83 ef 01             	sub    $0x1,%edi
  80f227:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f22a:	fd                   	std    
  80f22b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f22d:	fc                   	cld    
  80f22e:	eb 1a                	jmp    80f24a <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f230:	89 c2                	mov    %eax,%edx
  80f232:	09 ca                	or     %ecx,%edx
  80f234:	09 f2                	or     %esi,%edx
  80f236:	f6 c2 03             	test   $0x3,%dl
  80f239:	75 0a                	jne    80f245 <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f23b:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f23e:	89 c7                	mov    %eax,%edi
  80f240:	fc                   	cld    
  80f241:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f243:	eb 05                	jmp    80f24a <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80f245:	89 c7                	mov    %eax,%edi
  80f247:	fc                   	cld    
  80f248:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f24a:	5e                   	pop    %esi
  80f24b:	5f                   	pop    %edi
  80f24c:	5d                   	pop    %ebp
  80f24d:	c3                   	ret    

0080f24e <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f24e:	55                   	push   %ebp
  80f24f:	89 e5                	mov    %esp,%ebp
  80f251:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f254:	ff 75 10             	pushl  0x10(%ebp)
  80f257:	ff 75 0c             	pushl  0xc(%ebp)
  80f25a:	ff 75 08             	pushl  0x8(%ebp)
  80f25d:	e8 8a ff ff ff       	call   80f1ec <memmove>
}
  80f262:	c9                   	leave  
  80f263:	c3                   	ret    

0080f264 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f264:	55                   	push   %ebp
  80f265:	89 e5                	mov    %esp,%ebp
  80f267:	56                   	push   %esi
  80f268:	53                   	push   %ebx
  80f269:	8b 45 08             	mov    0x8(%ebp),%eax
  80f26c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f26f:	89 c6                	mov    %eax,%esi
  80f271:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f274:	39 f0                	cmp    %esi,%eax
  80f276:	74 1c                	je     80f294 <memcmp+0x30>
		if (*s1 != *s2)
  80f278:	0f b6 08             	movzbl (%eax),%ecx
  80f27b:	0f b6 1a             	movzbl (%edx),%ebx
  80f27e:	38 d9                	cmp    %bl,%cl
  80f280:	75 08                	jne    80f28a <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f282:	83 c0 01             	add    $0x1,%eax
  80f285:	83 c2 01             	add    $0x1,%edx
  80f288:	eb ea                	jmp    80f274 <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80f28a:	0f b6 c1             	movzbl %cl,%eax
  80f28d:	0f b6 db             	movzbl %bl,%ebx
  80f290:	29 d8                	sub    %ebx,%eax
  80f292:	eb 05                	jmp    80f299 <memcmp+0x35>
	}

	return 0;
  80f294:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f299:	5b                   	pop    %ebx
  80f29a:	5e                   	pop    %esi
  80f29b:	5d                   	pop    %ebp
  80f29c:	c3                   	ret    

0080f29d <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f29d:	55                   	push   %ebp
  80f29e:	89 e5                	mov    %esp,%ebp
  80f2a0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2a3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f2a6:	89 c2                	mov    %eax,%edx
  80f2a8:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f2ab:	39 d0                	cmp    %edx,%eax
  80f2ad:	73 09                	jae    80f2b8 <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f2af:	38 08                	cmp    %cl,(%eax)
  80f2b1:	74 05                	je     80f2b8 <memfind+0x1b>
	for (; s < ends; s++)
  80f2b3:	83 c0 01             	add    $0x1,%eax
  80f2b6:	eb f3                	jmp    80f2ab <memfind+0xe>
			break;
	return (void *) s;
}
  80f2b8:	5d                   	pop    %ebp
  80f2b9:	c3                   	ret    

0080f2ba <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f2ba:	55                   	push   %ebp
  80f2bb:	89 e5                	mov    %esp,%ebp
  80f2bd:	57                   	push   %edi
  80f2be:	56                   	push   %esi
  80f2bf:	53                   	push   %ebx
  80f2c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f2c3:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f2c6:	eb 03                	jmp    80f2cb <strtol+0x11>
		s++;
  80f2c8:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f2cb:	0f b6 01             	movzbl (%ecx),%eax
  80f2ce:	3c 20                	cmp    $0x20,%al
  80f2d0:	74 f6                	je     80f2c8 <strtol+0xe>
  80f2d2:	3c 09                	cmp    $0x9,%al
  80f2d4:	74 f2                	je     80f2c8 <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80f2d6:	3c 2b                	cmp    $0x2b,%al
  80f2d8:	74 2a                	je     80f304 <strtol+0x4a>
	int neg = 0;
  80f2da:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f2df:	3c 2d                	cmp    $0x2d,%al
  80f2e1:	74 2b                	je     80f30e <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f2e3:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f2e9:	75 0f                	jne    80f2fa <strtol+0x40>
  80f2eb:	80 39 30             	cmpb   $0x30,(%ecx)
  80f2ee:	74 28                	je     80f318 <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f2f0:	85 db                	test   %ebx,%ebx
  80f2f2:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f2f7:	0f 44 d8             	cmove  %eax,%ebx
  80f2fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2ff:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f302:	eb 50                	jmp    80f354 <strtol+0x9a>
		s++;
  80f304:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f307:	bf 00 00 00 00       	mov    $0x0,%edi
  80f30c:	eb d5                	jmp    80f2e3 <strtol+0x29>
		s++, neg = 1;
  80f30e:	83 c1 01             	add    $0x1,%ecx
  80f311:	bf 01 00 00 00       	mov    $0x1,%edi
  80f316:	eb cb                	jmp    80f2e3 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f318:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f31c:	74 0e                	je     80f32c <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80f31e:	85 db                	test   %ebx,%ebx
  80f320:	75 d8                	jne    80f2fa <strtol+0x40>
		s++, base = 8;
  80f322:	83 c1 01             	add    $0x1,%ecx
  80f325:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f32a:	eb ce                	jmp    80f2fa <strtol+0x40>
		s += 2, base = 16;
  80f32c:	83 c1 02             	add    $0x2,%ecx
  80f32f:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f334:	eb c4                	jmp    80f2fa <strtol+0x40>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80f336:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f339:	89 f3                	mov    %esi,%ebx
  80f33b:	80 fb 19             	cmp    $0x19,%bl
  80f33e:	77 29                	ja     80f369 <strtol+0xaf>
			dig = *s - 'a' + 10;
  80f340:	0f be d2             	movsbl %dl,%edx
  80f343:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f346:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f349:	7d 30                	jge    80f37b <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80f34b:	83 c1 01             	add    $0x1,%ecx
  80f34e:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f352:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f354:	0f b6 11             	movzbl (%ecx),%edx
  80f357:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f35a:	89 f3                	mov    %esi,%ebx
  80f35c:	80 fb 09             	cmp    $0x9,%bl
  80f35f:	77 d5                	ja     80f336 <strtol+0x7c>
			dig = *s - '0';
  80f361:	0f be d2             	movsbl %dl,%edx
  80f364:	83 ea 30             	sub    $0x30,%edx
  80f367:	eb dd                	jmp    80f346 <strtol+0x8c>
		else if (*s >= 'A' && *s <= 'Z')
  80f369:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f36c:	89 f3                	mov    %esi,%ebx
  80f36e:	80 fb 19             	cmp    $0x19,%bl
  80f371:	77 08                	ja     80f37b <strtol+0xc1>
			dig = *s - 'A' + 10;
  80f373:	0f be d2             	movsbl %dl,%edx
  80f376:	83 ea 37             	sub    $0x37,%edx
  80f379:	eb cb                	jmp    80f346 <strtol+0x8c>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f37b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f37f:	74 05                	je     80f386 <strtol+0xcc>
		*endptr = (char *) s;
  80f381:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f384:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f386:	89 c2                	mov    %eax,%edx
  80f388:	f7 da                	neg    %edx
  80f38a:	85 ff                	test   %edi,%edi
  80f38c:	0f 45 c2             	cmovne %edx,%eax
}
  80f38f:	5b                   	pop    %ebx
  80f390:	5e                   	pop    %esi
  80f391:	5f                   	pop    %edi
  80f392:	5d                   	pop    %ebp
  80f393:	c3                   	ret    

0080f394 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f394:	55                   	push   %ebp
  80f395:	89 e5                	mov    %esp,%ebp
  80f397:	57                   	push   %edi
  80f398:	56                   	push   %esi
  80f399:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f39a:	b8 00 00 00 00       	mov    $0x0,%eax
  80f39f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3a2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3a5:	89 c3                	mov    %eax,%ebx
  80f3a7:	89 c7                	mov    %eax,%edi
  80f3a9:	89 c6                	mov    %eax,%esi
  80f3ab:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f3ad:	5b                   	pop    %ebx
  80f3ae:	5e                   	pop    %esi
  80f3af:	5f                   	pop    %edi
  80f3b0:	5d                   	pop    %ebp
  80f3b1:	c3                   	ret    

0080f3b2 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f3b2:	55                   	push   %ebp
  80f3b3:	89 e5                	mov    %esp,%ebp
  80f3b5:	57                   	push   %edi
  80f3b6:	56                   	push   %esi
  80f3b7:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f3b8:	ba 00 00 00 00       	mov    $0x0,%edx
  80f3bd:	b8 01 00 00 00       	mov    $0x1,%eax
  80f3c2:	89 d1                	mov    %edx,%ecx
  80f3c4:	89 d3                	mov    %edx,%ebx
  80f3c6:	89 d7                	mov    %edx,%edi
  80f3c8:	89 d6                	mov    %edx,%esi
  80f3ca:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f3cc:	5b                   	pop    %ebx
  80f3cd:	5e                   	pop    %esi
  80f3ce:	5f                   	pop    %edi
  80f3cf:	5d                   	pop    %ebp
  80f3d0:	c3                   	ret    

0080f3d1 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f3d1:	55                   	push   %ebp
  80f3d2:	89 e5                	mov    %esp,%ebp
  80f3d4:	57                   	push   %edi
  80f3d5:	56                   	push   %esi
  80f3d6:	53                   	push   %ebx
  80f3d7:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3da:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f3df:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3e2:	b8 03 00 00 00       	mov    $0x3,%eax
  80f3e7:	89 cb                	mov    %ecx,%ebx
  80f3e9:	89 cf                	mov    %ecx,%edi
  80f3eb:	89 ce                	mov    %ecx,%esi
  80f3ed:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f3ef:	85 c0                	test   %eax,%eax
  80f3f1:	7f 08                	jg     80f3fb <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f3f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3f6:	5b                   	pop    %ebx
  80f3f7:	5e                   	pop    %esi
  80f3f8:	5f                   	pop    %edi
  80f3f9:	5d                   	pop    %ebp
  80f3fa:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3fb:	83 ec 0c             	sub    $0xc,%esp
  80f3fe:	50                   	push   %eax
  80f3ff:	6a 03                	push   $0x3
  80f401:	68 88 3e 81 00       	push   $0x813e88
  80f406:	6a 43                	push   $0x43
  80f408:	68 a5 3e 81 00       	push   $0x813ea5
  80f40d:	e8 f7 f3 ff ff       	call   80e809 <_panic>

0080f412 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f412:	55                   	push   %ebp
  80f413:	89 e5                	mov    %esp,%ebp
  80f415:	57                   	push   %edi
  80f416:	56                   	push   %esi
  80f417:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f418:	ba 00 00 00 00       	mov    $0x0,%edx
  80f41d:	b8 02 00 00 00       	mov    $0x2,%eax
  80f422:	89 d1                	mov    %edx,%ecx
  80f424:	89 d3                	mov    %edx,%ebx
  80f426:	89 d7                	mov    %edx,%edi
  80f428:	89 d6                	mov    %edx,%esi
  80f42a:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f42c:	5b                   	pop    %ebx
  80f42d:	5e                   	pop    %esi
  80f42e:	5f                   	pop    %edi
  80f42f:	5d                   	pop    %ebp
  80f430:	c3                   	ret    

0080f431 <sys_yield>:

void
sys_yield(void)
{
  80f431:	55                   	push   %ebp
  80f432:	89 e5                	mov    %esp,%ebp
  80f434:	57                   	push   %edi
  80f435:	56                   	push   %esi
  80f436:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f437:	ba 00 00 00 00       	mov    $0x0,%edx
  80f43c:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f441:	89 d1                	mov    %edx,%ecx
  80f443:	89 d3                	mov    %edx,%ebx
  80f445:	89 d7                	mov    %edx,%edi
  80f447:	89 d6                	mov    %edx,%esi
  80f449:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f44b:	5b                   	pop    %ebx
  80f44c:	5e                   	pop    %esi
  80f44d:	5f                   	pop    %edi
  80f44e:	5d                   	pop    %ebp
  80f44f:	c3                   	ret    

0080f450 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f450:	55                   	push   %ebp
  80f451:	89 e5                	mov    %esp,%ebp
  80f453:	57                   	push   %edi
  80f454:	56                   	push   %esi
  80f455:	53                   	push   %ebx
  80f456:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f459:	be 00 00 00 00       	mov    $0x0,%esi
  80f45e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f461:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f464:	b8 04 00 00 00       	mov    $0x4,%eax
  80f469:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f46c:	89 f7                	mov    %esi,%edi
  80f46e:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f470:	85 c0                	test   %eax,%eax
  80f472:	7f 08                	jg     80f47c <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f474:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f477:	5b                   	pop    %ebx
  80f478:	5e                   	pop    %esi
  80f479:	5f                   	pop    %edi
  80f47a:	5d                   	pop    %ebp
  80f47b:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f47c:	83 ec 0c             	sub    $0xc,%esp
  80f47f:	50                   	push   %eax
  80f480:	6a 04                	push   $0x4
  80f482:	68 88 3e 81 00       	push   $0x813e88
  80f487:	6a 43                	push   $0x43
  80f489:	68 a5 3e 81 00       	push   $0x813ea5
  80f48e:	e8 76 f3 ff ff       	call   80e809 <_panic>

0080f493 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f493:	55                   	push   %ebp
  80f494:	89 e5                	mov    %esp,%ebp
  80f496:	57                   	push   %edi
  80f497:	56                   	push   %esi
  80f498:	53                   	push   %ebx
  80f499:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f49c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f49f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4a2:	b8 05 00 00 00       	mov    $0x5,%eax
  80f4a7:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f4aa:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f4ad:	8b 75 18             	mov    0x18(%ebp),%esi
  80f4b0:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4b2:	85 c0                	test   %eax,%eax
  80f4b4:	7f 08                	jg     80f4be <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f4b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4b9:	5b                   	pop    %ebx
  80f4ba:	5e                   	pop    %esi
  80f4bb:	5f                   	pop    %edi
  80f4bc:	5d                   	pop    %ebp
  80f4bd:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4be:	83 ec 0c             	sub    $0xc,%esp
  80f4c1:	50                   	push   %eax
  80f4c2:	6a 05                	push   $0x5
  80f4c4:	68 88 3e 81 00       	push   $0x813e88
  80f4c9:	6a 43                	push   $0x43
  80f4cb:	68 a5 3e 81 00       	push   $0x813ea5
  80f4d0:	e8 34 f3 ff ff       	call   80e809 <_panic>

0080f4d5 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f4d5:	55                   	push   %ebp
  80f4d6:	89 e5                	mov    %esp,%ebp
  80f4d8:	57                   	push   %edi
  80f4d9:	56                   	push   %esi
  80f4da:	53                   	push   %ebx
  80f4db:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f4de:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4e3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4e9:	b8 06 00 00 00       	mov    $0x6,%eax
  80f4ee:	89 df                	mov    %ebx,%edi
  80f4f0:	89 de                	mov    %ebx,%esi
  80f4f2:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4f4:	85 c0                	test   %eax,%eax
  80f4f6:	7f 08                	jg     80f500 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f4f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4fb:	5b                   	pop    %ebx
  80f4fc:	5e                   	pop    %esi
  80f4fd:	5f                   	pop    %edi
  80f4fe:	5d                   	pop    %ebp
  80f4ff:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f500:	83 ec 0c             	sub    $0xc,%esp
  80f503:	50                   	push   %eax
  80f504:	6a 06                	push   $0x6
  80f506:	68 88 3e 81 00       	push   $0x813e88
  80f50b:	6a 43                	push   $0x43
  80f50d:	68 a5 3e 81 00       	push   $0x813ea5
  80f512:	e8 f2 f2 ff ff       	call   80e809 <_panic>

0080f517 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f517:	55                   	push   %ebp
  80f518:	89 e5                	mov    %esp,%ebp
  80f51a:	57                   	push   %edi
  80f51b:	56                   	push   %esi
  80f51c:	53                   	push   %ebx
  80f51d:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f520:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f525:	8b 55 08             	mov    0x8(%ebp),%edx
  80f528:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f52b:	b8 08 00 00 00       	mov    $0x8,%eax
  80f530:	89 df                	mov    %ebx,%edi
  80f532:	89 de                	mov    %ebx,%esi
  80f534:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f536:	85 c0                	test   %eax,%eax
  80f538:	7f 08                	jg     80f542 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f53a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f53d:	5b                   	pop    %ebx
  80f53e:	5e                   	pop    %esi
  80f53f:	5f                   	pop    %edi
  80f540:	5d                   	pop    %ebp
  80f541:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f542:	83 ec 0c             	sub    $0xc,%esp
  80f545:	50                   	push   %eax
  80f546:	6a 08                	push   $0x8
  80f548:	68 88 3e 81 00       	push   $0x813e88
  80f54d:	6a 43                	push   $0x43
  80f54f:	68 a5 3e 81 00       	push   $0x813ea5
  80f554:	e8 b0 f2 ff ff       	call   80e809 <_panic>

0080f559 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f559:	55                   	push   %ebp
  80f55a:	89 e5                	mov    %esp,%ebp
  80f55c:	57                   	push   %edi
  80f55d:	56                   	push   %esi
  80f55e:	53                   	push   %ebx
  80f55f:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f562:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f567:	8b 55 08             	mov    0x8(%ebp),%edx
  80f56a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f56d:	b8 09 00 00 00       	mov    $0x9,%eax
  80f572:	89 df                	mov    %ebx,%edi
  80f574:	89 de                	mov    %ebx,%esi
  80f576:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f578:	85 c0                	test   %eax,%eax
  80f57a:	7f 08                	jg     80f584 <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f57c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f57f:	5b                   	pop    %ebx
  80f580:	5e                   	pop    %esi
  80f581:	5f                   	pop    %edi
  80f582:	5d                   	pop    %ebp
  80f583:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f584:	83 ec 0c             	sub    $0xc,%esp
  80f587:	50                   	push   %eax
  80f588:	6a 09                	push   $0x9
  80f58a:	68 88 3e 81 00       	push   $0x813e88
  80f58f:	6a 43                	push   $0x43
  80f591:	68 a5 3e 81 00       	push   $0x813ea5
  80f596:	e8 6e f2 ff ff       	call   80e809 <_panic>

0080f59b <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f59b:	55                   	push   %ebp
  80f59c:	89 e5                	mov    %esp,%ebp
  80f59e:	57                   	push   %edi
  80f59f:	56                   	push   %esi
  80f5a0:	53                   	push   %ebx
  80f5a1:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f5a4:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f5a9:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5ac:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5af:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f5b4:	89 df                	mov    %ebx,%edi
  80f5b6:	89 de                	mov    %ebx,%esi
  80f5b8:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f5ba:	85 c0                	test   %eax,%eax
  80f5bc:	7f 08                	jg     80f5c6 <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f5be:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f5c1:	5b                   	pop    %ebx
  80f5c2:	5e                   	pop    %esi
  80f5c3:	5f                   	pop    %edi
  80f5c4:	5d                   	pop    %ebp
  80f5c5:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f5c6:	83 ec 0c             	sub    $0xc,%esp
  80f5c9:	50                   	push   %eax
  80f5ca:	6a 0a                	push   $0xa
  80f5cc:	68 88 3e 81 00       	push   $0x813e88
  80f5d1:	6a 43                	push   $0x43
  80f5d3:	68 a5 3e 81 00       	push   $0x813ea5
  80f5d8:	e8 2c f2 ff ff       	call   80e809 <_panic>

0080f5dd <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f5dd:	55                   	push   %ebp
  80f5de:	89 e5                	mov    %esp,%ebp
  80f5e0:	57                   	push   %edi
  80f5e1:	56                   	push   %esi
  80f5e2:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f5e3:	8b 55 08             	mov    0x8(%ebp),%edx
  80f5e6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f5e9:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f5ee:	be 00 00 00 00       	mov    $0x0,%esi
  80f5f3:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f5f6:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f5f9:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f5fb:	5b                   	pop    %ebx
  80f5fc:	5e                   	pop    %esi
  80f5fd:	5f                   	pop    %edi
  80f5fe:	5d                   	pop    %ebp
  80f5ff:	c3                   	ret    

0080f600 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f600:	55                   	push   %ebp
  80f601:	89 e5                	mov    %esp,%ebp
  80f603:	57                   	push   %edi
  80f604:	56                   	push   %esi
  80f605:	53                   	push   %ebx
  80f606:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f609:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f60e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f611:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f616:	89 cb                	mov    %ecx,%ebx
  80f618:	89 cf                	mov    %ecx,%edi
  80f61a:	89 ce                	mov    %ecx,%esi
  80f61c:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f61e:	85 c0                	test   %eax,%eax
  80f620:	7f 08                	jg     80f62a <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f622:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f625:	5b                   	pop    %ebx
  80f626:	5e                   	pop    %esi
  80f627:	5f                   	pop    %edi
  80f628:	5d                   	pop    %ebp
  80f629:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f62a:	83 ec 0c             	sub    $0xc,%esp
  80f62d:	50                   	push   %eax
  80f62e:	6a 0d                	push   $0xd
  80f630:	68 88 3e 81 00       	push   $0x813e88
  80f635:	6a 43                	push   $0x43
  80f637:	68 a5 3e 81 00       	push   $0x813ea5
  80f63c:	e8 c8 f1 ff ff       	call   80e809 <_panic>

0080f641 <sys_map_kernel_page>:

int
sys_map_kernel_page(void* kpage, void* va)
{
  80f641:	55                   	push   %ebp
  80f642:	89 e5                	mov    %esp,%ebp
  80f644:	57                   	push   %edi
  80f645:	56                   	push   %esi
  80f646:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f647:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f64c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f64f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f652:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f657:	89 df                	mov    %ebx,%edi
  80f659:	89 de                	mov    %ebx,%esi
  80f65b:	cd 30                	int    $0x30
	return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}
  80f65d:	5b                   	pop    %ebx
  80f65e:	5e                   	pop    %esi
  80f65f:	5f                   	pop    %edi
  80f660:	5d                   	pop    %ebp
  80f661:	c3                   	ret    

0080f662 <sys_sbrk>:

int
sys_sbrk(uint32_t inc)
{
  80f662:	55                   	push   %ebp
  80f663:	89 e5                	mov    %esp,%ebp
  80f665:	57                   	push   %edi
  80f666:	56                   	push   %esi
  80f667:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f668:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f66d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f670:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f675:	89 cb                	mov    %ecx,%ebx
  80f677:	89 cf                	mov    %ecx,%edi
  80f679:	89 ce                	mov    %ecx,%esi
  80f67b:	cd 30                	int    $0x30
	return syscall(SYS_sbrk, 0, (uint32_t)inc, (uint32_t)0, 0, 0, 0);
}
  80f67d:	5b                   	pop    %ebx
  80f67e:	5e                   	pop    %esi
  80f67f:	5f                   	pop    %edi
  80f680:	5d                   	pop    %ebp
  80f681:	c3                   	ret    

0080f682 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f682:	55                   	push   %ebp
  80f683:	89 e5                	mov    %esp,%ebp
  80f685:	57                   	push   %edi
  80f686:	56                   	push   %esi
  80f687:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f688:	ba 00 00 00 00       	mov    $0x0,%edx
  80f68d:	b8 10 00 00 00       	mov    $0x10,%eax
  80f692:	89 d1                	mov    %edx,%ecx
  80f694:	89 d3                	mov    %edx,%ebx
  80f696:	89 d7                	mov    %edx,%edi
  80f698:	89 d6                	mov    %edx,%esi
  80f69a:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f69c:	5b                   	pop    %ebx
  80f69d:	5e                   	pop    %esi
  80f69e:	5f                   	pop    %edi
  80f69f:	5d                   	pop    %ebp
  80f6a0:	c3                   	ret    

0080f6a1 <sys_net_send>:

int
sys_net_send(const void *buf, uint32_t len)
{
  80f6a1:	55                   	push   %ebp
  80f6a2:	89 e5                	mov    %esp,%ebp
  80f6a4:	57                   	push   %edi
  80f6a5:	56                   	push   %esi
  80f6a6:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f6a7:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f6ac:	8b 55 08             	mov    0x8(%ebp),%edx
  80f6af:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f6b2:	b8 11 00 00 00       	mov    $0x11,%eax
  80f6b7:	89 df                	mov    %ebx,%edi
  80f6b9:	89 de                	mov    %ebx,%esi
  80f6bb:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_send, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f6bd:	5b                   	pop    %ebx
  80f6be:	5e                   	pop    %esi
  80f6bf:	5f                   	pop    %edi
  80f6c0:	5d                   	pop    %ebp
  80f6c1:	c3                   	ret    

0080f6c2 <sys_net_recv>:

int
sys_net_recv(void *buf, uint32_t len)
{
  80f6c2:	55                   	push   %ebp
  80f6c3:	89 e5                	mov    %esp,%ebp
  80f6c5:	57                   	push   %edi
  80f6c6:	56                   	push   %esi
  80f6c7:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f6c8:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f6cd:	8b 55 08             	mov    0x8(%ebp),%edx
  80f6d0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f6d3:	b8 12 00 00 00       	mov    $0x12,%eax
  80f6d8:	89 df                	mov    %ebx,%edi
  80f6da:	89 de                	mov    %ebx,%esi
  80f6dc:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_recv, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f6de:	5b                   	pop    %ebx
  80f6df:	5e                   	pop    %esi
  80f6e0:	5f                   	pop    %edi
  80f6e1:	5d                   	pop    %ebp
  80f6e2:	c3                   	ret    

0080f6e3 <sys_clear_access_bit>:
int
sys_clear_access_bit(envid_t envid, void *va)
{
  80f6e3:	55                   	push   %ebp
  80f6e4:	89 e5                	mov    %esp,%ebp
  80f6e6:	57                   	push   %edi
  80f6e7:	56                   	push   %esi
  80f6e8:	53                   	push   %ebx
  80f6e9:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f6ec:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f6f1:	8b 55 08             	mov    0x8(%ebp),%edx
  80f6f4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f6f7:	b8 13 00 00 00       	mov    $0x13,%eax
  80f6fc:	89 df                	mov    %ebx,%edi
  80f6fe:	89 de                	mov    %ebx,%esi
  80f700:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f702:	85 c0                	test   %eax,%eax
  80f704:	7f 08                	jg     80f70e <sys_clear_access_bit+0x2b>
	return syscall(SYS_clear_access_bit, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f706:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f709:	5b                   	pop    %ebx
  80f70a:	5e                   	pop    %esi
  80f70b:	5f                   	pop    %edi
  80f70c:	5d                   	pop    %ebp
  80f70d:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f70e:	83 ec 0c             	sub    $0xc,%esp
  80f711:	50                   	push   %eax
  80f712:	6a 13                	push   $0x13
  80f714:	68 88 3e 81 00       	push   $0x813e88
  80f719:	6a 43                	push   $0x43
  80f71b:	68 a5 3e 81 00       	push   $0x813ea5
  80f720:	e8 e4 f0 ff ff       	call   80e809 <_panic>

0080f725 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  80f725:	55                   	push   %ebp
  80f726:	89 e5                	mov    %esp,%ebp
  80f728:	53                   	push   %ebx
  80f729:	83 ec 04             	sub    $0x4,%esp
	int r;
	//lab5 bug?
	if((uvpt[pn]) & PTE_SHARE){
  80f72c:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f733:	f6 c5 04             	test   $0x4,%ch
  80f736:	75 45                	jne    80f77d <duppage+0x58>
							uvpt[pn] & PTE_SYSCALL);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_W)) == (PTE_P | PTE_U | PTE_W)){
  80f738:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f73f:	83 e1 07             	and    $0x7,%ecx
  80f742:	83 f9 07             	cmp    $0x7,%ecx
  80f745:	74 6f                	je     80f7b6 <duppage+0x91>
						 PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_COW)) == (PTE_P | PTE_U | PTE_COW)){
  80f747:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f74e:	81 e1 05 08 00 00    	and    $0x805,%ecx
  80f754:	81 f9 05 08 00 00    	cmp    $0x805,%ecx
  80f75a:	0f 84 b6 00 00 00    	je     80f816 <duppage+0xf1>
						PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U)) == (PTE_P | PTE_U)){
  80f760:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f767:	83 e1 05             	and    $0x5,%ecx
  80f76a:	83 f9 05             	cmp    $0x5,%ecx
  80f76d:	0f 84 d7 00 00 00    	je     80f84a <duppage+0x125>
	}

	// LAB 4: Your code here.
	// panic("duppage not implemented");
	return 0;
}
  80f773:	b8 00 00 00 00       	mov    $0x0,%eax
  80f778:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f77b:	c9                   	leave  
  80f77c:	c3                   	ret    
							uvpt[pn] & PTE_SYSCALL);
  80f77d:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f784:	c1 e2 0c             	shl    $0xc,%edx
  80f787:	83 ec 0c             	sub    $0xc,%esp
  80f78a:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  80f790:	51                   	push   %ecx
  80f791:	52                   	push   %edx
  80f792:	50                   	push   %eax
  80f793:	52                   	push   %edx
  80f794:	6a 00                	push   $0x0
  80f796:	e8 f8 fc ff ff       	call   80f493 <sys_page_map>
		if(r < 0)
  80f79b:	83 c4 20             	add    $0x20,%esp
  80f79e:	85 c0                	test   %eax,%eax
  80f7a0:	79 d1                	jns    80f773 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f7a2:	83 ec 04             	sub    $0x4,%esp
  80f7a5:	68 b3 3e 81 00       	push   $0x813eb3
  80f7aa:	6a 54                	push   $0x54
  80f7ac:	68 c9 3e 81 00       	push   $0x813ec9
  80f7b1:	e8 53 f0 ff ff       	call   80e809 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f7b6:	89 d3                	mov    %edx,%ebx
  80f7b8:	c1 e3 0c             	shl    $0xc,%ebx
  80f7bb:	83 ec 0c             	sub    $0xc,%esp
  80f7be:	68 05 08 00 00       	push   $0x805
  80f7c3:	53                   	push   %ebx
  80f7c4:	50                   	push   %eax
  80f7c5:	53                   	push   %ebx
  80f7c6:	6a 00                	push   $0x0
  80f7c8:	e8 c6 fc ff ff       	call   80f493 <sys_page_map>
		if(r < 0)
  80f7cd:	83 c4 20             	add    $0x20,%esp
  80f7d0:	85 c0                	test   %eax,%eax
  80f7d2:	78 2e                	js     80f802 <duppage+0xdd>
		r = sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE),
  80f7d4:	83 ec 0c             	sub    $0xc,%esp
  80f7d7:	68 05 08 00 00       	push   $0x805
  80f7dc:	53                   	push   %ebx
  80f7dd:	6a 00                	push   $0x0
  80f7df:	53                   	push   %ebx
  80f7e0:	6a 00                	push   $0x0
  80f7e2:	e8 ac fc ff ff       	call   80f493 <sys_page_map>
		if(r < 0)
  80f7e7:	83 c4 20             	add    $0x20,%esp
  80f7ea:	85 c0                	test   %eax,%eax
  80f7ec:	79 85                	jns    80f773 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f7ee:	83 ec 04             	sub    $0x4,%esp
  80f7f1:	68 b3 3e 81 00       	push   $0x813eb3
  80f7f6:	6a 5f                	push   $0x5f
  80f7f8:	68 c9 3e 81 00       	push   $0x813ec9
  80f7fd:	e8 07 f0 ff ff       	call   80e809 <_panic>
			panic("sys_page_map() panic\n");
  80f802:	83 ec 04             	sub    $0x4,%esp
  80f805:	68 b3 3e 81 00       	push   $0x813eb3
  80f80a:	6a 5b                	push   $0x5b
  80f80c:	68 c9 3e 81 00       	push   $0x813ec9
  80f811:	e8 f3 ef ff ff       	call   80e809 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f816:	c1 e2 0c             	shl    $0xc,%edx
  80f819:	83 ec 0c             	sub    $0xc,%esp
  80f81c:	68 05 08 00 00       	push   $0x805
  80f821:	52                   	push   %edx
  80f822:	50                   	push   %eax
  80f823:	52                   	push   %edx
  80f824:	6a 00                	push   $0x0
  80f826:	e8 68 fc ff ff       	call   80f493 <sys_page_map>
		if(r < 0)
  80f82b:	83 c4 20             	add    $0x20,%esp
  80f82e:	85 c0                	test   %eax,%eax
  80f830:	0f 89 3d ff ff ff    	jns    80f773 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f836:	83 ec 04             	sub    $0x4,%esp
  80f839:	68 b3 3e 81 00       	push   $0x813eb3
  80f83e:	6a 66                	push   $0x66
  80f840:	68 c9 3e 81 00       	push   $0x813ec9
  80f845:	e8 bf ef ff ff       	call   80e809 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f84a:	c1 e2 0c             	shl    $0xc,%edx
  80f84d:	83 ec 0c             	sub    $0xc,%esp
  80f850:	6a 05                	push   $0x5
  80f852:	52                   	push   %edx
  80f853:	50                   	push   %eax
  80f854:	52                   	push   %edx
  80f855:	6a 00                	push   $0x0
  80f857:	e8 37 fc ff ff       	call   80f493 <sys_page_map>
		if(r < 0)
  80f85c:	83 c4 20             	add    $0x20,%esp
  80f85f:	85 c0                	test   %eax,%eax
  80f861:	0f 89 0c ff ff ff    	jns    80f773 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f867:	83 ec 04             	sub    $0x4,%esp
  80f86a:	68 b3 3e 81 00       	push   $0x813eb3
  80f86f:	6a 6d                	push   $0x6d
  80f871:	68 c9 3e 81 00       	push   $0x813ec9
  80f876:	e8 8e ef ff ff       	call   80e809 <_panic>

0080f87b <pgfault>:
{
  80f87b:	55                   	push   %ebp
  80f87c:	89 e5                	mov    %esp,%ebp
  80f87e:	53                   	push   %ebx
  80f87f:	83 ec 04             	sub    $0x4,%esp
  80f882:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80f885:	8b 02                	mov    (%edx),%eax
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f887:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80f88b:	0f 84 99 00 00 00    	je     80f92a <pgfault+0xaf>
  80f891:	89 c2                	mov    %eax,%edx
  80f893:	c1 ea 16             	shr    $0x16,%edx
  80f896:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f89d:	f6 c2 01             	test   $0x1,%dl
  80f8a0:	0f 84 84 00 00 00    	je     80f92a <pgfault+0xaf>
		((uvpt[PGNUM(addr)] & (PTE_P | PTE_COW)) 
  80f8a6:	89 c2                	mov    %eax,%edx
  80f8a8:	c1 ea 0c             	shr    $0xc,%edx
  80f8ab:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f8b2:	81 e2 01 08 00 00    	and    $0x801,%edx
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f8b8:	81 fa 01 08 00 00    	cmp    $0x801,%edx
  80f8be:	75 6a                	jne    80f92a <pgfault+0xaf>
	addr = ROUNDDOWN(addr, PGSIZE);
  80f8c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f8c5:	89 c3                	mov    %eax,%ebx
	ret = sys_page_alloc(0, (void *)PFTEMP, PTE_P | PTE_U | PTE_W);
  80f8c7:	83 ec 04             	sub    $0x4,%esp
  80f8ca:	6a 07                	push   $0x7
  80f8cc:	68 00 f0 7f 00       	push   $0x7ff000
  80f8d1:	6a 00                	push   $0x0
  80f8d3:	e8 78 fb ff ff       	call   80f450 <sys_page_alloc>
	if(ret < 0)
  80f8d8:	83 c4 10             	add    $0x10,%esp
  80f8db:	85 c0                	test   %eax,%eax
  80f8dd:	78 5f                	js     80f93e <pgfault+0xc3>
	memcpy((void *)PFTEMP, (void *)addr, PGSIZE);
  80f8df:	83 ec 04             	sub    $0x4,%esp
  80f8e2:	68 00 10 00 00       	push   $0x1000
  80f8e7:	53                   	push   %ebx
  80f8e8:	68 00 f0 7f 00       	push   $0x7ff000
  80f8ed:	e8 5c f9 ff ff       	call   80f24e <memcpy>
	ret = sys_page_map(0, PFTEMP, 0, addr,  PTE_P | PTE_U | PTE_W);
  80f8f2:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f8f9:	53                   	push   %ebx
  80f8fa:	6a 00                	push   $0x0
  80f8fc:	68 00 f0 7f 00       	push   $0x7ff000
  80f901:	6a 00                	push   $0x0
  80f903:	e8 8b fb ff ff       	call   80f493 <sys_page_map>
	if(ret < 0)
  80f908:	83 c4 20             	add    $0x20,%esp
  80f90b:	85 c0                	test   %eax,%eax
  80f90d:	78 43                	js     80f952 <pgfault+0xd7>
	ret = sys_page_unmap(0, (void *)PFTEMP);
  80f90f:	83 ec 08             	sub    $0x8,%esp
  80f912:	68 00 f0 7f 00       	push   $0x7ff000
  80f917:	6a 00                	push   $0x0
  80f919:	e8 b7 fb ff ff       	call   80f4d5 <sys_page_unmap>
	if(ret < 0)
  80f91e:	83 c4 10             	add    $0x10,%esp
  80f921:	85 c0                	test   %eax,%eax
  80f923:	78 41                	js     80f966 <pgfault+0xeb>
}
  80f925:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f928:	c9                   	leave  
  80f929:	c3                   	ret    
		panic("panic at pgfault()\n");
  80f92a:	83 ec 04             	sub    $0x4,%esp
  80f92d:	68 d4 3e 81 00       	push   $0x813ed4
  80f932:	6a 26                	push   $0x26
  80f934:	68 c9 3e 81 00       	push   $0x813ec9
  80f939:	e8 cb ee ff ff       	call   80e809 <_panic>
		panic("panic in sys_page_alloc()\n");
  80f93e:	83 ec 04             	sub    $0x4,%esp
  80f941:	68 e8 3e 81 00       	push   $0x813ee8
  80f946:	6a 31                	push   $0x31
  80f948:	68 c9 3e 81 00       	push   $0x813ec9
  80f94d:	e8 b7 ee ff ff       	call   80e809 <_panic>
		panic("panic in sys_page_map()\n");
  80f952:	83 ec 04             	sub    $0x4,%esp
  80f955:	68 03 3f 81 00       	push   $0x813f03
  80f95a:	6a 36                	push   $0x36
  80f95c:	68 c9 3e 81 00       	push   $0x813ec9
  80f961:	e8 a3 ee ff ff       	call   80e809 <_panic>
		panic("panic in sys_page_unmap()\n");
  80f966:	83 ec 04             	sub    $0x4,%esp
  80f969:	68 1c 3f 81 00       	push   $0x813f1c
  80f96e:	6a 39                	push   $0x39
  80f970:	68 c9 3e 81 00       	push   $0x813ec9
  80f975:	e8 8f ee ff ff       	call   80e809 <_panic>

0080f97a <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f97a:	55                   	push   %ebp
  80f97b:	89 e5                	mov    %esp,%ebp
  80f97d:	57                   	push   %edi
  80f97e:	56                   	push   %esi
  80f97f:	53                   	push   %ebx
  80f980:	83 ec 18             	sub    $0x18,%esp
	int ret;
	set_pgfault_handler(pgfault);
  80f983:	68 7b f8 80 00       	push   $0x80f87b
  80f988:	e8 6a 17 00 00       	call   8110f7 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f98d:	b8 07 00 00 00       	mov    $0x7,%eax
  80f992:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f994:	83 c4 10             	add    $0x10,%esp
  80f997:	85 c0                	test   %eax,%eax
  80f999:	78 27                	js     80f9c2 <fork+0x48>
  80f99b:	89 c6                	mov    %eax,%esi
  80f99d:	89 c7                	mov    %eax,%edi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f99f:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f9a4:	75 48                	jne    80f9ee <fork+0x74>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f9a6:	e8 67 fa ff ff       	call   80f412 <sys_getenvid>
  80f9ab:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f9b0:	c1 e0 07             	shl    $0x7,%eax
  80f9b3:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f9b8:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
		return 0;
  80f9bd:	e9 90 00 00 00       	jmp    80fa52 <fork+0xd8>
		panic("the fork panic! at sys_exofork()\n");
  80f9c2:	83 ec 04             	sub    $0x4,%esp
  80f9c5:	68 38 3f 81 00       	push   $0x813f38
  80f9ca:	68 8c 00 00 00       	push   $0x8c
  80f9cf:	68 c9 3e 81 00       	push   $0x813ec9
  80f9d4:	e8 30 ee ff ff       	call   80e809 <_panic>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
			duppage(child_envid, PGNUM(i));
  80f9d9:	89 f8                	mov    %edi,%eax
  80f9db:	e8 45 fd ff ff       	call   80f725 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f9e0:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f9e6:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f9ec:	74 26                	je     80fa14 <fork+0x9a>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
  80f9ee:	89 d8                	mov    %ebx,%eax
  80f9f0:	c1 e8 16             	shr    $0x16,%eax
  80f9f3:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f9fa:	a8 01                	test   $0x1,%al
  80f9fc:	74 e2                	je     80f9e0 <fork+0x66>
  80f9fe:	89 da                	mov    %ebx,%edx
  80fa00:	c1 ea 0c             	shr    $0xc,%edx
  80fa03:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80fa0a:	83 e0 05             	and    $0x5,%eax
  80fa0d:	83 f8 05             	cmp    $0x5,%eax
  80fa10:	75 ce                	jne    80f9e0 <fork+0x66>
  80fa12:	eb c5                	jmp    80f9d9 <fork+0x5f>
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80fa14:	83 ec 04             	sub    $0x4,%esp
  80fa17:	6a 07                	push   $0x7
  80fa19:	68 00 f0 bf ee       	push   $0xeebff000
  80fa1e:	56                   	push   %esi
  80fa1f:	e8 2c fa ff ff       	call   80f450 <sys_page_alloc>
	if(ret < 0)
  80fa24:	83 c4 10             	add    $0x10,%esp
  80fa27:	85 c0                	test   %eax,%eax
  80fa29:	78 31                	js     80fa5c <fork+0xe2>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80fa2b:	83 ec 08             	sub    $0x8,%esp
  80fa2e:	68 66 11 81 00       	push   $0x811166
  80fa33:	56                   	push   %esi
  80fa34:	e8 62 fb ff ff       	call   80f59b <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80fa39:	83 c4 10             	add    $0x10,%esp
  80fa3c:	85 c0                	test   %eax,%eax
  80fa3e:	78 33                	js     80fa73 <fork+0xf9>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80fa40:	83 ec 08             	sub    $0x8,%esp
  80fa43:	6a 02                	push   $0x2
  80fa45:	56                   	push   %esi
  80fa46:	e8 cc fa ff ff       	call   80f517 <sys_env_set_status>
	if(ret < 0)
  80fa4b:	83 c4 10             	add    $0x10,%esp
  80fa4e:	85 c0                	test   %eax,%eax
  80fa50:	78 38                	js     80fa8a <fork+0x110>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
	// LAB 4: Your code here.
	// panic("fork not implemented");
}
  80fa52:	89 f0                	mov    %esi,%eax
  80fa54:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fa57:	5b                   	pop    %ebx
  80fa58:	5e                   	pop    %esi
  80fa59:	5f                   	pop    %edi
  80fa5a:	5d                   	pop    %ebp
  80fa5b:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80fa5c:	83 ec 04             	sub    $0x4,%esp
  80fa5f:	68 e8 3e 81 00       	push   $0x813ee8
  80fa64:	68 98 00 00 00       	push   $0x98
  80fa69:	68 c9 3e 81 00       	push   $0x813ec9
  80fa6e:	e8 96 ed ff ff       	call   80e809 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80fa73:	83 ec 04             	sub    $0x4,%esp
  80fa76:	68 5c 3f 81 00       	push   $0x813f5c
  80fa7b:	68 9b 00 00 00       	push   $0x9b
  80fa80:	68 c9 3e 81 00       	push   $0x813ec9
  80fa85:	e8 7f ed ff ff       	call   80e809 <_panic>
		panic("panic in sys_env_set_status()\n");
  80fa8a:	83 ec 04             	sub    $0x4,%esp
  80fa8d:	68 84 3f 81 00       	push   $0x813f84
  80fa92:	68 9e 00 00 00       	push   $0x9e
  80fa97:	68 c9 3e 81 00       	push   $0x813ec9
  80fa9c:	e8 68 ed ff ff       	call   80e809 <_panic>

0080faa1 <sfork>:

// Challenge!
int
sfork(void)
{
  80faa1:	55                   	push   %ebp
  80faa2:	89 e5                	mov    %esp,%ebp
  80faa4:	57                   	push   %edi
  80faa5:	56                   	push   %esi
  80faa6:	53                   	push   %ebx
  80faa7:	83 ec 18             	sub    $0x18,%esp
	// panic("sfork not implemented");
	// envid_t child_envid = sys_exofork();
	// return -E_INVAL;
	int ret;
	set_pgfault_handler(pgfault);
  80faaa:	68 7b f8 80 00       	push   $0x80f87b
  80faaf:	e8 43 16 00 00       	call   8110f7 <set_pgfault_handler>
  80fab4:	b8 07 00 00 00       	mov    $0x7,%eax
  80fab9:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80fabb:	83 c4 10             	add    $0x10,%esp
  80fabe:	85 c0                	test   %eax,%eax
  80fac0:	78 27                	js     80fae9 <sfork+0x48>
  80fac2:	89 c7                	mov    %eax,%edi
  80fac4:	89 c6                	mov    %eax,%esi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80fac6:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80facb:	75 55                	jne    80fb22 <sfork+0x81>
		thisenv = &envs[ENVX(sys_getenvid())];
  80facd:	e8 40 f9 ff ff       	call   80f412 <sys_getenvid>
  80fad2:	25 ff 03 00 00       	and    $0x3ff,%eax
  80fad7:	c1 e0 07             	shl    $0x7,%eax
  80fada:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fadf:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
		return 0;
  80fae4:	e9 d4 00 00 00       	jmp    80fbbd <sfork+0x11c>
		panic("the fork panic! at sys_exofork()\n");
  80fae9:	83 ec 04             	sub    $0x4,%esp
  80faec:	68 38 3f 81 00       	push   $0x813f38
  80faf1:	68 af 00 00 00       	push   $0xaf
  80faf6:	68 c9 3e 81 00       	push   $0x813ec9
  80fafb:	e8 09 ed ff ff       	call   80e809 <_panic>
		if(i == (USTACKTOP - PGSIZE))
			duppage(child_envid, PGNUM(i));
  80fb00:	ba fd eb 0e 00       	mov    $0xeebfd,%edx
  80fb05:	89 f0                	mov    %esi,%eax
  80fb07:	e8 19 fc ff ff       	call   80f725 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80fb0c:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80fb12:	81 fb ff df bf ee    	cmp    $0xeebfdfff,%ebx
  80fb18:	77 65                	ja     80fb7f <sfork+0xde>
		if(i == (USTACKTOP - PGSIZE))
  80fb1a:	81 fb 00 d0 bf ee    	cmp    $0xeebfd000,%ebx
  80fb20:	74 de                	je     80fb00 <sfork+0x5f>
		else if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U))){
  80fb22:	89 d8                	mov    %ebx,%eax
  80fb24:	c1 e8 16             	shr    $0x16,%eax
  80fb27:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fb2e:	a8 01                	test   $0x1,%al
  80fb30:	74 da                	je     80fb0c <sfork+0x6b>
  80fb32:	89 da                	mov    %ebx,%edx
  80fb34:	c1 ea 0c             	shr    $0xc,%edx
  80fb37:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80fb3e:	83 e0 05             	and    $0x5,%eax
  80fb41:	83 f8 05             	cmp    $0x5,%eax
  80fb44:	75 c6                	jne    80fb0c <sfork+0x6b>
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
						((uvpt[PGNUM(i)] & (PTE_P | PTE_U | PTE_W)))))
  80fb46:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
  80fb4d:	c1 e2 0c             	shl    $0xc,%edx
  80fb50:	83 ec 0c             	sub    $0xc,%esp
  80fb53:	83 e0 07             	and    $0x7,%eax
  80fb56:	50                   	push   %eax
  80fb57:	52                   	push   %edx
  80fb58:	56                   	push   %esi
  80fb59:	52                   	push   %edx
  80fb5a:	6a 00                	push   $0x0
  80fb5c:	e8 32 f9 ff ff       	call   80f493 <sys_page_map>
  80fb61:	83 c4 20             	add    $0x20,%esp
  80fb64:	85 c0                	test   %eax,%eax
  80fb66:	74 a4                	je     80fb0c <sfork+0x6b>
				panic("sys_page_map() panic\n");
  80fb68:	83 ec 04             	sub    $0x4,%esp
  80fb6b:	68 b3 3e 81 00       	push   $0x813eb3
  80fb70:	68 ba 00 00 00       	push   $0xba
  80fb75:	68 c9 3e 81 00       	push   $0x813ec9
  80fb7a:	e8 8a ec ff ff       	call   80e809 <_panic>
		}
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80fb7f:	83 ec 04             	sub    $0x4,%esp
  80fb82:	6a 07                	push   $0x7
  80fb84:	68 00 f0 bf ee       	push   $0xeebff000
  80fb89:	57                   	push   %edi
  80fb8a:	e8 c1 f8 ff ff       	call   80f450 <sys_page_alloc>
	if(ret < 0)
  80fb8f:	83 c4 10             	add    $0x10,%esp
  80fb92:	85 c0                	test   %eax,%eax
  80fb94:	78 31                	js     80fbc7 <sfork+0x126>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80fb96:	83 ec 08             	sub    $0x8,%esp
  80fb99:	68 66 11 81 00       	push   $0x811166
  80fb9e:	57                   	push   %edi
  80fb9f:	e8 f7 f9 ff ff       	call   80f59b <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80fba4:	83 c4 10             	add    $0x10,%esp
  80fba7:	85 c0                	test   %eax,%eax
  80fba9:	78 33                	js     80fbde <sfork+0x13d>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80fbab:	83 ec 08             	sub    $0x8,%esp
  80fbae:	6a 02                	push   $0x2
  80fbb0:	57                   	push   %edi
  80fbb1:	e8 61 f9 ff ff       	call   80f517 <sys_env_set_status>
	if(ret < 0)
  80fbb6:	83 c4 10             	add    $0x10,%esp
  80fbb9:	85 c0                	test   %eax,%eax
  80fbbb:	78 38                	js     80fbf5 <sfork+0x154>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
  80fbbd:	89 f8                	mov    %edi,%eax
  80fbbf:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fbc2:	5b                   	pop    %ebx
  80fbc3:	5e                   	pop    %esi
  80fbc4:	5f                   	pop    %edi
  80fbc5:	5d                   	pop    %ebp
  80fbc6:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80fbc7:	83 ec 04             	sub    $0x4,%esp
  80fbca:	68 e8 3e 81 00       	push   $0x813ee8
  80fbcf:	68 c0 00 00 00       	push   $0xc0
  80fbd4:	68 c9 3e 81 00       	push   $0x813ec9
  80fbd9:	e8 2b ec ff ff       	call   80e809 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80fbde:	83 ec 04             	sub    $0x4,%esp
  80fbe1:	68 5c 3f 81 00       	push   $0x813f5c
  80fbe6:	68 c3 00 00 00       	push   $0xc3
  80fbeb:	68 c9 3e 81 00       	push   $0x813ec9
  80fbf0:	e8 14 ec ff ff       	call   80e809 <_panic>
		panic("panic in sys_env_set_status()\n");
  80fbf5:	83 ec 04             	sub    $0x4,%esp
  80fbf8:	68 84 3f 81 00       	push   $0x813f84
  80fbfd:	68 c6 00 00 00       	push   $0xc6
  80fc02:	68 c9 3e 81 00       	push   $0x813ec9
  80fc07:	e8 fd eb ff ff       	call   80e809 <_panic>

0080fc0c <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80fc0c:	55                   	push   %ebp
  80fc0d:	89 e5                	mov    %esp,%ebp
  80fc0f:	56                   	push   %esi
  80fc10:	53                   	push   %ebx
  80fc11:	8b 75 08             	mov    0x8(%ebp),%esi
  80fc14:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fc17:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");
	int ret;
	if(!pg)
  80fc1a:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80fc1c:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80fc21:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  80fc24:	83 ec 0c             	sub    $0xc,%esp
  80fc27:	50                   	push   %eax
  80fc28:	e8 d3 f9 ff ff       	call   80f600 <sys_ipc_recv>
	if(ret < 0){
  80fc2d:	83 c4 10             	add    $0x10,%esp
  80fc30:	85 c0                	test   %eax,%eax
  80fc32:	78 2b                	js     80fc5f <ipc_recv+0x53>
			*from_env_store = 0;
		if(perm_store)
			*perm_store = 0;
		return ret;
	}
	if(from_env_store){
  80fc34:	85 f6                	test   %esi,%esi
  80fc36:	74 0a                	je     80fc42 <ipc_recv+0x36>
		*from_env_store = thisenv->env_ipc_from;
  80fc38:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fc3d:	8b 40 74             	mov    0x74(%eax),%eax
  80fc40:	89 06                	mov    %eax,(%esi)
	}
	if(perm_store){
  80fc42:	85 db                	test   %ebx,%ebx
  80fc44:	74 0a                	je     80fc50 <ipc_recv+0x44>
		*perm_store = thisenv->env_ipc_perm;
  80fc46:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fc4b:	8b 40 78             	mov    0x78(%eax),%eax
  80fc4e:	89 03                	mov    %eax,(%ebx)
	}
	return thisenv->env_ipc_value;
  80fc50:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fc55:	8b 40 70             	mov    0x70(%eax),%eax
}
  80fc58:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80fc5b:	5b                   	pop    %ebx
  80fc5c:	5e                   	pop    %esi
  80fc5d:	5d                   	pop    %ebp
  80fc5e:	c3                   	ret    
		if(from_env_store)
  80fc5f:	85 f6                	test   %esi,%esi
  80fc61:	74 06                	je     80fc69 <ipc_recv+0x5d>
			*from_env_store = 0;
  80fc63:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store)
  80fc69:	85 db                	test   %ebx,%ebx
  80fc6b:	74 eb                	je     80fc58 <ipc_recv+0x4c>
			*perm_store = 0;
  80fc6d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80fc73:	eb e3                	jmp    80fc58 <ipc_recv+0x4c>

0080fc75 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{	
  80fc75:	55                   	push   %ebp
  80fc76:	89 e5                	mov    %esp,%ebp
  80fc78:	57                   	push   %edi
  80fc79:	56                   	push   %esi
  80fc7a:	53                   	push   %ebx
  80fc7b:	83 ec 0c             	sub    $0xc,%esp
  80fc7e:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fc81:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fc84:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// cprintf("%d: in %s to_env is %d\n", thisenv->env_id, __FUNCTION__, to_env);
	int ret;
	if(!pg)
		pg = (void *)UTOP;
  80fc87:	85 db                	test   %ebx,%ebx
  80fc89:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80fc8e:	0f 44 d8             	cmove  %eax,%ebx
  80fc91:	eb 05                	jmp    80fc98 <ipc_send+0x23>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
			panic("panic at ipc_send()\n");
		}
		sys_yield();
  80fc93:	e8 99 f7 ff ff       	call   80f431 <sys_yield>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
  80fc98:	ff 75 14             	pushl  0x14(%ebp)
  80fc9b:	53                   	push   %ebx
  80fc9c:	56                   	push   %esi
  80fc9d:	57                   	push   %edi
  80fc9e:	e8 3a f9 ff ff       	call   80f5dd <sys_ipc_try_send>
  80fca3:	83 c4 10             	add    $0x10,%esp
  80fca6:	85 c0                	test   %eax,%eax
  80fca8:	74 1b                	je     80fcc5 <ipc_send+0x50>
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
  80fcaa:	79 e7                	jns    80fc93 <ipc_send+0x1e>
  80fcac:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80fcaf:	74 e2                	je     80fc93 <ipc_send+0x1e>
			panic("panic at ipc_send()\n");
  80fcb1:	83 ec 04             	sub    $0x4,%esp
  80fcb4:	68 a3 3f 81 00       	push   $0x813fa3
  80fcb9:	6a 46                	push   $0x46
  80fcbb:	68 b8 3f 81 00       	push   $0x813fb8
  80fcc0:	e8 44 eb ff ff       	call   80e809 <_panic>
	}
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");
}
  80fcc5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fcc8:	5b                   	pop    %ebx
  80fcc9:	5e                   	pop    %esi
  80fcca:	5f                   	pop    %edi
  80fccb:	5d                   	pop    %ebp
  80fccc:	c3                   	ret    

0080fccd <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80fccd:	55                   	push   %ebp
  80fcce:	89 e5                	mov    %esp,%ebp
  80fcd0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80fcd3:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80fcd8:	89 c2                	mov    %eax,%edx
  80fcda:	c1 e2 07             	shl    $0x7,%edx
  80fcdd:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80fce3:	8b 52 50             	mov    0x50(%edx),%edx
  80fce6:	39 ca                	cmp    %ecx,%edx
  80fce8:	74 11                	je     80fcfb <ipc_find_env+0x2e>
	for (i = 0; i < NENV; i++)
  80fcea:	83 c0 01             	add    $0x1,%eax
  80fced:	3d 00 04 00 00       	cmp    $0x400,%eax
  80fcf2:	75 e4                	jne    80fcd8 <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80fcf4:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcf9:	eb 0b                	jmp    80fd06 <ipc_find_env+0x39>
			return envs[i].env_id;
  80fcfb:	c1 e0 07             	shl    $0x7,%eax
  80fcfe:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fd03:	8b 40 48             	mov    0x48(%eax),%eax
}
  80fd06:	5d                   	pop    %ebp
  80fd07:	c3                   	ret    

0080fd08 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80fd08:	55                   	push   %ebp
  80fd09:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fd0b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd0e:	05 00 00 00 30       	add    $0x30000000,%eax
  80fd13:	c1 e8 0c             	shr    $0xc,%eax
}
  80fd16:	5d                   	pop    %ebp
  80fd17:	c3                   	ret    

0080fd18 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80fd18:	55                   	push   %ebp
  80fd19:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fd1b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd1e:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fd23:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fd28:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fd2d:	5d                   	pop    %ebp
  80fd2e:	c3                   	ret    

0080fd2f <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fd2f:	55                   	push   %ebp
  80fd30:	89 e5                	mov    %esp,%ebp
  80fd32:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80fd37:	89 c2                	mov    %eax,%edx
  80fd39:	c1 ea 16             	shr    $0x16,%edx
  80fd3c:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80fd43:	f6 c2 01             	test   $0x1,%dl
  80fd46:	74 2d                	je     80fd75 <fd_alloc+0x46>
  80fd48:	89 c2                	mov    %eax,%edx
  80fd4a:	c1 ea 0c             	shr    $0xc,%edx
  80fd4d:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fd54:	f6 c2 01             	test   $0x1,%dl
  80fd57:	74 1c                	je     80fd75 <fd_alloc+0x46>
  80fd59:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fd5e:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fd63:	75 d2                	jne    80fd37 <fd_alloc+0x8>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fd65:	8b 45 08             	mov    0x8(%ebp),%eax
  80fd68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fd6e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fd73:	eb 0a                	jmp    80fd7f <fd_alloc+0x50>
			*fd_store = fd;
  80fd75:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fd78:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fd7a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fd7f:	5d                   	pop    %ebp
  80fd80:	c3                   	ret    

0080fd81 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fd81:	55                   	push   %ebp
  80fd82:	89 e5                	mov    %esp,%ebp
  80fd84:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fd87:	83 f8 1f             	cmp    $0x1f,%eax
  80fd8a:	77 30                	ja     80fdbc <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fd8c:	c1 e0 0c             	shl    $0xc,%eax
  80fd8f:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fd94:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fd9a:	f6 c2 01             	test   $0x1,%dl
  80fd9d:	74 24                	je     80fdc3 <fd_lookup+0x42>
  80fd9f:	89 c2                	mov    %eax,%edx
  80fda1:	c1 ea 0c             	shr    $0xc,%edx
  80fda4:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fdab:	f6 c2 01             	test   $0x1,%dl
  80fdae:	74 1a                	je     80fdca <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fdb0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fdb3:	89 02                	mov    %eax,(%edx)
	return 0;
  80fdb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fdba:	5d                   	pop    %ebp
  80fdbb:	c3                   	ret    
		return -E_INVAL;
  80fdbc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fdc1:	eb f7                	jmp    80fdba <fd_lookup+0x39>
		return -E_INVAL;
  80fdc3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fdc8:	eb f0                	jmp    80fdba <fd_lookup+0x39>
  80fdca:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fdcf:	eb e9                	jmp    80fdba <fd_lookup+0x39>

0080fdd1 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fdd1:	55                   	push   %ebp
  80fdd2:	89 e5                	mov    %esp,%ebp
  80fdd4:	83 ec 08             	sub    $0x8,%esp
  80fdd7:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fdda:	ba 00 00 00 00       	mov    $0x0,%edx
  80fddf:	b8 ec 52 81 00       	mov    $0x8152ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fde4:	39 08                	cmp    %ecx,(%eax)
  80fde6:	74 38                	je     80fe20 <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80fde8:	83 c2 01             	add    $0x1,%edx
  80fdeb:	8b 04 95 40 40 81 00 	mov    0x814040(,%edx,4),%eax
  80fdf2:	85 c0                	test   %eax,%eax
  80fdf4:	75 ee                	jne    80fde4 <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fdf6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80fdfb:	8b 40 48             	mov    0x48(%eax),%eax
  80fdfe:	83 ec 04             	sub    $0x4,%esp
  80fe01:	51                   	push   %ecx
  80fe02:	50                   	push   %eax
  80fe03:	68 c4 3f 81 00       	push   $0x813fc4
  80fe08:	e8 f2 ea ff ff       	call   80e8ff <cprintf>
	*dev = 0;
  80fe0d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fe10:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fe16:	83 c4 10             	add    $0x10,%esp
  80fe19:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fe1e:	c9                   	leave  
  80fe1f:	c3                   	ret    
			*dev = devtab[i];
  80fe20:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe23:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fe25:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe2a:	eb f2                	jmp    80fe1e <dev_lookup+0x4d>

0080fe2c <fd_close>:
{
  80fe2c:	55                   	push   %ebp
  80fe2d:	89 e5                	mov    %esp,%ebp
  80fe2f:	57                   	push   %edi
  80fe30:	56                   	push   %esi
  80fe31:	53                   	push   %ebx
  80fe32:	83 ec 24             	sub    $0x24,%esp
  80fe35:	8b 75 08             	mov    0x8(%ebp),%esi
  80fe38:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fe3b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fe3e:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fe3f:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fe45:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fe48:	50                   	push   %eax
  80fe49:	e8 33 ff ff ff       	call   80fd81 <fd_lookup>
  80fe4e:	89 c3                	mov    %eax,%ebx
  80fe50:	83 c4 10             	add    $0x10,%esp
  80fe53:	85 c0                	test   %eax,%eax
  80fe55:	78 05                	js     80fe5c <fd_close+0x30>
	    || fd != fd2)
  80fe57:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fe5a:	74 16                	je     80fe72 <fd_close+0x46>
		return (must_exist ? r : 0);
  80fe5c:	89 f8                	mov    %edi,%eax
  80fe5e:	84 c0                	test   %al,%al
  80fe60:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe65:	0f 44 d8             	cmove  %eax,%ebx
}
  80fe68:	89 d8                	mov    %ebx,%eax
  80fe6a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fe6d:	5b                   	pop    %ebx
  80fe6e:	5e                   	pop    %esi
  80fe6f:	5f                   	pop    %edi
  80fe70:	5d                   	pop    %ebp
  80fe71:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fe72:	83 ec 08             	sub    $0x8,%esp
  80fe75:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fe78:	50                   	push   %eax
  80fe79:	ff 36                	pushl  (%esi)
  80fe7b:	e8 51 ff ff ff       	call   80fdd1 <dev_lookup>
  80fe80:	89 c3                	mov    %eax,%ebx
  80fe82:	83 c4 10             	add    $0x10,%esp
  80fe85:	85 c0                	test   %eax,%eax
  80fe87:	78 1a                	js     80fea3 <fd_close+0x77>
		if (dev->dev_close)
  80fe89:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fe8c:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fe8f:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fe94:	85 c0                	test   %eax,%eax
  80fe96:	74 0b                	je     80fea3 <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80fe98:	83 ec 0c             	sub    $0xc,%esp
  80fe9b:	56                   	push   %esi
  80fe9c:	ff d0                	call   *%eax
  80fe9e:	89 c3                	mov    %eax,%ebx
  80fea0:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fea3:	83 ec 08             	sub    $0x8,%esp
  80fea6:	56                   	push   %esi
  80fea7:	6a 00                	push   $0x0
  80fea9:	e8 27 f6 ff ff       	call   80f4d5 <sys_page_unmap>
	return r;
  80feae:	83 c4 10             	add    $0x10,%esp
  80feb1:	eb b5                	jmp    80fe68 <fd_close+0x3c>

0080feb3 <close>:

int
close(int fdnum)
{
  80feb3:	55                   	push   %ebp
  80feb4:	89 e5                	mov    %esp,%ebp
  80feb6:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80feb9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80febc:	50                   	push   %eax
  80febd:	ff 75 08             	pushl  0x8(%ebp)
  80fec0:	e8 bc fe ff ff       	call   80fd81 <fd_lookup>
  80fec5:	83 c4 10             	add    $0x10,%esp
  80fec8:	85 c0                	test   %eax,%eax
  80feca:	79 02                	jns    80fece <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80fecc:	c9                   	leave  
  80fecd:	c3                   	ret    
		return fd_close(fd, 1);
  80fece:	83 ec 08             	sub    $0x8,%esp
  80fed1:	6a 01                	push   $0x1
  80fed3:	ff 75 f4             	pushl  -0xc(%ebp)
  80fed6:	e8 51 ff ff ff       	call   80fe2c <fd_close>
  80fedb:	83 c4 10             	add    $0x10,%esp
  80fede:	eb ec                	jmp    80fecc <close+0x19>

0080fee0 <close_all>:

void
close_all(void)
{
  80fee0:	55                   	push   %ebp
  80fee1:	89 e5                	mov    %esp,%ebp
  80fee3:	53                   	push   %ebx
  80fee4:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fee7:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80feec:	83 ec 0c             	sub    $0xc,%esp
  80feef:	53                   	push   %ebx
  80fef0:	e8 be ff ff ff       	call   80feb3 <close>
	for (i = 0; i < MAXFD; i++)
  80fef5:	83 c3 01             	add    $0x1,%ebx
  80fef8:	83 c4 10             	add    $0x10,%esp
  80fefb:	83 fb 20             	cmp    $0x20,%ebx
  80fefe:	75 ec                	jne    80feec <close_all+0xc>
}
  80ff00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ff03:	c9                   	leave  
  80ff04:	c3                   	ret    

0080ff05 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80ff05:	55                   	push   %ebp
  80ff06:	89 e5                	mov    %esp,%ebp
  80ff08:	57                   	push   %edi
  80ff09:	56                   	push   %esi
  80ff0a:	53                   	push   %ebx
  80ff0b:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80ff0e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ff11:	50                   	push   %eax
  80ff12:	ff 75 08             	pushl  0x8(%ebp)
  80ff15:	e8 67 fe ff ff       	call   80fd81 <fd_lookup>
  80ff1a:	89 c3                	mov    %eax,%ebx
  80ff1c:	83 c4 10             	add    $0x10,%esp
  80ff1f:	85 c0                	test   %eax,%eax
  80ff21:	0f 88 81 00 00 00    	js     80ffa8 <dup+0xa3>
		return r;
	close(newfdnum);
  80ff27:	83 ec 0c             	sub    $0xc,%esp
  80ff2a:	ff 75 0c             	pushl  0xc(%ebp)
  80ff2d:	e8 81 ff ff ff       	call   80feb3 <close>

	newfd = INDEX2FD(newfdnum);
  80ff32:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ff35:	c1 e6 0c             	shl    $0xc,%esi
  80ff38:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80ff3e:	83 c4 04             	add    $0x4,%esp
  80ff41:	ff 75 e4             	pushl  -0x1c(%ebp)
  80ff44:	e8 cf fd ff ff       	call   80fd18 <fd2data>
  80ff49:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80ff4b:	89 34 24             	mov    %esi,(%esp)
  80ff4e:	e8 c5 fd ff ff       	call   80fd18 <fd2data>
  80ff53:	83 c4 10             	add    $0x10,%esp
  80ff56:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80ff58:	89 d8                	mov    %ebx,%eax
  80ff5a:	c1 e8 16             	shr    $0x16,%eax
  80ff5d:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80ff64:	a8 01                	test   $0x1,%al
  80ff66:	74 11                	je     80ff79 <dup+0x74>
  80ff68:	89 d8                	mov    %ebx,%eax
  80ff6a:	c1 e8 0c             	shr    $0xc,%eax
  80ff6d:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80ff74:	f6 c2 01             	test   $0x1,%dl
  80ff77:	75 39                	jne    80ffb2 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80ff79:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ff7c:	89 d0                	mov    %edx,%eax
  80ff7e:	c1 e8 0c             	shr    $0xc,%eax
  80ff81:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ff88:	83 ec 0c             	sub    $0xc,%esp
  80ff8b:	25 07 0e 00 00       	and    $0xe07,%eax
  80ff90:	50                   	push   %eax
  80ff91:	56                   	push   %esi
  80ff92:	6a 00                	push   $0x0
  80ff94:	52                   	push   %edx
  80ff95:	6a 00                	push   $0x0
  80ff97:	e8 f7 f4 ff ff       	call   80f493 <sys_page_map>
  80ff9c:	89 c3                	mov    %eax,%ebx
  80ff9e:	83 c4 20             	add    $0x20,%esp
  80ffa1:	85 c0                	test   %eax,%eax
  80ffa3:	78 31                	js     80ffd6 <dup+0xd1>
		goto err;

	return newfdnum;
  80ffa5:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80ffa8:	89 d8                	mov    %ebx,%eax
  80ffaa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ffad:	5b                   	pop    %ebx
  80ffae:	5e                   	pop    %esi
  80ffaf:	5f                   	pop    %edi
  80ffb0:	5d                   	pop    %ebp
  80ffb1:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80ffb2:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ffb9:	83 ec 0c             	sub    $0xc,%esp
  80ffbc:	25 07 0e 00 00       	and    $0xe07,%eax
  80ffc1:	50                   	push   %eax
  80ffc2:	57                   	push   %edi
  80ffc3:	6a 00                	push   $0x0
  80ffc5:	53                   	push   %ebx
  80ffc6:	6a 00                	push   $0x0
  80ffc8:	e8 c6 f4 ff ff       	call   80f493 <sys_page_map>
  80ffcd:	89 c3                	mov    %eax,%ebx
  80ffcf:	83 c4 20             	add    $0x20,%esp
  80ffd2:	85 c0                	test   %eax,%eax
  80ffd4:	79 a3                	jns    80ff79 <dup+0x74>
	sys_page_unmap(0, newfd);
  80ffd6:	83 ec 08             	sub    $0x8,%esp
  80ffd9:	56                   	push   %esi
  80ffda:	6a 00                	push   $0x0
  80ffdc:	e8 f4 f4 ff ff       	call   80f4d5 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80ffe1:	83 c4 08             	add    $0x8,%esp
  80ffe4:	57                   	push   %edi
  80ffe5:	6a 00                	push   $0x0
  80ffe7:	e8 e9 f4 ff ff       	call   80f4d5 <sys_page_unmap>
	return r;
  80ffec:	83 c4 10             	add    $0x10,%esp
  80ffef:	eb b7                	jmp    80ffa8 <dup+0xa3>

0080fff1 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fff1:	55                   	push   %ebp
  80fff2:	89 e5                	mov    %esp,%ebp
  80fff4:	53                   	push   %ebx
  80fff5:	83 ec 1c             	sub    $0x1c,%esp
  80fff8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fffb:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fffe:	50                   	push   %eax
  80ffff:	53                   	push   %ebx
  810000:	e8 7c fd ff ff       	call   80fd81 <fd_lookup>
  810005:	83 c4 10             	add    $0x10,%esp
  810008:	85 c0                	test   %eax,%eax
  81000a:	78 3f                	js     81004b <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81000c:	83 ec 08             	sub    $0x8,%esp
  81000f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810012:	50                   	push   %eax
  810013:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810016:	ff 30                	pushl  (%eax)
  810018:	e8 b4 fd ff ff       	call   80fdd1 <dev_lookup>
  81001d:	83 c4 10             	add    $0x10,%esp
  810020:	85 c0                	test   %eax,%eax
  810022:	78 27                	js     81004b <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  810024:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810027:	8b 42 08             	mov    0x8(%edx),%eax
  81002a:	83 e0 03             	and    $0x3,%eax
  81002d:	83 f8 01             	cmp    $0x1,%eax
  810030:	74 1e                	je     810050 <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  810032:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810035:	8b 40 08             	mov    0x8(%eax),%eax
  810038:	85 c0                	test   %eax,%eax
  81003a:	74 35                	je     810071 <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  81003c:	83 ec 04             	sub    $0x4,%esp
  81003f:	ff 75 10             	pushl  0x10(%ebp)
  810042:	ff 75 0c             	pushl  0xc(%ebp)
  810045:	52                   	push   %edx
  810046:	ff d0                	call   *%eax
  810048:	83 c4 10             	add    $0x10,%esp
}
  81004b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81004e:	c9                   	leave  
  81004f:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  810050:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  810055:	8b 40 48             	mov    0x48(%eax),%eax
  810058:	83 ec 04             	sub    $0x4,%esp
  81005b:	53                   	push   %ebx
  81005c:	50                   	push   %eax
  81005d:	68 05 40 81 00       	push   $0x814005
  810062:	e8 98 e8 ff ff       	call   80e8ff <cprintf>
		return -E_INVAL;
  810067:	83 c4 10             	add    $0x10,%esp
  81006a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81006f:	eb da                	jmp    81004b <read+0x5a>
		return -E_NOT_SUPP;
  810071:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810076:	eb d3                	jmp    81004b <read+0x5a>

00810078 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  810078:	55                   	push   %ebp
  810079:	89 e5                	mov    %esp,%ebp
  81007b:	57                   	push   %edi
  81007c:	56                   	push   %esi
  81007d:	53                   	push   %ebx
  81007e:	83 ec 0c             	sub    $0xc,%esp
  810081:	8b 7d 08             	mov    0x8(%ebp),%edi
  810084:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  810087:	bb 00 00 00 00       	mov    $0x0,%ebx
  81008c:	39 f3                	cmp    %esi,%ebx
  81008e:	73 23                	jae    8100b3 <readn+0x3b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810090:	83 ec 04             	sub    $0x4,%esp
  810093:	89 f0                	mov    %esi,%eax
  810095:	29 d8                	sub    %ebx,%eax
  810097:	50                   	push   %eax
  810098:	89 d8                	mov    %ebx,%eax
  81009a:	03 45 0c             	add    0xc(%ebp),%eax
  81009d:	50                   	push   %eax
  81009e:	57                   	push   %edi
  81009f:	e8 4d ff ff ff       	call   80fff1 <read>
		if (m < 0)
  8100a4:	83 c4 10             	add    $0x10,%esp
  8100a7:	85 c0                	test   %eax,%eax
  8100a9:	78 06                	js     8100b1 <readn+0x39>
			return m;
		if (m == 0)
  8100ab:	74 06                	je     8100b3 <readn+0x3b>
	for (tot = 0; tot < n; tot += m) {
  8100ad:	01 c3                	add    %eax,%ebx
  8100af:	eb db                	jmp    81008c <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  8100b1:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  8100b3:	89 d8                	mov    %ebx,%eax
  8100b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8100b8:	5b                   	pop    %ebx
  8100b9:	5e                   	pop    %esi
  8100ba:	5f                   	pop    %edi
  8100bb:	5d                   	pop    %ebp
  8100bc:	c3                   	ret    

008100bd <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  8100bd:	55                   	push   %ebp
  8100be:	89 e5                	mov    %esp,%ebp
  8100c0:	53                   	push   %ebx
  8100c1:	83 ec 1c             	sub    $0x1c,%esp
  8100c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8100c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8100ca:	50                   	push   %eax
  8100cb:	53                   	push   %ebx
  8100cc:	e8 b0 fc ff ff       	call   80fd81 <fd_lookup>
  8100d1:	83 c4 10             	add    $0x10,%esp
  8100d4:	85 c0                	test   %eax,%eax
  8100d6:	78 3a                	js     810112 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8100d8:	83 ec 08             	sub    $0x8,%esp
  8100db:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8100de:	50                   	push   %eax
  8100df:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8100e2:	ff 30                	pushl  (%eax)
  8100e4:	e8 e8 fc ff ff       	call   80fdd1 <dev_lookup>
  8100e9:	83 c4 10             	add    $0x10,%esp
  8100ec:	85 c0                	test   %eax,%eax
  8100ee:	78 22                	js     810112 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8100f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8100f3:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  8100f7:	74 1e                	je     810117 <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  8100f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8100fc:	8b 52 0c             	mov    0xc(%edx),%edx
  8100ff:	85 d2                	test   %edx,%edx
  810101:	74 35                	je     810138 <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  810103:	83 ec 04             	sub    $0x4,%esp
  810106:	ff 75 10             	pushl  0x10(%ebp)
  810109:	ff 75 0c             	pushl  0xc(%ebp)
  81010c:	50                   	push   %eax
  81010d:	ff d2                	call   *%edx
  81010f:	83 c4 10             	add    $0x10,%esp
}
  810112:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810115:	c9                   	leave  
  810116:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  810117:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  81011c:	8b 40 48             	mov    0x48(%eax),%eax
  81011f:	83 ec 04             	sub    $0x4,%esp
  810122:	53                   	push   %ebx
  810123:	50                   	push   %eax
  810124:	68 21 40 81 00       	push   $0x814021
  810129:	e8 d1 e7 ff ff       	call   80e8ff <cprintf>
		return -E_INVAL;
  81012e:	83 c4 10             	add    $0x10,%esp
  810131:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810136:	eb da                	jmp    810112 <write+0x55>
		return -E_NOT_SUPP;
  810138:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  81013d:	eb d3                	jmp    810112 <write+0x55>

0081013f <seek>:

int
seek(int fdnum, off_t offset)
{
  81013f:	55                   	push   %ebp
  810140:	89 e5                	mov    %esp,%ebp
  810142:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810145:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810148:	50                   	push   %eax
  810149:	ff 75 08             	pushl  0x8(%ebp)
  81014c:	e8 30 fc ff ff       	call   80fd81 <fd_lookup>
  810151:	83 c4 10             	add    $0x10,%esp
  810154:	85 c0                	test   %eax,%eax
  810156:	78 0e                	js     810166 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  810158:	8b 55 0c             	mov    0xc(%ebp),%edx
  81015b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81015e:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  810161:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810166:	c9                   	leave  
  810167:	c3                   	ret    

00810168 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  810168:	55                   	push   %ebp
  810169:	89 e5                	mov    %esp,%ebp
  81016b:	53                   	push   %ebx
  81016c:	83 ec 1c             	sub    $0x1c,%esp
  81016f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  810172:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810175:	50                   	push   %eax
  810176:	53                   	push   %ebx
  810177:	e8 05 fc ff ff       	call   80fd81 <fd_lookup>
  81017c:	83 c4 10             	add    $0x10,%esp
  81017f:	85 c0                	test   %eax,%eax
  810181:	78 37                	js     8101ba <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810183:	83 ec 08             	sub    $0x8,%esp
  810186:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810189:	50                   	push   %eax
  81018a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81018d:	ff 30                	pushl  (%eax)
  81018f:	e8 3d fc ff ff       	call   80fdd1 <dev_lookup>
  810194:	83 c4 10             	add    $0x10,%esp
  810197:	85 c0                	test   %eax,%eax
  810199:	78 1f                	js     8101ba <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  81019b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81019e:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  8101a2:	74 1b                	je     8101bf <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  8101a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8101a7:	8b 52 18             	mov    0x18(%edx),%edx
  8101aa:	85 d2                	test   %edx,%edx
  8101ac:	74 32                	je     8101e0 <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  8101ae:	83 ec 08             	sub    $0x8,%esp
  8101b1:	ff 75 0c             	pushl  0xc(%ebp)
  8101b4:	50                   	push   %eax
  8101b5:	ff d2                	call   *%edx
  8101b7:	83 c4 10             	add    $0x10,%esp
}
  8101ba:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8101bd:	c9                   	leave  
  8101be:	c3                   	ret    
			thisenv->env_id, fdnum);
  8101bf:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8101c4:	8b 40 48             	mov    0x48(%eax),%eax
  8101c7:	83 ec 04             	sub    $0x4,%esp
  8101ca:	53                   	push   %ebx
  8101cb:	50                   	push   %eax
  8101cc:	68 e4 3f 81 00       	push   $0x813fe4
  8101d1:	e8 29 e7 ff ff       	call   80e8ff <cprintf>
		return -E_INVAL;
  8101d6:	83 c4 10             	add    $0x10,%esp
  8101d9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8101de:	eb da                	jmp    8101ba <ftruncate+0x52>
		return -E_NOT_SUPP;
  8101e0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8101e5:	eb d3                	jmp    8101ba <ftruncate+0x52>

008101e7 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  8101e7:	55                   	push   %ebp
  8101e8:	89 e5                	mov    %esp,%ebp
  8101ea:	53                   	push   %ebx
  8101eb:	83 ec 1c             	sub    $0x1c,%esp
  8101ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8101f1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8101f4:	50                   	push   %eax
  8101f5:	ff 75 08             	pushl  0x8(%ebp)
  8101f8:	e8 84 fb ff ff       	call   80fd81 <fd_lookup>
  8101fd:	83 c4 10             	add    $0x10,%esp
  810200:	85 c0                	test   %eax,%eax
  810202:	78 4b                	js     81024f <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810204:	83 ec 08             	sub    $0x8,%esp
  810207:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81020a:	50                   	push   %eax
  81020b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81020e:	ff 30                	pushl  (%eax)
  810210:	e8 bc fb ff ff       	call   80fdd1 <dev_lookup>
  810215:	83 c4 10             	add    $0x10,%esp
  810218:	85 c0                	test   %eax,%eax
  81021a:	78 33                	js     81024f <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  81021c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81021f:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  810223:	74 2f                	je     810254 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  810225:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  810228:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  81022f:	00 00 00 
	stat->st_isdir = 0;
  810232:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810239:	00 00 00 
	stat->st_dev = dev;
  81023c:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  810242:	83 ec 08             	sub    $0x8,%esp
  810245:	53                   	push   %ebx
  810246:	ff 75 f0             	pushl  -0x10(%ebp)
  810249:	ff 50 14             	call   *0x14(%eax)
  81024c:	83 c4 10             	add    $0x10,%esp
}
  81024f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810252:	c9                   	leave  
  810253:	c3                   	ret    
		return -E_NOT_SUPP;
  810254:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810259:	eb f4                	jmp    81024f <fstat+0x68>

0081025b <stat>:

int
stat(const char *path, struct Stat *stat)
{
  81025b:	55                   	push   %ebp
  81025c:	89 e5                	mov    %esp,%ebp
  81025e:	56                   	push   %esi
  81025f:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  810260:	83 ec 08             	sub    $0x8,%esp
  810263:	6a 00                	push   $0x0
  810265:	ff 75 08             	pushl  0x8(%ebp)
  810268:	e8 22 02 00 00       	call   81048f <open>
  81026d:	89 c3                	mov    %eax,%ebx
  81026f:	83 c4 10             	add    $0x10,%esp
  810272:	85 c0                	test   %eax,%eax
  810274:	78 1b                	js     810291 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  810276:	83 ec 08             	sub    $0x8,%esp
  810279:	ff 75 0c             	pushl  0xc(%ebp)
  81027c:	50                   	push   %eax
  81027d:	e8 65 ff ff ff       	call   8101e7 <fstat>
  810282:	89 c6                	mov    %eax,%esi
	close(fd);
  810284:	89 1c 24             	mov    %ebx,(%esp)
  810287:	e8 27 fc ff ff       	call   80feb3 <close>
	return r;
  81028c:	83 c4 10             	add    $0x10,%esp
  81028f:	89 f3                	mov    %esi,%ebx
}
  810291:	89 d8                	mov    %ebx,%eax
  810293:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810296:	5b                   	pop    %ebx
  810297:	5e                   	pop    %esi
  810298:	5d                   	pop    %ebp
  810299:	c3                   	ret    

0081029a <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  81029a:	55                   	push   %ebp
  81029b:	89 e5                	mov    %esp,%ebp
  81029d:	56                   	push   %esi
  81029e:	53                   	push   %ebx
  81029f:	89 c6                	mov    %eax,%esi
  8102a1:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  8102a3:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  8102aa:	74 27                	je     8102d3 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  8102ac:	6a 07                	push   $0x7
  8102ae:	68 00 d0 b3 00       	push   $0xb3d000
  8102b3:	56                   	push   %esi
  8102b4:	ff 35 cc c1 b3 00    	pushl  0xb3c1cc
  8102ba:	e8 b6 f9 ff ff       	call   80fc75 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  8102bf:	83 c4 0c             	add    $0xc,%esp
  8102c2:	6a 00                	push   $0x0
  8102c4:	53                   	push   %ebx
  8102c5:	6a 00                	push   $0x0
  8102c7:	e8 40 f9 ff ff       	call   80fc0c <ipc_recv>
}
  8102cc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8102cf:	5b                   	pop    %ebx
  8102d0:	5e                   	pop    %esi
  8102d1:	5d                   	pop    %ebp
  8102d2:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8102d3:	83 ec 0c             	sub    $0xc,%esp
  8102d6:	6a 01                	push   $0x1
  8102d8:	e8 f0 f9 ff ff       	call   80fccd <ipc_find_env>
  8102dd:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
  8102e2:	83 c4 10             	add    $0x10,%esp
  8102e5:	eb c5                	jmp    8102ac <fsipc+0x12>

008102e7 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  8102e7:	55                   	push   %ebp
  8102e8:	89 e5                	mov    %esp,%ebp
  8102ea:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  8102ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8102f0:	8b 40 0c             	mov    0xc(%eax),%eax
  8102f3:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  8102f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8102fb:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810300:	ba 00 00 00 00       	mov    $0x0,%edx
  810305:	b8 02 00 00 00       	mov    $0x2,%eax
  81030a:	e8 8b ff ff ff       	call   81029a <fsipc>
}
  81030f:	c9                   	leave  
  810310:	c3                   	ret    

00810311 <devfile_flush>:
{
  810311:	55                   	push   %ebp
  810312:	89 e5                	mov    %esp,%ebp
  810314:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  810317:	8b 45 08             	mov    0x8(%ebp),%eax
  81031a:	8b 40 0c             	mov    0xc(%eax),%eax
  81031d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  810322:	ba 00 00 00 00       	mov    $0x0,%edx
  810327:	b8 06 00 00 00       	mov    $0x6,%eax
  81032c:	e8 69 ff ff ff       	call   81029a <fsipc>
}
  810331:	c9                   	leave  
  810332:	c3                   	ret    

00810333 <devfile_stat>:
{
  810333:	55                   	push   %ebp
  810334:	89 e5                	mov    %esp,%ebp
  810336:	53                   	push   %ebx
  810337:	83 ec 04             	sub    $0x4,%esp
  81033a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  81033d:	8b 45 08             	mov    0x8(%ebp),%eax
  810340:	8b 40 0c             	mov    0xc(%eax),%eax
  810343:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  810348:	ba 00 00 00 00       	mov    $0x0,%edx
  81034d:	b8 05 00 00 00       	mov    $0x5,%eax
  810352:	e8 43 ff ff ff       	call   81029a <fsipc>
  810357:	85 c0                	test   %eax,%eax
  810359:	78 2c                	js     810387 <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  81035b:	83 ec 08             	sub    $0x8,%esp
  81035e:	68 00 d0 b3 00       	push   $0xb3d000
  810363:	53                   	push   %ebx
  810364:	e8 f5 ec ff ff       	call   80f05e <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  810369:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  81036e:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810374:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  810379:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  81037f:	83 c4 10             	add    $0x10,%esp
  810382:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810387:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81038a:	c9                   	leave  
  81038b:	c3                   	ret    

0081038c <devfile_write>:
{
  81038c:	55                   	push   %ebp
  81038d:	89 e5                	mov    %esp,%ebp
  81038f:	53                   	push   %ebx
  810390:	83 ec 08             	sub    $0x8,%esp
  810393:	8b 5d 10             	mov    0x10(%ebp),%ebx
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810396:	8b 45 08             	mov    0x8(%ebp),%eax
  810399:	8b 40 0c             	mov    0xc(%eax),%eax
  81039c:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.write.req_n = n;
  8103a1:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	memcpy(fsipcbuf.write.req_buf, buf, n);
  8103a7:	53                   	push   %ebx
  8103a8:	ff 75 0c             	pushl  0xc(%ebp)
  8103ab:	68 08 d0 b3 00       	push   $0xb3d008
  8103b0:	e8 99 ee ff ff       	call   80f24e <memcpy>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  8103b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8103ba:	b8 04 00 00 00       	mov    $0x4,%eax
  8103bf:	e8 d6 fe ff ff       	call   81029a <fsipc>
  8103c4:	83 c4 10             	add    $0x10,%esp
  8103c7:	85 c0                	test   %eax,%eax
  8103c9:	78 0b                	js     8103d6 <devfile_write+0x4a>
	assert(r <= n);
  8103cb:	39 d8                	cmp    %ebx,%eax
  8103cd:	77 0c                	ja     8103db <devfile_write+0x4f>
	assert(r <= PGSIZE);
  8103cf:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8103d4:	7f 1e                	jg     8103f4 <devfile_write+0x68>
}
  8103d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8103d9:	c9                   	leave  
  8103da:	c3                   	ret    
	assert(r <= n);
  8103db:	68 54 40 81 00       	push   $0x814054
  8103e0:	68 6b 2c 81 00       	push   $0x812c6b
  8103e5:	68 98 00 00 00       	push   $0x98
  8103ea:	68 5b 40 81 00       	push   $0x81405b
  8103ef:	e8 15 e4 ff ff       	call   80e809 <_panic>
	assert(r <= PGSIZE);
  8103f4:	68 66 40 81 00       	push   $0x814066
  8103f9:	68 6b 2c 81 00       	push   $0x812c6b
  8103fe:	68 99 00 00 00       	push   $0x99
  810403:	68 5b 40 81 00       	push   $0x81405b
  810408:	e8 fc e3 ff ff       	call   80e809 <_panic>

0081040d <devfile_read>:
{
  81040d:	55                   	push   %ebp
  81040e:	89 e5                	mov    %esp,%ebp
  810410:	56                   	push   %esi
  810411:	53                   	push   %ebx
  810412:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  810415:	8b 45 08             	mov    0x8(%ebp),%eax
  810418:	8b 40 0c             	mov    0xc(%eax),%eax
  81041b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  810420:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  810426:	ba 00 00 00 00       	mov    $0x0,%edx
  81042b:	b8 03 00 00 00       	mov    $0x3,%eax
  810430:	e8 65 fe ff ff       	call   81029a <fsipc>
  810435:	89 c3                	mov    %eax,%ebx
  810437:	85 c0                	test   %eax,%eax
  810439:	78 1f                	js     81045a <devfile_read+0x4d>
	assert(r <= n);
  81043b:	39 f0                	cmp    %esi,%eax
  81043d:	77 24                	ja     810463 <devfile_read+0x56>
	assert(r <= PGSIZE);
  81043f:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810444:	7f 33                	jg     810479 <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  810446:	83 ec 04             	sub    $0x4,%esp
  810449:	50                   	push   %eax
  81044a:	68 00 d0 b3 00       	push   $0xb3d000
  81044f:	ff 75 0c             	pushl  0xc(%ebp)
  810452:	e8 95 ed ff ff       	call   80f1ec <memmove>
	return r;
  810457:	83 c4 10             	add    $0x10,%esp
}
  81045a:	89 d8                	mov    %ebx,%eax
  81045c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81045f:	5b                   	pop    %ebx
  810460:	5e                   	pop    %esi
  810461:	5d                   	pop    %ebp
  810462:	c3                   	ret    
	assert(r <= n);
  810463:	68 54 40 81 00       	push   $0x814054
  810468:	68 6b 2c 81 00       	push   $0x812c6b
  81046d:	6a 7c                	push   $0x7c
  81046f:	68 5b 40 81 00       	push   $0x81405b
  810474:	e8 90 e3 ff ff       	call   80e809 <_panic>
	assert(r <= PGSIZE);
  810479:	68 66 40 81 00       	push   $0x814066
  81047e:	68 6b 2c 81 00       	push   $0x812c6b
  810483:	6a 7d                	push   $0x7d
  810485:	68 5b 40 81 00       	push   $0x81405b
  81048a:	e8 7a e3 ff ff       	call   80e809 <_panic>

0081048f <open>:
{
  81048f:	55                   	push   %ebp
  810490:	89 e5                	mov    %esp,%ebp
  810492:	56                   	push   %esi
  810493:	53                   	push   %ebx
  810494:	83 ec 1c             	sub    $0x1c,%esp
  810497:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  81049a:	56                   	push   %esi
  81049b:	e8 85 eb ff ff       	call   80f025 <strlen>
  8104a0:	83 c4 10             	add    $0x10,%esp
  8104a3:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8104a8:	7f 6c                	jg     810516 <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  8104aa:	83 ec 0c             	sub    $0xc,%esp
  8104ad:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8104b0:	50                   	push   %eax
  8104b1:	e8 79 f8 ff ff       	call   80fd2f <fd_alloc>
  8104b6:	89 c3                	mov    %eax,%ebx
  8104b8:	83 c4 10             	add    $0x10,%esp
  8104bb:	85 c0                	test   %eax,%eax
  8104bd:	78 3c                	js     8104fb <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  8104bf:	83 ec 08             	sub    $0x8,%esp
  8104c2:	56                   	push   %esi
  8104c3:	68 00 d0 b3 00       	push   $0xb3d000
  8104c8:	e8 91 eb ff ff       	call   80f05e <strcpy>
	fsipcbuf.open.req_omode = mode;
  8104cd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8104d0:	a3 00 d4 b3 00       	mov    %eax,0xb3d400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  8104d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8104d8:	b8 01 00 00 00       	mov    $0x1,%eax
  8104dd:	e8 b8 fd ff ff       	call   81029a <fsipc>
  8104e2:	89 c3                	mov    %eax,%ebx
  8104e4:	83 c4 10             	add    $0x10,%esp
  8104e7:	85 c0                	test   %eax,%eax
  8104e9:	78 19                	js     810504 <open+0x75>
	return fd2num(fd);
  8104eb:	83 ec 0c             	sub    $0xc,%esp
  8104ee:	ff 75 f4             	pushl  -0xc(%ebp)
  8104f1:	e8 12 f8 ff ff       	call   80fd08 <fd2num>
  8104f6:	89 c3                	mov    %eax,%ebx
  8104f8:	83 c4 10             	add    $0x10,%esp
}
  8104fb:	89 d8                	mov    %ebx,%eax
  8104fd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810500:	5b                   	pop    %ebx
  810501:	5e                   	pop    %esi
  810502:	5d                   	pop    %ebp
  810503:	c3                   	ret    
		fd_close(fd, 0);
  810504:	83 ec 08             	sub    $0x8,%esp
  810507:	6a 00                	push   $0x0
  810509:	ff 75 f4             	pushl  -0xc(%ebp)
  81050c:	e8 1b f9 ff ff       	call   80fe2c <fd_close>
		return r;
  810511:	83 c4 10             	add    $0x10,%esp
  810514:	eb e5                	jmp    8104fb <open+0x6c>
		return -E_BAD_PATH;
  810516:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  81051b:	eb de                	jmp    8104fb <open+0x6c>

0081051d <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  81051d:	55                   	push   %ebp
  81051e:	89 e5                	mov    %esp,%ebp
  810520:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810523:	ba 00 00 00 00       	mov    $0x0,%edx
  810528:	b8 08 00 00 00       	mov    $0x8,%eax
  81052d:	e8 68 fd ff ff       	call   81029a <fsipc>
}
  810532:	c9                   	leave  
  810533:	c3                   	ret    

00810534 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810534:	55                   	push   %ebp
  810535:	89 e5                	mov    %esp,%ebp
  810537:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  81053a:	68 72 40 81 00       	push   $0x814072
  81053f:	ff 75 0c             	pushl  0xc(%ebp)
  810542:	e8 17 eb ff ff       	call   80f05e <strcpy>
	return 0;
}
  810547:	b8 00 00 00 00       	mov    $0x0,%eax
  81054c:	c9                   	leave  
  81054d:	c3                   	ret    

0081054e <devsock_close>:
{
  81054e:	55                   	push   %ebp
  81054f:	89 e5                	mov    %esp,%ebp
  810551:	53                   	push   %ebx
  810552:	83 ec 10             	sub    $0x10,%esp
  810555:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810558:	53                   	push   %ebx
  810559:	e8 2e 0c 00 00       	call   81118c <pageref>
  81055e:	83 c4 10             	add    $0x10,%esp
		return 0;
  810561:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  810566:	83 f8 01             	cmp    $0x1,%eax
  810569:	74 07                	je     810572 <devsock_close+0x24>
}
  81056b:	89 d0                	mov    %edx,%eax
  81056d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810570:	c9                   	leave  
  810571:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  810572:	83 ec 0c             	sub    $0xc,%esp
  810575:	ff 73 0c             	pushl  0xc(%ebx)
  810578:	e8 b9 02 00 00       	call   810836 <nsipc_close>
  81057d:	89 c2                	mov    %eax,%edx
  81057f:	83 c4 10             	add    $0x10,%esp
  810582:	eb e7                	jmp    81056b <devsock_close+0x1d>

00810584 <devsock_write>:
{
  810584:	55                   	push   %ebp
  810585:	89 e5                	mov    %esp,%ebp
  810587:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  81058a:	6a 00                	push   $0x0
  81058c:	ff 75 10             	pushl  0x10(%ebp)
  81058f:	ff 75 0c             	pushl  0xc(%ebp)
  810592:	8b 45 08             	mov    0x8(%ebp),%eax
  810595:	ff 70 0c             	pushl  0xc(%eax)
  810598:	e8 76 03 00 00       	call   810913 <nsipc_send>
}
  81059d:	c9                   	leave  
  81059e:	c3                   	ret    

0081059f <devsock_read>:
{
  81059f:	55                   	push   %ebp
  8105a0:	89 e5                	mov    %esp,%ebp
  8105a2:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8105a5:	6a 00                	push   $0x0
  8105a7:	ff 75 10             	pushl  0x10(%ebp)
  8105aa:	ff 75 0c             	pushl  0xc(%ebp)
  8105ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8105b0:	ff 70 0c             	pushl  0xc(%eax)
  8105b3:	e8 ef 02 00 00       	call   8108a7 <nsipc_recv>
}
  8105b8:	c9                   	leave  
  8105b9:	c3                   	ret    

008105ba <fd2sockid>:
{
  8105ba:	55                   	push   %ebp
  8105bb:	89 e5                	mov    %esp,%ebp
  8105bd:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  8105c0:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8105c3:	52                   	push   %edx
  8105c4:	50                   	push   %eax
  8105c5:	e8 b7 f7 ff ff       	call   80fd81 <fd_lookup>
  8105ca:	83 c4 10             	add    $0x10,%esp
  8105cd:	85 c0                	test   %eax,%eax
  8105cf:	78 10                	js     8105e1 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  8105d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8105d4:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
  8105da:	39 08                	cmp    %ecx,(%eax)
  8105dc:	75 05                	jne    8105e3 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  8105de:	8b 40 0c             	mov    0xc(%eax),%eax
}
  8105e1:	c9                   	leave  
  8105e2:	c3                   	ret    
		return -E_NOT_SUPP;
  8105e3:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8105e8:	eb f7                	jmp    8105e1 <fd2sockid+0x27>

008105ea <alloc_sockfd>:
{
  8105ea:	55                   	push   %ebp
  8105eb:	89 e5                	mov    %esp,%ebp
  8105ed:	56                   	push   %esi
  8105ee:	53                   	push   %ebx
  8105ef:	83 ec 1c             	sub    $0x1c,%esp
  8105f2:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  8105f4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8105f7:	50                   	push   %eax
  8105f8:	e8 32 f7 ff ff       	call   80fd2f <fd_alloc>
  8105fd:	89 c3                	mov    %eax,%ebx
  8105ff:	83 c4 10             	add    $0x10,%esp
  810602:	85 c0                	test   %eax,%eax
  810604:	78 43                	js     810649 <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810606:	83 ec 04             	sub    $0x4,%esp
  810609:	68 07 04 00 00       	push   $0x407
  81060e:	ff 75 f4             	pushl  -0xc(%ebp)
  810611:	6a 00                	push   $0x0
  810613:	e8 38 ee ff ff       	call   80f450 <sys_page_alloc>
  810618:	89 c3                	mov    %eax,%ebx
  81061a:	83 c4 10             	add    $0x10,%esp
  81061d:	85 c0                	test   %eax,%eax
  81061f:	78 28                	js     810649 <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  810621:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810624:	8b 15 08 53 81 00    	mov    0x815308,%edx
  81062a:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  81062c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81062f:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  810636:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  810639:	83 ec 0c             	sub    $0xc,%esp
  81063c:	50                   	push   %eax
  81063d:	e8 c6 f6 ff ff       	call   80fd08 <fd2num>
  810642:	89 c3                	mov    %eax,%ebx
  810644:	83 c4 10             	add    $0x10,%esp
  810647:	eb 0c                	jmp    810655 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  810649:	83 ec 0c             	sub    $0xc,%esp
  81064c:	56                   	push   %esi
  81064d:	e8 e4 01 00 00       	call   810836 <nsipc_close>
		return r;
  810652:	83 c4 10             	add    $0x10,%esp
}
  810655:	89 d8                	mov    %ebx,%eax
  810657:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81065a:	5b                   	pop    %ebx
  81065b:	5e                   	pop    %esi
  81065c:	5d                   	pop    %ebp
  81065d:	c3                   	ret    

0081065e <accept>:
{
  81065e:	55                   	push   %ebp
  81065f:	89 e5                	mov    %esp,%ebp
  810661:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810664:	8b 45 08             	mov    0x8(%ebp),%eax
  810667:	e8 4e ff ff ff       	call   8105ba <fd2sockid>
  81066c:	85 c0                	test   %eax,%eax
  81066e:	78 1b                	js     81068b <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810670:	83 ec 04             	sub    $0x4,%esp
  810673:	ff 75 10             	pushl  0x10(%ebp)
  810676:	ff 75 0c             	pushl  0xc(%ebp)
  810679:	50                   	push   %eax
  81067a:	e8 0e 01 00 00       	call   81078d <nsipc_accept>
  81067f:	83 c4 10             	add    $0x10,%esp
  810682:	85 c0                	test   %eax,%eax
  810684:	78 05                	js     81068b <accept+0x2d>
	return alloc_sockfd(r);
  810686:	e8 5f ff ff ff       	call   8105ea <alloc_sockfd>
}
  81068b:	c9                   	leave  
  81068c:	c3                   	ret    

0081068d <bind>:
{
  81068d:	55                   	push   %ebp
  81068e:	89 e5                	mov    %esp,%ebp
  810690:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810693:	8b 45 08             	mov    0x8(%ebp),%eax
  810696:	e8 1f ff ff ff       	call   8105ba <fd2sockid>
  81069b:	85 c0                	test   %eax,%eax
  81069d:	78 12                	js     8106b1 <bind+0x24>
	return nsipc_bind(r, name, namelen);
  81069f:	83 ec 04             	sub    $0x4,%esp
  8106a2:	ff 75 10             	pushl  0x10(%ebp)
  8106a5:	ff 75 0c             	pushl  0xc(%ebp)
  8106a8:	50                   	push   %eax
  8106a9:	e8 31 01 00 00       	call   8107df <nsipc_bind>
  8106ae:	83 c4 10             	add    $0x10,%esp
}
  8106b1:	c9                   	leave  
  8106b2:	c3                   	ret    

008106b3 <shutdown>:
{
  8106b3:	55                   	push   %ebp
  8106b4:	89 e5                	mov    %esp,%ebp
  8106b6:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8106b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8106bc:	e8 f9 fe ff ff       	call   8105ba <fd2sockid>
  8106c1:	85 c0                	test   %eax,%eax
  8106c3:	78 0f                	js     8106d4 <shutdown+0x21>
	return nsipc_shutdown(r, how);
  8106c5:	83 ec 08             	sub    $0x8,%esp
  8106c8:	ff 75 0c             	pushl  0xc(%ebp)
  8106cb:	50                   	push   %eax
  8106cc:	e8 43 01 00 00       	call   810814 <nsipc_shutdown>
  8106d1:	83 c4 10             	add    $0x10,%esp
}
  8106d4:	c9                   	leave  
  8106d5:	c3                   	ret    

008106d6 <connect>:
{
  8106d6:	55                   	push   %ebp
  8106d7:	89 e5                	mov    %esp,%ebp
  8106d9:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8106dc:	8b 45 08             	mov    0x8(%ebp),%eax
  8106df:	e8 d6 fe ff ff       	call   8105ba <fd2sockid>
  8106e4:	85 c0                	test   %eax,%eax
  8106e6:	78 12                	js     8106fa <connect+0x24>
	return nsipc_connect(r, name, namelen);
  8106e8:	83 ec 04             	sub    $0x4,%esp
  8106eb:	ff 75 10             	pushl  0x10(%ebp)
  8106ee:	ff 75 0c             	pushl  0xc(%ebp)
  8106f1:	50                   	push   %eax
  8106f2:	e8 59 01 00 00       	call   810850 <nsipc_connect>
  8106f7:	83 c4 10             	add    $0x10,%esp
}
  8106fa:	c9                   	leave  
  8106fb:	c3                   	ret    

008106fc <listen>:
{
  8106fc:	55                   	push   %ebp
  8106fd:	89 e5                	mov    %esp,%ebp
  8106ff:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810702:	8b 45 08             	mov    0x8(%ebp),%eax
  810705:	e8 b0 fe ff ff       	call   8105ba <fd2sockid>
  81070a:	85 c0                	test   %eax,%eax
  81070c:	78 0f                	js     81071d <listen+0x21>
	return nsipc_listen(r, backlog);
  81070e:	83 ec 08             	sub    $0x8,%esp
  810711:	ff 75 0c             	pushl  0xc(%ebp)
  810714:	50                   	push   %eax
  810715:	e8 6b 01 00 00       	call   810885 <nsipc_listen>
  81071a:	83 c4 10             	add    $0x10,%esp
}
  81071d:	c9                   	leave  
  81071e:	c3                   	ret    

0081071f <socket>:

int
socket(int domain, int type, int protocol)
{
  81071f:	55                   	push   %ebp
  810720:	89 e5                	mov    %esp,%ebp
  810722:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810725:	ff 75 10             	pushl  0x10(%ebp)
  810728:	ff 75 0c             	pushl  0xc(%ebp)
  81072b:	ff 75 08             	pushl  0x8(%ebp)
  81072e:	e8 3e 02 00 00       	call   810971 <nsipc_socket>
  810733:	83 c4 10             	add    $0x10,%esp
  810736:	85 c0                	test   %eax,%eax
  810738:	78 05                	js     81073f <socket+0x20>
		return r;
	return alloc_sockfd(r);
  81073a:	e8 ab fe ff ff       	call   8105ea <alloc_sockfd>
}
  81073f:	c9                   	leave  
  810740:	c3                   	ret    

00810741 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810741:	55                   	push   %ebp
  810742:	89 e5                	mov    %esp,%ebp
  810744:	53                   	push   %ebx
  810745:	83 ec 04             	sub    $0x4,%esp
  810748:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  81074a:	83 3d d0 c1 b3 00 00 	cmpl   $0x0,0xb3c1d0
  810751:	74 26                	je     810779 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810753:	6a 07                	push   $0x7
  810755:	68 00 e0 b3 00       	push   $0xb3e000
  81075a:	53                   	push   %ebx
  81075b:	ff 35 d0 c1 b3 00    	pushl  0xb3c1d0
  810761:	e8 0f f5 ff ff       	call   80fc75 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810766:	83 c4 0c             	add    $0xc,%esp
  810769:	6a 00                	push   $0x0
  81076b:	6a 00                	push   $0x0
  81076d:	6a 00                	push   $0x0
  81076f:	e8 98 f4 ff ff       	call   80fc0c <ipc_recv>
}
  810774:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810777:	c9                   	leave  
  810778:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810779:	83 ec 0c             	sub    $0xc,%esp
  81077c:	6a 02                	push   $0x2
  81077e:	e8 4a f5 ff ff       	call   80fccd <ipc_find_env>
  810783:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
  810788:	83 c4 10             	add    $0x10,%esp
  81078b:	eb c6                	jmp    810753 <nsipc+0x12>

0081078d <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81078d:	55                   	push   %ebp
  81078e:	89 e5                	mov    %esp,%ebp
  810790:	56                   	push   %esi
  810791:	53                   	push   %ebx
  810792:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810795:	8b 45 08             	mov    0x8(%ebp),%eax
  810798:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  81079d:	8b 06                	mov    (%esi),%eax
  81079f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  8107a4:	b8 01 00 00 00       	mov    $0x1,%eax
  8107a9:	e8 93 ff ff ff       	call   810741 <nsipc>
  8107ae:	89 c3                	mov    %eax,%ebx
  8107b0:	85 c0                	test   %eax,%eax
  8107b2:	79 09                	jns    8107bd <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  8107b4:	89 d8                	mov    %ebx,%eax
  8107b6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8107b9:	5b                   	pop    %ebx
  8107ba:	5e                   	pop    %esi
  8107bb:	5d                   	pop    %ebp
  8107bc:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  8107bd:	83 ec 04             	sub    $0x4,%esp
  8107c0:	ff 35 10 e0 b3 00    	pushl  0xb3e010
  8107c6:	68 00 e0 b3 00       	push   $0xb3e000
  8107cb:	ff 75 0c             	pushl  0xc(%ebp)
  8107ce:	e8 19 ea ff ff       	call   80f1ec <memmove>
		*addrlen = ret->ret_addrlen;
  8107d3:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  8107d8:	89 06                	mov    %eax,(%esi)
  8107da:	83 c4 10             	add    $0x10,%esp
	return r;
  8107dd:	eb d5                	jmp    8107b4 <nsipc_accept+0x27>

008107df <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8107df:	55                   	push   %ebp
  8107e0:	89 e5                	mov    %esp,%ebp
  8107e2:	53                   	push   %ebx
  8107e3:	83 ec 08             	sub    $0x8,%esp
  8107e6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  8107e9:	8b 45 08             	mov    0x8(%ebp),%eax
  8107ec:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8107f1:	53                   	push   %ebx
  8107f2:	ff 75 0c             	pushl  0xc(%ebp)
  8107f5:	68 04 e0 b3 00       	push   $0xb3e004
  8107fa:	e8 ed e9 ff ff       	call   80f1ec <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8107ff:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  810805:	b8 02 00 00 00       	mov    $0x2,%eax
  81080a:	e8 32 ff ff ff       	call   810741 <nsipc>
}
  81080f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810812:	c9                   	leave  
  810813:	c3                   	ret    

00810814 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  810814:	55                   	push   %ebp
  810815:	89 e5                	mov    %esp,%ebp
  810817:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  81081a:	8b 45 08             	mov    0x8(%ebp),%eax
  81081d:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  810822:	8b 45 0c             	mov    0xc(%ebp),%eax
  810825:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  81082a:	b8 03 00 00 00       	mov    $0x3,%eax
  81082f:	e8 0d ff ff ff       	call   810741 <nsipc>
}
  810834:	c9                   	leave  
  810835:	c3                   	ret    

00810836 <nsipc_close>:

int
nsipc_close(int s)
{
  810836:	55                   	push   %ebp
  810837:	89 e5                	mov    %esp,%ebp
  810839:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  81083c:	8b 45 08             	mov    0x8(%ebp),%eax
  81083f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  810844:	b8 04 00 00 00       	mov    $0x4,%eax
  810849:	e8 f3 fe ff ff       	call   810741 <nsipc>
}
  81084e:	c9                   	leave  
  81084f:	c3                   	ret    

00810850 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810850:	55                   	push   %ebp
  810851:	89 e5                	mov    %esp,%ebp
  810853:	53                   	push   %ebx
  810854:	83 ec 08             	sub    $0x8,%esp
  810857:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  81085a:	8b 45 08             	mov    0x8(%ebp),%eax
  81085d:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  810862:	53                   	push   %ebx
  810863:	ff 75 0c             	pushl  0xc(%ebp)
  810866:	68 04 e0 b3 00       	push   $0xb3e004
  81086b:	e8 7c e9 ff ff       	call   80f1ec <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810870:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  810876:	b8 05 00 00 00       	mov    $0x5,%eax
  81087b:	e8 c1 fe ff ff       	call   810741 <nsipc>
}
  810880:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810883:	c9                   	leave  
  810884:	c3                   	ret    

00810885 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810885:	55                   	push   %ebp
  810886:	89 e5                	mov    %esp,%ebp
  810888:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  81088b:	8b 45 08             	mov    0x8(%ebp),%eax
  81088e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  810893:	8b 45 0c             	mov    0xc(%ebp),%eax
  810896:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  81089b:	b8 06 00 00 00       	mov    $0x6,%eax
  8108a0:	e8 9c fe ff ff       	call   810741 <nsipc>
}
  8108a5:	c9                   	leave  
  8108a6:	c3                   	ret    

008108a7 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  8108a7:	55                   	push   %ebp
  8108a8:	89 e5                	mov    %esp,%ebp
  8108aa:	56                   	push   %esi
  8108ab:	53                   	push   %ebx
  8108ac:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  8108af:	8b 45 08             	mov    0x8(%ebp),%eax
  8108b2:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  8108b7:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  8108bd:	8b 45 14             	mov    0x14(%ebp),%eax
  8108c0:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8108c5:	b8 07 00 00 00       	mov    $0x7,%eax
  8108ca:	e8 72 fe ff ff       	call   810741 <nsipc>
  8108cf:	89 c3                	mov    %eax,%ebx
  8108d1:	85 c0                	test   %eax,%eax
  8108d3:	78 1f                	js     8108f4 <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  8108d5:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  8108da:	7f 21                	jg     8108fd <nsipc_recv+0x56>
  8108dc:	39 c6                	cmp    %eax,%esi
  8108de:	7c 1d                	jl     8108fd <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8108e0:	83 ec 04             	sub    $0x4,%esp
  8108e3:	50                   	push   %eax
  8108e4:	68 00 e0 b3 00       	push   $0xb3e000
  8108e9:	ff 75 0c             	pushl  0xc(%ebp)
  8108ec:	e8 fb e8 ff ff       	call   80f1ec <memmove>
  8108f1:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  8108f4:	89 d8                	mov    %ebx,%eax
  8108f6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8108f9:	5b                   	pop    %ebx
  8108fa:	5e                   	pop    %esi
  8108fb:	5d                   	pop    %ebp
  8108fc:	c3                   	ret    
		assert(r < 1600 && r <= len);
  8108fd:	68 7e 40 81 00       	push   $0x81407e
  810902:	68 6b 2c 81 00       	push   $0x812c6b
  810907:	6a 62                	push   $0x62
  810909:	68 93 40 81 00       	push   $0x814093
  81090e:	e8 f6 de ff ff       	call   80e809 <_panic>

00810913 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  810913:	55                   	push   %ebp
  810914:	89 e5                	mov    %esp,%ebp
  810916:	53                   	push   %ebx
  810917:	83 ec 04             	sub    $0x4,%esp
  81091a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  81091d:	8b 45 08             	mov    0x8(%ebp),%eax
  810920:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  810925:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  81092b:	7f 2e                	jg     81095b <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  81092d:	83 ec 04             	sub    $0x4,%esp
  810930:	53                   	push   %ebx
  810931:	ff 75 0c             	pushl  0xc(%ebp)
  810934:	68 0c e0 b3 00       	push   $0xb3e00c
  810939:	e8 ae e8 ff ff       	call   80f1ec <memmove>
	nsipcbuf.send.req_size = size;
  81093e:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  810944:	8b 45 14             	mov    0x14(%ebp),%eax
  810947:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  81094c:	b8 08 00 00 00       	mov    $0x8,%eax
  810951:	e8 eb fd ff ff       	call   810741 <nsipc>
}
  810956:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810959:	c9                   	leave  
  81095a:	c3                   	ret    
	assert(size < 1600);
  81095b:	68 9f 40 81 00       	push   $0x81409f
  810960:	68 6b 2c 81 00       	push   $0x812c6b
  810965:	6a 6d                	push   $0x6d
  810967:	68 93 40 81 00       	push   $0x814093
  81096c:	e8 98 de ff ff       	call   80e809 <_panic>

00810971 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810971:	55                   	push   %ebp
  810972:	89 e5                	mov    %esp,%ebp
  810974:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810977:	8b 45 08             	mov    0x8(%ebp),%eax
  81097a:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  81097f:	8b 45 0c             	mov    0xc(%ebp),%eax
  810982:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  810987:	8b 45 10             	mov    0x10(%ebp),%eax
  81098a:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  81098f:	b8 09 00 00 00       	mov    $0x9,%eax
  810994:	e8 a8 fd ff ff       	call   810741 <nsipc>
}
  810999:	c9                   	leave  
  81099a:	c3                   	ret    

0081099b <free>:
	return v;
}

void
free(void *v)
{
  81099b:	55                   	push   %ebp
  81099c:	89 e5                	mov    %esp,%ebp
  81099e:	53                   	push   %ebx
  81099f:	83 ec 04             	sub    $0x4,%esp
  8109a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8109a5:	85 db                	test   %ebx,%ebx
  8109a7:	0f 84 85 00 00 00    	je     810a32 <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8109ad:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8109b3:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8109b8:	77 51                	ja     810a0b <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  8109ba:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8109c0:	89 d8                	mov    %ebx,%eax
  8109c2:	c1 e8 0c             	shr    $0xc,%eax
  8109c5:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8109cc:	f6 c4 02             	test   $0x2,%ah
  8109cf:	74 50                	je     810a21 <free+0x86>
		sys_page_unmap(0, c);
  8109d1:	83 ec 08             	sub    $0x8,%esp
  8109d4:	53                   	push   %ebx
  8109d5:	6a 00                	push   $0x0
  8109d7:	e8 f9 ea ff ff       	call   80f4d5 <sys_page_unmap>
		c += PGSIZE;
  8109dc:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  8109e2:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  8109e8:	83 c4 10             	add    $0x10,%esp
  8109eb:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  8109f0:	76 ce                	jbe    8109c0 <free+0x25>
  8109f2:	68 e7 40 81 00       	push   $0x8140e7
  8109f7:	68 6b 2c 81 00       	push   $0x812c6b
  8109fc:	68 81 00 00 00       	push   $0x81
  810a01:	68 da 40 81 00       	push   $0x8140da
  810a06:	e8 fe dd ff ff       	call   80e809 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  810a0b:	68 ac 40 81 00       	push   $0x8140ac
  810a10:	68 6b 2c 81 00       	push   $0x812c6b
  810a15:	6a 7a                	push   $0x7a
  810a17:	68 da 40 81 00       	push   $0x8140da
  810a1c:	e8 e8 dd ff ff       	call   80e809 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  810a21:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  810a27:	83 e8 01             	sub    $0x1,%eax
  810a2a:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  810a30:	74 05                	je     810a37 <free+0x9c>
		sys_page_unmap(0, c);
}
  810a32:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810a35:	c9                   	leave  
  810a36:	c3                   	ret    
		sys_page_unmap(0, c);
  810a37:	83 ec 08             	sub    $0x8,%esp
  810a3a:	53                   	push   %ebx
  810a3b:	6a 00                	push   $0x0
  810a3d:	e8 93 ea ff ff       	call   80f4d5 <sys_page_unmap>
  810a42:	83 c4 10             	add    $0x10,%esp
  810a45:	eb eb                	jmp    810a32 <free+0x97>

00810a47 <malloc>:
{
  810a47:	55                   	push   %ebp
  810a48:	89 e5                	mov    %esp,%ebp
  810a4a:	57                   	push   %edi
  810a4b:	56                   	push   %esi
  810a4c:	53                   	push   %ebx
  810a4d:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  810a50:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
  810a55:	85 c0                	test   %eax,%eax
  810a57:	74 74                	je     810acd <malloc+0x86>
	n = ROUNDUP(n, 4);
  810a59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810a5c:	8d 51 03             	lea    0x3(%ecx),%edx
  810a5f:	83 e2 fc             	and    $0xfffffffc,%edx
  810a62:	89 d6                	mov    %edx,%esi
  810a64:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810a67:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810a6d:	0f 87 55 01 00 00    	ja     810bc8 <malloc+0x181>
	if ((uintptr_t) mptr % PGSIZE){
  810a73:	89 c1                	mov    %eax,%ecx
  810a75:	a9 ff 0f 00 00       	test   $0xfff,%eax
  810a7a:	74 30                	je     810aac <malloc+0x65>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  810a7c:	89 c3                	mov    %eax,%ebx
  810a7e:	c1 eb 0c             	shr    $0xc,%ebx
  810a81:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810a85:	c1 ea 0c             	shr    $0xc,%edx
  810a88:	39 d3                	cmp    %edx,%ebx
  810a8a:	74 64                	je     810af0 <malloc+0xa9>
		free(mptr);	/* drop reference to this page */
  810a8c:	83 ec 0c             	sub    $0xc,%esp
  810a8f:	50                   	push   %eax
  810a90:	e8 06 ff ff ff       	call   81099b <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810a95:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
  810a9a:	05 00 10 00 00       	add    $0x1000,%eax
  810a9f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810aa4:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
  810aa9:	83 c4 10             	add    $0x10,%esp
  810aac:	8b 15 d4 c1 b3 00    	mov    0xb3c1d4,%edx
{
  810ab2:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810ab9:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  810abe:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810ac1:	8d 78 04             	lea    0x4(%eax),%edi
  810ac4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810ac8:	e9 86 00 00 00       	jmp    810b53 <malloc+0x10c>
		mptr = mbegin;
  810acd:	c7 05 d4 c1 b3 00 00 	movl   $0x8000000,0xb3c1d4
  810ad4:	00 00 08 
	n = ROUNDUP(n, 4);
  810ad7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810ada:	8d 51 03             	lea    0x3(%ecx),%edx
  810add:	83 e2 fc             	and    $0xfffffffc,%edx
  810ae0:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810ae3:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810ae9:	76 c1                	jbe    810aac <malloc+0x65>
  810aeb:	e9 fd 00 00 00       	jmp    810bed <malloc+0x1a6>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810af0:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  810af6:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  810afc:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  810b00:	89 f2                	mov    %esi,%edx
  810b02:	01 c2                	add    %eax,%edx
  810b04:	89 15 d4 c1 b3 00    	mov    %edx,0xb3c1d4
			return v;
  810b0a:	e9 de 00 00 00       	jmp    810bed <malloc+0x1a6>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810b0f:	05 00 10 00 00       	add    $0x1000,%eax
  810b14:	39 c8                	cmp    %ecx,%eax
  810b16:	73 66                	jae    810b7e <malloc+0x137>
		if (va >= (uintptr_t) mend
  810b18:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  810b1d:	77 22                	ja     810b41 <malloc+0xfa>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  810b1f:	89 c3                	mov    %eax,%ebx
  810b21:	c1 eb 16             	shr    $0x16,%ebx
  810b24:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  810b2b:	f6 c3 01             	test   $0x1,%bl
  810b2e:	74 df                	je     810b0f <malloc+0xc8>
  810b30:	89 c3                	mov    %eax,%ebx
  810b32:	c1 eb 0c             	shr    $0xc,%ebx
  810b35:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  810b3c:	f6 c3 01             	test   $0x1,%bl
  810b3f:	74 ce                	je     810b0f <malloc+0xc8>
  810b41:	81 c2 00 10 00 00    	add    $0x1000,%edx
  810b47:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  810b4b:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  810b51:	74 0a                	je     810b5d <malloc+0x116>
  810b53:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  810b56:	89 d0                	mov    %edx,%eax
  810b58:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  810b5b:	eb b7                	jmp    810b14 <malloc+0xcd>
			mptr = mbegin;
  810b5d:	ba 00 00 00 08       	mov    $0x8000000,%edx
  810b62:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  810b67:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  810b6b:	75 e6                	jne    810b53 <malloc+0x10c>
  810b6d:	c7 05 d4 c1 b3 00 00 	movl   $0x8000000,0xb3c1d4
  810b74:	00 00 08 
				return 0;	/* out of address space */
  810b77:	b8 00 00 00 00       	mov    $0x0,%eax
  810b7c:	eb 6f                	jmp    810bed <malloc+0x1a6>
  810b7e:	89 f0                	mov    %esi,%eax
  810b80:	84 c0                	test   %al,%al
  810b82:	74 08                	je     810b8c <malloc+0x145>
  810b84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810b87:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  810b8c:	bb 00 00 00 00       	mov    $0x0,%ebx
  810b91:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810b94:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  810b9a:	39 f7                	cmp    %esi,%edi
  810b9c:	76 57                	jbe    810bf5 <malloc+0x1ae>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810b9e:	83 ec 04             	sub    $0x4,%esp
  810ba1:	68 07 02 00 00       	push   $0x207
  810ba6:	89 d8                	mov    %ebx,%eax
  810ba8:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810bae:	50                   	push   %eax
  810baf:	6a 00                	push   $0x0
  810bb1:	e8 9a e8 ff ff       	call   80f450 <sys_page_alloc>
  810bb6:	83 c4 10             	add    $0x10,%esp
  810bb9:	85 c0                	test   %eax,%eax
  810bbb:	78 55                	js     810c12 <malloc+0x1cb>
	for (i = 0; i < n + 4; i += PGSIZE){
  810bbd:	89 f3                	mov    %esi,%ebx
  810bbf:	eb d0                	jmp    810b91 <malloc+0x14a>
			return 0;	/* out of physical memory */
  810bc1:	b8 00 00 00 00       	mov    $0x0,%eax
  810bc6:	eb 25                	jmp    810bed <malloc+0x1a6>
		return 0;
  810bc8:	b8 00 00 00 00       	mov    $0x0,%eax
  810bcd:	eb 1e                	jmp    810bed <malloc+0x1a6>
	ref = (uint32_t*) (mptr + i - 4);
  810bcf:	a1 d4 c1 b3 00       	mov    0xb3c1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810bd4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810bd7:	c7 84 08 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%ecx,1)
  810bde:	02 00 00 00 
	mptr += n;
  810be2:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810be5:	01 c2                	add    %eax,%edx
  810be7:	89 15 d4 c1 b3 00    	mov    %edx,0xb3c1d4
}
  810bed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810bf0:	5b                   	pop    %ebx
  810bf1:	5e                   	pop    %esi
  810bf2:	5f                   	pop    %edi
  810bf3:	5d                   	pop    %ebp
  810bf4:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810bf5:	83 ec 04             	sub    $0x4,%esp
  810bf8:	6a 07                	push   $0x7
  810bfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810bfd:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810c03:	50                   	push   %eax
  810c04:	6a 00                	push   $0x0
  810c06:	e8 45 e8 ff ff       	call   80f450 <sys_page_alloc>
  810c0b:	83 c4 10             	add    $0x10,%esp
  810c0e:	85 c0                	test   %eax,%eax
  810c10:	79 bd                	jns    810bcf <malloc+0x188>
			for (; i >= 0; i -= PGSIZE)
  810c12:	85 db                	test   %ebx,%ebx
  810c14:	78 ab                	js     810bc1 <malloc+0x17a>
				sys_page_unmap(0, mptr + i);
  810c16:	83 ec 08             	sub    $0x8,%esp
  810c19:	89 d8                	mov    %ebx,%eax
  810c1b:	03 05 d4 c1 b3 00    	add    0xb3c1d4,%eax
  810c21:	50                   	push   %eax
  810c22:	6a 00                	push   $0x0
  810c24:	e8 ac e8 ff ff       	call   80f4d5 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810c29:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810c2f:	83 c4 10             	add    $0x10,%esp
  810c32:	eb de                	jmp    810c12 <malloc+0x1cb>

00810c34 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810c34:	55                   	push   %ebp
  810c35:	89 e5                	mov    %esp,%ebp
  810c37:	56                   	push   %esi
  810c38:	53                   	push   %ebx
  810c39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810c3c:	83 ec 0c             	sub    $0xc,%esp
  810c3f:	ff 75 08             	pushl  0x8(%ebp)
  810c42:	e8 d1 f0 ff ff       	call   80fd18 <fd2data>
  810c47:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810c49:	83 c4 08             	add    $0x8,%esp
  810c4c:	68 ff 40 81 00       	push   $0x8140ff
  810c51:	53                   	push   %ebx
  810c52:	e8 07 e4 ff ff       	call   80f05e <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810c57:	8b 46 04             	mov    0x4(%esi),%eax
  810c5a:	2b 06                	sub    (%esi),%eax
  810c5c:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810c62:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810c69:	00 00 00 
	stat->st_dev = &devpipe;
  810c6c:	c7 83 88 00 00 00 24 	movl   $0x815324,0x88(%ebx)
  810c73:	53 81 00 
	return 0;
}
  810c76:	b8 00 00 00 00       	mov    $0x0,%eax
  810c7b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810c7e:	5b                   	pop    %ebx
  810c7f:	5e                   	pop    %esi
  810c80:	5d                   	pop    %ebp
  810c81:	c3                   	ret    

00810c82 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810c82:	55                   	push   %ebp
  810c83:	89 e5                	mov    %esp,%ebp
  810c85:	53                   	push   %ebx
  810c86:	83 ec 0c             	sub    $0xc,%esp
  810c89:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810c8c:	53                   	push   %ebx
  810c8d:	6a 00                	push   $0x0
  810c8f:	e8 41 e8 ff ff       	call   80f4d5 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810c94:	89 1c 24             	mov    %ebx,(%esp)
  810c97:	e8 7c f0 ff ff       	call   80fd18 <fd2data>
  810c9c:	83 c4 08             	add    $0x8,%esp
  810c9f:	50                   	push   %eax
  810ca0:	6a 00                	push   $0x0
  810ca2:	e8 2e e8 ff ff       	call   80f4d5 <sys_page_unmap>
}
  810ca7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810caa:	c9                   	leave  
  810cab:	c3                   	ret    

00810cac <_pipeisclosed>:
{
  810cac:	55                   	push   %ebp
  810cad:	89 e5                	mov    %esp,%ebp
  810caf:	57                   	push   %edi
  810cb0:	56                   	push   %esi
  810cb1:	53                   	push   %ebx
  810cb2:	83 ec 1c             	sub    $0x1c,%esp
  810cb5:	89 c7                	mov    %eax,%edi
  810cb7:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810cb9:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  810cbe:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810cc1:	83 ec 0c             	sub    $0xc,%esp
  810cc4:	57                   	push   %edi
  810cc5:	e8 c2 04 00 00       	call   81118c <pageref>
  810cca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810ccd:	89 34 24             	mov    %esi,(%esp)
  810cd0:	e8 b7 04 00 00       	call   81118c <pageref>
		nn = thisenv->env_runs;
  810cd5:	8b 15 5c c2 b3 00    	mov    0xb3c25c,%edx
  810cdb:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810cde:	83 c4 10             	add    $0x10,%esp
  810ce1:	39 cb                	cmp    %ecx,%ebx
  810ce3:	74 1b                	je     810d00 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810ce5:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810ce8:	75 cf                	jne    810cb9 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810cea:	8b 42 58             	mov    0x58(%edx),%eax
  810ced:	6a 01                	push   $0x1
  810cef:	50                   	push   %eax
  810cf0:	53                   	push   %ebx
  810cf1:	68 06 41 81 00       	push   $0x814106
  810cf6:	e8 04 dc ff ff       	call   80e8ff <cprintf>
  810cfb:	83 c4 10             	add    $0x10,%esp
  810cfe:	eb b9                	jmp    810cb9 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810d00:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810d03:	0f 94 c0             	sete   %al
  810d06:	0f b6 c0             	movzbl %al,%eax
}
  810d09:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d0c:	5b                   	pop    %ebx
  810d0d:	5e                   	pop    %esi
  810d0e:	5f                   	pop    %edi
  810d0f:	5d                   	pop    %ebp
  810d10:	c3                   	ret    

00810d11 <devpipe_write>:
{
  810d11:	55                   	push   %ebp
  810d12:	89 e5                	mov    %esp,%ebp
  810d14:	57                   	push   %edi
  810d15:	56                   	push   %esi
  810d16:	53                   	push   %ebx
  810d17:	83 ec 28             	sub    $0x28,%esp
  810d1a:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810d1d:	56                   	push   %esi
  810d1e:	e8 f5 ef ff ff       	call   80fd18 <fd2data>
  810d23:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810d25:	83 c4 10             	add    $0x10,%esp
  810d28:	bf 00 00 00 00       	mov    $0x0,%edi
  810d2d:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810d30:	74 4f                	je     810d81 <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810d32:	8b 43 04             	mov    0x4(%ebx),%eax
  810d35:	8b 0b                	mov    (%ebx),%ecx
  810d37:	8d 51 20             	lea    0x20(%ecx),%edx
  810d3a:	39 d0                	cmp    %edx,%eax
  810d3c:	72 14                	jb     810d52 <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810d3e:	89 da                	mov    %ebx,%edx
  810d40:	89 f0                	mov    %esi,%eax
  810d42:	e8 65 ff ff ff       	call   810cac <_pipeisclosed>
  810d47:	85 c0                	test   %eax,%eax
  810d49:	75 3b                	jne    810d86 <devpipe_write+0x75>
			sys_yield();
  810d4b:	e8 e1 e6 ff ff       	call   80f431 <sys_yield>
  810d50:	eb e0                	jmp    810d32 <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810d52:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810d55:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810d59:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810d5c:	89 c2                	mov    %eax,%edx
  810d5e:	c1 fa 1f             	sar    $0x1f,%edx
  810d61:	89 d1                	mov    %edx,%ecx
  810d63:	c1 e9 1b             	shr    $0x1b,%ecx
  810d66:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810d69:	83 e2 1f             	and    $0x1f,%edx
  810d6c:	29 ca                	sub    %ecx,%edx
  810d6e:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810d72:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810d76:	83 c0 01             	add    $0x1,%eax
  810d79:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810d7c:	83 c7 01             	add    $0x1,%edi
  810d7f:	eb ac                	jmp    810d2d <devpipe_write+0x1c>
	return i;
  810d81:	8b 45 10             	mov    0x10(%ebp),%eax
  810d84:	eb 05                	jmp    810d8b <devpipe_write+0x7a>
				return 0;
  810d86:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810d8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810d8e:	5b                   	pop    %ebx
  810d8f:	5e                   	pop    %esi
  810d90:	5f                   	pop    %edi
  810d91:	5d                   	pop    %ebp
  810d92:	c3                   	ret    

00810d93 <devpipe_read>:
{
  810d93:	55                   	push   %ebp
  810d94:	89 e5                	mov    %esp,%ebp
  810d96:	57                   	push   %edi
  810d97:	56                   	push   %esi
  810d98:	53                   	push   %ebx
  810d99:	83 ec 18             	sub    $0x18,%esp
  810d9c:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810d9f:	57                   	push   %edi
  810da0:	e8 73 ef ff ff       	call   80fd18 <fd2data>
  810da5:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810da7:	83 c4 10             	add    $0x10,%esp
  810daa:	be 00 00 00 00       	mov    $0x0,%esi
  810daf:	3b 75 10             	cmp    0x10(%ebp),%esi
  810db2:	75 14                	jne    810dc8 <devpipe_read+0x35>
	return i;
  810db4:	8b 45 10             	mov    0x10(%ebp),%eax
  810db7:	eb 02                	jmp    810dbb <devpipe_read+0x28>
				return i;
  810db9:	89 f0                	mov    %esi,%eax
}
  810dbb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810dbe:	5b                   	pop    %ebx
  810dbf:	5e                   	pop    %esi
  810dc0:	5f                   	pop    %edi
  810dc1:	5d                   	pop    %ebp
  810dc2:	c3                   	ret    
			sys_yield();
  810dc3:	e8 69 e6 ff ff       	call   80f431 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810dc8:	8b 03                	mov    (%ebx),%eax
  810dca:	3b 43 04             	cmp    0x4(%ebx),%eax
  810dcd:	75 18                	jne    810de7 <devpipe_read+0x54>
			if (i > 0)
  810dcf:	85 f6                	test   %esi,%esi
  810dd1:	75 e6                	jne    810db9 <devpipe_read+0x26>
			if (_pipeisclosed(fd, p))
  810dd3:	89 da                	mov    %ebx,%edx
  810dd5:	89 f8                	mov    %edi,%eax
  810dd7:	e8 d0 fe ff ff       	call   810cac <_pipeisclosed>
  810ddc:	85 c0                	test   %eax,%eax
  810dde:	74 e3                	je     810dc3 <devpipe_read+0x30>
				return 0;
  810de0:	b8 00 00 00 00       	mov    $0x0,%eax
  810de5:	eb d4                	jmp    810dbb <devpipe_read+0x28>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810de7:	99                   	cltd   
  810de8:	c1 ea 1b             	shr    $0x1b,%edx
  810deb:	01 d0                	add    %edx,%eax
  810ded:	83 e0 1f             	and    $0x1f,%eax
  810df0:	29 d0                	sub    %edx,%eax
  810df2:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810df7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810dfa:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810dfd:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810e00:	83 c6 01             	add    $0x1,%esi
  810e03:	eb aa                	jmp    810daf <devpipe_read+0x1c>

00810e05 <pipe>:
{
  810e05:	55                   	push   %ebp
  810e06:	89 e5                	mov    %esp,%ebp
  810e08:	56                   	push   %esi
  810e09:	53                   	push   %ebx
  810e0a:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810e0d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e10:	50                   	push   %eax
  810e11:	e8 19 ef ff ff       	call   80fd2f <fd_alloc>
  810e16:	89 c3                	mov    %eax,%ebx
  810e18:	83 c4 10             	add    $0x10,%esp
  810e1b:	85 c0                	test   %eax,%eax
  810e1d:	0f 88 23 01 00 00    	js     810f46 <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810e23:	83 ec 04             	sub    $0x4,%esp
  810e26:	68 07 04 00 00       	push   $0x407
  810e2b:	ff 75 f4             	pushl  -0xc(%ebp)
  810e2e:	6a 00                	push   $0x0
  810e30:	e8 1b e6 ff ff       	call   80f450 <sys_page_alloc>
  810e35:	89 c3                	mov    %eax,%ebx
  810e37:	83 c4 10             	add    $0x10,%esp
  810e3a:	85 c0                	test   %eax,%eax
  810e3c:	0f 88 04 01 00 00    	js     810f46 <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  810e42:	83 ec 0c             	sub    $0xc,%esp
  810e45:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810e48:	50                   	push   %eax
  810e49:	e8 e1 ee ff ff       	call   80fd2f <fd_alloc>
  810e4e:	89 c3                	mov    %eax,%ebx
  810e50:	83 c4 10             	add    $0x10,%esp
  810e53:	85 c0                	test   %eax,%eax
  810e55:	0f 88 db 00 00 00    	js     810f36 <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810e5b:	83 ec 04             	sub    $0x4,%esp
  810e5e:	68 07 04 00 00       	push   $0x407
  810e63:	ff 75 f0             	pushl  -0x10(%ebp)
  810e66:	6a 00                	push   $0x0
  810e68:	e8 e3 e5 ff ff       	call   80f450 <sys_page_alloc>
  810e6d:	89 c3                	mov    %eax,%ebx
  810e6f:	83 c4 10             	add    $0x10,%esp
  810e72:	85 c0                	test   %eax,%eax
  810e74:	0f 88 bc 00 00 00    	js     810f36 <pipe+0x131>
	va = fd2data(fd0);
  810e7a:	83 ec 0c             	sub    $0xc,%esp
  810e7d:	ff 75 f4             	pushl  -0xc(%ebp)
  810e80:	e8 93 ee ff ff       	call   80fd18 <fd2data>
  810e85:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810e87:	83 c4 0c             	add    $0xc,%esp
  810e8a:	68 07 04 00 00       	push   $0x407
  810e8f:	50                   	push   %eax
  810e90:	6a 00                	push   $0x0
  810e92:	e8 b9 e5 ff ff       	call   80f450 <sys_page_alloc>
  810e97:	89 c3                	mov    %eax,%ebx
  810e99:	83 c4 10             	add    $0x10,%esp
  810e9c:	85 c0                	test   %eax,%eax
  810e9e:	0f 88 82 00 00 00    	js     810f26 <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810ea4:	83 ec 0c             	sub    $0xc,%esp
  810ea7:	ff 75 f0             	pushl  -0x10(%ebp)
  810eaa:	e8 69 ee ff ff       	call   80fd18 <fd2data>
  810eaf:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810eb6:	50                   	push   %eax
  810eb7:	6a 00                	push   $0x0
  810eb9:	56                   	push   %esi
  810eba:	6a 00                	push   $0x0
  810ebc:	e8 d2 e5 ff ff       	call   80f493 <sys_page_map>
  810ec1:	89 c3                	mov    %eax,%ebx
  810ec3:	83 c4 20             	add    $0x20,%esp
  810ec6:	85 c0                	test   %eax,%eax
  810ec8:	78 4e                	js     810f18 <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  810eca:	a1 24 53 81 00       	mov    0x815324,%eax
  810ecf:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810ed2:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810ed4:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810ed7:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810ede:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810ee1:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810ee6:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810eed:	83 ec 0c             	sub    $0xc,%esp
  810ef0:	ff 75 f4             	pushl  -0xc(%ebp)
  810ef3:	e8 10 ee ff ff       	call   80fd08 <fd2num>
  810ef8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810efb:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810efd:	83 c4 04             	add    $0x4,%esp
  810f00:	ff 75 f0             	pushl  -0x10(%ebp)
  810f03:	e8 00 ee ff ff       	call   80fd08 <fd2num>
  810f08:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810f0b:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810f0e:	83 c4 10             	add    $0x10,%esp
  810f11:	bb 00 00 00 00       	mov    $0x0,%ebx
  810f16:	eb 2e                	jmp    810f46 <pipe+0x141>
	sys_page_unmap(0, va);
  810f18:	83 ec 08             	sub    $0x8,%esp
  810f1b:	56                   	push   %esi
  810f1c:	6a 00                	push   $0x0
  810f1e:	e8 b2 e5 ff ff       	call   80f4d5 <sys_page_unmap>
  810f23:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810f26:	83 ec 08             	sub    $0x8,%esp
  810f29:	ff 75 f0             	pushl  -0x10(%ebp)
  810f2c:	6a 00                	push   $0x0
  810f2e:	e8 a2 e5 ff ff       	call   80f4d5 <sys_page_unmap>
  810f33:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810f36:	83 ec 08             	sub    $0x8,%esp
  810f39:	ff 75 f4             	pushl  -0xc(%ebp)
  810f3c:	6a 00                	push   $0x0
  810f3e:	e8 92 e5 ff ff       	call   80f4d5 <sys_page_unmap>
  810f43:	83 c4 10             	add    $0x10,%esp
}
  810f46:	89 d8                	mov    %ebx,%eax
  810f48:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810f4b:	5b                   	pop    %ebx
  810f4c:	5e                   	pop    %esi
  810f4d:	5d                   	pop    %ebp
  810f4e:	c3                   	ret    

00810f4f <pipeisclosed>:
{
  810f4f:	55                   	push   %ebp
  810f50:	89 e5                	mov    %esp,%ebp
  810f52:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810f55:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810f58:	50                   	push   %eax
  810f59:	ff 75 08             	pushl  0x8(%ebp)
  810f5c:	e8 20 ee ff ff       	call   80fd81 <fd_lookup>
  810f61:	83 c4 10             	add    $0x10,%esp
  810f64:	85 c0                	test   %eax,%eax
  810f66:	78 18                	js     810f80 <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810f68:	83 ec 0c             	sub    $0xc,%esp
  810f6b:	ff 75 f4             	pushl  -0xc(%ebp)
  810f6e:	e8 a5 ed ff ff       	call   80fd18 <fd2data>
	return _pipeisclosed(fd, p);
  810f73:	89 c2                	mov    %eax,%edx
  810f75:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810f78:	e8 2f fd ff ff       	call   810cac <_pipeisclosed>
  810f7d:	83 c4 10             	add    $0x10,%esp
}
  810f80:	c9                   	leave  
  810f81:	c3                   	ret    

00810f82 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810f82:	b8 00 00 00 00       	mov    $0x0,%eax
  810f87:	c3                   	ret    

00810f88 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810f88:	55                   	push   %ebp
  810f89:	89 e5                	mov    %esp,%ebp
  810f8b:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810f8e:	68 1e 41 81 00       	push   $0x81411e
  810f93:	ff 75 0c             	pushl  0xc(%ebp)
  810f96:	e8 c3 e0 ff ff       	call   80f05e <strcpy>
	return 0;
}
  810f9b:	b8 00 00 00 00       	mov    $0x0,%eax
  810fa0:	c9                   	leave  
  810fa1:	c3                   	ret    

00810fa2 <devcons_write>:
{
  810fa2:	55                   	push   %ebp
  810fa3:	89 e5                	mov    %esp,%ebp
  810fa5:	57                   	push   %edi
  810fa6:	56                   	push   %esi
  810fa7:	53                   	push   %ebx
  810fa8:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810fae:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810fb3:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810fb9:	3b 75 10             	cmp    0x10(%ebp),%esi
  810fbc:	73 31                	jae    810fef <devcons_write+0x4d>
		m = n - tot;
  810fbe:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810fc1:	29 f3                	sub    %esi,%ebx
  810fc3:	83 fb 7f             	cmp    $0x7f,%ebx
  810fc6:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810fcb:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810fce:	83 ec 04             	sub    $0x4,%esp
  810fd1:	53                   	push   %ebx
  810fd2:	89 f0                	mov    %esi,%eax
  810fd4:	03 45 0c             	add    0xc(%ebp),%eax
  810fd7:	50                   	push   %eax
  810fd8:	57                   	push   %edi
  810fd9:	e8 0e e2 ff ff       	call   80f1ec <memmove>
		sys_cputs(buf, m);
  810fde:	83 c4 08             	add    $0x8,%esp
  810fe1:	53                   	push   %ebx
  810fe2:	57                   	push   %edi
  810fe3:	e8 ac e3 ff ff       	call   80f394 <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810fe8:	01 de                	add    %ebx,%esi
  810fea:	83 c4 10             	add    $0x10,%esp
  810fed:	eb ca                	jmp    810fb9 <devcons_write+0x17>
}
  810fef:	89 f0                	mov    %esi,%eax
  810ff1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810ff4:	5b                   	pop    %ebx
  810ff5:	5e                   	pop    %esi
  810ff6:	5f                   	pop    %edi
  810ff7:	5d                   	pop    %ebp
  810ff8:	c3                   	ret    

00810ff9 <devcons_read>:
{
  810ff9:	55                   	push   %ebp
  810ffa:	89 e5                	mov    %esp,%ebp
  810ffc:	83 ec 08             	sub    $0x8,%esp
  810fff:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  811004:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  811008:	74 21                	je     81102b <devcons_read+0x32>
	while ((c = sys_cgetc()) == 0)
  81100a:	e8 a3 e3 ff ff       	call   80f3b2 <sys_cgetc>
  81100f:	85 c0                	test   %eax,%eax
  811011:	75 07                	jne    81101a <devcons_read+0x21>
		sys_yield();
  811013:	e8 19 e4 ff ff       	call   80f431 <sys_yield>
  811018:	eb f0                	jmp    81100a <devcons_read+0x11>
	if (c < 0)
  81101a:	78 0f                	js     81102b <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  81101c:	83 f8 04             	cmp    $0x4,%eax
  81101f:	74 0c                	je     81102d <devcons_read+0x34>
	*(char*)vbuf = c;
  811021:	8b 55 0c             	mov    0xc(%ebp),%edx
  811024:	88 02                	mov    %al,(%edx)
	return 1;
  811026:	b8 01 00 00 00       	mov    $0x1,%eax
}
  81102b:	c9                   	leave  
  81102c:	c3                   	ret    
		return 0;
  81102d:	b8 00 00 00 00       	mov    $0x0,%eax
  811032:	eb f7                	jmp    81102b <devcons_read+0x32>

00811034 <cputchar>:
{
  811034:	55                   	push   %ebp
  811035:	89 e5                	mov    %esp,%ebp
  811037:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  81103a:	8b 45 08             	mov    0x8(%ebp),%eax
  81103d:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  811040:	6a 01                	push   $0x1
  811042:	8d 45 f7             	lea    -0x9(%ebp),%eax
  811045:	50                   	push   %eax
  811046:	e8 49 e3 ff ff       	call   80f394 <sys_cputs>
}
  81104b:	83 c4 10             	add    $0x10,%esp
  81104e:	c9                   	leave  
  81104f:	c3                   	ret    

00811050 <getchar>:
{
  811050:	55                   	push   %ebp
  811051:	89 e5                	mov    %esp,%ebp
  811053:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  811056:	6a 01                	push   $0x1
  811058:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81105b:	50                   	push   %eax
  81105c:	6a 00                	push   $0x0
  81105e:	e8 8e ef ff ff       	call   80fff1 <read>
	if (r < 0)
  811063:	83 c4 10             	add    $0x10,%esp
  811066:	85 c0                	test   %eax,%eax
  811068:	78 06                	js     811070 <getchar+0x20>
	if (r < 1)
  81106a:	74 06                	je     811072 <getchar+0x22>
	return c;
  81106c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  811070:	c9                   	leave  
  811071:	c3                   	ret    
		return -E_EOF;
  811072:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  811077:	eb f7                	jmp    811070 <getchar+0x20>

00811079 <iscons>:
{
  811079:	55                   	push   %ebp
  81107a:	89 e5                	mov    %esp,%ebp
  81107c:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  81107f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811082:	50                   	push   %eax
  811083:	ff 75 08             	pushl  0x8(%ebp)
  811086:	e8 f6 ec ff ff       	call   80fd81 <fd_lookup>
  81108b:	83 c4 10             	add    $0x10,%esp
  81108e:	85 c0                	test   %eax,%eax
  811090:	78 11                	js     8110a3 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  811092:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811095:	8b 15 40 53 81 00    	mov    0x815340,%edx
  81109b:	39 10                	cmp    %edx,(%eax)
  81109d:	0f 94 c0             	sete   %al
  8110a0:	0f b6 c0             	movzbl %al,%eax
}
  8110a3:	c9                   	leave  
  8110a4:	c3                   	ret    

008110a5 <opencons>:
{
  8110a5:	55                   	push   %ebp
  8110a6:	89 e5                	mov    %esp,%ebp
  8110a8:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  8110ab:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8110ae:	50                   	push   %eax
  8110af:	e8 7b ec ff ff       	call   80fd2f <fd_alloc>
  8110b4:	83 c4 10             	add    $0x10,%esp
  8110b7:	85 c0                	test   %eax,%eax
  8110b9:	78 3a                	js     8110f5 <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8110bb:	83 ec 04             	sub    $0x4,%esp
  8110be:	68 07 04 00 00       	push   $0x407
  8110c3:	ff 75 f4             	pushl  -0xc(%ebp)
  8110c6:	6a 00                	push   $0x0
  8110c8:	e8 83 e3 ff ff       	call   80f450 <sys_page_alloc>
  8110cd:	83 c4 10             	add    $0x10,%esp
  8110d0:	85 c0                	test   %eax,%eax
  8110d2:	78 21                	js     8110f5 <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  8110d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8110d7:	8b 15 40 53 81 00    	mov    0x815340,%edx
  8110dd:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8110df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8110e2:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8110e9:	83 ec 0c             	sub    $0xc,%esp
  8110ec:	50                   	push   %eax
  8110ed:	e8 16 ec ff ff       	call   80fd08 <fd2num>
  8110f2:	83 c4 10             	add    $0x10,%esp
}
  8110f5:	c9                   	leave  
  8110f6:	c3                   	ret    

008110f7 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8110f7:	55                   	push   %ebp
  8110f8:	89 e5                	mov    %esp,%ebp
  8110fa:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  8110fd:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  811104:	74 0a                	je     811110 <set_pgfault_handler+0x19>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
		// panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  811106:	8b 45 08             	mov    0x8(%ebp),%eax
  811109:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  81110e:	c9                   	leave  
  81110f:	c3                   	ret    
		r = sys_page_alloc((envid_t)0, (void*)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P);
  811110:	83 ec 04             	sub    $0x4,%esp
  811113:	6a 07                	push   $0x7
  811115:	68 00 f0 bf ee       	push   $0xeebff000
  81111a:	6a 00                	push   $0x0
  81111c:	e8 2f e3 ff ff       	call   80f450 <sys_page_alloc>
		if(r < 0)
  811121:	83 c4 10             	add    $0x10,%esp
  811124:	85 c0                	test   %eax,%eax
  811126:	78 2a                	js     811152 <set_pgfault_handler+0x5b>
		r = sys_env_set_pgfault_upcall((envid_t)0, _pgfault_upcall);
  811128:	83 ec 08             	sub    $0x8,%esp
  81112b:	68 66 11 81 00       	push   $0x811166
  811130:	6a 00                	push   $0x0
  811132:	e8 64 e4 ff ff       	call   80f59b <sys_env_set_pgfault_upcall>
		if(r < 0)
  811137:	83 c4 10             	add    $0x10,%esp
  81113a:	85 c0                	test   %eax,%eax
  81113c:	79 c8                	jns    811106 <set_pgfault_handler+0xf>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
  81113e:	83 ec 04             	sub    $0x4,%esp
  811141:	68 5c 41 81 00       	push   $0x81415c
  811146:	6a 25                	push   $0x25
  811148:	68 98 41 81 00       	push   $0x814198
  81114d:	e8 b7 d6 ff ff       	call   80e809 <_panic>
			panic("the sys_page_alloc() return value is wrong!\n");
  811152:	83 ec 04             	sub    $0x4,%esp
  811155:	68 2c 41 81 00       	push   $0x81412c
  81115a:	6a 22                	push   $0x22
  81115c:	68 98 41 81 00       	push   $0x814198
  811161:	e8 a3 d6 ff ff       	call   80e809 <_panic>

00811166 <_pgfault_upcall>:
_pgfault_upcall:
	//movl testxixi, %eax 
	//call *%eax 

	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  811166:	54                   	push   %esp
	movl _pgfault_handler, %eax
  811167:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  81116c:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  81116e:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %ebx 
  811171:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl 0x30(%esp), %eax 
  811175:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax 
  811179:	83 e8 04             	sub    $0x4,%eax
	movl %ebx, (%eax)
  81117c:	89 18                	mov    %ebx,(%eax)
	movl %eax, 0x30(%esp)
  81117e:	89 44 24 30          	mov    %eax,0x30(%esp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp 
  811182:	83 c4 08             	add    $0x8,%esp
	popal
  811185:	61                   	popa   
	
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp
  811186:	83 c4 04             	add    $0x4,%esp
	popfl
  811189:	9d                   	popf   
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  81118a:	5c                   	pop    %esp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
  81118b:	c3                   	ret    

0081118c <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  81118c:	55                   	push   %ebp
  81118d:	89 e5                	mov    %esp,%ebp
  81118f:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811192:	89 d0                	mov    %edx,%eax
  811194:	c1 e8 16             	shr    $0x16,%eax
  811197:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  81119e:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  8111a3:	f6 c1 01             	test   $0x1,%cl
  8111a6:	74 1d                	je     8111c5 <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  8111a8:	c1 ea 0c             	shr    $0xc,%edx
  8111ab:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  8111b2:	f6 c2 01             	test   $0x1,%dl
  8111b5:	74 0e                	je     8111c5 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8111b7:	c1 ea 0c             	shr    $0xc,%edx
  8111ba:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  8111c1:	ef 
  8111c2:	0f b7 c0             	movzwl %ax,%eax
}
  8111c5:	5d                   	pop    %ebp
  8111c6:	c3                   	ret    
  8111c7:	66 90                	xchg   %ax,%ax
  8111c9:	66 90                	xchg   %ax,%ax
  8111cb:	66 90                	xchg   %ax,%ax
  8111cd:	66 90                	xchg   %ax,%ax
  8111cf:	90                   	nop

008111d0 <__udivdi3>:
  8111d0:	55                   	push   %ebp
  8111d1:	57                   	push   %edi
  8111d2:	56                   	push   %esi
  8111d3:	53                   	push   %ebx
  8111d4:	83 ec 1c             	sub    $0x1c,%esp
  8111d7:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  8111db:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  8111df:	8b 74 24 34          	mov    0x34(%esp),%esi
  8111e3:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  8111e7:	85 d2                	test   %edx,%edx
  8111e9:	75 4d                	jne    811238 <__udivdi3+0x68>
  8111eb:	39 f3                	cmp    %esi,%ebx
  8111ed:	76 19                	jbe    811208 <__udivdi3+0x38>
  8111ef:	31 ff                	xor    %edi,%edi
  8111f1:	89 e8                	mov    %ebp,%eax
  8111f3:	89 f2                	mov    %esi,%edx
  8111f5:	f7 f3                	div    %ebx
  8111f7:	89 fa                	mov    %edi,%edx
  8111f9:	83 c4 1c             	add    $0x1c,%esp
  8111fc:	5b                   	pop    %ebx
  8111fd:	5e                   	pop    %esi
  8111fe:	5f                   	pop    %edi
  8111ff:	5d                   	pop    %ebp
  811200:	c3                   	ret    
  811201:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811208:	89 d9                	mov    %ebx,%ecx
  81120a:	85 db                	test   %ebx,%ebx
  81120c:	75 0b                	jne    811219 <__udivdi3+0x49>
  81120e:	b8 01 00 00 00       	mov    $0x1,%eax
  811213:	31 d2                	xor    %edx,%edx
  811215:	f7 f3                	div    %ebx
  811217:	89 c1                	mov    %eax,%ecx
  811219:	31 d2                	xor    %edx,%edx
  81121b:	89 f0                	mov    %esi,%eax
  81121d:	f7 f1                	div    %ecx
  81121f:	89 c6                	mov    %eax,%esi
  811221:	89 e8                	mov    %ebp,%eax
  811223:	89 f7                	mov    %esi,%edi
  811225:	f7 f1                	div    %ecx
  811227:	89 fa                	mov    %edi,%edx
  811229:	83 c4 1c             	add    $0x1c,%esp
  81122c:	5b                   	pop    %ebx
  81122d:	5e                   	pop    %esi
  81122e:	5f                   	pop    %edi
  81122f:	5d                   	pop    %ebp
  811230:	c3                   	ret    
  811231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811238:	39 f2                	cmp    %esi,%edx
  81123a:	77 1c                	ja     811258 <__udivdi3+0x88>
  81123c:	0f bd fa             	bsr    %edx,%edi
  81123f:	83 f7 1f             	xor    $0x1f,%edi
  811242:	75 2c                	jne    811270 <__udivdi3+0xa0>
  811244:	39 f2                	cmp    %esi,%edx
  811246:	72 06                	jb     81124e <__udivdi3+0x7e>
  811248:	31 c0                	xor    %eax,%eax
  81124a:	39 eb                	cmp    %ebp,%ebx
  81124c:	77 a9                	ja     8111f7 <__udivdi3+0x27>
  81124e:	b8 01 00 00 00       	mov    $0x1,%eax
  811253:	eb a2                	jmp    8111f7 <__udivdi3+0x27>
  811255:	8d 76 00             	lea    0x0(%esi),%esi
  811258:	31 ff                	xor    %edi,%edi
  81125a:	31 c0                	xor    %eax,%eax
  81125c:	89 fa                	mov    %edi,%edx
  81125e:	83 c4 1c             	add    $0x1c,%esp
  811261:	5b                   	pop    %ebx
  811262:	5e                   	pop    %esi
  811263:	5f                   	pop    %edi
  811264:	5d                   	pop    %ebp
  811265:	c3                   	ret    
  811266:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81126d:	8d 76 00             	lea    0x0(%esi),%esi
  811270:	89 f9                	mov    %edi,%ecx
  811272:	b8 20 00 00 00       	mov    $0x20,%eax
  811277:	29 f8                	sub    %edi,%eax
  811279:	d3 e2                	shl    %cl,%edx
  81127b:	89 54 24 08          	mov    %edx,0x8(%esp)
  81127f:	89 c1                	mov    %eax,%ecx
  811281:	89 da                	mov    %ebx,%edx
  811283:	d3 ea                	shr    %cl,%edx
  811285:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811289:	09 d1                	or     %edx,%ecx
  81128b:	89 f2                	mov    %esi,%edx
  81128d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811291:	89 f9                	mov    %edi,%ecx
  811293:	d3 e3                	shl    %cl,%ebx
  811295:	89 c1                	mov    %eax,%ecx
  811297:	d3 ea                	shr    %cl,%edx
  811299:	89 f9                	mov    %edi,%ecx
  81129b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81129f:	89 eb                	mov    %ebp,%ebx
  8112a1:	d3 e6                	shl    %cl,%esi
  8112a3:	89 c1                	mov    %eax,%ecx
  8112a5:	d3 eb                	shr    %cl,%ebx
  8112a7:	09 de                	or     %ebx,%esi
  8112a9:	89 f0                	mov    %esi,%eax
  8112ab:	f7 74 24 08          	divl   0x8(%esp)
  8112af:	89 d6                	mov    %edx,%esi
  8112b1:	89 c3                	mov    %eax,%ebx
  8112b3:	f7 64 24 0c          	mull   0xc(%esp)
  8112b7:	39 d6                	cmp    %edx,%esi
  8112b9:	72 15                	jb     8112d0 <__udivdi3+0x100>
  8112bb:	89 f9                	mov    %edi,%ecx
  8112bd:	d3 e5                	shl    %cl,%ebp
  8112bf:	39 c5                	cmp    %eax,%ebp
  8112c1:	73 04                	jae    8112c7 <__udivdi3+0xf7>
  8112c3:	39 d6                	cmp    %edx,%esi
  8112c5:	74 09                	je     8112d0 <__udivdi3+0x100>
  8112c7:	89 d8                	mov    %ebx,%eax
  8112c9:	31 ff                	xor    %edi,%edi
  8112cb:	e9 27 ff ff ff       	jmp    8111f7 <__udivdi3+0x27>
  8112d0:	8d 43 ff             	lea    -0x1(%ebx),%eax
  8112d3:	31 ff                	xor    %edi,%edi
  8112d5:	e9 1d ff ff ff       	jmp    8111f7 <__udivdi3+0x27>
  8112da:	66 90                	xchg   %ax,%ax
  8112dc:	66 90                	xchg   %ax,%ax
  8112de:	66 90                	xchg   %ax,%ax

008112e0 <__umoddi3>:
  8112e0:	55                   	push   %ebp
  8112e1:	57                   	push   %edi
  8112e2:	56                   	push   %esi
  8112e3:	53                   	push   %ebx
  8112e4:	83 ec 1c             	sub    $0x1c,%esp
  8112e7:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  8112eb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  8112ef:	8b 74 24 30          	mov    0x30(%esp),%esi
  8112f3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  8112f7:	89 da                	mov    %ebx,%edx
  8112f9:	85 c0                	test   %eax,%eax
  8112fb:	75 43                	jne    811340 <__umoddi3+0x60>
  8112fd:	39 df                	cmp    %ebx,%edi
  8112ff:	76 17                	jbe    811318 <__umoddi3+0x38>
  811301:	89 f0                	mov    %esi,%eax
  811303:	f7 f7                	div    %edi
  811305:	89 d0                	mov    %edx,%eax
  811307:	31 d2                	xor    %edx,%edx
  811309:	83 c4 1c             	add    $0x1c,%esp
  81130c:	5b                   	pop    %ebx
  81130d:	5e                   	pop    %esi
  81130e:	5f                   	pop    %edi
  81130f:	5d                   	pop    %ebp
  811310:	c3                   	ret    
  811311:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811318:	89 fd                	mov    %edi,%ebp
  81131a:	85 ff                	test   %edi,%edi
  81131c:	75 0b                	jne    811329 <__umoddi3+0x49>
  81131e:	b8 01 00 00 00       	mov    $0x1,%eax
  811323:	31 d2                	xor    %edx,%edx
  811325:	f7 f7                	div    %edi
  811327:	89 c5                	mov    %eax,%ebp
  811329:	89 d8                	mov    %ebx,%eax
  81132b:	31 d2                	xor    %edx,%edx
  81132d:	f7 f5                	div    %ebp
  81132f:	89 f0                	mov    %esi,%eax
  811331:	f7 f5                	div    %ebp
  811333:	89 d0                	mov    %edx,%eax
  811335:	eb d0                	jmp    811307 <__umoddi3+0x27>
  811337:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81133e:	66 90                	xchg   %ax,%ax
  811340:	89 f1                	mov    %esi,%ecx
  811342:	39 d8                	cmp    %ebx,%eax
  811344:	76 0a                	jbe    811350 <__umoddi3+0x70>
  811346:	89 f0                	mov    %esi,%eax
  811348:	83 c4 1c             	add    $0x1c,%esp
  81134b:	5b                   	pop    %ebx
  81134c:	5e                   	pop    %esi
  81134d:	5f                   	pop    %edi
  81134e:	5d                   	pop    %ebp
  81134f:	c3                   	ret    
  811350:	0f bd e8             	bsr    %eax,%ebp
  811353:	83 f5 1f             	xor    $0x1f,%ebp
  811356:	75 20                	jne    811378 <__umoddi3+0x98>
  811358:	39 d8                	cmp    %ebx,%eax
  81135a:	0f 82 b0 00 00 00    	jb     811410 <__umoddi3+0x130>
  811360:	39 f7                	cmp    %esi,%edi
  811362:	0f 86 a8 00 00 00    	jbe    811410 <__umoddi3+0x130>
  811368:	89 c8                	mov    %ecx,%eax
  81136a:	83 c4 1c             	add    $0x1c,%esp
  81136d:	5b                   	pop    %ebx
  81136e:	5e                   	pop    %esi
  81136f:	5f                   	pop    %edi
  811370:	5d                   	pop    %ebp
  811371:	c3                   	ret    
  811372:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811378:	89 e9                	mov    %ebp,%ecx
  81137a:	ba 20 00 00 00       	mov    $0x20,%edx
  81137f:	29 ea                	sub    %ebp,%edx
  811381:	d3 e0                	shl    %cl,%eax
  811383:	89 44 24 08          	mov    %eax,0x8(%esp)
  811387:	89 d1                	mov    %edx,%ecx
  811389:	89 f8                	mov    %edi,%eax
  81138b:	d3 e8                	shr    %cl,%eax
  81138d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811391:	89 54 24 04          	mov    %edx,0x4(%esp)
  811395:	8b 54 24 04          	mov    0x4(%esp),%edx
  811399:	09 c1                	or     %eax,%ecx
  81139b:	89 d8                	mov    %ebx,%eax
  81139d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8113a1:	89 e9                	mov    %ebp,%ecx
  8113a3:	d3 e7                	shl    %cl,%edi
  8113a5:	89 d1                	mov    %edx,%ecx
  8113a7:	d3 e8                	shr    %cl,%eax
  8113a9:	89 e9                	mov    %ebp,%ecx
  8113ab:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8113af:	d3 e3                	shl    %cl,%ebx
  8113b1:	89 c7                	mov    %eax,%edi
  8113b3:	89 d1                	mov    %edx,%ecx
  8113b5:	89 f0                	mov    %esi,%eax
  8113b7:	d3 e8                	shr    %cl,%eax
  8113b9:	89 e9                	mov    %ebp,%ecx
  8113bb:	89 fa                	mov    %edi,%edx
  8113bd:	d3 e6                	shl    %cl,%esi
  8113bf:	09 d8                	or     %ebx,%eax
  8113c1:	f7 74 24 08          	divl   0x8(%esp)
  8113c5:	89 d1                	mov    %edx,%ecx
  8113c7:	89 f3                	mov    %esi,%ebx
  8113c9:	f7 64 24 0c          	mull   0xc(%esp)
  8113cd:	89 c6                	mov    %eax,%esi
  8113cf:	89 d7                	mov    %edx,%edi
  8113d1:	39 d1                	cmp    %edx,%ecx
  8113d3:	72 06                	jb     8113db <__umoddi3+0xfb>
  8113d5:	75 10                	jne    8113e7 <__umoddi3+0x107>
  8113d7:	39 c3                	cmp    %eax,%ebx
  8113d9:	73 0c                	jae    8113e7 <__umoddi3+0x107>
  8113db:	2b 44 24 0c          	sub    0xc(%esp),%eax
  8113df:	1b 54 24 08          	sbb    0x8(%esp),%edx
  8113e3:	89 d7                	mov    %edx,%edi
  8113e5:	89 c6                	mov    %eax,%esi
  8113e7:	89 ca                	mov    %ecx,%edx
  8113e9:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  8113ee:	29 f3                	sub    %esi,%ebx
  8113f0:	19 fa                	sbb    %edi,%edx
  8113f2:	89 d0                	mov    %edx,%eax
  8113f4:	d3 e0                	shl    %cl,%eax
  8113f6:	89 e9                	mov    %ebp,%ecx
  8113f8:	d3 eb                	shr    %cl,%ebx
  8113fa:	d3 ea                	shr    %cl,%edx
  8113fc:	09 d8                	or     %ebx,%eax
  8113fe:	83 c4 1c             	add    $0x1c,%esp
  811401:	5b                   	pop    %ebx
  811402:	5e                   	pop    %esi
  811403:	5f                   	pop    %edi
  811404:	5d                   	pop    %ebp
  811405:	c3                   	ret    
  811406:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81140d:	8d 76 00             	lea    0x0(%esi),%esi
  811410:	89 da                	mov    %ebx,%edx
  811412:	29 fe                	sub    %edi,%esi
  811414:	19 c2                	sbb    %eax,%edx
  811416:	89 f1                	mov    %esi,%ecx
  811418:	89 c8                	mov    %ecx,%eax
  81141a:	e9 4b ff ff ff       	jmp    81136a <__umoddi3+0x8a>
