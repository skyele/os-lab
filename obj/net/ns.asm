
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 5b e5 00 00       	call   80e58c <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>

00800033 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800033:	55                   	push   %ebp
  800034:	89 e5                	mov    %esp,%ebp
  800036:	83 ec 14             	sub    $0x14,%esp
  800039:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  80003c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800042:	50                   	push   %eax
  800043:	e8 c1 a5 00 00       	call   80a609 <thread_wakeup>
}
  800048:	83 c4 10             	add    $0x10,%esp
  80004b:	c9                   	leave  
  80004c:	c3                   	ret    

0080004d <start_timer>:
{
  80004d:	55                   	push   %ebp
  80004e:	89 e5                	mov    %esp,%ebp
  800050:	53                   	push   %ebx
  800051:	83 ec 04             	sub    $0x4,%esp
	t->msec = msec;
  800054:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800057:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800059:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  80005c:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80005f:	50                   	push   %eax
  800060:	68 94 00 80 00       	push   $0x800094
  800065:	51                   	push   %ecx
  800066:	6a 00                	push   $0x0
  800068:	e8 06 a6 00 00       	call   80a673 <thread_create>
	if (r < 0)
  80006d:	83 c4 10             	add    $0x10,%esp
  800070:	85 c0                	test   %eax,%eax
  800072:	78 05                	js     800079 <start_timer+0x2c>
}
  800074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800077:	c9                   	leave  
  800078:	c3                   	ret    
		panic("cannot create timer thread: %s", e2s(r));
  800079:	83 ec 0c             	sub    $0xc,%esp
  80007c:	50                   	push   %eax
  80007d:	e8 27 a9 00 00       	call   80a9a9 <e2s>
  800082:	50                   	push   %eax
  800083:	68 c0 12 81 00       	push   $0x8112c0
  800088:	6a 7a                	push   $0x7a
  80008a:	68 f5 13 81 00       	push   $0x8113f5
  80008f:	e8 05 e6 00 00       	call   80e699 <_panic>

00800094 <net_timer>:
{
  800094:	55                   	push   %ebp
  800095:	89 e5                	mov    %esp,%ebp
  800097:	56                   	push   %esi
  800098:	53                   	push   %ebx
	struct timer_thread *t = (struct timer_thread *) arg;
  800099:	8b 75 08             	mov    0x8(%ebp),%esi
		uint32_t cur = sys_time_msec();
  80009c:	e8 71 f4 00 00       	call   80f512 <sys_time_msec>
  8000a1:	89 c3                	mov    %eax,%ebx
		lwip_core_lock();
  8000a3:	e8 38 a5 00 00       	call   80a5e0 <lwip_core_lock>
		t->func();
  8000a8:	ff 56 04             	call   *0x4(%esi)
		lwip_core_unlock();
  8000ab:	e8 31 a5 00 00       	call   80a5e1 <lwip_core_unlock>
		thread_wait(0, 0, cur + t->msec);
  8000b0:	83 ec 04             	sub    $0x4,%esp
  8000b3:	03 1e                	add    (%esi),%ebx
  8000b5:	53                   	push   %ebx
  8000b6:	6a 00                	push   $0x0
  8000b8:	6a 00                	push   $0x0
  8000ba:	e8 60 a7 00 00       	call   80a81f <thread_wait>
  8000bf:	83 c4 10             	add    $0x10,%esp
  8000c2:	eb d8                	jmp    80009c <net_timer+0x8>

008000c4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000c4:	55                   	push   %ebp
  8000c5:	89 e5                	mov    %esp,%ebp
  8000c7:	57                   	push   %edi
  8000c8:	56                   	push   %esi
  8000c9:	53                   	push   %ebx
  8000ca:	83 ec 7c             	sub    $0x7c,%esp
  8000cd:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  8000d0:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  8000d3:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8000d6:	0f 87 4f 01 00 00    	ja     80022b <serve_thread+0x167>
  8000dc:	8b 03                	mov    (%ebx),%eax
  8000de:	ff 24 85 c4 14 81 00 	jmp    *0x8114c4(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  8000e5:	8b 46 04             	mov    0x4(%esi),%eax
  8000e8:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  8000eb:	83 ec 04             	sub    $0x4,%esp
  8000ee:	8d 45 94             	lea    -0x6c(%ebp),%eax
  8000f1:	50                   	push   %eax
  8000f2:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000f5:	50                   	push   %eax
  8000f6:	ff 36                	pushl  (%esi)
  8000f8:	e8 b3 0d 00 00       	call   800eb0 <lwip_accept>
  8000fd:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  8000ff:	83 c4 0c             	add    $0xc,%esp
  800102:	6a 14                	push   $0x14
  800104:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800107:	50                   	push   %eax
  800108:	56                   	push   %esi
  800109:	e8 6e ef 00 00       	call   80f07c <memmove>
  80010e:	83 c4 10             	add    $0x10,%esp
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800111:	83 ff ff             	cmp    $0xffffffff,%edi
  800114:	0f 84 2f 01 00 00    	je     800249 <serve_thread+0x185>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
		perror(buf);
	}

	if (args->reqno != NSREQ_INPUT)
  80011a:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80011d:	0f 85 48 01 00 00    	jne    80026b <serve_thread+0x1a7>
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
  800123:	8b 53 08             	mov    0x8(%ebx),%edx
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800126:	8d 82 00 50 01 f0    	lea    -0xffeb000(%edx),%eax
  80012c:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80012f:	c6 80 00 50 81 00 00 	movb   $0x0,0x815000(%eax)
	sys_page_unmap(0, (void*) args->req);
  800136:	83 ec 08             	sub    $0x8,%esp
  800139:	52                   	push   %edx
  80013a:	6a 00                	push   $0x0
  80013c:	e8 24 f2 00 00       	call   80f365 <sys_page_unmap>
	free(args);
  800141:	89 1c 24             	mov    %ebx,(%esp)
  800144:	e8 e2 06 01 00       	call   81082b <free>
}
  800149:	83 c4 10             	add    $0x10,%esp
  80014c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80014f:	5b                   	pop    %ebx
  800150:	5e                   	pop    %esi
  800151:	5f                   	pop    %edi
  800152:	5d                   	pop    %ebp
  800153:	c3                   	ret    
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	83 ec 04             	sub    $0x4,%esp
  800157:	ff 76 14             	pushl  0x14(%esi)
  80015a:	8d 46 04             	lea    0x4(%esi),%eax
  80015d:	50                   	push   %eax
  80015e:	ff 36                	pushl  (%esi)
  800160:	e8 fd 0e 00 00       	call   801062 <lwip_bind>
  800165:	89 c7                	mov    %eax,%edi
		break;
  800167:	83 c4 10             	add    $0x10,%esp
  80016a:	eb a5                	jmp    800111 <serve_thread+0x4d>
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  80016c:	83 ec 08             	sub    $0x8,%esp
  80016f:	ff 76 04             	pushl  0x4(%esi)
  800172:	ff 36                	pushl  (%esi)
  800174:	e8 44 1a 00 00       	call   801bbd <lwip_shutdown>
  800179:	89 c7                	mov    %eax,%edi
		break;
  80017b:	83 c4 10             	add    $0x10,%esp
  80017e:	eb 91                	jmp    800111 <serve_thread+0x4d>
		r = lwip_close(req->close.req_s);
  800180:	83 ec 0c             	sub    $0xc,%esp
  800183:	ff 36                	pushl  (%esi)
  800185:	e8 8e 0f 00 00       	call   801118 <lwip_close>
  80018a:	89 c7                	mov    %eax,%edi
		break;
  80018c:	83 c4 10             	add    $0x10,%esp
  80018f:	eb 80                	jmp    800111 <serve_thread+0x4d>
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800191:	83 ec 04             	sub    $0x4,%esp
  800194:	ff 76 14             	pushl  0x14(%esi)
  800197:	8d 46 04             	lea    0x4(%esi),%eax
  80019a:	50                   	push   %eax
  80019b:	ff 36                	pushl  (%esi)
  80019d:	e8 ff 0f 00 00       	call   8011a1 <lwip_connect>
  8001a2:	89 c7                	mov    %eax,%edi
		break;
  8001a4:	83 c4 10             	add    $0x10,%esp
  8001a7:	e9 65 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001ac:	83 ec 08             	sub    $0x8,%esp
  8001af:	ff 76 04             	pushl  0x4(%esi)
  8001b2:	ff 36                	pushl  (%esi)
  8001b4:	e8 9e 10 00 00       	call   801257 <lwip_listen>
  8001b9:	89 c7                	mov    %eax,%edi
		break;
  8001bb:	83 c4 10             	add    $0x10,%esp
  8001be:	e9 4e ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001c3:	ff 76 08             	pushl  0x8(%esi)
  8001c6:	ff 76 04             	pushl  0x4(%esi)
  8001c9:	56                   	push   %esi
  8001ca:	ff 36                	pushl  (%esi)
  8001cc:	e8 71 13 00 00       	call   801542 <lwip_recv>
  8001d1:	89 c7                	mov    %eax,%edi
		break;
  8001d3:	83 c4 10             	add    $0x10,%esp
  8001d6:	e9 36 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001db:	ff 76 08             	pushl  0x8(%esi)
  8001de:	ff 76 04             	pushl  0x4(%esi)
  8001e1:	8d 46 0c             	lea    0xc(%esi),%eax
  8001e4:	50                   	push   %eax
  8001e5:	ff 36                	pushl  (%esi)
  8001e7:	e8 e8 14 00 00       	call   8016d4 <lwip_send>
  8001ec:	89 c7                	mov    %eax,%edi
		break;
  8001ee:	83 c4 10             	add    $0x10,%esp
  8001f1:	e9 1b ff ff ff       	jmp    800111 <serve_thread+0x4d>
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8001f6:	83 ec 04             	sub    $0x4,%esp
  8001f9:	ff 76 08             	pushl  0x8(%esi)
  8001fc:	ff 76 04             	pushl  0x4(%esi)
  8001ff:	ff 36                	pushl  (%esi)
  800201:	e8 5f 15 00 00       	call   801765 <lwip_socket>
  800206:	89 c7                	mov    %eax,%edi
		break;
  800208:	83 c4 10             	add    $0x10,%esp
  80020b:	e9 01 ff ff ff       	jmp    800111 <serve_thread+0x4d>
		jif_input(&nif, (void *)&req->pkt);
  800210:	83 ec 08             	sub    $0x8,%esp
  800213:	56                   	push   %esi
  800214:	68 00 b2 b3 00       	push   $0xb3b200
  800219:	e8 7a a8 00 00       	call   80aa98 <jif_input>
  80021e:	83 c4 10             	add    $0x10,%esp
		r = 0;
  800221:	bf 00 00 00 00       	mov    $0x0,%edi
  800226:	e9 ef fe ff ff       	jmp    80011a <serve_thread+0x56>
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80022b:	83 ec 04             	sub    $0x4,%esp
  80022e:	56                   	push   %esi
  80022f:	ff 73 04             	pushl  0x4(%ebx)
  800232:	68 e0 12 81 00       	push   $0x8112e0
  800237:	e8 53 e5 00 00       	call   80e78f <cprintf>
  80023c:	83 c4 10             	add    $0x10,%esp
		r = -E_INVAL;
  80023f:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800244:	e9 d1 fe ff ff       	jmp    80011a <serve_thread+0x56>
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800249:	ff 33                	pushl  (%ebx)
  80024b:	68 00 14 81 00       	push   $0x811400
  800250:	6a 64                	push   $0x64
  800252:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800255:	56                   	push   %esi
  800256:	e8 40 ec 00 00       	call   80ee9b <snprintf>
		perror(buf);
  80025b:	89 34 24             	mov    %esi,(%esp)
  80025e:	e8 22 a7 00 00       	call   80a985 <perror>
  800263:	83 c4 10             	add    $0x10,%esp
  800266:	e9 af fe ff ff       	jmp    80011a <serve_thread+0x56>
		ipc_send(args->whom, r, 0, 0);
  80026b:	6a 00                	push   $0x0
  80026d:	6a 00                	push   $0x0
  80026f:	57                   	push   %edi
  800270:	ff 73 04             	pushl  0x4(%ebx)
  800273:	e8 8d f8 00 00       	call   80fb05 <ipc_send>
  800278:	83 c4 10             	add    $0x10,%esp
  80027b:	e9 a3 fe ff ff       	jmp    800123 <serve_thread+0x5f>

00800280 <serve_init>:
{
  800280:	55                   	push   %ebp
  800281:	89 e5                	mov    %esp,%ebp
  800283:	56                   	push   %esi
  800284:	53                   	push   %ebx
  800285:	83 ec 10             	sub    $0x10,%esp
  800288:	8b 75 08             	mov    0x8(%ebp),%esi
	lwip_core_lock();
  80028b:	e8 50 a3 00 00       	call   80a5e0 <lwip_core_lock>
	uint32_t done = 0;
  800290:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800297:	83 ec 08             	sub    $0x8,%esp
  80029a:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80029d:	53                   	push   %ebx
  80029e:	68 33 00 80 00       	push   $0x800033
  8002a3:	e8 a8 21 00 00       	call   802450 <tcpip_init>
	lwip_core_unlock();
  8002a8:	e8 34 a3 00 00       	call   80a5e1 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8002ad:	83 c4 0c             	add    $0xc,%esp
  8002b0:	6a ff                	push   $0xffffffff
  8002b2:	6a 00                	push   $0x0
  8002b4:	53                   	push   %ebx
  8002b5:	e8 65 a5 00 00       	call   80a81f <thread_wait>
	lwip_core_lock();
  8002ba:	e8 21 a3 00 00       	call   80a5e0 <lwip_core_lock>
	ipaddr.addr  = init_addr;
  8002bf:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  8002c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8002c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8002c8:	8b 45 10             	mov    0x10(%ebp),%eax
  8002cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8002ce:	83 c4 0c             	add    $0xc,%esp
  8002d1:	68 a1 65 80 00       	push   $0x8065a1
  8002d6:	68 83 ab 80 00       	push   $0x80ab83
  8002db:	68 14 50 81 00       	push   $0x815014
  8002e0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8002e3:	50                   	push   %eax
  8002e4:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8002e7:	50                   	push   %eax
  8002e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8002eb:	50                   	push   %eax
  8002ec:	68 00 b2 b3 00       	push   $0xb3b200
  8002f1:	e8 b0 43 00 00       	call   8046a6 <netif_add>
  8002f6:	83 c4 20             	add    $0x20,%esp
  8002f9:	85 c0                	test   %eax,%eax
  8002fb:	0f 84 cc 00 00 00    	je     8003cd <serve_init+0x14d>
	netif_set_default(nif);
  800301:	83 ec 0c             	sub    $0xc,%esp
  800304:	68 00 b2 b3 00       	push   $0xb3b200
  800309:	e8 4a 44 00 00       	call   804758 <netif_set_default>
	netif_set_up(nif);
  80030e:	c7 04 24 00 b2 b3 00 	movl   $0xb3b200,(%esp)
  800315:	e8 4b 44 00 00       	call   804765 <netif_set_up>
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80031a:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800321:	b9 0f 14 81 00       	mov    $0x81140f,%ecx
  800326:	ba 63 95 80 00       	mov    $0x809563,%edx
  80032b:	b8 34 50 81 00       	mov    $0x815034,%eax
  800330:	e8 18 fd ff ff       	call   80004d <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800335:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80033c:	b9 19 14 81 00       	mov    $0x811419,%ecx
  800341:	ba 2d 57 80 00       	mov    $0x80572d,%edx
  800346:	b8 28 50 81 00       	mov    $0x815028,%eax
  80034b:	e8 fd fc ff ff       	call   80004d <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800350:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800357:	b9 25 14 81 00       	mov    $0x811425,%ecx
  80035c:	ba e6 5c 80 00       	mov    $0x805ce6,%edx
  800361:	b8 1c 50 81 00       	mov    $0x81501c,%eax
  800366:	e8 e2 fc ff ff       	call   80004d <start_timer>
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80036b:	89 34 24             	mov    %esi,(%esp)
  80036e:	e8 51 73 00 00       	call   8076c4 <inet_ntoa>
  800373:	50                   	push   %eax
  800374:	0f b6 05 2a b2 b3 00 	movzbl 0xb3b22a,%eax
  80037b:	50                   	push   %eax
  80037c:	0f b6 05 29 b2 b3 00 	movzbl 0xb3b229,%eax
  800383:	50                   	push   %eax
  800384:	0f b6 05 28 b2 b3 00 	movzbl 0xb3b228,%eax
  80038b:	50                   	push   %eax
  80038c:	0f b6 05 27 b2 b3 00 	movzbl 0xb3b227,%eax
  800393:	50                   	push   %eax
  800394:	0f b6 05 26 b2 b3 00 	movzbl 0xb3b226,%eax
  80039b:	50                   	push   %eax
  80039c:	0f b6 05 25 b2 b3 00 	movzbl 0xb3b225,%eax
  8003a3:	50                   	push   %eax
  8003a4:	68 24 13 81 00       	push   $0x811324
  8003a9:	e8 e1 e3 00 00       	call   80e78f <cprintf>
	lwip_core_unlock();
  8003ae:	83 c4 30             	add    $0x30,%esp
  8003b1:	e8 2b a2 00 00       	call   80a5e1 <lwip_core_unlock>
	cprintf("NS: TCP/IP initialized.\n");
  8003b6:	83 ec 0c             	sub    $0xc,%esp
  8003b9:	68 31 14 81 00       	push   $0x811431
  8003be:	e8 cc e3 00 00       	call   80e78f <cprintf>
}
  8003c3:	83 c4 10             	add    $0x10,%esp
  8003c6:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8003c9:	5b                   	pop    %ebx
  8003ca:	5e                   	pop    %esi
  8003cb:	5d                   	pop    %ebp
  8003cc:	c3                   	ret    
		panic("lwip_init: error in netif_add\n");
  8003cd:	83 ec 04             	sub    $0x4,%esp
  8003d0:	68 04 13 81 00       	push   $0x811304
  8003d5:	6a 5c                	push   $0x5c
  8003d7:	68 f5 13 81 00       	push   $0x8113f5
  8003dc:	e8 b8 e2 00 00       	call   80e699 <_panic>

008003e1 <serve>:

void
serve(void) {
  8003e1:	55                   	push   %ebp
  8003e2:	89 e5                	mov    %esp,%ebp
  8003e4:	57                   	push   %edi
  8003e5:	56                   	push   %esi
  8003e6:	53                   	push   %ebx
  8003e7:	83 ec 2c             	sub    $0x2c,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8003ea:	8d 7d e0             	lea    -0x20(%ebp),%edi
  8003ed:	e9 9d 00 00 00       	jmp    80048f <serve+0xae>
		perm = 0;
  8003f2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	for (i = 0; i < QUEUE_SIZE; i++)
  8003f9:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8003fe:	80 b8 00 50 81 00 00 	cmpb   $0x0,0x815000(%eax)
  800405:	74 1c                	je     800423 <serve+0x42>
	for (i = 0; i < QUEUE_SIZE; i++)
  800407:	83 c0 01             	add    $0x1,%eax
  80040a:	83 f8 14             	cmp    $0x14,%eax
  80040d:	75 ef                	jne    8003fe <serve+0x1d>
		panic("NS: buffer overflow");
  80040f:	83 ec 04             	sub    $0x4,%esp
  800412:	68 4a 14 81 00       	push   $0x81144a
  800417:	6a 3f                	push   $0x3f
  800419:	68 f5 13 81 00       	push   $0x8113f5
  80041e:	e8 76 e2 00 00       	call   80e699 <_panic>
	va = (void *)(REQVA + i * PGSIZE);
  800423:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  800429:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  80042c:	c6 80 00 50 81 00 01 	movb   $0x1,0x815000(%eax)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800433:	83 ec 04             	sub    $0x4,%esp
  800436:	57                   	push   %edi
  800437:	53                   	push   %ebx
  800438:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80043b:	50                   	push   %eax
  80043c:	e8 5b f6 00 00       	call   80fa9c <ipc_recv>
  800441:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800443:	83 c4 10             	add    $0x10,%esp
  800446:	83 f8 0c             	cmp    $0xc,%eax
  800449:	74 69                	je     8004b4 <serve+0xd3>
			put_buffer(va);
			continue;
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80044b:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80044f:	0f 84 ba 00 00 00    	je     80050f <serve+0x12e>
			continue; // just leave it hanging...
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  800455:	83 ec 0c             	sub    $0xc,%esp
  800458:	6a 0c                	push   $0xc
  80045a:	e8 78 04 01 00       	call   8108d7 <malloc>
		if (!args)
  80045f:	83 c4 10             	add    $0x10,%esp
  800462:	85 c0                	test   %eax,%eax
  800464:	0f 84 bd 00 00 00    	je     800527 <serve+0x146>
			panic("could not allocate thread args structure");

		args->reqno = reqno;
  80046a:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  80046c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80046f:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  800472:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  800475:	50                   	push   %eax
  800476:	68 c4 00 80 00       	push   $0x8000c4
  80047b:	68 5e 14 81 00       	push   $0x81145e
  800480:	6a 00                	push   $0x0
  800482:	e8 ec a1 00 00       	call   80a673 <thread_create>
		thread_yield(); // let the thread created run
  800487:	e8 10 a3 00 00       	call   80a79c <thread_yield>
  80048c:	83 c4 10             	add    $0x10,%esp
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80048f:	bb 00 00 00 00       	mov    $0x0,%ebx
  800494:	e8 91 a1 00 00       	call   80a62a <thread_wakeups_pending>
  800499:	85 c0                	test   %eax,%eax
  80049b:	0f 84 51 ff ff ff    	je     8003f2 <serve+0x11>
  8004a1:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a4:	0f 8f 48 ff ff ff    	jg     8003f2 <serve+0x11>
			thread_yield();
  8004aa:	e8 ed a2 00 00       	call   80a79c <thread_yield>
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004af:	83 c3 01             	add    $0x1,%ebx
  8004b2:	eb e0                	jmp    800494 <serve+0xb3>
			process_timer(whom);
  8004b4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
	if (envid != timer_envid) {
  8004b7:	3b 35 18 50 81 00    	cmp    0x815018,%esi
  8004bd:	74 23                	je     8004e2 <serve+0x101>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  8004bf:	83 ec 08             	sub    $0x8,%esp
  8004c2:	56                   	push   %esi
  8004c3:	68 60 13 81 00       	push   $0x811360
  8004c8:	e8 c2 e2 00 00       	call   80e78f <cprintf>
  8004cd:	83 c4 10             	add    $0x10,%esp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8004d0:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  8004d6:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  8004d9:	c6 83 00 50 81 00 00 	movb   $0x0,0x815000(%ebx)
  8004e0:	eb ad                	jmp    80048f <serve+0xae>
	start = sys_time_msec();
  8004e2:	e8 2b f0 00 00       	call   80f512 <sys_time_msec>
  8004e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  8004ea:	e8 ad a2 00 00       	call   80a79c <thread_yield>
	now = sys_time_msec();
  8004ef:	e8 1e f0 00 00       	call   80f512 <sys_time_msec>
	ipc_send(envid, to, 0, 0);
  8004f4:	6a 00                	push   $0x0
  8004f6:	6a 00                	push   $0x0
	to = TIMER_INTERVAL - (now - start);
  8004f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8004fb:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800501:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  800503:	52                   	push   %edx
  800504:	56                   	push   %esi
  800505:	e8 fb f5 00 00       	call   80fb05 <ipc_send>
  80050a:	83 c4 10             	add    $0x10,%esp
  80050d:	eb c1                	jmp    8004d0 <serve+0xef>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80050f:	83 ec 08             	sub    $0x8,%esp
  800512:	ff 75 e4             	pushl  -0x1c(%ebp)
  800515:	68 9c 13 81 00       	push   $0x81139c
  80051a:	e8 70 e2 00 00       	call   80e78f <cprintf>
			continue; // just leave it hanging...
  80051f:	83 c4 10             	add    $0x10,%esp
  800522:	e9 68 ff ff ff       	jmp    80048f <serve+0xae>
			panic("could not allocate thread args structure");
  800527:	83 ec 04             	sub    $0x4,%esp
  80052a:	68 cc 13 81 00       	push   $0x8113cc
  80052f:	68 27 01 00 00       	push   $0x127
  800534:	68 f5 13 81 00       	push   $0x8113f5
  800539:	e8 5b e1 00 00       	call   80e699 <_panic>

0080053e <tmain>:
	}
}

static void
tmain(uint32_t arg) {
  80053e:	55                   	push   %ebp
  80053f:	89 e5                	mov    %esp,%ebp
  800541:	56                   	push   %esi
  800542:	53                   	push   %ebx
	serve_init(inet_addr(IP),
  800543:	83 ec 0c             	sub    $0xc,%esp
  800546:	68 6b 14 81 00       	push   $0x81146b
  80054b:	e8 23 74 00 00       	call   807973 <inet_addr>
  800550:	89 c6                	mov    %eax,%esi
  800552:	c7 04 24 74 14 81 00 	movl   $0x811474,(%esp)
  800559:	e8 15 74 00 00       	call   807973 <inet_addr>
  80055e:	89 c3                	mov    %eax,%ebx
  800560:	c7 04 24 82 14 81 00 	movl   $0x811482,(%esp)
  800567:	e8 07 74 00 00       	call   807973 <inet_addr>
  80056c:	83 c4 0c             	add    $0xc,%esp
  80056f:	56                   	push   %esi
  800570:	53                   	push   %ebx
  800571:	50                   	push   %eax
  800572:	e8 09 fd ff ff       	call   800280 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800577:	e8 65 fe ff ff       	call   8003e1 <serve>

0080057c <umain>:
}

void
umain(int argc, char **argv)
{
  80057c:	55                   	push   %ebp
  80057d:	89 e5                	mov    %esp,%ebp
  80057f:	53                   	push   %ebx
  800580:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in umain serv.c\n", thisenv->env_id);
  800583:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  800588:	8b 40 48             	mov    0x48(%eax),%eax
  80058b:	50                   	push   %eax
  80058c:	68 8c 14 81 00       	push   $0x81148c
  800591:	e8 f9 e1 00 00       	call   80e78f <cprintf>
	envid_t ns_envid = sys_getenvid();
  800596:	e8 07 ed 00 00       	call   80f2a2 <sys_getenvid>
  80059b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80059d:	c7 05 e8 42 81 00 47 	movl   $0x813f47,0x8142e8
  8005a4:	3f 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  8005a7:	e8 5e f2 00 00       	call   80f80a <fork>
  8005ac:	a3 18 50 81 00       	mov    %eax,0x815018
	if (timer_envid < 0)
  8005b1:	83 c4 10             	add    $0x10,%esp
  8005b4:	85 c0                	test   %eax,%eax
  8005b6:	78 43                	js     8005fb <umain+0x7f>
		panic("error forking");
	else if (timer_envid == 0) {
  8005b8:	74 58                	je     800612 <umain+0x96>
		return;
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8005ba:	e8 4b f2 00 00       	call   80f80a <fork>
	if (input_envid < 0)
  8005bf:	85 c0                	test   %eax,%eax
  8005c1:	78 65                	js     800628 <umain+0xac>
		panic("error forking");
	else if (input_envid == 0) {
  8005c3:	74 7a                	je     80063f <umain+0xc3>
		return;
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8005c5:	e8 40 f2 00 00       	call   80f80a <fork>
  8005ca:	a3 14 50 81 00       	mov    %eax,0x815014
	if (output_envid < 0)
  8005cf:	85 c0                	test   %eax,%eax
  8005d1:	78 7a                	js     80064d <umain+0xd1>
		panic("error forking");
	else if (output_envid == 0) {
  8005d3:	0f 84 8b 00 00 00    	je     800664 <umain+0xe8>
		return;
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  8005d9:	e8 04 a0 00 00       	call   80a5e2 <thread_init>
	thread_create(0, "main", tmain, 0);
  8005de:	6a 00                	push   $0x0
  8005e0:	68 3e 05 80 00       	push   $0x80053e
  8005e5:	68 bf 14 81 00       	push   $0x8114bf
  8005ea:	6a 00                	push   $0x0
  8005ec:	e8 82 a0 00 00       	call   80a673 <thread_create>
	thread_yield();
  8005f1:	e8 a6 a1 00 00       	call   80a79c <thread_yield>
  8005f6:	83 c4 10             	add    $0x10,%esp
  8005f9:	eb 28                	jmp    800623 <umain+0xa7>
		panic("error forking");
  8005fb:	83 ec 04             	sub    $0x4,%esp
  8005fe:	68 a1 14 81 00       	push   $0x8114a1
  800603:	68 45 01 00 00       	push   $0x145
  800608:	68 f5 13 81 00       	push   $0x8113f5
  80060d:	e8 87 e0 00 00       	call   80e699 <_panic>
		timer(ns_envid, TIMER_INTERVAL);
  800612:	83 ec 08             	sub    $0x8,%esp
  800615:	68 fa 00 00 00       	push   $0xfa
  80061a:	53                   	push   %ebx
  80061b:	e8 67 00 00 00       	call   800687 <timer>
		return;
  800620:	83 c4 10             	add    $0x10,%esp
	// never coming here!
}
  800623:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800626:	c9                   	leave  
  800627:	c3                   	ret    
		panic("error forking");
  800628:	83 ec 04             	sub    $0x4,%esp
  80062b:	68 a1 14 81 00       	push   $0x8114a1
  800630:	68 4f 01 00 00       	push   $0x14f
  800635:	68 f5 13 81 00       	push   $0x8113f5
  80063a:	e8 5a e0 00 00       	call   80e699 <_panic>
		input(ns_envid);
  80063f:	83 ec 0c             	sub    $0xc,%esp
  800642:	53                   	push   %ebx
  800643:	e8 d2 00 00 00       	call   80071a <input>
		return;
  800648:	83 c4 10             	add    $0x10,%esp
  80064b:	eb d6                	jmp    800623 <umain+0xa7>
		panic("error forking");
  80064d:	83 ec 04             	sub    $0x4,%esp
  800650:	68 a1 14 81 00       	push   $0x8114a1
  800655:	68 59 01 00 00       	push   $0x159
  80065a:	68 f5 13 81 00       	push   $0x8113f5
  80065f:	e8 35 e0 00 00       	call   80e699 <_panic>
		cprintf("%d: after fork\n", thisenv->env_id);
  800664:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  800669:	8b 40 48             	mov    0x48(%eax),%eax
  80066c:	83 ec 08             	sub    $0x8,%esp
  80066f:	50                   	push   %eax
  800670:	68 af 14 81 00       	push   $0x8114af
  800675:	e8 15 e1 00 00       	call   80e78f <cprintf>
		output(ns_envid);
  80067a:	89 1c 24             	mov    %ebx,(%esp)
  80067d:	e8 a3 00 00 00       	call   800725 <output>
		return;
  800682:	83 c4 10             	add    $0x10,%esp
  800685:	eb 9c                	jmp    800623 <umain+0xa7>

00800687 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800687:	55                   	push   %ebp
  800688:	89 e5                	mov    %esp,%ebp
  80068a:	57                   	push   %edi
  80068b:	56                   	push   %esi
  80068c:	53                   	push   %ebx
  80068d:	83 ec 1c             	sub    $0x1c,%esp
  800690:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800693:	e8 7a ee 00 00       	call   80f512 <sys_time_msec>
  800698:	03 45 0c             	add    0xc(%ebp),%eax
  80069b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns_timer";
  80069d:	c7 05 e8 42 81 00 f0 	movl   $0x8114f0,0x8142e8
  8006a4:	14 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006a7:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8006aa:	eb 33                	jmp    8006df <timer+0x58>
		if (r < 0)
  8006ac:	85 c0                	test   %eax,%eax
  8006ae:	78 45                	js     8006f5 <timer+0x6e>
		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8006b0:	6a 00                	push   $0x0
  8006b2:	6a 00                	push   $0x0
  8006b4:	6a 0c                	push   $0xc
  8006b6:	56                   	push   %esi
  8006b7:	e8 49 f4 00 00       	call   80fb05 <ipc_send>
  8006bc:	83 c4 10             	add    $0x10,%esp
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8006bf:	83 ec 04             	sub    $0x4,%esp
  8006c2:	6a 00                	push   $0x0
  8006c4:	6a 00                	push   $0x0
  8006c6:	57                   	push   %edi
  8006c7:	e8 d0 f3 00 00       	call   80fa9c <ipc_recv>
  8006cc:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8006ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8006d1:	83 c4 10             	add    $0x10,%esp
  8006d4:	39 f0                	cmp    %esi,%eax
  8006d6:	75 2f                	jne    800707 <timer+0x80>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  8006d8:	e8 35 ee 00 00       	call   80f512 <sys_time_msec>
  8006dd:	01 c3                	add    %eax,%ebx
		while((r = sys_time_msec()) < stop && r >= 0) {
  8006df:	e8 2e ee 00 00       	call   80f512 <sys_time_msec>
  8006e4:	89 c2                	mov    %eax,%edx
  8006e6:	85 c0                	test   %eax,%eax
  8006e8:	78 c2                	js     8006ac <timer+0x25>
  8006ea:	39 d8                	cmp    %ebx,%eax
  8006ec:	73 be                	jae    8006ac <timer+0x25>
			sys_yield();
  8006ee:	e8 ce eb 00 00       	call   80f2c1 <sys_yield>
  8006f3:	eb ea                	jmp    8006df <timer+0x58>
			panic("sys_time_msec: %e", r);
  8006f5:	52                   	push   %edx
  8006f6:	68 f9 14 81 00       	push   $0x8114f9
  8006fb:	6a 0f                	push   $0xf
  8006fd:	68 0b 15 81 00       	push   $0x81150b
  800702:	e8 92 df 00 00       	call   80e699 <_panic>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800707:	83 ec 08             	sub    $0x8,%esp
  80070a:	50                   	push   %eax
  80070b:	68 18 15 81 00       	push   $0x811518
  800710:	e8 7a e0 00 00       	call   80e78f <cprintf>
				continue;
  800715:	83 c4 10             	add    $0x10,%esp
  800718:	eb a5                	jmp    8006bf <timer+0x38>

0080071a <input>:
extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
	binaryname = "ns_input";
  80071a:	c7 05 e8 42 81 00 53 	movl   $0x811553,0x8142e8
  800721:	15 81 00 
	//	- send it to the network server (using ipc_send with NSREQ_INPUT as value)
	//	do the above things in a loop
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  800724:	c3                   	ret    

00800725 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800725:	55                   	push   %ebp
  800726:	89 e5                	mov    %esp,%ebp
  800728:	56                   	push   %esi
  800729:	53                   	push   %ebx
  80072a:	83 ec 18             	sub    $0x18,%esp
	cprintf("in %s\n", __FUNCTION__);
  80072d:	68 98 15 81 00       	push   $0x811598
  800732:	68 e6 38 81 00       	push   $0x8138e6
  800737:	e8 53 e0 00 00       	call   80e78f <cprintf>
	binaryname = "ns_output";
  80073c:	c7 05 e8 42 81 00 5c 	movl   $0x81155c,0x8142e8
  800743:	15 81 00 
  800746:	83 c4 10             	add    $0x10,%esp
	envid_t from_env_store;
	int perm_store; 

	int r;
	while(1){
		r = ipc_recv(&from_env_store, &nsipcbuf, &perm_store);
  800749:	8d 75 f0             	lea    -0x10(%ebp),%esi
  80074c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80074f:	83 ec 04             	sub    $0x4,%esp
  800752:	56                   	push   %esi
  800753:	68 00 d0 b3 00       	push   $0xb3d000
  800758:	53                   	push   %ebx
  800759:	e8 3e f3 00 00       	call   80fa9c <ipc_recv>
		if(r < 0)
  80075e:	83 c4 10             	add    $0x10,%esp
  800761:	85 c0                	test   %eax,%eax
  800763:	78 33                	js     800798 <output+0x73>
			panic("ipc_recv panic\n");
		while((r = sys_net_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len)) < 0){
  800765:	83 ec 08             	sub    $0x8,%esp
  800768:	ff 35 00 d0 b3 00    	pushl  0xb3d000
  80076e:	68 04 d0 b3 00       	push   $0xb3d004
  800773:	e8 b9 ed 00 00       	call   80f531 <sys_net_send>
  800778:	83 c4 10             	add    $0x10,%esp
  80077b:	85 c0                	test   %eax,%eax
  80077d:	79 d0                	jns    80074f <output+0x2a>
			if(r != -E_TX_FULL)
  80077f:	83 f8 ef             	cmp    $0xffffffef,%eax
  800782:	74 e1                	je     800765 <output+0x40>
				panic("sys_net_send panic\n");
  800784:	83 ec 04             	sub    $0x4,%esp
  800787:	68 83 15 81 00       	push   $0x811583
  80078c:	6a 19                	push   $0x19
  80078e:	68 76 15 81 00       	push   $0x811576
  800793:	e8 01 df 00 00       	call   80e699 <_panic>
			panic("ipc_recv panic\n");
  800798:	83 ec 04             	sub    $0x4,%esp
  80079b:	68 66 15 81 00       	push   $0x811566
  8007a0:	6a 16                	push   $0x16
  8007a2:	68 76 15 81 00       	push   $0x811576
  8007a7:	e8 ed de 00 00       	call   80e699 <_panic>

008007ac <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8007ac:	89 c2                	mov    %eax,%edx
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8007ae:	83 f8 1f             	cmp    $0x1f,%eax
  8007b1:	77 19                	ja     8007cc <get_socket+0x20>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  8007b3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8007b6:	8d 04 85 60 50 81 00 	lea    0x815060(,%eax,4),%eax

  if (!sock->conn) {
  8007bd:	8d 14 92             	lea    (%edx,%edx,4),%edx
  8007c0:	8b 14 95 60 50 81 00 	mov    0x815060(,%edx,4),%edx
  8007c7:	85 d2                	test   %edx,%edx
  8007c9:	74 11                	je     8007dc <get_socket+0x30>
    set_errno(EBADF);
    return NULL;
  }

  return sock;
}
  8007cb:	c3                   	ret    
    set_errno(EBADF);
  8007cc:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  8007d3:	00 00 00 
    return NULL;
  8007d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8007db:	c3                   	ret    
    set_errno(EBADF);
  8007dc:	c7 05 e0 b1 b3 00 09 	movl   $0x9,0xb3b1e0
  8007e3:	00 00 00 
    return NULL;
  8007e6:	89 d0                	mov    %edx,%eax
  8007e8:	eb e1                	jmp    8007cb <get_socket+0x1f>

008007ea <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8007ea:	55                   	push   %ebp
  8007eb:	89 e5                	mov    %esp,%ebp
  8007ed:	57                   	push   %edi
  8007ee:	56                   	push   %esi
  8007ef:	53                   	push   %ebx
  8007f0:	83 ec 40             	sub    $0x40,%esp
  8007f3:	89 45 d0             	mov    %eax,-0x30(%ebp)
  8007f6:	89 55 cc             	mov    %edx,-0x34(%ebp)
  8007f9:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  8007fc:	6a 04                	push   $0x4
  8007fe:	6a 00                	push   $0x0
  800800:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800803:	50                   	push   %eax
  800804:	e8 2b e8 00 00       	call   80f034 <memset>
  FD_ZERO(&lwriteset);
  800809:	83 c4 0c             	add    $0xc,%esp
  80080c:	6a 04                	push   $0x4
  80080e:	6a 00                	push   $0x0
  800810:	8d 45 e0             	lea    -0x20(%ebp),%eax
  800813:	50                   	push   %eax
  800814:	e8 1b e8 00 00       	call   80f034 <memset>
  FD_ZERO(&lexceptset);
  800819:	83 c4 0c             	add    $0xc,%esp
  80081c:	6a 04                	push   $0x4
  80081e:	6a 00                	push   $0x0
  800820:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800823:	50                   	push   %eax
  800824:	e8 0b e8 00 00       	call   80f034 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800829:	83 c4 10             	add    $0x10,%esp
  int i, nready = 0;
  80082c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  for(i = 0; i < maxfdp1; i++) {
  800833:	bf 00 00 00 00       	mov    $0x0,%edi
  800838:	eb 33                	jmp    80086d <lwip_selscan+0x83>
    if (FD_ISSET(i, readset)) {
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  80083a:	89 f8                	mov    %edi,%eax
  80083c:	e8 6b ff ff ff       	call   8007ac <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800841:	85 c0                	test   %eax,%eax
  800843:	74 4c                	je     800891 <lwip_selscan+0xa7>
  800845:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800849:	74 16                	je     800861 <lwip_selscan+0x77>
        FD_SET(i, &lreadset);
  80084b:	b8 01 00 00 00       	mov    $0x1,%eax
  800850:	89 f1                	mov    %esi,%ecx
  800852:	d3 e0                	shl    %cl,%eax
  800854:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800857:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  80085b:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  80085f:	eb 30                	jmp    800891 <lwip_selscan+0xa7>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800861:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800866:	74 29                	je     800891 <lwip_selscan+0xa7>
  800868:	eb e1                	jmp    80084b <lwip_selscan+0x61>
  for(i = 0; i < maxfdp1; i++) {
  80086a:	83 c7 01             	add    $0x1,%edi
  80086d:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800870:	7d 53                	jge    8008c5 <lwip_selscan+0xdb>
    if (FD_ISSET(i, readset)) {
  800872:	8d 5f 07             	lea    0x7(%edi),%ebx
  800875:	85 ff                	test   %edi,%edi
  800877:	0f 49 df             	cmovns %edi,%ebx
  80087a:	c1 fb 03             	sar    $0x3,%ebx
  80087d:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800880:	89 fe                	mov    %edi,%esi
  800882:	83 e6 07             	and    $0x7,%esi
  800885:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800888:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  80088c:	0f a3 f0             	bt     %esi,%eax
  80088f:	72 a9                	jb     80083a <lwip_selscan+0x50>
      }
    }
    if (FD_ISSET(i, writeset)) {
  800891:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800894:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800898:	0f a3 f0             	bt     %esi,%eax
  80089b:	73 cd                	jae    80086a <lwip_selscan+0x80>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  80089d:	89 f8                	mov    %edi,%eax
  80089f:	e8 08 ff ff ff       	call   8007ac <get_socket>
      if (p_sock && p_sock->sendevent) {
  8008a4:	85 c0                	test   %eax,%eax
  8008a6:	74 c2                	je     80086a <lwip_selscan+0x80>
  8008a8:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  8008ad:	74 bb                	je     80086a <lwip_selscan+0x80>
        FD_SET(i, &lwriteset);
  8008af:	b8 01 00 00 00       	mov    $0x1,%eax
  8008b4:	89 f1                	mov    %esi,%ecx
  8008b6:	d3 e0                	shl    %cl,%eax
  8008b8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  8008bb:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  8008bf:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  8008c3:	eb a5                	jmp    80086a <lwip_selscan+0x80>
      }
    }
  }
  *readset = lreadset;
  8008c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008c8:	8b 55 cc             	mov    -0x34(%ebp),%edx
  8008cb:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  8008cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8008d0:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  8008d3:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  8008d5:	83 ec 04             	sub    $0x4,%esp
  8008d8:	6a 04                	push   $0x4
  8008da:	6a 00                	push   $0x0
  8008dc:	ff 75 08             	pushl  0x8(%ebp)
  8008df:	e8 50 e7 00 00       	call   80f034 <memset>
  
  return nready;
}
  8008e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  8008e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8008ea:	5b                   	pop    %ebx
  8008eb:	5e                   	pop    %esi
  8008ec:	5f                   	pop    %edi
  8008ed:	5d                   	pop    %ebp
  8008ee:	c3                   	ret    

008008ef <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  8008ef:	55                   	push   %ebp
  8008f0:	89 e5                	mov    %esp,%ebp
  8008f2:	57                   	push   %edi
  8008f3:	56                   	push   %esi
  8008f4:	53                   	push   %ebx
  8008f5:	83 ec 3c             	sub    $0x3c,%esp
  8008f8:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  8008fb:	89 cf                	mov    %ecx,%edi
  8008fd:	8b 75 08             	mov    0x8(%ebp),%esi
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800900:	e8 a7 fe ff ff       	call   8007ac <get_socket>
  if (!sock)
  800905:	85 c0                	test   %eax,%eax
  800907:	0f 84 86 00 00 00    	je     800993 <lwip_getaddrname+0xa4>
  80090d:	89 c3                	mov    %eax,%ebx
    return -1;

  memset(&sin, 0, sizeof(sin));
  80090f:	83 ec 04             	sub    $0x4,%esp
  800912:	6a 10                	push   $0x10
  800914:	6a 00                	push   $0x0
  800916:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800919:	50                   	push   %eax
  80091a:	e8 15 e7 00 00       	call   80f034 <memset>
  sin.sin_len = sizeof(sin);
  80091f:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800923:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800927:	89 f0                	mov    %esi,%eax
  800929:	0f b6 f0             	movzbl %al,%esi
  80092c:	56                   	push   %esi
  80092d:	8d 45 da             	lea    -0x26(%ebp),%eax
  800930:	50                   	push   %eax
  800931:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800934:	50                   	push   %eax
  800935:	ff 33                	pushl  (%ebx)
  800937:	e8 36 a4 00 00       	call   80ad72 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  80093c:	83 c4 14             	add    $0x14,%esp
  80093f:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800943:	50                   	push   %eax
  800944:	e8 1b 6e 00 00       	call   807764 <htons>
  800949:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80094d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800950:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800953:	83 c4 10             	add    $0x10,%esp
  800956:	83 3f 10             	cmpl   $0x10,(%edi)
  800959:	76 06                	jbe    800961 <lwip_getaddrname+0x72>
    *namelen = sizeof(sin);
  80095b:	c7 07 10 00 00 00    	movl   $0x10,(%edi)

  SMEMCPY(name, &sin, *namelen);
  800961:	83 ec 04             	sub    $0x4,%esp
  800964:	ff 37                	pushl  (%edi)
  800966:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800969:	50                   	push   %eax
  80096a:	ff 75 c4             	pushl  -0x3c(%ebp)
  80096d:	e8 6c e7 00 00       	call   80f0de <memcpy>
  sock_set_errno(sock, 0);
  800972:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800979:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800980:	00 00 00 
  return 0;
  800983:	83 c4 10             	add    $0x10,%esp
  800986:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80098b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80098e:	5b                   	pop    %ebx
  80098f:	5e                   	pop    %esi
  800990:	5f                   	pop    %edi
  800991:	5d                   	pop    %ebp
  800992:	c3                   	ret    
    return -1;
  800993:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800998:	eb f1                	jmp    80098b <lwip_getaddrname+0x9c>

0080099a <event_callback>:
{
  80099a:	55                   	push   %ebp
  80099b:	89 e5                	mov    %esp,%ebp
  80099d:	57                   	push   %edi
  80099e:	56                   	push   %esi
  80099f:	53                   	push   %ebx
  8009a0:	83 ec 1c             	sub    $0x1c,%esp
  8009a3:	8b 7d 08             	mov    0x8(%ebp),%edi
  8009a6:	8b 75 0c             	mov    0xc(%ebp),%esi
  if (conn) {
  8009a9:	85 ff                	test   %edi,%edi
  8009ab:	0f 84 8b 01 00 00    	je     800b3c <event_callback+0x1a2>
    s = conn->socket;
  8009b1:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  8009b4:	85 db                	test   %ebx,%ebx
  8009b6:	78 4d                	js     800a05 <event_callback+0x6b>
    sock = get_socket(s);
  8009b8:	89 d8                	mov    %ebx,%eax
  8009ba:	e8 ed fd ff ff       	call   8007ac <get_socket>
  8009bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  8009c2:	85 c0                	test   %eax,%eax
  8009c4:	0f 84 72 01 00 00    	je     800b3c <event_callback+0x1a2>
  sys_sem_wait(selectsem);
  8009ca:	83 ec 0c             	sub    $0xc,%esp
  8009cd:	ff 35 40 50 81 00    	pushl  0x815040
  8009d3:	e8 90 47 00 00       	call   805168 <sys_sem_wait>
  switch (evt) {
  8009d8:	83 c4 10             	add    $0x10,%esp
  8009db:	83 fe 01             	cmp    $0x1,%esi
  8009de:	0f 84 a1 00 00 00    	je     800a85 <event_callback+0xeb>
  8009e4:	85 f6                	test   %esi,%esi
  8009e6:	74 68                	je     800a50 <event_callback+0xb6>
  8009e8:	83 fe 02             	cmp    $0x2,%esi
  8009eb:	0f 84 9e 00 00 00    	je     800a8f <event_callback+0xf5>
  8009f1:	83 fe 03             	cmp    $0x3,%esi
  8009f4:	0f 85 a0 00 00 00    	jne    800a9a <event_callback+0x100>
      sock->sendevent = 0;
  8009fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8009fd:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800a03:	eb 53                	jmp    800a58 <event_callback+0xbe>
      sys_sem_wait(socksem);
  800a05:	83 ec 0c             	sub    $0xc,%esp
  800a08:	ff 35 44 50 81 00    	pushl  0x815044
  800a0e:	e8 55 47 00 00       	call   805168 <sys_sem_wait>
      if (conn->socket < 0) {
  800a13:	8b 47 1c             	mov    0x1c(%edi),%eax
  800a16:	83 c4 10             	add    $0x10,%esp
  800a19:	85 c0                	test   %eax,%eax
  800a1b:	78 13                	js     800a30 <event_callback+0x96>
      sys_sem_signal(socksem);
  800a1d:	83 ec 0c             	sub    $0xc,%esp
  800a20:	ff 35 44 50 81 00    	pushl  0x815044
  800a26:	e8 cf 96 00 00       	call   80a0fa <sys_sem_signal>
  800a2b:	83 c4 10             	add    $0x10,%esp
  800a2e:	eb 88                	jmp    8009b8 <event_callback+0x1e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800a30:	85 f6                	test   %esi,%esi
  800a32:	75 06                	jne    800a3a <event_callback+0xa0>
          conn->socket--;
  800a34:	83 e8 01             	sub    $0x1,%eax
  800a37:	89 47 1c             	mov    %eax,0x1c(%edi)
        sys_sem_signal(socksem);
  800a3a:	83 ec 0c             	sub    $0xc,%esp
  800a3d:	ff 35 44 50 81 00    	pushl  0x815044
  800a43:	e8 b2 96 00 00       	call   80a0fa <sys_sem_signal>
        return;
  800a48:	83 c4 10             	add    $0x10,%esp
  800a4b:	e9 ec 00 00 00       	jmp    800b3c <event_callback+0x1a2>
      sock->rcvevent++;
  800a50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a53:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
  sys_sem_signal(selectsem);
  800a58:	83 ec 0c             	sub    $0xc,%esp
  800a5b:	ff 35 40 50 81 00    	pushl  0x815040
  800a61:	e8 94 96 00 00       	call   80a0fa <sys_sem_signal>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800a66:	8d 73 07             	lea    0x7(%ebx),%esi
  800a69:	83 c4 10             	add    $0x10,%esp
  800a6c:	85 db                	test   %ebx,%ebx
  800a6e:	0f 49 f3             	cmovns %ebx,%esi
  800a71:	c1 fe 03             	sar    $0x3,%esi
  800a74:	89 d9                	mov    %ebx,%ecx
  800a76:	83 e1 07             	and    $0x7,%ecx
  800a79:	bf 01 00 00 00       	mov    $0x1,%edi
  800a7e:	d3 e7                	shl    %cl,%edi
  800a80:	e9 8d 00 00 00       	jmp    800b12 <event_callback+0x178>
      sock->rcvevent--;
  800a85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a88:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800a8d:	eb c9                	jmp    800a58 <event_callback+0xbe>
      sock->sendevent = 1;
  800a8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800a92:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800a98:	eb be                	jmp    800a58 <event_callback+0xbe>
      LWIP_ASSERT("unknown event", 0);
  800a9a:	83 ec 04             	sub    $0x4,%esp
  800a9d:	68 9f 15 81 00       	push   $0x81159f
  800aa2:	68 17 04 00 00       	push   $0x417
  800aa7:	68 ad 15 81 00       	push   $0x8115ad
  800aac:	e8 e8 db 00 00       	call   80e699 <_panic>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800ab1:	8b 1b                	mov    (%ebx),%ebx
  800ab3:	85 db                	test   %ebx,%ebx
  800ab5:	74 74                	je     800b2b <event_callback+0x191>
      if (scb->sem_signalled == 0) {
  800ab7:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800abb:	75 f4                	jne    800ab1 <event_callback+0x117>
        if (scb->readset && FD_ISSET(s, scb->readset))
  800abd:	8b 43 04             	mov    0x4(%ebx),%eax
  800ac0:	85 c0                	test   %eax,%eax
  800ac2:	74 12                	je     800ad6 <event_callback+0x13c>
  800ac4:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800ac8:	85 f8                	test   %edi,%eax
  800aca:	74 0a                	je     800ad6 <event_callback+0x13c>
          if (sock->rcvevent)
  800acc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800acf:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800ad4:	75 19                	jne    800aef <event_callback+0x155>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800ad6:	8b 43 08             	mov    0x8(%ebx),%eax
  800ad9:	85 c0                	test   %eax,%eax
  800adb:	74 d4                	je     800ab1 <event_callback+0x117>
  800add:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  800ae1:	85 f8                	test   %edi,%eax
  800ae3:	74 cc                	je     800ab1 <event_callback+0x117>
          if (sock->sendevent)
  800ae5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ae8:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800aed:	74 c2                	je     800ab1 <event_callback+0x117>
      scb->sem_signalled = 1;
  800aef:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800af6:	83 ec 0c             	sub    $0xc,%esp
  800af9:	ff 35 40 50 81 00    	pushl  0x815040
  800aff:	e8 f6 95 00 00       	call   80a0fa <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800b04:	83 c4 04             	add    $0x4,%esp
  800b07:	ff 73 14             	pushl  0x14(%ebx)
  800b0a:	e8 eb 95 00 00       	call   80a0fa <sys_sem_signal>
    sys_sem_wait(selectsem);
  800b0f:	83 c4 10             	add    $0x10,%esp
  800b12:	83 ec 0c             	sub    $0xc,%esp
  800b15:	ff 35 40 50 81 00    	pushl  0x815040
  800b1b:	e8 48 46 00 00       	call   805168 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800b20:	8b 1d 48 50 81 00    	mov    0x815048,%ebx
  800b26:	83 c4 10             	add    $0x10,%esp
  800b29:	eb 88                	jmp    800ab3 <event_callback+0x119>
      sys_sem_signal(selectsem);
  800b2b:	83 ec 0c             	sub    $0xc,%esp
  800b2e:	ff 35 40 50 81 00    	pushl  0x815040
  800b34:	e8 c1 95 00 00       	call   80a0fa <sys_sem_signal>
      break;
  800b39:	83 c4 10             	add    $0x10,%esp
}
  800b3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800b3f:	5b                   	pop    %ebx
  800b40:	5e                   	pop    %esi
  800b41:	5f                   	pop    %edi
  800b42:	5d                   	pop    %ebp
  800b43:	c3                   	ret    

00800b44 <alloc_socket>:
{
  800b44:	55                   	push   %ebp
  800b45:	89 e5                	mov    %esp,%ebp
  800b47:	56                   	push   %esi
  800b48:	53                   	push   %ebx
  800b49:	89 c6                	mov    %eax,%esi
  sys_sem_wait(socksem);
  800b4b:	83 ec 0c             	sub    $0xc,%esp
  800b4e:	ff 35 44 50 81 00    	pushl  0x815044
  800b54:	e8 0f 46 00 00       	call   805168 <sys_sem_wait>
  800b59:	b8 60 50 81 00       	mov    $0x815060,%eax
  800b5e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b61:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800b66:	83 38 00             	cmpl   $0x0,(%eax)
  800b69:	74 23                	je     800b8e <alloc_socket+0x4a>
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800b6b:	83 c3 01             	add    $0x1,%ebx
  800b6e:	83 c0 14             	add    $0x14,%eax
  800b71:	83 fb 20             	cmp    $0x20,%ebx
  800b74:	75 f0                	jne    800b66 <alloc_socket+0x22>
  sys_sem_signal(socksem);
  800b76:	83 ec 0c             	sub    $0xc,%esp
  800b79:	ff 35 44 50 81 00    	pushl  0x815044
  800b7f:	e8 76 95 00 00       	call   80a0fa <sys_sem_signal>
  return -1;
  800b84:	83 c4 10             	add    $0x10,%esp
  800b87:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  800b8c:	eb 55                	jmp    800be3 <alloc_socket+0x9f>
      sockets[i].conn       = newconn;
  800b8e:	8d 14 9b             	lea    (%ebx,%ebx,4),%edx
  800b91:	c1 e2 02             	shl    $0x2,%edx
  800b94:	89 b2 60 50 81 00    	mov    %esi,0x815060(%edx)
      sockets[i].lastdata   = NULL;
  800b9a:	c7 82 64 50 81 00 00 	movl   $0x0,0x815064(%edx)
  800ba1:	00 00 00 
      sockets[i].lastoffset = 0;
  800ba4:	66 c7 82 68 50 81 00 	movw   $0x0,0x815068(%edx)
  800bab:	00 00 
      sockets[i].rcvevent   = 0;
  800bad:	66 c7 82 6a 50 81 00 	movw   $0x0,0x81506a(%edx)
  800bb4:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800bb6:	66 c7 82 6c 50 81 00 	movw   $0x1,0x81506c(%edx)
  800bbd:	01 00 
      sockets[i].flags      = 0;
  800bbf:	66 c7 82 6e 50 81 00 	movw   $0x0,0x81506e(%edx)
  800bc6:	00 00 
      sockets[i].err        = 0;
  800bc8:	c7 82 70 50 81 00 00 	movl   $0x0,0x815070(%edx)
  800bcf:	00 00 00 
      sys_sem_signal(socksem);
  800bd2:	83 ec 0c             	sub    $0xc,%esp
  800bd5:	ff 35 44 50 81 00    	pushl  0x815044
  800bdb:	e8 1a 95 00 00       	call   80a0fa <sys_sem_signal>
      return i;
  800be0:	83 c4 10             	add    $0x10,%esp
}
  800be3:	89 d8                	mov    %ebx,%eax
  800be5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  800be8:	5b                   	pop    %ebx
  800be9:	5e                   	pop    %esi
  800bea:	5d                   	pop    %ebp
  800beb:	c3                   	ret    

00800bec <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800bec:	55                   	push   %ebp
  800bed:	89 e5                	mov    %esp,%ebp
  800bef:	53                   	push   %ebx
  800bf0:	83 ec 04             	sub    $0x4,%esp
  800bf3:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800bf6:	85 c0                	test   %eax,%eax
  800bf8:	74 39                	je     800c33 <lwip_getsockopt_internal+0x47>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800bfa:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800bfc:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800bff:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800c02:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800c05:	83 fa 06             	cmp    $0x6,%edx
  800c08:	0f 84 37 01 00 00    	je     800d45 <lwip_getsockopt_internal+0x159>
  800c0e:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800c14:	74 34                	je     800c4a <lwip_getsockopt_internal+0x5e>
  800c16:	85 d2                	test   %edx,%edx
  800c18:	0f 84 f9 00 00 00    	je     800d17 <lwip_getsockopt_internal+0x12b>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800c1e:	83 ec 0c             	sub    $0xc,%esp
  800c21:	8b 03                	mov    (%ebx),%eax
  800c23:	ff 70 10             	pushl  0x10(%eax)
  800c26:	e8 cf 94 00 00       	call   80a0fa <sys_sem_signal>
}
  800c2b:	83 c4 10             	add    $0x10,%esp
  800c2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800c31:	c9                   	leave  
  800c32:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800c33:	83 ec 04             	sub    $0x4,%esp
  800c36:	68 c4 15 81 00       	push   $0x8115c4
  800c3b:	68 38 05 00 00       	push   $0x538
  800c40:	68 ad 15 81 00       	push   $0x8115ad
  800c45:	e8 4f da 00 00       	call   80e699 <_panic>
  800c4a:	83 f9 20             	cmp    $0x20,%ecx
  800c4d:	74 65                	je     800cb4 <lwip_getsockopt_internal+0xc8>
  800c4f:	7e 55                	jle    800ca6 <lwip_getsockopt_internal+0xba>
  800c51:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  800c57:	74 6d                	je     800cc6 <lwip_getsockopt_internal+0xda>
  800c59:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800c5f:	0f 84 9f 00 00 00    	je     800d04 <lwip_getsockopt_internal+0x118>
  800c65:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  800c6b:	75 b1                	jne    800c1e <lwip_getsockopt_internal+0x32>
      if (sock->err == 0) {
  800c6d:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800c71:	75 22                	jne    800c95 <lwip_getsockopt_internal+0xa9>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800c73:	8b 13                	mov    (%ebx),%edx
  800c75:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  800c79:	f7 da                	neg    %edx
  800c7b:	b9 05 00 00 00       	mov    $0x5,%ecx
  800c80:	83 fa 0e             	cmp    $0xe,%edx
  800c83:	77 07                	ja     800c8c <lwip_getsockopt_internal+0xa0>
  800c85:	8b 0c 95 60 16 81 00 	mov    0x811660(,%edx,4),%ecx
  800c8c:	89 4b 10             	mov    %ecx,0x10(%ebx)
  800c8f:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
      *(int *)optval = sock->err;
  800c95:	8b 53 10             	mov    0x10(%ebx),%edx
  800c98:	89 10                	mov    %edx,(%eax)
      sock->err = 0;
  800c9a:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
      break;
  800ca1:	e9 78 ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
  800ca6:	83 f9 02             	cmp    $0x2,%ecx
  800ca9:	74 09                	je     800cb4 <lwip_getsockopt_internal+0xc8>
  800cab:	83 f9 08             	cmp    $0x8,%ecx
  800cae:	0f 85 6a ff ff ff    	jne    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800cb4:	8b 13                	mov    (%ebx),%edx
  800cb6:	8b 52 08             	mov    0x8(%edx),%edx
  800cb9:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  800cbd:	21 d1                	and    %edx,%ecx
  800cbf:	89 08                	mov    %ecx,(%eax)
      break;
  800cc1:	e9 58 ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800cc6:	8b 13                	mov    (%ebx),%edx
  800cc8:	8b 12                	mov    (%edx),%edx
  800cca:	89 d1                	mov    %edx,%ecx
  800ccc:	81 e1 f0 00 00 00    	and    $0xf0,%ecx
  800cd2:	83 f9 20             	cmp    $0x20,%ecx
  800cd5:	74 22                	je     800cf9 <lwip_getsockopt_internal+0x10d>
  800cd7:	83 f9 40             	cmp    $0x40,%ecx
  800cda:	74 12                	je     800cee <lwip_getsockopt_internal+0x102>
        *(int*)optval = sock->conn->type;
  800cdc:	83 f9 10             	cmp    $0x10,%ecx
  800cdf:	b9 01 00 00 00       	mov    $0x1,%ecx
  800ce4:	0f 44 d1             	cmove  %ecx,%edx
  800ce7:	89 10                	mov    %edx,(%eax)
  800ce9:	e9 30 ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_RAW;
  800cee:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        break;
  800cf4:	e9 25 ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
        *(int*)optval = SOCK_DGRAM;
  800cf9:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        break;
  800cff:	e9 1a ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800d04:	8b 13                	mov    (%ebx),%edx
  800d06:	8b 52 08             	mov    0x8(%edx),%edx
  800d09:	0f b6 52 10          	movzbl 0x10(%edx),%edx
  800d0d:	83 e2 01             	and    $0x1,%edx
  800d10:	89 10                	mov    %edx,(%eax)
      break;
  800d12:	e9 07 ff ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
  800d17:	83 f9 01             	cmp    $0x1,%ecx
  800d1a:	74 19                	je     800d35 <lwip_getsockopt_internal+0x149>
  800d1c:	83 f9 02             	cmp    $0x2,%ecx
  800d1f:	0f 85 f9 fe ff ff    	jne    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800d25:	8b 13                	mov    (%ebx),%edx
  800d27:	8b 52 08             	mov    0x8(%edx),%edx
  800d2a:	0f b6 52 0b          	movzbl 0xb(%edx),%edx
  800d2e:	89 10                	mov    %edx,(%eax)
      break;
  800d30:	e9 e9 fe ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = sock->conn->pcb.ip->tos;
  800d35:	8b 13                	mov    (%ebx),%edx
  800d37:	8b 52 08             	mov    0x8(%edx),%edx
  800d3a:	0f b6 52 0a          	movzbl 0xa(%edx),%edx
  800d3e:	89 10                	mov    %edx,(%eax)
      break;
  800d40:	e9 d9 fe ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
  800d45:	83 f9 01             	cmp    $0x1,%ecx
  800d48:	74 1b                	je     800d65 <lwip_getsockopt_internal+0x179>
  800d4a:	83 f9 02             	cmp    $0x2,%ecx
  800d4d:	0f 85 cb fe ff ff    	jne    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800d53:	8b 13                	mov    (%ebx),%edx
  800d55:	8b 52 08             	mov    0x8(%edx),%edx
  800d58:	8b 92 9c 00 00 00    	mov    0x9c(%edx),%edx
  800d5e:	89 10                	mov    %edx,(%eax)
      break;
  800d60:	e9 b9 fe ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800d65:	8b 13                	mov    (%ebx),%edx
  800d67:	8b 52 08             	mov    0x8(%edx),%edx
  800d6a:	0f b6 52 20          	movzbl 0x20(%edx),%edx
  800d6e:	83 e2 40             	and    $0x40,%edx
  800d71:	0f b6 d2             	movzbl %dl,%edx
  800d74:	89 10                	mov    %edx,(%eax)
      break;
  800d76:	e9 a3 fe ff ff       	jmp    800c1e <lwip_getsockopt_internal+0x32>

00800d7b <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800d7b:	55                   	push   %ebp
  800d7c:	89 e5                	mov    %esp,%ebp
  800d7e:	53                   	push   %ebx
  800d7f:	83 ec 04             	sub    $0x4,%esp
  800d82:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800d85:	85 c0                	test   %eax,%eax
  800d87:	74 35                	je     800dbe <lwip_setsockopt_internal+0x43>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800d89:	8b 18                	mov    (%eax),%ebx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  800d8b:	8b 50 08             	mov    0x8(%eax),%edx
  optname = data->optname;
  800d8e:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800d91:	8b 40 10             	mov    0x10(%eax),%eax

  switch (level) {
  800d94:	83 fa 06             	cmp    $0x6,%edx
  800d97:	0f 84 aa 00 00 00    	je     800e47 <lwip_setsockopt_internal+0xcc>
  800d9d:	81 fa ff 0f 00 00    	cmp    $0xfff,%edx
  800da3:	74 30                	je     800dd5 <lwip_setsockopt_internal+0x5a>
  800da5:	85 d2                	test   %edx,%edx
  800da7:	74 76                	je     800e1f <lwip_setsockopt_internal+0xa4>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800da9:	83 ec 0c             	sub    $0xc,%esp
  800dac:	8b 03                	mov    (%ebx),%eax
  800dae:	ff 70 10             	pushl  0x10(%eax)
  800db1:	e8 44 93 00 00       	call   80a0fa <sys_sem_signal>
}
  800db6:	83 c4 10             	add    $0x10,%esp
  800db9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  800dbc:	c9                   	leave  
  800dbd:	c3                   	ret    
  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dbe:	83 ec 04             	sub    $0x4,%esp
  800dc1:	68 c4 15 81 00       	push   $0x8115c4
  800dc6:	68 ae 06 00 00       	push   $0x6ae
  800dcb:	68 ad 15 81 00       	push   $0x8115ad
  800dd0:	e8 c4 d8 00 00       	call   80e699 <_panic>
  800dd5:	83 f9 20             	cmp    $0x20,%ecx
  800dd8:	74 0d                	je     800de7 <lwip_setsockopt_internal+0x6c>
  800dda:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800de0:	74 22                	je     800e04 <lwip_setsockopt_internal+0x89>
  800de2:	83 f9 08             	cmp    $0x8,%ecx
  800de5:	75 c2                	jne    800da9 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800de7:	83 38 00             	cmpl   $0x0,(%eax)
  800dea:	74 0b                	je     800df7 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  800dec:	8b 03                	mov    (%ebx),%eax
  800dee:	8b 40 08             	mov    0x8(%eax),%eax
  800df1:	66 09 48 08          	or     %cx,0x8(%eax)
  800df5:	eb b2                	jmp    800da9 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.ip->so_options &= ~optname;
  800df7:	8b 03                	mov    (%ebx),%eax
  800df9:	8b 40 08             	mov    0x8(%eax),%eax
  800dfc:	f7 d1                	not    %ecx
  800dfe:	66 21 48 08          	and    %cx,0x8(%eax)
  800e02:	eb a5                	jmp    800da9 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e04:	83 38 00             	cmpl   $0x0,(%eax)
  800e07:	74 0b                	je     800e14 <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800e09:	8b 03                	mov    (%ebx),%eax
  800e0b:	8b 40 08             	mov    0x8(%eax),%eax
  800e0e:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800e12:	eb 95                	jmp    800da9 <lwip_setsockopt_internal+0x2e>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800e14:	8b 03                	mov    (%ebx),%eax
  800e16:	8b 40 08             	mov    0x8(%eax),%eax
  800e19:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800e1d:	eb 8a                	jmp    800da9 <lwip_setsockopt_internal+0x2e>
  800e1f:	83 f9 01             	cmp    $0x1,%ecx
  800e22:	74 14                	je     800e38 <lwip_setsockopt_internal+0xbd>
  800e24:	83 f9 02             	cmp    $0x2,%ecx
  800e27:	75 80                	jne    800da9 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  800e29:	8b 13                	mov    (%ebx),%edx
  800e2b:	8b 52 08             	mov    0x8(%edx),%edx
  800e2e:	8b 00                	mov    (%eax),%eax
  800e30:	88 42 0b             	mov    %al,0xb(%edx)
      break;
  800e33:	e9 71 ff ff ff       	jmp    800da9 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  800e38:	8b 13                	mov    (%ebx),%edx
  800e3a:	8b 52 08             	mov    0x8(%edx),%edx
  800e3d:	8b 00                	mov    (%eax),%eax
  800e3f:	88 42 0a             	mov    %al,0xa(%edx)
      break;
  800e42:	e9 62 ff ff ff       	jmp    800da9 <lwip_setsockopt_internal+0x2e>
  800e47:	83 f9 01             	cmp    $0x1,%ecx
  800e4a:	74 1b                	je     800e67 <lwip_setsockopt_internal+0xec>
  800e4c:	83 f9 02             	cmp    $0x2,%ecx
  800e4f:	0f 85 54 ff ff ff    	jne    800da9 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  800e55:	8b 13                	mov    (%ebx),%edx
  800e57:	8b 52 08             	mov    0x8(%edx),%edx
  800e5a:	8b 00                	mov    (%eax),%eax
  800e5c:	89 82 9c 00 00 00    	mov    %eax,0x9c(%edx)
      break;
  800e62:	e9 42 ff ff ff       	jmp    800da9 <lwip_setsockopt_internal+0x2e>
      if (*(int*)optval) {
  800e67:	83 38 00             	cmpl   $0x0,(%eax)
  800e6a:	74 0e                	je     800e7a <lwip_setsockopt_internal+0xff>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  800e6c:	8b 03                	mov    (%ebx),%eax
  800e6e:	8b 40 08             	mov    0x8(%eax),%eax
  800e71:	80 48 20 40          	orb    $0x40,0x20(%eax)
  800e75:	e9 2f ff ff ff       	jmp    800da9 <lwip_setsockopt_internal+0x2e>
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  800e7a:	8b 03                	mov    (%ebx),%eax
  800e7c:	8b 40 08             	mov    0x8(%eax),%eax
  800e7f:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  800e83:	e9 21 ff ff ff       	jmp    800da9 <lwip_setsockopt_internal+0x2e>

00800e88 <lwip_socket_init>:
{
  800e88:	55                   	push   %ebp
  800e89:	89 e5                	mov    %esp,%ebp
  800e8b:	83 ec 14             	sub    $0x14,%esp
  socksem   = sys_sem_new(1);
  800e8e:	6a 01                	push   $0x1
  800e90:	e8 a8 8f 00 00       	call   809e3d <sys_sem_new>
  800e95:	a3 44 50 81 00       	mov    %eax,0x815044
  selectsem = sys_sem_new(1);
  800e9a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  800ea1:	e8 97 8f 00 00       	call   809e3d <sys_sem_new>
  800ea6:	a3 40 50 81 00       	mov    %eax,0x815040
}
  800eab:	83 c4 10             	add    $0x10,%esp
  800eae:	c9                   	leave  
  800eaf:	c3                   	ret    

00800eb0 <lwip_accept>:
{
  800eb0:	55                   	push   %ebp
  800eb1:	89 e5                	mov    %esp,%ebp
  800eb3:	57                   	push   %edi
  800eb4:	56                   	push   %esi
  800eb5:	53                   	push   %ebx
  800eb6:	83 ec 3c             	sub    $0x3c,%esp
  800eb9:	8b 7d 10             	mov    0x10(%ebp),%edi
  sock = get_socket(s);
  800ebc:	8b 45 08             	mov    0x8(%ebp),%eax
  800ebf:	e8 e8 f8 ff ff       	call   8007ac <get_socket>
  if (!sock)
  800ec4:	85 c0                	test   %eax,%eax
  800ec6:	0f 84 8c 01 00 00    	je     801058 <lwip_accept+0x1a8>
  800ecc:	89 c6                	mov    %eax,%esi
  newconn = netconn_accept(sock->conn);
  800ece:	83 ec 0c             	sub    $0xc,%esp
  800ed1:	ff 30                	pushl  (%eax)
  800ed3:	e8 50 a0 00 00       	call   80af28 <netconn_accept>
  800ed8:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  800eda:	83 c4 10             	add    $0x10,%esp
  800edd:	85 c0                	test   %eax,%eax
  800edf:	0f 84 de 00 00 00    	je     800fc3 <lwip_accept+0x113>
  err = netconn_peer(newconn, &naddr, &port);
  800ee5:	6a 00                	push   $0x0
  800ee7:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  800eea:	50                   	push   %eax
  800eeb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800eee:	50                   	push   %eax
  800eef:	53                   	push   %ebx
  800ef0:	e8 7d 9e 00 00       	call   80ad72 <netconn_getaddr>
  800ef5:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  800ef8:	83 c4 10             	add    $0x10,%esp
  800efb:	84 c0                	test   %al,%al
  800efd:	0f 85 e9 00 00 00    	jne    800fec <lwip_accept+0x13c>
  memset(&sin, 0, sizeof(sin));
  800f03:	83 ec 04             	sub    $0x4,%esp
  800f06:	6a 10                	push   $0x10
  800f08:	6a 00                	push   $0x0
  800f0a:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f0d:	50                   	push   %eax
  800f0e:	e8 21 e1 00 00       	call   80f034 <memset>
  sin.sin_len = sizeof(sin);
  800f13:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  800f17:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  800f1b:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  800f1f:	89 04 24             	mov    %eax,(%esp)
  800f22:	e8 3d 68 00 00       	call   807764 <htons>
  800f27:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800f2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800f2e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  if (*addrlen > sizeof(sin))
  800f31:	83 c4 10             	add    $0x10,%esp
  800f34:	83 3f 10             	cmpl   $0x10,(%edi)
  800f37:	76 06                	jbe    800f3f <lwip_accept+0x8f>
    *addrlen = sizeof(sin);
  800f39:	c7 07 10 00 00 00    	movl   $0x10,(%edi)
  SMEMCPY(addr, &sin, *addrlen);
  800f3f:	83 ec 04             	sub    $0x4,%esp
  800f42:	ff 37                	pushl  (%edi)
  800f44:	8d 45 d0             	lea    -0x30(%ebp),%eax
  800f47:	50                   	push   %eax
  800f48:	ff 75 0c             	pushl  0xc(%ebp)
  800f4b:	e8 8e e1 00 00       	call   80f0de <memcpy>
  newsock = alloc_socket(newconn);
  800f50:	89 d8                	mov    %ebx,%eax
  800f52:	e8 ed fb ff ff       	call   800b44 <alloc_socket>
  800f57:	89 c7                	mov    %eax,%edi
  if (newsock == -1) {
  800f59:	83 c4 10             	add    $0x10,%esp
  800f5c:	83 f8 ff             	cmp    $0xffffffff,%eax
  800f5f:	0f 84 ba 00 00 00    	je     80101f <lwip_accept+0x16f>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  800f65:	83 f8 1f             	cmp    $0x1f,%eax
  800f68:	0f 87 d3 00 00 00    	ja     801041 <lwip_accept+0x191>
  newconn->callback = event_callback;
  800f6e:	c7 43 2c 9a 09 80 00 	movl   $0x80099a,0x2c(%ebx)
  sys_sem_wait(socksem);
  800f75:	83 ec 0c             	sub    $0xc,%esp
  800f78:	ff 35 44 50 81 00    	pushl  0x815044
  800f7e:	e8 e5 41 00 00       	call   805168 <sys_sem_wait>
  nsock->rcvevent += -1 - newconn->socket;
  800f83:	8d 04 bf             	lea    (%edi,%edi,4),%eax
  800f86:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  800f8a:	f7 d2                	not    %edx
  800f8c:	66 01 14 85 6a 50 81 	add    %dx,0x81506a(,%eax,4)
  800f93:	00 
  newconn->socket = newsock;
  800f94:	89 7b 1c             	mov    %edi,0x1c(%ebx)
  sys_sem_signal(socksem);
  800f97:	83 c4 04             	add    $0x4,%esp
  800f9a:	ff 35 44 50 81 00    	pushl  0x815044
  800fa0:	e8 55 91 00 00       	call   80a0fa <sys_sem_signal>
  sock_set_errno(sock, 0);
  800fa5:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  800fac:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  800fb3:	00 00 00 
  return newsock;
  800fb6:	83 c4 10             	add    $0x10,%esp
}
  800fb9:	89 f8                	mov    %edi,%eax
  800fbb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  800fbe:	5b                   	pop    %ebx
  800fbf:	5e                   	pop    %esi
  800fc0:	5f                   	pop    %edi
  800fc1:	5d                   	pop    %ebp
  800fc2:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  800fc3:	8b 06                	mov    (%esi),%eax
  800fc5:	0f be 40 0c          	movsbl 0xc(%eax),%eax
  800fc9:	f7 d8                	neg    %eax
  800fcb:	ba 05 00 00 00       	mov    $0x5,%edx
  800fd0:	83 f8 0e             	cmp    $0xe,%eax
  800fd3:	77 07                	ja     800fdc <lwip_accept+0x12c>
  800fd5:	8b 14 85 60 16 81 00 	mov    0x811660(,%eax,4),%edx
  800fdc:	89 56 10             	mov    %edx,0x10(%esi)
  800fdf:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  800fe5:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  800fea:	eb cd                	jmp    800fb9 <lwip_accept+0x109>
    netconn_delete(newconn);
  800fec:	83 ec 0c             	sub    $0xc,%esp
  800fef:	53                   	push   %ebx
  800ff0:	e8 15 9d 00 00       	call   80ad0a <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  800ff5:	0f be 45 c7          	movsbl -0x39(%ebp),%eax
  800ff9:	f7 d8                	neg    %eax
  800ffb:	83 c4 10             	add    $0x10,%esp
  800ffe:	ba 05 00 00 00       	mov    $0x5,%edx
  801003:	83 f8 0e             	cmp    $0xe,%eax
  801006:	77 07                	ja     80100f <lwip_accept+0x15f>
  801008:	8b 14 85 60 16 81 00 	mov    0x811660(,%eax,4),%edx
  80100f:	89 56 10             	mov    %edx,0x10(%esi)
  801012:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801018:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80101d:	eb 9a                	jmp    800fb9 <lwip_accept+0x109>
    netconn_delete(newconn);
  80101f:	83 ec 0c             	sub    $0xc,%esp
  801022:	53                   	push   %ebx
  801023:	e8 e2 9c 00 00       	call   80ad0a <netconn_delete>
    sock_set_errno(sock, ENFILE);
  801028:	c7 46 10 17 00 00 00 	movl   $0x17,0x10(%esi)
  80102f:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  801036:	00 00 00 
    return -1;
  801039:	83 c4 10             	add    $0x10,%esp
  80103c:	e9 78 ff ff ff       	jmp    800fb9 <lwip_accept+0x109>
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  801041:	83 ec 04             	sub    $0x4,%esp
  801044:	68 d0 15 81 00       	push   $0x8115d0
  801049:	68 25 01 00 00       	push   $0x125
  80104e:	68 ad 15 81 00       	push   $0x8115ad
  801053:	e8 41 d6 00 00       	call   80e699 <_panic>
    return -1;
  801058:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80105d:	e9 57 ff ff ff       	jmp    800fb9 <lwip_accept+0x109>

00801062 <lwip_bind>:
{
  801062:	55                   	push   %ebp
  801063:	89 e5                	mov    %esp,%ebp
  801065:	56                   	push   %esi
  801066:	53                   	push   %ebx
  801067:	83 ec 10             	sub    $0x10,%esp
  80106a:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  80106d:	8b 45 08             	mov    0x8(%ebp),%eax
  801070:	e8 37 f7 ff ff       	call   8007ac <get_socket>
  if (!sock)
  801075:	85 c0                	test   %eax,%eax
  801077:	0f 84 94 00 00 00    	je     801111 <lwip_bind+0xaf>
  80107d:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80107f:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801083:	75 4f                	jne    8010d4 <lwip_bind+0x72>
  801085:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801089:	75 49                	jne    8010d4 <lwip_bind+0x72>
  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80108b:	8b 46 04             	mov    0x4(%esi),%eax
  80108e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  801091:	83 ec 0c             	sub    $0xc,%esp
  801094:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  801098:	50                   	push   %eax
  801099:	e8 d3 66 00 00       	call   807771 <ntohs>
  80109e:	83 c4 0c             	add    $0xc,%esp
  8010a1:	0f b7 c0             	movzwl %ax,%eax
  8010a4:	50                   	push   %eax
  8010a5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8010a8:	50                   	push   %eax
  8010a9:	ff 33                	pushl  (%ebx)
  8010ab:	e8 4e 9d 00 00       	call   80adfe <netconn_bind>
  if (err != ERR_OK) {
  8010b0:	83 c4 10             	add    $0x10,%esp
  8010b3:	84 c0                	test   %al,%al
  8010b5:	75 34                	jne    8010eb <lwip_bind+0x89>
  sock_set_errno(sock, 0);
  8010b7:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8010be:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8010c5:	00 00 00 
  return 0;
  8010c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8010cd:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8010d0:	5b                   	pop    %ebx
  8010d1:	5e                   	pop    %esi
  8010d2:	5d                   	pop    %ebp
  8010d3:	c3                   	ret    
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8010d4:	83 ec 04             	sub    $0x4,%esp
  8010d7:	68 e5 15 81 00       	push   $0x8115e5
  8010dc:	68 4a 01 00 00       	push   $0x14a
  8010e1:	68 ad 15 81 00       	push   $0x8115ad
  8010e6:	e8 ae d5 00 00       	call   80e699 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  8010eb:	0f be c0             	movsbl %al,%eax
  8010ee:	f7 d8                	neg    %eax
  8010f0:	ba 05 00 00 00       	mov    $0x5,%edx
  8010f5:	83 f8 0e             	cmp    $0xe,%eax
  8010f8:	77 07                	ja     801101 <lwip_bind+0x9f>
  8010fa:	8b 14 85 60 16 81 00 	mov    0x811660(,%eax,4),%edx
  801101:	89 53 10             	mov    %edx,0x10(%ebx)
  801104:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  80110a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80110f:	eb bc                	jmp    8010cd <lwip_bind+0x6b>
    return -1;
  801111:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801116:	eb b5                	jmp    8010cd <lwip_bind+0x6b>

00801118 <lwip_close>:
{
  801118:	55                   	push   %ebp
  801119:	89 e5                	mov    %esp,%ebp
  80111b:	53                   	push   %ebx
  80111c:	83 ec 04             	sub    $0x4,%esp
  sock = get_socket(s);
  80111f:	8b 45 08             	mov    0x8(%ebp),%eax
  801122:	e8 85 f6 ff ff       	call   8007ac <get_socket>
  if (!sock) {
  801127:	85 c0                	test   %eax,%eax
  801129:	74 6f                	je     80119a <lwip_close+0x82>
  80112b:	89 c3                	mov    %eax,%ebx
  netconn_delete(sock->conn);
  80112d:	83 ec 0c             	sub    $0xc,%esp
  801130:	ff 30                	pushl  (%eax)
  801132:	e8 d3 9b 00 00       	call   80ad0a <netconn_delete>
  sys_sem_wait(socksem);
  801137:	83 c4 04             	add    $0x4,%esp
  80113a:	ff 35 44 50 81 00    	pushl  0x815044
  801140:	e8 23 40 00 00       	call   805168 <sys_sem_wait>
  if (sock->lastdata) {
  801145:	8b 43 04             	mov    0x4(%ebx),%eax
  801148:	83 c4 10             	add    $0x10,%esp
  80114b:	85 c0                	test   %eax,%eax
  80114d:	74 0c                	je     80115b <lwip_close+0x43>
    netbuf_delete(sock->lastdata);
  80114f:	83 ec 0c             	sub    $0xc,%esp
  801152:	50                   	push   %eax
  801153:	e8 99 13 00 00       	call   8024f1 <netbuf_delete>
  801158:	83 c4 10             	add    $0x10,%esp
  sock->lastdata   = NULL;
  80115b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801162:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  801168:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80116e:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801175:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80117c:	00 00 00 
  sys_sem_signal(socksem);
  80117f:	83 ec 0c             	sub    $0xc,%esp
  801182:	ff 35 44 50 81 00    	pushl  0x815044
  801188:	e8 6d 8f 00 00       	call   80a0fa <sys_sem_signal>
  return 0;
  80118d:	83 c4 10             	add    $0x10,%esp
  801190:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801195:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  801198:	c9                   	leave  
  801199:	c3                   	ret    
    return -1;
  80119a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80119f:	eb f4                	jmp    801195 <lwip_close+0x7d>

008011a1 <lwip_connect>:
{
  8011a1:	55                   	push   %ebp
  8011a2:	89 e5                	mov    %esp,%ebp
  8011a4:	56                   	push   %esi
  8011a5:	53                   	push   %ebx
  8011a6:	83 ec 10             	sub    $0x10,%esp
  8011a9:	8b 75 0c             	mov    0xc(%ebp),%esi
  sock = get_socket(s);
  8011ac:	8b 45 08             	mov    0x8(%ebp),%eax
  8011af:	e8 f8 f5 ff ff       	call   8007ac <get_socket>
  if (!sock)
  8011b4:	85 c0                	test   %eax,%eax
  8011b6:	0f 84 94 00 00 00    	je     801250 <lwip_connect+0xaf>
  8011bc:	89 c3                	mov    %eax,%ebx
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8011be:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8011c2:	75 4f                	jne    801213 <lwip_connect+0x72>
  8011c4:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8011c8:	75 49                	jne    801213 <lwip_connect+0x72>
    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8011ca:	8b 46 04             	mov    0x4(%esi),%eax
  8011cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8011d0:	83 ec 0c             	sub    $0xc,%esp
  8011d3:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8011d7:	50                   	push   %eax
  8011d8:	e8 94 65 00 00       	call   807771 <ntohs>
  8011dd:	83 c4 0c             	add    $0xc,%esp
  8011e0:	0f b7 c0             	movzwl %ax,%eax
  8011e3:	50                   	push   %eax
  8011e4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8011e7:	50                   	push   %eax
  8011e8:	ff 33                	pushl  (%ebx)
  8011ea:	e8 60 9c 00 00       	call   80ae4f <netconn_connect>
  if (err != ERR_OK) {
  8011ef:	83 c4 10             	add    $0x10,%esp
  8011f2:	84 c0                	test   %al,%al
  8011f4:	75 34                	jne    80122a <lwip_connect+0x89>
  sock_set_errno(sock, 0);
  8011f6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8011fd:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801204:	00 00 00 
  return 0;
  801207:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80120c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80120f:	5b                   	pop    %ebx
  801210:	5e                   	pop    %esi
  801211:	5d                   	pop    %ebp
  801212:	c3                   	ret    
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801213:	83 ec 04             	sub    $0x4,%esp
  801216:	68 00 16 81 00       	push   $0x811600
  80121b:	68 86 01 00 00       	push   $0x186
  801220:	68 ad 15 81 00       	push   $0x8115ad
  801225:	e8 6f d4 00 00       	call   80e699 <_panic>
    sock_set_errno(sock, err_to_errno(err));
  80122a:	0f be c0             	movsbl %al,%eax
  80122d:	f7 d8                	neg    %eax
  80122f:	ba 05 00 00 00       	mov    $0x5,%edx
  801234:	83 f8 0e             	cmp    $0xe,%eax
  801237:	77 07                	ja     801240 <lwip_connect+0x9f>
  801239:	8b 14 85 60 16 81 00 	mov    0x811660(,%eax,4),%edx
  801240:	89 53 10             	mov    %edx,0x10(%ebx)
  801243:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  801249:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80124e:	eb bc                	jmp    80120c <lwip_connect+0x6b>
    return -1;
  801250:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801255:	eb b5                	jmp    80120c <lwip_connect+0x6b>

00801257 <lwip_listen>:
{
  801257:	55                   	push   %ebp
  801258:	89 e5                	mov    %esp,%ebp
  80125a:	56                   	push   %esi
  80125b:	53                   	push   %ebx
  80125c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  sock = get_socket(s);
  80125f:	8b 45 08             	mov    0x8(%ebp),%eax
  801262:	e8 45 f5 ff ff       	call   8007ac <get_socket>
  if (!sock)
  801267:	85 c0                	test   %eax,%eax
  801269:	74 6f                	je     8012da <lwip_listen+0x83>
  80126b:	89 c6                	mov    %eax,%esi
  80126d:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  801273:	b8 ff 00 00 00       	mov    $0xff,%eax
  801278:	0f 4f d8             	cmovg  %eax,%ebx
  err = netconn_listen_with_backlog(sock->conn, backlog);
  80127b:	83 ec 08             	sub    $0x8,%esp
  80127e:	85 db                	test   %ebx,%ebx
  801280:	b8 00 00 00 00       	mov    $0x0,%eax
  801285:	0f 48 d8             	cmovs  %eax,%ebx
  801288:	53                   	push   %ebx
  801289:	ff 36                	pushl  (%esi)
  80128b:	e8 54 9c 00 00       	call   80aee4 <netconn_listen_with_backlog>
  if (err != ERR_OK) {
  801290:	83 c4 10             	add    $0x10,%esp
  801293:	84 c0                	test   %al,%al
  801295:	75 1d                	jne    8012b4 <lwip_listen+0x5d>
  sock_set_errno(sock, 0);
  801297:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  80129e:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8012a5:	00 00 00 
  return 0;
  8012a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8012ad:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8012b0:	5b                   	pop    %ebx
  8012b1:	5e                   	pop    %esi
  8012b2:	5d                   	pop    %ebp
  8012b3:	c3                   	ret    
    sock_set_errno(sock, err_to_errno(err));
  8012b4:	0f be c0             	movsbl %al,%eax
  8012b7:	f7 d8                	neg    %eax
  8012b9:	ba 05 00 00 00       	mov    $0x5,%edx
  8012be:	83 f8 0e             	cmp    $0xe,%eax
  8012c1:	77 07                	ja     8012ca <lwip_listen+0x73>
  8012c3:	8b 14 85 60 16 81 00 	mov    0x811660(,%eax,4),%edx
  8012ca:	89 56 10             	mov    %edx,0x10(%esi)
  8012cd:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
    return -1;
  8012d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012d8:	eb d3                	jmp    8012ad <lwip_listen+0x56>
    return -1;
  8012da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012df:	eb cc                	jmp    8012ad <lwip_listen+0x56>

008012e1 <lwip_recvfrom>:
{
  8012e1:	55                   	push   %ebp
  8012e2:	89 e5                	mov    %esp,%ebp
  8012e4:	57                   	push   %edi
  8012e5:	56                   	push   %esi
  8012e6:	53                   	push   %ebx
  8012e7:	83 ec 3c             	sub    $0x3c,%esp
  sock = get_socket(s);
  8012ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8012ed:	e8 ba f4 ff ff       	call   8007ac <get_socket>
  if (!sock)
  8012f2:	85 c0                	test   %eax,%eax
  8012f4:	0f 84 22 02 00 00    	je     80151c <lwip_recvfrom+0x23b>
  8012fa:	89 c7                	mov    %eax,%edi
  u16_t               buflen, copylen, off = 0;
  8012fc:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801302:	8b 45 14             	mov    0x14(%ebp),%eax
  801305:	83 e0 08             	and    $0x8,%eax
  801308:	89 45 b8             	mov    %eax,-0x48(%ebp)
  80130b:	e9 a7 00 00 00       	jmp    8013b7 <lwip_recvfrom+0xd6>
  801310:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801314:	75 06                	jne    80131c <lwip_recvfrom+0x3b>
  801316:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  80131a:	74 07                	je     801323 <lwip_recvfrom+0x42>
  80131c:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801321:	74 56                	je     801379 <lwip_recvfrom+0x98>
      sock->lastdata = buf = netconn_recv(sock->conn);
  801323:	83 ec 0c             	sub    $0xc,%esp
  801326:	ff 37                	pushl  (%edi)
  801328:	e8 6d 9c 00 00       	call   80af9a <netconn_recv>
  80132d:	89 c6                	mov    %eax,%esi
  80132f:	89 47 04             	mov    %eax,0x4(%edi)
      if (!buf) {
  801332:	83 c4 10             	add    $0x10,%esp
  801335:	85 c0                	test   %eax,%eax
  801337:	0f 85 85 00 00 00    	jne    8013c2 <lwip_recvfrom+0xe1>
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80133d:	8b 17                	mov    (%edi),%edx
  80133f:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  801343:	74 0b                	je     801350 <lwip_recvfrom+0x6f>
  801345:	b8 6e 00 00 00       	mov    $0x6e,%eax
  80134a:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80134e:	74 17                	je     801367 <lwip_recvfrom+0x86>
  801350:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  801354:	f7 da                	neg    %edx
  801356:	b8 05 00 00 00       	mov    $0x5,%eax
  80135b:	83 fa 0e             	cmp    $0xe,%edx
  80135e:	77 07                	ja     801367 <lwip_recvfrom+0x86>
  801360:	8b 04 95 60 16 81 00 	mov    0x811660(,%edx,4),%eax
  801367:	89 47 10             	mov    %eax,0x10(%edi)
  80136a:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
        return 0;
  80136f:	b8 00 00 00 00       	mov    $0x0,%eax
  801374:	e9 0b 01 00 00       	jmp    801484 <lwip_recvfrom+0x1a3>
        sock_set_errno(sock, EWOULDBLOCK);
  801379:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801380:	c7 05 e0 b1 b3 00 0b 	movl   $0xb,0xb3b1e0
  801387:	00 00 00 
        return -1;
  80138a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80138f:	e9 f0 00 00 00       	jmp    801484 <lwip_recvfrom+0x1a3>
        sock->lastdata = NULL;
  801394:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  80139b:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        netbuf_delete(buf);
  8013a1:	83 ec 0c             	sub    $0xc,%esp
  8013a4:	56                   	push   %esi
  8013a5:	e8 47 11 00 00       	call   8024f1 <netbuf_delete>
  8013aa:	83 c4 10             	add    $0x10,%esp
  } while (!done);
  8013ad:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  8013b1:	0f 85 ac 00 00 00    	jne    801463 <lwip_recvfrom+0x182>
    if (sock->lastdata) {
  8013b7:	8b 77 04             	mov    0x4(%edi),%esi
  8013ba:	85 f6                	test   %esi,%esi
  8013bc:	0f 84 4e ff ff ff    	je     801310 <lwip_recvfrom+0x2f>
    buflen = netbuf_len(buf);
  8013c2:	8b 16                	mov    (%esi),%edx
  8013c4:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
    buflen -= sock->lastoffset;
  8013c8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8013cc:	89 cb                	mov    %ecx,%ebx
  8013ce:	29 c3                	sub    %eax,%ebx
    if (len > buflen) {
  8013d0:	0f b7 db             	movzwl %bx,%ebx
  8013d3:	89 5d bc             	mov    %ebx,-0x44(%ebp)
      copylen = len;
  8013d6:	29 c1                	sub    %eax,%ecx
  8013d8:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8013db:	66 0f 4d 4d 10       	cmovge 0x10(%ebp),%cx
  8013e0:	89 cb                	mov    %ecx,%ebx
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8013e2:	0f b7 c9             	movzwl %cx,%ecx
  8013e5:	0f b7 c0             	movzwl %ax,%eax
  8013e8:	50                   	push   %eax
  8013e9:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8013ec:	51                   	push   %ecx
  8013ed:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8013f1:	03 45 0c             	add    0xc(%ebp),%eax
  8013f4:	50                   	push   %eax
  8013f5:	52                   	push   %edx
  8013f6:	e8 0b 3c 00 00       	call   805006 <pbuf_copy_partial>
    off += copylen;
  8013fb:	66 01 5d c4          	add    %bx,-0x3c(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8013ff:	83 c4 04             	add    $0x4,%esp
  801402:	ff 37                	pushl  (%edi)
  801404:	e8 41 99 00 00       	call   80ad4a <netconn_type>
  801409:	83 c4 10             	add    $0x10,%esp
      done = 1;
  80140c:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801410:	83 f8 10             	cmp    $0x10,%eax
  801413:	75 23                	jne    801438 <lwip_recvfrom+0x157>
      len -= copylen;
  801415:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  801418:	29 4d 10             	sub    %ecx,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  80141b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80141f:	7e 17                	jle    801438 <lwip_recvfrom+0x157>
  801421:	8b 06                	mov    (%esi),%eax
  801423:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
  801427:	83 e0 01             	and    $0x1,%eax
  80142a:	88 45 c7             	mov    %al,-0x39(%ebp)
  80142d:	75 09                	jne    801438 <lwip_recvfrom+0x157>
  80142f:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801434:	0f 94 45 c7          	sete   -0x39(%ebp)
    if ((flags & MSG_PEEK)==0) {
  801438:	f6 45 14 01          	testb  $0x1,0x14(%ebp)
  80143c:	75 25                	jne    801463 <lwip_recvfrom+0x182>
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80143e:	8b 07                	mov    (%edi),%eax
  801440:	83 38 10             	cmpl   $0x10,(%eax)
  801443:	0f 85 4b ff ff ff    	jne    801394 <lwip_recvfrom+0xb3>
  801449:	8b 45 bc             	mov    -0x44(%ebp),%eax
  80144c:	2b 45 c0             	sub    -0x40(%ebp),%eax
  80144f:	85 c0                	test   %eax,%eax
  801451:	0f 8e 3d ff ff ff    	jle    801394 <lwip_recvfrom+0xb3>
        sock->lastdata = buf;
  801457:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  80145a:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80145e:	e9 4a ff ff ff       	jmp    8013ad <lwip_recvfrom+0xcc>
  if (from && fromlen) {
  801463:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801467:	74 06                	je     80146f <lwip_recvfrom+0x18e>
  801469:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80146d:	75 1d                	jne    80148c <lwip_recvfrom+0x1ab>
  sock_set_errno(sock, 0);
  80146f:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  801476:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80147d:	00 00 00 
  return off;
  801480:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
}
  801484:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801487:	5b                   	pop    %ebx
  801488:	5e                   	pop    %esi
  801489:	5f                   	pop    %edi
  80148a:	5d                   	pop    %ebp
  80148b:	c3                   	ret    
    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80148c:	83 ec 0c             	sub    $0xc,%esp
  80148f:	ff 37                	pushl  (%edi)
  801491:	e8 b4 98 00 00       	call   80ad4a <netconn_type>
  801496:	83 c4 10             	add    $0x10,%esp
  801499:	83 f8 10             	cmp    $0x10,%eax
  80149c:	74 65                	je     801503 <lwip_recvfrom+0x222>
      addr = netbuf_fromaddr(buf);
  80149e:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  8014a1:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8014a5:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    memset(&sin, 0, sizeof(sin));
  8014a9:	83 ec 04             	sub    $0x4,%esp
  8014ac:	6a 10                	push   $0x10
  8014ae:	6a 00                	push   $0x0
  8014b0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014b3:	50                   	push   %eax
  8014b4:	e8 7b db 00 00       	call   80f034 <memset>
    sin.sin_len = sizeof(sin);
  8014b9:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8014bd:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8014c1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8014c5:	89 04 24             	mov    %eax,(%esp)
  8014c8:	e8 97 62 00 00       	call   807764 <htons>
  8014cd:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8014d1:	8b 03                	mov    (%ebx),%eax
  8014d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (*fromlen > sizeof(sin))
  8014d6:	83 c4 10             	add    $0x10,%esp
  8014d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014dc:	83 38 10             	cmpl   $0x10,(%eax)
  8014df:	76 06                	jbe    8014e7 <lwip_recvfrom+0x206>
      *fromlen = sizeof(sin);
  8014e1:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
    SMEMCPY(from, &sin, *fromlen);
  8014e7:	83 ec 04             	sub    $0x4,%esp
  8014ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8014ed:	ff 30                	pushl  (%eax)
  8014ef:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8014f2:	50                   	push   %eax
  8014f3:	ff 75 18             	pushl  0x18(%ebp)
  8014f6:	e8 e3 db 00 00       	call   80f0de <memcpy>
  8014fb:	83 c4 10             	add    $0x10,%esp
  8014fe:	e9 6c ff ff ff       	jmp    80146f <lwip_recvfrom+0x18e>
      netconn_getaddr(sock->conn, addr, &port, 0);
  801503:	6a 00                	push   $0x0
  801505:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801508:	50                   	push   %eax
  801509:	8d 45 d8             	lea    -0x28(%ebp),%eax
  80150c:	50                   	push   %eax
  80150d:	ff 37                	pushl  (%edi)
  80150f:	e8 5e 98 00 00       	call   80ad72 <netconn_getaddr>
  801514:	83 c4 10             	add    $0x10,%esp
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801517:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  80151a:	eb 8d                	jmp    8014a9 <lwip_recvfrom+0x1c8>
    return -1;
  80151c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801521:	e9 5e ff ff ff       	jmp    801484 <lwip_recvfrom+0x1a3>

00801526 <lwip_read>:
{
  801526:	55                   	push   %ebp
  801527:	89 e5                	mov    %esp,%ebp
  801529:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  80152c:	6a 00                	push   $0x0
  80152e:	6a 00                	push   $0x0
  801530:	6a 00                	push   $0x0
  801532:	ff 75 10             	pushl  0x10(%ebp)
  801535:	ff 75 0c             	pushl  0xc(%ebp)
  801538:	ff 75 08             	pushl  0x8(%ebp)
  80153b:	e8 a1 fd ff ff       	call   8012e1 <lwip_recvfrom>
}
  801540:	c9                   	leave  
  801541:	c3                   	ret    

00801542 <lwip_recv>:
{
  801542:	55                   	push   %ebp
  801543:	89 e5                	mov    %esp,%ebp
  801545:	83 ec 10             	sub    $0x10,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  801548:	6a 00                	push   $0x0
  80154a:	6a 00                	push   $0x0
  80154c:	ff 75 14             	pushl  0x14(%ebp)
  80154f:	ff 75 10             	pushl  0x10(%ebp)
  801552:	ff 75 0c             	pushl  0xc(%ebp)
  801555:	ff 75 08             	pushl  0x8(%ebp)
  801558:	e8 84 fd ff ff       	call   8012e1 <lwip_recvfrom>
}
  80155d:	c9                   	leave  
  80155e:	c3                   	ret    

0080155f <lwip_sendto>:
{
  80155f:	55                   	push   %ebp
  801560:	89 e5                	mov    %esp,%ebp
  801562:	57                   	push   %edi
  801563:	56                   	push   %esi
  801564:	53                   	push   %ebx
  801565:	83 ec 2c             	sub    $0x2c,%esp
  801568:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80156b:	8b 7d 18             	mov    0x18(%ebp),%edi
  sock = get_socket(s);
  80156e:	8b 45 08             	mov    0x8(%ebp),%eax
  801571:	e8 36 f2 ff ff       	call   8007ac <get_socket>
  if (!sock)
  801576:	85 c0                	test   %eax,%eax
  801578:	0f 84 28 01 00 00    	je     8016a6 <lwip_sendto+0x147>
  80157e:	89 c6                	mov    %eax,%esi
  if (sock->conn->type==NETCONN_TCP) {
  801580:	8b 00                	mov    (%eax),%eax
  801582:	83 38 10             	cmpl   $0x10,(%eax)
  801585:	0f 84 be 00 00 00    	je     801649 <lwip_sendto+0xea>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80158b:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  801591:	0f 87 c8 00 00 00    	ja     80165f <lwip_sendto+0x100>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801597:	89 f8                	mov    %edi,%eax
  801599:	0b 45 1c             	or     0x1c(%ebp),%eax
  80159c:	0f 84 0b 01 00 00    	je     8016ad <lwip_sendto+0x14e>
  8015a2:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8015a6:	0f 85 ca 00 00 00    	jne    801676 <lwip_sendto+0x117>
  8015ac:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  8015b0:	0f 85 c0 00 00 00    	jne    801676 <lwip_sendto+0x117>
  buf.p = buf.ptr = NULL;
  8015b6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8015bd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8015c4:	8b 47 04             	mov    0x4(%edi),%eax
  8015c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8015ca:	83 ec 0c             	sub    $0xc,%esp
  8015cd:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8015d1:	50                   	push   %eax
  8015d2:	e8 9a 61 00 00       	call   807771 <ntohs>
    buf.addr         = &remote_addr;
  8015d7:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8015da:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  8015dd:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  8015e1:	83 c4 10             	add    $0x10,%esp
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  8015e4:	83 ec 04             	sub    $0x4,%esp
  8015e7:	0f b7 c3             	movzwl %bx,%eax
  8015ea:	50                   	push   %eax
  8015eb:	ff 75 0c             	pushl  0xc(%ebp)
  8015ee:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8015f1:	50                   	push   %eax
  8015f2:	e8 f5 0f 00 00       	call   8025ec <netbuf_ref>
  8015f7:	0f be f8             	movsbl %al,%edi
  8015fa:	83 c4 10             	add    $0x10,%esp
  8015fd:	85 ff                	test   %edi,%edi
  8015ff:	0f 84 88 00 00 00    	je     80168d <lwip_sendto+0x12e>
  if (buf.p != NULL) {
  801605:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  801608:	85 c0                	test   %eax,%eax
  80160a:	74 0c                	je     801618 <lwip_sendto+0xb9>
    pbuf_free(buf.p);
  80160c:	83 ec 0c             	sub    $0xc,%esp
  80160f:	50                   	push   %eax
  801610:	e8 75 32 00 00       	call   80488a <pbuf_free>
  801615:	83 c4 10             	add    $0x10,%esp
  sock_set_errno(sock, err_to_errno(err));
  801618:	89 fa                	mov    %edi,%edx
  80161a:	f7 da                	neg    %edx
  80161c:	b8 05 00 00 00       	mov    $0x5,%eax
  801621:	83 fa 0e             	cmp    $0xe,%edx
  801624:	77 07                	ja     80162d <lwip_sendto+0xce>
  801626:	8b 04 95 60 16 81 00 	mov    0x811660(,%edx,4),%eax
  80162d:	89 46 10             	mov    %eax,0x10(%esi)
  801630:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801635:	85 ff                	test   %edi,%edi
  801637:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80163c:	0f 45 d8             	cmovne %eax,%ebx
}
  80163f:	89 d8                	mov    %ebx,%eax
  801641:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801644:	5b                   	pop    %ebx
  801645:	5e                   	pop    %esi
  801646:	5f                   	pop    %edi
  801647:	5d                   	pop    %ebp
  801648:	c3                   	ret    
    return lwip_send(s, data, size, flags);
  801649:	ff 75 14             	pushl  0x14(%ebp)
  80164c:	53                   	push   %ebx
  80164d:	ff 75 0c             	pushl  0xc(%ebp)
  801650:	ff 75 08             	pushl  0x8(%ebp)
  801653:	e8 7c 00 00 00       	call   8016d4 <lwip_send>
  801658:	89 c3                	mov    %eax,%ebx
  80165a:	83 c4 10             	add    $0x10,%esp
  80165d:	eb e0                	jmp    80163f <lwip_sendto+0xe0>
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  80165f:	83 ec 04             	sub    $0x4,%esp
  801662:	68 3c 16 81 00       	push   $0x81163c
  801667:	68 97 02 00 00       	push   $0x297
  80166c:	68 ad 15 81 00       	push   $0x8115ad
  801671:	e8 23 d0 00 00       	call   80e699 <_panic>
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  801676:	83 ec 04             	sub    $0x4,%esp
  801679:	68 1e 16 81 00       	push   $0x81161e
  80167e:	68 9b 02 00 00       	push   $0x29b
  801683:	68 ad 15 81 00       	push   $0x8115ad
  801688:	e8 0c d0 00 00       	call   80e699 <_panic>
    err = netconn_send(sock->conn, &buf);
  80168d:	83 ec 08             	sub    $0x8,%esp
  801690:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801693:	50                   	push   %eax
  801694:	ff 36                	pushl  (%esi)
  801696:	e8 94 9a 00 00       	call   80b12f <netconn_send>
  80169b:	0f be f8             	movsbl %al,%edi
  80169e:	83 c4 10             	add    $0x10,%esp
  8016a1:	e9 5f ff ff ff       	jmp    801605 <lwip_sendto+0xa6>
    return -1;
  8016a6:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  8016ab:	eb 92                	jmp    80163f <lwip_sendto+0xe0>
  buf.p = buf.ptr = NULL;
  8016ad:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8016b4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    remote_addr.addr = 0;
  8016bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    buf.addr         = NULL;
  8016c2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  8016c9:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
  8016cf:	e9 10 ff ff ff       	jmp    8015e4 <lwip_sendto+0x85>

008016d4 <lwip_send>:
{
  8016d4:	55                   	push   %ebp
  8016d5:	89 e5                	mov    %esp,%ebp
  8016d7:	57                   	push   %edi
  8016d8:	56                   	push   %esi
  8016d9:	53                   	push   %ebx
  8016da:	83 ec 0c             	sub    $0xc,%esp
  8016dd:	8b 7d 08             	mov    0x8(%ebp),%edi
  8016e0:	8b 5d 10             	mov    0x10(%ebp),%ebx
  sock = get_socket(s);
  8016e3:	89 f8                	mov    %edi,%eax
  8016e5:	e8 c2 f0 ff ff       	call   8007ac <get_socket>
  if (!sock)
  8016ea:	85 c0                	test   %eax,%eax
  8016ec:	74 70                	je     80175e <lwip_send+0x8a>
  8016ee:	89 c6                	mov    %eax,%esi
  if (sock->conn->type!=NETCONN_TCP) {
  8016f0:	8b 00                	mov    (%eax),%eax
  8016f2:	83 38 10             	cmpl   $0x10,(%eax)
  8016f5:	74 1f                	je     801716 <lwip_send+0x42>
    return lwip_sendto(s, data, size, flags, NULL, 0);
  8016f7:	83 ec 08             	sub    $0x8,%esp
  8016fa:	6a 00                	push   $0x0
  8016fc:	6a 00                	push   $0x0
  8016fe:	ff 75 14             	pushl  0x14(%ebp)
  801701:	53                   	push   %ebx
  801702:	ff 75 0c             	pushl  0xc(%ebp)
  801705:	57                   	push   %edi
  801706:	e8 54 fe ff ff       	call   80155f <lwip_sendto>
  80170b:	83 c4 20             	add    $0x20,%esp
}
  80170e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801711:	5b                   	pop    %ebx
  801712:	5e                   	pop    %esi
  801713:	5f                   	pop    %edi
  801714:	5d                   	pop    %ebp
  801715:	c3                   	ret    
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801716:	8b 55 14             	mov    0x14(%ebp),%edx
  801719:	c1 ea 03             	shr    $0x3,%edx
  80171c:	83 e2 02             	and    $0x2,%edx
  80171f:	83 ca 01             	or     $0x1,%edx
  801722:	0f b6 d2             	movzbl %dl,%edx
  801725:	52                   	push   %edx
  801726:	53                   	push   %ebx
  801727:	ff 75 0c             	pushl  0xc(%ebp)
  80172a:	50                   	push   %eax
  80172b:	e8 7b 9a 00 00       	call   80b1ab <netconn_write>
  sock_set_errno(sock, err_to_errno(err));
  801730:	0f be d0             	movsbl %al,%edx
  801733:	f7 da                	neg    %edx
  801735:	83 c4 10             	add    $0x10,%esp
  801738:	b9 05 00 00 00       	mov    $0x5,%ecx
  80173d:	83 fa 0e             	cmp    $0xe,%edx
  801740:	77 07                	ja     801749 <lwip_send+0x75>
  801742:	8b 0c 95 60 16 81 00 	mov    0x811660(,%edx,4),%ecx
  801749:	89 4e 10             	mov    %ecx,0x10(%esi)
  80174c:	89 0d e0 b1 b3 00    	mov    %ecx,0xb3b1e0
  return (err==ERR_OK?size:-1);
  801752:	84 c0                	test   %al,%al
  801754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801759:	0f 44 c3             	cmove  %ebx,%eax
  80175c:	eb b0                	jmp    80170e <lwip_send+0x3a>
    return -1;
  80175e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801763:	eb a9                	jmp    80170e <lwip_send+0x3a>

00801765 <lwip_socket>:
{
  801765:	55                   	push   %ebp
  801766:	89 e5                	mov    %esp,%ebp
  801768:	56                   	push   %esi
  801769:	53                   	push   %ebx
  80176a:	8b 45 0c             	mov    0xc(%ebp),%eax
  switch (type) {
  80176d:	83 f8 02             	cmp    $0x2,%eax
  801770:	74 5c                	je     8017ce <lwip_socket+0x69>
  801772:	83 f8 03             	cmp    $0x3,%eax
  801775:	74 16                	je     80178d <lwip_socket+0x28>
  801777:	83 f8 01             	cmp    $0x1,%eax
  80177a:	74 79                	je     8017f5 <lwip_socket+0x90>
    set_errno(EINVAL);
  80177c:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801783:	00 00 00 
    return -1;
  801786:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80178b:	eb 38                	jmp    8017c5 <lwip_socket+0x60>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  80178d:	83 ec 04             	sub    $0x4,%esp
  801790:	68 9a 09 80 00       	push   $0x80099a
  801795:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  801799:	50                   	push   %eax
  80179a:	6a 40                	push   $0x40
  80179c:	e8 8e 94 00 00       	call   80ac2f <netconn_new_with_proto_and_callback>
  8017a1:	89 c6                	mov    %eax,%esi
    break;
  8017a3:	83 c4 10             	add    $0x10,%esp
  if (!conn) {
  8017a6:	85 f6                	test   %esi,%esi
  8017a8:	74 63                	je     80180d <lwip_socket+0xa8>
  i = alloc_socket(conn);
  8017aa:	89 f0                	mov    %esi,%eax
  8017ac:	e8 93 f3 ff ff       	call   800b44 <alloc_socket>
  8017b1:	89 c3                	mov    %eax,%ebx
  if (i == -1) {
  8017b3:	83 f8 ff             	cmp    $0xffffffff,%eax
  8017b6:	74 66                	je     80181e <lwip_socket+0xb9>
  conn->socket = i;
  8017b8:	89 46 1c             	mov    %eax,0x1c(%esi)
  set_errno(0);
  8017bb:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  8017c2:	00 00 00 
}
  8017c5:	89 d8                	mov    %ebx,%eax
  8017c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8017ca:	5b                   	pop    %ebx
  8017cb:	5e                   	pop    %esi
  8017cc:	5d                   	pop    %ebp
  8017cd:	c3                   	ret    
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8017ce:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  8017d5:	0f 94 c0             	sete   %al
  8017d8:	0f b6 c0             	movzbl %al,%eax
  8017db:	83 c0 20             	add    $0x20,%eax
  8017de:	83 ec 04             	sub    $0x4,%esp
  8017e1:	68 9a 09 80 00       	push   $0x80099a
  8017e6:	6a 00                	push   $0x0
  8017e8:	50                   	push   %eax
  8017e9:	e8 41 94 00 00       	call   80ac2f <netconn_new_with_proto_and_callback>
  8017ee:	89 c6                	mov    %eax,%esi
    break;
  8017f0:	83 c4 10             	add    $0x10,%esp
  8017f3:	eb b1                	jmp    8017a6 <lwip_socket+0x41>
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8017f5:	83 ec 04             	sub    $0x4,%esp
  8017f8:	68 9a 09 80 00       	push   $0x80099a
  8017fd:	6a 00                	push   $0x0
  8017ff:	6a 10                	push   $0x10
  801801:	e8 29 94 00 00       	call   80ac2f <netconn_new_with_proto_and_callback>
  801806:	89 c6                	mov    %eax,%esi
    break;
  801808:	83 c4 10             	add    $0x10,%esp
  80180b:	eb 99                	jmp    8017a6 <lwip_socket+0x41>
    set_errno(ENOBUFS);
  80180d:	c7 05 e0 b1 b3 00 69 	movl   $0x69,0xb3b1e0
  801814:	00 00 00 
    return -1;
  801817:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80181c:	eb a7                	jmp    8017c5 <lwip_socket+0x60>
    netconn_delete(conn);
  80181e:	83 ec 0c             	sub    $0xc,%esp
  801821:	56                   	push   %esi
  801822:	e8 e3 94 00 00       	call   80ad0a <netconn_delete>
    set_errno(ENFILE);
  801827:	c7 05 e0 b1 b3 00 17 	movl   $0x17,0xb3b1e0
  80182e:	00 00 00 
    return -1;
  801831:	83 c4 10             	add    $0x10,%esp
  801834:	eb 8f                	jmp    8017c5 <lwip_socket+0x60>

00801836 <lwip_write>:
{
  801836:	55                   	push   %ebp
  801837:	89 e5                	mov    %esp,%ebp
  801839:	83 ec 08             	sub    $0x8,%esp
  return lwip_send(s, data, size, 0);
  80183c:	6a 00                	push   $0x0
  80183e:	ff 75 10             	pushl  0x10(%ebp)
  801841:	ff 75 0c             	pushl  0xc(%ebp)
  801844:	ff 75 08             	pushl  0x8(%ebp)
  801847:	e8 88 fe ff ff       	call   8016d4 <lwip_send>
}
  80184c:	c9                   	leave  
  80184d:	c3                   	ret    

0080184e <lwip_select>:
{
  80184e:	55                   	push   %ebp
  80184f:	89 e5                	mov    %esp,%ebp
  801851:	57                   	push   %edi
  801852:	56                   	push   %esi
  801853:	53                   	push   %ebx
  801854:	83 ec 58             	sub    $0x58,%esp
  801857:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80185a:	8b 75 10             	mov    0x10(%ebp),%esi
  80185d:	8b 7d 14             	mov    0x14(%ebp),%edi
  select_cb.next = 0;
  801860:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801867:	89 5d c8             	mov    %ebx,-0x38(%ebp)
  select_cb.writeset = writeset;
  80186a:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  80186d:	89 7d d0             	mov    %edi,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801870:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  sys_sem_wait(selectsem);
  801877:	ff 35 40 50 81 00    	pushl  0x815040
  80187d:	e8 e6 38 00 00       	call   805168 <sys_sem_wait>
  if (readset)
  801882:	83 c4 10             	add    $0x10,%esp
  801885:	85 db                	test   %ebx,%ebx
  801887:	0f 84 0b 01 00 00    	je     801998 <lwip_select+0x14a>
    lreadset = *readset;
  80188d:	8b 03                	mov    (%ebx),%eax
  80188f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (writeset)
  801892:	85 f6                	test   %esi,%esi
  801894:	0f 84 16 01 00 00    	je     8019b0 <lwip_select+0x162>
    lwriteset = *writeset;
  80189a:	8b 06                	mov    (%esi),%eax
  80189c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (exceptset)
  80189f:	85 ff                	test   %edi,%edi
  8018a1:	0f 84 21 01 00 00    	je     8019c8 <lwip_select+0x17a>
    lexceptset = *exceptset;
  8018a7:	8b 07                	mov    (%edi),%eax
  8018a9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  8018ac:	83 ec 0c             	sub    $0xc,%esp
  8018af:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8018b2:	50                   	push   %eax
  8018b3:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  8018b6:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8018b9:	8b 45 08             	mov    0x8(%ebp),%eax
  8018bc:	e8 29 ef ff ff       	call   8007ea <lwip_selscan>
  8018c1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if (!nready) {
  8018c4:	83 c4 10             	add    $0x10,%esp
  8018c7:	85 c0                	test   %eax,%eax
  8018c9:	0f 85 a0 02 00 00    	jne    801b6f <lwip_select+0x321>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  8018cf:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8018d3:	0f 84 ac 02 00 00    	je     801b85 <lwip_select+0x337>
  8018d9:	8b 45 18             	mov    0x18(%ebp),%eax
  8018dc:	83 38 00             	cmpl   $0x0,(%eax)
  8018df:	75 0e                	jne    8018ef <lwip_select+0xa1>
  8018e1:	8b 40 04             	mov    0x4(%eax),%eax
  8018e4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  8018e7:	85 c0                	test   %eax,%eax
  8018e9:	0f 84 f1 00 00 00    	je     8019e0 <lwip_select+0x192>
    select_cb.sem = sys_sem_new(0);
  8018ef:	83 ec 0c             	sub    $0xc,%esp
  8018f2:	6a 00                	push   $0x0
  8018f4:	e8 44 85 00 00       	call   809e3d <sys_sem_new>
  8018f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  8018fc:	a1 48 50 81 00       	mov    0x815048,%eax
  801901:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801904:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801907:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  80190c:	83 c4 04             	add    $0x4,%esp
  80190f:	ff 35 40 50 81 00    	pushl  0x815040
  801915:	e8 e0 87 00 00       	call   80a0fa <sys_sem_signal>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80191a:	8b 45 18             	mov    0x18(%ebp),%eax
  80191d:	8b 40 04             	mov    0x4(%eax),%eax
  801920:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801923:	8d 88 f4 01 00 00    	lea    0x1f4(%eax),%ecx
  801929:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80192e:	89 c8                	mov    %ecx,%eax
  801930:	f7 ea                	imul   %edx
  801932:	c1 fa 06             	sar    $0x6,%edx
  801935:	c1 f9 1f             	sar    $0x1f,%ecx
  801938:	29 ca                	sub    %ecx,%edx
  80193a:	8b 45 18             	mov    0x18(%ebp),%eax
  80193d:	69 00 e8 03 00 00    	imul   $0x3e8,(%eax),%eax
      if(msectimeout == 0)
  801943:	83 c4 10             	add    $0x10,%esp
  801946:	01 d0                	add    %edx,%eax
        msectimeout = 1;
  801948:	ba 01 00 00 00       	mov    $0x1,%edx
  80194d:	0f 44 c2             	cmove  %edx,%eax
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801950:	83 ec 08             	sub    $0x8,%esp
  801953:	50                   	push   %eax
  801954:	ff 75 d8             	pushl  -0x28(%ebp)
  801957:	e8 dc 39 00 00       	call   805338 <sys_sem_wait_timeout>
  80195c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    sys_sem_wait(selectsem);
  80195f:	83 c4 04             	add    $0x4,%esp
  801962:	ff 35 40 50 81 00    	pushl  0x815040
  801968:	e8 fb 37 00 00       	call   805168 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  80196d:	a1 48 50 81 00       	mov    0x815048,%eax
  801972:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  801975:	83 c4 10             	add    $0x10,%esp
        if (p_selcb->next == &select_cb) {
  801978:	89 d1                	mov    %edx,%ecx
    if (select_cb_list == &select_cb)
  80197a:	39 d0                	cmp    %edx,%eax
  80197c:	0f 84 ba 00 00 00    	je     801a3c <lwip_select+0x1ee>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801982:	85 c0                	test   %eax,%eax
  801984:	0f 84 c1 00 00 00    	je     801a4b <lwip_select+0x1fd>
        if (p_selcb->next == &select_cb) {
  80198a:	8b 10                	mov    (%eax),%edx
  80198c:	39 ca                	cmp    %ecx,%edx
  80198e:	0f 84 b2 00 00 00    	je     801a46 <lwip_select+0x1f8>
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801994:	89 d0                	mov    %edx,%eax
  801996:	eb ea                	jmp    801982 <lwip_select+0x134>
    FD_ZERO(&lreadset);
  801998:	83 ec 04             	sub    $0x4,%esp
  80199b:	6a 04                	push   $0x4
  80199d:	6a 00                	push   $0x0
  80199f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8019a2:	50                   	push   %eax
  8019a3:	e8 8c d6 00 00       	call   80f034 <memset>
  8019a8:	83 c4 10             	add    $0x10,%esp
  8019ab:	e9 e2 fe ff ff       	jmp    801892 <lwip_select+0x44>
    FD_ZERO(&lwriteset);
  8019b0:	83 ec 04             	sub    $0x4,%esp
  8019b3:	6a 04                	push   $0x4
  8019b5:	6a 00                	push   $0x0
  8019b7:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8019ba:	50                   	push   %eax
  8019bb:	e8 74 d6 00 00       	call   80f034 <memset>
  8019c0:	83 c4 10             	add    $0x10,%esp
  8019c3:	e9 d7 fe ff ff       	jmp    80189f <lwip_select+0x51>
    FD_ZERO(&lexceptset);
  8019c8:	83 ec 04             	sub    $0x4,%esp
  8019cb:	6a 04                	push   $0x4
  8019cd:	6a 00                	push   $0x0
  8019cf:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8019d2:	50                   	push   %eax
  8019d3:	e8 5c d6 00 00       	call   80f034 <memset>
  8019d8:	83 c4 10             	add    $0x10,%esp
  8019db:	e9 cc fe ff ff       	jmp    8018ac <lwip_select+0x5e>
      sys_sem_signal(selectsem);
  8019e0:	83 ec 0c             	sub    $0xc,%esp
  8019e3:	ff 35 40 50 81 00    	pushl  0x815040
  8019e9:	e8 0c 87 00 00       	call   80a0fa <sys_sem_signal>
      if (readset)
  8019ee:	83 c4 10             	add    $0x10,%esp
  8019f1:	85 db                	test   %ebx,%ebx
  8019f3:	74 10                	je     801a05 <lwip_select+0x1b7>
        FD_ZERO(readset);
  8019f5:	83 ec 04             	sub    $0x4,%esp
  8019f8:	6a 04                	push   $0x4
  8019fa:	6a 00                	push   $0x0
  8019fc:	53                   	push   %ebx
  8019fd:	e8 32 d6 00 00       	call   80f034 <memset>
  801a02:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801a05:	85 f6                	test   %esi,%esi
  801a07:	74 10                	je     801a19 <lwip_select+0x1cb>
        FD_ZERO(writeset);
  801a09:	83 ec 04             	sub    $0x4,%esp
  801a0c:	6a 04                	push   $0x4
  801a0e:	6a 00                	push   $0x0
  801a10:	56                   	push   %esi
  801a11:	e8 1e d6 00 00       	call   80f034 <memset>
  801a16:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801a19:	85 ff                	test   %edi,%edi
  801a1b:	74 10                	je     801a2d <lwip_select+0x1df>
        FD_ZERO(exceptset);
  801a1d:	83 ec 04             	sub    $0x4,%esp
  801a20:	6a 04                	push   $0x4
  801a22:	6a 00                	push   $0x0
  801a24:	57                   	push   %edi
  801a25:	e8 0a d6 00 00       	call   80f034 <memset>
  801a2a:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801a2d:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801a34:	00 00 00 
      return 0;
  801a37:	e9 98 00 00 00       	jmp    801ad4 <lwip_select+0x286>
      select_cb_list = select_cb.next;
  801a3c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801a3f:	a3 48 50 81 00       	mov    %eax,0x815048
  801a44:	eb 05                	jmp    801a4b <lwip_select+0x1fd>
          p_selcb->next = select_cb.next;
  801a46:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801a49:	89 10                	mov    %edx,(%eax)
    sys_sem_signal(selectsem);
  801a4b:	83 ec 0c             	sub    $0xc,%esp
  801a4e:	ff 35 40 50 81 00    	pushl  0x815040
  801a54:	e8 a1 86 00 00       	call   80a0fa <sys_sem_signal>
    sys_sem_free(select_cb.sem);
  801a59:	83 c4 04             	add    $0x4,%esp
  801a5c:	ff 75 d8             	pushl  -0x28(%ebp)
  801a5f:	e8 5a 84 00 00       	call   809ebe <sys_sem_free>
    if (i == 0)  {
  801a64:	83 c4 10             	add    $0x10,%esp
  801a67:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  801a6b:	74 72                	je     801adf <lwip_select+0x291>
    if (readset)
  801a6d:	85 db                	test   %ebx,%ebx
  801a6f:	0f 84 b2 00 00 00    	je     801b27 <lwip_select+0x2d9>
      lreadset = *readset;
  801a75:	8b 03                	mov    (%ebx),%eax
  801a77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (writeset)
  801a7a:	85 f6                	test   %esi,%esi
  801a7c:	0f 84 bd 00 00 00    	je     801b3f <lwip_select+0x2f1>
      lwriteset = *writeset;
  801a82:	8b 06                	mov    (%esi),%eax
  801a84:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (exceptset)
  801a87:	85 ff                	test   %edi,%edi
  801a89:	0f 84 c8 00 00 00    	je     801b57 <lwip_select+0x309>
      lexceptset = *exceptset;
  801a8f:	8b 07                	mov    (%edi),%eax
  801a91:	89 45 dc             	mov    %eax,-0x24(%ebp)
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801a94:	83 ec 0c             	sub    $0xc,%esp
  801a97:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801a9a:	50                   	push   %eax
  801a9b:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801a9e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801aa1:	8b 45 08             	mov    0x8(%ebp),%eax
  801aa4:	e8 41 ed ff ff       	call   8007ea <lwip_selscan>
  801aa9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  801aac:	83 c4 10             	add    $0x10,%esp
  if (readset)
  801aaf:	85 db                	test   %ebx,%ebx
  801ab1:	74 05                	je     801ab8 <lwip_select+0x26a>
    *readset = lreadset;
  801ab3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ab6:	89 03                	mov    %eax,(%ebx)
  if (writeset)
  801ab8:	85 f6                	test   %esi,%esi
  801aba:	74 05                	je     801ac1 <lwip_select+0x273>
    *writeset = lwriteset;
  801abc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801abf:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801ac1:	85 ff                	test   %edi,%edi
  801ac3:	74 05                	je     801aca <lwip_select+0x27c>
    *exceptset = lexceptset;
  801ac5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801ac8:	89 07                	mov    %eax,(%edi)
  set_errno(0);
  801aca:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801ad1:	00 00 00 
}
  801ad4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  801ad7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801ada:	5b                   	pop    %ebx
  801adb:	5e                   	pop    %esi
  801adc:	5f                   	pop    %edi
  801add:	5d                   	pop    %ebp
  801ade:	c3                   	ret    
      if (readset)
  801adf:	85 db                	test   %ebx,%ebx
  801ae1:	74 10                	je     801af3 <lwip_select+0x2a5>
        FD_ZERO(readset);
  801ae3:	83 ec 04             	sub    $0x4,%esp
  801ae6:	6a 04                	push   $0x4
  801ae8:	6a 00                	push   $0x0
  801aea:	53                   	push   %ebx
  801aeb:	e8 44 d5 00 00       	call   80f034 <memset>
  801af0:	83 c4 10             	add    $0x10,%esp
      if (writeset)
  801af3:	85 f6                	test   %esi,%esi
  801af5:	74 10                	je     801b07 <lwip_select+0x2b9>
        FD_ZERO(writeset);
  801af7:	83 ec 04             	sub    $0x4,%esp
  801afa:	6a 04                	push   $0x4
  801afc:	6a 00                	push   $0x0
  801afe:	56                   	push   %esi
  801aff:	e8 30 d5 00 00       	call   80f034 <memset>
  801b04:	83 c4 10             	add    $0x10,%esp
      if (exceptset)
  801b07:	85 ff                	test   %edi,%edi
  801b09:	74 10                	je     801b1b <lwip_select+0x2cd>
        FD_ZERO(exceptset);
  801b0b:	83 ec 04             	sub    $0x4,%esp
  801b0e:	6a 04                	push   $0x4
  801b10:	6a 00                	push   $0x0
  801b12:	57                   	push   %edi
  801b13:	e8 1c d5 00 00       	call   80f034 <memset>
  801b18:	83 c4 10             	add    $0x10,%esp
      set_errno(0);
  801b1b:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801b22:	00 00 00 
      return 0;
  801b25:	eb ad                	jmp    801ad4 <lwip_select+0x286>
      FD_ZERO(&lreadset);
  801b27:	83 ec 04             	sub    $0x4,%esp
  801b2a:	6a 04                	push   $0x4
  801b2c:	6a 00                	push   $0x0
  801b2e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801b31:	50                   	push   %eax
  801b32:	e8 fd d4 00 00       	call   80f034 <memset>
  801b37:	83 c4 10             	add    $0x10,%esp
  801b3a:	e9 3b ff ff ff       	jmp    801a7a <lwip_select+0x22c>
      FD_ZERO(&lwriteset);
  801b3f:	83 ec 04             	sub    $0x4,%esp
  801b42:	6a 04                	push   $0x4
  801b44:	6a 00                	push   $0x0
  801b46:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b49:	50                   	push   %eax
  801b4a:	e8 e5 d4 00 00       	call   80f034 <memset>
  801b4f:	83 c4 10             	add    $0x10,%esp
  801b52:	e9 30 ff ff ff       	jmp    801a87 <lwip_select+0x239>
      FD_ZERO(&lexceptset);
  801b57:	83 ec 04             	sub    $0x4,%esp
  801b5a:	6a 04                	push   $0x4
  801b5c:	6a 00                	push   $0x0
  801b5e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b61:	50                   	push   %eax
  801b62:	e8 cd d4 00 00       	call   80f034 <memset>
  801b67:	83 c4 10             	add    $0x10,%esp
  801b6a:	e9 25 ff ff ff       	jmp    801a94 <lwip_select+0x246>
    sys_sem_signal(selectsem);
  801b6f:	83 ec 0c             	sub    $0xc,%esp
  801b72:	ff 35 40 50 81 00    	pushl  0x815040
  801b78:	e8 7d 85 00 00       	call   80a0fa <sys_sem_signal>
  801b7d:	83 c4 10             	add    $0x10,%esp
  801b80:	e9 2a ff ff ff       	jmp    801aaf <lwip_select+0x261>
    select_cb.sem = sys_sem_new(0);
  801b85:	83 ec 0c             	sub    $0xc,%esp
  801b88:	6a 00                	push   $0x0
  801b8a:	e8 ae 82 00 00       	call   809e3d <sys_sem_new>
  801b8f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    select_cb.next = select_cb_list;
  801b92:	a1 48 50 81 00       	mov    0x815048,%eax
  801b97:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801b9a:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801b9d:	a3 48 50 81 00       	mov    %eax,0x815048
    sys_sem_signal(selectsem);
  801ba2:	83 c4 04             	add    $0x4,%esp
  801ba5:	ff 35 40 50 81 00    	pushl  0x815040
  801bab:	e8 4a 85 00 00       	call   80a0fa <sys_sem_signal>
  801bb0:	83 c4 10             	add    $0x10,%esp
      msectimeout = 0;
  801bb3:	b8 00 00 00 00       	mov    $0x0,%eax
  801bb8:	e9 93 fd ff ff       	jmp    801950 <lwip_select+0x102>

00801bbd <lwip_shutdown>:
{
  801bbd:	55                   	push   %ebp
  801bbe:	89 e5                	mov    %esp,%ebp
  801bc0:	83 ec 14             	sub    $0x14,%esp
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801bc3:	ff 75 08             	pushl  0x8(%ebp)
  801bc6:	e8 4d f5 ff ff       	call   801118 <lwip_close>
}
  801bcb:	c9                   	leave  
  801bcc:	c3                   	ret    

00801bcd <lwip_getpeername>:
{
  801bcd:	55                   	push   %ebp
  801bce:	89 e5                	mov    %esp,%ebp
  801bd0:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801bd3:	6a 00                	push   $0x0
  801bd5:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bd8:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bdb:	8b 45 08             	mov    0x8(%ebp),%eax
  801bde:	e8 0c ed ff ff       	call   8008ef <lwip_getaddrname>
}
  801be3:	c9                   	leave  
  801be4:	c3                   	ret    

00801be5 <lwip_getsockname>:
{
  801be5:	55                   	push   %ebp
  801be6:	89 e5                	mov    %esp,%ebp
  801be8:	83 ec 14             	sub    $0x14,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801beb:	6a 01                	push   $0x1
  801bed:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801bf0:	8b 55 0c             	mov    0xc(%ebp),%edx
  801bf3:	8b 45 08             	mov    0x8(%ebp),%eax
  801bf6:	e8 f4 ec ff ff       	call   8008ef <lwip_getaddrname>
}
  801bfb:	c9                   	leave  
  801bfc:	c3                   	ret    

00801bfd <lwip_getsockopt>:
{
  801bfd:	55                   	push   %ebp
  801bfe:	89 e5                	mov    %esp,%ebp
  801c00:	57                   	push   %edi
  801c01:	56                   	push   %esi
  801c02:	53                   	push   %ebx
  801c03:	83 ec 2c             	sub    $0x2c,%esp
  801c06:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801c09:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801c0c:	8b 45 08             	mov    0x8(%ebp),%eax
  801c0f:	e8 98 eb ff ff       	call   8007ac <get_socket>
  if (!sock)
  801c14:	85 c0                	test   %eax,%eax
  801c16:	0f 84 af 01 00 00    	je     801dcb <lwip_getsockopt+0x1ce>
  801c1c:	89 c6                	mov    %eax,%esi
  if ((NULL == optval) || (NULL == optlen)) {
  801c1e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801c22:	74 39                	je     801c5d <lwip_getsockopt+0x60>
  801c24:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801c28:	74 33                	je     801c5d <lwip_getsockopt+0x60>
  switch (level) {
  801c2a:	83 fb 06             	cmp    $0x6,%ebx
  801c2d:	0f 84 36 01 00 00    	je     801d69 <lwip_getsockopt+0x16c>
  801c33:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801c39:	74 3d                	je     801c78 <lwip_getsockopt+0x7b>
      err = ENOPROTOOPT;
  801c3b:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801c40:	85 db                	test   %ebx,%ebx
  801c42:	0f 84 a9 00 00 00    	je     801cf1 <lwip_getsockopt+0xf4>
    sock_set_errno(sock, err);
  801c48:	0f be c0             	movsbl %al,%eax
  801c4b:	89 46 10             	mov    %eax,0x10(%esi)
  801c4e:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801c53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c58:	e9 04 01 00 00       	jmp    801d61 <lwip_getsockopt+0x164>
    sock_set_errno(sock, EFAULT);
  801c5d:	c7 46 10 0e 00 00 00 	movl   $0xe,0x10(%esi)
  801c64:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801c6b:	00 00 00 
    return -1;
  801c6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801c73:	e9 e9 00 00 00       	jmp    801d61 <lwip_getsockopt+0x164>
  801c78:	83 ff 20             	cmp    $0x20,%edi
  801c7b:	74 62                	je     801cdf <lwip_getsockopt+0xe2>
  801c7d:	7e 4d                	jle    801ccc <lwip_getsockopt+0xcf>
  801c7f:	81 ff 07 10 00 00    	cmp    $0x1007,%edi
  801c85:	0f 8c 04 01 00 00    	jl     801d8f <lwip_getsockopt+0x192>
  801c8b:	81 ff 08 10 00 00    	cmp    $0x1008,%edi
  801c91:	7e 4c                	jle    801cdf <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801c93:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801c98:	81 ff 0a 10 00 00    	cmp    $0x100a,%edi
  801c9e:	75 a8                	jne    801c48 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801ca0:	8b 45 18             	mov    0x18(%ebp),%eax
  801ca3:	83 38 04             	cmpl   $0x4,(%eax)
  801ca6:	19 c0                	sbb    %eax,%eax
  801ca8:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801cab:	8b 16                	mov    (%esi),%edx
  801cad:	83 3a 20             	cmpl   $0x20,(%edx)
  801cb0:	0f 85 e3 00 00 00    	jne    801d99 <lwip_getsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801cb6:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801cb9:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801cbd:	0f 85 e0 00 00 00    	jne    801da3 <lwip_getsockopt+0x1a6>
  if (err != ERR_OK) {
  801cc3:	84 c0                	test   %al,%al
  801cc5:	74 42                	je     801d09 <lwip_getsockopt+0x10c>
  801cc7:	e9 7c ff ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
  801ccc:	83 ff 02             	cmp    $0x2,%edi
  801ccf:	74 0e                	je     801cdf <lwip_getsockopt+0xe2>
      err = ENOPROTOOPT;
  801cd1:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801cd6:	83 ff 08             	cmp    $0x8,%edi
  801cd9:	0f 85 69 ff ff ff    	jne    801c48 <lwip_getsockopt+0x4b>
      if (*optlen < sizeof(int)) {
  801cdf:	8b 45 18             	mov    0x18(%ebp),%eax
  801ce2:	83 38 03             	cmpl   $0x3,(%eax)
  801ce5:	77 22                	ja     801d09 <lwip_getsockopt+0x10c>
        err = EINVAL;
  801ce7:	b8 16 00 00 00       	mov    $0x16,%eax
  801cec:	e9 57 ff ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
  801cf1:	8d 47 ff             	lea    -0x1(%edi),%eax
  801cf4:	83 f8 01             	cmp    $0x1,%eax
  801cf7:	0f 87 b0 00 00 00    	ja     801dad <lwip_getsockopt+0x1b0>
      if (*optlen < sizeof(int)) {
  801cfd:	8b 45 18             	mov    0x18(%ebp),%eax
  801d00:	83 38 03             	cmpl   $0x3,(%eax)
  801d03:	0f 86 ae 00 00 00    	jbe    801db7 <lwip_getsockopt+0x1ba>
  data.sock = sock;
  801d09:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801d0c:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801d0f:	89 7d d8             	mov    %edi,-0x28(%ebp)
  data.optval = optval;
  801d12:	8b 45 14             	mov    0x14(%ebp),%eax
  801d15:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801d18:	8b 45 18             	mov    0x18(%ebp),%eax
  801d1b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801d1e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801d22:	83 ec 04             	sub    $0x4,%esp
  801d25:	6a 01                	push   $0x1
  801d27:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801d2a:	50                   	push   %eax
  801d2b:	68 ec 0b 80 00       	push   $0x800bec
  801d30:	e8 dc 05 00 00       	call   802311 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801d35:	83 c4 08             	add    $0x8,%esp
  801d38:	6a 00                	push   $0x0
  801d3a:	8b 06                	mov    (%esi),%eax
  801d3c:	ff 70 10             	pushl  0x10(%eax)
  801d3f:	e8 26 84 00 00       	call   80a16a <sys_arch_sem_wait>
  err = data.err;
  801d44:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801d48:	0f be d0             	movsbl %al,%edx
  801d4b:	89 56 10             	mov    %edx,0x10(%esi)
  801d4e:	89 15 e0 b1 b3 00    	mov    %edx,0xb3b1e0
  return err ? -1 : 0;
  801d54:	83 c4 10             	add    $0x10,%esp
  801d57:	84 c0                	test   %al,%al
  801d59:	0f 95 c0             	setne  %al
  801d5c:	0f b6 c0             	movzbl %al,%eax
  801d5f:	f7 d8                	neg    %eax
}
  801d61:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801d64:	5b                   	pop    %ebx
  801d65:	5e                   	pop    %esi
  801d66:	5f                   	pop    %edi
  801d67:	5d                   	pop    %ebp
  801d68:	c3                   	ret    
    if (*optlen < sizeof(int)) {
  801d69:	8b 45 18             	mov    0x18(%ebp),%eax
  801d6c:	83 38 03             	cmpl   $0x3,(%eax)
  801d6f:	76 50                	jbe    801dc1 <lwip_getsockopt+0x1c4>
    if (sock->conn->type != NETCONN_TCP)
  801d71:	8b 16                	mov    (%esi),%edx
      return 0;
  801d73:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801d78:	83 3a 10             	cmpl   $0x10,(%edx)
  801d7b:	75 e4                	jne    801d61 <lwip_getsockopt+0x164>
  801d7d:	8d 47 ff             	lea    -0x1(%edi),%eax
  801d80:	83 f8 01             	cmp    $0x1,%eax
  801d83:	76 84                	jbe    801d09 <lwip_getsockopt+0x10c>
      err = ENOPROTOOPT;
  801d85:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d8a:	e9 b9 fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801d8f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801d94:	e9 af fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
        err = EAFNOSUPPORT;
  801d99:	b8 61 00 00 00       	mov    $0x61,%eax
  801d9e:	e9 a5 fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
  801da3:	b8 61 00 00 00       	mov    $0x61,%eax
  801da8:	e9 9b fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
      err = ENOPROTOOPT;
  801dad:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801db2:	e9 91 fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
        err = EINVAL;
  801db7:	b8 16 00 00 00       	mov    $0x16,%eax
  801dbc:	e9 87 fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
      err = EINVAL;
  801dc1:	b8 16 00 00 00       	mov    $0x16,%eax
  801dc6:	e9 7d fe ff ff       	jmp    801c48 <lwip_getsockopt+0x4b>
    return -1;
  801dcb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801dd0:	eb 8f                	jmp    801d61 <lwip_getsockopt+0x164>

00801dd2 <lwip_setsockopt>:
{
  801dd2:	55                   	push   %ebp
  801dd3:	89 e5                	mov    %esp,%ebp
  801dd5:	57                   	push   %edi
  801dd6:	56                   	push   %esi
  801dd7:	53                   	push   %ebx
  801dd8:	83 ec 2c             	sub    $0x2c,%esp
  801ddb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801dde:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  801de1:	8b 45 08             	mov    0x8(%ebp),%eax
  801de4:	e8 c3 e9 ff ff       	call   8007ac <get_socket>
  if (!sock)
  801de9:	85 c0                	test   %eax,%eax
  801deb:	0f 84 69 01 00 00    	je     801f5a <lwip_setsockopt+0x188>
  801df1:	89 c6                	mov    %eax,%esi
  if (NULL == optval) {
  801df3:	85 ff                	test   %edi,%edi
  801df5:	74 2c                	je     801e23 <lwip_setsockopt+0x51>
  switch (level) {
  801df7:	83 fb 06             	cmp    $0x6,%ebx
  801dfa:	0f 84 01 01 00 00    	je     801f01 <lwip_setsockopt+0x12f>
  801e00:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
  801e06:	74 36                	je     801e3e <lwip_setsockopt+0x6c>
    err = ENOPROTOOPT;
  801e08:	b8 5c 00 00 00       	mov    $0x5c,%eax
  switch (level) {
  801e0d:	85 db                	test   %ebx,%ebx
  801e0f:	74 7b                	je     801e8c <lwip_setsockopt+0xba>
    sock_set_errno(sock, err);
  801e11:	89 46 10             	mov    %eax,0x10(%esi)
  801e14:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
    return -1;
  801e19:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e1e:	e9 d6 00 00 00       	jmp    801ef9 <lwip_setsockopt+0x127>
    sock_set_errno(sock, EFAULT);
  801e23:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  801e2a:	c7 05 e0 b1 b3 00 0e 	movl   $0xe,0xb3b1e0
  801e31:	00 00 00 
    return -1;
  801e34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801e39:	e9 bb 00 00 00       	jmp    801ef9 <lwip_setsockopt+0x127>
  801e3e:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801e42:	74 14                	je     801e58 <lwip_setsockopt+0x86>
  801e44:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801e4b:	74 18                	je     801e65 <lwip_setsockopt+0x93>
      err = ENOPROTOOPT;
  801e4d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801e52:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801e56:	75 b9                	jne    801e11 <lwip_setsockopt+0x3f>
      if (optlen < sizeof(int)) {
  801e58:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e5c:	77 47                	ja     801ea5 <lwip_setsockopt+0xd3>
        err = EINVAL;
  801e5e:	b8 16 00 00 00       	mov    $0x16,%eax
  801e63:	eb ac                	jmp    801e11 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801e65:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  801e69:	19 c0                	sbb    %eax,%eax
  801e6b:	83 e0 16             	and    $0x16,%eax
      if ((sock->conn->type != NETCONN_UDP) ||
  801e6e:	8b 16                	mov    (%esi),%edx
  801e70:	83 3a 20             	cmpl   $0x20,(%edx)
  801e73:	0f 85 af 00 00 00    	jne    801f28 <lwip_setsockopt+0x156>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801e79:	8b 52 08             	mov    0x8(%edx),%edx
      if ((sock->conn->type != NETCONN_UDP) ||
  801e7c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801e80:	0f 85 ac 00 00 00    	jne    801f32 <lwip_setsockopt+0x160>
  if (err != ERR_OK) {
  801e86:	85 c0                	test   %eax,%eax
  801e88:	74 1b                	je     801ea5 <lwip_setsockopt+0xd3>
  801e8a:	eb 85                	jmp    801e11 <lwip_setsockopt+0x3f>
  801e8c:	8b 45 10             	mov    0x10(%ebp),%eax
  801e8f:	83 e8 01             	sub    $0x1,%eax
  801e92:	83 f8 01             	cmp    $0x1,%eax
  801e95:	0f 87 a1 00 00 00    	ja     801f3c <lwip_setsockopt+0x16a>
      if (optlen < sizeof(int)) {
  801e9b:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801e9f:	0f 86 a1 00 00 00    	jbe    801f46 <lwip_setsockopt+0x174>
  data.sock = sock;
  801ea5:	89 75 cc             	mov    %esi,-0x34(%ebp)
  data.level = level;
  801ea8:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  data.optname = optname;
  801eab:	8b 45 10             	mov    0x10(%ebp),%eax
  801eae:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  801eb1:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  801eb4:	8d 45 18             	lea    0x18(%ebp),%eax
  801eb7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  801eba:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  801ebe:	83 ec 04             	sub    $0x4,%esp
  801ec1:	6a 01                	push   $0x1
  801ec3:	8d 45 cc             	lea    -0x34(%ebp),%eax
  801ec6:	50                   	push   %eax
  801ec7:	68 7b 0d 80 00       	push   $0x800d7b
  801ecc:	e8 40 04 00 00       	call   802311 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  801ed1:	83 c4 08             	add    $0x8,%esp
  801ed4:	6a 00                	push   $0x0
  801ed6:	8b 06                	mov    (%esi),%eax
  801ed8:	ff 70 10             	pushl  0x10(%eax)
  801edb:	e8 8a 82 00 00       	call   80a16a <sys_arch_sem_wait>
  err = data.err;
  801ee0:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
  sock_set_errno(sock, err);
  801ee4:	89 46 10             	mov    %eax,0x10(%esi)
  801ee7:	a3 e0 b1 b3 00       	mov    %eax,0xb3b1e0
  return err ? -1 : 0;
  801eec:	83 c4 10             	add    $0x10,%esp
  801eef:	85 c0                	test   %eax,%eax
  801ef1:	0f 95 c0             	setne  %al
  801ef4:	0f b6 c0             	movzbl %al,%eax
  801ef7:	f7 d8                	neg    %eax
}
  801ef9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  801efc:	5b                   	pop    %ebx
  801efd:	5e                   	pop    %esi
  801efe:	5f                   	pop    %edi
  801eff:	5d                   	pop    %ebp
  801f00:	c3                   	ret    
    if (optlen < sizeof(int)) {
  801f01:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  801f05:	76 49                	jbe    801f50 <lwip_setsockopt+0x17e>
    if (sock->conn->type != NETCONN_TCP)
  801f07:	8b 10                	mov    (%eax),%edx
      return 0;
  801f09:	b8 00 00 00 00       	mov    $0x0,%eax
    if (sock->conn->type != NETCONN_TCP)
  801f0e:	83 3a 10             	cmpl   $0x10,(%edx)
  801f11:	75 e6                	jne    801ef9 <lwip_setsockopt+0x127>
  801f13:	8b 45 10             	mov    0x10(%ebp),%eax
  801f16:	83 e8 01             	sub    $0x1,%eax
  801f19:	83 f8 01             	cmp    $0x1,%eax
  801f1c:	76 87                	jbe    801ea5 <lwip_setsockopt+0xd3>
      err = ENOPROTOOPT;
  801f1e:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f23:	e9 e9 fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
        err = EAFNOSUPPORT;
  801f28:	b8 61 00 00 00       	mov    $0x61,%eax
  801f2d:	e9 df fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
  801f32:	b8 61 00 00 00       	mov    $0x61,%eax
  801f37:	e9 d5 fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
        err = ENOPROTOOPT;
  801f3c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801f41:	e9 cb fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
        err = EINVAL;
  801f46:	b8 16 00 00 00       	mov    $0x16,%eax
  801f4b:	e9 c1 fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
      err = EINVAL;
  801f50:	b8 16 00 00 00       	mov    $0x16,%eax
  801f55:	e9 b7 fe ff ff       	jmp    801e11 <lwip_setsockopt+0x3f>
    return -1;
  801f5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801f5f:	eb 98                	jmp    801ef9 <lwip_setsockopt+0x127>

00801f61 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  801f61:	55                   	push   %ebp
  801f62:	89 e5                	mov    %esp,%ebp
  801f64:	56                   	push   %esi
  801f65:	53                   	push   %ebx
  801f66:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801f69:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  801f6c:	8b 45 08             	mov    0x8(%ebp),%eax
  801f6f:	e8 38 e8 ff ff       	call   8007ac <get_socket>
  u16_t buflen = 0;

  if (!sock)
  801f74:	85 c0                	test   %eax,%eax
  801f76:	0f 84 b4 00 00 00    	je     802030 <lwip_ioctl+0xcf>
    return -1;

  switch (cmd) {
  801f7c:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  801f82:	74 5d                	je     801fe1 <lwip_ioctl+0x80>
  801f84:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  801f8a:	0f 85 88 00 00 00    	jne    802018 <lwip_ioctl+0xb7>
  case FIONREAD:
    if (!argp) {
  801f90:	85 f6                	test   %esi,%esi
  801f92:	74 35                	je     801fc9 <lwip_ioctl+0x68>
      sock_set_errno(sock, EINVAL);
      return -1;
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  801f94:	8b 10                	mov    (%eax),%edx
  801f96:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  801f9a:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  801f9d:	8b 48 04             	mov    0x4(%eax),%ecx
  801fa0:	85 c9                	test   %ecx,%ecx
  801fa2:	74 0d                	je     801fb1 <lwip_ioctl+0x50>
      buflen = netbuf_len(sock->lastdata);
  801fa4:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  801fa6:	66 2b 50 08          	sub    0x8(%eax),%dx
  801faa:	66 03 51 08          	add    0x8(%ecx),%dx
  801fae:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  801fb1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  801fb8:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  801fbf:	00 00 00 
    return 0;
  801fc2:	b8 00 00 00 00       	mov    $0x0,%eax
  801fc7:	eb 4b                	jmp    802014 <lwip_ioctl+0xb3>
      sock_set_errno(sock, EINVAL);
  801fc9:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  801fd0:	c7 05 e0 b1 b3 00 16 	movl   $0x16,0xb3b1e0
  801fd7:	00 00 00 
      return -1;
  801fda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fdf:	eb 33                	jmp    802014 <lwip_ioctl+0xb3>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  801fe1:	85 f6                	test   %esi,%esi
  801fe3:	74 0e                	je     801ff3 <lwip_ioctl+0x92>
  801fe5:	83 3e 00             	cmpl   $0x0,(%esi)
  801fe8:	74 09                	je     801ff3 <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  801fea:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801fee:	80 ce 08             	or     $0x8,%dh
  801ff1:	eb 07                	jmp    801ffa <lwip_ioctl+0x99>
    else
      sock->flags &= ~O_NONBLOCK;
  801ff3:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  801ff7:	80 e6 f7             	and    $0xf7,%dh
  801ffa:	66 89 50 0e          	mov    %dx,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  801ffe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  802005:	c7 05 e0 b1 b3 00 00 	movl   $0x0,0xb3b1e0
  80200c:	00 00 00 
    return 0;
  80200f:	b8 00 00 00 00       	mov    $0x0,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  802014:	5b                   	pop    %ebx
  802015:	5e                   	pop    %esi
  802016:	5d                   	pop    %ebp
  802017:	c3                   	ret    
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802018:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  80201f:	c7 05 e0 b1 b3 00 26 	movl   $0x26,0xb3b1e0
  802026:	00 00 00 
    return -1;
  802029:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80202e:	eb e4                	jmp    802014 <lwip_ioctl+0xb3>
    return -1;
  802030:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802035:	eb dd                	jmp    802014 <lwip_ioctl+0xb3>

00802037 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802037:	55                   	push   %ebp
  802038:	89 e5                	mov    %esp,%ebp
  80203a:	83 ec 08             	sub    $0x8,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  80203d:	e8 1e 41 00 00       	call   806160 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802042:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802049:	74 19                	je     802064 <tcpip_tcp_timer+0x2d>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80204b:	83 ec 04             	sub    $0x4,%esp
  80204e:	6a 00                	push   $0x0
  802050:	68 37 20 80 00       	push   $0x802037
  802055:	68 fa 00 00 00       	push   $0xfa
  80205a:	e8 96 31 00 00       	call   8051f5 <sys_timeout>
  80205f:	83 c4 10             	add    $0x10,%esp
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
  802062:	c9                   	leave  
  802063:	c3                   	ret    
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  802064:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  80206b:	75 de                	jne    80204b <tcpip_tcp_timer+0x14>
    tcpip_tcp_timer_active = 0;
  80206d:	c7 05 e0 52 81 00 00 	movl   $0x0,0x8152e0
  802074:	00 00 00 
}
  802077:	eb e9                	jmp    802062 <tcpip_tcp_timer+0x2b>

00802079 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802079:	55                   	push   %ebp
  80207a:	89 e5                	mov    %esp,%ebp
  80207c:	53                   	push   %ebx
  80207d:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802080:	6a 00                	push   $0x0
  802082:	68 29 22 80 00       	push   $0x802229
  802087:	68 e8 03 00 00       	push   $0x3e8
  80208c:	e8 64 31 00 00       	call   8051f5 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802091:	83 c4 0c             	add    $0xc,%esp
  802094:	6a 00                	push   $0x0
  802096:	68 05 22 80 00       	push   $0x802205
  80209b:	68 88 13 00 00       	push   $0x1388
  8020a0:	e8 50 31 00 00       	call   8051f5 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8020a5:	83 c4 0c             	add    $0xc,%esp
  8020a8:	6a 00                	push   $0x0
  8020aa:	68 e1 21 80 00       	push   $0x8021e1
  8020af:	68 60 ea 00 00       	push   $0xea60
  8020b4:	e8 3c 31 00 00       	call   8051f5 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8020b9:	83 c4 0c             	add    $0xc,%esp
  8020bc:	6a 00                	push   $0x0
  8020be:	68 bd 21 80 00       	push   $0x8021bd
  8020c3:	68 f4 01 00 00       	push   $0x1f4
  8020c8:	e8 28 31 00 00       	call   8051f5 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8020cd:	a1 e8 52 81 00       	mov    0x8152e8,%eax
  8020d2:	83 c4 10             	add    $0x10,%esp
  8020d5:	85 c0                	test   %eax,%eax
  8020d7:	74 0e                	je     8020e7 <tcpip_thread+0x6e>
    tcpip_init_done(tcpip_init_done_arg);
  8020d9:	83 ec 0c             	sub    $0xc,%esp
  8020dc:	ff 35 e4 52 81 00    	pushl  0x8152e4
  8020e2:	ff d0                	call   *%eax
  8020e4:	83 c4 10             	add    $0x10,%esp
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8020e7:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8020ea:	eb 0f                	jmp    8020fb <tcpip_thread+0x82>
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  8020ec:	8b 42 08             	mov    0x8(%edx),%eax
  8020ef:	83 ec 0c             	sub    $0xc,%esp
  8020f2:	8d 50 04             	lea    0x4(%eax),%edx
  8020f5:	52                   	push   %edx
  8020f6:	ff 10                	call   *(%eax)
      break;
  8020f8:	83 c4 10             	add    $0x10,%esp
    sys_mbox_fetch(mbox, (void *)&msg);
  8020fb:	83 ec 08             	sub    $0x8,%esp
  8020fe:	53                   	push   %ebx
  8020ff:	ff 35 00 40 81 00    	pushl  0x814000
  802105:	e8 cb 2f 00 00       	call   8050d5 <sys_mbox_fetch>
    switch (msg->type) {
  80210a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80210d:	8b 02                	mov    (%edx),%eax
  80210f:	83 c4 10             	add    $0x10,%esp
  802112:	83 f8 01             	cmp    $0x1,%eax
  802115:	74 3a                	je     802151 <tcpip_thread+0xd8>
  802117:	85 c0                	test   %eax,%eax
  802119:	74 d1                	je     8020ec <tcpip_thread+0x73>
  80211b:	83 f8 02             	cmp    $0x2,%eax
  80211e:	74 6c                	je     80218c <tcpip_thread+0x113>
  802120:	83 f8 03             	cmp    $0x3,%eax
  802123:	75 d6                	jne    8020fb <tcpip_thread+0x82>
      break;

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  802125:	8b 42 08             	mov    0x8(%edx),%eax
  802128:	83 f8 ff             	cmp    $0xffffffff,%eax
  80212b:	74 7d                	je     8021aa <tcpip_thread+0x131>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  80212d:	83 ec 04             	sub    $0x4,%esp
  802130:	ff 72 10             	pushl  0x10(%edx)
  802133:	ff 72 0c             	pushl  0xc(%edx)
  802136:	50                   	push   %eax
  802137:	e8 b9 30 00 00       	call   8051f5 <sys_timeout>
  80213c:	83 c4 10             	add    $0x10,%esp
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80213f:	83 ec 08             	sub    $0x8,%esp
  802142:	ff 75 f4             	pushl  -0xc(%ebp)
  802145:	6a 08                	push   $0x8
  802147:	e8 f1 23 00 00       	call   80453d <memp_free>
      break;
  80214c:	83 c4 10             	add    $0x10,%esp
  80214f:	eb aa                	jmp    8020fb <tcpip_thread+0x82>
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802151:	8b 42 0c             	mov    0xc(%edx),%eax
  802154:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802158:	74 21                	je     80217b <tcpip_thread+0x102>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80215a:	83 ec 08             	sub    $0x8,%esp
  80215d:	50                   	push   %eax
  80215e:	ff 72 08             	pushl  0x8(%edx)
  802161:	e8 2d 7b 00 00       	call   809c93 <ethernet_input>
  802166:	83 c4 10             	add    $0x10,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802169:	83 ec 08             	sub    $0x8,%esp
  80216c:	ff 75 f4             	pushl  -0xc(%ebp)
  80216f:	6a 09                	push   $0x9
  802171:	e8 c7 23 00 00       	call   80453d <memp_free>
      break;
  802176:	83 c4 10             	add    $0x10,%esp
  802179:	eb 80                	jmp    8020fb <tcpip_thread+0x82>
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80217b:	83 ec 08             	sub    $0x8,%esp
  80217e:	50                   	push   %eax
  80217f:	ff 72 08             	pushl  0x8(%edx)
  802182:	e8 1a 44 00 00       	call   8065a1 <ip_input>
  802187:	83 c4 10             	add    $0x10,%esp
  80218a:	eb dd                	jmp    802169 <tcpip_thread+0xf0>
      msg->msg.cb.f(msg->msg.cb.ctx);
  80218c:	83 ec 0c             	sub    $0xc,%esp
  80218f:	ff 72 0c             	pushl  0xc(%edx)
  802192:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802195:	83 c4 08             	add    $0x8,%esp
  802198:	ff 75 f4             	pushl  -0xc(%ebp)
  80219b:	6a 08                	push   $0x8
  80219d:	e8 9b 23 00 00       	call   80453d <memp_free>
      break;
  8021a2:	83 c4 10             	add    $0x10,%esp
  8021a5:	e9 51 ff ff ff       	jmp    8020fb <tcpip_thread+0x82>
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8021aa:	83 ec 08             	sub    $0x8,%esp
  8021ad:	ff 72 10             	pushl  0x10(%edx)
  8021b0:	ff 72 0c             	pushl  0xc(%edx)
  8021b3:	e8 00 31 00 00       	call   8052b8 <sys_untimeout>
  8021b8:	83 c4 10             	add    $0x10,%esp
  8021bb:	eb 82                	jmp    80213f <tcpip_thread+0xc6>

008021bd <dhcp_timer_fine>:
{
  8021bd:	55                   	push   %ebp
  8021be:	89 e5                	mov    %esp,%ebp
  8021c0:	83 ec 08             	sub    $0x8,%esp
  dhcp_fine_tmr();
  8021c3:	e8 45 1b 00 00       	call   803d0d <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8021c8:	83 ec 04             	sub    $0x4,%esp
  8021cb:	6a 00                	push   $0x0
  8021cd:	68 bd 21 80 00       	push   $0x8021bd
  8021d2:	68 f4 01 00 00       	push   $0x1f4
  8021d7:	e8 19 30 00 00       	call   8051f5 <sys_timeout>
}
  8021dc:	83 c4 10             	add    $0x10,%esp
  8021df:	c9                   	leave  
  8021e0:	c3                   	ret    

008021e1 <dhcp_timer_coarse>:
{
  8021e1:	55                   	push   %ebp
  8021e2:	89 e5                	mov    %esp,%ebp
  8021e4:	83 ec 08             	sub    $0x8,%esp
  dhcp_coarse_tmr();
  8021e7:	e8 55 19 00 00       	call   803b41 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8021ec:	83 ec 04             	sub    $0x4,%esp
  8021ef:	6a 00                	push   $0x0
  8021f1:	68 e1 21 80 00       	push   $0x8021e1
  8021f6:	68 60 ea 00 00       	push   $0xea60
  8021fb:	e8 f5 2f 00 00       	call   8051f5 <sys_timeout>
}
  802200:	83 c4 10             	add    $0x10,%esp
  802203:	c9                   	leave  
  802204:	c3                   	ret    

00802205 <arp_timer>:
{
  802205:	55                   	push   %ebp
  802206:	89 e5                	mov    %esp,%ebp
  802208:	83 ec 08             	sub    $0x8,%esp
  etharp_tmr();
  80220b:	e8 53 73 00 00       	call   809563 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802210:	83 ec 04             	sub    $0x4,%esp
  802213:	6a 00                	push   $0x0
  802215:	68 05 22 80 00       	push   $0x802205
  80221a:	68 88 13 00 00       	push   $0x1388
  80221f:	e8 d1 2f 00 00       	call   8051f5 <sys_timeout>
}
  802224:	83 c4 10             	add    $0x10,%esp
  802227:	c9                   	leave  
  802228:	c3                   	ret    

00802229 <ip_reass_timer>:
{
  802229:	55                   	push   %ebp
  80222a:	89 e5                	mov    %esp,%ebp
  80222c:	83 ec 08             	sub    $0x8,%esp
  ip_reass_tmr();
  80222f:	e8 68 4a 00 00       	call   806c9c <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802234:	83 ec 04             	sub    $0x4,%esp
  802237:	6a 00                	push   $0x0
  802239:	68 29 22 80 00       	push   $0x802229
  80223e:	68 e8 03 00 00       	push   $0x3e8
  802243:	e8 ad 2f 00 00       	call   8051f5 <sys_timeout>
}
  802248:	83 c4 10             	add    $0x10,%esp
  80224b:	c9                   	leave  
  80224c:	c3                   	ret    

0080224d <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80224d:	55                   	push   %ebp
  80224e:	89 e5                	mov    %esp,%ebp
  802250:	83 ec 14             	sub    $0x14,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802253:	ff 75 08             	pushl  0x8(%ebp)
  802256:	e8 2f 26 00 00       	call   80488a <pbuf_free>
}
  80225b:	83 c4 10             	add    $0x10,%esp
  80225e:	c9                   	leave  
  80225f:	c3                   	ret    

00802260 <tcp_timer_needed>:
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802260:	83 3d e0 52 81 00 00 	cmpl   $0x0,0x8152e0
  802267:	75 38                	jne    8022a1 <tcp_timer_needed+0x41>
  802269:	83 3d 3c b2 b3 00 00 	cmpl   $0x0,0xb3b23c
  802270:	74 26                	je     802298 <tcp_timer_needed+0x38>
{
  802272:	55                   	push   %ebp
  802273:	89 e5                	mov    %esp,%ebp
  802275:	83 ec 0c             	sub    $0xc,%esp
    tcpip_tcp_timer_active = 1;
  802278:	c7 05 e0 52 81 00 01 	movl   $0x1,0x8152e0
  80227f:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  802282:	6a 00                	push   $0x0
  802284:	68 37 20 80 00       	push   $0x802037
  802289:	68 fa 00 00 00       	push   $0xfa
  80228e:	e8 62 2f 00 00       	call   8051f5 <sys_timeout>
  802293:	83 c4 10             	add    $0x10,%esp
}
  802296:	c9                   	leave  
  802297:	c3                   	ret    
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  802298:	83 3d 50 b2 b3 00 00 	cmpl   $0x0,0xb3b250
  80229f:	75 d1                	jne    802272 <tcp_timer_needed+0x12>
  8022a1:	c3                   	ret    

008022a2 <tcpip_input>:
  if (mbox != SYS_MBOX_NULL) {
  8022a2:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8022a9:	74 59                	je     802304 <tcpip_input+0x62>
{
  8022ab:	55                   	push   %ebp
  8022ac:	89 e5                	mov    %esp,%ebp
  8022ae:	53                   	push   %ebx
  8022af:	83 ec 10             	sub    $0x10,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8022b2:	6a 09                	push   $0x9
  8022b4:	e8 2e 22 00 00       	call   8044e7 <memp_malloc>
  8022b9:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  8022bb:	83 c4 10             	add    $0x10,%esp
  8022be:	85 c0                	test   %eax,%eax
  8022c0:	74 48                	je     80230a <tcpip_input+0x68>
    msg->type = TCPIP_MSG_INPKT;
  8022c2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  8022c8:	8b 45 08             	mov    0x8(%ebp),%eax
  8022cb:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  8022ce:	8b 45 0c             	mov    0xc(%ebp),%eax
  8022d1:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8022d4:	83 ec 08             	sub    $0x8,%esp
  8022d7:	53                   	push   %ebx
  8022d8:	ff 35 00 40 81 00    	pushl  0x814000
  8022de:	e8 97 7f 00 00       	call   80a27a <sys_mbox_trypost>
  8022e3:	83 c4 10             	add    $0x10,%esp
  8022e6:	84 c0                	test   %al,%al
  8022e8:	75 05                	jne    8022ef <tcpip_input+0x4d>
}
  8022ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8022ed:	c9                   	leave  
  8022ee:	c3                   	ret    
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8022ef:	83 ec 08             	sub    $0x8,%esp
  8022f2:	53                   	push   %ebx
  8022f3:	6a 09                	push   $0x9
  8022f5:	e8 43 22 00 00       	call   80453d <memp_free>
      return ERR_MEM;
  8022fa:	83 c4 10             	add    $0x10,%esp
  8022fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802302:	eb e6                	jmp    8022ea <tcpip_input+0x48>
  return ERR_VAL;
  802304:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802309:	c3                   	ret    
      return ERR_MEM;
  80230a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80230f:	eb d9                	jmp    8022ea <tcpip_input+0x48>

00802311 <tcpip_callback_with_block>:
{
  802311:	55                   	push   %ebp
  802312:	89 e5                	mov    %esp,%ebp
  802314:	56                   	push   %esi
  802315:	53                   	push   %ebx
  802316:	8b 75 10             	mov    0x10(%ebp),%esi
  if (mbox != SYS_MBOX_NULL) {
  802319:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  802320:	74 76                	je     802398 <tcpip_callback_with_block+0x87>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802322:	83 ec 0c             	sub    $0xc,%esp
  802325:	6a 08                	push   $0x8
  802327:	e8 bb 21 00 00       	call   8044e7 <memp_malloc>
  80232c:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  80232e:	83 c4 10             	add    $0x10,%esp
  802331:	85 c0                	test   %eax,%eax
  802333:	74 6a                	je     80239f <tcpip_callback_with_block+0x8e>
    msg->type = TCPIP_MSG_CALLBACK;
  802335:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80233b:	8b 45 08             	mov    0x8(%ebp),%eax
  80233e:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802341:	8b 45 0c             	mov    0xc(%ebp),%eax
  802344:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  802347:	89 f0                	mov    %esi,%eax
  802349:	84 c0                	test   %al,%al
  80234b:	75 1d                	jne    80236a <tcpip_callback_with_block+0x59>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80234d:	83 ec 08             	sub    $0x8,%esp
  802350:	53                   	push   %ebx
  802351:	ff 35 00 40 81 00    	pushl  0x814000
  802357:	e8 1e 7f 00 00       	call   80a27a <sys_mbox_trypost>
  80235c:	83 c4 10             	add    $0x10,%esp
  80235f:	84 c0                	test   %al,%al
  802361:	75 20                	jne    802383 <tcpip_callback_with_block+0x72>
}
  802363:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802366:	5b                   	pop    %ebx
  802367:	5e                   	pop    %esi
  802368:	5d                   	pop    %ebp
  802369:	c3                   	ret    
      sys_mbox_post(mbox, msg);
  80236a:	83 ec 08             	sub    $0x8,%esp
  80236d:	53                   	push   %ebx
  80236e:	ff 35 00 40 81 00    	pushl  0x814000
  802374:	e8 c6 7f 00 00       	call   80a33f <sys_mbox_post>
  802379:	83 c4 10             	add    $0x10,%esp
    return ERR_OK;
  80237c:	b8 00 00 00 00       	mov    $0x0,%eax
  802381:	eb e0                	jmp    802363 <tcpip_callback_with_block+0x52>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  802383:	83 ec 08             	sub    $0x8,%esp
  802386:	53                   	push   %ebx
  802387:	6a 08                	push   $0x8
  802389:	e8 af 21 00 00       	call   80453d <memp_free>
        return ERR_MEM;
  80238e:	83 c4 10             	add    $0x10,%esp
  802391:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802396:	eb cb                	jmp    802363 <tcpip_callback_with_block+0x52>
  return ERR_VAL;
  802398:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80239d:	eb c4                	jmp    802363 <tcpip_callback_with_block+0x52>
      return ERR_MEM;
  80239f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023a4:	eb bd                	jmp    802363 <tcpip_callback_with_block+0x52>

008023a6 <tcpip_timeout>:
  if (mbox != SYS_MBOX_NULL) {
  8023a6:	83 3d 00 40 81 00 ff 	cmpl   $0xffffffff,0x814000
  8023ad:	74 45                	je     8023f4 <tcpip_timeout+0x4e>
{
  8023af:	55                   	push   %ebp
  8023b0:	89 e5                	mov    %esp,%ebp
  8023b2:	83 ec 14             	sub    $0x14,%esp
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8023b5:	6a 08                	push   $0x8
  8023b7:	e8 2b 21 00 00       	call   8044e7 <memp_malloc>
    if (msg == NULL) {
  8023bc:	83 c4 10             	add    $0x10,%esp
  8023bf:	85 c0                	test   %eax,%eax
  8023c1:	74 37                	je     8023fa <tcpip_timeout+0x54>
    msg->type = TCPIP_MSG_TIMEOUT;
  8023c3:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  8023c9:	8b 55 08             	mov    0x8(%ebp),%edx
  8023cc:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  8023cf:	8b 55 0c             	mov    0xc(%ebp),%edx
  8023d2:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  8023d5:	8b 55 10             	mov    0x10(%ebp),%edx
  8023d8:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  8023db:	83 ec 08             	sub    $0x8,%esp
  8023de:	50                   	push   %eax
  8023df:	ff 35 00 40 81 00    	pushl  0x814000
  8023e5:	e8 55 7f 00 00       	call   80a33f <sys_mbox_post>
    return ERR_OK;
  8023ea:	83 c4 10             	add    $0x10,%esp
  8023ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023f2:	c9                   	leave  
  8023f3:	c3                   	ret    
  return ERR_VAL;
  8023f4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8023f9:	c3                   	ret    
      return ERR_MEM;
  8023fa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8023ff:	eb f1                	jmp    8023f2 <tcpip_timeout+0x4c>

00802401 <tcpip_apimsg>:
{
  802401:	55                   	push   %ebp
  802402:	89 e5                	mov    %esp,%ebp
  802404:	53                   	push   %ebx
  802405:	83 ec 24             	sub    $0x24,%esp
  802408:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (mbox != SYS_MBOX_NULL) {
  80240b:	a1 00 40 81 00       	mov    0x814000,%eax
  802410:	83 f8 ff             	cmp    $0xffffffff,%eax
  802413:	74 34                	je     802449 <tcpip_apimsg+0x48>
    msg.type = TCPIP_MSG_API;
  802415:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  80241c:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  80241f:	83 ec 08             	sub    $0x8,%esp
  802422:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802425:	52                   	push   %edx
  802426:	50                   	push   %eax
  802427:	e8 13 7f 00 00       	call   80a33f <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80242c:	83 c4 08             	add    $0x8,%esp
  80242f:	6a 00                	push   $0x0
  802431:	8b 43 04             	mov    0x4(%ebx),%eax
  802434:	ff 70 10             	pushl  0x10(%eax)
  802437:	e8 2e 7d 00 00       	call   80a16a <sys_arch_sem_wait>
    return ERR_OK;
  80243c:	83 c4 10             	add    $0x10,%esp
  80243f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802444:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802447:	c9                   	leave  
  802448:	c3                   	ret    
  return ERR_VAL;
  802449:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80244e:	eb f4                	jmp    802444 <tcpip_apimsg+0x43>

00802450 <tcpip_init>:
{
  802450:	55                   	push   %ebp
  802451:	89 e5                	mov    %esp,%ebp
  802453:	83 ec 08             	sub    $0x8,%esp
  lwip_init();
  802456:	e8 6a 03 00 00       	call   8027c5 <lwip_init>
  tcpip_init_done = initfunc;
  80245b:	8b 45 08             	mov    0x8(%ebp),%eax
  80245e:	a3 e8 52 81 00       	mov    %eax,0x8152e8
  tcpip_init_done_arg = arg;
  802463:	8b 45 0c             	mov    0xc(%ebp),%eax
  802466:	a3 e4 52 81 00       	mov    %eax,0x8152e4
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80246b:	83 ec 0c             	sub    $0xc,%esp
  80246e:	6a 00                	push   $0x0
  802470:	e8 71 7b 00 00       	call   809fe6 <sys_mbox_new>
  802475:	a3 00 40 81 00       	mov    %eax,0x814000
  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80247a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  802481:	6a 00                	push   $0x0
  802483:	6a 00                	push   $0x0
  802485:	68 79 20 80 00       	push   $0x802079
  80248a:	68 9c 16 81 00       	push   $0x81169c
  80248f:	e8 de 7f 00 00       	call   80a472 <sys_thread_new>
}
  802494:	83 c4 20             	add    $0x20,%esp
  802497:	c9                   	leave  
  802498:	c3                   	ret    

00802499 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  802499:	55                   	push   %ebp
  80249a:	89 e5                	mov    %esp,%ebp
  80249c:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  80249f:	6a 00                	push   $0x0
  8024a1:	ff 75 08             	pushl  0x8(%ebp)
  8024a4:	68 4d 22 80 00       	push   $0x80224d
  8024a9:	e8 63 fe ff ff       	call   802311 <tcpip_callback_with_block>
}
  8024ae:	c9                   	leave  
  8024af:	c3                   	ret    

008024b0 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8024b0:	55                   	push   %ebp
  8024b1:	89 e5                	mov    %esp,%ebp
  8024b3:	83 ec 0c             	sub    $0xc,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8024b6:	6a 00                	push   $0x0
  8024b8:	ff 75 08             	pushl  0x8(%ebp)
  8024bb:	68 a4 3f 80 00       	push   $0x803fa4
  8024c0:	e8 4c fe ff ff       	call   802311 <tcpip_callback_with_block>
}
  8024c5:	c9                   	leave  
  8024c6:	c3                   	ret    

008024c7 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8024c7:	55                   	push   %ebp
  8024c8:	89 e5                	mov    %esp,%ebp
  8024ca:	83 ec 14             	sub    $0x14,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8024cd:	6a 06                	push   $0x6
  8024cf:	e8 13 20 00 00       	call   8044e7 <memp_malloc>
  if (buf != NULL) {
  8024d4:	83 c4 10             	add    $0x10,%esp
  8024d7:	85 c0                	test   %eax,%eax
  8024d9:	74 14                	je     8024ef <netbuf_new+0x28>
    buf->p = NULL;
  8024db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8024e1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  8024e8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  8024ef:	c9                   	leave  
  8024f0:	c3                   	ret    

008024f1 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8024f1:	55                   	push   %ebp
  8024f2:	89 e5                	mov    %esp,%ebp
  8024f4:	53                   	push   %ebx
  8024f5:	83 ec 04             	sub    $0x4,%esp
  8024f8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8024fb:	85 db                	test   %ebx,%ebx
  8024fd:	74 2d                	je     80252c <netbuf_delete+0x3b>
    if (buf->p != NULL) {
  8024ff:	8b 03                	mov    (%ebx),%eax
  802501:	85 c0                	test   %eax,%eax
  802503:	74 19                	je     80251e <netbuf_delete+0x2d>
      pbuf_free(buf->p);
  802505:	83 ec 0c             	sub    $0xc,%esp
  802508:	50                   	push   %eax
  802509:	e8 7c 23 00 00       	call   80488a <pbuf_free>
      buf->p = buf->ptr = NULL;
  80250e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  802515:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80251b:	83 c4 10             	add    $0x10,%esp
    }
    memp_free(MEMP_NETBUF, buf);
  80251e:	83 ec 08             	sub    $0x8,%esp
  802521:	53                   	push   %ebx
  802522:	6a 06                	push   $0x6
  802524:	e8 14 20 00 00       	call   80453d <memp_free>
  802529:	83 c4 10             	add    $0x10,%esp
  }
}
  80252c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80252f:	c9                   	leave  
  802530:	c3                   	ret    

00802531 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  802531:	55                   	push   %ebp
  802532:	89 e5                	mov    %esp,%ebp
  802534:	56                   	push   %esi
  802535:	53                   	push   %ebx
  802536:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802539:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80253c:	85 db                	test   %ebx,%ebx
  80253e:	74 3e                	je     80257e <netbuf_alloc+0x4d>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  802540:	8b 03                	mov    (%ebx),%eax
  802542:	85 c0                	test   %eax,%eax
  802544:	74 0c                	je     802552 <netbuf_alloc+0x21>
    pbuf_free(buf->p);
  802546:	83 ec 0c             	sub    $0xc,%esp
  802549:	50                   	push   %eax
  80254a:	e8 3b 23 00 00       	call   80488a <pbuf_free>
  80254f:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  802552:	83 ec 04             	sub    $0x4,%esp
  802555:	6a 00                	push   $0x0
  802557:	0f b7 c6             	movzwl %si,%eax
  80255a:	50                   	push   %eax
  80255b:	6a 00                	push   $0x0
  80255d:	e8 ee 23 00 00       	call   804950 <pbuf_alloc>
  802562:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802564:	83 c4 10             	add    $0x10,%esp
  802567:	85 c0                	test   %eax,%eax
  802569:	74 0c                	je     802577 <netbuf_alloc+0x46>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  80256b:	66 39 70 0a          	cmp    %si,0xa(%eax)
  80256f:	72 21                	jb     802592 <netbuf_alloc+0x61>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  802571:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  802574:	8b 40 04             	mov    0x4(%eax),%eax
}
  802577:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80257a:	5b                   	pop    %ebx
  80257b:	5e                   	pop    %esi
  80257c:	5d                   	pop    %ebp
  80257d:	c3                   	ret    
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80257e:	83 ec 04             	sub    $0x4,%esp
  802581:	68 a9 16 81 00       	push   $0x8116a9
  802586:	6a 63                	push   $0x63
  802588:	68 c3 16 81 00       	push   $0x8116c3
  80258d:	e8 07 c1 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("check that first pbuf can hold size",
  802592:	83 ec 04             	sub    $0x4,%esp
  802595:	68 90 17 81 00       	push   $0x811790
  80259a:	6a 6e                	push   $0x6e
  80259c:	68 c3 16 81 00       	push   $0x8116c3
  8025a1:	e8 f3 c0 00 00       	call   80e699 <_panic>

008025a6 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  8025a6:	55                   	push   %ebp
  8025a7:	89 e5                	mov    %esp,%ebp
  8025a9:	53                   	push   %ebx
  8025aa:	83 ec 04             	sub    $0x4,%esp
  8025ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025b0:	85 db                	test   %ebx,%ebx
  8025b2:	74 24                	je     8025d8 <netbuf_free+0x32>
  if (buf->p != NULL) {
  8025b4:	8b 03                	mov    (%ebx),%eax
  8025b6:	85 c0                	test   %eax,%eax
  8025b8:	74 0c                	je     8025c6 <netbuf_free+0x20>
    pbuf_free(buf->p);
  8025ba:	83 ec 0c             	sub    $0xc,%esp
  8025bd:	50                   	push   %eax
  8025be:	e8 c7 22 00 00       	call   80488a <pbuf_free>
  8025c3:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = buf->ptr = NULL;
  8025c6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8025cd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8025d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8025d6:	c9                   	leave  
  8025d7:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8025d8:	83 ec 04             	sub    $0x4,%esp
  8025db:	68 d9 16 81 00       	push   $0x8116d9
  8025e0:	6a 7b                	push   $0x7b
  8025e2:	68 c3 16 81 00       	push   $0x8116c3
  8025e7:	e8 ad c0 00 00       	call   80e699 <_panic>

008025ec <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8025ec:	55                   	push   %ebp
  8025ed:	89 e5                	mov    %esp,%ebp
  8025ef:	56                   	push   %esi
  8025f0:	53                   	push   %ebx
  8025f1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8025f4:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8025f7:	85 db                	test   %ebx,%ebx
  8025f9:	74 4c                	je     802647 <netbuf_ref+0x5b>
  if (buf->p != NULL) {
  8025fb:	8b 03                	mov    (%ebx),%eax
  8025fd:	85 c0                	test   %eax,%eax
  8025ff:	74 0c                	je     80260d <netbuf_ref+0x21>
    pbuf_free(buf->p);
  802601:	83 ec 0c             	sub    $0xc,%esp
  802604:	50                   	push   %eax
  802605:	e8 80 22 00 00       	call   80488a <pbuf_free>
  80260a:	83 c4 10             	add    $0x10,%esp
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80260d:	83 ec 04             	sub    $0x4,%esp
  802610:	6a 02                	push   $0x2
  802612:	6a 00                	push   $0x0
  802614:	6a 00                	push   $0x0
  802616:	e8 35 23 00 00       	call   804950 <pbuf_alloc>
  80261b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  80261d:	83 c4 10             	add    $0x10,%esp
  802620:	85 c0                	test   %eax,%eax
  802622:	74 3a                	je     80265e <netbuf_ref+0x72>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  802624:	8b 55 0c             	mov    0xc(%ebp),%edx
  802627:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  80262a:	8b 03                	mov    (%ebx),%eax
  80262c:	66 89 70 08          	mov    %si,0x8(%eax)
  802630:	8b 03                	mov    (%ebx),%eax
  802632:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802636:	8b 03                	mov    (%ebx),%eax
  802638:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  80263b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802640:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802643:	5b                   	pop    %ebx
  802644:	5e                   	pop    %esi
  802645:	5d                   	pop    %ebp
  802646:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  802647:	83 ec 04             	sub    $0x4,%esp
  80264a:	68 f2 16 81 00       	push   $0x8116f2
  80264f:	68 8e 00 00 00       	push   $0x8e
  802654:	68 c3 16 81 00       	push   $0x8116c3
  802659:	e8 3b c0 00 00       	call   80e699 <_panic>
    buf->ptr = NULL;
  80265e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  802665:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80266a:	eb d4                	jmp    802640 <netbuf_ref+0x54>

0080266c <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  80266c:	55                   	push   %ebp
  80266d:	89 e5                	mov    %esp,%ebp
  80266f:	56                   	push   %esi
  802670:	53                   	push   %ebx
  802671:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802674:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802677:	85 db                	test   %ebx,%ebx
  802679:	74 2a                	je     8026a5 <netbuf_chain+0x39>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  80267b:	85 f6                	test   %esi,%esi
  80267d:	74 3d                	je     8026bc <netbuf_chain+0x50>
  pbuf_chain(head->p, tail->p);
  80267f:	83 ec 08             	sub    $0x8,%esp
  802682:	ff 36                	pushl  (%esi)
  802684:	ff 33                	pushl  (%ebx)
  802686:	e8 e0 26 00 00       	call   804d6b <pbuf_chain>
  head->ptr = head->p;
  80268b:	8b 03                	mov    (%ebx),%eax
  80268d:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802690:	83 c4 08             	add    $0x8,%esp
  802693:	56                   	push   %esi
  802694:	6a 06                	push   $0x6
  802696:	e8 a2 1e 00 00       	call   80453d <memp_free>
  80269b:	83 c4 10             	add    $0x10,%esp
}
  80269e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8026a1:	5b                   	pop    %ebx
  8026a2:	5e                   	pop    %esi
  8026a3:	5d                   	pop    %ebp
  8026a4:	c3                   	ret    
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8026a5:	83 ec 04             	sub    $0x4,%esp
  8026a8:	68 0a 17 81 00       	push   $0x81170a
  8026ad:	68 a6 00 00 00       	push   $0xa6
  8026b2:	68 c3 16 81 00       	push   $0x8116c3
  8026b7:	e8 dd bf 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8026bc:	83 ec 04             	sub    $0x4,%esp
  8026bf:	68 23 17 81 00       	push   $0x811723
  8026c4:	68 a7 00 00 00       	push   $0xa7
  8026c9:	68 c3 16 81 00       	push   $0x8116c3
  8026ce:	e8 c6 bf 00 00       	call   80e699 <_panic>

008026d3 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  8026d3:	55                   	push   %ebp
  8026d4:	89 e5                	mov    %esp,%ebp
  8026d6:	53                   	push   %ebx
  8026d7:	83 ec 04             	sub    $0x4,%esp
  8026da:	8b 45 08             	mov    0x8(%ebp),%eax
  8026dd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8026e0:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  8026e3:	85 c0                	test   %eax,%eax
  8026e5:	74 28                	je     80270f <netbuf_data+0x3c>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  8026e7:	85 c9                	test   %ecx,%ecx
  8026e9:	74 3b                	je     802726 <netbuf_data+0x53>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  8026eb:	85 d2                	test   %edx,%edx
  8026ed:	74 4e                	je     80273d <netbuf_data+0x6a>

  if (buf->ptr == NULL) {
  8026ef:	8b 58 04             	mov    0x4(%eax),%ebx
  8026f2:	85 db                	test   %ebx,%ebx
  8026f4:	74 5e                	je     802754 <netbuf_data+0x81>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  8026f6:	8b 5b 04             	mov    0x4(%ebx),%ebx
  8026f9:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  8026fb:	8b 40 04             	mov    0x4(%eax),%eax
  8026fe:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802702:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802705:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80270a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80270d:	c9                   	leave  
  80270e:	c3                   	ret    
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80270f:	83 ec 04             	sub    $0x4,%esp
  802712:	68 3e 17 81 00       	push   $0x81173e
  802717:	68 b9 00 00 00       	push   $0xb9
  80271c:	68 c3 16 81 00       	push   $0x8116c3
  802721:	e8 73 bf 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802726:	83 ec 04             	sub    $0x4,%esp
  802729:	68 57 17 81 00       	push   $0x811757
  80272e:	68 ba 00 00 00       	push   $0xba
  802733:	68 c3 16 81 00       	push   $0x8116c3
  802738:	e8 5c bf 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80273d:	83 ec 04             	sub    $0x4,%esp
  802740:	68 74 17 81 00       	push   $0x811774
  802745:	68 bb 00 00 00       	push   $0xbb
  80274a:	68 c3 16 81 00       	push   $0x8116c3
  80274f:	e8 45 bf 00 00       	call   80e699 <_panic>
    return ERR_BUF;
  802754:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  802759:	eb af                	jmp    80270a <netbuf_data+0x37>

0080275b <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  80275b:	55                   	push   %ebp
  80275c:	89 e5                	mov    %esp,%ebp
  80275e:	83 ec 08             	sub    $0x8,%esp
  802761:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802764:	85 c0                	test   %eax,%eax
  802766:	74 14                	je     80277c <netbuf_next+0x21>
  if (buf->ptr->next == NULL) {
  802768:	8b 50 04             	mov    0x4(%eax),%edx
  80276b:	8b 12                	mov    (%edx),%edx
  80276d:	85 d2                	test   %edx,%edx
  80276f:	74 22                	je     802793 <netbuf_next+0x38>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802771:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802774:	83 3a 00             	cmpl   $0x0,(%edx)
  802777:	0f 94 c0             	sete   %al
    return 1;
  }
  return 0;
}
  80277a:	c9                   	leave  
  80277b:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  80277c:	83 ec 04             	sub    $0x4,%esp
  80277f:	68 d9 16 81 00       	push   $0x8116d9
  802784:	68 d2 00 00 00       	push   $0xd2
  802789:	68 c3 16 81 00       	push   $0x8116c3
  80278e:	e8 06 bf 00 00       	call   80e699 <_panic>
    return -1;
  802793:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802798:	eb e0                	jmp    80277a <netbuf_next+0x1f>

0080279a <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  80279a:	55                   	push   %ebp
  80279b:	89 e5                	mov    %esp,%ebp
  80279d:	83 ec 08             	sub    $0x8,%esp
  8027a0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027a3:	85 c0                	test   %eax,%eax
  8027a5:	74 07                	je     8027ae <netbuf_first+0x14>
  buf->ptr = buf->p;
  8027a7:	8b 10                	mov    (%eax),%edx
  8027a9:	89 50 04             	mov    %edx,0x4(%eax)
}
  8027ac:	c9                   	leave  
  8027ad:	c3                   	ret    
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8027ae:	83 ec 04             	sub    $0x4,%esp
  8027b1:	68 d9 16 81 00       	push   $0x8116d9
  8027b6:	68 e7 00 00 00       	push   $0xe7
  8027bb:	68 c3 16 81 00       	push   $0x8116c3
  8027c0:	e8 d4 be 00 00       	call   80e699 <_panic>

008027c5 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  8027c5:	55                   	push   %ebp
  8027c6:	89 e5                	mov    %esp,%ebp
  8027c8:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  8027cb:	e8 d0 75 00 00       	call   809da0 <sys_init>
  mem_init();
  8027d0:	e8 69 17 00 00       	call   803f3e <mem_init>
  memp_init();
  8027d5:	e8 b1 1c 00 00       	call   80448b <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  8027da:	e8 a9 e6 ff ff       	call   800e88 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  8027df:	c9                   	leave  
  8027e0:	c3                   	ret    

008027e1 <dhcp_set_state>:
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
  8027e1:	38 10                	cmp    %dl,(%eax)
  8027e3:	74 06                	je     8027eb <dhcp_set_state+0xa>
    dhcp->state = new_state;
  8027e5:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  8027e7:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  8027eb:	c3                   	ret    

008027ec <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  8027ec:	55                   	push   %ebp
  8027ed:	89 e5                	mov    %esp,%ebp
  8027ef:	57                   	push   %edi
  8027f0:	56                   	push   %esi
  8027f1:	53                   	push   %ebx
  8027f2:	83 ec 0c             	sub    $0xc,%esp
  8027f5:	89 c7                	mov    %eax,%edi
  8027f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  8027fa:	8b 40 14             	mov    0x14(%eax),%eax
  8027fd:	85 c0                	test   %eax,%eax
  8027ff:	74 19                	je     80281a <dhcp_get_option_ptr+0x2e>
  802801:	89 d6                	mov    %edx,%esi
  802803:	0f b7 7f 18          	movzwl 0x18(%edi),%edi
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  802807:	b9 00 00 00 00       	mov    $0x0,%ecx
  u8_t overload = DHCP_OVERLOAD_NONE;
  80280c:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802810:	66 85 ff             	test   %di,%di
  802813:	75 2d                	jne    802842 <dhcp_get_option_ptr+0x56>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802815:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80281a:	83 c4 0c             	add    $0xc,%esp
  80281d:	5b                   	pop    %ebx
  80281e:	5e                   	pop    %esi
  80281f:	5f                   	pop    %edi
  802820:	5d                   	pop    %ebp
  802821:	c3                   	ret    
        offset += 2;
  802822:	8d 51 02             	lea    0x2(%ecx),%edx
        overload = options[offset++];
  802825:	83 c1 03             	add    $0x3,%ecx
  802828:	0f b7 d2             	movzwl %dx,%edx
  80282b:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
  80282f:	88 5d ef             	mov    %bl,-0x11(%ebp)
  802832:	eb 0e                	jmp    802842 <dhcp_get_option_ptr+0x56>
        offset++;
  802834:	8d 51 01             	lea    0x1(%ecx),%edx
        offset += 1 + options[offset];
  802837:	0f b7 d2             	movzwl %dx,%edx
  80283a:	0f b6 14 10          	movzbl (%eax,%edx,1),%edx
  80283e:	8d 4c 0a 02          	lea    0x2(%edx,%ecx,1),%ecx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802842:	66 39 cf             	cmp    %cx,%di
  802845:	76 22                	jbe    802869 <dhcp_get_option_ptr+0x7d>
  802847:	0f b7 d9             	movzwl %cx,%ebx
  80284a:	01 c3                	add    %eax,%ebx
  80284c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
  80284f:	0f b6 13             	movzbl (%ebx),%edx
  802852:	80 fa ff             	cmp    $0xff,%dl
  802855:	74 12                	je     802869 <dhcp_get_option_ptr+0x7d>
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802857:	80 fa 34             	cmp    $0x34,%dl
  80285a:	74 c6                	je     802822 <dhcp_get_option_ptr+0x36>
      else if (options[offset] == option_type) {
  80285c:	89 f3                	mov    %esi,%ebx
  80285e:	38 da                	cmp    %bl,%dl
  802860:	75 d2                	jne    802834 <dhcp_get_option_ptr+0x48>
  802862:	8b 5d f0             	mov    -0x10(%ebp),%ebx
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802865:	89 d8                	mov    %ebx,%eax
  802867:	eb b1                	jmp    80281a <dhcp_get_option_ptr+0x2e>
  return NULL;
  802869:	b8 00 00 00 00       	mov    $0x0,%eax
    if (overload != DHCP_OVERLOAD_NONE) {
  80286e:	0f b6 4d ef          	movzbl -0x11(%ebp),%ecx
  802872:	84 c9                	test   %cl,%cl
  802874:	74 a4                	je     80281a <dhcp_get_option_ptr+0x2e>
      if (overload == DHCP_OVERLOAD_FILE) {
  802876:	80 f9 01             	cmp    $0x1,%cl
  802879:	74 55                	je     8028d0 <dhcp_get_option_ptr+0xe4>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80287b:	80 7d ef 02          	cmpb   $0x2,-0x11(%ebp)
  80287f:	74 5f                	je     8028e0 <dhcp_get_option_ptr+0xf4>
        options = (u8_t *)&dhcp->msg_in->sname;
  802881:	8b 45 e8             	mov    -0x18(%ebp),%eax
  802884:	8b 48 10             	mov    0x10(%eax),%ecx
  802887:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80288a:	bf c0 00 00 00       	mov    $0xc0,%edi
      offset = 0;
  80288f:	ba 00 00 00 00       	mov    $0x0,%edx
  802894:	89 f0                	mov    %esi,%eax
  802896:	88 45 f0             	mov    %al,-0x10(%ebp)
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802899:	0f b7 c2             	movzwl %dx,%eax
  80289c:	01 c8                	add    %ecx,%eax
  80289e:	0f b6 30             	movzbl (%eax),%esi
  8028a1:	89 f3                	mov    %esi,%ebx
  8028a3:	80 fb ff             	cmp    $0xff,%bl
  8028a6:	74 48                	je     8028f0 <dhcp_get_option_ptr+0x104>
        if (options[offset] == option_type) {
  8028a8:	89 f3                	mov    %esi,%ebx
  8028aa:	3a 5d f0             	cmp    -0x10(%ebp),%bl
  8028ad:	0f 84 67 ff ff ff    	je     80281a <dhcp_get_option_ptr+0x2e>
          offset++;
  8028b3:	8d 42 01             	lea    0x1(%edx),%eax
          offset += 1 + options[offset];
  8028b6:	0f b7 c0             	movzwl %ax,%eax
  8028b9:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  8028bd:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8028c1:	66 39 d7             	cmp    %dx,%di
  8028c4:	77 d3                	ja     802899 <dhcp_get_option_ptr+0xad>
  return NULL;
  8028c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8028cb:	e9 4a ff ff ff       	jmp    80281a <dhcp_get_option_ptr+0x2e>
        options = (u8_t *)&dhcp->msg_in->file;
  8028d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8028d3:	8b 48 10             	mov    0x10(%eax),%ecx
  8028d6:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  8028d9:	bf 80 00 00 00       	mov    $0x80,%edi
  8028de:	eb af                	jmp    80288f <dhcp_get_option_ptr+0xa3>
        options = (u8_t *)&dhcp->msg_in->sname;
  8028e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8028e3:	8b 48 10             	mov    0x10(%eax),%ecx
  8028e6:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  8028e9:	bf 40 00 00 00       	mov    $0x40,%edi
  8028ee:	eb 9f                	jmp    80288f <dhcp_get_option_ptr+0xa3>
  return NULL;
  8028f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8028f5:	e9 20 ff ff ff       	jmp    80281a <dhcp_get_option_ptr+0x2e>

008028fa <dhcp_get_option_long>:
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  8028fa:	0f b6 10             	movzbl (%eax),%edx
  8028fd:	89 d1                	mov    %edx,%ecx
  8028ff:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802902:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802906:	c1 e2 10             	shl    $0x10,%edx
  802909:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  80290b:	0f b6 48 03          	movzbl 0x3(%eax),%ecx
  80290f:	09 ca                	or     %ecx,%edx
  value |= (u32_t)(*ptr++) << 8;
  802911:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  802915:	c1 e0 08             	shl    $0x8,%eax
  value |= (u32_t)(*ptr++);
  802918:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  80291a:	c3                   	ret    

0080291b <dhcp_option_byte>:
{
  80291b:	55                   	push   %ebp
  80291c:	89 e5                	mov    %esp,%ebp
  80291e:	56                   	push   %esi
  80291f:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802920:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802924:	66 83 f9 43          	cmp    $0x43,%cx
  802928:	77 1b                	ja     802945 <dhcp_option_byte+0x2a>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80292a:	8b 58 20             	mov    0x20(%eax),%ebx
  80292d:	8d 71 01             	lea    0x1(%ecx),%esi
  802930:	66 89 70 24          	mov    %si,0x24(%eax)
  802934:	0f b7 c9             	movzwl %cx,%ecx
  802937:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  80293e:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802941:	5b                   	pop    %ebx
  802942:	5e                   	pop    %esi
  802943:	5d                   	pop    %ebp
  802944:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802945:	83 ec 04             	sub    $0x4,%esp
  802948:	68 b4 17 81 00       	push   $0x8117b4
  80294d:	68 65 04 00 00       	push   $0x465
  802952:	68 02 1b 81 00       	push   $0x811b02
  802957:	e8 3d bd 00 00       	call   80e699 <_panic>

0080295c <dhcp_option>:
{
  80295c:	55                   	push   %ebp
  80295d:	89 e5                	mov    %esp,%ebp
  80295f:	57                   	push   %edi
  802960:	56                   	push   %esi
  802961:	53                   	push   %ebx
  802962:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802965:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802969:	0f b6 f9             	movzbl %cl,%edi
  80296c:	0f b7 f3             	movzwl %bx,%esi
  80296f:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802973:	83 fe 44             	cmp    $0x44,%esi
  802976:	77 34                	ja     8029ac <dhcp_option+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802978:	8b 70 20             	mov    0x20(%eax),%esi
  80297b:	8d 7b 01             	lea    0x1(%ebx),%edi
  80297e:	66 89 78 24          	mov    %di,0x24(%eax)
  802982:	0f b7 db             	movzwl %bx,%ebx
  802985:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80298c:	8b 58 20             	mov    0x20(%eax),%ebx
  80298f:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802993:	8d 72 01             	lea    0x1(%edx),%esi
  802996:	66 89 70 24          	mov    %si,0x24(%eax)
  80299a:	0f b7 d2             	movzwl %dx,%edx
  80299d:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  8029a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8029a7:	5b                   	pop    %ebx
  8029a8:	5e                   	pop    %esi
  8029a9:	5f                   	pop    %edi
  8029aa:	5d                   	pop    %ebp
  8029ab:	c3                   	ret    
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8029ac:	83 ec 04             	sub    $0x4,%esp
  8029af:	68 f0 17 81 00       	push   $0x8117f0
  8029b4:	68 5a 04 00 00       	push   $0x45a
  8029b9:	68 02 1b 81 00       	push   $0x811b02
  8029be:	e8 d6 bc 00 00       	call   80e699 <_panic>

008029c3 <dhcp_option_short>:
{
  8029c3:	55                   	push   %ebp
  8029c4:	89 e5                	mov    %esp,%ebp
  8029c6:	56                   	push   %esi
  8029c7:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  8029c8:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029cc:	0f b7 d9             	movzwl %cx,%ebx
  8029cf:	83 c3 02             	add    $0x2,%ebx
  8029d2:	83 fb 44             	cmp    $0x44,%ebx
  8029d5:	77 33                	ja     802a0a <dhcp_option_short+0x47>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  8029d7:	8b 58 20             	mov    0x20(%eax),%ebx
  8029da:	8d 71 01             	lea    0x1(%ecx),%esi
  8029dd:	66 89 70 24          	mov    %si,0x24(%eax)
  8029e1:	0f b7 c9             	movzwl %cx,%ecx
  8029e4:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  8029eb:	8b 58 20             	mov    0x20(%eax),%ebx
  8029ee:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8029f2:	8d 71 01             	lea    0x1(%ecx),%esi
  8029f5:	66 89 70 24          	mov    %si,0x24(%eax)
  8029f9:	0f b7 c9             	movzwl %cx,%ecx
  8029fc:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802a03:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802a06:	5b                   	pop    %ebx
  802a07:	5e                   	pop    %esi
  802a08:	5d                   	pop    %ebp
  802a09:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802a0a:	83 ec 04             	sub    $0x4,%esp
  802a0d:	68 38 18 81 00       	push   $0x811838
  802a12:	68 6c 04 00 00       	push   $0x46c
  802a17:	68 02 1b 81 00       	push   $0x811b02
  802a1c:	e8 78 bc 00 00       	call   80e699 <_panic>

00802a21 <dhcp_option_trailer>:
{
  802a21:	55                   	push   %ebp
  802a22:	89 e5                	mov    %esp,%ebp
  802a24:	53                   	push   %ebx
  802a25:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a28:	85 c0                	test   %eax,%eax
  802a2a:	74 25                	je     802a51 <dhcp_option_trailer+0x30>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a2c:	8b 48 20             	mov    0x20(%eax),%ecx
  802a2f:	85 c9                	test   %ecx,%ecx
  802a31:	74 35                	je     802a68 <dhcp_option_trailer+0x47>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a33:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802a37:	66 83 fa 43          	cmp    $0x43,%dx
  802a3b:	77 42                	ja     802a7f <dhcp_option_trailer+0x5e>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802a3d:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a40:	66 89 58 24          	mov    %bx,0x24(%eax)
  802a44:	0f b7 d2             	movzwl %dx,%edx
  802a47:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802a4e:	ff 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802a4f:	eb 5a                	jmp    802aab <dhcp_option_trailer+0x8a>
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802a51:	83 ec 04             	sub    $0x4,%esp
  802a54:	68 7c 18 81 00       	push   $0x81187c
  802a59:	68 80 05 00 00       	push   $0x580
  802a5e:	68 02 1b 81 00       	push   $0x811b02
  802a63:	e8 31 bc 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802a68:	83 ec 04             	sub    $0x4,%esp
  802a6b:	68 a0 18 81 00       	push   $0x8118a0
  802a70:	68 81 05 00 00       	push   $0x581
  802a75:	68 02 1b 81 00       	push   $0x811b02
  802a7a:	e8 1a bc 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802a7f:	83 ec 04             	sub    $0x4,%esp
  802a82:	68 cc 18 81 00       	push   $0x8118cc
  802a87:	68 82 05 00 00       	push   $0x582
  802a8c:	68 02 1b 81 00       	push   $0x811b02
  802a91:	e8 03 bc 00 00       	call   80e699 <_panic>
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802a96:	8b 48 20             	mov    0x20(%eax),%ecx
  802a99:	8d 5a 01             	lea    0x1(%edx),%ebx
  802a9c:	66 89 58 24          	mov    %bx,0x24(%eax)
  802aa0:	0f b7 d2             	movzwl %dx,%edx
  802aa3:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802aaa:	00 
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802aab:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802aaf:	66 83 fa 43          	cmp    $0x43,%dx
  802ab3:	76 e1                	jbe    802a96 <dhcp_option_trailer+0x75>
  802ab5:	f6 c2 03             	test   $0x3,%dl
  802ab8:	74 17                	je     802ad1 <dhcp_option_trailer+0xb0>
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802aba:	83 ec 04             	sub    $0x4,%esp
  802abd:	68 cc 18 81 00       	push   $0x8118cc
  802ac2:	68 87 05 00 00       	push   $0x587
  802ac7:	68 02 1b 81 00       	push   $0x811b02
  802acc:	e8 c8 bb 00 00       	call   80e699 <_panic>
}
  802ad1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802ad4:	c9                   	leave  
  802ad5:	c3                   	ret    

00802ad6 <dhcp_option_long>:
{
  802ad6:	55                   	push   %ebp
  802ad7:	89 e5                	mov    %esp,%ebp
  802ad9:	56                   	push   %esi
  802ada:	53                   	push   %ebx
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802adb:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802adf:	0f b7 d9             	movzwl %cx,%ebx
  802ae2:	83 c3 04             	add    $0x4,%ebx
  802ae5:	83 fb 44             	cmp    $0x44,%ebx
  802ae8:	77 6d                	ja     802b57 <dhcp_option_long+0x81>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802aea:	8d 71 01             	lea    0x1(%ecx),%esi
  802aed:	66 89 70 24          	mov    %si,0x24(%eax)
  802af1:	0f b7 c9             	movzwl %cx,%ecx
  802af4:	89 d3                	mov    %edx,%ebx
  802af6:	c1 eb 18             	shr    $0x18,%ebx
  802af9:	8b 70 20             	mov    0x20(%eax),%esi
  802afc:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802b03:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b07:	8d 71 01             	lea    0x1(%ecx),%esi
  802b0a:	66 89 70 24          	mov    %si,0x24(%eax)
  802b0e:	0f b7 c9             	movzwl %cx,%ecx
  802b11:	89 d3                	mov    %edx,%ebx
  802b13:	c1 eb 10             	shr    $0x10,%ebx
  802b16:	8b 70 20             	mov    0x20(%eax),%esi
  802b19:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802b20:	8b 58 20             	mov    0x20(%eax),%ebx
  802b23:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b27:	8d 71 01             	lea    0x1(%ecx),%esi
  802b2a:	66 89 70 24          	mov    %si,0x24(%eax)
  802b2e:	0f b7 c9             	movzwl %cx,%ecx
  802b31:	88 b4 0b f0 00 00 00 	mov    %dh,0xf0(%ebx,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802b38:	8b 58 20             	mov    0x20(%eax),%ebx
  802b3b:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802b3f:	8d 71 01             	lea    0x1(%ecx),%esi
  802b42:	66 89 70 24          	mov    %si,0x24(%eax)
  802b46:	0f b7 c9             	movzwl %cx,%ecx
  802b49:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802b50:	8d 65 f8             	lea    -0x8(%ebp),%esp
  802b53:	5b                   	pop    %ebx
  802b54:	5e                   	pop    %esi
  802b55:	5d                   	pop    %ebp
  802b56:	c3                   	ret    
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802b57:	83 ec 04             	sub    $0x4,%esp
  802b5a:	68 0c 19 81 00       	push   $0x81190c
  802b5f:	68 74 04 00 00       	push   $0x474
  802b64:	68 02 1b 81 00       	push   $0x811b02
  802b69:	e8 2b bb 00 00       	call   80e699 <_panic>

00802b6e <dhcp_create_request>:
{
  802b6e:	55                   	push   %ebp
  802b6f:	89 e5                	mov    %esp,%ebp
  802b71:	57                   	push   %edi
  802b72:	56                   	push   %esi
  802b73:	53                   	push   %ebx
  802b74:	83 ec 0c             	sub    $0xc,%esp
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802b77:	85 c0                	test   %eax,%eax
  802b79:	0f 84 d8 00 00 00    	je     802c57 <dhcp_create_request+0xe9>
  802b7f:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  802b81:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802b84:	85 db                	test   %ebx,%ebx
  802b86:	0f 84 e2 00 00 00    	je     802c6e <dhcp_create_request+0x100>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802b8c:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802b90:	0f 85 ef 00 00 00    	jne    802c85 <dhcp_create_request+0x117>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802b96:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802b9a:	0f 85 fc 00 00 00    	jne    802c9c <dhcp_create_request+0x12e>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  802ba0:	83 ec 04             	sub    $0x4,%esp
  802ba3:	6a 00                	push   $0x0
  802ba5:	68 34 01 00 00       	push   $0x134
  802baa:	6a 00                	push   $0x0
  802bac:	e8 9f 1d 00 00       	call   804950 <pbuf_alloc>
  802bb1:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  802bb4:	83 c4 10             	add    $0x10,%esp
  802bb7:	85 c0                	test   %eax,%eax
  802bb9:	0f 84 9b 01 00 00    	je     802d5a <dhcp_create_request+0x1ec>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802bbf:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  802bc5:	0f 86 e8 00 00 00    	jbe    802cb3 <dhcp_create_request+0x145>
  dhcp->xid = xid++;
  802bcb:	8b 15 04 40 81 00    	mov    0x814004,%edx
  802bd1:	8d 4a 01             	lea    0x1(%edx),%ecx
  802bd4:	89 0d 04 40 81 00    	mov    %ecx,0x814004
  802bda:	89 53 04             	mov    %edx,0x4(%ebx)
  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  802bdd:	8b 40 04             	mov    0x4(%eax),%eax
  802be0:	89 43 20             	mov    %eax,0x20(%ebx)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  802be3:	c6 00 01             	movb   $0x1,(%eax)
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  802be6:	8b 43 20             	mov    0x20(%ebx),%eax
  802be9:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  802bed:	8b 43 20             	mov    0x20(%ebx),%eax
  802bf0:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  802bf4:	8b 43 20             	mov    0x20(%ebx),%eax
  802bf7:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  802bfb:	8b 7b 20             	mov    0x20(%ebx),%edi
  802bfe:	83 ec 0c             	sub    $0xc,%esp
  802c01:	ff 73 04             	pushl  0x4(%ebx)
  802c04:	e8 75 4b 00 00       	call   80777e <htonl>
  802c09:	89 47 04             	mov    %eax,0x4(%edi)
  dhcp->msg_out->secs = 0;
  802c0c:	8b 43 20             	mov    0x20(%ebx),%eax
  802c0f:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  802c15:	8b 43 20             	mov    0x20(%ebx),%eax
  802c18:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  802c1e:	8b 43 20             	mov    0x20(%ebx),%eax
  802c21:	8b 56 04             	mov    0x4(%esi),%edx
  802c24:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  802c27:	8b 43 20             	mov    0x20(%ebx),%eax
  802c2a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  802c31:	8b 43 20             	mov    0x20(%ebx),%eax
  802c34:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  802c3b:	8b 43 20             	mov    0x20(%ebx),%eax
  802c3e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  802c45:	83 c4 10             	add    $0x10,%esp
  802c48:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802c4d:	bf 00 00 00 00       	mov    $0x0,%edi
  802c52:	e9 82 00 00 00       	jmp    802cd9 <dhcp_create_request+0x16b>
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802c57:	83 ec 04             	sub    $0x4,%esp
  802c5a:	68 4c 19 81 00       	push   $0x81194c
  802c5f:	68 2d 05 00 00       	push   $0x52d
  802c64:	68 02 1b 81 00       	push   $0x811b02
  802c69:	e8 2b ba 00 00       	call   80e699 <_panic>
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802c6e:	83 ec 04             	sub    $0x4,%esp
  802c71:	68 70 19 81 00       	push   $0x811970
  802c76:	68 2f 05 00 00       	push   $0x52f
  802c7b:	68 02 1b 81 00       	push   $0x811b02
  802c80:	e8 14 ba 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802c85:	83 ec 04             	sub    $0x4,%esp
  802c88:	68 94 19 81 00       	push   $0x811994
  802c8d:	68 30 05 00 00       	push   $0x530
  802c92:	68 02 1b 81 00       	push   $0x811b02
  802c97:	e8 fd b9 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  802c9c:	83 ec 04             	sub    $0x4,%esp
  802c9f:	68 c0 19 81 00       	push   $0x8119c0
  802ca4:	68 31 05 00 00       	push   $0x531
  802ca9:	68 02 1b 81 00       	push   $0x811b02
  802cae:	e8 e6 b9 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  802cb3:	83 ec 04             	sub    $0x4,%esp
  802cb6:	68 ec 19 81 00       	push   $0x8119ec
  802cbb:	68 38 05 00 00       	push   $0x538
  802cc0:	68 02 1b 81 00       	push   $0x811b02
  802cc5:	e8 cf b9 00 00       	call   80e699 <_panic>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cca:	8b 4b 20             	mov    0x20(%ebx),%ecx
  802ccd:	88 54 01 1c          	mov    %dl,0x1c(%ecx,%eax,1)
  802cd1:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  802cd4:	83 f8 10             	cmp    $0x10,%eax
  802cd7:	74 12                	je     802ceb <dhcp_create_request+0x17d>
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  802cd9:	0f b6 4e 24          	movzbl 0x24(%esi),%ecx
  802cdd:	89 fa                	mov    %edi,%edx
  802cdf:	66 39 c1             	cmp    %ax,%cx
  802ce2:	76 e6                	jbe    802cca <dhcp_create_request+0x15c>
  802ce4:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  802ce9:	eb df                	jmp    802cca <dhcp_create_request+0x15c>
  802ceb:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->sname[i] = 0;
  802cf0:	8b 53 20             	mov    0x20(%ebx),%edx
  802cf3:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  802cf8:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  802cfb:	83 f8 40             	cmp    $0x40,%eax
  802cfe:	75 f0                	jne    802cf0 <dhcp_create_request+0x182>
  802d00:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->file[i] = 0;
  802d05:	8b 53 20             	mov    0x20(%ebx),%edx
  802d08:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  802d0d:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  802d10:	3d 80 00 00 00       	cmp    $0x80,%eax
  802d15:	75 ee                	jne    802d05 <dhcp_create_request+0x197>
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  802d17:	8b 73 20             	mov    0x20(%ebx),%esi
  802d1a:	83 ec 0c             	sub    $0xc,%esp
  802d1d:	68 63 53 82 63       	push   $0x63825363
  802d22:	e8 57 4a 00 00       	call   80777e <htonl>
  802d27:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  802d2d:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  802d33:	83 c4 10             	add    $0x10,%esp
  802d36:	b8 00 00 00 00       	mov    $0x0,%eax
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  802d3b:	8b 53 20             	mov    0x20(%ebx),%edx
  802d3e:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  802d45:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  802d48:	83 f8 44             	cmp    $0x44,%eax
  802d4b:	75 ee                	jne    802d3b <dhcp_create_request+0x1cd>
  return ERR_OK;
  802d4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802d52:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802d55:	5b                   	pop    %ebx
  802d56:	5e                   	pop    %esi
  802d57:	5f                   	pop    %edi
  802d58:	5d                   	pop    %ebp
  802d59:	c3                   	ret    
    return ERR_MEM;
  802d5a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802d5f:	eb f1                	jmp    802d52 <dhcp_create_request+0x1e4>

00802d61 <dhcp_delete_request>:
{
  802d61:	55                   	push   %ebp
  802d62:	89 e5                	mov    %esp,%ebp
  802d64:	53                   	push   %ebx
  802d65:	83 ec 04             	sub    $0x4,%esp
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d68:	85 c0                	test   %eax,%eax
  802d6a:	74 33                	je     802d9f <dhcp_delete_request+0x3e>
  dhcp = netif->dhcp;
  802d6c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802d6f:	85 db                	test   %ebx,%ebx
  802d71:	74 43                	je     802db6 <dhcp_delete_request+0x55>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802d73:	8b 43 1c             	mov    0x1c(%ebx),%eax
  802d76:	85 c0                	test   %eax,%eax
  802d78:	74 53                	je     802dcd <dhcp_delete_request+0x6c>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802d7a:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  802d7e:	74 64                	je     802de4 <dhcp_delete_request+0x83>
    pbuf_free(dhcp->p_out);
  802d80:	83 ec 0c             	sub    $0xc,%esp
  802d83:	50                   	push   %eax
  802d84:	e8 01 1b 00 00       	call   80488a <pbuf_free>
  dhcp->p_out = NULL;
  802d89:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  802d90:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  802d97:	83 c4 10             	add    $0x10,%esp
}
  802d9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  802d9d:	c9                   	leave  
  802d9e:	c3                   	ret    
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  802d9f:	83 ec 04             	sub    $0x4,%esp
  802da2:	68 30 1a 81 00       	push   $0x811a30
  802da7:	68 69 05 00 00       	push   $0x569
  802dac:	68 02 1b 81 00       	push   $0x811b02
  802db1:	e8 e3 b8 00 00       	call   80e699 <_panic>
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  802db6:	83 ec 04             	sub    $0x4,%esp
  802db9:	68 54 1a 81 00       	push   $0x811a54
  802dbe:	68 6b 05 00 00       	push   $0x56b
  802dc3:	68 02 1b 81 00       	push   $0x811b02
  802dc8:	e8 cc b8 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  802dcd:	83 ec 04             	sub    $0x4,%esp
  802dd0:	68 78 1a 81 00       	push   $0x811a78
  802dd5:	68 6c 05 00 00       	push   $0x56c
  802dda:	68 02 1b 81 00       	push   $0x811b02
  802ddf:	e8 b5 b8 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  802de4:	83 ec 04             	sub    $0x4,%esp
  802de7:	68 a4 1a 81 00       	push   $0x811aa4
  802dec:	68 6d 05 00 00       	push   $0x56d
  802df1:	68 02 1b 81 00       	push   $0x811b02
  802df6:	e8 9e b8 00 00       	call   80e699 <_panic>

00802dfb <dhcp_rebind>:
{
  802dfb:	55                   	push   %ebp
  802dfc:	89 e5                	mov    %esp,%ebp
  802dfe:	57                   	push   %edi
  802dff:	56                   	push   %esi
  802e00:	53                   	push   %ebx
  802e01:	83 ec 0c             	sub    $0xc,%esp
  802e04:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802e06:	8b 58 20             	mov    0x20(%eax),%ebx
  dhcp_set_state(dhcp, DHCP_REBINDING);
  802e09:	ba 04 00 00 00       	mov    $0x4,%edx
  802e0e:	89 d8                	mov    %ebx,%eax
  802e10:	e8 cc f9 ff ff       	call   8027e1 <dhcp_set_state>
  result = dhcp_create_request(netif);
  802e15:	89 f8                	mov    %edi,%eax
  802e17:	e8 52 fd ff ff       	call   802b6e <dhcp_create_request>
  802e1c:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802e1e:	84 c0                	test   %al,%al
  802e20:	74 3e                	je     802e60 <dhcp_rebind+0x65>
  dhcp->tries++;
  802e22:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802e26:	83 c0 01             	add    $0x1,%eax
  802e29:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  802e2c:	ba 10 27 00 00       	mov    $0x2710,%edx
  802e31:	3c 09                	cmp    $0x9,%al
  802e33:	77 08                	ja     802e3d <dhcp_rebind+0x42>
  802e35:	0f b6 d0             	movzbl %al,%edx
  802e38:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802e3d:	0f b7 d2             	movzwl %dx,%edx
  802e40:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802e46:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802e4b:	89 d0                	mov    %edx,%eax
  802e4d:	f7 e9                	imul   %ecx
  802e4f:	c1 fa 05             	sar    $0x5,%edx
  802e52:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802e56:	89 f0                	mov    %esi,%eax
  802e58:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802e5b:	5b                   	pop    %ebx
  802e5c:	5e                   	pop    %esi
  802e5d:	5f                   	pop    %edi
  802e5e:	5d                   	pop    %ebp
  802e5f:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802e60:	b9 01 00 00 00       	mov    $0x1,%ecx
  802e65:	ba 35 00 00 00       	mov    $0x35,%edx
  802e6a:	89 d8                	mov    %ebx,%eax
  802e6c:	e8 eb fa ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  802e71:	ba 03 00 00 00       	mov    $0x3,%edx
  802e76:	89 d8                	mov    %ebx,%eax
  802e78:	e8 9e fa ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802e7d:	b9 02 00 00 00       	mov    $0x2,%ecx
  802e82:	ba 39 00 00 00       	mov    $0x39,%edx
  802e87:	89 d8                	mov    %ebx,%eax
  802e89:	e8 ce fa ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802e8e:	ba 40 02 00 00       	mov    $0x240,%edx
  802e93:	89 d8                	mov    %ebx,%eax
  802e95:	e8 29 fb ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  802e9a:	89 d8                	mov    %ebx,%eax
  802e9c:	e8 80 fb ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802ea1:	83 ec 08             	sub    $0x8,%esp
  802ea4:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802ea8:	66 05 f0 00          	add    $0xf0,%ax
  802eac:	0f b7 c0             	movzwl %ax,%eax
  802eaf:	50                   	push   %eax
  802eb0:	ff 73 1c             	pushl  0x1c(%ebx)
  802eb3:	e8 0a 1d 00 00       	call   804bc2 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802eb8:	83 c4 0c             	add    $0xc,%esp
  802ebb:	6a 43                	push   $0x43
  802ebd:	68 a8 23 81 00       	push   $0x8123a8
  802ec2:	ff 73 08             	pushl  0x8(%ebx)
  802ec5:	e8 ad 60 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802eca:	89 3c 24             	mov    %edi,(%esp)
  802ecd:	6a 43                	push   $0x43
  802ecf:	68 a4 23 81 00       	push   $0x8123a4
  802ed4:	ff 73 1c             	pushl  0x1c(%ebx)
  802ed7:	ff 73 08             	pushl  0x8(%ebx)
  802eda:	e8 a3 5e 00 00       	call   808d82 <udp_sendto_if>
    dhcp_delete_request(netif);
  802edf:	83 c4 20             	add    $0x20,%esp
  802ee2:	89 f8                	mov    %edi,%eax
  802ee4:	e8 78 fe ff ff       	call   802d61 <dhcp_delete_request>
  802ee9:	e9 34 ff ff ff       	jmp    802e22 <dhcp_rebind+0x27>

00802eee <dhcp_discover>:
{
  802eee:	55                   	push   %ebp
  802eef:	89 e5                	mov    %esp,%ebp
  802ef1:	57                   	push   %edi
  802ef2:	56                   	push   %esi
  802ef3:	53                   	push   %ebx
  802ef4:	83 ec 0c             	sub    $0xc,%esp
  802ef7:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  802ef9:	8b 58 20             	mov    0x20(%eax),%ebx
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  802efc:	a1 a8 23 81 00       	mov    0x8123a8,%eax
  802f01:	89 43 30             	mov    %eax,0x30(%ebx)
  result = dhcp_create_request(netif);
  802f04:	89 f8                	mov    %edi,%eax
  802f06:	e8 63 fc ff ff       	call   802b6e <dhcp_create_request>
  802f0b:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  802f0d:	84 c0                	test   %al,%al
  802f0f:	74 41                	je     802f52 <dhcp_discover+0x64>
  dhcp->tries++;
  802f11:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  802f15:	83 c0 01             	add    $0x1,%eax
  802f18:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  802f1b:	ba 10 27 00 00       	mov    $0x2710,%edx
  802f20:	3c 03                	cmp    $0x3,%al
  802f22:	77 0b                	ja     802f2f <dhcp_discover+0x41>
  802f24:	0f b6 d0             	movzbl %al,%edx
  802f27:	83 c2 01             	add    $0x1,%edx
  802f2a:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  802f2f:	0f b7 d2             	movzwl %dx,%edx
  802f32:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  802f38:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  802f3d:	89 d0                	mov    %edx,%eax
  802f3f:	f7 e9                	imul   %ecx
  802f41:	c1 fa 05             	sar    $0x5,%edx
  802f44:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  802f48:	89 f0                	mov    %esi,%eax
  802f4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  802f4d:	5b                   	pop    %ebx
  802f4e:	5e                   	pop    %esi
  802f4f:	5f                   	pop    %edi
  802f50:	5d                   	pop    %ebp
  802f51:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  802f52:	b9 01 00 00 00       	mov    $0x1,%ecx
  802f57:	ba 35 00 00 00       	mov    $0x35,%edx
  802f5c:	89 d8                	mov    %ebx,%eax
  802f5e:	e8 f9 f9 ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  802f63:	ba 01 00 00 00       	mov    $0x1,%edx
  802f68:	89 d8                	mov    %ebx,%eax
  802f6a:	e8 ac f9 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  802f6f:	b9 02 00 00 00       	mov    $0x2,%ecx
  802f74:	ba 39 00 00 00       	mov    $0x39,%edx
  802f79:	89 d8                	mov    %ebx,%eax
  802f7b:	e8 dc f9 ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  802f80:	ba 40 02 00 00       	mov    $0x240,%edx
  802f85:	89 d8                	mov    %ebx,%eax
  802f87:	e8 37 fa ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  802f8c:	b9 04 00 00 00       	mov    $0x4,%ecx
  802f91:	ba 37 00 00 00       	mov    $0x37,%edx
  802f96:	89 d8                	mov    %ebx,%eax
  802f98:	e8 bf f9 ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  802f9d:	ba 01 00 00 00       	mov    $0x1,%edx
  802fa2:	89 d8                	mov    %ebx,%eax
  802fa4:	e8 72 f9 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  802fa9:	ba 03 00 00 00       	mov    $0x3,%edx
  802fae:	89 d8                	mov    %ebx,%eax
  802fb0:	e8 66 f9 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  802fb5:	ba 1c 00 00 00       	mov    $0x1c,%edx
  802fba:	89 d8                	mov    %ebx,%eax
  802fbc:	e8 5a f9 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  802fc1:	ba 06 00 00 00       	mov    $0x6,%edx
  802fc6:	89 d8                	mov    %ebx,%eax
  802fc8:	e8 4e f9 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  802fcd:	89 d8                	mov    %ebx,%eax
  802fcf:	e8 4d fa ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  802fd4:	83 ec 08             	sub    $0x8,%esp
  802fd7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  802fdb:	66 05 f0 00          	add    $0xf0,%ax
  802fdf:	0f b7 c0             	movzwl %ax,%eax
  802fe2:	50                   	push   %eax
  802fe3:	ff 73 1c             	pushl  0x1c(%ebx)
  802fe6:	e8 d7 1b 00 00       	call   804bc2 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  802feb:	83 c4 0c             	add    $0xc,%esp
  802fee:	6a 43                	push   $0x43
  802ff0:	68 a8 23 81 00       	push   $0x8123a8
  802ff5:	ff 73 08             	pushl  0x8(%ebx)
  802ff8:	e8 7a 5f 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  802ffd:	89 3c 24             	mov    %edi,(%esp)
  803000:	6a 43                	push   $0x43
  803002:	68 a4 23 81 00       	push   $0x8123a4
  803007:	ff 73 1c             	pushl  0x1c(%ebx)
  80300a:	ff 73 08             	pushl  0x8(%ebx)
  80300d:	e8 70 5d 00 00       	call   808d82 <udp_sendto_if>
    dhcp_delete_request(netif);
  803012:	83 c4 20             	add    $0x20,%esp
  803015:	89 f8                	mov    %edi,%eax
  803017:	e8 45 fd ff ff       	call   802d61 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80301c:	ba 06 00 00 00       	mov    $0x6,%edx
  803021:	89 d8                	mov    %ebx,%eax
  803023:	e8 b9 f7 ff ff       	call   8027e1 <dhcp_set_state>
  803028:	e9 e4 fe ff ff       	jmp    802f11 <dhcp_discover+0x23>

0080302d <dhcp_select>:
{
  80302d:	55                   	push   %ebp
  80302e:	89 e5                	mov    %esp,%ebp
  803030:	57                   	push   %edi
  803031:	56                   	push   %esi
  803032:	53                   	push   %ebx
  803033:	83 ec 0c             	sub    $0xc,%esp
  803036:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803038:	8b 58 20             	mov    0x20(%eax),%ebx
  result = dhcp_create_request(netif);
  80303b:	e8 2e fb ff ff       	call   802b6e <dhcp_create_request>
  803040:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803042:	84 c0                	test   %al,%al
  803044:	74 3e                	je     803084 <dhcp_select+0x57>
  dhcp->tries++;
  803046:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80304a:	83 c0 01             	add    $0x1,%eax
  80304d:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  803050:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  803055:	3c 03                	cmp    $0x3,%al
  803057:	77 08                	ja     803061 <dhcp_select+0x34>
  803059:	0f b6 d0             	movzbl %al,%edx
  80305c:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803061:	0f b7 d2             	movzwl %dx,%edx
  803064:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80306a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80306f:	89 d0                	mov    %edx,%eax
  803071:	f7 e9                	imul   %ecx
  803073:	c1 fa 05             	sar    $0x5,%edx
  803076:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  80307a:	89 f0                	mov    %esi,%eax
  80307c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80307f:	5b                   	pop    %ebx
  803080:	5e                   	pop    %esi
  803081:	5f                   	pop    %edi
  803082:	5d                   	pop    %ebp
  803083:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803084:	b9 01 00 00 00       	mov    $0x1,%ecx
  803089:	ba 35 00 00 00       	mov    $0x35,%edx
  80308e:	89 d8                	mov    %ebx,%eax
  803090:	e8 c7 f8 ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803095:	ba 03 00 00 00       	mov    $0x3,%edx
  80309a:	89 d8                	mov    %ebx,%eax
  80309c:	e8 7a f8 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8030a1:	b9 02 00 00 00       	mov    $0x2,%ecx
  8030a6:	ba 39 00 00 00       	mov    $0x39,%edx
  8030ab:	89 d8                	mov    %ebx,%eax
  8030ad:	e8 aa f8 ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8030b2:	ba 40 02 00 00       	mov    $0x240,%edx
  8030b7:	89 d8                	mov    %ebx,%eax
  8030b9:	e8 05 f9 ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8030be:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030c3:	ba 32 00 00 00       	mov    $0x32,%edx
  8030c8:	89 d8                	mov    %ebx,%eax
  8030ca:	e8 8d f8 ff ff       	call   80295c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8030cf:	83 ec 0c             	sub    $0xc,%esp
  8030d2:	ff 73 30             	pushl  0x30(%ebx)
  8030d5:	e8 bb 48 00 00       	call   807995 <ntohl>
  8030da:	89 c2                	mov    %eax,%edx
  8030dc:	89 d8                	mov    %ebx,%eax
  8030de:	e8 f3 f9 ff ff       	call   802ad6 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8030e3:	b9 04 00 00 00       	mov    $0x4,%ecx
  8030e8:	ba 36 00 00 00       	mov    $0x36,%edx
  8030ed:	89 d8                	mov    %ebx,%eax
  8030ef:	e8 68 f8 ff ff       	call   80295c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8030f4:	83 c4 04             	add    $0x4,%esp
  8030f7:	ff 73 2c             	pushl  0x2c(%ebx)
  8030fa:	e8 96 48 00 00       	call   807995 <ntohl>
  8030ff:	89 c2                	mov    %eax,%edx
  803101:	89 d8                	mov    %ebx,%eax
  803103:	e8 ce f9 ff ff       	call   802ad6 <dhcp_option_long>
    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  803108:	b9 04 00 00 00       	mov    $0x4,%ecx
  80310d:	ba 37 00 00 00       	mov    $0x37,%edx
  803112:	89 d8                	mov    %ebx,%eax
  803114:	e8 43 f8 ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  803119:	ba 01 00 00 00       	mov    $0x1,%edx
  80311e:	89 d8                	mov    %ebx,%eax
  803120:	e8 f6 f7 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  803125:	ba 03 00 00 00       	mov    $0x3,%edx
  80312a:	89 d8                	mov    %ebx,%eax
  80312c:	e8 ea f7 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803131:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803136:	89 d8                	mov    %ebx,%eax
  803138:	e8 de f7 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80313d:	ba 06 00 00 00       	mov    $0x6,%edx
  803142:	89 d8                	mov    %ebx,%eax
  803144:	e8 d2 f7 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803149:	89 d8                	mov    %ebx,%eax
  80314b:	e8 d1 f8 ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803150:	83 c4 08             	add    $0x8,%esp
  803153:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803157:	66 05 f0 00          	add    $0xf0,%ax
  80315b:	0f b7 c0             	movzwl %ax,%eax
  80315e:	50                   	push   %eax
  80315f:	ff 73 1c             	pushl  0x1c(%ebx)
  803162:	e8 5b 1a 00 00       	call   804bc2 <pbuf_realloc>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803167:	89 3c 24             	mov    %edi,(%esp)
  80316a:	6a 43                	push   $0x43
  80316c:	68 a4 23 81 00       	push   $0x8123a4
  803171:	ff 73 1c             	pushl  0x1c(%ebx)
  803174:	ff 73 08             	pushl  0x8(%ebx)
  803177:	e8 06 5c 00 00       	call   808d82 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80317c:	83 c4 1c             	add    $0x1c,%esp
  80317f:	6a 43                	push   $0x43
  803181:	68 a8 23 81 00       	push   $0x8123a8
  803186:	ff 73 08             	pushl  0x8(%ebx)
  803189:	e8 e9 5d 00 00       	call   808f77 <udp_connect>
    dhcp_delete_request(netif);
  80318e:	89 f8                	mov    %edi,%eax
  803190:	e8 cc fb ff ff       	call   802d61 <dhcp_delete_request>
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  803195:	ba 01 00 00 00       	mov    $0x1,%edx
  80319a:	89 d8                	mov    %ebx,%eax
  80319c:	e8 40 f6 ff ff       	call   8027e1 <dhcp_set_state>
  8031a1:	83 c4 10             	add    $0x10,%esp
  8031a4:	e9 9d fe ff ff       	jmp    803046 <dhcp_select+0x19>

008031a9 <dhcp_check>:
{
  8031a9:	55                   	push   %ebp
  8031aa:	89 e5                	mov    %esp,%ebp
  8031ac:	53                   	push   %ebx
  8031ad:	83 ec 08             	sub    $0x8,%esp
  struct dhcp *dhcp = netif->dhcp;
  8031b0:	8b 58 20             	mov    0x20(%eax),%ebx
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8031b3:	6a 00                	push   $0x0
  8031b5:	8d 53 30             	lea    0x30(%ebx),%edx
  8031b8:	52                   	push   %edx
  8031b9:	50                   	push   %eax
  8031ba:	e8 ac 67 00 00       	call   80996b <etharp_query>
  dhcp->tries++;
  8031bf:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8031c3:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8031c9:	ba 08 00 00 00       	mov    $0x8,%edx
  8031ce:	89 d8                	mov    %ebx,%eax
  8031d0:	e8 0c f6 ff ff       	call   8027e1 <dhcp_set_state>
}
  8031d5:	83 c4 10             	add    $0x10,%esp
  8031d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8031db:	c9                   	leave  
  8031dc:	c3                   	ret    

008031dd <dhcp_bind>:
{
  8031dd:	55                   	push   %ebp
  8031de:	89 e5                	mov    %esp,%ebp
  8031e0:	56                   	push   %esi
  8031e1:	53                   	push   %ebx
  8031e2:	83 ec 10             	sub    $0x10,%esp
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8031e5:	85 c0                	test   %eax,%eax
  8031e7:	0f 84 cf 00 00 00    	je     8032bc <dhcp_bind+0xdf>
  8031ed:	89 c6                	mov    %eax,%esi
  dhcp = netif->dhcp;
  8031ef:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8031f2:	85 db                	test   %ebx,%ebx
  8031f4:	0f 84 d9 00 00 00    	je     8032d3 <dhcp_bind+0xf6>
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  8031fa:	8b 53 50             	mov    0x50(%ebx),%edx
  8031fd:	83 fa ff             	cmp    $0xffffffff,%edx
  803200:	74 2a                	je     80322c <dhcp_bind+0x4f>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803202:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803205:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  80320b:	0f 87 74 01 00 00    	ja     803385 <dhcp_bind+0x1a8>
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803211:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803216:	89 d0                	mov    %edx,%eax
  803218:	f7 e1                	mul    %ecx
  80321a:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t1_timeout == 0) {
  80321d:	66 85 d2             	test   %dx,%dx
  803220:	0f 85 c4 00 00 00    	jne    8032ea <dhcp_bind+0x10d>
      dhcp->t1_timeout = 1;
  803226:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80322c:	8b 53 54             	mov    0x54(%ebx),%edx
  80322f:	83 fa ff             	cmp    $0xffffffff,%edx
  803232:	74 2a                	je     80325e <dhcp_bind+0x81>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803234:	83 c2 1e             	add    $0x1e,%edx
    if(timeout > 0xffff) {
  803237:	81 fa ff ff 3b 00    	cmp    $0x3bffff,%edx
  80323d:	0f 87 37 01 00 00    	ja     80337a <dhcp_bind+0x19d>
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  803243:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  803248:	89 d0                	mov    %edx,%eax
  80324a:	f7 e1                	mul    %ecx
  80324c:	c1 ea 05             	shr    $0x5,%edx
    if (dhcp->t2_timeout == 0) {
  80324f:	66 85 d2             	test   %dx,%dx
  803252:	0f 85 9b 00 00 00    	jne    8032f3 <dhcp_bind+0x116>
      dhcp->t2_timeout = 1;
  803258:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80325e:	8b 43 34             	mov    0x34(%ebx),%eax
  803261:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (sn_mask.addr == 0) {
  803264:	85 c0                	test   %eax,%eax
  803266:	0f 84 90 00 00 00    	je     8032fc <dhcp_bind+0x11f>
  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80326c:	8b 43 38             	mov    0x38(%ebx),%eax
  80326f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (gw_addr.addr == 0) {
  803272:	85 c0                	test   %eax,%eax
  803274:	0f 84 e2 00 00 00    	je     80335c <dhcp_bind+0x17f>
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80327a:	83 ec 08             	sub    $0x8,%esp
  80327d:	8d 43 30             	lea    0x30(%ebx),%eax
  803280:	50                   	push   %eax
  803281:	56                   	push   %esi
  803282:	e8 73 13 00 00       	call   8045fa <netif_set_ipaddr>
  netif_set_netmask(netif, &sn_mask);
  803287:	83 c4 08             	add    $0x8,%esp
  80328a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80328d:	50                   	push   %eax
  80328e:	56                   	push   %esi
  80328f:	e8 ab 14 00 00       	call   80473f <netif_set_netmask>
  netif_set_gw(netif, &gw_addr);
  803294:	83 c4 08             	add    $0x8,%esp
  803297:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80329a:	50                   	push   %eax
  80329b:	56                   	push   %esi
  80329c:	e8 85 14 00 00       	call   804726 <netif_set_gw>
  netif_set_up(netif);
  8032a1:	89 34 24             	mov    %esi,(%esp)
  8032a4:	e8 bc 14 00 00       	call   804765 <netif_set_up>
  dhcp_set_state(dhcp, DHCP_BOUND);
  8032a9:	ba 0a 00 00 00       	mov    $0xa,%edx
  8032ae:	89 d8                	mov    %ebx,%eax
  8032b0:	e8 2c f5 ff ff       	call   8027e1 <dhcp_set_state>
}
  8032b5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8032b8:	5b                   	pop    %ebx
  8032b9:	5e                   	pop    %esi
  8032ba:	5d                   	pop    %ebp
  8032bb:	c3                   	ret    
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8032bc:	83 ec 04             	sub    $0x4,%esp
  8032bf:	68 17 1b 81 00       	push   $0x811b17
  8032c4:	68 3d 03 00 00       	push   $0x33d
  8032c9:	68 02 1b 81 00       	push   $0x811b02
  8032ce:	e8 c6 b3 00 00       	call   80e699 <_panic>
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8032d3:	83 ec 04             	sub    $0x4,%esp
  8032d6:	68 30 1b 81 00       	push   $0x811b30
  8032db:	68 3f 03 00 00       	push   $0x33f
  8032e0:	68 02 1b 81 00       	push   $0x811b02
  8032e5:	e8 af b3 00 00       	call   80e699 <_panic>
    dhcp->t1_timeout = (u16_t)timeout;
  8032ea:	66 89 53 28          	mov    %dx,0x28(%ebx)
  8032ee:	e9 39 ff ff ff       	jmp    80322c <dhcp_bind+0x4f>
    dhcp->t2_timeout = (u16_t)timeout;
  8032f3:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
  8032f7:	e9 62 ff ff ff       	jmp    80325e <dhcp_bind+0x81>
    u8_t first_octet = ip4_addr1(&sn_mask);
  8032fc:	83 ec 0c             	sub    $0xc,%esp
  8032ff:	6a 00                	push   $0x0
  803301:	e8 8f 46 00 00       	call   807995 <ntohl>
  803306:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803309:	83 c4 10             	add    $0x10,%esp
  80330c:	84 c0                	test   %al,%al
  80330e:	79 1c                	jns    80332c <dhcp_bind+0x14f>
    } else if (first_octet >= 192) {
  803310:	3c bf                	cmp    $0xbf,%al
  803312:	76 30                	jbe    803344 <dhcp_bind+0x167>
      sn_mask.addr = htonl(0xffffff00);
  803314:	83 ec 0c             	sub    $0xc,%esp
  803317:	68 00 ff ff ff       	push   $0xffffff00
  80331c:	e8 5d 44 00 00       	call   80777e <htonl>
  803321:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803324:	83 c4 10             	add    $0x10,%esp
  803327:	e9 40 ff ff ff       	jmp    80326c <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xff000000);
  80332c:	83 ec 0c             	sub    $0xc,%esp
  80332f:	68 00 00 00 ff       	push   $0xff000000
  803334:	e8 45 44 00 00       	call   80777e <htonl>
  803339:	89 45 f4             	mov    %eax,-0xc(%ebp)
  80333c:	83 c4 10             	add    $0x10,%esp
  80333f:	e9 28 ff ff ff       	jmp    80326c <dhcp_bind+0x8f>
      sn_mask.addr = htonl(0xffff0000);
  803344:	83 ec 0c             	sub    $0xc,%esp
  803347:	68 00 00 ff ff       	push   $0xffff0000
  80334c:	e8 2d 44 00 00       	call   80777e <htonl>
  803351:	89 45 f4             	mov    %eax,-0xc(%ebp)
  803354:	83 c4 10             	add    $0x10,%esp
  803357:	e9 10 ff ff ff       	jmp    80326c <dhcp_bind+0x8f>
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80335c:	8b 43 30             	mov    0x30(%ebx),%eax
  80335f:	23 45 f4             	and    -0xc(%ebp),%eax
  803362:	89 45 f0             	mov    %eax,-0x10(%ebp)
    gw_addr.addr |= htonl(0x00000001);
  803365:	83 ec 0c             	sub    $0xc,%esp
  803368:	6a 01                	push   $0x1
  80336a:	e8 0f 44 00 00       	call   80777e <htonl>
  80336f:	09 45 f0             	or     %eax,-0x10(%ebp)
  803372:	83 c4 10             	add    $0x10,%esp
  803375:	e9 00 ff ff ff       	jmp    80327a <dhcp_bind+0x9d>
    dhcp->t2_timeout = (u16_t)timeout;
  80337a:	66 c7 43 2a ff ff    	movw   $0xffff,0x2a(%ebx)
  803380:	e9 d9 fe ff ff       	jmp    80325e <dhcp_bind+0x81>
    dhcp->t1_timeout = (u16_t)timeout;
  803385:	66 c7 43 28 ff ff    	movw   $0xffff,0x28(%ebx)
  80338b:	e9 9c fe ff ff       	jmp    80322c <dhcp_bind+0x4f>

00803390 <dhcp_free_reply>:
{
  803390:	55                   	push   %ebp
  803391:	89 e5                	mov    %esp,%ebp
  803393:	53                   	push   %ebx
  803394:	83 ec 04             	sub    $0x4,%esp
  803397:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803399:	8b 40 10             	mov    0x10(%eax),%eax
  80339c:	85 c0                	test   %eax,%eax
  80339e:	74 13                	je     8033b3 <dhcp_free_reply+0x23>
    mem_free((void *)dhcp->msg_in);
  8033a0:	83 ec 0c             	sub    $0xc,%esp
  8033a3:	50                   	push   %eax
  8033a4:	e8 fb 0b 00 00       	call   803fa4 <mem_free>
    dhcp->msg_in = NULL;
  8033a9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8033b0:	83 c4 10             	add    $0x10,%esp
  if (dhcp->options_in) {
  8033b3:	8b 43 14             	mov    0x14(%ebx),%eax
  8033b6:	85 c0                	test   %eax,%eax
  8033b8:	74 19                	je     8033d3 <dhcp_free_reply+0x43>
    mem_free((void *)dhcp->options_in);
  8033ba:	83 ec 0c             	sub    $0xc,%esp
  8033bd:	50                   	push   %eax
  8033be:	e8 e1 0b 00 00       	call   803fa4 <mem_free>
    dhcp->options_in = NULL;
  8033c3:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  8033ca:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  8033d0:	83 c4 10             	add    $0x10,%esp
}
  8033d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8033d6:	c9                   	leave  
  8033d7:	c3                   	ret    

008033d8 <dhcp_recv>:
{
  8033d8:	55                   	push   %ebp
  8033d9:	89 e5                	mov    %esp,%ebp
  8033db:	57                   	push   %edi
  8033dc:	56                   	push   %esi
  8033dd:	53                   	push   %ebx
  8033de:	83 ec 1c             	sub    $0x1c,%esp
  struct dhcp *dhcp = netif->dhcp;
  8033e1:	8b 45 08             	mov    0x8(%ebp),%eax
  8033e4:	8b 78 20             	mov    0x20(%eax),%edi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  8033e7:	8b 45 10             	mov    0x10(%ebp),%eax
  8033ea:	8b 70 04             	mov    0x4(%eax),%esi
  8033ed:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  dhcp->p = p;
  8033f0:	89 47 0c             	mov    %eax,0xc(%edi)
  if (reply_msg->op != DHCP_BOOTREPLY) {
  8033f3:	80 3e 02             	cmpb   $0x2,(%esi)
  8033f6:	75 26                	jne    80341e <dhcp_recv+0x46>
  8033f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8033fb:	83 c0 25             	add    $0x25,%eax
  8033fe:	8d 56 1c             	lea    0x1c(%esi),%edx
  803401:	8b 4d 08             	mov    0x8(%ebp),%ecx
  803404:	0f b6 71 24          	movzbl 0x24(%ecx),%esi
  803408:	01 c6                	add    %eax,%esi
  for (i = 0; i < netif->hwaddr_len; i++) {
  80340a:	39 f0                	cmp    %esi,%eax
  80340c:	74 2a                	je     803438 <dhcp_recv+0x60>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80340e:	0f b6 18             	movzbl (%eax),%ebx
  803411:	0f b6 0a             	movzbl (%edx),%ecx
  803414:	83 c0 01             	add    $0x1,%eax
  803417:	83 c2 01             	add    $0x1,%edx
  80341a:	38 cb                	cmp    %cl,%bl
  80341c:	74 ec                	je     80340a <dhcp_recv+0x32>
  pbuf_free(p);
  80341e:	83 ec 0c             	sub    $0xc,%esp
  803421:	ff 75 10             	pushl  0x10(%ebp)
  803424:	e8 61 14 00 00       	call   80488a <pbuf_free>
  dhcp->p = NULL;
  803429:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
}
  803430:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803433:	5b                   	pop    %ebx
  803434:	5e                   	pop    %esi
  803435:	5f                   	pop    %edi
  803436:	5d                   	pop    %ebp
  803437:	c3                   	ret    
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  803438:	83 ec 0c             	sub    $0xc,%esp
  80343b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80343e:	ff 70 04             	pushl  0x4(%eax)
  803441:	e8 4f 45 00 00       	call   807995 <ntohl>
  803446:	83 c4 10             	add    $0x10,%esp
  803449:	3b 47 04             	cmp    0x4(%edi),%eax
  80344c:	75 d0                	jne    80341e <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80344e:	83 7f 0c 00          	cmpl   $0x0,0xc(%edi)
  803452:	0f 84 20 01 00 00    	je     803578 <dhcp_recv+0x1a0>
  dhcp_free_reply(dhcp);
  803458:	89 f8                	mov    %edi,%eax
  80345a:	e8 31 ff ff ff       	call   803390 <dhcp_free_reply>
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80345f:	8b 47 0c             	mov    0xc(%edi),%eax
  803462:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803466:	66 3d f0 00          	cmp    $0xf0,%ax
  80346a:	76 1e                	jbe    80348a <dhcp_recv+0xb2>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80346c:	66 2d f0 00          	sub    $0xf0,%ax
  803470:	66 89 47 18          	mov    %ax,0x18(%edi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  803474:	83 ec 0c             	sub    $0xc,%esp
  803477:	0f b7 c0             	movzwl %ax,%eax
  80347a:	50                   	push   %eax
  80347b:	e8 13 0e 00 00       	call   804293 <mem_malloc>
  803480:	89 47 14             	mov    %eax,0x14(%edi)
    if (dhcp->options_in == NULL) {
  803483:	83 c4 10             	add    $0x10,%esp
  803486:	85 c0                	test   %eax,%eax
  803488:	74 94                	je     80341e <dhcp_recv+0x46>
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80348a:	83 ec 0c             	sub    $0xc,%esp
  80348d:	68 f0 00 00 00       	push   $0xf0
  803492:	e8 fc 0d 00 00       	call   804293 <mem_malloc>
  803497:	89 47 10             	mov    %eax,0x10(%edi)
  if (dhcp->msg_in == NULL) {
  80349a:	83 c4 10             	add    $0x10,%esp
  80349d:	85 c0                	test   %eax,%eax
  80349f:	0f 84 ea 00 00 00    	je     80358f <dhcp_recv+0x1b7>
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  8034a5:	6a 00                	push   $0x0
  8034a7:	68 f0 00 00 00       	push   $0xf0
  8034ac:	50                   	push   %eax
  8034ad:	ff 77 0c             	pushl  0xc(%edi)
  8034b0:	e8 51 1b 00 00       	call   805006 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034b5:	83 c4 10             	add    $0x10,%esp
  8034b8:	66 3d f0 00          	cmp    $0xf0,%ax
  8034bc:	0f 85 e7 00 00 00    	jne    8035a9 <dhcp_recv+0x1d1>
  if (dhcp->options_in != NULL) {
  8034c2:	8b 47 14             	mov    0x14(%edi),%eax
  8034c5:	85 c0                	test   %eax,%eax
  8034c7:	74 20                	je     8034e9 <dhcp_recv+0x111>
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8034c9:	68 f0 00 00 00       	push   $0xf0
  8034ce:	0f b7 57 18          	movzwl 0x18(%edi),%edx
  8034d2:	52                   	push   %edx
  8034d3:	50                   	push   %eax
  8034d4:	ff 77 0c             	pushl  0xc(%edi)
  8034d7:	e8 2a 1b 00 00       	call   805006 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8034dc:	83 c4 10             	add    $0x10,%esp
  8034df:	66 3b 47 18          	cmp    0x18(%edi),%ax
  8034e3:	0f 85 d7 00 00 00    	jne    8035c0 <dhcp_recv+0x1e8>
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  8034e9:	ba 35 00 00 00       	mov    $0x35,%edx
  8034ee:	89 f8                	mov    %edi,%eax
  8034f0:	e8 f7 f2 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8034f5:	85 c0                	test   %eax,%eax
  8034f7:	0f 84 21 ff ff ff    	je     80341e <dhcp_recv+0x46>
  return *ptr;
  8034fd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  if (msg_type == DHCP_ACK) {
  803501:	3c 05                	cmp    $0x5,%al
  803503:	0f 84 ce 00 00 00    	je     8035d7 <dhcp_recv+0x1ff>
  else if ((msg_type == DHCP_NAK) &&
  803509:	3c 06                	cmp    $0x6,%al
  80350b:	0f 84 6e 02 00 00    	je     80377f <dhcp_recv+0x3a7>
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803511:	3c 02                	cmp    $0x2,%al
  803513:	0f 85 05 ff ff ff    	jne    80341e <dhcp_recv+0x46>
  803519:	80 3f 06             	cmpb   $0x6,(%edi)
  80351c:	0f 85 fc fe ff ff    	jne    80341e <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  803522:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803528:	8b 45 08             	mov    0x8(%ebp),%eax
  80352b:	8b 58 20             	mov    0x20(%eax),%ebx
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80352e:	ba 36 00 00 00       	mov    $0x36,%edx
  803533:	89 d8                	mov    %ebx,%eax
  803535:	e8 b2 f2 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80353a:	85 c0                	test   %eax,%eax
  80353c:	0f 84 dc fe ff ff    	je     80341e <dhcp_recv+0x46>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803542:	83 c0 02             	add    $0x2,%eax
  803545:	e8 b0 f3 ff ff       	call   8028fa <dhcp_get_option_long>
  80354a:	83 ec 0c             	sub    $0xc,%esp
  80354d:	50                   	push   %eax
  80354e:	e8 2b 42 00 00       	call   80777e <htonl>
  803553:	89 43 2c             	mov    %eax,0x2c(%ebx)
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803556:	8b 43 10             	mov    0x10(%ebx),%eax
  803559:	83 c4 10             	add    $0x10,%esp
  80355c:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80355f:	0f 84 8e 02 00 00    	je     8037f3 <dhcp_recv+0x41b>
  803565:	8b 40 10             	mov    0x10(%eax),%eax
  803568:	89 43 30             	mov    %eax,0x30(%ebx)
    dhcp_select(netif);
  80356b:	8b 45 08             	mov    0x8(%ebp),%eax
  80356e:	e8 ba fa ff ff       	call   80302d <dhcp_select>
  803573:	e9 a6 fe ff ff       	jmp    80341e <dhcp_recv+0x46>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  803578:	83 ec 04             	sub    $0x4,%esp
  80357b:	68 48 1b 81 00       	push   $0x811b48
  803580:	68 8a 04 00 00       	push   $0x48a
  803585:	68 02 1b 81 00       	push   $0x811b02
  80358a:	e8 0a b1 00 00       	call   80e699 <_panic>
    mem_free((void *)dhcp->options_in);
  80358f:	83 ec 0c             	sub    $0xc,%esp
  803592:	ff 77 14             	pushl  0x14(%edi)
  803595:	e8 0a 0a 00 00       	call   803fa4 <mem_free>
    dhcp->options_in = NULL;
  80359a:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
  8035a1:	83 c4 10             	add    $0x10,%esp
  8035a4:	e9 75 fe ff ff       	jmp    80341e <dhcp_recv+0x46>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8035a9:	83 ec 04             	sub    $0x4,%esp
  8035ac:	68 d0 1a 81 00       	push   $0x811ad0
  8035b1:	68 a0 04 00 00       	push   $0x4a0
  8035b6:	68 02 1b 81 00       	push   $0x811b02
  8035bb:	e8 d9 b0 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8035c0:	83 ec 04             	sub    $0x4,%esp
  8035c3:	68 58 1b 81 00       	push   $0x811b58
  8035c8:	68 a7 04 00 00       	push   $0x4a7
  8035cd:	68 02 1b 81 00       	push   $0x811b02
  8035d2:	e8 c2 b0 00 00       	call   80e699 <_panic>
    if (dhcp->state == DHCP_REQUESTING) {
  8035d7:	0f b6 07             	movzbl (%edi),%eax
  8035da:	3c 01                	cmp    $0x1,%al
  8035dc:	74 1e                	je     8035fc <dhcp_recv+0x224>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8035de:	83 e8 03             	sub    $0x3,%eax
  8035e1:	3c 02                	cmp    $0x2,%al
  8035e3:	0f 87 35 fe ff ff    	ja     80341e <dhcp_recv+0x46>
      dhcp->request_timeout = 0;
  8035e9:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_bind(netif);
  8035ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8035f2:	e8 e6 fb ff ff       	call   8031dd <dhcp_bind>
  8035f7:	e9 22 fe ff ff       	jmp    80341e <dhcp_recv+0x46>
  struct dhcp *dhcp = netif->dhcp;
  8035fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8035ff:	8b 70 20             	mov    0x20(%eax),%esi
  dhcp->offered_sn_mask.addr = 0;
  803602:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  dhcp->offered_gw_addr.addr = 0;
  803609:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
  dhcp->offered_bc_addr.addr = 0;
  803610:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803617:	ba 33 00 00 00       	mov    $0x33,%edx
  80361c:	89 f0                	mov    %esi,%eax
  80361e:	e8 c9 f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803623:	85 c0                	test   %eax,%eax
  803625:	74 0b                	je     803632 <dhcp_recv+0x25a>
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803627:	83 c0 02             	add    $0x2,%eax
  80362a:	e8 cb f2 ff ff       	call   8028fa <dhcp_get_option_long>
  80362f:	89 46 4c             	mov    %eax,0x4c(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803632:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803637:	89 f0                	mov    %esi,%eax
  803639:	e8 ae f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80363e:	85 c0                	test   %eax,%eax
  803640:	0f 84 e7 00 00 00    	je     80372d <dhcp_recv+0x355>
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803646:	83 c0 02             	add    $0x2,%eax
  803649:	e8 ac f2 ff ff       	call   8028fa <dhcp_get_option_long>
  80364e:	89 46 50             	mov    %eax,0x50(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803651:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803656:	89 f0                	mov    %esi,%eax
  803658:	e8 8f f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80365d:	85 c0                	test   %eax,%eax
  80365f:	0f 84 d2 00 00 00    	je     803737 <dhcp_recv+0x35f>
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803665:	83 c0 02             	add    $0x2,%eax
  803668:	e8 8d f2 ff ff       	call   8028fa <dhcp_get_option_long>
  80366d:	89 46 54             	mov    %eax,0x54(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803670:	8b 56 10             	mov    0x10(%esi),%edx
  803673:	b8 00 00 00 00       	mov    $0x0,%eax
  803678:	83 fa f0             	cmp    $0xfffffff0,%edx
  80367b:	74 03                	je     803680 <dhcp_recv+0x2a8>
  80367d:	8b 42 10             	mov    0x10(%edx),%eax
  803680:	89 46 30             	mov    %eax,0x30(%esi)
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  803683:	ba 01 00 00 00       	mov    $0x1,%edx
  803688:	89 f0                	mov    %esi,%eax
  80368a:	e8 5d f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80368f:	85 c0                	test   %eax,%eax
  803691:	74 17                	je     8036aa <dhcp_recv+0x2d2>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803693:	83 c0 02             	add    $0x2,%eax
  803696:	e8 5f f2 ff ff       	call   8028fa <dhcp_get_option_long>
  80369b:	83 ec 0c             	sub    $0xc,%esp
  80369e:	50                   	push   %eax
  80369f:	e8 da 40 00 00       	call   80777e <htonl>
  8036a4:	89 46 34             	mov    %eax,0x34(%esi)
  8036a7:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8036aa:	ba 03 00 00 00       	mov    $0x3,%edx
  8036af:	89 f0                	mov    %esi,%eax
  8036b1:	e8 36 f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036b6:	85 c0                	test   %eax,%eax
  8036b8:	74 17                	je     8036d1 <dhcp_recv+0x2f9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036ba:	83 c0 02             	add    $0x2,%eax
  8036bd:	e8 38 f2 ff ff       	call   8028fa <dhcp_get_option_long>
  8036c2:	83 ec 0c             	sub    $0xc,%esp
  8036c5:	50                   	push   %eax
  8036c6:	e8 b3 40 00 00       	call   80777e <htonl>
  8036cb:	89 46 38             	mov    %eax,0x38(%esi)
  8036ce:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  8036d1:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8036d6:	89 f0                	mov    %esi,%eax
  8036d8:	e8 0f f1 ff ff       	call   8027ec <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8036dd:	85 c0                	test   %eax,%eax
  8036df:	74 17                	je     8036f8 <dhcp_recv+0x320>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8036e1:	83 c0 02             	add    $0x2,%eax
  8036e4:	e8 11 f2 ff ff       	call   8028fa <dhcp_get_option_long>
  8036e9:	83 ec 0c             	sub    $0xc,%esp
  8036ec:	50                   	push   %eax
  8036ed:	e8 8c 40 00 00       	call   80777e <htonl>
  8036f2:	89 46 3c             	mov    %eax,0x3c(%esi)
  8036f5:	83 c4 10             	add    $0x10,%esp
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  8036f8:	ba 06 00 00 00       	mov    $0x6,%edx
  8036fd:	89 f0                	mov    %esi,%eax
  8036ff:	e8 e8 f0 ff ff       	call   8027ec <dhcp_get_option_ptr>
  803704:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (option_ptr != NULL) {
  803707:	85 c0                	test   %eax,%eax
  803709:	74 61                	je     80376c <dhcp_recv+0x394>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  80370b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  80370f:	c0 e8 02             	shr    $0x2,%al
  803712:	0f b6 c0             	movzbl %al,%eax
  803715:	83 f8 02             	cmp    $0x2,%eax
  803718:	ba 02 00 00 00       	mov    $0x2,%edx
  80371d:	0f 47 c2             	cmova  %edx,%eax
  803720:	89 46 40             	mov    %eax,0x40(%esi)
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803723:	bb 00 00 00 00       	mov    $0x0,%ebx
  803728:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80372b:	eb 34                	jmp    803761 <dhcp_recv+0x389>
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  80372d:	8b 46 4c             	mov    0x4c(%esi),%eax
  803730:	d1 e8                	shr    %eax
  803732:	e9 17 ff ff ff       	jmp    80364e <dhcp_recv+0x276>
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803737:	8b 46 4c             	mov    0x4c(%esi),%eax
  80373a:	e9 2e ff ff ff       	jmp    80366d <dhcp_recv+0x295>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80373f:	0f b6 fb             	movzbl %bl,%edi
  803742:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803745:	8d 44 b8 02          	lea    0x2(%eax,%edi,4),%eax
  803749:	e8 ac f1 ff ff       	call   8028fa <dhcp_get_option_long>
  80374e:	83 ec 0c             	sub    $0xc,%esp
  803751:	50                   	push   %eax
  803752:	e8 27 40 00 00       	call   80777e <htonl>
  803757:	89 44 be 44          	mov    %eax,0x44(%esi,%edi,4)
    for (n = 0; n < dhcp->dns_count; n++) {
  80375b:	83 c3 01             	add    $0x1,%ebx
  80375e:	83 c4 10             	add    $0x10,%esp
  803761:	0f b6 c3             	movzbl %bl,%eax
  803764:	3b 46 40             	cmp    0x40(%esi),%eax
  803767:	72 d6                	jb     80373f <dhcp_recv+0x367>
  803769:	8b 7d e0             	mov    -0x20(%ebp),%edi
      dhcp->request_timeout = 0;
  80376c:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
      dhcp_check(netif);
  803772:	8b 45 08             	mov    0x8(%ebp),%eax
  803775:	e8 2f fa ff ff       	call   8031a9 <dhcp_check>
  80377a:	e9 9f fc ff ff       	jmp    80341e <dhcp_recv+0x46>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80377f:	0f b6 07             	movzbl (%edi),%eax
  803782:	8d 50 fd             	lea    -0x3(%eax),%edx
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  803785:	80 fa 02             	cmp    $0x2,%dl
  803788:	76 08                	jbe    803792 <dhcp_recv+0x3ba>
  80378a:	3c 01                	cmp    $0x1,%al
  80378c:	0f 85 8c fc ff ff    	jne    80341e <dhcp_recv+0x46>
    dhcp->request_timeout = 0;
  803792:	66 c7 47 26 00 00    	movw   $0x0,0x26(%edi)
  struct dhcp *dhcp = netif->dhcp;
  803798:	8b 45 08             	mov    0x8(%ebp),%eax
  80379b:	8b 58 20             	mov    0x20(%eax),%ebx
  netif_set_down(netif);
  80379e:	83 ec 0c             	sub    $0xc,%esp
  8037a1:	50                   	push   %eax
  8037a2:	e8 f1 0f 00 00       	call   804798 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8037a7:	83 c4 08             	add    $0x8,%esp
  8037aa:	68 a8 23 81 00       	push   $0x8123a8
  8037af:	ff 75 08             	pushl  0x8(%ebp)
  8037b2:	e8 43 0e 00 00       	call   8045fa <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8037b7:	83 c4 08             	add    $0x8,%esp
  8037ba:	68 a8 23 81 00       	push   $0x8123a8
  8037bf:	ff 75 08             	pushl  0x8(%ebp)
  8037c2:	e8 5f 0f 00 00       	call   804726 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  8037c7:	83 c4 08             	add    $0x8,%esp
  8037ca:	68 a8 23 81 00       	push   $0x8123a8
  8037cf:	ff 75 08             	pushl  0x8(%ebp)
  8037d2:	e8 68 0f 00 00       	call   80473f <netif_set_netmask>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8037d7:	ba 0c 00 00 00       	mov    $0xc,%edx
  8037dc:	89 d8                	mov    %ebx,%eax
  8037de:	e8 fe ef ff ff       	call   8027e1 <dhcp_set_state>
  dhcp_discover(netif);
  8037e3:	8b 45 08             	mov    0x8(%ebp),%eax
  8037e6:	e8 03 f7 ff ff       	call   802eee <dhcp_discover>
  8037eb:	83 c4 10             	add    $0x10,%esp
  8037ee:	e9 2b fc ff ff       	jmp    80341e <dhcp_recv+0x46>
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8037f3:	b8 00 00 00 00       	mov    $0x0,%eax
  8037f8:	e9 6b fd ff ff       	jmp    803568 <dhcp_recv+0x190>

008037fd <dhcp_inform>:
{
  8037fd:	55                   	push   %ebp
  8037fe:	89 e5                	mov    %esp,%ebp
  803800:	57                   	push   %edi
  803801:	56                   	push   %esi
  803802:	53                   	push   %ebx
  803803:	83 ec 18             	sub    $0x18,%esp
  803806:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803809:	8b 7e 20             	mov    0x20(%esi),%edi
  dhcp = mem_malloc(sizeof(struct dhcp));
  80380c:	6a 58                	push   $0x58
  80380e:	e8 80 0a 00 00       	call   804293 <mem_malloc>
  if (dhcp == NULL) {
  803813:	83 c4 10             	add    $0x10,%esp
  803816:	85 c0                	test   %eax,%eax
  803818:	74 55                	je     80386f <dhcp_inform+0x72>
  80381a:	89 c3                	mov    %eax,%ebx
  netif->dhcp = dhcp;
  80381c:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  80381f:	83 ec 04             	sub    $0x4,%esp
  803822:	6a 58                	push   $0x58
  803824:	6a 00                	push   $0x0
  803826:	50                   	push   %eax
  803827:	e8 08 b8 00 00       	call   80f034 <memset>
  dhcp->pcb = udp_new();
  80382c:	e8 2a 58 00 00       	call   80905b <udp_new>
  803831:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803834:	83 c4 10             	add    $0x10,%esp
  803837:	85 c0                	test   %eax,%eax
  803839:	74 3c                	je     803877 <dhcp_inform+0x7a>
  result = dhcp_create_request(netif);
  80383b:	89 f0                	mov    %esi,%eax
  80383d:	e8 2c f3 ff ff       	call   802b6e <dhcp_create_request>
  if (result == ERR_OK) {
  803842:	84 c0                	test   %al,%al
  803844:	74 3f                	je     803885 <dhcp_inform+0x88>
    if (dhcp->pcb != NULL) {
  803846:	8b 43 08             	mov    0x8(%ebx),%eax
  803849:	85 c0                	test   %eax,%eax
  80384b:	74 0c                	je     803859 <dhcp_inform+0x5c>
      udp_remove(dhcp->pcb);
  80384d:	83 ec 0c             	sub    $0xc,%esp
  803850:	50                   	push   %eax
  803851:	e8 c1 57 00 00       	call   809017 <udp_remove>
  803856:	83 c4 10             	add    $0x10,%esp
    dhcp->pcb = NULL;
  803859:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803860:	83 ec 0c             	sub    $0xc,%esp
  803863:	53                   	push   %ebx
  803864:	e8 3b 07 00 00       	call   803fa4 <mem_free>
    netif->dhcp = old_dhcp;
  803869:	89 7e 20             	mov    %edi,0x20(%esi)
  80386c:	83 c4 10             	add    $0x10,%esp
}
  80386f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803872:	5b                   	pop    %ebx
  803873:	5e                   	pop    %esi
  803874:	5f                   	pop    %edi
  803875:	5d                   	pop    %ebp
  803876:	c3                   	ret    
    mem_free((void *)dhcp);
  803877:	83 ec 0c             	sub    $0xc,%esp
  80387a:	53                   	push   %ebx
  80387b:	e8 24 07 00 00       	call   803fa4 <mem_free>
    return;
  803880:	83 c4 10             	add    $0x10,%esp
  803883:	eb ea                	jmp    80386f <dhcp_inform+0x72>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803885:	b9 01 00 00 00       	mov    $0x1,%ecx
  80388a:	ba 35 00 00 00       	mov    $0x35,%edx
  80388f:	89 d8                	mov    %ebx,%eax
  803891:	e8 c6 f0 ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803896:	ba 08 00 00 00       	mov    $0x8,%edx
  80389b:	89 d8                	mov    %ebx,%eax
  80389d:	e8 79 f0 ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8038a2:	b9 02 00 00 00       	mov    $0x2,%ecx
  8038a7:	ba 39 00 00 00       	mov    $0x39,%edx
  8038ac:	89 d8                	mov    %ebx,%eax
  8038ae:	e8 a9 f0 ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8038b3:	ba 40 02 00 00       	mov    $0x240,%edx
  8038b8:	89 d8                	mov    %ebx,%eax
  8038ba:	e8 04 f1 ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  8038bf:	89 d8                	mov    %ebx,%eax
  8038c1:	e8 5b f1 ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8038c6:	83 ec 08             	sub    $0x8,%esp
  8038c9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8038cd:	66 05 f0 00          	add    $0xf0,%ax
  8038d1:	0f b7 c0             	movzwl %ax,%eax
  8038d4:	50                   	push   %eax
  8038d5:	ff 73 1c             	pushl  0x1c(%ebx)
  8038d8:	e8 e5 12 00 00       	call   804bc2 <pbuf_realloc>
    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8038dd:	83 c4 0c             	add    $0xc,%esp
  8038e0:	6a 44                	push   $0x44
  8038e2:	68 a8 23 81 00       	push   $0x8123a8
  8038e7:	ff 73 08             	pushl  0x8(%ebx)
  8038ea:	e8 d8 53 00 00       	call   808cc7 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8038ef:	83 c4 0c             	add    $0xc,%esp
  8038f2:	6a 43                	push   $0x43
  8038f4:	68 a4 23 81 00       	push   $0x8123a4
  8038f9:	ff 73 08             	pushl  0x8(%ebx)
  8038fc:	e8 76 56 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803901:	89 34 24             	mov    %esi,(%esp)
  803904:	6a 43                	push   $0x43
  803906:	68 a4 23 81 00       	push   $0x8123a4
  80390b:	ff 73 1c             	pushl  0x1c(%ebx)
  80390e:	ff 73 08             	pushl  0x8(%ebx)
  803911:	e8 6c 54 00 00       	call   808d82 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803916:	83 c4 1c             	add    $0x1c,%esp
  803919:	6a 43                	push   $0x43
  80391b:	68 a8 23 81 00       	push   $0x8123a8
  803920:	ff 73 08             	pushl  0x8(%ebx)
  803923:	e8 4f 56 00 00       	call   808f77 <udp_connect>
    dhcp_delete_request(netif);
  803928:	89 f0                	mov    %esi,%eax
  80392a:	e8 32 f4 ff ff       	call   802d61 <dhcp_delete_request>
  80392f:	83 c4 10             	add    $0x10,%esp
  803932:	e9 0f ff ff ff       	jmp    803846 <dhcp_inform+0x49>

00803937 <dhcp_arp_reply>:
{
  803937:	55                   	push   %ebp
  803938:	89 e5                	mov    %esp,%ebp
  80393a:	56                   	push   %esi
  80393b:	53                   	push   %ebx
  80393c:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80393f:	85 f6                	test   %esi,%esi
  803941:	74 13                	je     803956 <dhcp_arp_reply+0x1f>
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803943:	8b 5e 20             	mov    0x20(%esi),%ebx
  803946:	85 db                	test   %ebx,%ebx
  803948:	74 05                	je     80394f <dhcp_arp_reply+0x18>
  80394a:	80 3b 08             	cmpb   $0x8,(%ebx)
  80394d:	74 1e                	je     80396d <dhcp_arp_reply+0x36>
}
  80394f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803952:	5b                   	pop    %ebx
  803953:	5e                   	pop    %esi
  803954:	5d                   	pop    %ebp
  803955:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803956:	83 ec 04             	sub    $0x4,%esp
  803959:	68 22 1b 81 00       	push   $0x811b22
  80395e:	68 b5 02 00 00       	push   $0x2b5
  803963:	68 02 1b 81 00       	push   $0x811b02
  803968:	e8 2c ad 00 00       	call   80e699 <_panic>
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80396d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803970:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803973:	39 08                	cmp    %ecx,(%eax)
  803975:	75 d8                	jne    80394f <dhcp_arp_reply+0x18>
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803977:	ba 0c 00 00 00       	mov    $0xc,%edx
  80397c:	89 d8                	mov    %ebx,%eax
  80397e:	e8 5e ee ff ff       	call   8027e1 <dhcp_set_state>
  result = dhcp_create_request(netif);
  803983:	89 f0                	mov    %esi,%eax
  803985:	e8 e4 f1 ff ff       	call   802b6e <dhcp_create_request>
  if (result == ERR_OK) {
  80398a:	84 c0                	test   %al,%al
  80398c:	74 0c                	je     80399a <dhcp_arp_reply+0x63>
  dhcp->tries++;
  80398e:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803992:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
  803998:	eb b5                	jmp    80394f <dhcp_arp_reply+0x18>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80399a:	b9 01 00 00 00       	mov    $0x1,%ecx
  80399f:	ba 35 00 00 00       	mov    $0x35,%edx
  8039a4:	89 d8                	mov    %ebx,%eax
  8039a6:	e8 b1 ef ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8039ab:	ba 04 00 00 00       	mov    $0x4,%edx
  8039b0:	89 d8                	mov    %ebx,%eax
  8039b2:	e8 64 ef ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8039b7:	b9 02 00 00 00       	mov    $0x2,%ecx
  8039bc:	ba 39 00 00 00       	mov    $0x39,%edx
  8039c1:	89 d8                	mov    %ebx,%eax
  8039c3:	e8 94 ef ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8039c8:	ba 40 02 00 00       	mov    $0x240,%edx
  8039cd:	89 d8                	mov    %ebx,%eax
  8039cf:	e8 ef ef ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8039d4:	b9 04 00 00 00       	mov    $0x4,%ecx
  8039d9:	ba 32 00 00 00       	mov    $0x32,%edx
  8039de:	89 d8                	mov    %ebx,%eax
  8039e0:	e8 77 ef ff ff       	call   80295c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8039e5:	83 ec 0c             	sub    $0xc,%esp
  8039e8:	ff 73 30             	pushl  0x30(%ebx)
  8039eb:	e8 a5 3f 00 00       	call   807995 <ntohl>
  8039f0:	89 c2                	mov    %eax,%edx
  8039f2:	89 d8                	mov    %ebx,%eax
  8039f4:	e8 dd f0 ff ff       	call   802ad6 <dhcp_option_long>
    dhcp_option_trailer(dhcp);
  8039f9:	89 d8                	mov    %ebx,%eax
  8039fb:	e8 21 f0 ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803a00:	83 c4 08             	add    $0x8,%esp
  803a03:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803a07:	66 05 f0 00          	add    $0xf0,%ax
  803a0b:	0f b7 c0             	movzwl %ax,%eax
  803a0e:	50                   	push   %eax
  803a0f:	ff 73 1c             	pushl  0x1c(%ebx)
  803a12:	e8 ab 11 00 00       	call   804bc2 <pbuf_realloc>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803a17:	83 c4 0c             	add    $0xc,%esp
  803a1a:	6a 43                	push   $0x43
  803a1c:	68 a8 23 81 00       	push   $0x8123a8
  803a21:	ff 73 08             	pushl  0x8(%ebx)
  803a24:	e8 4e 55 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803a29:	89 34 24             	mov    %esi,(%esp)
  803a2c:	6a 43                	push   $0x43
  803a2e:	68 a4 23 81 00       	push   $0x8123a4
  803a33:	ff 73 1c             	pushl  0x1c(%ebx)
  803a36:	ff 73 08             	pushl  0x8(%ebx)
  803a39:	e8 44 53 00 00       	call   808d82 <udp_sendto_if>
    dhcp_delete_request(netif);
  803a3e:	83 c4 20             	add    $0x20,%esp
  803a41:	89 f0                	mov    %esi,%eax
  803a43:	e8 19 f3 ff ff       	call   802d61 <dhcp_delete_request>
  803a48:	e9 41 ff ff ff       	jmp    80398e <dhcp_arp_reply+0x57>

00803a4d <dhcp_renew>:
{
  803a4d:	55                   	push   %ebp
  803a4e:	89 e5                	mov    %esp,%ebp
  803a50:	57                   	push   %edi
  803a51:	56                   	push   %esi
  803a52:	53                   	push   %ebx
  803a53:	83 ec 1c             	sub    $0x1c,%esp
  803a56:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803a59:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803a5c:	ba 05 00 00 00       	mov    $0x5,%edx
  803a61:	89 d8                	mov    %ebx,%eax
  803a63:	e8 79 ed ff ff       	call   8027e1 <dhcp_set_state>
  result = dhcp_create_request(netif);
  803a68:	89 f0                	mov    %esi,%eax
  803a6a:	e8 ff f0 ff ff       	call   802b6e <dhcp_create_request>
  803a6f:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803a71:	84 c0                	test   %al,%al
  803a73:	74 3e                	je     803ab3 <dhcp_renew+0x66>
  dhcp->tries++;
  803a75:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803a79:	83 c0 01             	add    $0x1,%eax
  803a7c:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  803a7f:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  803a84:	3c 09                	cmp    $0x9,%al
  803a86:	77 08                	ja     803a90 <dhcp_renew+0x43>
  803a88:	0f b6 d0             	movzbl %al,%edx
  803a8b:	66 69 d2 d0 07       	imul   $0x7d0,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803a90:	0f b7 d2             	movzwl %dx,%edx
  803a93:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803a99:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803a9e:	89 d0                	mov    %edx,%eax
  803aa0:	f7 e9                	imul   %ecx
  803aa2:	c1 fa 05             	sar    $0x5,%edx
  803aa5:	66 89 53 26          	mov    %dx,0x26(%ebx)
}
  803aa9:	89 f8                	mov    %edi,%eax
  803aab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803aae:	5b                   	pop    %ebx
  803aaf:	5e                   	pop    %esi
  803ab0:	5f                   	pop    %edi
  803ab1:	5d                   	pop    %ebp
  803ab2:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803ab3:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ab8:	ba 35 00 00 00       	mov    $0x35,%edx
  803abd:	89 d8                	mov    %ebx,%eax
  803abf:	e8 98 ee ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803ac4:	ba 03 00 00 00       	mov    $0x3,%edx
  803ac9:	89 d8                	mov    %ebx,%eax
  803acb:	e8 4b ee ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803ad0:	b9 02 00 00 00       	mov    $0x2,%ecx
  803ad5:	ba 39 00 00 00       	mov    $0x39,%edx
  803ada:	89 d8                	mov    %ebx,%eax
  803adc:	e8 7b ee ff ff       	call   80295c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803ae1:	ba 40 02 00 00       	mov    $0x240,%edx
  803ae6:	89 d8                	mov    %ebx,%eax
  803ae8:	e8 d6 ee ff ff       	call   8029c3 <dhcp_option_short>
    dhcp_option_trailer(dhcp);
  803aed:	89 d8                	mov    %ebx,%eax
  803aef:	e8 2d ef ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803af4:	83 ec 08             	sub    $0x8,%esp
  803af7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803afb:	66 05 f0 00          	add    $0xf0,%ax
  803aff:	0f b7 c0             	movzwl %ax,%eax
  803b02:	50                   	push   %eax
  803b03:	ff 73 1c             	pushl  0x1c(%ebx)
  803b06:	e8 b7 10 00 00       	call   804bc2 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803b0b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803b0e:	83 c4 0c             	add    $0xc,%esp
  803b11:	6a 43                	push   $0x43
  803b13:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803b16:	50                   	push   %eax
  803b17:	ff 73 08             	pushl  0x8(%ebx)
  803b1a:	e8 58 54 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803b1f:	89 34 24             	mov    %esi,(%esp)
  803b22:	6a 43                	push   $0x43
  803b24:	ff 75 e4             	pushl  -0x1c(%ebp)
  803b27:	ff 73 1c             	pushl  0x1c(%ebx)
  803b2a:	ff 73 08             	pushl  0x8(%ebx)
  803b2d:	e8 50 52 00 00       	call   808d82 <udp_sendto_if>
    dhcp_delete_request(netif);
  803b32:	83 c4 20             	add    $0x20,%esp
  803b35:	89 f0                	mov    %esi,%eax
  803b37:	e8 25 f2 ff ff       	call   802d61 <dhcp_delete_request>
  803b3c:	e9 34 ff ff ff       	jmp    803a75 <dhcp_renew+0x28>

00803b41 <dhcp_coarse_tmr>:
{
  803b41:	55                   	push   %ebp
  803b42:	89 e5                	mov    %esp,%ebp
  803b44:	53                   	push   %ebx
  803b45:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803b48:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803b4e:	eb 1d                	jmp    803b6d <dhcp_coarse_tmr+0x2c>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b50:	8b 43 20             	mov    0x20(%ebx),%eax
  803b53:	0f b6 00             	movzbl (%eax),%eax
  803b56:	89 c2                	mov    %eax,%edx
  803b58:	83 e2 fb             	and    $0xfffffffb,%edx
  803b5b:	80 fa 01             	cmp    $0x1,%dl
  803b5e:	74 04                	je     803b64 <dhcp_coarse_tmr+0x23>
  803b60:	3c 0a                	cmp    $0xa,%al
  803b62:	75 07                	jne    803b6b <dhcp_coarse_tmr+0x2a>
    dhcp_rebind(netif);
  803b64:	89 d8                	mov    %ebx,%eax
  803b66:	e8 90 f2 ff ff       	call   802dfb <dhcp_rebind>
    netif = netif->next;
  803b6b:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803b6d:	85 db                	test   %ebx,%ebx
  803b6f:	74 4e                	je     803bbf <dhcp_coarse_tmr+0x7e>
    if (netif->dhcp != NULL) {
  803b71:	8b 43 20             	mov    0x20(%ebx),%eax
  803b74:	85 c0                	test   %eax,%eax
  803b76:	74 f3                	je     803b6b <dhcp_coarse_tmr+0x2a>
      if (netif->dhcp->t2_timeout-- == 1) {
  803b78:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  803b7c:	8d 4a ff             	lea    -0x1(%edx),%ecx
  803b7f:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  803b83:	66 83 fa 01          	cmp    $0x1,%dx
  803b87:	74 c7                	je     803b50 <dhcp_coarse_tmr+0xf>
      } else if (netif->dhcp->t1_timeout-- == 1) {
  803b89:	8b 53 20             	mov    0x20(%ebx),%edx
  803b8c:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  803b90:	8d 48 ff             	lea    -0x1(%eax),%ecx
  803b93:	66 89 4a 28          	mov    %cx,0x28(%edx)
  803b97:	66 83 f8 01          	cmp    $0x1,%ax
  803b9b:	75 ce                	jne    803b6b <dhcp_coarse_tmr+0x2a>
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  803b9d:	8b 43 20             	mov    0x20(%ebx),%eax
  803ba0:	0f b6 00             	movzbl (%eax),%eax
  803ba3:	89 c2                	mov    %eax,%edx
  803ba5:	83 e2 fb             	and    $0xfffffffb,%edx
  803ba8:	80 fa 01             	cmp    $0x1,%dl
  803bab:	74 04                	je     803bb1 <dhcp_coarse_tmr+0x70>
  803bad:	3c 0a                	cmp    $0xa,%al
  803baf:	75 ba                	jne    803b6b <dhcp_coarse_tmr+0x2a>
    dhcp_renew(netif);
  803bb1:	83 ec 0c             	sub    $0xc,%esp
  803bb4:	53                   	push   %ebx
  803bb5:	e8 93 fe ff ff       	call   803a4d <dhcp_renew>
  803bba:	83 c4 10             	add    $0x10,%esp
  803bbd:	eb ac                	jmp    803b6b <dhcp_coarse_tmr+0x2a>
}
  803bbf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803bc2:	c9                   	leave  
  803bc3:	c3                   	ret    

00803bc4 <dhcp_release>:
{
  803bc4:	55                   	push   %ebp
  803bc5:	89 e5                	mov    %esp,%ebp
  803bc7:	57                   	push   %edi
  803bc8:	56                   	push   %esi
  803bc9:	53                   	push   %ebx
  803bca:	83 ec 1c             	sub    $0x1c,%esp
  803bcd:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803bd0:	8b 5e 20             	mov    0x20(%esi),%ebx
  dhcp_set_state(dhcp, DHCP_OFF);
  803bd3:	ba 0d 00 00 00       	mov    $0xd,%edx
  803bd8:	89 d8                	mov    %ebx,%eax
  803bda:	e8 02 ec ff ff       	call   8027e1 <dhcp_set_state>
  dhcp->server_ip_addr.addr = 0;
  803bdf:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  803be6:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  803bed:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  803bf4:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  803bfb:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  803c02:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  803c09:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  803c10:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  803c17:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  result = dhcp_create_request(netif);
  803c1e:	89 f0                	mov    %esi,%eax
  803c20:	e8 49 ef ff ff       	call   802b6e <dhcp_create_request>
  803c25:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803c27:	84 c0                	test   %al,%al
  803c29:	74 71                	je     803c9c <dhcp_release+0xd8>
  dhcp->tries++;
  803c2b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803c2f:	83 c0 01             	add    $0x1,%eax
  803c32:	88 43 01             	mov    %al,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  803c35:	ba 10 27 00 00       	mov    $0x2710,%edx
  803c3a:	3c 09                	cmp    $0x9,%al
  803c3c:	77 08                	ja     803c46 <dhcp_release+0x82>
  803c3e:	0f b6 d0             	movzbl %al,%edx
  803c41:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803c46:	0f b7 d2             	movzwl %dx,%edx
  803c49:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803c4f:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803c54:	89 d0                	mov    %edx,%eax
  803c56:	f7 e9                	imul   %ecx
  803c58:	c1 fa 05             	sar    $0x5,%edx
  803c5b:	66 89 53 26          	mov    %dx,0x26(%ebx)
  netif_set_down(netif);
  803c5f:	83 ec 0c             	sub    $0xc,%esp
  803c62:	56                   	push   %esi
  803c63:	e8 30 0b 00 00       	call   804798 <netif_set_down>
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803c68:	83 c4 08             	add    $0x8,%esp
  803c6b:	68 a8 23 81 00       	push   $0x8123a8
  803c70:	56                   	push   %esi
  803c71:	e8 84 09 00 00       	call   8045fa <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803c76:	83 c4 08             	add    $0x8,%esp
  803c79:	68 a8 23 81 00       	push   $0x8123a8
  803c7e:	56                   	push   %esi
  803c7f:	e8 a2 0a 00 00       	call   804726 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  803c84:	83 c4 08             	add    $0x8,%esp
  803c87:	68 a8 23 81 00       	push   $0x8123a8
  803c8c:	56                   	push   %esi
  803c8d:	e8 ad 0a 00 00       	call   80473f <netif_set_netmask>
}
  803c92:	89 f8                	mov    %edi,%eax
  803c94:	8d 65 f4             	lea    -0xc(%ebp),%esp
  803c97:	5b                   	pop    %ebx
  803c98:	5e                   	pop    %esi
  803c99:	5f                   	pop    %edi
  803c9a:	5d                   	pop    %ebp
  803c9b:	c3                   	ret    
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803c9c:	b9 01 00 00 00       	mov    $0x1,%ecx
  803ca1:	ba 35 00 00 00       	mov    $0x35,%edx
  803ca6:	89 d8                	mov    %ebx,%eax
  803ca8:	e8 af ec ff ff       	call   80295c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  803cad:	ba 07 00 00 00       	mov    $0x7,%edx
  803cb2:	89 d8                	mov    %ebx,%eax
  803cb4:	e8 62 ec ff ff       	call   80291b <dhcp_option_byte>
    dhcp_option_trailer(dhcp);
  803cb9:	89 d8                	mov    %ebx,%eax
  803cbb:	e8 61 ed ff ff       	call   802a21 <dhcp_option_trailer>
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803cc0:	83 ec 08             	sub    $0x8,%esp
  803cc3:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803cc7:	66 05 f0 00          	add    $0xf0,%ax
  803ccb:	0f b7 c0             	movzwl %ax,%eax
  803cce:	50                   	push   %eax
  803ccf:	ff 73 1c             	pushl  0x1c(%ebx)
  803cd2:	e8 eb 0e 00 00       	call   804bc2 <pbuf_realloc>
    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803cd7:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803cda:	83 c4 0c             	add    $0xc,%esp
  803cdd:	6a 43                	push   $0x43
  803cdf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803ce2:	50                   	push   %eax
  803ce3:	ff 73 08             	pushl  0x8(%ebx)
  803ce6:	e8 8c 52 00 00       	call   808f77 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ceb:	89 34 24             	mov    %esi,(%esp)
  803cee:	6a 43                	push   $0x43
  803cf0:	ff 75 e4             	pushl  -0x1c(%ebp)
  803cf3:	ff 73 1c             	pushl  0x1c(%ebx)
  803cf6:	ff 73 08             	pushl  0x8(%ebx)
  803cf9:	e8 84 50 00 00       	call   808d82 <udp_sendto_if>
    dhcp_delete_request(netif);
  803cfe:	83 c4 20             	add    $0x20,%esp
  803d01:	89 f0                	mov    %esi,%eax
  803d03:	e8 59 f0 ff ff       	call   802d61 <dhcp_delete_request>
  803d08:	e9 1e ff ff ff       	jmp    803c2b <dhcp_release+0x67>

00803d0d <dhcp_fine_tmr>:
{
  803d0d:	55                   	push   %ebp
  803d0e:	89 e5                	mov    %esp,%ebp
  803d10:	53                   	push   %ebx
  803d11:	83 ec 04             	sub    $0x4,%esp
  struct netif *netif = netif_list;
  803d14:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  while (netif != NULL) {
  803d1a:	eb 04                	jmp    803d20 <dhcp_fine_tmr+0x13>
      else if (netif->dhcp->request_timeout == 1) {
  803d1c:	74 24                	je     803d42 <dhcp_fine_tmr+0x35>
    netif = netif->next;
  803d1e:	8b 1b                	mov    (%ebx),%ebx
  while (netif != NULL) {
  803d20:	85 db                	test   %ebx,%ebx
  803d22:	0f 84 c4 00 00 00    	je     803dec <dhcp_fine_tmr+0xdf>
    if (netif->dhcp != NULL) {
  803d28:	8b 43 20             	mov    0x20(%ebx),%eax
  803d2b:	85 c0                	test   %eax,%eax
  803d2d:	74 ef                	je     803d1e <dhcp_fine_tmr+0x11>
      if (netif->dhcp->request_timeout > 1) {
  803d2f:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  803d33:	66 83 fa 01          	cmp    $0x1,%dx
  803d37:	76 e3                	jbe    803d1c <dhcp_fine_tmr+0xf>
        netif->dhcp->request_timeout--;
  803d39:	83 ea 01             	sub    $0x1,%edx
  803d3c:	66 89 50 26          	mov    %dx,0x26(%eax)
  803d40:	eb dc                	jmp    803d1e <dhcp_fine_tmr+0x11>
        netif->dhcp->request_timeout--;
  803d42:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
  struct dhcp *dhcp = netif->dhcp;
  803d48:	8b 53 20             	mov    0x20(%ebx),%edx
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  803d4b:	0f b6 02             	movzbl (%edx),%eax
  803d4e:	3c 0c                	cmp    $0xc,%al
  803d50:	74 23                	je     803d75 <dhcp_fine_tmr+0x68>
  803d52:	3c 06                	cmp    $0x6,%al
  803d54:	74 1f                	je     803d75 <dhcp_fine_tmr+0x68>
  } else if (dhcp->state == DHCP_REQUESTING) {
  803d56:	3c 01                	cmp    $0x1,%al
  803d58:	74 24                	je     803d7e <dhcp_fine_tmr+0x71>
  } else if (dhcp->state == DHCP_CHECKING) {
  803d5a:	3c 08                	cmp    $0x8,%al
  803d5c:	74 47                	je     803da5 <dhcp_fine_tmr+0x98>
  else if (dhcp->state == DHCP_RENEWING) {
  803d5e:	3c 05                	cmp    $0x5,%al
  803d60:	74 61                	je     803dc3 <dhcp_fine_tmr+0xb6>
  } else if (dhcp->state == DHCP_REBINDING) {
  803d62:	3c 04                	cmp    $0x4,%al
  803d64:	75 b8                	jne    803d1e <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 8) {
  803d66:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  803d6a:	77 68                	ja     803dd4 <dhcp_fine_tmr+0xc7>
      dhcp_rebind(netif);
  803d6c:	89 d8                	mov    %ebx,%eax
  803d6e:	e8 88 f0 ff ff       	call   802dfb <dhcp_rebind>
  803d73:	eb a9                	jmp    803d1e <dhcp_fine_tmr+0x11>
    dhcp_discover(netif);
  803d75:	89 d8                	mov    %ebx,%eax
  803d77:	e8 72 f1 ff ff       	call   802eee <dhcp_discover>
  803d7c:	eb a0                	jmp    803d1e <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 5) {
  803d7e:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  803d82:	77 09                	ja     803d8d <dhcp_fine_tmr+0x80>
      dhcp_select(netif);
  803d84:	89 d8                	mov    %ebx,%eax
  803d86:	e8 a2 f2 ff ff       	call   80302d <dhcp_select>
  803d8b:	eb 91                	jmp    803d1e <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803d8d:	83 ec 0c             	sub    $0xc,%esp
  803d90:	53                   	push   %ebx
  803d91:	e8 2e fe ff ff       	call   803bc4 <dhcp_release>
      dhcp_discover(netif);
  803d96:	89 d8                	mov    %ebx,%eax
  803d98:	e8 51 f1 ff ff       	call   802eee <dhcp_discover>
  803d9d:	83 c4 10             	add    $0x10,%esp
  803da0:	e9 79 ff ff ff       	jmp    803d1e <dhcp_fine_tmr+0x11>
    if (dhcp->tries <= 1) {
  803da5:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  803da9:	76 0c                	jbe    803db7 <dhcp_fine_tmr+0xaa>
      dhcp_bind(netif);
  803dab:	89 d8                	mov    %ebx,%eax
  803dad:	e8 2b f4 ff ff       	call   8031dd <dhcp_bind>
  803db2:	e9 67 ff ff ff       	jmp    803d1e <dhcp_fine_tmr+0x11>
      dhcp_check(netif);
  803db7:	89 d8                	mov    %ebx,%eax
  803db9:	e8 eb f3 ff ff       	call   8031a9 <dhcp_check>
  803dbe:	e9 5b ff ff ff       	jmp    803d1e <dhcp_fine_tmr+0x11>
    dhcp_renew(netif);
  803dc3:	83 ec 0c             	sub    $0xc,%esp
  803dc6:	53                   	push   %ebx
  803dc7:	e8 81 fc ff ff       	call   803a4d <dhcp_renew>
  803dcc:	83 c4 10             	add    $0x10,%esp
  803dcf:	e9 4a ff ff ff       	jmp    803d1e <dhcp_fine_tmr+0x11>
      dhcp_release(netif);
  803dd4:	83 ec 0c             	sub    $0xc,%esp
  803dd7:	53                   	push   %ebx
  803dd8:	e8 e7 fd ff ff       	call   803bc4 <dhcp_release>
      dhcp_discover(netif);
  803ddd:	89 d8                	mov    %ebx,%eax
  803ddf:	e8 0a f1 ff ff       	call   802eee <dhcp_discover>
  803de4:	83 c4 10             	add    $0x10,%esp
  803de7:	e9 32 ff ff ff       	jmp    803d1e <dhcp_fine_tmr+0x11>
}
  803dec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  803def:	c9                   	leave  
  803df0:	c3                   	ret    

00803df1 <dhcp_stop>:
{
  803df1:	55                   	push   %ebp
  803df2:	89 e5                	mov    %esp,%ebp
  803df4:	56                   	push   %esi
  803df5:	53                   	push   %ebx
  803df6:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803df9:	8b 5e 20             	mov    0x20(%esi),%ebx
  netif->flags &= ~NETIF_FLAG_DHCP;
  803dfc:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)
  if (dhcp != NULL) {
  803e00:	85 db                	test   %ebx,%ebx
  803e02:	74 4e                	je     803e52 <dhcp_stop+0x61>
    if (dhcp->pcb != NULL) {
  803e04:	8b 43 08             	mov    0x8(%ebx),%eax
  803e07:	85 c0                	test   %eax,%eax
  803e09:	74 13                	je     803e1e <dhcp_stop+0x2d>
      udp_remove(dhcp->pcb);
  803e0b:	83 ec 0c             	sub    $0xc,%esp
  803e0e:	50                   	push   %eax
  803e0f:	e8 03 52 00 00       	call   809017 <udp_remove>
      dhcp->pcb = NULL;
  803e14:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  803e1b:	83 c4 10             	add    $0x10,%esp
    if (dhcp->p != NULL) {
  803e1e:	8b 43 0c             	mov    0xc(%ebx),%eax
  803e21:	85 c0                	test   %eax,%eax
  803e23:	74 13                	je     803e38 <dhcp_stop+0x47>
      pbuf_free(dhcp->p);
  803e25:	83 ec 0c             	sub    $0xc,%esp
  803e28:	50                   	push   %eax
  803e29:	e8 5c 0a 00 00       	call   80488a <pbuf_free>
      dhcp->p = NULL;
  803e2e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  803e35:	83 c4 10             	add    $0x10,%esp
    dhcp_free_reply(dhcp);
  803e38:	89 d8                	mov    %ebx,%eax
  803e3a:	e8 51 f5 ff ff       	call   803390 <dhcp_free_reply>
    mem_free((void *)dhcp);
  803e3f:	83 ec 0c             	sub    $0xc,%esp
  803e42:	53                   	push   %ebx
  803e43:	e8 5c 01 00 00       	call   803fa4 <mem_free>
    netif->dhcp = NULL;
  803e48:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  803e4f:	83 c4 10             	add    $0x10,%esp
}
  803e52:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803e55:	5b                   	pop    %ebx
  803e56:	5e                   	pop    %esi
  803e57:	5d                   	pop    %ebp
  803e58:	c3                   	ret    

00803e59 <dhcp_start>:
{
  803e59:	55                   	push   %ebp
  803e5a:	89 e5                	mov    %esp,%ebp
  803e5c:	56                   	push   %esi
  803e5d:	53                   	push   %ebx
  803e5e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803e61:	85 db                	test   %ebx,%ebx
  803e63:	74 73                	je     803ed8 <dhcp_start+0x7f>
  dhcp = netif->dhcp;
  803e65:	8b 73 20             	mov    0x20(%ebx),%esi
  netif->flags &= ~NETIF_FLAG_DHCP;
  803e68:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)
  if (dhcp == NULL) {
  803e6c:	85 f6                	test   %esi,%esi
  803e6e:	74 7f                	je     803eef <dhcp_start+0x96>
  memset(dhcp, 0, sizeof(struct dhcp));
  803e70:	83 ec 04             	sub    $0x4,%esp
  803e73:	6a 58                	push   $0x58
  803e75:	6a 00                	push   $0x0
  803e77:	56                   	push   %esi
  803e78:	e8 b7 b1 00 00       	call   80f034 <memset>
  dhcp->pcb = udp_new();
  803e7d:	e8 d9 51 00 00       	call   80905b <udp_new>
  803e82:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  803e85:	83 c4 10             	add    $0x10,%esp
  803e88:	85 c0                	test   %eax,%eax
  803e8a:	74 7e                	je     803f0a <dhcp_start+0xb1>
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803e8c:	83 ec 04             	sub    $0x4,%esp
  803e8f:	6a 44                	push   $0x44
  803e91:	68 a8 23 81 00       	push   $0x8123a8
  803e96:	50                   	push   %eax
  803e97:	e8 2b 4e 00 00       	call   808cc7 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803e9c:	83 c4 0c             	add    $0xc,%esp
  803e9f:	6a 43                	push   $0x43
  803ea1:	68 a8 23 81 00       	push   $0x8123a8
  803ea6:	ff 76 08             	pushl  0x8(%esi)
  803ea9:	e8 c9 50 00 00       	call   808f77 <udp_connect>
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  803eae:	83 c4 0c             	add    $0xc,%esp
  803eb1:	53                   	push   %ebx
  803eb2:	68 d8 33 80 00       	push   $0x8033d8
  803eb7:	ff 76 08             	pushl  0x8(%esi)
  803eba:	e8 44 51 00 00       	call   809003 <udp_recv>
  result = dhcp_discover(netif);
  803ebf:	89 d8                	mov    %ebx,%eax
  803ec1:	e8 28 f0 ff ff       	call   802eee <dhcp_discover>
  if (result != ERR_OK) {
  803ec6:	83 c4 10             	add    $0x10,%esp
  803ec9:	84 c0                	test   %al,%al
  803ecb:	75 57                	jne    803f24 <dhcp_start+0xcb>
  netif->flags |= NETIF_FLAG_DHCP;
  803ecd:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
}
  803ed1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  803ed4:	5b                   	pop    %ebx
  803ed5:	5e                   	pop    %esi
  803ed6:	5d                   	pop    %ebp
  803ed7:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  803ed8:	83 ec 04             	sub    $0x4,%esp
  803edb:	68 22 1b 81 00       	push   $0x811b22
  803ee0:	68 38 02 00 00       	push   $0x238
  803ee5:	68 02 1b 81 00       	push   $0x811b02
  803eea:	e8 aa a7 00 00       	call   80e699 <_panic>
    dhcp = mem_malloc(sizeof(struct dhcp));
  803eef:	83 ec 0c             	sub    $0xc,%esp
  803ef2:	6a 58                	push   $0x58
  803ef4:	e8 9a 03 00 00       	call   804293 <mem_malloc>
  803ef9:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  803efb:	83 c4 10             	add    $0x10,%esp
  803efe:	85 c0                	test   %eax,%eax
  803f00:	74 35                	je     803f37 <dhcp_start+0xde>
    netif->dhcp = dhcp;
  803f02:	89 43 20             	mov    %eax,0x20(%ebx)
  803f05:	e9 66 ff ff ff       	jmp    803e70 <dhcp_start+0x17>
    mem_free((void *)dhcp);
  803f0a:	83 ec 0c             	sub    $0xc,%esp
  803f0d:	56                   	push   %esi
  803f0e:	e8 91 00 00 00       	call   803fa4 <mem_free>
    netif->dhcp = dhcp = NULL;
  803f13:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  803f1a:	83 c4 10             	add    $0x10,%esp
  803f1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f22:	eb ad                	jmp    803ed1 <dhcp_start+0x78>
    dhcp_stop(netif);
  803f24:	83 ec 0c             	sub    $0xc,%esp
  803f27:	53                   	push   %ebx
  803f28:	e8 c4 fe ff ff       	call   803df1 <dhcp_stop>
    return ERR_MEM;
  803f2d:	83 c4 10             	add    $0x10,%esp
  803f30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f35:	eb 9a                	jmp    803ed1 <dhcp_start+0x78>
      return ERR_MEM;
  803f37:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803f3c:	eb 93                	jmp    803ed1 <dhcp_start+0x78>

00803f3e <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  803f3e:	55                   	push   %ebp
  803f3f:	89 e5                	mov    %esp,%ebp
  803f41:	83 ec 14             	sub    $0x14,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  803f44:	b8 23 53 81 00       	mov    $0x815323,%eax
  803f49:	83 e0 fc             	and    $0xfffffffc,%eax
  803f4c:	a3 0c 53 81 00       	mov    %eax,0x81530c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  803f51:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  803f57:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  803f5e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  803f62:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  803f68:	89 15 08 53 81 00    	mov    %edx,0x815308
  ram_end->used = 1;
  803f6e:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  803f75:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  803f7c:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  803f7f:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  803f86:	00 22 00 

  mem_sem = sys_sem_new(1);
  803f89:	6a 01                	push   $0x1
  803f8b:	e8 ad 5e 00 00       	call   809e3d <sys_sem_new>
  803f90:	a3 00 53 81 00       	mov    %eax,0x815300

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  803f95:	a1 0c 53 81 00       	mov    0x81530c,%eax
  803f9a:	a3 04 53 81 00       	mov    %eax,0x815304

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  803f9f:	83 c4 10             	add    $0x10,%esp
  803fa2:	c9                   	leave  
  803fa3:	c3                   	ret    

00803fa4 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  803fa4:	55                   	push   %ebp
  803fa5:	89 e5                	mov    %esp,%ebp
  803fa7:	56                   	push   %esi
  803fa8:	53                   	push   %ebx
  803fa9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  803fac:	85 db                	test   %ebx,%ebx
  803fae:	0f 84 e1 00 00 00    	je     804095 <mem_free+0xf1>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  803fb4:	f6 c3 03             	test   $0x3,%bl
  803fb7:	0f 85 df 00 00 00    	jne    80409c <mem_free+0xf8>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  803fbd:	39 1d 0c 53 81 00    	cmp    %ebx,0x81530c
  803fc3:	0f 87 ea 00 00 00    	ja     8040b3 <mem_free+0x10f>
  803fc9:	39 1d 08 53 81 00    	cmp    %ebx,0x815308
  803fcf:	0f 86 de 00 00 00    	jbe    8040b3 <mem_free+0x10f>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  803fd5:	83 ec 08             	sub    $0x8,%esp
  803fd8:	6a 00                	push   $0x0
  803fda:	ff 35 00 53 81 00    	pushl  0x815300
  803fe0:	e8 85 61 00 00       	call   80a16a <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  803fe5:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  803fe8:	83 c4 10             	add    $0x10,%esp
  803feb:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  803fef:	0f 84 d5 00 00 00    	je     8040ca <mem_free+0x126>
  /* ... and is now unused. */
  mem->used = 0;
  803ff5:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  803ff9:	39 05 04 53 81 00    	cmp    %eax,0x815304
  803fff:	76 05                	jbe    804006 <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  804001:	a3 04 53 81 00       	mov    %eax,0x815304
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  804006:	8b 0d 0c 53 81 00    	mov    0x81530c,%ecx
  80400c:	39 c8                	cmp    %ecx,%eax
  80400e:	0f 82 cd 00 00 00    	jb     8040e1 <mem_free+0x13d>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  804014:	8b 35 08 53 81 00    	mov    0x815308,%esi
  80401a:	39 f0                	cmp    %esi,%eax
  80401c:	0f 83 d6 00 00 00    	jae    8040f8 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  804022:	8b 53 f4             	mov    -0xc(%ebx),%edx
  804025:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80402b:	0f 87 de 00 00 00    	ja     80410f <mem_free+0x16b>
  nmem = (struct mem *)&ram[mem->next];
  804031:	01 ca                	add    %ecx,%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804033:	39 d0                	cmp    %edx,%eax
  804035:	74 25                	je     80405c <mem_free+0xb8>
  804037:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80403b:	75 1f                	jne    80405c <mem_free+0xb8>
  80403d:	39 d6                	cmp    %edx,%esi
  80403f:	74 1b                	je     80405c <mem_free+0xb8>
    if (lfree == nmem) {
  804041:	3b 15 04 53 81 00    	cmp    0x815304,%edx
  804047:	0f 84 d9 00 00 00    	je     804126 <mem_free+0x182>
    mem->next = nmem->next;
  80404d:	8b 32                	mov    (%edx),%esi
  80404f:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804052:	8b 12                	mov    (%edx),%edx
  804054:	89 c6                	mov    %eax,%esi
  804056:	29 ce                	sub    %ecx,%esi
  804058:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  pmem = (struct mem *)&ram[mem->prev];
  80405c:	8b 73 f8             	mov    -0x8(%ebx),%esi
  80405f:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  if (pmem != mem && pmem->used == 0) {
  804062:	39 d0                	cmp    %edx,%eax
  804064:	74 1e                	je     804084 <mem_free+0xe0>
  804066:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80406a:	75 18                	jne    804084 <mem_free+0xe0>
    if (lfree == mem) {
  80406c:	3b 05 04 53 81 00    	cmp    0x815304,%eax
  804072:	0f 84 b8 00 00 00    	je     804130 <mem_free+0x18c>
    pmem->next = mem->next;
  804078:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80407b:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80407d:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804080:	89 74 01 04          	mov    %esi,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  804084:	83 ec 0c             	sub    $0xc,%esp
  804087:	ff 35 00 53 81 00    	pushl  0x815300
  80408d:	e8 68 60 00 00       	call   80a0fa <sys_sem_signal>
  804092:	83 c4 10             	add    $0x10,%esp
}
  804095:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804098:	5b                   	pop    %ebx
  804099:	5e                   	pop    %esi
  80409a:	5d                   	pop    %ebp
  80409b:	c3                   	ret    
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80409c:	83 ec 04             	sub    $0x4,%esp
  80409f:	68 74 1b 81 00       	push   $0x811b74
  8040a4:	68 30 01 00 00       	push   $0x130
  8040a9:	68 6b 1c 81 00       	push   $0x811c6b
  8040ae:	e8 e6 a5 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8040b3:	83 ec 04             	sub    $0x4,%esp
  8040b6:	68 7f 1c 81 00       	push   $0x811c7f
  8040bb:	68 33 01 00 00       	push   $0x133
  8040c0:	68 6b 1c 81 00       	push   $0x811c6b
  8040c5:	e8 cf a5 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8040ca:	83 ec 04             	sub    $0x4,%esp
  8040cd:	68 96 1c 81 00       	push   $0x811c96
  8040d2:	68 43 01 00 00       	push   $0x143
  8040d7:	68 6b 1c 81 00       	push   $0x811c6b
  8040dc:	e8 b8 a5 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  8040e1:	83 ec 04             	sub    $0x4,%esp
  8040e4:	68 aa 1c 81 00       	push   $0x811caa
  8040e9:	68 e3 00 00 00       	push   $0xe3
  8040ee:	68 6b 1c 81 00       	push   $0x811c6b
  8040f3:	e8 a1 a5 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  8040f8:	83 ec 04             	sub    $0x4,%esp
  8040fb:	68 c1 1c 81 00       	push   $0x811cc1
  804100:	68 e4 00 00 00       	push   $0xe4
  804105:	68 6b 1c 81 00       	push   $0x811c6b
  80410a:	e8 8a a5 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80410f:	83 ec 04             	sub    $0x4,%esp
  804112:	68 98 1b 81 00       	push   $0x811b98
  804117:	68 e8 00 00 00       	push   $0xe8
  80411c:	68 6b 1c 81 00       	push   $0x811c6b
  804121:	e8 73 a5 00 00       	call   80e699 <_panic>
      lfree = mem;
  804126:	a3 04 53 81 00       	mov    %eax,0x815304
  80412b:	e9 1d ff ff ff       	jmp    80404d <mem_free+0xa9>
      lfree = pmem;
  804130:	89 15 04 53 81 00    	mov    %edx,0x815304
  804136:	e9 3d ff ff ff       	jmp    804078 <mem_free+0xd4>

0080413b <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80413b:	55                   	push   %ebp
  80413c:	89 e5                	mov    %esp,%ebp
  80413e:	57                   	push   %edi
  80413f:	56                   	push   %esi
  804140:	53                   	push   %ebx
  804141:	83 ec 1c             	sub    $0x1c,%esp
  804144:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  804147:	8b 45 0c             	mov    0xc(%ebp),%eax
  80414a:	8d 58 03             	lea    0x3(%eax),%ebx
  80414d:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  804150:	83 fb 0b             	cmp    $0xb,%ebx
  804153:	76 12                	jbe    804167 <mem_realloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  804155:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  80415b:	76 0f                	jbe    80416c <mem_realloc+0x31>
    return NULL;
  80415d:	be 00 00 00 00       	mov    $0x0,%esi
  804162:	e9 a1 00 00 00       	jmp    804208 <mem_realloc+0xcd>
    newsize = MIN_SIZE_ALIGNED;
  804167:	bb 0c 00 00 00       	mov    $0xc,%ebx
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80416c:	a1 0c 53 81 00       	mov    0x81530c,%eax
  804171:	39 f0                	cmp    %esi,%eax
  804173:	0f 87 99 00 00 00    	ja     804212 <mem_realloc+0xd7>
  804179:	39 35 08 53 81 00    	cmp    %esi,0x815308
  80417f:	0f 86 8d 00 00 00    	jbe    804212 <mem_realloc+0xd7>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  804185:	8d 56 f4             	lea    -0xc(%esi),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  804188:	29 c2                	sub    %eax,%edx
  80418a:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80418d:	8b 4e f4             	mov    -0xc(%esi),%ecx
  804190:	8d 79 f4             	lea    -0xc(%ecx),%edi
  804193:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804195:	39 df                	cmp    %ebx,%edi
  804197:	0f 82 8c 00 00 00    	jb     804229 <mem_realloc+0xee>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  80419d:	74 69                	je     804208 <mem_realloc+0xcd>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80419f:	83 ec 08             	sub    $0x8,%esp
  8041a2:	6a 00                	push   $0x0
  8041a4:	ff 35 00 53 81 00    	pushl  0x815300
  8041aa:	e8 bb 5f 00 00       	call   80a16a <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8041af:	a1 0c 53 81 00       	mov    0x81530c,%eax
  8041b4:	89 c2                	mov    %eax,%edx
  8041b6:	03 56 f4             	add    -0xc(%esi),%edx
  if(mem2->used == 0) {
  8041b9:	83 c4 10             	add    $0x10,%esp
  8041bc:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8041c0:	0f 85 85 00 00 00    	jne    80424b <mem_realloc+0x110>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8041c6:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8041c8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8041cb:	8d 5c 3b 0c          	lea    0xc(%ebx,%edi,1),%ebx
    if (lfree == mem2) {
  8041cf:	39 15 04 53 81 00    	cmp    %edx,0x815304
  8041d5:	74 69                	je     804240 <mem_realloc+0x105>
      lfree = (struct mem *)&ram[ptr2];
    }
    mem2 = (struct mem *)&ram[ptr2];
  8041d7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8041da:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8041de:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8041e0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8041e3:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8041e6:	89 5e f4             	mov    %ebx,-0xc(%esi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8041e9:	8b 12                	mov    (%edx),%edx
  8041eb:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8041f1:	74 04                	je     8041f7 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8041f3:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8041f7:	83 ec 0c             	sub    $0xc,%esp
  8041fa:	ff 35 00 53 81 00    	pushl  0x815300
  804200:	e8 f5 5e 00 00       	call   80a0fa <sys_sem_signal>
  return rmem;
  804205:	83 c4 10             	add    $0x10,%esp
}
  804208:	89 f0                	mov    %esi,%eax
  80420a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80420d:	5b                   	pop    %ebx
  80420e:	5e                   	pop    %esi
  80420f:	5f                   	pop    %edi
  804210:	5d                   	pop    %ebp
  804211:	c3                   	ret    
  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804212:	83 ec 04             	sub    $0x4,%esp
  804215:	68 db 1c 81 00       	push   $0x811cdb
  80421a:	68 79 01 00 00       	push   $0x179
  80421f:	68 6b 1c 81 00       	push   $0x811c6b
  804224:	e8 70 a4 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804229:	83 ec 04             	sub    $0x4,%esp
  80422c:	68 c4 1b 81 00       	push   $0x811bc4
  804231:	68 8a 01 00 00       	push   $0x18a
  804236:	68 6b 1c 81 00       	push   $0x811c6b
  80423b:	e8 59 a4 00 00       	call   80e699 <_panic>
      lfree = (struct mem *)&ram[ptr2];
  804240:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  804243:	89 15 04 53 81 00    	mov    %edx,0x815304
  804249:	eb 8c                	jmp    8041d7 <mem_realloc+0x9c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80424b:	8d 53 18             	lea    0x18(%ebx),%edx
  80424e:	39 fa                	cmp    %edi,%edx
  804250:	77 a5                	ja     8041f7 <mem_realloc+0xbc>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804252:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  804255:	8d 4c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  804259:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  80425c:	39 15 04 53 81 00    	cmp    %edx,0x815304
  804262:	76 06                	jbe    80426a <mem_realloc+0x12f>
      lfree = mem2;
  804264:	89 15 04 53 81 00    	mov    %edx,0x815304
    mem2->used = 0;
  80426a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  80426e:	8b 5e f4             	mov    -0xc(%esi),%ebx
  804271:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  804273:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804276:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  804279:	89 4e f4             	mov    %ecx,-0xc(%esi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80427c:	8b 12                	mov    (%edx),%edx
  80427e:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  804284:	0f 84 6d ff ff ff    	je     8041f7 <mem_realloc+0xbc>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80428a:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
  80428e:	e9 64 ff ff ff       	jmp    8041f7 <mem_realloc+0xbc>

00804293 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  804293:	55                   	push   %ebp
  804294:	89 e5                	mov    %esp,%ebp
  804296:	57                   	push   %edi
  804297:	56                   	push   %esi
  804298:	53                   	push   %ebx
  804299:	83 ec 1c             	sub    $0x1c,%esp
  80429c:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80429f:	85 c0                	test   %eax,%eax
  8042a1:	0f 84 a0 01 00 00    	je     804447 <mem_malloc+0x1b4>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8042a7:	83 c0 03             	add    $0x3,%eax
  8042aa:	83 e0 fc             	and    $0xfffffffc,%eax
  8042ad:	89 c7                	mov    %eax,%edi

  if(size < MIN_SIZE_ALIGNED) {
  8042af:	83 f8 0b             	cmp    $0xb,%eax
  8042b2:	76 3a                	jbe    8042ee <mem_malloc+0x5b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  8042b4:	3d 00 00 22 00       	cmp    $0x220000,%eax
  8042b9:	0f 87 8f 01 00 00    	ja     80444e <mem_malloc+0x1bb>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  8042bf:	83 ec 08             	sub    $0x8,%esp
  8042c2:	6a 00                	push   $0x0
  8042c4:	ff 35 00 53 81 00    	pushl  0x815300
  8042ca:	e8 9b 5e 00 00       	call   80a16a <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8042cf:	a1 04 53 81 00       	mov    0x815304,%eax
  8042d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8042d7:	8b 35 0c 53 81 00    	mov    0x81530c,%esi
  8042dd:	29 f0                	sub    %esi,%eax
  8042df:	83 c4 10             	add    $0x10,%esp
  8042e2:	b9 00 00 22 00       	mov    $0x220000,%ecx
  8042e7:	29 f9                	sub    %edi,%ecx
  8042e9:	e9 e2 00 00 00       	jmp    8043d0 <mem_malloc+0x13d>
    size = MIN_SIZE_ALIGNED;
  8042ee:	bf 0c 00 00 00       	mov    $0xc,%edi
  8042f3:	eb ca                	jmp    8042bf <mem_malloc+0x2c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  8042f5:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8042f9:	39 5d e4             	cmp    %ebx,-0x1c(%ebp)
  8042fc:	74 4c                	je     80434a <mem_malloc+0xb7>
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8042fe:	83 ec 0c             	sub    $0xc,%esp
  804301:	ff 35 00 53 81 00    	pushl  0x815300
  804307:	e8 ee 5d 00 00       	call   80a0fa <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80430c:	8d 44 3b 0c          	lea    0xc(%ebx,%edi,1),%eax
  804310:	83 c4 10             	add    $0x10,%esp
  804313:	39 05 08 53 81 00    	cmp    %eax,0x815308
  804319:	0f 82 81 00 00 00    	jb     8043a0 <mem_malloc+0x10d>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80431f:	8d 43 0c             	lea    0xc(%ebx),%eax
  804322:	a8 03                	test   $0x3,%al
  804324:	0f 85 8d 00 00 00    	jne    8043b7 <mem_malloc+0x124>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80432a:	f6 c3 03             	test   $0x3,%bl
  80432d:	0f 84 0c 01 00 00    	je     80443f <mem_malloc+0x1ac>
  804333:	83 ec 04             	sub    $0x4,%esp
  804336:	68 48 1c 81 00       	push   $0x811c48
  80433b:	68 4f 02 00 00       	push   $0x24f
  804340:	68 6b 1c 81 00       	push   $0x811c6b
  804345:	e8 4f a3 00 00       	call   80e699 <_panic>
          while (lfree->used && lfree != ram_end) {
  80434a:	8b 15 08 53 81 00    	mov    0x815308,%edx
  804350:	b8 00 00 00 00       	mov    $0x0,%eax
  804355:	b9 01 00 00 00       	mov    $0x1,%ecx
  80435a:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80435d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804360:	eb 08                	jmp    80436a <mem_malloc+0xd7>
            lfree = (struct mem *)&ram[lfree->next];
  804362:	89 f0                	mov    %esi,%eax
  804364:	03 07                	add    (%edi),%eax
  804366:	89 c7                	mov    %eax,%edi
  804368:	89 c8                	mov    %ecx,%eax
          while (lfree->used && lfree != ram_end) {
  80436a:	80 7f 08 00          	cmpb   $0x0,0x8(%edi)
  80436e:	74 18                	je     804388 <mem_malloc+0xf5>
  804370:	39 fa                	cmp    %edi,%edx
  804372:	75 ee                	jne    804362 <mem_malloc+0xcf>
  804374:	89 fe                	mov    %edi,%esi
  804376:	8b 7d e0             	mov    -0x20(%ebp),%edi
  804379:	84 c0                	test   %al,%al
  80437b:	74 81                	je     8042fe <mem_malloc+0x6b>
  80437d:	89 35 04 53 81 00    	mov    %esi,0x815304
  804383:	e9 76 ff ff ff       	jmp    8042fe <mem_malloc+0x6b>
  804388:	89 fe                	mov    %edi,%esi
  80438a:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80438d:	84 c0                	test   %al,%al
  80438f:	0f 84 69 ff ff ff    	je     8042fe <mem_malloc+0x6b>
  804395:	89 35 04 53 81 00    	mov    %esi,0x815304
  80439b:	e9 5e ff ff ff       	jmp    8042fe <mem_malloc+0x6b>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8043a0:	83 ec 04             	sub    $0x4,%esp
  8043a3:	68 e8 1b 81 00       	push   $0x811be8
  8043a8:	68 4b 02 00 00       	push   $0x24b
  8043ad:	68 6b 1c 81 00       	push   $0x811c6b
  8043b2:	e8 e2 a2 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  8043b7:	83 ec 04             	sub    $0x4,%esp
  8043ba:	68 18 1c 81 00       	push   $0x811c18
  8043bf:	68 4d 02 00 00       	push   $0x24d
  8043c4:	68 6b 1c 81 00       	push   $0x811c6b
  8043c9:	e8 cb a2 00 00       	call   80e699 <_panic>
         ptr = ((struct mem *)&ram[ptr])->next) {
  8043ce:	8b 03                	mov    (%ebx),%eax
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  8043d0:	39 c1                	cmp    %eax,%ecx
  8043d2:	76 55                	jbe    804429 <mem_malloc+0x196>
      mem = (struct mem *)&ram[ptr];
  8043d4:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
      if ((!mem->used) &&
  8043d7:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8043db:	75 f1                	jne    8043ce <mem_malloc+0x13b>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  8043dd:	ba f4 ff ff ff       	mov    $0xfffffff4,%edx
  8043e2:	29 c2                	sub    %eax,%edx
  8043e4:	03 13                	add    (%ebx),%edx
      if ((!mem->used) &&
  8043e6:	39 fa                	cmp    %edi,%edx
  8043e8:	72 e4                	jb     8043ce <mem_malloc+0x13b>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  8043ea:	8d 4f 18             	lea    0x18(%edi),%ecx
  8043ed:	39 ca                	cmp    %ecx,%edx
  8043ef:	0f 82 00 ff ff ff    	jb     8042f5 <mem_malloc+0x62>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  8043f5:	8d 4c 38 0c          	lea    0xc(%eax,%edi,1),%ecx
          mem2 = (struct mem *)&ram[ptr2];
  8043f9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  8043fc:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  8043ff:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  804403:	8b 0b                	mov    (%ebx),%ecx
  804405:	89 0a                	mov    %ecx,(%edx)
          mem2->prev = ptr;
  804407:	89 42 04             	mov    %eax,0x4(%edx)
          mem->next = ptr2;
  80440a:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80440d:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  80440f:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          if (mem2->next != MEM_SIZE_ALIGNED) {
  804413:	8b 02                	mov    (%edx),%eax
  804415:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80441a:	0f 84 d9 fe ff ff    	je     8042f9 <mem_malloc+0x66>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804420:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  804424:	e9 d0 fe ff ff       	jmp    8042f9 <mem_malloc+0x66>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804429:	83 ec 0c             	sub    $0xc,%esp
  80442c:	ff 35 00 53 81 00    	pushl  0x815300
  804432:	e8 c3 5c 00 00       	call   80a0fa <sys_sem_signal>
  return NULL;
  804437:	83 c4 10             	add    $0x10,%esp
  80443a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80443f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804442:	5b                   	pop    %ebx
  804443:	5e                   	pop    %esi
  804444:	5f                   	pop    %edi
  804445:	5d                   	pop    %ebp
  804446:	c3                   	ret    
    return NULL;
  804447:	b8 00 00 00 00       	mov    $0x0,%eax
  80444c:	eb f1                	jmp    80443f <mem_malloc+0x1ac>
    return NULL;
  80444e:	b8 00 00 00 00       	mov    $0x0,%eax
  804453:	eb ea                	jmp    80443f <mem_malloc+0x1ac>

00804455 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804455:	55                   	push   %ebp
  804456:	89 e5                	mov    %esp,%ebp
  804458:	56                   	push   %esi
  804459:	53                   	push   %ebx
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80445a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80445d:	0f af 5d 08          	imul   0x8(%ebp),%ebx
  804461:	83 ec 0c             	sub    $0xc,%esp
  804464:	53                   	push   %ebx
  804465:	e8 29 fe ff ff       	call   804293 <mem_malloc>
  80446a:	89 c6                	mov    %eax,%esi
  if (p) {
  80446c:	83 c4 10             	add    $0x10,%esp
  80446f:	85 c0                	test   %eax,%eax
  804471:	74 0f                	je     804482 <mem_calloc+0x2d>
    /* zero the memory */
    memset(p, 0, count * size);
  804473:	83 ec 04             	sub    $0x4,%esp
  804476:	53                   	push   %ebx
  804477:	6a 00                	push   $0x0
  804479:	50                   	push   %eax
  80447a:	e8 b5 ab 00 00       	call   80f034 <memset>
  80447f:	83 c4 10             	add    $0x10,%esp
  }
  return p;
}
  804482:	89 f0                	mov    %esi,%eax
  804484:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804487:	5b                   	pop    %ebx
  804488:	5e                   	pop    %esi
  804489:	5d                   	pop    %ebp
  80448a:	c3                   	ret    

0080448b <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80448b:	55                   	push   %ebp
  80448c:	89 e5                	mov    %esp,%ebp
  80448e:	56                   	push   %esi
  80448f:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  804490:	b8 43 53 a3 00       	mov    $0xa35343,%eax
  804495:	83 e0 fc             	and    $0xfffffffc,%eax
  804498:	ba 00 00 00 00       	mov    $0x0,%edx
  80449d:	eb 08                	jmp    8044a7 <memp_init+0x1c>
  80449f:	83 c2 01             	add    $0x1,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8044a2:	83 fa 0e             	cmp    $0xe,%edx
  8044a5:	74 3c                	je     8044e3 <memp_init+0x58>
    memp_tab[i] = NULL;
  8044a7:	c7 04 95 c0 43 b3 00 	movl   $0x0,0xb343c0(,%edx,4)
  8044ae:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8044b2:	0f b7 b4 12 6c 1d 81 	movzwl 0x811d6c(%edx,%edx,1),%esi
  8044b9:	00 
  8044ba:	b9 00 00 00 00       	mov    $0x0,%ecx
  8044bf:	66 39 ce             	cmp    %cx,%si
  8044c2:	74 db                	je     80449f <memp_init+0x14>
      memp->next = memp_tab[i];
  8044c4:	8b 1c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ebx
  8044cb:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  8044cd:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8044d4:	0f b7 9c 12 88 1d 81 	movzwl 0x811d88(%edx,%edx,1),%ebx
  8044db:	00 
  8044dc:	01 d8                	add    %ebx,%eax
    for (j = 0; j < memp_num[i]; ++j) {
  8044de:	83 c1 01             	add    $0x1,%ecx
  8044e1:	eb dc                	jmp    8044bf <memp_init+0x34>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8044e3:	5b                   	pop    %ebx
  8044e4:	5e                   	pop    %esi
  8044e5:	5d                   	pop    %ebp
  8044e6:	c3                   	ret    

008044e7 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  8044e7:	55                   	push   %ebp
  8044e8:	89 e5                	mov    %esp,%ebp
  8044ea:	83 ec 08             	sub    $0x8,%esp
  8044ed:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  8044f0:	83 fa 0d             	cmp    $0xd,%edx
  8044f3:	77 1a                	ja     80450f <memp_malloc+0x28>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  8044f5:	8b 04 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%eax
  
  if (memp != NULL) {    
  8044fc:	85 c0                	test   %eax,%eax
  8044fe:	74 0d                	je     80450d <memp_malloc+0x26>
    memp_tab[type] = memp->next;    
  804500:	8b 08                	mov    (%eax),%ecx
  804502:	89 0c 95 c0 43 b3 00 	mov    %ecx,0xb343c0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804509:	a8 03                	test   $0x3,%al
  80450b:	75 19                	jne    804526 <memp_malloc+0x3f>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  80450d:	c9                   	leave  
  80450e:	c3                   	ret    
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80450f:	83 ec 04             	sub    $0x4,%esp
  804512:	68 f5 1c 81 00       	push   $0x811cf5
  804517:	68 2d 01 00 00       	push   $0x12d
  80451c:	68 12 1d 81 00       	push   $0x811d12
  804521:	e8 73 a1 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804526:	83 ec 04             	sub    $0x4,%esp
  804529:	68 28 1d 81 00       	push   $0x811d28
  80452e:	68 3f 01 00 00       	push   $0x13f
  804533:	68 12 1d 81 00       	push   $0x811d12
  804538:	e8 5c a1 00 00       	call   80e699 <_panic>

0080453d <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80453d:	55                   	push   %ebp
  80453e:	89 e5                	mov    %esp,%ebp
  804540:	83 ec 08             	sub    $0x8,%esp
  804543:	8b 55 08             	mov    0x8(%ebp),%edx
  804546:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804549:	85 c0                	test   %eax,%eax
  80454b:	74 14                	je     804561 <memp_free+0x24>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80454d:	a8 03                	test   $0x3,%al
  80454f:	75 12                	jne    804563 <memp_free+0x26>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804551:	8b 0c 95 c0 43 b3 00 	mov    0xb343c0(,%edx,4),%ecx
  804558:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  80455a:	89 04 95 c0 43 b3 00 	mov    %eax,0xb343c0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804561:	c9                   	leave  
  804562:	c3                   	ret    
  LWIP_ASSERT("memp_free: mem properly aligned",
  804563:	83 ec 04             	sub    $0x4,%esp
  804566:	68 4c 1d 81 00       	push   $0x811d4c
  80456b:	68 5b 01 00 00       	push   $0x15b
  804570:	68 12 1d 81 00       	push   $0x811d12
  804575:	e8 1f a1 00 00       	call   80e699 <_panic>

0080457a <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80457a:	55                   	push   %ebp
  80457b:	89 e5                	mov    %esp,%ebp
  80457d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804580:	85 c9                	test   %ecx,%ecx
  804582:	74 2c                	je     8045b0 <netif_remove+0x36>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804584:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804589:	39 c8                	cmp    %ecx,%eax
  80458b:	74 0e                	je     80459b <netif_remove+0x21>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80458d:	85 c0                	test   %eax,%eax
  80458f:	74 1f                	je     8045b0 <netif_remove+0x36>
      if (tmpNetif->next == netif) {
  804591:	8b 10                	mov    (%eax),%edx
  804593:	39 ca                	cmp    %ecx,%edx
  804595:	74 0d                	je     8045a4 <netif_remove+0x2a>
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804597:	89 d0                	mov    %edx,%eax
  804599:	eb f2                	jmp    80458d <netif_remove+0x13>
    netif_list = netif->next;
  80459b:	8b 01                	mov    (%ecx),%eax
  80459d:	a3 34 b2 b3 00       	mov    %eax,0xb3b234
  8045a2:	eb 04                	jmp    8045a8 <netif_remove+0x2e>
        tmpNetif->next = netif->next;
  8045a4:	8b 11                	mov    (%ecx),%edx
  8045a6:	89 10                	mov    %edx,(%eax)
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  8045a8:	39 0d 38 b2 b3 00    	cmp    %ecx,0xb3b238
  8045ae:	74 02                	je     8045b2 <netif_remove+0x38>
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  8045b0:	5d                   	pop    %ebp
  8045b1:	c3                   	ret    
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8045b2:	c7 05 38 b2 b3 00 00 	movl   $0x0,0xb3b238
  8045b9:	00 00 00 
  8045bc:	eb f2                	jmp    8045b0 <netif_remove+0x36>

008045be <netif_find>:
{
  8045be:	55                   	push   %ebp
  8045bf:	89 e5                	mov    %esp,%ebp
  8045c1:	53                   	push   %ebx
  8045c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if (name == NULL) {
  8045c5:	85 c9                	test   %ecx,%ecx
  8045c7:	74 2d                	je     8045f6 <netif_find+0x38>
  num = name[2] - '0';
  8045c9:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  8045cd:	8d 50 d0             	lea    -0x30(%eax),%edx
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8045d0:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  8045d5:	eb 02                	jmp    8045d9 <netif_find+0x1b>
  8045d7:	8b 00                	mov    (%eax),%eax
  8045d9:	85 c0                	test   %eax,%eax
  8045db:	74 16                	je     8045f3 <netif_find+0x35>
    if (num == netif->num &&
  8045dd:	38 50 31             	cmp    %dl,0x31(%eax)
  8045e0:	75 f5                	jne    8045d7 <netif_find+0x19>
  8045e2:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  8045e6:	38 19                	cmp    %bl,(%ecx)
  8045e8:	75 ed                	jne    8045d7 <netif_find+0x19>
       name[0] == netif->name[0] &&
  8045ea:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  8045ee:	38 59 01             	cmp    %bl,0x1(%ecx)
  8045f1:	75 e4                	jne    8045d7 <netif_find+0x19>
}
  8045f3:	5b                   	pop    %ebx
  8045f4:	5d                   	pop    %ebp
  8045f5:	c3                   	ret    
    return NULL;
  8045f6:	89 c8                	mov    %ecx,%eax
  8045f8:	eb f9                	jmp    8045f3 <netif_find+0x35>

008045fa <netif_set_ipaddr>:
{
  8045fa:	55                   	push   %ebp
  8045fb:	89 e5                	mov    %esp,%ebp
  8045fd:	57                   	push   %edi
  8045fe:	56                   	push   %esi
  8045ff:	53                   	push   %ebx
  804600:	83 ec 0c             	sub    $0xc,%esp
  804603:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804606:	8b 75 0c             	mov    0xc(%ebp),%esi
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804609:	8b 43 04             	mov    0x4(%ebx),%eax
  80460c:	39 06                	cmp    %eax,(%esi)
  80460e:	74 47                	je     804657 <netif_set_ipaddr+0x5d>
    pcb = tcp_active_pcbs;
  804610:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
    while (pcb != NULL) {
  804615:	eb 11                	jmp    804628 <netif_set_ipaddr+0x2e>
        struct tcp_pcb *next = pcb->next;
  804617:	8b 78 0c             	mov    0xc(%eax),%edi
        tcp_abort(pcb);
  80461a:	83 ec 0c             	sub    $0xc,%esp
  80461d:	50                   	push   %eax
  80461e:	e8 cd 15 00 00       	call   805bf0 <tcp_abort>
  804623:	83 c4 10             	add    $0x10,%esp
        pcb = next;
  804626:	89 f8                	mov    %edi,%eax
    while (pcb != NULL) {
  804628:	85 c0                	test   %eax,%eax
  80462a:	74 0c                	je     804638 <netif_set_ipaddr+0x3e>
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80462c:	8b 4b 04             	mov    0x4(%ebx),%ecx
  80462f:	39 08                	cmp    %ecx,(%eax)
  804631:	74 e4                	je     804617 <netif_set_ipaddr+0x1d>
        pcb = pcb->next;
  804633:	8b 40 0c             	mov    0xc(%eax),%eax
  804636:	eb f0                	jmp    804628 <netif_set_ipaddr+0x2e>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804638:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80463d:	eb 03                	jmp    804642 <netif_set_ipaddr+0x48>
  80463f:	8b 40 0c             	mov    0xc(%eax),%eax
  804642:	85 c0                	test   %eax,%eax
  804644:	74 11                	je     804657 <netif_set_ipaddr+0x5d>
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804646:	8b 10                	mov    (%eax),%edx
  804648:	85 d2                	test   %edx,%edx
  80464a:	74 f3                	je     80463f <netif_set_ipaddr+0x45>
  80464c:	3b 53 04             	cmp    0x4(%ebx),%edx
  80464f:	75 ee                	jne    80463f <netif_set_ipaddr+0x45>
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804651:	8b 16                	mov    (%esi),%edx
  804653:	89 10                	mov    %edx,(%eax)
  804655:	eb e8                	jmp    80463f <netif_set_ipaddr+0x45>
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804657:	8b 06                	mov    (%esi),%eax
  804659:	89 43 04             	mov    %eax,0x4(%ebx)
}
  80465c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80465f:	5b                   	pop    %ebx
  804660:	5e                   	pop    %esi
  804661:	5f                   	pop    %edi
  804662:	5d                   	pop    %ebp
  804663:	c3                   	ret    

00804664 <netif_set_addr>:
{
  804664:	55                   	push   %ebp
  804665:	89 e5                	mov    %esp,%ebp
  804667:	57                   	push   %edi
  804668:	56                   	push   %esi
  804669:	53                   	push   %ebx
  80466a:	83 ec 14             	sub    $0x14,%esp
  80466d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804670:	8b 7d 10             	mov    0x10(%ebp),%edi
  804673:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804676:	ff 75 0c             	pushl  0xc(%ebp)
  804679:	53                   	push   %ebx
  80467a:	e8 7b ff ff ff       	call   8045fa <netif_set_ipaddr>
  ip_addr_set(&(netif->netmask), netmask);
  80467f:	83 c4 10             	add    $0x10,%esp
  804682:	b8 00 00 00 00       	mov    $0x0,%eax
  804687:	85 ff                	test   %edi,%edi
  804689:	74 02                	je     80468d <netif_set_addr+0x29>
  80468b:	8b 07                	mov    (%edi),%eax
  80468d:	89 43 08             	mov    %eax,0x8(%ebx)
  ip_addr_set(&(netif->gw), gw);
  804690:	b8 00 00 00 00       	mov    $0x0,%eax
  804695:	85 f6                	test   %esi,%esi
  804697:	74 02                	je     80469b <netif_set_addr+0x37>
  804699:	8b 06                	mov    (%esi),%eax
  80469b:	89 43 0c             	mov    %eax,0xc(%ebx)
}
  80469e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8046a1:	5b                   	pop    %ebx
  8046a2:	5e                   	pop    %esi
  8046a3:	5f                   	pop    %edi
  8046a4:	5d                   	pop    %ebp
  8046a5:	c3                   	ret    

008046a6 <netif_add>:
{
  8046a6:	55                   	push   %ebp
  8046a7:	89 e5                	mov    %esp,%ebp
  8046a9:	53                   	push   %ebx
  8046aa:	83 ec 04             	sub    $0x4,%esp
  8046ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif->ip_addr.addr = 0;
  8046b0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  8046b7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  8046be:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  8046c5:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
  netif->dhcp = NULL;
  8046c9:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->state = state;
  8046d0:	8b 45 18             	mov    0x18(%ebp),%eax
  8046d3:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8046d6:	0f b6 05 f8 43 b3 00 	movzbl 0xb343f8,%eax
  8046dd:	8d 50 01             	lea    0x1(%eax),%edx
  8046e0:	88 15 f8 43 b3 00    	mov    %dl,0xb343f8
  8046e6:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  8046e9:	8b 45 20             	mov    0x20(%ebp),%eax
  8046ec:	89 43 10             	mov    %eax,0x10(%ebx)
  netif_set_addr(netif, ipaddr, netmask, gw);
  8046ef:	ff 75 14             	pushl  0x14(%ebp)
  8046f2:	ff 75 10             	pushl  0x10(%ebp)
  8046f5:	ff 75 0c             	pushl  0xc(%ebp)
  8046f8:	53                   	push   %ebx
  8046f9:	e8 66 ff ff ff       	call   804664 <netif_set_addr>
  if (init(netif) != ERR_OK) {
  8046fe:	89 1c 24             	mov    %ebx,(%esp)
  804701:	ff 55 1c             	call   *0x1c(%ebp)
  804704:	83 c4 10             	add    $0x10,%esp
  804707:	84 c0                	test   %al,%al
  804709:	75 14                	jne    80471f <netif_add+0x79>
  netif->next = netif_list;
  80470b:	a1 34 b2 b3 00       	mov    0xb3b234,%eax
  804710:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804712:	89 1d 34 b2 b3 00    	mov    %ebx,0xb3b234
  return netif;
  804718:	89 d8                	mov    %ebx,%eax
}
  80471a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80471d:	c9                   	leave  
  80471e:	c3                   	ret    
    return NULL;
  80471f:	b8 00 00 00 00       	mov    $0x0,%eax
  804724:	eb f4                	jmp    80471a <netif_add+0x74>

00804726 <netif_set_gw>:
{
  804726:	55                   	push   %ebp
  804727:	89 e5                	mov    %esp,%ebp
  804729:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  80472c:	b8 00 00 00 00       	mov    $0x0,%eax
  804731:	85 d2                	test   %edx,%edx
  804733:	74 02                	je     804737 <netif_set_gw+0x11>
  804735:	8b 02                	mov    (%edx),%eax
  804737:	8b 55 08             	mov    0x8(%ebp),%edx
  80473a:	89 42 0c             	mov    %eax,0xc(%edx)
}
  80473d:	5d                   	pop    %ebp
  80473e:	c3                   	ret    

0080473f <netif_set_netmask>:
{
  80473f:	55                   	push   %ebp
  804740:	89 e5                	mov    %esp,%ebp
  804742:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->netmask), netmask);
  804745:	b8 00 00 00 00       	mov    $0x0,%eax
  80474a:	85 d2                	test   %edx,%edx
  80474c:	74 02                	je     804750 <netif_set_netmask+0x11>
  80474e:	8b 02                	mov    (%edx),%eax
  804750:	8b 55 08             	mov    0x8(%ebp),%edx
  804753:	89 42 08             	mov    %eax,0x8(%edx)
}
  804756:	5d                   	pop    %ebp
  804757:	c3                   	ret    

00804758 <netif_set_default>:
{
  804758:	55                   	push   %ebp
  804759:	89 e5                	mov    %esp,%ebp
  netif_default = netif;
  80475b:	8b 45 08             	mov    0x8(%ebp),%eax
  80475e:	a3 38 b2 b3 00       	mov    %eax,0xb3b238
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804763:	5d                   	pop    %ebp
  804764:	c3                   	ret    

00804765 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804765:	55                   	push   %ebp
  804766:	89 e5                	mov    %esp,%ebp
  804768:	83 ec 08             	sub    $0x8,%esp
  80476b:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80476e:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804772:	a8 01                	test   $0x1,%al
  804774:	75 0c                	jne    804782 <netif_set_up+0x1d>
    netif->flags |= NETIF_FLAG_UP;
  804776:	89 c1                	mov    %eax,%ecx
  804778:	83 c9 01             	or     $0x1,%ecx
  80477b:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80477e:	a8 20                	test   $0x20,%al
  804780:	75 02                	jne    804784 <netif_set_up+0x1f>
      etharp_query(netif, &(netif->ip_addr), NULL);
    }
#endif /* LWIP_ARP */
    
  }
}
  804782:	c9                   	leave  
  804783:	c3                   	ret    
      etharp_query(netif, &(netif->ip_addr), NULL);
  804784:	83 ec 04             	sub    $0x4,%esp
  804787:	6a 00                	push   $0x0
  804789:	8d 42 04             	lea    0x4(%edx),%eax
  80478c:	50                   	push   %eax
  80478d:	52                   	push   %edx
  80478e:	e8 d8 51 00 00       	call   80996b <etharp_query>
  804793:	83 c4 10             	add    $0x10,%esp
}
  804796:	eb ea                	jmp    804782 <netif_set_up+0x1d>

00804798 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804798:	55                   	push   %ebp
  804799:	89 e5                	mov    %esp,%ebp
  80479b:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( netif->flags & NETIF_FLAG_UP )
  80479e:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  8047a2:	a8 01                	test   $0x1,%al
  8047a4:	74 06                	je     8047ac <netif_set_down+0x14>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  8047a6:	83 e0 fe             	and    $0xfffffffe,%eax
  8047a9:	88 42 2e             	mov    %al,0x2e(%edx)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  8047ac:	5d                   	pop    %ebp
  8047ad:	c3                   	ret    

008047ae <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  8047ae:	55                   	push   %ebp
  8047af:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  8047b1:	8b 45 08             	mov    0x8(%ebp),%eax
  8047b4:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  8047b8:	83 e0 01             	and    $0x1,%eax
}
  8047bb:	5d                   	pop    %ebp
  8047bc:	c3                   	ret    

008047bd <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  8047bd:	55                   	push   %ebp
  8047be:	89 e5                	mov    %esp,%ebp
  8047c0:	56                   	push   %esi
  8047c1:	53                   	push   %ebx
  8047c2:	8b 55 08             	mov    0x8(%ebp),%edx
  8047c5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  8047c8:	85 d2                	test   %edx,%edx
  8047ca:	74 42                	je     80480e <pbuf_header+0x51>
  if ((header_size_increment == 0) || (p == NULL))
  8047cc:	66 85 c9             	test   %cx,%cx
  8047cf:	0f 84 ae 00 00 00    	je     804883 <pbuf_header+0xc6>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  8047d5:	89 ce                	mov    %ecx,%esi
  if (header_size_increment < 0){
  8047d7:	78 4c                	js     804825 <pbuf_header+0x68>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  8047d9:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  8047dd:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  8047e0:	66 85 c0             	test   %ax,%ax
  8047e3:	74 5f                	je     804844 <pbuf_header+0x87>
  8047e5:	66 83 f8 03          	cmp    $0x3,%ax
  8047e9:	74 59                	je     804844 <pbuf_header+0x87>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8047eb:	83 e8 01             	sub    $0x1,%eax
  8047ee:	66 83 f8 01          	cmp    $0x1,%ax
  8047f2:	77 78                	ja     80486c <pbuf_header+0xaf>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8047f4:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8047f9:	66 85 c9             	test   %cx,%cx
  8047fc:	79 67                	jns    804865 <pbuf_header+0xa8>
  8047fe:	66 39 72 0a          	cmp    %si,0xa(%edx)
  804802:	72 61                	jb     804865 <pbuf_header+0xa8>
      p->payload = (u8_t *)p->payload - header_size_increment;
  804804:	0f bf c1             	movswl %cx,%eax
  804807:	29 c3                	sub    %eax,%ebx
  804809:	89 5a 04             	mov    %ebx,0x4(%edx)
  80480c:	eb 4a                	jmp    804858 <pbuf_header+0x9b>
  LWIP_ASSERT("p != NULL", p != NULL);
  80480e:	83 ec 04             	sub    $0x4,%esp
  804811:	68 68 1e 81 00       	push   $0x811e68
  804816:	68 64 01 00 00       	push   $0x164
  80481b:	68 a4 1d 81 00       	push   $0x811da4
  804820:	e8 74 9e 00 00       	call   80e699 <_panic>
    increment_magnitude = -header_size_increment;
  804825:	f7 de                	neg    %esi
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804827:	66 39 72 0a          	cmp    %si,0xa(%edx)
  80482b:	73 ac                	jae    8047d9 <pbuf_header+0x1c>
  80482d:	83 ec 04             	sub    $0x4,%esp
  804830:	68 b9 1d 81 00       	push   $0x811db9
  804835:	68 6b 01 00 00       	push   $0x16b
  80483a:	68 a4 1d 81 00       	push   $0x811da4
  80483f:	e8 55 9e 00 00       	call   80e699 <_panic>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804844:	0f bf c1             	movswl %cx,%eax
  804847:	29 c3                	sub    %eax,%ebx
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804849:	8d 72 10             	lea    0x10(%edx),%esi
      return 1;
  80484c:	b8 01 00 00 00       	mov    $0x1,%eax
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804851:	39 f3                	cmp    %esi,%ebx
  804853:	72 10                	jb     804865 <pbuf_header+0xa8>
    p->payload = (u8_t *)p->payload - header_size_increment;
  804855:	89 5a 04             	mov    %ebx,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804858:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  80485c:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804860:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804865:	8d 65 f8             	lea    -0x8(%ebp),%esp
  804868:	5b                   	pop    %ebx
  804869:	5e                   	pop    %esi
  80486a:	5d                   	pop    %ebp
  80486b:	c3                   	ret    
    LWIP_ASSERT("bad pbuf type", 0);
  80486c:	83 ec 04             	sub    $0x4,%esp
  80486f:	68 d7 1d 81 00       	push   $0x811dd7
  804874:	68 9a 01 00 00       	push   $0x19a
  804879:	68 a4 1d 81 00       	push   $0x811da4
  80487e:	e8 16 9e 00 00       	call   80e699 <_panic>
    return 0;
  804883:	b8 00 00 00 00       	mov    $0x0,%eax
  804888:	eb db                	jmp    804865 <pbuf_header+0xa8>

0080488a <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80488a:	55                   	push   %ebp
  80488b:	89 e5                	mov    %esp,%ebp
  80488d:	56                   	push   %esi
  80488e:	53                   	push   %ebx
  80488f:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804892:	85 c0                	test   %eax,%eax
  804894:	74 0d                	je     8048a3 <pbuf_free+0x19>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804896:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  80489a:	77 1e                	ja     8048ba <pbuf_free+0x30>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80489c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8048a1:	eb 6c                	jmp    80490f <pbuf_free+0x85>
    LWIP_ASSERT("p != NULL", p != NULL);
  8048a3:	83 ec 04             	sub    $0x4,%esp
  8048a6:	68 68 1e 81 00       	push   $0x811e68
  8048ab:	68 d0 01 00 00       	push   $0x1d0
  8048b0:	68 a4 1d 81 00       	push   $0x811da4
  8048b5:	e8 df 9d 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("pbuf_free: sane type",
  8048ba:	83 ec 04             	sub    $0x4,%esp
  8048bd:	68 e5 1d 81 00       	push   $0x811de5
  8048c2:	68 db 01 00 00       	push   $0x1db
  8048c7:	68 a4 1d 81 00       	push   $0x811da4
  8048cc:	e8 c8 9d 00 00       	call   80e699 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8048d1:	83 ec 04             	sub    $0x4,%esp
  8048d4:	68 fa 1d 81 00       	push   $0x811dfa
  8048d9:	68 e8 01 00 00       	push   $0x1e8
  8048de:	68 a4 1d 81 00       	push   $0x811da4
  8048e3:	e8 b1 9d 00 00       	call   80e699 <_panic>
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
        memp_free(MEMP_PBUF_POOL, p);
  8048e8:	83 ec 08             	sub    $0x8,%esp
  8048eb:	50                   	push   %eax
  8048ec:	6a 0d                	push   $0xd
  8048ee:	e8 4a fc ff ff       	call   80453d <memp_free>
  8048f3:	83 c4 10             	add    $0x10,%esp
  8048f6:	eb 0e                	jmp    804906 <pbuf_free+0x7c>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
        memp_free(MEMP_PBUF, p);
  8048f8:	83 ec 08             	sub    $0x8,%esp
  8048fb:	50                   	push   %eax
  8048fc:	6a 0c                	push   $0xc
  8048fe:	e8 3a fc ff ff       	call   80453d <memp_free>
  804903:	83 c4 10             	add    $0x10,%esp
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
      }
      count++;
  804906:	83 c3 01             	add    $0x1,%ebx
      /* proceed to next pbuf */
      p = q;
  804909:	89 f0                	mov    %esi,%eax
  while (p != NULL) {
  80490b:	85 f6                	test   %esi,%esi
  80490d:	74 38                	je     804947 <pbuf_free+0xbd>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80490f:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  804913:	66 85 d2             	test   %dx,%dx
  804916:	74 b9                	je     8048d1 <pbuf_free+0x47>
    ref = --(p->ref);
  804918:	83 ea 01             	sub    $0x1,%edx
  80491b:	66 89 50 0e          	mov    %dx,0xe(%eax)
    if (ref == 0) {
  80491f:	66 85 d2             	test   %dx,%dx
  804922:	75 23                	jne    804947 <pbuf_free+0xbd>
      q = p->next;
  804924:	8b 30                	mov    (%eax),%esi
      type = p->type;
  804926:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      if (type == PBUF_POOL) {
  80492a:	66 83 fa 03          	cmp    $0x3,%dx
  80492e:	74 b8                	je     8048e8 <pbuf_free+0x5e>
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804930:	83 ea 01             	sub    $0x1,%edx
  804933:	66 83 fa 01          	cmp    $0x1,%dx
  804937:	76 bf                	jbe    8048f8 <pbuf_free+0x6e>
        mem_free(p);
  804939:	83 ec 0c             	sub    $0xc,%esp
  80493c:	50                   	push   %eax
  80493d:	e8 62 f6 ff ff       	call   803fa4 <mem_free>
  804942:	83 c4 10             	add    $0x10,%esp
  804945:	eb bf                	jmp    804906 <pbuf_free+0x7c>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804947:	89 d8                	mov    %ebx,%eax
  804949:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80494c:	5b                   	pop    %ebx
  80494d:	5e                   	pop    %esi
  80494e:	5d                   	pop    %ebp
  80494f:	c3                   	ret    

00804950 <pbuf_alloc>:
{
  804950:	55                   	push   %ebp
  804951:	89 e5                	mov    %esp,%ebp
  804953:	57                   	push   %edi
  804954:	56                   	push   %esi
  804955:	53                   	push   %ebx
  804956:	83 ec 1c             	sub    $0x1c,%esp
  804959:	8b 45 08             	mov    0x8(%ebp),%eax
  80495c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80495f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  switch (layer) {
  804962:	83 f8 01             	cmp    $0x1,%eax
  804965:	0f 84 8a 00 00 00    	je     8049f5 <pbuf_alloc+0xa5>
  80496b:	85 c0                	test   %eax,%eax
  80496d:	0f 84 89 00 00 00    	je     8049fc <pbuf_alloc+0xac>
  804973:	83 f8 02             	cmp    $0x2,%eax
  804976:	0f 84 94 00 00 00    	je     804a10 <pbuf_alloc+0xc0>
  80497c:	83 f8 03             	cmp    $0x3,%eax
  80497f:	0f 85 92 00 00 00    	jne    804a17 <pbuf_alloc+0xc7>
  offset = 0;
  804985:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  switch (type) {
  80498b:	83 fb 02             	cmp    $0x2,%ebx
  80498e:	0f 87 9a 00 00 00    	ja     804a2e <pbuf_alloc+0xde>
  804994:	85 db                	test   %ebx,%ebx
  804996:	0f 85 db 01 00 00    	jne    804b77 <pbuf_alloc+0x227>
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80499c:	0f b7 5d e4          	movzwl -0x1c(%ebp),%ebx
  8049a0:	83 ec 0c             	sub    $0xc,%esp
  8049a3:	8d 43 13             	lea    0x13(%ebx),%eax
  8049a6:	83 e0 fc             	and    $0xfffffffc,%eax
  8049a9:	89 c2                	mov    %eax,%edx
  8049ab:	0f b7 c6             	movzwl %si,%eax
  8049ae:	83 c0 03             	add    $0x3,%eax
  8049b1:	83 e0 fc             	and    $0xfffffffc,%eax
  8049b4:	01 d0                	add    %edx,%eax
  8049b6:	50                   	push   %eax
  8049b7:	e8 d7 f8 ff ff       	call   804293 <mem_malloc>
  8049bc:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  8049be:	83 c4 10             	add    $0x10,%esp
  8049c1:	85 c0                	test   %eax,%eax
  8049c3:	74 26                	je     8049eb <pbuf_alloc+0x9b>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  8049c5:	8d 44 18 13          	lea    0x13(%eax,%ebx,1),%eax
  8049c9:	83 e0 fc             	and    $0xfffffffc,%eax
  8049cc:	89 47 04             	mov    %eax,0x4(%edi)
    p->len = p->tot_len = length;
  8049cf:	66 89 77 08          	mov    %si,0x8(%edi)
  8049d3:	66 89 77 0a          	mov    %si,0xa(%edi)
    p->next = NULL;
  8049d7:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
    p->type = type;
  8049dd:	c6 47 0c 00          	movb   $0x0,0xc(%edi)
  p->ref = 1;
  8049e1:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
  p->flags = 0;
  8049e7:	c6 47 0d 00          	movb   $0x0,0xd(%edi)
}
  8049eb:	89 f8                	mov    %edi,%eax
  8049ed:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8049f0:	5b                   	pop    %ebx
  8049f1:	5e                   	pop    %esi
  8049f2:	5f                   	pop    %edi
  8049f3:	5d                   	pop    %ebp
  8049f4:	c3                   	ret    
  offset = 0;
  8049f5:	bf 00 00 00 00       	mov    $0x0,%edi
  8049fa:	eb 05                	jmp    804a01 <pbuf_alloc+0xb1>
    offset += PBUF_TRANSPORT_HLEN;
  8049fc:	bf 14 00 00 00       	mov    $0x14,%edi
    offset += PBUF_IP_HLEN;
  804a01:	83 c7 14             	add    $0x14,%edi
    offset += PBUF_LINK_HLEN;
  804a04:	8d 47 0e             	lea    0xe(%edi),%eax
  804a07:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  804a0b:	e9 7b ff ff ff       	jmp    80498b <pbuf_alloc+0x3b>
  offset = 0;
  804a10:	bf 00 00 00 00       	mov    $0x0,%edi
  804a15:	eb ed                	jmp    804a04 <pbuf_alloc+0xb4>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804a17:	83 ec 04             	sub    $0x4,%esp
  804a1a:	68 10 1e 81 00       	push   $0x811e10
  804a1f:	68 8a 00 00 00       	push   $0x8a
  804a24:	68 a4 1d 81 00       	push   $0x811da4
  804a29:	e8 6b 9c 00 00       	call   80e699 <_panic>
  switch (type) {
  804a2e:	83 fb 03             	cmp    $0x3,%ebx
  804a31:	0f 85 74 01 00 00    	jne    804bab <pbuf_alloc+0x25b>
      p = memp_malloc(MEMP_PBUF_POOL);
  804a37:	83 ec 0c             	sub    $0xc,%esp
  804a3a:	6a 0d                	push   $0xd
  804a3c:	e8 a6 fa ff ff       	call   8044e7 <memp_malloc>
  804a41:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804a43:	83 c4 10             	add    $0x10,%esp
  804a46:	85 c0                	test   %eax,%eax
  804a48:	74 a1                	je     8049eb <pbuf_alloc+0x9b>
    p->type = type;
  804a4a:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804a4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804a54:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804a58:	8d 54 07 13          	lea    0x13(%edi,%eax,1),%edx
  804a5c:	83 e2 fc             	and    $0xfffffffc,%edx
  804a5f:	89 57 04             	mov    %edx,0x4(%edi)
    p->tot_len = length;
  804a62:	66 89 77 08          	mov    %si,0x8(%edi)
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804a66:	0f b7 f6             	movzwl %si,%esi
  804a69:	83 c0 03             	add    $0x3,%eax
  804a6c:	83 e0 fc             	and    $0xfffffffc,%eax
  804a6f:	89 c1                	mov    %eax,%ecx
  804a71:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804a76:	29 c8                	sub    %ecx,%eax
  804a78:	39 f0                	cmp    %esi,%eax
  804a7a:	0f 4f c6             	cmovg  %esi,%eax
  804a7d:	66 89 47 0a          	mov    %ax,0xa(%edi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804a81:	8d 9f e0 07 00 00    	lea    0x7e0(%edi),%ebx
  804a87:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  804a8a:	01 c2                	add    %eax,%edx
  804a8c:	39 d3                	cmp    %edx,%ebx
  804a8e:	72 76                	jb     804b06 <pbuf_alloc+0x1b6>
    p->ref = 1;
  804a90:	66 c7 47 0e 01 00    	movw   $0x1,0xe(%edi)
    rem_len = length - p->len;
  804a96:	29 c6                	sub    %eax,%esi
    r = p;
  804a98:	89 fb                	mov    %edi,%ebx
    while (rem_len > 0) {
  804a9a:	85 f6                	test   %esi,%esi
  804a9c:	0f 8e 3f ff ff ff    	jle    8049e1 <pbuf_alloc+0x91>
      q = memp_malloc(MEMP_PBUF_POOL);
  804aa2:	83 ec 0c             	sub    $0xc,%esp
  804aa5:	6a 0d                	push   $0xd
  804aa7:	e8 3b fa ff ff       	call   8044e7 <memp_malloc>
      if (q == NULL) {
  804aac:	83 c4 10             	add    $0x10,%esp
  804aaf:	85 c0                	test   %eax,%eax
  804ab1:	74 6a                	je     804b1d <pbuf_alloc+0x1cd>
      q->type = type;
  804ab3:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  804ab7:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  804abb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      r->next = q;
  804ac1:	89 03                	mov    %eax,(%ebx)
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804ac3:	81 fe fe ff 00 00    	cmp    $0xfffe,%esi
  804ac9:	7f 67                	jg     804b32 <pbuf_alloc+0x1e2>
      q->tot_len = (u16_t)rem_len;
  804acb:	66 89 70 08          	mov    %si,0x8(%eax)
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  804acf:	66 81 fe d0 07       	cmp    $0x7d0,%si
  804ad4:	ba d0 07 00 00       	mov    $0x7d0,%edx
  804ad9:	0f 46 d6             	cmovbe %esi,%edx
  804adc:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  804ae0:	8d 48 10             	lea    0x10(%eax),%ecx
  804ae3:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804ae6:	f6 c1 03             	test   $0x3,%cl
  804ae9:	75 5e                	jne    804b49 <pbuf_alloc+0x1f9>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804aeb:	0f b7 4f 0a          	movzwl 0xa(%edi),%ecx
  804aef:	03 4f 04             	add    0x4(%edi),%ecx
  804af2:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  804af5:	72 69                	jb     804b60 <pbuf_alloc+0x210>
      q->ref = 1;
  804af7:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      rem_len -= q->len;
  804afd:	0f b7 d2             	movzwl %dx,%edx
  804b00:	29 d6                	sub    %edx,%esi
      r = q;
  804b02:	89 c3                	mov    %eax,%ebx
  804b04:	eb 94                	jmp    804a9a <pbuf_alloc+0x14a>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b06:	83 ec 04             	sub    $0x4,%esp
  804b09:	68 28 1f 81 00       	push   $0x811f28
  804b0e:	68 a3 00 00 00       	push   $0xa3
  804b13:	68 a4 1d 81 00       	push   $0x811da4
  804b18:	e8 7c 9b 00 00       	call   80e699 <_panic>
  804b1d:	89 c3                	mov    %eax,%ebx
        pbuf_free(p);
  804b1f:	83 ec 0c             	sub    $0xc,%esp
  804b22:	57                   	push   %edi
  804b23:	e8 62 fd ff ff       	call   80488a <pbuf_free>
        return NULL;
  804b28:	83 c4 10             	add    $0x10,%esp
  804b2b:	89 df                	mov    %ebx,%edi
  804b2d:	e9 b9 fe ff ff       	jmp    8049eb <pbuf_alloc+0x9b>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  804b32:	83 ec 04             	sub    $0x4,%esp
  804b35:	68 2b 1e 81 00       	push   $0x811e2b
  804b3a:	68 bc 00 00 00       	push   $0xbc
  804b3f:	68 a4 1d 81 00       	push   $0x811da4
  804b44:	e8 50 9b 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  804b49:	83 ec 04             	sub    $0x4,%esp
  804b4c:	68 5c 1f 81 00       	push   $0x811f5c
  804b51:	68 c2 00 00 00       	push   $0xc2
  804b56:	68 a4 1d 81 00       	push   $0x811da4
  804b5b:	e8 39 9b 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804b60:	83 ec 04             	sub    $0x4,%esp
  804b63:	68 28 1f 81 00       	push   $0x811f28
  804b68:	68 c5 00 00 00       	push   $0xc5
  804b6d:	68 a4 1d 81 00       	push   $0x811da4
  804b72:	e8 22 9b 00 00       	call   80e699 <_panic>
    p = memp_malloc(MEMP_PBUF);
  804b77:	83 ec 0c             	sub    $0xc,%esp
  804b7a:	6a 0c                	push   $0xc
  804b7c:	e8 66 f9 ff ff       	call   8044e7 <memp_malloc>
  804b81:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  804b83:	83 c4 10             	add    $0x10,%esp
  804b86:	85 c0                	test   %eax,%eax
  804b88:	0f 84 5d fe ff ff    	je     8049eb <pbuf_alloc+0x9b>
    p->payload = NULL;
  804b8e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  804b95:	66 89 70 08          	mov    %si,0x8(%eax)
  804b99:	66 89 70 0a          	mov    %si,0xa(%eax)
    p->next = NULL;
  804b9d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  804ba3:	88 58 0c             	mov    %bl,0xc(%eax)
    break;
  804ba6:	e9 36 fe ff ff       	jmp    8049e1 <pbuf_alloc+0x91>
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  804bab:	83 ec 04             	sub    $0x4,%esp
  804bae:	68 3f 1e 81 00       	push   $0x811e3f
  804bb3:	68 f1 00 00 00       	push   $0xf1
  804bb8:	68 a4 1d 81 00       	push   $0x811da4
  804bbd:	e8 d7 9a 00 00       	call   80e699 <_panic>

00804bc2 <pbuf_realloc>:
{
  804bc2:	55                   	push   %ebp
  804bc3:	89 e5                	mov    %esp,%ebp
  804bc5:	57                   	push   %edi
  804bc6:	56                   	push   %esi
  804bc7:	53                   	push   %ebx
  804bc8:	83 ec 0c             	sub    $0xc,%esp
  804bcb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804bce:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804bd1:	85 db                	test   %ebx,%ebx
  804bd3:	74 53                	je     804c28 <pbuf_realloc+0x66>
  804bd5:	89 f2                	mov    %esi,%edx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804bd7:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  804bdb:	77 62                	ja     804c3f <pbuf_realloc+0x7d>
  if (new_len >= p->tot_len) {
  804bdd:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804be1:	66 39 f0             	cmp    %si,%ax
  804be4:	0f 86 ae 00 00 00    	jbe    804c98 <pbuf_realloc+0xd6>
  grow = new_len - p->tot_len;
  804bea:	0f b7 ce             	movzwl %si,%ecx
  804bed:	0f b7 f8             	movzwl %ax,%edi
  804bf0:	29 f9                	sub    %edi,%ecx
    q->tot_len += (u16_t)grow;
  804bf2:	29 c2                	sub    %eax,%edx
  while (rem_len > q->len) {
  804bf4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804bf8:	66 39 f0             	cmp    %si,%ax
  804bfb:	73 70                	jae    804c6d <pbuf_realloc+0xab>
    rem_len -= q->len;
  804bfd:	29 c6                	sub    %eax,%esi
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804bff:	81 f9 fe ff 00 00    	cmp    $0xfffe,%ecx
  804c05:	7f 4f                	jg     804c56 <pbuf_realloc+0x94>
    q->tot_len += (u16_t)grow;
  804c07:	66 01 53 08          	add    %dx,0x8(%ebx)
    q = q->next;
  804c0b:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  804c0d:	85 db                	test   %ebx,%ebx
  804c0f:	75 e3                	jne    804bf4 <pbuf_realloc+0x32>
  804c11:	83 ec 04             	sub    $0x4,%esp
  804c14:	68 9e 1e 81 00       	push   $0x811e9e
  804c19:	68 2f 01 00 00       	push   $0x12f
  804c1e:	68 a4 1d 81 00       	push   $0x811da4
  804c23:	e8 71 9a 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  804c28:	83 ec 04             	sub    $0x4,%esp
  804c2b:	68 5a 1e 81 00       	push   $0x811e5a
  804c30:	68 13 01 00 00       	push   $0x113
  804c35:	68 a4 1d 81 00       	push   $0x811da4
  804c3a:	e8 5a 9a 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  804c3f:	83 ec 04             	sub    $0x4,%esp
  804c42:	68 72 1e 81 00       	push   $0x811e72
  804c47:	68 17 01 00 00       	push   $0x117
  804c4c:	68 a4 1d 81 00       	push   $0x811da4
  804c51:	e8 43 9a 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  804c56:	83 ec 04             	sub    $0x4,%esp
  804c59:	68 8d 1e 81 00       	push   $0x811e8d
  804c5e:	68 2b 01 00 00       	push   $0x12b
  804c63:	68 a4 1d 81 00       	push   $0x811da4
  804c68:	e8 2c 9a 00 00       	call   80e699 <_panic>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  804c6d:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  804c71:	75 05                	jne    804c78 <pbuf_realloc+0xb6>
  804c73:	66 39 f0             	cmp    %si,%ax
  804c76:	75 28                	jne    804ca0 <pbuf_realloc+0xde>
  q->len = rem_len;
  804c78:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  804c7c:	66 89 73 08          	mov    %si,0x8(%ebx)
  if (q->next != NULL) {
  804c80:	8b 03                	mov    (%ebx),%eax
  804c82:	85 c0                	test   %eax,%eax
  804c84:	74 0c                	je     804c92 <pbuf_realloc+0xd0>
    pbuf_free(q->next);
  804c86:	83 ec 0c             	sub    $0xc,%esp
  804c89:	50                   	push   %eax
  804c8a:	e8 fb fb ff ff       	call   80488a <pbuf_free>
  804c8f:	83 c4 10             	add    $0x10,%esp
  q->next = NULL;
  804c92:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  804c98:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804c9b:	5b                   	pop    %ebx
  804c9c:	5e                   	pop    %esi
  804c9d:	5f                   	pop    %edi
  804c9e:	5d                   	pop    %ebp
  804c9f:	c3                   	ret    
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  804ca0:	8b 43 04             	mov    0x4(%ebx),%eax
  804ca3:	29 d8                	sub    %ebx,%eax
  804ca5:	0f b7 d6             	movzwl %si,%edx
  804ca8:	01 d0                	add    %edx,%eax
  804caa:	83 ec 08             	sub    $0x8,%esp
  804cad:	50                   	push   %eax
  804cae:	53                   	push   %ebx
  804caf:	e8 87 f4 ff ff       	call   80413b <mem_realloc>
  804cb4:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  804cb6:	83 c4 10             	add    $0x10,%esp
  804cb9:	85 c0                	test   %eax,%eax
  804cbb:	75 bb                	jne    804c78 <pbuf_realloc+0xb6>
  804cbd:	83 ec 04             	sub    $0x4,%esp
  804cc0:	68 b6 1e 81 00       	push   $0x811eb6
  804cc5:	68 39 01 00 00       	push   $0x139
  804cca:	68 a4 1d 81 00       	push   $0x811da4
  804ccf:	e8 c5 99 00 00       	call   80e699 <_panic>

00804cd4 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  804cd4:	55                   	push   %ebp
  804cd5:	89 e5                	mov    %esp,%ebp
  804cd7:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  804cda:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  804cdf:	85 d2                	test   %edx,%edx
  804ce1:	74 07                	je     804cea <pbuf_clen+0x16>
    ++len;
  804ce3:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  804ce6:	8b 12                	mov    (%edx),%edx
  804ce8:	eb f5                	jmp    804cdf <pbuf_clen+0xb>
  }
  return len;
}
  804cea:	5d                   	pop    %ebp
  804ceb:	c3                   	ret    

00804cec <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  804cec:	55                   	push   %ebp
  804ced:	89 e5                	mov    %esp,%ebp
  804cef:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  804cf2:	85 c0                	test   %eax,%eax
  804cf4:	74 05                	je     804cfb <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  804cf6:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  804cfb:	5d                   	pop    %ebp
  804cfc:	c3                   	ret    

00804cfd <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  804cfd:	55                   	push   %ebp
  804cfe:	89 e5                	mov    %esp,%ebp
  804d00:	53                   	push   %ebx
  804d01:	83 ec 04             	sub    $0x4,%esp
  804d04:	8b 45 08             	mov    0x8(%ebp),%eax
  804d07:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804d0a:	85 c0                	test   %eax,%eax
  804d0c:	74 16                	je     804d24 <pbuf_cat+0x27>
  804d0e:	85 db                	test   %ebx,%ebx
  804d10:	74 12                	je     804d24 <pbuf_cat+0x27>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  804d12:	8b 10                	mov    (%eax),%edx
  804d14:	85 d2                	test   %edx,%edx
  804d16:	74 23                	je     804d3b <pbuf_cat+0x3e>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  804d18:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  804d1c:	66 01 48 08          	add    %cx,0x8(%eax)
  for (p = h; p->next != NULL; p = p->next) {
  804d20:	89 d0                	mov    %edx,%eax
  804d22:	eb ee                	jmp    804d12 <pbuf_cat+0x15>
  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  804d24:	83 ec 04             	sub    $0x4,%esp
  804d27:	68 8c 1f 81 00       	push   $0x811f8c
  804d2c:	68 42 02 00 00       	push   $0x242
  804d31:	68 a4 1d 81 00       	push   $0x811da4
  804d36:	e8 5e 99 00 00       	call   80e699 <_panic>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804d3b:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  804d3f:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  804d43:	75 0f                	jne    804d54 <pbuf_cat+0x57>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  804d45:	66 03 53 08          	add    0x8(%ebx),%dx
  804d49:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  804d4d:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  804d4f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d52:	c9                   	leave  
  804d53:	c3                   	ret    
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  804d54:	83 ec 04             	sub    $0x4,%esp
  804d57:	68 c4 1f 81 00       	push   $0x811fc4
  804d5c:	68 4a 02 00 00       	push   $0x24a
  804d61:	68 a4 1d 81 00       	push   $0x811da4
  804d66:	e8 2e 99 00 00       	call   80e699 <_panic>

00804d6b <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  804d6b:	55                   	push   %ebp
  804d6c:	89 e5                	mov    %esp,%ebp
  804d6e:	53                   	push   %ebx
  804d6f:	83 ec 0c             	sub    $0xc,%esp
  804d72:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  804d75:	53                   	push   %ebx
  804d76:	ff 75 08             	pushl  0x8(%ebp)
  804d79:	e8 7f ff ff ff       	call   804cfd <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  804d7e:	89 1c 24             	mov    %ebx,(%esp)
  804d81:	e8 66 ff ff ff       	call   804cec <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  804d86:	83 c4 10             	add    $0x10,%esp
  804d89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  804d8c:	c9                   	leave  
  804d8d:	c3                   	ret    

00804d8e <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  804d8e:	55                   	push   %ebp
  804d8f:	89 e5                	mov    %esp,%ebp
  804d91:	57                   	push   %edi
  804d92:	56                   	push   %esi
  804d93:	53                   	push   %ebx
  804d94:	83 ec 1c             	sub    $0x1c,%esp
  804d97:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  804d9a:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  804d9c:	85 f6                	test   %esi,%esi
  804d9e:	74 71                	je     804e11 <pbuf_dechain+0x83>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804da0:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804da4:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804da8:	0f b7 7e 08          	movzwl 0x8(%esi),%edi
  804dac:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804daf:	0f b7 d0             	movzwl %ax,%edx
  804db2:	0f b7 f9             	movzwl %cx,%edi
  804db5:	29 fa                	sub    %edi,%edx
  804db7:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  804dba:	75 3e                	jne    804dfa <pbuf_dechain+0x6c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  804dbc:	29 c8                	sub    %ecx,%eax
  804dbe:	66 89 46 08          	mov    %ax,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  804dc2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  804dc8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804dcc:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  804dd0:	83 ec 0c             	sub    $0xc,%esp
  804dd3:	56                   	push   %esi
  804dd4:	e8 b1 fa ff ff       	call   80488a <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804dd9:	83 c4 10             	add    $0x10,%esp
  804ddc:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  804de0:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  804de4:	75 35                	jne    804e1b <pbuf_dechain+0x8d>
  return ((tail_gone > 0) ? NULL : q);
  804de6:	84 c0                	test   %al,%al
  804de8:	b8 00 00 00 00       	mov    $0x0,%eax
  804ded:	0f 45 f0             	cmovne %eax,%esi
}
  804df0:	89 f0                	mov    %esi,%eax
  804df2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  804df5:	5b                   	pop    %ebx
  804df6:	5e                   	pop    %esi
  804df7:	5f                   	pop    %edi
  804df8:	5d                   	pop    %ebp
  804df9:	c3                   	ret    
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  804dfa:	83 ec 04             	sub    $0x4,%esp
  804dfd:	68 f4 1f 81 00       	push   $0x811ff4
  804e02:	68 80 02 00 00       	push   $0x280
  804e07:	68 a4 1d 81 00       	push   $0x811da4
  804e0c:	e8 88 98 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  804e11:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804e15:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  804e19:	74 d5                	je     804df0 <pbuf_dechain+0x62>
  804e1b:	83 ec 04             	sub    $0x4,%esp
  804e1e:	68 d1 1e 81 00       	push   $0x811ed1
  804e23:	68 91 02 00 00       	push   $0x291
  804e28:	68 a4 1d 81 00       	push   $0x811da4
  804e2d:	e8 67 98 00 00       	call   80e699 <_panic>

00804e32 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  804e32:	55                   	push   %ebp
  804e33:	89 e5                	mov    %esp,%ebp
  804e35:	57                   	push   %edi
  804e36:	56                   	push   %esi
  804e37:	53                   	push   %ebx
  804e38:	83 ec 1c             	sub    $0x1c,%esp
  804e3b:	8b 7d 08             	mov    0x8(%ebp),%edi
  804e3e:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804e41:	85 ff                	test   %edi,%edi
  804e43:	74 22                	je     804e67 <pbuf_copy+0x35>
  804e45:	85 db                	test   %ebx,%ebx
  804e47:	74 1e                	je     804e67 <pbuf_copy+0x35>
  804e49:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804e4d:	66 39 47 08          	cmp    %ax,0x8(%edi)
  804e51:	72 14                	jb     804e67 <pbuf_copy+0x35>
  u16_t offset_to=0, offset_from=0, len;
  804e53:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804e59:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804e5f:	89 7d 08             	mov    %edi,0x8(%ebp)
  804e62:	e9 92 00 00 00       	jmp    804ef9 <pbuf_copy+0xc7>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  804e67:	83 ec 04             	sub    $0x4,%esp
  804e6a:	68 18 20 81 00       	push   $0x812018
  804e6f:	68 b1 02 00 00       	push   $0x2b1
  804e74:	68 a4 1d 81 00       	push   $0x811da4
  804e79:	e8 1b 98 00 00       	call   80e699 <_panic>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804e7e:	83 ec 04             	sub    $0x4,%esp
  804e81:	68 e6 1e 81 00       	push   $0x811ee6
  804e86:	68 c2 02 00 00       	push   $0x2c2
  804e8b:	68 a4 1d 81 00       	push   $0x811da4
  804e90:	e8 04 98 00 00       	call   80e699 <_panic>
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  804e95:	8b 45 08             	mov    0x8(%ebp),%eax
  804e98:	8b 00                	mov    (%eax),%eax
  804e9a:	89 45 08             	mov    %eax,0x8(%ebp)
      offset_to = 0;
  804e9d:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  804ea3:	e9 c7 00 00 00       	jmp    804f6f <pbuf_copy+0x13d>
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804ea8:	83 ec 04             	sub    $0x4,%esp
  804eab:	68 fd 1e 81 00       	push   $0x811efd
  804eb0:	68 c8 02 00 00       	push   $0x2c8
  804eb5:	68 a4 1d 81 00       	push   $0x811da4
  804eba:	e8 da 97 00 00       	call   80e699 <_panic>
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  804ebf:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804ec5:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  804ec9:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  804ecd:	0f 84 cf 00 00 00    	je     804fa2 <pbuf_copy+0x170>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804ed3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804ed7:	0f 84 05 01 00 00    	je     804fe2 <pbuf_copy+0x1b0>
  804edd:	8b 45 08             	mov    0x8(%ebp),%eax
  804ee0:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804ee4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804ee7:	66 39 41 0a          	cmp    %ax,0xa(%ecx)
  804eeb:	0f 84 d1 00 00 00    	je     804fc2 <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  804ef1:	85 db                	test   %ebx,%ebx
  804ef3:	0f 84 00 01 00 00    	je     804ff9 <pbuf_copy+0x1c7>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  804ef9:	8b 45 08             	mov    0x8(%ebp),%eax
  804efc:	0f b7 70 0a          	movzwl 0xa(%eax),%esi
  804f00:	0f b7 ce             	movzwl %si,%ecx
  804f03:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  804f07:	29 c1                	sub    %eax,%ecx
  804f09:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  804f0d:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f11:	29 c2                	sub    %eax,%edx
      len = p_from->len - offset_from;
  804f13:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  804f17:	66 2b 7d e6          	sub    -0x1a(%ebp),%di
  804f1b:	89 f8                	mov    %edi,%eax
  804f1d:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  804f21:	29 fe                	sub    %edi,%esi
  804f23:	39 d1                	cmp    %edx,%ecx
  804f25:	0f 4d f0             	cmovge %eax,%esi
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  804f28:	83 ec 04             	sub    $0x4,%esp
  804f2b:	0f b7 c6             	movzwl %si,%eax
  804f2e:	50                   	push   %eax
  804f2f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804f33:	03 43 04             	add    0x4(%ebx),%eax
  804f36:	50                   	push   %eax
  804f37:	0f b7 c7             	movzwl %di,%eax
  804f3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  804f3d:	03 41 04             	add    0x4(%ecx),%eax
  804f40:	50                   	push   %eax
  804f41:	e8 98 a1 00 00       	call   80f0de <memcpy>
    offset_to += len;
  804f46:	89 fa                	mov    %edi,%edx
  804f48:	01 f2                	add    %esi,%edx
  804f4a:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    offset_from += len;
  804f4e:	66 01 75 e6          	add    %si,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  804f52:	8b 45 08             	mov    0x8(%ebp),%eax
  804f55:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804f59:	83 c4 10             	add    $0x10,%esp
  804f5c:	66 39 d0             	cmp    %dx,%ax
  804f5f:	0f 82 19 ff ff ff    	jb     804e7e <pbuf_copy+0x4c>
    if (offset_to == p_to->len) {
  804f65:	66 3b 45 e4          	cmp    -0x1c(%ebp),%ax
  804f69:	0f 84 26 ff ff ff    	je     804e95 <pbuf_copy+0x63>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  804f6f:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  804f73:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f77:	0f 82 2b ff ff ff    	jb     804ea8 <pbuf_copy+0x76>
    if (offset_from >= p_from->len) {
  804f7d:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
  804f81:	0f 85 3e ff ff ff    	jne    804ec5 <pbuf_copy+0x93>
      p_from = p_from->next;
  804f87:	8b 1b                	mov    (%ebx),%ebx
    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  804f89:	85 db                	test   %ebx,%ebx
  804f8b:	0f 85 2e ff ff ff    	jne    804ebf <pbuf_copy+0x8d>
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  804f91:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  804f95:	74 62                	je     804ff9 <pbuf_copy+0x1c7>
      offset_from = 0;
  804f97:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  804f9d:	e9 3b ff ff ff       	jmp    804edd <pbuf_copy+0xab>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804fa2:	83 3b 00             	cmpl   $0x0,(%ebx)
  804fa5:	0f 84 28 ff ff ff    	je     804ed3 <pbuf_copy+0xa1>
  804fab:	83 ec 04             	sub    $0x4,%esp
  804fae:	68 48 20 81 00       	push   $0x812048
  804fb3:	68 d2 02 00 00       	push   $0x2d2
  804fb8:	68 a4 1d 81 00       	push   $0x811da4
  804fbd:	e8 d7 96 00 00       	call   80e699 <_panic>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  804fc2:	83 39 00             	cmpl   $0x0,(%ecx)
  804fc5:	0f 84 26 ff ff ff    	je     804ef1 <pbuf_copy+0xbf>
  804fcb:	83 ec 04             	sub    $0x4,%esp
  804fce:	68 48 20 81 00       	push   $0x812048
  804fd3:	68 d7 02 00 00       	push   $0x2d7
  804fd8:	68 a4 1d 81 00       	push   $0x811da4
  804fdd:	e8 b7 96 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  804fe2:	83 ec 04             	sub    $0x4,%esp
  804fe5:	68 18 1f 81 00       	push   $0x811f18
  804fea:	68 b6 02 00 00       	push   $0x2b6
  804fef:	68 a4 1d 81 00       	push   $0x811da4
  804ff4:	e8 a0 96 00 00       	call   80e699 <_panic>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  804ff9:	b8 00 00 00 00       	mov    $0x0,%eax
  804ffe:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805001:	5b                   	pop    %ebx
  805002:	5e                   	pop    %esi
  805003:	5f                   	pop    %edi
  805004:	5d                   	pop    %ebp
  805005:	c3                   	ret    

00805006 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  805006:	55                   	push   %ebp
  805007:	89 e5                	mov    %esp,%ebp
  805009:	57                   	push   %edi
  80500a:	56                   	push   %esi
  80500b:	53                   	push   %ebx
  80500c:	83 ec 1c             	sub    $0x1c,%esp
  80500f:	8b 75 08             	mov    0x8(%ebp),%esi
  805012:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  805016:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80501a:	85 f6                	test   %esi,%esi
  80501c:	74 0e                	je     80502c <pbuf_copy_partial+0x26>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80501e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  805022:	74 1f                	je     805043 <pbuf_copy_partial+0x3d>

  left = 0;
  805024:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  80502a:	eb 65                	jmp    805091 <pbuf_copy_partial+0x8b>
  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80502c:	83 ec 04             	sub    $0x4,%esp
  80502f:	68 74 20 81 00       	push   $0x812074
  805034:	68 ef 02 00 00       	push   $0x2ef
  805039:	68 a4 1d 81 00       	push   $0x811da4
  80503e:	e8 56 96 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805043:	83 ec 04             	sub    $0x4,%esp
  805046:	68 98 20 81 00       	push   $0x812098
  80504b:	68 f0 02 00 00       	push   $0x2f0
  805050:	68 a4 1d 81 00       	push   $0x811da4
  805055:	e8 3f 96 00 00       	call   80e699 <_panic>
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80505a:	0f b7 5e 0a          	movzwl 0xa(%esi),%ebx
  80505e:	29 c3                	sub    %eax,%ebx
  805060:	66 39 df             	cmp    %bx,%di
  805063:	0f 46 df             	cmovbe %edi,%ebx
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805066:	83 ec 04             	sub    $0x4,%esp
  805069:	0f b7 d3             	movzwl %bx,%edx
  80506c:	52                   	push   %edx
  80506d:	0f b7 c0             	movzwl %ax,%eax
  805070:	03 46 04             	add    0x4(%esi),%eax
  805073:	50                   	push   %eax
  805074:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805078:	03 45 0c             	add    0xc(%ebp),%eax
  80507b:	50                   	push   %eax
  80507c:	e8 5d a0 00 00       	call   80f0de <memcpy>
      copied_total += buf_copy_len;
  805081:	66 01 5d e6          	add    %bx,-0x1a(%ebp)
      left += buf_copy_len;
      len -= buf_copy_len;
  805085:	29 df                	sub    %ebx,%edi
  805087:	83 c4 10             	add    $0x10,%esp
      offset = 0;
  80508a:	b8 00 00 00 00       	mov    $0x0,%eax
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80508f:	8b 36                	mov    (%esi),%esi
  805091:	66 85 ff             	test   %di,%di
  805094:	74 16                	je     8050ac <pbuf_copy_partial+0xa6>
  805096:	85 f6                	test   %esi,%esi
  805098:	74 12                	je     8050ac <pbuf_copy_partial+0xa6>
    if ((offset != 0) && (offset >= p->len)) {
  80509a:	66 85 c0             	test   %ax,%ax
  80509d:	74 bb                	je     80505a <pbuf_copy_partial+0x54>
  80509f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8050a3:	66 39 c2             	cmp    %ax,%dx
  8050a6:	77 b2                	ja     80505a <pbuf_copy_partial+0x54>
      offset -= p->len;
  8050a8:	29 d0                	sub    %edx,%eax
  8050aa:	eb e3                	jmp    80508f <pbuf_copy_partial+0x89>
    }
  }
  return copied_total;
}
  8050ac:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8050b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050b3:	5b                   	pop    %ebx
  8050b4:	5e                   	pop    %esi
  8050b5:	5f                   	pop    %edi
  8050b6:	5d                   	pop    %ebp
  8050b7:	c3                   	ret    

008050b8 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8050b8:	55                   	push   %ebp
  8050b9:	89 e5                	mov    %esp,%ebp
  8050bb:	83 ec 14             	sub    $0x14,%esp
  8050be:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8050c1:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8050c6:	8b 40 04             	mov    0x4(%eax),%eax
  8050c9:	ff 30                	pushl  (%eax)
  8050cb:	e8 2a 50 00 00       	call   80a0fa <sys_sem_signal>
}
  8050d0:	83 c4 10             	add    $0x10,%esp
  8050d3:	c9                   	leave  
  8050d4:	c3                   	ret    

008050d5 <sys_mbox_fetch>:
{
  8050d5:	55                   	push   %ebp
  8050d6:	89 e5                	mov    %esp,%ebp
  8050d8:	57                   	push   %edi
  8050d9:	56                   	push   %esi
  8050da:	53                   	push   %ebx
  8050db:	83 ec 0c             	sub    $0xc,%esp
  8050de:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8050e1:	eb 40                	jmp    805123 <sys_mbox_fetch+0x4e>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8050e3:	83 ec 04             	sub    $0x4,%esp
  8050e6:	6a 00                	push   $0x0
  8050e8:	57                   	push   %edi
  8050e9:	ff 75 08             	pushl  0x8(%ebp)
  8050ec:	e8 7e 52 00 00       	call   80a36f <sys_arch_mbox_fetch>
  8050f1:	83 c4 10             	add    $0x10,%esp
}
  8050f4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8050f7:	5b                   	pop    %ebx
  8050f8:	5e                   	pop    %esi
  8050f9:	5f                   	pop    %edi
  8050fa:	5d                   	pop    %ebp
  8050fb:	c3                   	ret    
      tmptimeout = timeouts->next;
  8050fc:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8050fe:	8b 10                	mov    (%eax),%edx
  805100:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  805102:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805105:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805108:	83 ec 08             	sub    $0x8,%esp
  80510b:	50                   	push   %eax
  80510c:	6a 0b                	push   $0xb
  80510e:	e8 2a f4 ff ff       	call   80453d <memp_free>
      if (h != NULL) {
  805113:	83 c4 10             	add    $0x10,%esp
  805116:	85 db                	test   %ebx,%ebx
  805118:	74 09                	je     805123 <sys_mbox_fetch+0x4e>
        h(arg);
  80511a:	83 ec 0c             	sub    $0xc,%esp
  80511d:	56                   	push   %esi
  80511e:	ff d3                	call   *%ebx
  805120:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  805123:	e8 dc 53 00 00       	call   80a504 <sys_arch_timeouts>
  805128:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  80512a:	85 c0                	test   %eax,%eax
  80512c:	74 b5                	je     8050e3 <sys_mbox_fetch+0xe>
  80512e:	8b 00                	mov    (%eax),%eax
  805130:	85 c0                	test   %eax,%eax
  805132:	74 af                	je     8050e3 <sys_mbox_fetch+0xe>
    if (timeouts->next->time > 0) {
  805134:	8b 40 04             	mov    0x4(%eax),%eax
  805137:	85 c0                	test   %eax,%eax
  805139:	74 c1                	je     8050fc <sys_mbox_fetch+0x27>
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80513b:	83 ec 04             	sub    $0x4,%esp
  80513e:	50                   	push   %eax
  80513f:	57                   	push   %edi
  805140:	ff 75 08             	pushl  0x8(%ebp)
  805143:	e8 27 52 00 00       	call   80a36f <sys_arch_mbox_fetch>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  805148:	83 c4 10             	add    $0x10,%esp
  80514b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80514e:	74 ac                	je     8050fc <sys_mbox_fetch+0x27>
      if (time_needed < timeouts->next->time) {
  805150:	8b 1b                	mov    (%ebx),%ebx
  805152:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  805155:	89 ca                	mov    %ecx,%edx
  805157:	29 c2                	sub    %eax,%edx
  805159:	39 c1                	cmp    %eax,%ecx
  80515b:	b8 00 00 00 00       	mov    $0x0,%eax
  805160:	0f 46 d0             	cmovbe %eax,%edx
  805163:	89 53 04             	mov    %edx,0x4(%ebx)
  805166:	eb 8c                	jmp    8050f4 <sys_mbox_fetch+0x1f>

00805168 <sys_sem_wait>:
{
  805168:	55                   	push   %ebp
  805169:	89 e5                	mov    %esp,%ebp
  80516b:	57                   	push   %edi
  80516c:	56                   	push   %esi
  80516d:	53                   	push   %ebx
  80516e:	83 ec 0c             	sub    $0xc,%esp
  805171:	8b 75 08             	mov    0x8(%ebp),%esi
  805174:	eb 3d                	jmp    8051b3 <sys_sem_wait+0x4b>
    sys_arch_sem_wait(sem, 0);
  805176:	83 ec 08             	sub    $0x8,%esp
  805179:	6a 00                	push   $0x0
  80517b:	56                   	push   %esi
  80517c:	e8 e9 4f 00 00       	call   80a16a <sys_arch_sem_wait>
  805181:	83 c4 10             	add    $0x10,%esp
}
  805184:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805187:	5b                   	pop    %ebx
  805188:	5e                   	pop    %esi
  805189:	5f                   	pop    %edi
  80518a:	5d                   	pop    %ebp
  80518b:	c3                   	ret    
      tmptimeout = timeouts->next;
  80518c:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  80518e:	8b 10                	mov    (%eax),%edx
  805190:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  805192:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  805195:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  805198:	83 ec 08             	sub    $0x8,%esp
  80519b:	50                   	push   %eax
  80519c:	6a 0b                	push   $0xb
  80519e:	e8 9a f3 ff ff       	call   80453d <memp_free>
      if (h != NULL) {
  8051a3:	83 c4 10             	add    $0x10,%esp
  8051a6:	85 db                	test   %ebx,%ebx
  8051a8:	74 09                	je     8051b3 <sys_sem_wait+0x4b>
        h(arg);
  8051aa:	83 ec 0c             	sub    $0xc,%esp
  8051ad:	57                   	push   %edi
  8051ae:	ff d3                	call   *%ebx
  8051b0:	83 c4 10             	add    $0x10,%esp
  timeouts = sys_arch_timeouts();
  8051b3:	e8 4c 53 00 00       	call   80a504 <sys_arch_timeouts>
  8051b8:	89 c3                	mov    %eax,%ebx
  if (!timeouts || !timeouts->next) {
  8051ba:	85 c0                	test   %eax,%eax
  8051bc:	74 b8                	je     805176 <sys_sem_wait+0xe>
  8051be:	8b 00                	mov    (%eax),%eax
  8051c0:	85 c0                	test   %eax,%eax
  8051c2:	74 b2                	je     805176 <sys_sem_wait+0xe>
    if (timeouts->next->time > 0) {
  8051c4:	8b 40 04             	mov    0x4(%eax),%eax
  8051c7:	85 c0                	test   %eax,%eax
  8051c9:	74 c1                	je     80518c <sys_sem_wait+0x24>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  8051cb:	83 ec 08             	sub    $0x8,%esp
  8051ce:	50                   	push   %eax
  8051cf:	56                   	push   %esi
  8051d0:	e8 95 4f 00 00       	call   80a16a <sys_arch_sem_wait>
    if (time_needed == SYS_ARCH_TIMEOUT) {
  8051d5:	83 c4 10             	add    $0x10,%esp
  8051d8:	83 f8 ff             	cmp    $0xffffffff,%eax
  8051db:	74 af                	je     80518c <sys_sem_wait+0x24>
      if (time_needed < timeouts->next->time) {
  8051dd:	8b 1b                	mov    (%ebx),%ebx
  8051df:	8b 4b 04             	mov    0x4(%ebx),%ecx
        timeouts->next->time -= time_needed;
  8051e2:	89 ca                	mov    %ecx,%edx
  8051e4:	29 c2                	sub    %eax,%edx
  8051e6:	39 c1                	cmp    %eax,%ecx
  8051e8:	b8 00 00 00 00       	mov    $0x0,%eax
  8051ed:	0f 46 d0             	cmovbe %eax,%edx
  8051f0:	89 53 04             	mov    %edx,0x4(%ebx)
  8051f3:	eb 8f                	jmp    805184 <sys_sem_wait+0x1c>

008051f5 <sys_timeout>:
{
  8051f5:	55                   	push   %ebp
  8051f6:	89 e5                	mov    %esp,%ebp
  8051f8:	57                   	push   %edi
  8051f9:	56                   	push   %esi
  8051fa:	53                   	push   %ebx
  8051fb:	83 ec 28             	sub    $0x28,%esp
  8051fe:	8b 75 08             	mov    0x8(%ebp),%esi
  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  805201:	6a 0b                	push   $0xb
  805203:	e8 df f2 ff ff       	call   8044e7 <memp_malloc>
  if (timeout == NULL) {
  805208:	83 c4 10             	add    $0x10,%esp
  80520b:	85 c0                	test   %eax,%eax
  80520d:	74 40                	je     80524f <sys_timeout+0x5a>
  80520f:	89 c3                	mov    %eax,%ebx
  timeout->next = NULL;
  805211:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805217:	8b 45 0c             	mov    0xc(%ebp),%eax
  80521a:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80521d:	8b 45 10             	mov    0x10(%ebp),%eax
  805220:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805223:	89 73 04             	mov    %esi,0x4(%ebx)
  timeouts = sys_arch_timeouts();
  805226:	e8 d9 52 00 00       	call   80a504 <sys_arch_timeouts>
  if (timeouts == NULL) {
  80522b:	85 c0                	test   %eax,%eax
  80522d:	74 37                	je     805266 <sys_timeout+0x71>
  if (timeouts->next == NULL) {
  80522f:	8b 10                	mov    (%eax),%edx
  805231:	85 d2                	test   %edx,%edx
  805233:	74 48                	je     80527d <sys_timeout+0x88>
  if (timeouts->next->time > msecs) {
  805235:	8b 4a 04             	mov    0x4(%edx),%ecx
  805238:	39 f1                	cmp    %esi,%ecx
  80523a:	76 47                	jbe    805283 <sys_timeout+0x8e>
    timeouts->next->time -= msecs;
  80523c:	29 f1                	sub    %esi,%ecx
  80523e:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  805241:	8b 10                	mov    (%eax),%edx
  805243:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805245:	89 18                	mov    %ebx,(%eax)
}
  805247:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80524a:	5b                   	pop    %ebx
  80524b:	5e                   	pop    %esi
  80524c:	5f                   	pop    %edi
  80524d:	5d                   	pop    %ebp
  80524e:	c3                   	ret    
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80524f:	83 ec 04             	sub    $0x4,%esp
  805252:	68 bd 20 81 00       	push   $0x8120bd
  805257:	68 c3 00 00 00       	push   $0xc3
  80525c:	68 da 20 81 00       	push   $0x8120da
  805261:	e8 33 94 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  805266:	83 ec 04             	sub    $0x4,%esp
  805269:	68 ee 20 81 00       	push   $0x8120ee
  80526e:	68 d1 00 00 00       	push   $0xd1
  805273:	68 da 20 81 00       	push   $0x8120da
  805278:	e8 1c 94 00 00       	call   80e699 <_panic>
    timeouts->next = timeout;
  80527d:	89 18                	mov    %ebx,(%eax)
    return;
  80527f:	eb c6                	jmp    805247 <sys_timeout+0x52>
      if (t->next == NULL || t->next->time > timeout->time) {
  805281:	89 c2                	mov    %eax,%edx
      timeout->time -= t->time;
  805283:	8b 7b 04             	mov    0x4(%ebx),%edi
  805286:	8b 42 04             	mov    0x4(%edx),%eax
  805289:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80528c:	89 f9                	mov    %edi,%ecx
  80528e:	29 c1                	sub    %eax,%ecx
  805290:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  805293:	8b 02                	mov    (%edx),%eax
  805295:	85 c0                	test   %eax,%eax
  805297:	74 17                	je     8052b0 <sys_timeout+0xbb>
  805299:	8b 70 04             	mov    0x4(%eax),%esi
  80529c:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80529f:	39 f1                	cmp    %esi,%ecx
  8052a1:	73 de                	jae    805281 <sys_timeout+0x8c>
  8052a3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
          t->next->time -= timeout->time;
  8052a6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8052a9:	29 f9                	sub    %edi,%ecx
  8052ab:	01 ce                	add    %ecx,%esi
  8052ad:	89 70 04             	mov    %esi,0x4(%eax)
        timeout->next = t->next;
  8052b0:	8b 02                	mov    (%edx),%eax
  8052b2:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  8052b4:	89 1a                	mov    %ebx,(%edx)
        break;
  8052b6:	eb 8f                	jmp    805247 <sys_timeout+0x52>

008052b8 <sys_untimeout>:
{
  8052b8:	55                   	push   %ebp
  8052b9:	89 e5                	mov    %esp,%ebp
  8052bb:	57                   	push   %edi
  8052bc:	56                   	push   %esi
  8052bd:	53                   	push   %ebx
  8052be:	83 ec 0c             	sub    $0xc,%esp
  8052c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8052c4:	8b 75 0c             	mov    0xc(%ebp),%esi
  timeouts = sys_arch_timeouts();
  8052c7:	e8 38 52 00 00       	call   80a504 <sys_arch_timeouts>
  if (timeouts == NULL) {
  8052cc:	85 c0                	test   %eax,%eax
  8052ce:	74 0d                	je     8052dd <sys_untimeout+0x25>
  if (timeouts->next == NULL) {
  8052d0:	8b 10                	mov    (%eax),%edx
  8052d2:	85 d2                	test   %edx,%edx
  8052d4:	74 5a                	je     805330 <sys_untimeout+0x78>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8052d6:	bf 00 00 00 00       	mov    $0x0,%edi
  8052db:	eb 27                	jmp    805304 <sys_untimeout+0x4c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8052dd:	83 ec 04             	sub    $0x4,%esp
  8052e0:	68 0c 21 81 00       	push   $0x81210c
  8052e5:	68 00 01 00 00       	push   $0x100
  8052ea:	68 da 20 81 00       	push   $0x8120da
  8052ef:	e8 a5 93 00 00       	call   80e699 <_panic>
        timeouts->next = t->next;
  8052f4:	8b 0a                	mov    (%edx),%ecx
  8052f6:	89 08                	mov    %ecx,(%eax)
  8052f8:	eb 1c                	jmp    805316 <sys_untimeout+0x5e>
  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  8052fa:	8b 0a                	mov    (%edx),%ecx
  8052fc:	89 d7                	mov    %edx,%edi
  8052fe:	85 c9                	test   %ecx,%ecx
  805300:	74 2e                	je     805330 <sys_untimeout+0x78>
  805302:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  805304:	39 5a 08             	cmp    %ebx,0x8(%edx)
  805307:	75 f1                	jne    8052fa <sys_untimeout+0x42>
  805309:	39 72 0c             	cmp    %esi,0xc(%edx)
  80530c:	75 ec                	jne    8052fa <sys_untimeout+0x42>
      if (prev_t == NULL)
  80530e:	85 ff                	test   %edi,%edi
  805310:	74 e2                	je     8052f4 <sys_untimeout+0x3c>
        prev_t->next = t->next;
  805312:	8b 02                	mov    (%edx),%eax
  805314:	89 07                	mov    %eax,(%edi)
      if (t->next != NULL)
  805316:	8b 02                	mov    (%edx),%eax
  805318:	85 c0                	test   %eax,%eax
  80531a:	74 06                	je     805322 <sys_untimeout+0x6a>
        t->next->time += t->time;
  80531c:	8b 4a 04             	mov    0x4(%edx),%ecx
  80531f:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805322:	83 ec 08             	sub    $0x8,%esp
  805325:	52                   	push   %edx
  805326:	6a 0b                	push   $0xb
  805328:	e8 10 f2 ff ff       	call   80453d <memp_free>
      return;
  80532d:	83 c4 10             	add    $0x10,%esp
}
  805330:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805333:	5b                   	pop    %ebx
  805334:	5e                   	pop    %esi
  805335:	5f                   	pop    %edi
  805336:	5d                   	pop    %ebp
  805337:	c3                   	ret    

00805338 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  805338:	55                   	push   %ebp
  805339:	89 e5                	mov    %esp,%ebp
  80533b:	83 ec 18             	sub    $0x18,%esp
  80533e:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805341:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805344:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805347:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80534d:	85 c0                	test   %eax,%eax
  80534f:	75 1c                	jne    80536d <sys_sem_wait_timeout+0x35>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  805351:	83 ec 0c             	sub    $0xc,%esp
  805354:	ff 75 08             	pushl  0x8(%ebp)
  805357:	e8 0c fe ff ff       	call   805168 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80535c:	83 c4 10             	add    $0x10,%esp
    /* timeout */
    return 0;
  80535f:	b8 00 00 00 00       	mov    $0x0,%eax
  if (sswt_cb.timeflag) {
  805364:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  805369:	74 19                	je     805384 <sys_sem_wait_timeout+0x4c>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
    return 1;
  }
}
  80536b:	c9                   	leave  
  80536c:	c3                   	ret    
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80536d:	83 ec 04             	sub    $0x4,%esp
  805370:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805373:	52                   	push   %edx
  805374:	68 b8 50 80 00       	push   $0x8050b8
  805379:	50                   	push   %eax
  80537a:	e8 76 fe ff ff       	call   8051f5 <sys_timeout>
  80537f:	83 c4 10             	add    $0x10,%esp
  805382:	eb cd                	jmp    805351 <sys_sem_wait_timeout+0x19>
    sys_untimeout(sswt_handler, &sswt_cb);
  805384:	83 ec 08             	sub    $0x8,%esp
  805387:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80538a:	50                   	push   %eax
  80538b:	68 b8 50 80 00       	push   $0x8050b8
  805390:	e8 23 ff ff ff       	call   8052b8 <sys_untimeout>
    return 1;
  805395:	83 c4 10             	add    $0x10,%esp
  805398:	b8 01 00 00 00       	mov    $0x1,%eax
  80539d:	eb cc                	jmp    80536b <sys_sem_wait_timeout+0x33>

0080539f <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80539f:	55                   	push   %ebp
  8053a0:	89 e5                	mov    %esp,%ebp
  8053a2:	53                   	push   %ebx
  8053a3:	83 ec 10             	sub    $0x10,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  8053a6:	6a 00                	push   $0x0
  8053a8:	e8 90 4a 00 00       	call   809e3d <sys_sem_new>
  8053ad:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8053af:	83 c4 08             	add    $0x8,%esp
  8053b2:	ff 75 08             	pushl  0x8(%ebp)
  8053b5:	50                   	push   %eax
  8053b6:	e8 7d ff ff ff       	call   805338 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8053bb:	89 1c 24             	mov    %ebx,(%esp)
  8053be:	e8 fb 4a 00 00       	call   809ebe <sys_sem_free>
}
  8053c3:	83 c4 10             	add    $0x10,%esp
  8053c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8053c9:	c9                   	leave  
  8053ca:	c3                   	ret    

008053cb <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  8053cb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8053d0:	c3                   	ret    

008053d1 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8053d1:	55                   	push   %ebp
  8053d2:	89 e5                	mov    %esp,%ebp
  8053d4:	57                   	push   %edi
  8053d5:	56                   	push   %esi
  8053d6:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8053d7:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8053dd:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8053e3:	8b 3d 44 b2 b3 00    	mov    0xb3b244,%edi
  8053e9:	0f b7 05 0c 40 81 00 	movzwl 0x81400c,%eax
    port = TCP_LOCAL_PORT_RANGE_START;
  8053f0:	b9 00 10 00 00       	mov    $0x1000,%ecx
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8053f5:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8053f9:	0f 48 c1             	cmovs  %ecx,%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8053fc:	89 da                	mov    %ebx,%edx
  8053fe:	85 d2                	test   %edx,%edx
  805400:	74 0b                	je     80540d <tcp_new_port+0x3c>
    if (pcb->local_port == port) {
  805402:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805406:	74 ed                	je     8053f5 <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805408:	8b 52 0c             	mov    0xc(%edx),%edx
  80540b:	eb f1                	jmp    8053fe <tcp_new_port+0x2d>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80540d:	89 f2                	mov    %esi,%edx
  80540f:	85 d2                	test   %edx,%edx
  805411:	74 0b                	je     80541e <tcp_new_port+0x4d>
    if (pcb->local_port == port) {
  805413:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805417:	74 dc                	je     8053f5 <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805419:	8b 52 0c             	mov    0xc(%edx),%edx
  80541c:	eb f1                	jmp    80540f <tcp_new_port+0x3e>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80541e:	89 fa                	mov    %edi,%edx
  805420:	85 d2                	test   %edx,%edx
  805422:	74 0b                	je     80542f <tcp_new_port+0x5e>
    if (pcb->local_port == port) {
  805424:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805428:	74 cb                	je     8053f5 <tcp_new_port+0x24>
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80542a:	8b 52 0c             	mov    0xc(%edx),%edx
  80542d:	eb f1                	jmp    805420 <tcp_new_port+0x4f>
  80542f:	66 a3 0c 40 81 00    	mov    %ax,0x81400c
      goto again;
    }
  }
  return port;
}
  805435:	5b                   	pop    %ebx
  805436:	5e                   	pop    %esi
  805437:	5f                   	pop    %edi
  805438:	5d                   	pop    %ebp
  805439:	c3                   	ret    

0080543a <tcp_bind>:
{
  80543a:	55                   	push   %ebp
  80543b:	89 e5                	mov    %esp,%ebp
  80543d:	57                   	push   %edi
  80543e:	56                   	push   %esi
  80543f:	53                   	push   %ebx
  805440:	83 ec 0c             	sub    $0xc,%esp
  805443:	8b 75 08             	mov    0x8(%ebp),%esi
  805446:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805449:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80544c:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805450:	75 0f                	jne    805461 <tcp_bind+0x27>
  805452:	89 d0                	mov    %edx,%eax
  if (port == 0) {
  805454:	66 85 d2             	test   %dx,%dx
  805457:	74 1f                	je     805478 <tcp_bind+0x3e>
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805459:	8b 15 44 b2 b3 00    	mov    0xb3b244,%edx
  80545f:	eb 21                	jmp    805482 <tcp_bind+0x48>
  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805461:	83 ec 04             	sub    $0x4,%esp
  805464:	68 2c 21 81 00       	push   $0x81212c
  805469:	68 05 01 00 00       	push   $0x105
  80546e:	68 0e 23 81 00       	push   $0x81230e
  805473:	e8 21 92 00 00       	call   80e699 <_panic>
    port = tcp_new_port();
  805478:	e8 54 ff ff ff       	call   8053d1 <tcp_new_port>
  80547d:	eb da                	jmp    805459 <tcp_bind+0x1f>
      cpcb != NULL; cpcb = cpcb->next) {
  80547f:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805482:	85 d2                	test   %edx,%edx
  805484:	74 2c                	je     8054b2 <tcp_bind+0x78>
    if (cpcb->local_port == port) {
  805486:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80548a:	75 f3                	jne    80547f <tcp_bind+0x45>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80548c:	8b 0a                	mov    (%edx),%ecx
  80548e:	85 db                	test   %ebx,%ebx
  805490:	0f 84 d4 00 00 00    	je     80556a <tcp_bind+0x130>
  805496:	85 c9                	test   %ecx,%ecx
  805498:	0f 84 cc 00 00 00    	je     80556a <tcp_bind+0x130>
          ip_addr_isany(ipaddr) ||
  80549e:	8b 3b                	mov    (%ebx),%edi
  8054a0:	39 f9                	cmp    %edi,%ecx
  8054a2:	74 04                	je     8054a8 <tcp_bind+0x6e>
  8054a4:	85 ff                	test   %edi,%edi
  8054a6:	75 d7                	jne    80547f <tcp_bind+0x45>
        return ERR_USE;
  8054a8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054ad:	e9 bd 00 00 00       	jmp    80556f <tcp_bind+0x135>
  for(cpcb = tcp_active_pcbs;
  8054b2:	8b 15 3c b2 b3 00    	mov    0xb3b23c,%edx
  8054b8:	eb 03                	jmp    8054bd <tcp_bind+0x83>
      cpcb != NULL; cpcb = cpcb->next) {
  8054ba:	8b 52 0c             	mov    0xc(%edx),%edx
  for(cpcb = tcp_active_pcbs;
  8054bd:	85 d2                	test   %edx,%edx
  8054bf:	74 2c                	je     8054ed <tcp_bind+0xb3>
    if (cpcb->local_port == port) {
  8054c1:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8054c5:	75 f3                	jne    8054ba <tcp_bind+0x80>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8054c7:	8b 0a                	mov    (%edx),%ecx
  8054c9:	85 db                	test   %ebx,%ebx
  8054cb:	0f 84 a6 00 00 00    	je     805577 <tcp_bind+0x13d>
  8054d1:	85 c9                	test   %ecx,%ecx
  8054d3:	0f 84 9e 00 00 00    	je     805577 <tcp_bind+0x13d>
          ip_addr_isany(ipaddr) ||
  8054d9:	8b 3b                	mov    (%ebx),%edi
  8054db:	39 f9                	cmp    %edi,%ecx
  8054dd:	74 04                	je     8054e3 <tcp_bind+0xa9>
  8054df:	85 ff                	test   %edi,%edi
  8054e1:	75 d7                	jne    8054ba <tcp_bind+0x80>
        return ERR_USE;
  8054e3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  8054e8:	e9 82 00 00 00       	jmp    80556f <tcp_bind+0x135>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8054ed:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8054f3:	eb 03                	jmp    8054f8 <tcp_bind+0xbe>
  8054f5:	8b 52 0c             	mov    0xc(%edx),%edx
  8054f8:	85 d2                	test   %edx,%edx
  8054fa:	74 21                	je     80551d <tcp_bind+0xe3>
    if (cpcb->local_port == port) {
  8054fc:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805500:	75 f3                	jne    8054f5 <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805502:	8b 0a                	mov    (%edx),%ecx
  805504:	85 db                	test   %ebx,%ebx
  805506:	74 76                	je     80557e <tcp_bind+0x144>
  805508:	85 c9                	test   %ecx,%ecx
  80550a:	74 72                	je     80557e <tcp_bind+0x144>
          ip_addr_isany(ipaddr) ||
  80550c:	8b 3b                	mov    (%ebx),%edi
  80550e:	39 f9                	cmp    %edi,%ecx
  805510:	74 04                	je     805516 <tcp_bind+0xdc>
  805512:	85 ff                	test   %edi,%edi
  805514:	75 df                	jne    8054f5 <tcp_bind+0xbb>
        return ERR_USE;
  805516:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80551b:	eb 52                	jmp    80556f <tcp_bind+0x135>
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80551d:	8b 15 50 b2 b3 00    	mov    0xb3b250,%edx
  805523:	eb 03                	jmp    805528 <tcp_bind+0xee>
  805525:	8b 52 0c             	mov    0xc(%edx),%edx
  805528:	85 d2                	test   %edx,%edx
  80552a:	74 13                	je     80553f <tcp_bind+0x105>
    if (cpcb->local_port == port) {
  80552c:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805530:	75 f3                	jne    805525 <tcp_bind+0xeb>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805532:	8b 3b                	mov    (%ebx),%edi
  805534:	39 3a                	cmp    %edi,(%edx)
  805536:	75 ed                	jne    805525 <tcp_bind+0xeb>
        return ERR_USE;
  805538:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80553d:	eb 30                	jmp    80556f <tcp_bind+0x135>
  if (!ip_addr_isany(ipaddr)) {
  80553f:	85 db                	test   %ebx,%ebx
  805541:	74 09                	je     80554c <tcp_bind+0x112>
  805543:	83 3b 00             	cmpl   $0x0,(%ebx)
  805546:	74 04                	je     80554c <tcp_bind+0x112>
    pcb->local_ip = *ipaddr;
  805548:	8b 13                	mov    (%ebx),%edx
  80554a:	89 16                	mov    %edx,(%esi)
  pcb->local_port = port;
  80554c:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805550:	a1 4c b2 b3 00       	mov    0xb3b24c,%eax
  805555:	89 46 0c             	mov    %eax,0xc(%esi)
  805558:	89 35 4c b2 b3 00    	mov    %esi,0xb3b24c
  80555e:	e8 fd cc ff ff       	call   802260 <tcp_timer_needed>
  return ERR_OK;
  805563:	b8 00 00 00 00       	mov    $0x0,%eax
  805568:	eb 05                	jmp    80556f <tcp_bind+0x135>
        return ERR_USE;
  80556a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80556f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805572:	5b                   	pop    %ebx
  805573:	5e                   	pop    %esi
  805574:	5f                   	pop    %edi
  805575:	5d                   	pop    %ebp
  805576:	c3                   	ret    
        return ERR_USE;
  805577:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80557c:	eb f1                	jmp    80556f <tcp_bind+0x135>
        return ERR_USE;
  80557e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805583:	eb ea                	jmp    80556f <tcp_bind+0x135>

00805585 <tcp_listen_with_backlog>:
{
  805585:	55                   	push   %ebp
  805586:	89 e5                	mov    %esp,%ebp
  805588:	57                   	push   %edi
  805589:	56                   	push   %esi
  80558a:	53                   	push   %ebx
  80558b:	83 ec 1c             	sub    $0x1c,%esp
  80558e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805591:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805595:	0f 85 80 00 00 00    	jne    80561b <tcp_listen_with_backlog+0x96>
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80559b:	83 ec 0c             	sub    $0xc,%esp
  80559e:	6a 03                	push   $0x3
  8055a0:	e8 42 ef ff ff       	call   8044e7 <memp_malloc>
  8055a5:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  8055a7:	83 c4 10             	add    $0x10,%esp
  8055aa:	85 c0                	test   %eax,%eax
  8055ac:	0f 84 b7 00 00 00    	je     805669 <tcp_listen_with_backlog+0xe4>
  lpcb->callback_arg = pcb->callback_arg;
  8055b2:	8b 43 18             	mov    0x18(%ebx),%eax
  8055b5:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  8055b8:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8055bc:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  8055c0:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options |= SOF_ACCEPTCONN;
  8055c7:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8055cb:	83 c8 02             	or     $0x2,%eax
  8055ce:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  8055d2:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8055d6:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  8055d9:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8055dd:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  8055e0:	8b 03                	mov    (%ebx),%eax
  8055e2:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8055e4:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  8055ea:	39 da                	cmp    %ebx,%edx
  8055ec:	74 44                	je     805632 <tcp_listen_with_backlog+0xad>
  8055ee:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  8055f4:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8055f8:	89 df                	mov    %ebx,%edi
  8055fa:	85 d2                	test   %edx,%edx
  8055fc:	0f 84 87 00 00 00    	je     805689 <tcp_listen_with_backlog+0x104>
  805602:	8b 42 0c             	mov    0xc(%edx),%eax
  805605:	39 f8                	cmp    %edi,%eax
  805607:	0f 94 c3             	sete   %bl
  80560a:	85 c0                	test   %eax,%eax
  80560c:	0f 95 c1             	setne  %cl
  80560f:	84 cb                	test   %cl,%bl
  805611:	75 60                	jne    805673 <tcp_listen_with_backlog+0xee>
  805613:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
  805617:	89 c2                	mov    %eax,%edx
  805619:	eb df                	jmp    8055fa <tcp_listen_with_backlog+0x75>
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80561b:	83 ec 04             	sub    $0x4,%esp
  80561e:	68 58 21 81 00       	push   $0x812158
  805623:	68 60 01 00 00       	push   $0x160
  805628:	68 0e 23 81 00       	push   $0x81230e
  80562d:	e8 67 90 00 00       	call   80e699 <_panic>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805632:	8b 43 0c             	mov    0xc(%ebx),%eax
  805635:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  80563a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805641:	83 ec 08             	sub    $0x8,%esp
  805644:	53                   	push   %ebx
  805645:	6a 02                	push   $0x2
  805647:	e8 f1 ee ff ff       	call   80453d <memp_free>
  lpcb->accept = tcp_accept_null;
  80564c:	c7 46 20 cb 53 80 00 	movl   $0x8053cb,0x20(%esi)
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805653:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  805658:	89 46 0c             	mov    %eax,0xc(%esi)
  80565b:	89 35 44 b2 b3 00    	mov    %esi,0xb3b244
  805661:	e8 fa cb ff ff       	call   802260 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805666:	83 c4 10             	add    $0x10,%esp
}
  805669:	89 f0                	mov    %esi,%eax
  80566b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80566e:	5b                   	pop    %ebx
  80566f:	5e                   	pop    %esi
  805670:	5f                   	pop    %edi
  805671:	5d                   	pop    %ebp
  805672:	c3                   	ret    
  805673:	89 fb                	mov    %edi,%ebx
  805675:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  805679:	74 06                	je     805681 <tcp_listen_with_backlog+0xfc>
  80567b:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805681:	8b 43 0c             	mov    0xc(%ebx),%eax
  805684:	89 42 0c             	mov    %eax,0xc(%edx)
  805687:	eb b1                	jmp    80563a <tcp_listen_with_backlog+0xb5>
  805689:	89 fb                	mov    %edi,%ebx
  80568b:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80568f:	74 a9                	je     80563a <tcp_listen_with_backlog+0xb5>
  805691:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805698:	00 00 00 
  80569b:	eb 9d                	jmp    80563a <tcp_listen_with_backlog+0xb5>

0080569d <tcp_recved>:
{
  80569d:	55                   	push   %ebp
  80569e:	89 e5                	mov    %esp,%ebp
  8056a0:	56                   	push   %esi
  8056a1:	53                   	push   %ebx
  8056a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8056a5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8056a8:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  8056ac:	0f b7 ca             	movzwl %dx,%ecx
  8056af:	0f b7 f3             	movzwl %bx,%esi
  8056b2:	01 f1                	add    %esi,%ecx
  8056b4:	81 f9 c0 5d 00 00    	cmp    $0x5dc0,%ecx
  8056ba:	76 27                	jbe    8056e3 <tcp_recved+0x46>
    pcb->rcv_wnd = TCP_WND;
  8056bc:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8056c2:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  if (!(pcb->flags & TF_ACK_DELAY) &&
  8056c8:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8056cc:	f6 c2 03             	test   $0x3,%dl
  8056cf:	75 3b                	jne    80570c <tcp_recved+0x6f>
    tcp_ack(pcb);
  8056d1:	f6 c2 01             	test   $0x1,%dl
  8056d4:	75 1f                	jne    8056f5 <tcp_recved+0x58>
  8056d6:	83 ca 01             	or     $0x1,%edx
  8056d9:	88 50 20             	mov    %dl,0x20(%eax)
}
  8056dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8056df:	5b                   	pop    %ebx
  8056e0:	5e                   	pop    %esi
  8056e1:	5d                   	pop    %ebp
  8056e2:	c3                   	ret    
    pcb->rcv_wnd += len;
  8056e3:	01 da                	add    %ebx,%edx
  8056e5:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8056e9:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8056ed:	72 d9                	jb     8056c8 <tcp_recved+0x2b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8056ef:	66 89 50 2a          	mov    %dx,0x2a(%eax)
  8056f3:	eb d3                	jmp    8056c8 <tcp_recved+0x2b>
    tcp_ack(pcb);
  8056f5:	83 e2 fe             	and    $0xfffffffe,%edx
  8056f8:	83 ca 02             	or     $0x2,%edx
  8056fb:	88 50 20             	mov    %dl,0x20(%eax)
  8056fe:	83 ec 0c             	sub    $0xc,%esp
  805701:	50                   	push   %eax
  805702:	e8 be 29 00 00       	call   8080c5 <tcp_output>
  805707:	83 c4 10             	add    $0x10,%esp
  80570a:	eb d0                	jmp    8056dc <tcp_recved+0x3f>
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80570c:	f6 c2 01             	test   $0x1,%dl
  80570f:	74 cb                	je     8056dc <tcp_recved+0x3f>
  805711:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805717:	76 c3                	jbe    8056dc <tcp_recved+0x3f>
    tcp_ack_now(pcb);
  805719:	83 ca 02             	or     $0x2,%edx
  80571c:	88 50 20             	mov    %dl,0x20(%eax)
  80571f:	83 ec 0c             	sub    $0xc,%esp
  805722:	50                   	push   %eax
  805723:	e8 9d 29 00 00       	call   8080c5 <tcp_output>
  805728:	83 c4 10             	add    $0x10,%esp
}
  80572b:	eb af                	jmp    8056dc <tcp_recved+0x3f>

0080572d <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80572d:	55                   	push   %ebp
  80572e:	89 e5                	mov    %esp,%ebp
  805730:	53                   	push   %ebx
  805731:	83 ec 04             	sub    $0x4,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805734:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  80573a:	eb 21                	jmp    80575d <tcp_fasttmr+0x30>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80573c:	83 ec 0c             	sub    $0xc,%esp
  80573f:	50                   	push   %eax
  805740:	e8 45 f1 ff ff       	call   80488a <pbuf_free>
  805745:	83 c4 10             	add    $0x10,%esp
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805748:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80574f:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805752:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805756:	a8 01                	test   $0x1,%al
  805758:	75 2d                	jne    805787 <tcp_fasttmr+0x5a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80575a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80575d:	85 db                	test   %ebx,%ebx
  80575f:	74 3e                	je     80579f <tcp_fasttmr+0x72>
    if (pcb->refused_data != NULL) {
  805761:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805767:	85 c0                	test   %eax,%eax
  805769:	74 e7                	je     805752 <tcp_fasttmr+0x25>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80576b:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805771:	85 d2                	test   %edx,%edx
  805773:	74 c7                	je     80573c <tcp_fasttmr+0xf>
  805775:	6a 00                	push   $0x0
  805777:	50                   	push   %eax
  805778:	53                   	push   %ebx
  805779:	ff 73 18             	pushl  0x18(%ebx)
  80577c:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80577e:	83 c4 10             	add    $0x10,%esp
  805781:	84 c0                	test   %al,%al
  805783:	74 c3                	je     805748 <tcp_fasttmr+0x1b>
  805785:	eb cb                	jmp    805752 <tcp_fasttmr+0x25>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805787:	83 c8 02             	or     $0x2,%eax
  80578a:	88 43 20             	mov    %al,0x20(%ebx)
  80578d:	83 ec 0c             	sub    $0xc,%esp
  805790:	53                   	push   %ebx
  805791:	e8 2f 29 00 00       	call   8080c5 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805796:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
  80579a:	83 c4 10             	add    $0x10,%esp
  80579d:	eb bb                	jmp    80575a <tcp_fasttmr+0x2d>
    }
  }
}
  80579f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8057a2:	c9                   	leave  
  8057a3:	c3                   	ret    

008057a4 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8057a4:	55                   	push   %ebp
  8057a5:	89 e5                	mov    %esp,%ebp
  8057a7:	56                   	push   %esi
  8057a8:	53                   	push   %ebx
  8057a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  8057ac:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
  8057b1:	85 db                	test   %ebx,%ebx
  8057b3:	74 23                	je     8057d8 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
  8057b5:	8b 43 04             	mov    0x4(%ebx),%eax
  8057b8:	85 c0                	test   %eax,%eax
  8057ba:	74 0e                	je     8057ca <tcp_seg_free+0x26>
      count = pbuf_free(seg->p);
  8057bc:	83 ec 0c             	sub    $0xc,%esp
  8057bf:	50                   	push   %eax
  8057c0:	e8 c5 f0 ff ff       	call   80488a <pbuf_free>
  8057c5:	89 c6                	mov    %eax,%esi
  8057c7:	83 c4 10             	add    $0x10,%esp
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8057ca:	83 ec 08             	sub    $0x8,%esp
  8057cd:	53                   	push   %ebx
  8057ce:	6a 04                	push   $0x4
  8057d0:	e8 68 ed ff ff       	call   80453d <memp_free>
  8057d5:	83 c4 10             	add    $0x10,%esp
  }
  return count;
}
  8057d8:	89 f0                	mov    %esi,%eax
  8057da:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8057dd:	5b                   	pop    %ebx
  8057de:	5e                   	pop    %esi
  8057df:	5d                   	pop    %ebp
  8057e0:	c3                   	ret    

008057e1 <tcp_segs_free>:
{
  8057e1:	55                   	push   %ebp
  8057e2:	89 e5                	mov    %esp,%ebp
  8057e4:	56                   	push   %esi
  8057e5:	53                   	push   %ebx
  8057e6:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  8057e9:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (seg != NULL) {
  8057ee:	85 c0                	test   %eax,%eax
  8057f0:	74 14                	je     805806 <tcp_segs_free+0x25>
    next = seg->next;
  8057f2:	8b 30                	mov    (%eax),%esi
    count += tcp_seg_free(seg);
  8057f4:	83 ec 0c             	sub    $0xc,%esp
  8057f7:	50                   	push   %eax
  8057f8:	e8 a7 ff ff ff       	call   8057a4 <tcp_seg_free>
  8057fd:	01 c3                	add    %eax,%ebx
    seg = next;
  8057ff:	83 c4 10             	add    $0x10,%esp
  805802:	89 f0                	mov    %esi,%eax
  805804:	eb e8                	jmp    8057ee <tcp_segs_free+0xd>
}
  805806:	89 d8                	mov    %ebx,%eax
  805808:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80580b:	5b                   	pop    %ebx
  80580c:	5e                   	pop    %esi
  80580d:	5d                   	pop    %ebp
  80580e:	c3                   	ret    

0080580f <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80580f:	55                   	push   %ebp
  805810:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805812:	8b 45 08             	mov    0x8(%ebp),%eax
  805815:	8b 55 0c             	mov    0xc(%ebp),%edx
  805818:	88 50 14             	mov    %dl,0x14(%eax)
}
  80581b:	5d                   	pop    %ebp
  80581c:	c3                   	ret    

0080581d <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80581d:	55                   	push   %ebp
  80581e:	89 e5                	mov    %esp,%ebp
  805820:	53                   	push   %ebx
  805821:	83 ec 10             	sub    $0x10,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805824:	6a 04                	push   $0x4
  805826:	e8 bc ec ff ff       	call   8044e7 <memp_malloc>
  80582b:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  80582d:	83 c4 10             	add    $0x10,%esp
  805830:	85 c0                	test   %eax,%eax
  805832:	74 1c                	je     805850 <tcp_seg_copy+0x33>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805834:	83 ec 04             	sub    $0x4,%esp
  805837:	6a 14                	push   $0x14
  805839:	ff 75 08             	pushl  0x8(%ebp)
  80583c:	50                   	push   %eax
  80583d:	e8 9c 98 00 00       	call   80f0de <memcpy>
  pbuf_ref(cseg->p);
  805842:	83 c4 04             	add    $0x4,%esp
  805845:	ff 73 04             	pushl  0x4(%ebx)
  805848:	e8 9f f4 ff ff       	call   804cec <pbuf_ref>
  return cseg;
  80584d:	83 c4 10             	add    $0x10,%esp
}
  805850:	89 d8                	mov    %ebx,%eax
  805852:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  805855:	c9                   	leave  
  805856:	c3                   	ret    

00805857 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805857:	55                   	push   %ebp
  805858:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  80585a:	8b 45 08             	mov    0x8(%ebp),%eax
  80585d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805860:	89 50 18             	mov    %edx,0x18(%eax)
}
  805863:	5d                   	pop    %ebp
  805864:	c3                   	ret    

00805865 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805865:	55                   	push   %ebp
  805866:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805868:	8b 45 08             	mov    0x8(%ebp),%eax
  80586b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80586e:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805874:	5d                   	pop    %ebp
  805875:	c3                   	ret    

00805876 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805876:	55                   	push   %ebp
  805877:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805879:	8b 45 08             	mov    0x8(%ebp),%eax
  80587c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80587f:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805885:	5d                   	pop    %ebp
  805886:	c3                   	ret    

00805887 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805887:	55                   	push   %ebp
  805888:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80588a:	8b 45 08             	mov    0x8(%ebp),%eax
  80588d:	8b 55 0c             	mov    0xc(%ebp),%edx
  805890:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805896:	5d                   	pop    %ebp
  805897:	c3                   	ret    

00805898 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805898:	55                   	push   %ebp
  805899:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80589b:	8b 45 08             	mov    0x8(%ebp),%eax
  80589e:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058a1:	89 50 20             	mov    %edx,0x20(%eax)
}
  8058a4:	5d                   	pop    %ebp
  8058a5:	c3                   	ret    

008058a6 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8058a6:	55                   	push   %ebp
  8058a7:	89 e5                	mov    %esp,%ebp
  8058a9:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8058ac:	8b 55 0c             	mov    0xc(%ebp),%edx
  8058af:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8058b5:	8b 55 10             	mov    0x10(%ebp),%edx
  8058b8:	88 50 31             	mov    %dl,0x31(%eax)
}
  8058bb:	5d                   	pop    %ebp
  8058bc:	c3                   	ret    

008058bd <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8058bd:	55                   	push   %ebp
  8058be:	89 e5                	mov    %esp,%ebp
  8058c0:	53                   	push   %ebx
  8058c1:	83 ec 04             	sub    $0x4,%esp
  8058c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  8058c7:	8b 43 10             	mov    0x10(%ebx),%eax
     pcb->state != TIME_WAIT &&
  8058ca:	83 f8 0a             	cmp    $0xa,%eax
  8058cd:	74 05                	je     8058d4 <tcp_pcb_purge+0x17>
  8058cf:	83 f8 01             	cmp    $0x1,%eax
  8058d2:	77 05                	ja     8058d9 <tcp_pcb_purge+0x1c>
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
  }
}
  8058d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8058d7:	c9                   	leave  
  8058d8:	c3                   	ret    
    if (pcb->refused_data != NULL) {
  8058d9:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  8058df:	85 c0                	test   %eax,%eax
  8058e1:	74 16                	je     8058f9 <tcp_pcb_purge+0x3c>
      pbuf_free(pcb->refused_data);
  8058e3:	83 ec 0c             	sub    $0xc,%esp
  8058e6:	50                   	push   %eax
  8058e7:	e8 9e ef ff ff       	call   80488a <pbuf_free>
      pcb->refused_data = NULL;
  8058ec:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8058f3:	00 00 00 
  8058f6:	83 c4 10             	add    $0x10,%esp
    pcb->rtime = -1;
  8058f9:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    tcp_segs_free(pcb->ooseq);
  8058ff:	83 ec 0c             	sub    $0xc,%esp
  805902:	ff 73 7c             	pushl  0x7c(%ebx)
  805905:	e8 d7 fe ff ff       	call   8057e1 <tcp_segs_free>
    pcb->ooseq = NULL;
  80590a:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
    tcp_segs_free(pcb->unsent);
  805911:	83 c4 04             	add    $0x4,%esp
  805914:	ff 73 74             	pushl  0x74(%ebx)
  805917:	e8 c5 fe ff ff       	call   8057e1 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  80591c:	83 c4 04             	add    $0x4,%esp
  80591f:	ff 73 78             	pushl  0x78(%ebx)
  805922:	e8 ba fe ff ff       	call   8057e1 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805927:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  80592e:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  805935:	83 c4 10             	add    $0x10,%esp
}
  805938:	eb 9a                	jmp    8058d4 <tcp_pcb_purge+0x17>

0080593a <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  80593a:	55                   	push   %ebp
  80593b:	89 e5                	mov    %esp,%ebp
  80593d:	57                   	push   %edi
  80593e:	56                   	push   %esi
  80593f:	53                   	push   %ebx
  805940:	83 ec 0c             	sub    $0xc,%esp
  805943:	8b 45 08             	mov    0x8(%ebp),%eax
  805946:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805949:	8b 10                	mov    (%eax),%edx
  80594b:	39 da                	cmp    %ebx,%edx
  80594d:	74 2f                	je     80597e <tcp_pcb_remove+0x44>
  80594f:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805955:	bf 00 00 00 00       	mov    $0x0,%edi
  80595a:	89 de                	mov    %ebx,%esi
  80595c:	85 d2                	test   %edx,%edx
  80595e:	0f 84 82 00 00 00    	je     8059e6 <tcp_pcb_remove+0xac>
  805964:	8b 42 0c             	mov    0xc(%edx),%eax
  805967:	39 f0                	cmp    %esi,%eax
  805969:	0f 94 c3             	sete   %bl
  80596c:	85 c0                	test   %eax,%eax
  80596e:	0f 95 c1             	setne  %cl
  805971:	84 cb                	test   %cl,%bl
  805973:	75 5b                	jne    8059d0 <tcp_pcb_remove+0x96>
  805975:	bf 01 00 00 00       	mov    $0x1,%edi
  80597a:	89 c2                	mov    %eax,%edx
  80597c:	eb de                	jmp    80595c <tcp_pcb_remove+0x22>
  80597e:	8b 53 0c             	mov    0xc(%ebx),%edx
  805981:	89 10                	mov    %edx,(%eax)
  805983:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  80598a:	83 ec 0c             	sub    $0xc,%esp
  80598d:	53                   	push   %ebx
  80598e:	e8 2a ff ff ff       	call   8058bd <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805993:	8b 43 10             	mov    0x10(%ebx),%eax
  805996:	83 c4 10             	add    $0x10,%esp
  805999:	83 f8 0a             	cmp    $0xa,%eax
  80599c:	74 6e                	je     805a0c <tcp_pcb_remove+0xd2>
  80599e:	83 f8 01             	cmp    $0x1,%eax
  8059a1:	74 69                	je     805a0c <tcp_pcb_remove+0xd2>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8059a3:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
     pcb->state != LISTEN &&
  8059a7:	a8 01                	test   $0x1,%al
  8059a9:	75 4f                	jne    8059fa <tcp_pcb_remove+0xc0>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  8059ab:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8059af:	75 63                	jne    805a14 <tcp_pcb_remove+0xda>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  8059b1:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8059b5:	75 74                	jne    805a2b <tcp_pcb_remove+0xf1>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8059b7:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8059bb:	0f 85 81 00 00 00    	jne    805a42 <tcp_pcb_remove+0x108>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8059c1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8059c8:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8059cb:	5b                   	pop    %ebx
  8059cc:	5e                   	pop    %esi
  8059cd:	5f                   	pop    %edi
  8059ce:	5d                   	pop    %ebp
  8059cf:	c3                   	ret    
  8059d0:	89 f3                	mov    %esi,%ebx
  8059d2:	89 f8                	mov    %edi,%eax
  8059d4:	84 c0                	test   %al,%al
  8059d6:	74 06                	je     8059de <tcp_pcb_remove+0xa4>
  8059d8:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(pcblist, pcb);
  8059de:	8b 43 0c             	mov    0xc(%ebx),%eax
  8059e1:	89 42 0c             	mov    %eax,0xc(%edx)
  8059e4:	eb 9d                	jmp    805983 <tcp_pcb_remove+0x49>
  8059e6:	89 f3                	mov    %esi,%ebx
  8059e8:	89 f8                	mov    %edi,%eax
  8059ea:	84 c0                	test   %al,%al
  8059ec:	74 95                	je     805983 <tcp_pcb_remove+0x49>
  8059ee:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8059f5:	00 00 00 
  8059f8:	eb 89                	jmp    805983 <tcp_pcb_remove+0x49>
    pcb->flags |= TF_ACK_NOW;
  8059fa:	83 c8 02             	or     $0x2,%eax
  8059fd:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  805a00:	83 ec 0c             	sub    $0xc,%esp
  805a03:	53                   	push   %ebx
  805a04:	e8 bc 26 00 00       	call   8080c5 <tcp_output>
  805a09:	83 c4 10             	add    $0x10,%esp
  if (pcb->state != LISTEN) {
  805a0c:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  805a10:	74 af                	je     8059c1 <tcp_pcb_remove+0x87>
  805a12:	eb 97                	jmp    8059ab <tcp_pcb_remove+0x71>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  805a14:	83 ec 04             	sub    $0x4,%esp
  805a17:	68 22 23 81 00       	push   $0x812322
  805a1c:	68 b4 04 00 00       	push   $0x4b4
  805a21:	68 0e 23 81 00       	push   $0x81230e
  805a26:	e8 6e 8c 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  805a2b:	83 ec 04             	sub    $0x4,%esp
  805a2e:	68 3a 23 81 00       	push   $0x81233a
  805a33:	68 b5 04 00 00       	push   $0x4b5
  805a38:	68 0e 23 81 00       	push   $0x81230e
  805a3d:	e8 57 8c 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  805a42:	83 ec 04             	sub    $0x4,%esp
  805a45:	68 53 23 81 00       	push   $0x812353
  805a4a:	68 b7 04 00 00       	push   $0x4b7
  805a4f:	68 0e 23 81 00       	push   $0x81230e
  805a54:	e8 40 8c 00 00       	call   80e699 <_panic>

00805a59 <tcp_close>:
{
  805a59:	55                   	push   %ebp
  805a5a:	89 e5                	mov    %esp,%ebp
  805a5c:	57                   	push   %edi
  805a5d:	56                   	push   %esi
  805a5e:	53                   	push   %ebx
  805a5f:	83 ec 0c             	sub    $0xc,%esp
  805a62:	8b 5d 08             	mov    0x8(%ebp),%ebx
  switch (pcb->state) {
  805a65:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  805a69:	0f 87 3e 01 00 00    	ja     805bad <tcp_close+0x154>
  805a6f:	8b 43 10             	mov    0x10(%ebx),%eax
  805a72:	ff 24 85 6c 23 81 00 	jmp    *0x81236c(,%eax,4)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805a79:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  805a7f:	39 da                	cmp    %ebx,%edx
  805a81:	74 2b                	je     805aae <tcp_close+0x55>
  805a83:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  805a89:	bf 00 00 00 00       	mov    $0x0,%edi
  805a8e:	89 de                	mov    %ebx,%esi
  805a90:	85 d2                	test   %edx,%edx
  805a92:	74 57                	je     805aeb <tcp_close+0x92>
  805a94:	8b 42 0c             	mov    0xc(%edx),%eax
  805a97:	39 f0                	cmp    %esi,%eax
  805a99:	0f 94 c3             	sete   %bl
  805a9c:	85 c0                	test   %eax,%eax
  805a9e:	0f 95 c1             	setne  %cl
  805aa1:	84 cb                	test   %cl,%bl
  805aa3:	75 30                	jne    805ad5 <tcp_close+0x7c>
  805aa5:	bf 01 00 00 00       	mov    $0x1,%edi
  805aaa:	89 c2                	mov    %eax,%edx
  805aac:	eb e2                	jmp    805a90 <tcp_close+0x37>
  805aae:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ab1:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  805ab6:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  805abd:	83 ec 08             	sub    $0x8,%esp
  805ac0:	53                   	push   %ebx
  805ac1:	6a 02                	push   $0x2
  805ac3:	e8 75 ea ff ff       	call   80453d <memp_free>
    break;
  805ac8:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805acb:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805ad0:	e9 9a 00 00 00       	jmp    805b6f <tcp_close+0x116>
  805ad5:	89 f3                	mov    %esi,%ebx
  805ad7:	89 f8                	mov    %edi,%eax
  805ad9:	84 c0                	test   %al,%al
  805adb:	74 06                	je     805ae3 <tcp_close+0x8a>
  805add:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
    TCP_RMV(&tcp_bound_pcbs, pcb);
  805ae3:	8b 43 0c             	mov    0xc(%ebx),%eax
  805ae6:	89 42 0c             	mov    %eax,0xc(%edx)
  805ae9:	eb cb                	jmp    805ab6 <tcp_close+0x5d>
  805aeb:	89 f3                	mov    %esi,%ebx
  805aed:	89 f8                	mov    %edi,%eax
  805aef:	84 c0                	test   %al,%al
  805af1:	74 c3                	je     805ab6 <tcp_close+0x5d>
  805af3:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  805afa:	00 00 00 
  805afd:	eb b7                	jmp    805ab6 <tcp_close+0x5d>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  805aff:	83 ec 08             	sub    $0x8,%esp
  805b02:	53                   	push   %ebx
  805b03:	68 44 b2 b3 00       	push   $0xb3b244
  805b08:	e8 2d fe ff ff       	call   80593a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  805b0d:	83 c4 08             	add    $0x8,%esp
  805b10:	53                   	push   %ebx
  805b11:	6a 03                	push   $0x3
  805b13:	e8 25 ea ff ff       	call   80453d <memp_free>
    break;
  805b18:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b1b:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b20:	eb 4d                	jmp    805b6f <tcp_close+0x116>
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805b22:	83 ec 08             	sub    $0x8,%esp
  805b25:	53                   	push   %ebx
  805b26:	68 3c b2 b3 00       	push   $0xb3b23c
  805b2b:	e8 0a fe ff ff       	call   80593a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805b30:	83 c4 08             	add    $0x8,%esp
  805b33:	53                   	push   %ebx
  805b34:	6a 02                	push   $0x2
  805b36:	e8 02 ea ff ff       	call   80453d <memp_free>
    break;
  805b3b:	83 c4 10             	add    $0x10,%esp
    err = ERR_OK;
  805b3e:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  805b43:	eb 2a                	jmp    805b6f <tcp_close+0x116>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b45:	83 ec 08             	sub    $0x8,%esp
  805b48:	6a 01                	push   $0x1
  805b4a:	53                   	push   %ebx
  805b4b:	e8 ff 24 00 00       	call   80804f <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b50:	83 c4 10             	add    $0x10,%esp
  805b53:	84 c0                	test   %al,%al
  805b55:	75 18                	jne    805b6f <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805b57:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
    tcp_output(pcb);
  805b5e:	83 ec 0c             	sub    $0xc,%esp
  805b61:	53                   	push   %ebx
  805b62:	e8 5e 25 00 00       	call   8080c5 <tcp_output>
  805b67:	83 c4 10             	add    $0x10,%esp
  805b6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805b6f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805b72:	5b                   	pop    %ebx
  805b73:	5e                   	pop    %esi
  805b74:	5f                   	pop    %edi
  805b75:	5d                   	pop    %ebp
  805b76:	c3                   	ret    
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b77:	83 ec 08             	sub    $0x8,%esp
  805b7a:	6a 01                	push   $0x1
  805b7c:	53                   	push   %ebx
  805b7d:	e8 cd 24 00 00       	call   80804f <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b82:	83 c4 10             	add    $0x10,%esp
  805b85:	84 c0                	test   %al,%al
  805b87:	75 e6                	jne    805b6f <tcp_close+0x116>
      pcb->state = FIN_WAIT_1;
  805b89:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  805b90:	eb cc                	jmp    805b5e <tcp_close+0x105>
    err = tcp_send_ctrl(pcb, TCP_FIN);
  805b92:	83 ec 08             	sub    $0x8,%esp
  805b95:	6a 01                	push   $0x1
  805b97:	53                   	push   %ebx
  805b98:	e8 b2 24 00 00       	call   80804f <tcp_send_ctrl>
    if (err == ERR_OK) {
  805b9d:	83 c4 10             	add    $0x10,%esp
  805ba0:	84 c0                	test   %al,%al
  805ba2:	75 cb                	jne    805b6f <tcp_close+0x116>
      pcb->state = LAST_ACK;
  805ba4:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  805bab:	eb b1                	jmp    805b5e <tcp_close+0x105>
    err = ERR_OK;
  805bad:	b8 00 00 00 00       	mov    $0x0,%eax
  return err;
  805bb2:	eb bb                	jmp    805b6f <tcp_close+0x116>

00805bb4 <tcp_recv_null>:
{
  805bb4:	55                   	push   %ebp
  805bb5:	89 e5                	mov    %esp,%ebp
  805bb7:	83 ec 08             	sub    $0x8,%esp
  805bba:	8b 45 10             	mov    0x10(%ebp),%eax
  805bbd:	8b 55 14             	mov    0x14(%ebp),%edx
  if (p != NULL) {
  805bc0:	85 c0                	test   %eax,%eax
  805bc2:	74 13                	je     805bd7 <tcp_recv_null+0x23>
    pbuf_free(p);
  805bc4:	83 ec 0c             	sub    $0xc,%esp
  805bc7:	50                   	push   %eax
  805bc8:	e8 bd ec ff ff       	call   80488a <pbuf_free>
  805bcd:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  805bd0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805bd5:	c9                   	leave  
  805bd6:	c3                   	ret    
  return ERR_OK;
  805bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  } else if (err == ERR_OK) {
  805bdc:	84 d2                	test   %dl,%dl
  805bde:	75 f5                	jne    805bd5 <tcp_recv_null+0x21>
    return tcp_close(pcb);
  805be0:	83 ec 0c             	sub    $0xc,%esp
  805be3:	ff 75 0c             	pushl  0xc(%ebp)
  805be6:	e8 6e fe ff ff       	call   805a59 <tcp_close>
  805beb:	83 c4 10             	add    $0x10,%esp
  805bee:	eb e5                	jmp    805bd5 <tcp_recv_null+0x21>

00805bf0 <tcp_abort>:
{
  805bf0:	55                   	push   %ebp
  805bf1:	89 e5                	mov    %esp,%ebp
  805bf3:	57                   	push   %edi
  805bf4:	56                   	push   %esi
  805bf5:	53                   	push   %ebx
  805bf6:	83 ec 2c             	sub    $0x2c,%esp
  805bf9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state == TIME_WAIT) {
  805bfc:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  805c00:	0f 84 c2 00 00 00    	je     805cc8 <tcp_abort+0xd8>
    seqno = pcb->snd_nxt;
  805c06:	8b 43 54             	mov    0x54(%ebx),%eax
  805c09:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  805c0c:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  805c0f:	8b 03                	mov    (%ebx),%eax
  805c11:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  805c14:	8b 43 04             	mov    0x4(%ebx),%eax
  805c17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  805c1a:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c1e:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  805c22:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  805c26:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
    errf = pcb->errf;
  805c2a:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
    errf_arg = pcb->callback_arg;
  805c30:	8b 43 18             	mov    0x18(%ebx),%eax
  805c33:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  805c36:	83 ec 08             	sub    $0x8,%esp
  805c39:	53                   	push   %ebx
  805c3a:	68 3c b2 b3 00       	push   $0xb3b23c
  805c3f:	e8 f6 fc ff ff       	call   80593a <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  805c44:	8b 43 78             	mov    0x78(%ebx),%eax
  805c47:	83 c4 10             	add    $0x10,%esp
  805c4a:	85 c0                	test   %eax,%eax
  805c4c:	74 0c                	je     805c5a <tcp_abort+0x6a>
      tcp_segs_free(pcb->unacked);
  805c4e:	83 ec 0c             	sub    $0xc,%esp
  805c51:	50                   	push   %eax
  805c52:	e8 8a fb ff ff       	call   8057e1 <tcp_segs_free>
  805c57:	83 c4 10             	add    $0x10,%esp
    if (pcb->unsent != NULL) {
  805c5a:	8b 43 74             	mov    0x74(%ebx),%eax
  805c5d:	85 c0                	test   %eax,%eax
  805c5f:	74 0c                	je     805c6d <tcp_abort+0x7d>
      tcp_segs_free(pcb->unsent);
  805c61:	83 ec 0c             	sub    $0xc,%esp
  805c64:	50                   	push   %eax
  805c65:	e8 77 fb ff ff       	call   8057e1 <tcp_segs_free>
  805c6a:	83 c4 10             	add    $0x10,%esp
    if (pcb->ooseq != NULL) {
  805c6d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805c70:	85 c0                	test   %eax,%eax
  805c72:	74 0c                	je     805c80 <tcp_abort+0x90>
      tcp_segs_free(pcb->ooseq);
  805c74:	83 ec 0c             	sub    $0xc,%esp
  805c77:	50                   	push   %eax
  805c78:	e8 64 fb ff ff       	call   8057e1 <tcp_segs_free>
  805c7d:	83 c4 10             	add    $0x10,%esp
    memp_free(MEMP_TCP_PCB, pcb);
  805c80:	83 ec 08             	sub    $0x8,%esp
  805c83:	53                   	push   %ebx
  805c84:	6a 02                	push   $0x2
  805c86:	e8 b2 e8 ff ff       	call   80453d <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  805c8b:	83 c4 10             	add    $0x10,%esp
  805c8e:	85 f6                	test   %esi,%esi
  805c90:	74 0d                	je     805c9f <tcp_abort+0xaf>
  805c92:	83 ec 08             	sub    $0x8,%esp
  805c95:	6a fb                	push   $0xfffffffb
  805c97:	ff 75 cc             	pushl  -0x34(%ebp)
  805c9a:	ff d6                	call   *%esi
  805c9c:	83 c4 10             	add    $0x10,%esp
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  805c9f:	83 ec 08             	sub    $0x8,%esp
  805ca2:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  805ca6:	50                   	push   %eax
  805ca7:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  805cab:	50                   	push   %eax
  805cac:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805caf:	50                   	push   %eax
  805cb0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805cb3:	50                   	push   %eax
  805cb4:	57                   	push   %edi
  805cb5:	ff 75 d4             	pushl  -0x2c(%ebp)
  805cb8:	e8 a8 28 00 00       	call   808565 <tcp_rst>
  805cbd:	83 c4 20             	add    $0x20,%esp
}
  805cc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  805cc3:	5b                   	pop    %ebx
  805cc4:	5e                   	pop    %esi
  805cc5:	5f                   	pop    %edi
  805cc6:	5d                   	pop    %ebp
  805cc7:	c3                   	ret    
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  805cc8:	83 ec 08             	sub    $0x8,%esp
  805ccb:	53                   	push   %ebx
  805ccc:	68 50 b2 b3 00       	push   $0xb3b250
  805cd1:	e8 64 fc ff ff       	call   80593a <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  805cd6:	83 c4 08             	add    $0x8,%esp
  805cd9:	53                   	push   %ebx
  805cda:	6a 02                	push   $0x2
  805cdc:	e8 5c e8 ff ff       	call   80453d <memp_free>
  805ce1:	83 c4 10             	add    $0x10,%esp
  805ce4:	eb da                	jmp    805cc0 <tcp_abort+0xd0>

00805ce6 <tcp_slowtmr>:
{
  805ce6:	55                   	push   %ebp
  805ce7:	89 e5                	mov    %esp,%ebp
  805ce9:	57                   	push   %edi
  805cea:	56                   	push   %esi
  805ceb:	53                   	push   %ebx
  805cec:	83 ec 1c             	sub    $0x1c,%esp
  ++tcp_ticks;
  805cef:	83 05 40 b2 b3 00 01 	addl   $0x1,0xb3b240
  pcb = tcp_active_pcbs;
  805cf6:	8b 1d 3c b2 b3 00    	mov    0xb3b23c,%ebx
  err = ERR_OK;
  805cfc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  prev = NULL;
  805d00:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  805d07:	e9 2a 02 00 00       	jmp    805f36 <tcp_slowtmr+0x250>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805d0c:	83 ec 04             	sub    $0x4,%esp
  805d0f:	68 7c 21 81 00       	push   $0x81217c
  805d14:	68 36 02 00 00       	push   $0x236
  805d19:	68 0e 23 81 00       	push   $0x81230e
  805d1e:	e8 76 89 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805d23:	83 ec 04             	sub    $0x4,%esp
  805d26:	68 a8 21 81 00       	push   $0x8121a8
  805d2b:	68 37 02 00 00       	push   $0x237
  805d30:	68 0e 23 81 00       	push   $0x81230e
  805d35:	e8 5f 89 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805d3a:	83 ec 04             	sub    $0x4,%esp
  805d3d:	68 d4 21 81 00       	push   $0x8121d4
  805d42:	68 38 02 00 00       	push   $0x238
  805d47:	68 0e 23 81 00       	push   $0x81230e
  805d4c:	e8 48 89 00 00       	call   80e699 <_panic>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805d51:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  805d55:	80 fa 06             	cmp    $0x6,%dl
  805d58:	0f 84 d0 00 00 00    	je     805e2e <tcp_slowtmr+0x148>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805d5e:	80 fa 0c             	cmp    $0xc,%dl
  805d61:	0f 85 0b 02 00 00    	jne    805f72 <tcp_slowtmr+0x28c>
  805d67:	be 01 00 00 00       	mov    $0x1,%esi
  805d6c:	e9 c2 00 00 00       	jmp    805e33 <tcp_slowtmr+0x14d>
        if(pcb->rtime >= 0)
  805d71:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  805d75:	66 85 c9             	test   %cx,%cx
  805d78:	78 07                	js     805d81 <tcp_slowtmr+0x9b>
          ++pcb->rtime;
  805d7a:	83 c1 01             	add    $0x1,%ecx
  805d7d:	66 89 4b 32          	mov    %cx,0x32(%ebx)
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  805d81:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  805d85:	0f 84 45 02 00 00    	je     805fd0 <tcp_slowtmr+0x2ea>
  805d8b:	0f b7 7b 44          	movzwl 0x44(%ebx),%edi
  805d8f:	66 39 7b 32          	cmp    %di,0x32(%ebx)
  805d93:	0f 8c 37 02 00 00    	jl     805fd0 <tcp_slowtmr+0x2ea>
          if (pcb->state != SYN_SENT) {
  805d99:	83 f8 02             	cmp    $0x2,%eax
  805d9c:	74 1f                	je     805dbd <tcp_slowtmr+0xd7>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  805d9e:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  805da2:	66 c1 f8 03          	sar    $0x3,%ax
  805da6:	98                   	cwtl   
  805da7:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  805dab:	01 c8                	add    %ecx,%eax
  805dad:	0f b6 d2             	movzbl %dl,%edx
  805db0:	0f b6 8a 94 23 81 00 	movzbl 0x812394(%edx),%ecx
  805db7:	d3 e0                	shl    %cl,%eax
  805db9:	66 89 43 44          	mov    %ax,0x44(%ebx)
          pcb->rtime = 0;
  805dbd:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  805dc3:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  805dc7:	66 39 43 5c          	cmp    %ax,0x5c(%ebx)
  805dcb:	66 0f 46 43 5c       	cmovbe 0x5c(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  805dd0:	66 d1 e8             	shr    %ax
          if (pcb->ssthresh < pcb->mss) {
  805dd3:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
            pcb->ssthresh = pcb->mss * 2;
  805dd7:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  805dda:	66 39 d0             	cmp    %dx,%ax
  805ddd:	0f 42 c1             	cmovb  %ecx,%eax
  805de0:	66 89 43 50          	mov    %ax,0x50(%ebx)
          pcb->cwnd = pcb->mss;
  805de4:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
          tcp_rexmit_rto(pcb);
  805de8:	83 ec 0c             	sub    $0xc,%esp
  805deb:	53                   	push   %ebx
  805dec:	e8 9d 28 00 00       	call   80868e <tcp_rexmit_rto>
  805df1:	83 c4 10             	add    $0x10,%esp
  805df4:	e9 d7 01 00 00       	jmp    805fd0 <tcp_slowtmr+0x2ea>
    pcb_remove = 0;
  805df9:	be 00 00 00 00       	mov    $0x0,%esi
  805dfe:	e9 cd 01 00 00       	jmp    805fd0 <tcp_slowtmr+0x2ea>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805e03:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e08:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  805e0b:	83 f8 29             	cmp    $0x29,%eax
  805e0e:	89 f0                	mov    %esi,%eax
  805e10:	1c ff                	sbb    $0xff,%al
  805e12:	89 c6                	mov    %eax,%esi
    if (pcb->ooseq != NULL &&
  805e14:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e17:	85 c9                	test   %ecx,%ecx
  805e19:	75 1f                	jne    805e3a <tcp_slowtmr+0x154>
  805e1b:	e9 d0 00 00 00       	jmp    805ef0 <tcp_slowtmr+0x20a>
        tcp_abort(pcb);
  805e20:	83 ec 0c             	sub    $0xc,%esp
  805e23:	53                   	push   %ebx
  805e24:	e8 c7 fd ff ff       	call   805bf0 <tcp_abort>
  805e29:	83 c4 10             	add    $0x10,%esp
  805e2c:	eb 05                	jmp    805e33 <tcp_slowtmr+0x14d>
  805e2e:	be 01 00 00 00       	mov    $0x1,%esi
    if (pcb->ooseq != NULL &&
  805e33:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  805e36:	85 c9                	test   %ecx,%ecx
  805e38:	74 16                	je     805e50 <tcp_slowtmr+0x16a>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  805e3a:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  805e40:	2b 53 2c             	sub    0x2c(%ebx),%edx
  805e43:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  805e47:	8d 04 40             	lea    (%eax,%eax,2),%eax
  805e4a:	01 c0                	add    %eax,%eax
    if (pcb->ooseq != NULL &&
  805e4c:	39 c2                	cmp    %eax,%edx
  805e4e:	73 7b                	jae    805ecb <tcp_slowtmr+0x1e5>
    if (pcb->state == SYN_RCVD) {
  805e50:	8b 43 10             	mov    0x10(%ebx),%eax
  805e53:	83 f8 03             	cmp    $0x3,%eax
  805e56:	0f 84 87 00 00 00    	je     805ee3 <tcp_slowtmr+0x1fd>
    if (pcb->state == LAST_ACK) {
  805e5c:	83 f8 09             	cmp    $0x9,%eax
  805e5f:	0f 85 8b 00 00 00    	jne    805ef0 <tcp_slowtmr+0x20a>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  805e65:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805e6a:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805e6d:	3d f0 00 00 00       	cmp    $0xf0,%eax
  805e72:	76 7c                	jbe    805ef0 <tcp_slowtmr+0x20a>
      tcp_pcb_purge(pcb);      
  805e74:	83 ec 0c             	sub    $0xc,%esp
  805e77:	53                   	push   %ebx
  805e78:	e8 40 fa ff ff       	call   8058bd <tcp_pcb_purge>
      if (prev != NULL) {
  805e7d:	83 c4 10             	add    $0x10,%esp
  805e80:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  805e84:	0f 84 e1 01 00 00    	je     80606b <tcp_slowtmr+0x385>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  805e8a:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  805e90:	0f 84 be 01 00 00    	je     806054 <tcp_slowtmr+0x36e>
        prev->next = pcb->next;
  805e96:	8b 43 0c             	mov    0xc(%ebx),%eax
  805e99:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  805e9c:	89 47 0c             	mov    %eax,0xc(%edi)
      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  805e9f:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  805ea5:	85 c0                	test   %eax,%eax
  805ea7:	74 0d                	je     805eb6 <tcp_slowtmr+0x1d0>
  805ea9:	83 ec 08             	sub    $0x8,%esp
  805eac:	6a fb                	push   $0xfffffffb
  805eae:	ff 73 18             	pushl  0x18(%ebx)
  805eb1:	ff d0                	call   *%eax
  805eb3:	83 c4 10             	add    $0x10,%esp
      pcb2 = pcb->next;
  805eb6:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  805eb9:	83 ec 08             	sub    $0x8,%esp
  805ebc:	53                   	push   %ebx
  805ebd:	6a 02                	push   $0x2
  805ebf:	e8 79 e6 ff ff       	call   80453d <memp_free>
  805ec4:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  805ec7:	89 f3                	mov    %esi,%ebx
  805ec9:	eb 6b                	jmp    805f36 <tcp_slowtmr+0x250>
      tcp_segs_free(pcb->ooseq);
  805ecb:	83 ec 0c             	sub    $0xc,%esp
  805ece:	51                   	push   %ecx
  805ecf:	e8 0d f9 ff ff       	call   8057e1 <tcp_segs_free>
      pcb->ooseq = NULL;
  805ed4:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
  805edb:	83 c4 10             	add    $0x10,%esp
  805ede:	e9 6d ff ff ff       	jmp    805e50 <tcp_slowtmr+0x16a>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  805ee3:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  805ee8:	2b 43 2c             	sub    0x2c(%ebx),%eax
  805eeb:	83 f8 28             	cmp    $0x28,%eax
  805eee:	77 84                	ja     805e74 <tcp_slowtmr+0x18e>
    if (pcb_remove) {
  805ef0:	89 f0                	mov    %esi,%eax
  805ef2:	84 c0                	test   %al,%al
  805ef4:	0f 85 7a ff ff ff    	jne    805e74 <tcp_slowtmr+0x18e>
      ++pcb->polltmr;
  805efa:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  805efe:	83 c0 01             	add    $0x1,%eax
  805f01:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  805f04:	3a 43 31             	cmp    0x31(%ebx),%al
  805f07:	72 27                	jb     805f30 <tcp_slowtmr+0x24a>
        pcb->polltmr = 0;
  805f09:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        TCP_EVENT_POLL(pcb, err);
  805f0d:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  805f13:	85 c0                	test   %eax,%eax
  805f15:	74 0f                	je     805f26 <tcp_slowtmr+0x240>
  805f17:	83 ec 08             	sub    $0x8,%esp
  805f1a:	53                   	push   %ebx
  805f1b:	ff 73 18             	pushl  0x18(%ebx)
  805f1e:	ff d0                	call   *%eax
  805f20:	88 45 e3             	mov    %al,-0x1d(%ebp)
  805f23:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  805f26:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  805f2a:	0f 84 67 01 00 00    	je     806097 <tcp_slowtmr+0x3b1>
      prev = pcb;
  805f30:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
      pcb = pcb->next;
  805f33:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while (pcb != NULL) {
  805f36:	85 db                	test   %ebx,%ebx
  805f38:	0f 84 6a 01 00 00    	je     8060a8 <tcp_slowtmr+0x3c2>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  805f3e:	8b 43 10             	mov    0x10(%ebx),%eax
  805f41:	85 c0                	test   %eax,%eax
  805f43:	0f 84 c3 fd ff ff    	je     805d0c <tcp_slowtmr+0x26>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  805f49:	83 f8 01             	cmp    $0x1,%eax
  805f4c:	0f 84 d1 fd ff ff    	je     805d23 <tcp_slowtmr+0x3d>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  805f52:	83 f8 0a             	cmp    $0xa,%eax
  805f55:	0f 84 df fd ff ff    	je     805d3a <tcp_slowtmr+0x54>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  805f5b:	83 f8 02             	cmp    $0x2,%eax
  805f5e:	0f 84 ed fd ff ff    	je     805d51 <tcp_slowtmr+0x6b>
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f64:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  805f68:	be 01 00 00 00       	mov    $0x1,%esi
    else if (pcb->nrtx == TCP_MAXRTX) {
  805f6d:	80 fa 0c             	cmp    $0xc,%dl
  805f70:	74 5e                	je     805fd0 <tcp_slowtmr+0x2ea>
      if (pcb->persist_backoff > 0) {
  805f72:	0f b6 b3 a4 00 00 00 	movzbl 0xa4(%ebx),%esi
  805f79:	89 f1                	mov    %esi,%ecx
  805f7b:	84 c9                	test   %cl,%cl
  805f7d:	0f 84 ee fd ff ff    	je     805d71 <tcp_slowtmr+0x8b>
        pcb->persist_cnt++;
  805f83:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  805f89:	83 c0 01             	add    $0x1,%eax
  805f8c:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  805f92:	0f b6 d1             	movzbl %cl,%edx
  805f95:	bf 8c 23 81 00       	mov    $0x81238c,%edi
  805f9a:	0f b6 54 17 ff       	movzbl -0x1(%edi,%edx,1),%edx
  805f9f:	39 d0                	cmp    %edx,%eax
  805fa1:	0f 82 52 fe ff ff    	jb     805df9 <tcp_slowtmr+0x113>
          pcb->persist_cnt = 0;
  805fa7:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  805fae:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  805fb1:	80 f9 06             	cmp    $0x6,%cl
  805fb4:	77 09                	ja     805fbf <tcp_slowtmr+0x2d9>
            pcb->persist_backoff++;
  805fb6:	8d 46 01             	lea    0x1(%esi),%eax
  805fb9:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          tcp_zero_window_probe(pcb);
  805fbf:	83 ec 0c             	sub    $0xc,%esp
  805fc2:	53                   	push   %ebx
  805fc3:	e8 92 28 00 00       	call   80885a <tcp_zero_window_probe>
  805fc8:	83 c4 10             	add    $0x10,%esp
    pcb_remove = 0;
  805fcb:	be 00 00 00 00       	mov    $0x0,%esi
    if (pcb->state == FIN_WAIT_2) {
  805fd0:	8b 43 10             	mov    0x10(%ebx),%eax
  805fd3:	83 f8 06             	cmp    $0x6,%eax
  805fd6:	0f 84 27 fe ff ff    	je     805e03 <tcp_slowtmr+0x11d>
    if((pcb->so_options & SOF_KEEPALIVE) && 
  805fdc:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  805fe0:	0f 84 4d fe ff ff    	je     805e33 <tcp_slowtmr+0x14d>
  805fe6:	83 f8 04             	cmp    $0x4,%eax
  805fe9:	74 09                	je     805ff4 <tcp_slowtmr+0x30e>
  805feb:	83 f8 07             	cmp    $0x7,%eax
  805fee:	0f 85 3f fe ff ff    	jne    805e33 <tcp_slowtmr+0x14d>
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  805ff4:	8b 0d 40 b2 b3 00    	mov    0xb3b240,%ecx
  805ffa:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  805ffd:	8b bb 9c 00 00 00    	mov    0x9c(%ebx),%edi
  806003:	8d 97 b8 4c 0a 00    	lea    0xa4cb8(%edi),%edx
  806009:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80600e:	f7 e2                	mul    %edx
  806010:	c1 ea 05             	shr    $0x5,%edx
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806013:	39 d1                	cmp    %edx,%ecx
  806015:	0f 87 05 fe ff ff    	ja     805e20 <tcp_slowtmr+0x13a>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80601b:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  806022:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  806028:	01 fa                	add    %edi,%edx
              / TCP_SLOW_INTERVAL)
  80602a:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80602f:	f7 e2                	mul    %edx
  806031:	c1 ea 05             	shr    $0x5,%edx
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  806034:	39 d1                	cmp    %edx,%ecx
  806036:	0f 86 f7 fd ff ff    	jbe    805e33 <tcp_slowtmr+0x14d>
        tcp_keepalive(pcb);
  80603c:	83 ec 0c             	sub    $0xc,%esp
  80603f:	53                   	push   %ebx
  806040:	e8 ef 26 00 00       	call   808734 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  806045:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)
  80604c:	83 c4 10             	add    $0x10,%esp
  80604f:	e9 df fd ff ff       	jmp    805e33 <tcp_slowtmr+0x14d>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  806054:	83 ec 04             	sub    $0x4,%esp
  806057:	68 04 22 81 00       	push   $0x812204
  80605c:	68 c1 02 00 00       	push   $0x2c1
  806061:	68 0e 23 81 00       	push   $0x81230e
  806066:	e8 2e 86 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80606b:	3b 1d 3c b2 b3 00    	cmp    0xb3b23c,%ebx
  806071:	75 0d                	jne    806080 <tcp_slowtmr+0x39a>
        tcp_active_pcbs = pcb->next;
  806073:	8b 43 0c             	mov    0xc(%ebx),%eax
  806076:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
  80607b:	e9 1f fe ff ff       	jmp    805e9f <tcp_slowtmr+0x1b9>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  806080:	83 ec 04             	sub    $0x4,%esp
  806083:	68 30 22 81 00       	push   $0x812230
  806088:	68 c5 02 00 00       	push   $0x2c5
  80608d:	68 0e 23 81 00       	push   $0x81230e
  806092:	e8 02 86 00 00       	call   80e699 <_panic>
          tcp_output(pcb);
  806097:	83 ec 0c             	sub    $0xc,%esp
  80609a:	53                   	push   %ebx
  80609b:	e8 25 20 00 00       	call   8080c5 <tcp_output>
  8060a0:	83 c4 10             	add    $0x10,%esp
  8060a3:	e9 88 fe ff ff       	jmp    805f30 <tcp_slowtmr+0x24a>
  pcb = tcp_tw_pcbs;
  8060a8:	8b 35 50 b2 b3 00    	mov    0xb3b250,%esi
  while (pcb != NULL) {
  8060ae:	eb 48                	jmp    8060f8 <tcp_slowtmr+0x412>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8060b0:	83 ec 04             	sub    $0x4,%esp
  8060b3:	68 5c 22 81 00       	push   $0x81225c
  8060b8:	68 e5 02 00 00       	push   $0x2e5
  8060bd:	68 0e 23 81 00       	push   $0x81230e
  8060c2:	e8 d2 85 00 00       	call   80e699 <_panic>
      tcp_pcb_purge(pcb);      
  8060c7:	83 ec 0c             	sub    $0xc,%esp
  8060ca:	56                   	push   %esi
  8060cb:	e8 ed f7 ff ff       	call   8058bd <tcp_pcb_purge>
      if (prev != NULL) {
  8060d0:	83 c4 10             	add    $0x10,%esp
  8060d3:	85 db                	test   %ebx,%ebx
  8060d5:	74 58                	je     80612f <tcp_slowtmr+0x449>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8060d7:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  8060dd:	74 39                	je     806118 <tcp_slowtmr+0x432>
        prev->next = pcb->next;
  8060df:	8b 46 0c             	mov    0xc(%esi),%eax
  8060e2:	89 43 0c             	mov    %eax,0xc(%ebx)
      pcb2 = pcb->next;
  8060e5:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  8060e8:	83 ec 08             	sub    $0x8,%esp
  8060eb:	56                   	push   %esi
  8060ec:	6a 02                	push   $0x2
  8060ee:	e8 4a e4 ff ff       	call   80453d <memp_free>
  8060f3:	83 c4 10             	add    $0x10,%esp
      pcb = pcb2;
  8060f6:	89 fe                	mov    %edi,%esi
  while (pcb != NULL) {
  8060f8:	85 f6                	test   %esi,%esi
  8060fa:	74 5c                	je     806158 <tcp_slowtmr+0x472>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8060fc:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806100:	75 ae                	jne    8060b0 <tcp_slowtmr+0x3ca>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806102:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  806107:	2b 46 2c             	sub    0x2c(%esi),%eax
  80610a:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80610f:	77 b6                	ja     8060c7 <tcp_slowtmr+0x3e1>
      prev = pcb;
  806111:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  806113:	8b 76 0c             	mov    0xc(%esi),%esi
  806116:	eb e0                	jmp    8060f8 <tcp_slowtmr+0x412>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  806118:	83 ec 04             	sub    $0x4,%esp
  80611b:	68 8c 22 81 00       	push   $0x81228c
  806120:	68 f4 02 00 00       	push   $0x2f4
  806125:	68 0e 23 81 00       	push   $0x81230e
  80612a:	e8 6a 85 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80612f:	3b 35 50 b2 b3 00    	cmp    0xb3b250,%esi
  806135:	75 0a                	jne    806141 <tcp_slowtmr+0x45b>
        tcp_tw_pcbs = pcb->next;
  806137:	8b 46 0c             	mov    0xc(%esi),%eax
  80613a:	a3 50 b2 b3 00       	mov    %eax,0xb3b250
  80613f:	eb a4                	jmp    8060e5 <tcp_slowtmr+0x3ff>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  806141:	83 ec 04             	sub    $0x4,%esp
  806144:	68 b4 22 81 00       	push   $0x8122b4
  806149:	68 f8 02 00 00       	push   $0x2f8
  80614e:	68 0e 23 81 00       	push   $0x81230e
  806153:	e8 41 85 00 00       	call   80e699 <_panic>
}
  806158:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80615b:	5b                   	pop    %ebx
  80615c:	5e                   	pop    %esi
  80615d:	5f                   	pop    %edi
  80615e:	5d                   	pop    %ebp
  80615f:	c3                   	ret    

00806160 <tcp_tmr>:
{
  806160:	55                   	push   %ebp
  806161:	89 e5                	mov    %esp,%ebp
  806163:	83 ec 08             	sub    $0x8,%esp
  tcp_fasttmr();
  806166:	e8 c2 f5 ff ff       	call   80572d <tcp_fasttmr>
  if (++tcp_timer & 1) {
  80616b:	0f b6 05 f9 43 b3 00 	movzbl 0xb343f9,%eax
  806172:	83 c0 01             	add    $0x1,%eax
  806175:	a2 f9 43 b3 00       	mov    %al,0xb343f9
  80617a:	a8 01                	test   $0x1,%al
  80617c:	75 02                	jne    806180 <tcp_tmr+0x20>
}
  80617e:	c9                   	leave  
  80617f:	c3                   	ret    
    tcp_slowtmr();
  806180:	e8 61 fb ff ff       	call   805ce6 <tcp_slowtmr>
}
  806185:	eb f7                	jmp    80617e <tcp_tmr+0x1e>

00806187 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806187:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80618c:	03 05 08 40 81 00    	add    0x814008,%eax
  806192:	a3 08 40 81 00       	mov    %eax,0x814008
  return iss;
}
  806197:	c3                   	ret    

00806198 <tcp_alloc>:
{
  806198:	55                   	push   %ebp
  806199:	89 e5                	mov    %esp,%ebp
  80619b:	57                   	push   %edi
  80619c:	56                   	push   %esi
  80619d:	53                   	push   %ebx
  80619e:	83 ec 28             	sub    $0x28,%esp
  8061a1:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  pcb = memp_malloc(MEMP_TCP_PCB);
  8061a5:	6a 02                	push   $0x2
  8061a7:	e8 3b e3 ff ff       	call   8044e7 <memp_malloc>
  8061ac:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8061ae:	83 c4 10             	add    $0x10,%esp
  8061b1:	85 c0                	test   %eax,%eax
  8061b3:	0f 84 a0 00 00 00    	je     806259 <tcp_alloc+0xc1>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8061b9:	83 ec 04             	sub    $0x4,%esp
  8061bc:	68 a8 00 00 00       	push   $0xa8
  8061c1:	6a 00                	push   $0x0
  8061c3:	53                   	push   %ebx
  8061c4:	e8 6b 8e 00 00       	call   80f034 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  8061c9:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  8061cd:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8061d3:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8061d9:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8061df:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8061e5:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8061e9:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8061ed:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8061f3:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8061f9:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8061ff:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  806205:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  80620b:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  806211:	e8 71 ff ff ff       	call   806187 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  806216:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  806219:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80621c:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80621f:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  806222:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  806225:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80622a:	89 43 2c             	mov    %eax,0x2c(%ebx)
    pcb->polltmr = 0;
  80622d:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
    pcb->recv = tcp_recv_null;
  806231:	c7 83 88 00 00 00 b4 	movl   $0x805bb4,0x88(%ebx)
  806238:	5b 80 00 
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80623b:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  806242:	dd 6d 00 
    pcb->keep_cnt_sent = 0;
  806245:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  80624c:	83 c4 10             	add    $0x10,%esp
}
  80624f:	89 d8                	mov    %ebx,%eax
  806251:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806254:	5b                   	pop    %ebx
  806255:	5e                   	pop    %esi
  806256:	5f                   	pop    %edi
  806257:	5d                   	pop    %ebp
  806258:	c3                   	ret    
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  806259:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80625e:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  inactivity = 0;
  806264:	b9 00 00 00 00       	mov    $0x0,%ecx
  806269:	eb 03                	jmp    80626e <tcp_alloc+0xd6>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80626b:	8b 40 0c             	mov    0xc(%eax),%eax
  80626e:	85 c0                	test   %eax,%eax
  806270:	74 0f                	je     806281 <tcp_alloc+0xe9>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806272:	89 fa                	mov    %edi,%edx
  806274:	2b 50 2c             	sub    0x2c(%eax),%edx
  806277:	39 ca                	cmp    %ecx,%edx
  806279:	72 f0                	jb     80626b <tcp_alloc+0xd3>
      inactivity = tcp_ticks - pcb->tmr;
  80627b:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  80627d:	89 c3                	mov    %eax,%ebx
  80627f:	eb ea                	jmp    80626b <tcp_alloc+0xd3>
  if (inactive != NULL) {
  806281:	85 db                	test   %ebx,%ebx
  806283:	74 0c                	je     806291 <tcp_alloc+0xf9>
    tcp_abort(inactive);
  806285:	83 ec 0c             	sub    $0xc,%esp
  806288:	53                   	push   %ebx
  806289:	e8 62 f9 ff ff       	call   805bf0 <tcp_abort>
  80628e:	83 c4 10             	add    $0x10,%esp
    pcb = memp_malloc(MEMP_TCP_PCB);
  806291:	83 ec 0c             	sub    $0xc,%esp
  806294:	6a 02                	push   $0x2
  806296:	e8 4c e2 ff ff       	call   8044e7 <memp_malloc>
  80629b:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  80629d:	83 c4 10             	add    $0x10,%esp
  8062a0:	85 c0                	test   %eax,%eax
  8062a2:	0f 85 11 ff ff ff    	jne    8061b9 <tcp_alloc+0x21>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8062a8:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062ad:	8b 3d 40 b2 b3 00    	mov    0xb3b240,%edi
  8062b3:	89 7d dc             	mov    %edi,-0x24(%ebp)
  mprio = TCP_PRIO_MAX;
  8062b6:	ba 7f 00 00 00       	mov    $0x7f,%edx
  inactivity = 0;
  8062bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8062c2:	89 df                	mov    %ebx,%edi
  8062c4:	89 f1                	mov    %esi,%ecx
  8062c6:	88 4d e7             	mov    %cl,-0x19(%ebp)
  8062c9:	eb 03                	jmp    8062ce <tcp_alloc+0x136>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8062cb:	8b 40 0c             	mov    0xc(%eax),%eax
  8062ce:	85 c0                	test   %eax,%eax
  8062d0:	74 29                	je     8062fb <tcp_alloc+0x163>
    if (pcb->prio <= prio &&
  8062d2:	0f b6 48 14          	movzbl 0x14(%eax),%ecx
  8062d6:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  8062da:	38 d3                	cmp    %dl,%bl
  8062dc:	89 d6                	mov    %edx,%esi
  8062de:	0f 46 f3             	cmovbe %ebx,%esi
  8062e1:	89 f3                	mov    %esi,%ebx
  8062e3:	38 cb                	cmp    %cl,%bl
  8062e5:	72 e4                	jb     8062cb <tcp_alloc+0x133>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8062e7:	8b 75 dc             	mov    -0x24(%ebp),%esi
  8062ea:	2b 70 2c             	sub    0x2c(%eax),%esi
       pcb->prio <= mprio &&
  8062ed:	3b 75 e0             	cmp    -0x20(%ebp),%esi
  8062f0:	72 d9                	jb     8062cb <tcp_alloc+0x133>
      mprio = pcb->prio;
  8062f2:	89 ca                	mov    %ecx,%edx
      inactivity = tcp_ticks - pcb->tmr;
  8062f4:	89 75 e0             	mov    %esi,-0x20(%ebp)
      inactive = pcb;
  8062f7:	89 c7                	mov    %eax,%edi
  8062f9:	eb d0                	jmp    8062cb <tcp_alloc+0x133>
  if (inactive != NULL) {
  8062fb:	85 ff                	test   %edi,%edi
  8062fd:	74 0c                	je     80630b <tcp_alloc+0x173>
    tcp_abort(inactive);
  8062ff:	83 ec 0c             	sub    $0xc,%esp
  806302:	57                   	push   %edi
  806303:	e8 e8 f8 ff ff       	call   805bf0 <tcp_abort>
  806308:	83 c4 10             	add    $0x10,%esp
      pcb = memp_malloc(MEMP_TCP_PCB);
  80630b:	83 ec 0c             	sub    $0xc,%esp
  80630e:	6a 02                	push   $0x2
  806310:	e8 d2 e1 ff ff       	call   8044e7 <memp_malloc>
  806315:	89 c3                	mov    %eax,%ebx
  if (pcb != NULL) {
  806317:	83 c4 10             	add    $0x10,%esp
  80631a:	85 c0                	test   %eax,%eax
  80631c:	0f 84 2d ff ff ff    	je     80624f <tcp_alloc+0xb7>
  806322:	e9 92 fe ff ff       	jmp    8061b9 <tcp_alloc+0x21>

00806327 <tcp_new>:
{
  806327:	55                   	push   %ebp
  806328:	89 e5                	mov    %esp,%ebp
  80632a:	83 ec 14             	sub    $0x14,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80632d:	6a 40                	push   $0x40
  80632f:	e8 64 fe ff ff       	call   806198 <tcp_alloc>
}
  806334:	c9                   	leave  
  806335:	c3                   	ret    

00806336 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806336:	55                   	push   %ebp
  806337:	89 e5                	mov    %esp,%ebp
  806339:	56                   	push   %esi
  80633a:	53                   	push   %ebx
  80633b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80633e:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806340:	83 ec 0c             	sub    $0xc,%esp
  806343:	ff 75 0c             	pushl  0xc(%ebp)
  806346:	e8 f9 01 00 00       	call   806544 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80634b:	83 c4 10             	add    $0x10,%esp
  80634e:	85 c0                	test   %eax,%eax
  806350:	74 14                	je     806366 <tcp_eff_send_mss+0x30>
  806352:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806356:	66 85 c0             	test   %ax,%ax
  806359:	74 0b                	je     806366 <tcp_eff_send_mss+0x30>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80635b:	83 e8 28             	sub    $0x28,%eax
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  80635e:	66 39 c3             	cmp    %ax,%bx
  806361:	0f 46 c3             	cmovbe %ebx,%eax
  806364:	89 c6                	mov    %eax,%esi
  }
  return sendmss;
}
  806366:	89 f0                	mov    %esi,%eax
  806368:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80636b:	5b                   	pop    %ebx
  80636c:	5e                   	pop    %esi
  80636d:	5d                   	pop    %ebp
  80636e:	c3                   	ret    

0080636f <tcp_connect>:
{
  80636f:	55                   	push   %ebp
  806370:	89 e5                	mov    %esp,%ebp
  806372:	57                   	push   %edi
  806373:	56                   	push   %esi
  806374:	53                   	push   %ebx
  806375:	83 ec 1c             	sub    $0x1c,%esp
  806378:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80637b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80637e:	8b 45 10             	mov    0x10(%ebp),%eax
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806381:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806385:	0f 85 bd 00 00 00    	jne    806448 <tcp_connect+0xd9>
  if (ipaddr != NULL) {
  80638b:	85 f6                	test   %esi,%esi
  80638d:	0f 84 67 01 00 00    	je     8064fa <tcp_connect+0x18b>
    pcb->remote_ip = *ipaddr;
  806393:	8b 16                	mov    (%esi),%edx
  806395:	89 53 04             	mov    %edx,0x4(%ebx)
  pcb->remote_port = port;
  806398:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80639c:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  8063a1:	0f 84 b8 00 00 00    	je     80645f <tcp_connect+0xf0>
  iss = tcp_next_iss();
  8063a7:	e8 db fd ff ff       	call   806187 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8063ac:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8063b3:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8063b6:	83 e8 01             	sub    $0x1,%eax
  8063b9:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8063bc:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8063bf:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8063c5:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8063cb:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8063d1:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8063d7:	83 ec 08             	sub    $0x8,%esp
  8063da:	56                   	push   %esi
  8063db:	68 18 02 00 00       	push   $0x218
  8063e0:	e8 51 ff ff ff       	call   806336 <tcp_eff_send_mss>
  8063e5:	66 89 43 34          	mov    %ax,0x34(%ebx)
  pcb->cwnd = 1;
  8063e9:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8063ef:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8063f2:	01 c0                	add    %eax,%eax
  8063f4:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8063f8:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
  pcb->connected = connected;
  8063ff:	8b 45 14             	mov    0x14(%ebp),%eax
  806402:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806408:	8b 15 4c b2 b3 00    	mov    0xb3b24c,%edx
  80640e:	83 c4 10             	add    $0x10,%esp
  806411:	39 da                	cmp    %ebx,%edx
  806413:	74 58                	je     80646d <tcp_connect+0xfe>
  806415:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  80641b:	bf 00 00 00 00       	mov    $0x0,%edi
  806420:	89 de                	mov    %ebx,%esi
  806422:	85 d2                	test   %edx,%edx
  806424:	0f 84 ae 00 00 00    	je     8064d8 <tcp_connect+0x169>
  80642a:	8b 42 0c             	mov    0xc(%edx),%eax
  80642d:	39 f0                	cmp    %esi,%eax
  80642f:	0f 94 c3             	sete   %bl
  806432:	85 c0                	test   %eax,%eax
  806434:	0f 95 c1             	setne  %cl
  806437:	84 cb                	test   %cl,%bl
  806439:	0f 85 83 00 00 00    	jne    8064c2 <tcp_connect+0x153>
  80643f:	bf 01 00 00 00       	mov    $0x1,%edi
  806444:	89 c2                	mov    %eax,%edx
  806446:	eb da                	jmp    806422 <tcp_connect+0xb3>
  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806448:	83 ec 04             	sub    $0x4,%esp
  80644b:	68 dc 22 81 00       	push   $0x8122dc
  806450:	68 ec 01 00 00       	push   $0x1ec
  806455:	68 0e 23 81 00       	push   $0x81230e
  80645a:	e8 3a 82 00 00       	call   80e699 <_panic>
    pcb->local_port = tcp_new_port();
  80645f:	e8 6d ef ff ff       	call   8053d1 <tcp_new_port>
  806464:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  806468:	e9 3a ff ff ff       	jmp    8063a7 <tcp_connect+0x38>
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80646d:	8b 43 0c             	mov    0xc(%ebx),%eax
  806470:	a3 4c b2 b3 00       	mov    %eax,0xb3b24c
  TCP_REG(&tcp_active_pcbs, pcb);
  806475:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80647a:	89 43 0c             	mov    %eax,0xc(%ebx)
  80647d:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  806483:	e8 d8 bd ff ff       	call   802260 <tcp_timer_needed>
  optdata = TCP_BUILD_MSS_OPTION();
  806488:	83 ec 0c             	sub    $0xc,%esp
  80648b:	68 b4 05 04 02       	push   $0x20405b4
  806490:	e8 e9 12 00 00       	call   80777e <htonl>
  806495:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806498:	83 c4 0c             	add    $0xc,%esp
  80649b:	6a 04                	push   $0x4
  80649d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8064a0:	50                   	push   %eax
  8064a1:	6a 00                	push   $0x0
  8064a3:	6a 02                	push   $0x2
  8064a5:	6a 00                	push   $0x0
  8064a7:	6a 00                	push   $0x0
  8064a9:	53                   	push   %ebx
  8064aa:	e8 f9 14 00 00       	call   8079a8 <tcp_enqueue>
  8064af:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  8064b1:	83 c4 20             	add    $0x20,%esp
  8064b4:	84 c0                	test   %al,%al
  8064b6:	74 34                	je     8064ec <tcp_connect+0x17d>
} 
  8064b8:	89 f0                	mov    %esi,%eax
  8064ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8064bd:	5b                   	pop    %ebx
  8064be:	5e                   	pop    %esi
  8064bf:	5f                   	pop    %edi
  8064c0:	5d                   	pop    %ebp
  8064c1:	c3                   	ret    
  8064c2:	89 f3                	mov    %esi,%ebx
  8064c4:	89 f8                	mov    %edi,%eax
  8064c6:	84 c0                	test   %al,%al
  8064c8:	74 06                	je     8064d0 <tcp_connect+0x161>
  8064ca:	89 15 48 b2 b3 00    	mov    %edx,0xb3b248
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8064d0:	8b 43 0c             	mov    0xc(%ebx),%eax
  8064d3:	89 42 0c             	mov    %eax,0xc(%edx)
  8064d6:	eb 9d                	jmp    806475 <tcp_connect+0x106>
  8064d8:	89 f3                	mov    %esi,%ebx
  8064da:	89 f8                	mov    %edi,%eax
  8064dc:	84 c0                	test   %al,%al
  8064de:	74 95                	je     806475 <tcp_connect+0x106>
  8064e0:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  8064e7:	00 00 00 
  8064ea:	eb 89                	jmp    806475 <tcp_connect+0x106>
    tcp_output(pcb);
  8064ec:	83 ec 0c             	sub    $0xc,%esp
  8064ef:	53                   	push   %ebx
  8064f0:	e8 d0 1b 00 00       	call   8080c5 <tcp_output>
  8064f5:	83 c4 10             	add    $0x10,%esp
  8064f8:	eb be                	jmp    8064b8 <tcp_connect+0x149>
    return ERR_VAL;
  8064fa:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  8064ff:	eb b7                	jmp    8064b8 <tcp_connect+0x149>

00806501 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806501:	55                   	push   %ebp
  806502:	89 e5                	mov    %esp,%ebp
  806504:	53                   	push   %ebx
  806505:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806508:	8b 45 08             	mov    0x8(%ebp),%eax
  80650b:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80650d:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806510:	b8 01 00 00 00       	mov    $0x1,%eax
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806515:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806518:	77 27                	ja     806541 <ip_addr_isbroadcast+0x40>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  80651a:	0f b6 41 2e          	movzbl 0x2e(%ecx),%eax
  80651e:	83 e0 02             	and    $0x2,%eax
  806521:	74 1e                	je     806541 <ip_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806523:	8b 59 04             	mov    0x4(%ecx),%ebx
    return 0;
  806526:	b8 00 00 00 00       	mov    $0x0,%eax
  else if (addr2test == netif->ip_addr.addr)
  80652b:	39 d3                	cmp    %edx,%ebx
  80652d:	74 12                	je     806541 <ip_addr_isbroadcast+0x40>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80652f:	8b 49 08             	mov    0x8(%ecx),%ecx
  806532:	31 d3                	xor    %edx,%ebx
  806534:	85 cb                	test   %ecx,%ebx
  806536:	75 09                	jne    806541 <ip_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806538:	f7 d1                	not    %ecx
  80653a:	21 ca                	and    %ecx,%edx
  80653c:	39 ca                	cmp    %ecx,%edx
  80653e:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806541:	5b                   	pop    %ebx
  806542:	5d                   	pop    %ebp
  806543:	c3                   	ret    

00806544 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806544:	55                   	push   %ebp
  806545:	89 e5                	mov    %esp,%ebp
  806547:	56                   	push   %esi
  806548:	53                   	push   %ebx
  806549:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80654c:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
  806552:	eb 02                	jmp    806556 <ip_route+0x12>
  806554:	8b 1b                	mov    (%ebx),%ebx
  806556:	85 db                	test   %ebx,%ebx
  806558:	74 1c                	je     806576 <ip_route+0x32>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80655a:	83 ec 0c             	sub    $0xc,%esp
  80655d:	53                   	push   %ebx
  80655e:	e8 4b e2 ff ff       	call   8047ae <netif_is_up>
  806563:	83 c4 10             	add    $0x10,%esp
  806566:	84 c0                	test   %al,%al
  806568:	74 ea                	je     806554 <ip_route+0x10>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80656a:	8b 06                	mov    (%esi),%eax
  80656c:	33 43 04             	xor    0x4(%ebx),%eax
  80656f:	85 43 08             	test   %eax,0x8(%ebx)
  806572:	75 e0                	jne    806554 <ip_route+0x10>
  806574:	eb 1e                	jmp    806594 <ip_route+0x50>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806576:	a1 38 b2 b3 00       	mov    0xb3b238,%eax
  80657b:	85 c0                	test   %eax,%eax
  80657d:	74 1e                	je     80659d <ip_route+0x59>
  80657f:	83 ec 0c             	sub    $0xc,%esp
  806582:	50                   	push   %eax
  806583:	e8 26 e2 ff ff       	call   8047ae <netif_is_up>
  806588:	83 c4 10             	add    $0x10,%esp
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  80658b:	84 c0                	test   %al,%al
  80658d:	0f 45 1d 38 b2 b3 00 	cmovne 0xb3b238,%ebx
}
  806594:	89 d8                	mov    %ebx,%eax
  806596:	8d 65 f8             	lea    -0x8(%ebp),%esp
  806599:	5b                   	pop    %ebx
  80659a:	5e                   	pop    %esi
  80659b:	5d                   	pop    %ebp
  80659c:	c3                   	ret    
    return NULL;
  80659d:	89 c3                	mov    %eax,%ebx
  80659f:	eb f3                	jmp    806594 <ip_route+0x50>

008065a1 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  8065a1:	55                   	push   %ebp
  8065a2:	89 e5                	mov    %esp,%ebp
  8065a4:	57                   	push   %edi
  8065a5:	56                   	push   %esi
  8065a6:	53                   	push   %ebx
  8065a7:	83 ec 28             	sub    $0x28,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  8065aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8065ad:	8b 78 04             	mov    0x4(%eax),%edi
  if (IPH_V(iphdr) != 4) {
  8065b0:	0f b7 07             	movzwl (%edi),%eax
  8065b3:	50                   	push   %eax
  8065b4:	e8 b8 11 00 00       	call   807771 <ntohs>
  8065b9:	66 c1 e8 0c          	shr    $0xc,%ax
  8065bd:	83 c4 10             	add    $0x10,%esp
  8065c0:	66 83 f8 04          	cmp    $0x4,%ax
  8065c4:	74 1b                	je     8065e1 <ip_input+0x40>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  8065c6:	83 ec 0c             	sub    $0xc,%esp
  8065c9:	ff 75 08             	pushl  0x8(%ebp)
  8065cc:	e8 b9 e2 ff ff       	call   80488a <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8065d1:	83 c4 10             	add    $0x10,%esp
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8065d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8065d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8065dc:	5b                   	pop    %ebx
  8065dd:	5e                   	pop    %esi
  8065de:	5f                   	pop    %edi
  8065df:	5d                   	pop    %ebp
  8065e0:	c3                   	ret    
  iphdr_hlen = IPH_HL(iphdr);
  8065e1:	83 ec 0c             	sub    $0xc,%esp
  8065e4:	0f b7 07             	movzwl (%edi),%eax
  8065e7:	50                   	push   %eax
  8065e8:	e8 84 11 00 00       	call   807771 <ntohs>
  8065ed:	66 c1 e8 06          	shr    $0x6,%ax
  iphdr_hlen *= 4;
  8065f1:	83 e0 3c             	and    $0x3c,%eax
  8065f4:	89 c6                	mov    %eax,%esi
  8065f6:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  iphdr_len = ntohs(IPH_LEN(iphdr));
  8065fa:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  8065fe:	89 04 24             	mov    %eax,(%esp)
  806601:	e8 6b 11 00 00       	call   807771 <ntohs>
  806606:	89 c3                	mov    %eax,%ebx
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806608:	83 c4 10             	add    $0x10,%esp
  80660b:	8b 45 08             	mov    0x8(%ebp),%eax
  80660e:	66 39 70 0a          	cmp    %si,0xa(%eax)
  806612:	72 06                	jb     80661a <ip_input+0x79>
  806614:	66 39 58 08          	cmp    %bx,0x8(%eax)
  806618:	73 10                	jae    80662a <ip_input+0x89>
    pbuf_free(p);
  80661a:	83 ec 0c             	sub    $0xc,%esp
  80661d:	ff 75 08             	pushl  0x8(%ebp)
  806620:	e8 65 e2 ff ff       	call   80488a <pbuf_free>
    return ERR_OK;
  806625:	83 c4 10             	add    $0x10,%esp
  806628:	eb aa                	jmp    8065d4 <ip_input+0x33>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80662a:	83 ec 08             	sub    $0x8,%esp
  80662d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806631:	50                   	push   %eax
  806632:	57                   	push   %edi
  806633:	e8 fe 0f 00 00       	call   807636 <inet_chksum>
  806638:	83 c4 10             	add    $0x10,%esp
  80663b:	66 85 c0             	test   %ax,%ax
  80663e:	75 27                	jne    806667 <ip_input+0xc6>
  pbuf_realloc(p, iphdr_len);
  806640:	83 ec 08             	sub    $0x8,%esp
  806643:	0f b7 db             	movzwl %bx,%ebx
  806646:	53                   	push   %ebx
  806647:	ff 75 08             	pushl  0x8(%ebp)
  80664a:	e8 73 e5 ff ff       	call   804bc2 <pbuf_realloc>
  80664f:	83 c4 10             	add    $0x10,%esp
    netif = inp;
  806652:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int first = 1;
  806655:	be 01 00 00 00       	mov    $0x1,%esi
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80665a:	8d 47 10             	lea    0x10(%edi),%eax
  80665d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806660:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806663:	89 df                	mov    %ebx,%edi
  806665:	eb 2e                	jmp    806695 <ip_input+0xf4>
    pbuf_free(p);
  806667:	83 ec 0c             	sub    $0xc,%esp
  80666a:	ff 75 08             	pushl  0x8(%ebp)
  80666d:	e8 18 e2 ff ff       	call   80488a <pbuf_free>
    return ERR_OK;
  806672:	83 c4 10             	add    $0x10,%esp
  806675:	e9 5a ff ff ff       	jmp    8065d4 <ip_input+0x33>
      if (first) {
  80667a:	85 f6                	test   %esi,%esi
  80667c:	74 56                	je     8066d4 <ip_input+0x133>
        netif = netif_list;
  80667e:	8b 1d 34 b2 b3 00    	mov    0xb3b234,%ebx
      if (netif == inp) {
  806684:	39 df                	cmp    %ebx,%edi
  806686:	74 50                	je     8066d8 <ip_input+0x137>
  806688:	be 00 00 00 00       	mov    $0x0,%esi
    } while(netif != NULL);
  80668d:	85 db                	test   %ebx,%ebx
  80668f:	0f 84 20 01 00 00    	je     8067b5 <ip_input+0x214>
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806695:	83 ec 0c             	sub    $0xc,%esp
  806698:	53                   	push   %ebx
  806699:	e8 10 e1 ff ff       	call   8047ae <netif_is_up>
  80669e:	83 c4 10             	add    $0x10,%esp
  8066a1:	84 c0                	test   %al,%al
  8066a3:	74 d5                	je     80667a <ip_input+0xd9>
  8066a5:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8066a8:	74 d0                	je     80667a <ip_input+0xd9>
  8066aa:	8b 43 04             	mov    0x4(%ebx),%eax
  8066ad:	85 c0                	test   %eax,%eax
  8066af:	74 c9                	je     80667a <ip_input+0xd9>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8066b1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8066b4:	3b 42 10             	cmp    0x10(%edx),%eax
  8066b7:	74 4a                	je     806703 <ip_input+0x162>
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8066b9:	83 ec 08             	sub    $0x8,%esp
  8066bc:	53                   	push   %ebx
  8066bd:	ff 75 dc             	pushl  -0x24(%ebp)
  8066c0:	e8 3c fe ff ff       	call   806501 <ip_addr_isbroadcast>
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  8066c5:	83 c4 10             	add    $0x10,%esp
  8066c8:	84 c0                	test   %al,%al
  8066ca:	74 ae                	je     80667a <ip_input+0xd9>
  8066cc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8066cf:	e9 fc 00 00 00       	jmp    8067d0 <ip_input+0x22f>
        netif = netif->next;
  8066d4:	8b 1b                	mov    (%ebx),%ebx
  8066d6:	eb ac                	jmp    806684 <ip_input+0xe3>
        netif = netif->next;
  8066d8:	8b 1b                	mov    (%ebx),%ebx
  8066da:	eb ac                	jmp    806688 <ip_input+0xe7>
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  8066dc:	83 ec 0c             	sub    $0xc,%esp
  8066df:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8066e3:	0f b7 44 07 02       	movzwl 0x2(%edi,%eax,1),%eax
  8066e8:	50                   	push   %eax
  8066e9:	e8 83 10 00 00       	call   807771 <ntohs>
  8066ee:	83 c4 10             	add    $0x10,%esp
  8066f1:	66 83 f8 44          	cmp    $0x44,%ax
  8066f5:	0f 85 d5 00 00 00    	jne    8067d0 <ip_input+0x22f>
        netif = inp;
  8066fb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8066fe:	e9 10 01 00 00       	jmp    806813 <ip_input+0x272>
  806703:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806706:	e9 c5 00 00 00       	jmp    8067d0 <ip_input+0x22f>
      pbuf_free(p);
  80670b:	83 ec 0c             	sub    $0xc,%esp
  80670e:	ff 75 08             	pushl  0x8(%ebp)
  806711:	e8 74 e1 ff ff       	call   80488a <pbuf_free>
      return ERR_OK;
  806716:	83 c4 10             	add    $0x10,%esp
  806719:	e9 b6 fe ff ff       	jmp    8065d4 <ip_input+0x33>
    pbuf_free(p);
  80671e:	83 ec 0c             	sub    $0xc,%esp
  806721:	ff 75 08             	pushl  0x8(%ebp)
  806724:	e8 61 e1 ff ff       	call   80488a <pbuf_free>
    return ERR_OK;
  806729:	83 c4 10             	add    $0x10,%esp
  80672c:	e9 a3 fe ff ff       	jmp    8065d4 <ip_input+0x33>
      udp_input(p, inp);
  806731:	83 ec 08             	sub    $0x8,%esp
  806734:	ff 75 0c             	pushl  0xc(%ebp)
  806737:	ff 75 08             	pushl  0x8(%ebp)
  80673a:	e8 6b 22 00 00       	call   8089aa <udp_input>
      break;
  80673f:	83 c4 10             	add    $0x10,%esp
  806742:	e9 8d fe ff ff       	jmp    8065d4 <ip_input+0x33>
      tcp_input(p, inp);
  806747:	83 ec 08             	sub    $0x8,%esp
  80674a:	ff 75 0c             	pushl  0xc(%ebp)
  80674d:	ff 75 08             	pushl  0x8(%ebp)
  806750:	e8 57 69 00 00       	call   80d0ac <tcp_input>
      break;
  806755:	83 c4 10             	add    $0x10,%esp
  806758:	e9 77 fe ff ff       	jmp    8065d4 <ip_input+0x33>
      icmp_input(p, inp);
  80675d:	83 ec 08             	sub    $0x8,%esp
  806760:	ff 75 0c             	pushl  0xc(%ebp)
  806763:	ff 75 08             	pushl  0x8(%ebp)
  806766:	e8 41 79 00 00       	call   80e0ac <icmp_input>
      break;
  80676b:	83 c4 10             	add    $0x10,%esp
  80676e:	e9 61 fe ff ff       	jmp    8065d4 <ip_input+0x33>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806773:	8b 5f 10             	mov    0x10(%edi),%ebx
  806776:	83 ec 0c             	sub    $0xc,%esp
  806779:	68 00 00 00 f0       	push   $0xf0000000
  80677e:	e8 12 12 00 00       	call   807995 <ntohl>
  806783:	21 c3                	and    %eax,%ebx
  806785:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80678c:	e8 04 12 00 00       	call   807995 <ntohl>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806791:	83 c4 10             	add    $0x10,%esp
  806794:	39 c3                	cmp    %eax,%ebx
  806796:	0f 84 18 01 00 00    	je     8068b4 <ip_input+0x313>
        p->payload = iphdr;
  80679c:	8b 45 08             	mov    0x8(%ebp),%eax
  80679f:	89 78 04             	mov    %edi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8067a2:	83 ec 08             	sub    $0x8,%esp
  8067a5:	6a 02                	push   $0x2
  8067a7:	50                   	push   %eax
  8067a8:	e8 19 7c 00 00       	call   80e3c6 <icmp_dest_unreach>
  8067ad:	83 c4 10             	add    $0x10,%esp
  8067b0:	e9 ff 00 00 00       	jmp    8068b4 <ip_input+0x313>
  8067b5:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  8067b8:	83 ec 0c             	sub    $0xc,%esp
  8067bb:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  8067bf:	50                   	push   %eax
  8067c0:	e8 ac 0f 00 00       	call   807771 <ntohs>
  8067c5:	83 c4 10             	add    $0x10,%esp
  8067c8:	3c 11                	cmp    $0x11,%al
  8067ca:	0f 84 0c ff ff ff    	je     8066dc <ip_input+0x13b>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8067d0:	83 ec 08             	sub    $0x8,%esp
  8067d3:	ff 75 0c             	pushl  0xc(%ebp)
  8067d6:	8d 47 0c             	lea    0xc(%edi),%eax
  8067d9:	50                   	push   %eax
  8067da:	e8 22 fd ff ff       	call   806501 <ip_addr_isbroadcast>
  8067df:	83 c4 10             	add    $0x10,%esp
  8067e2:	84 c0                	test   %al,%al
  8067e4:	0f 85 21 ff ff ff    	jne    80670b <ip_input+0x16a>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8067ea:	8b 77 0c             	mov    0xc(%edi),%esi
  8067ed:	83 ec 0c             	sub    $0xc,%esp
  8067f0:	68 00 00 00 f0       	push   $0xf0000000
  8067f5:	e8 9b 11 00 00       	call   807995 <ntohl>
  8067fa:	21 c6                	and    %eax,%esi
  8067fc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806803:	e8 8d 11 00 00       	call   807995 <ntohl>
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806808:	83 c4 10             	add    $0x10,%esp
  80680b:	39 c6                	cmp    %eax,%esi
  80680d:	0f 84 f8 fe ff ff    	je     80670b <ip_input+0x16a>
  if (netif == NULL) {
  806813:	85 db                	test   %ebx,%ebx
  806815:	0f 84 03 ff ff ff    	je     80671e <ip_input+0x17d>
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80681b:	0f b7 5f 06          	movzwl 0x6(%edi),%ebx
  80681f:	83 ec 0c             	sub    $0xc,%esp
  806822:	68 ff 3f 00 00       	push   $0x3fff
  806827:	e8 38 0f 00 00       	call   807764 <htons>
  80682c:	83 c4 10             	add    $0x10,%esp
  80682f:	66 85 c3             	test   %ax,%bx
  806832:	74 1c                	je     806850 <ip_input+0x2af>
    p = ip_reass(p);
  806834:	83 ec 0c             	sub    $0xc,%esp
  806837:	ff 75 08             	pushl  0x8(%ebp)
  80683a:	e8 95 04 00 00       	call   806cd4 <ip_reass>
  80683f:	89 45 08             	mov    %eax,0x8(%ebp)
    if (p == NULL) {
  806842:	83 c4 10             	add    $0x10,%esp
  806845:	85 c0                	test   %eax,%eax
  806847:	0f 84 87 fd ff ff    	je     8065d4 <ip_input+0x33>
    iphdr = p->payload;
  80684d:	8b 78 04             	mov    0x4(%eax),%edi
  if (raw_input(p, inp) == 0)
  806850:	83 ec 08             	sub    $0x8,%esp
  806853:	ff 75 0c             	pushl  0xc(%ebp)
  806856:	ff 75 08             	pushl  0x8(%ebp)
  806859:	e8 a5 75 00 00       	call   80de03 <raw_input>
  80685e:	83 c4 10             	add    $0x10,%esp
  806861:	84 c0                	test   %al,%al
  806863:	0f 85 6b fd ff ff    	jne    8065d4 <ip_input+0x33>
    switch (IPH_PROTO(iphdr)) {
  806869:	83 ec 0c             	sub    $0xc,%esp
  80686c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  806870:	50                   	push   %eax
  806871:	e8 fb 0e 00 00       	call   807771 <ntohs>
  806876:	0f b6 c0             	movzbl %al,%eax
  806879:	83 c4 10             	add    $0x10,%esp
  80687c:	66 83 f8 06          	cmp    $0x6,%ax
  806880:	0f 84 c1 fe ff ff    	je     806747 <ip_input+0x1a6>
  806886:	66 83 f8 11          	cmp    $0x11,%ax
  80688a:	0f 84 a1 fe ff ff    	je     806731 <ip_input+0x190>
  806890:	66 83 f8 01          	cmp    $0x1,%ax
  806894:	0f 84 c3 fe ff ff    	je     80675d <ip_input+0x1bc>
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80689a:	83 ec 08             	sub    $0x8,%esp
  80689d:	ff 75 0c             	pushl  0xc(%ebp)
  8068a0:	8d 47 10             	lea    0x10(%edi),%eax
  8068a3:	50                   	push   %eax
  8068a4:	e8 58 fc ff ff       	call   806501 <ip_addr_isbroadcast>
  8068a9:	83 c4 10             	add    $0x10,%esp
  8068ac:	84 c0                	test   %al,%al
  8068ae:	0f 84 bf fe ff ff    	je     806773 <ip_input+0x1d2>
      pbuf_free(p);
  8068b4:	83 ec 0c             	sub    $0xc,%esp
  8068b7:	ff 75 08             	pushl  0x8(%ebp)
  8068ba:	e8 cb df ff ff       	call   80488a <pbuf_free>
  8068bf:	83 c4 10             	add    $0x10,%esp
  8068c2:	e9 0d fd ff ff       	jmp    8065d4 <ip_input+0x33>

008068c7 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8068c7:	55                   	push   %ebp
  8068c8:	89 e5                	mov    %esp,%ebp
  8068ca:	57                   	push   %edi
  8068cb:	56                   	push   %esi
  8068cc:	53                   	push   %ebx
  8068cd:	83 ec 1c             	sub    $0x1c,%esp
  8068d0:	8b 75 08             	mov    0x8(%ebp),%esi
  8068d3:	8b 7d 14             	mov    0x14(%ebp),%edi
  8068d6:	8b 45 18             	mov    0x18(%ebp),%eax
  8068d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8068dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8068df:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8068e2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8068e6:	0f 84 42 01 00 00    	je     806a2e <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8068ec:	83 ec 08             	sub    $0x8,%esp
  8068ef:	6a 14                	push   $0x14
  8068f1:	56                   	push   %esi
  8068f2:	e8 c6 de ff ff       	call   8047bd <pbuf_header>
  8068f7:	83 c4 10             	add    $0x10,%esp
  8068fa:	84 c0                	test   %al,%al
  8068fc:	0f 85 4b 01 00 00    	jne    806a4d <ip_output_if+0x186>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806902:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806905:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  80690a:	0f 86 02 01 00 00    	jbe    806a12 <ip_output_if+0x14b>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806910:	83 ec 0c             	sub    $0xc,%esp
  806913:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806917:	50                   	push   %eax
  806918:	e8 54 0e 00 00       	call   807771 <ntohs>
  80691d:	0f b6 c0             	movzbl %al,%eax
  806920:	c1 e7 08             	shl    $0x8,%edi
  806923:	09 c7                	or     %eax,%edi
  806925:	0f b7 ff             	movzwl %di,%edi
  806928:	89 3c 24             	mov    %edi,(%esp)
  80692b:	e8 34 0e 00 00       	call   807764 <htons>
  806930:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806934:	0f b7 c0             	movzwl %ax,%eax
  806937:	89 04 24             	mov    %eax,(%esp)
  80693a:	e8 32 0e 00 00       	call   807771 <ntohs>
  80693f:	89 c2                	mov    %eax,%edx
  806941:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  806947:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  80694b:	09 d0                	or     %edx,%eax
  80694d:	0f b7 c0             	movzwl %ax,%eax
  806950:	89 04 24             	mov    %eax,(%esp)
  806953:	e8 0c 0e 00 00       	call   807764 <htons>
  806958:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  80695c:	8b 45 10             	mov    0x10(%ebp),%eax
  80695f:	8b 00                	mov    (%eax),%eax
  806961:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806964:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806968:	80 cc 45             	or     $0x45,%ah
  80696b:	89 04 24             	mov    %eax,(%esp)
  80696e:	e8 f1 0d 00 00       	call   807764 <htons>
  806973:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806976:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80697a:	89 04 24             	mov    %eax,(%esp)
  80697d:	e8 e2 0d 00 00       	call   807764 <htons>
  806982:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806986:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  80698c:	0f b7 05 fa 43 b3 00 	movzwl 0xb343fa,%eax
  806993:	89 04 24             	mov    %eax,(%esp)
  806996:	e8 c9 0d 00 00       	call   807764 <htons>
  80699b:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  80699f:	66 83 05 fa 43 b3 00 	addw   $0x1,0xb343fa
  8069a6:	01 

    if (ip_addr_isany(src)) {
  8069a7:	83 c4 10             	add    $0x10,%esp
  8069aa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8069ae:	74 09                	je     8069b9 <ip_output_if+0xf2>
  8069b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8069b3:	8b 00                	mov    (%eax),%eax
  8069b5:	85 c0                	test   %eax,%eax
  8069b7:	75 70                	jne    806a29 <ip_output_if+0x162>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8069b9:	b8 00 00 00 00       	mov    $0x0,%eax
  8069be:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  8069c2:	74 06                	je     8069ca <ip_output_if+0x103>
  8069c4:	8b 45 20             	mov    0x20(%ebp),%eax
  8069c7:	8b 40 04             	mov    0x4(%eax),%eax
  8069ca:	89 43 0c             	mov    %eax,0xc(%ebx)
    } else {
      ip_addr_set(&(iphdr->src), src);
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8069cd:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8069d3:	83 ec 08             	sub    $0x8,%esp
  8069d6:	6a 14                	push   $0x14
  8069d8:	53                   	push   %ebx
  8069d9:	e8 58 0c 00 00       	call   807636 <inet_chksum>
  8069de:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8069e2:	83 c4 10             	add    $0x10,%esp
    dest = &(iphdr->dest);
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8069e5:	8b 45 20             	mov    0x20(%ebp),%eax
  8069e8:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  8069ec:	66 85 c0             	test   %ax,%ax
  8069ef:	74 06                	je     8069f7 <ip_output_if+0x130>
  8069f1:	66 3b 46 08          	cmp    0x8(%esi),%ax
  8069f5:	72 42                	jb     806a39 <ip_output_if+0x172>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8069f7:	83 ec 04             	sub    $0x4,%esp
  8069fa:	ff 75 10             	pushl  0x10(%ebp)
  8069fd:	56                   	push   %esi
  8069fe:	ff 75 20             	pushl  0x20(%ebp)
  806a01:	8b 45 20             	mov    0x20(%ebp),%eax
  806a04:	ff 50 14             	call   *0x14(%eax)
  806a07:	83 c4 10             	add    $0x10,%esp
  }
}
  806a0a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a0d:	5b                   	pop    %ebx
  806a0e:	5e                   	pop    %esi
  806a0f:	5f                   	pop    %edi
  806a10:	5d                   	pop    %ebp
  806a11:	c3                   	ret    
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806a12:	83 ec 04             	sub    $0x4,%esp
  806a15:	68 ac 23 81 00       	push   $0x8123ac
  806a1a:	68 ee 01 00 00       	push   $0x1ee
  806a1f:	68 d9 23 81 00       	push   $0x8123d9
  806a24:	e8 70 7c 00 00       	call   80e699 <_panic>
      ip_addr_set(&(iphdr->src), src);
  806a29:	89 43 0c             	mov    %eax,0xc(%ebx)
  806a2c:	eb 9f                	jmp    8069cd <ip_output_if+0x106>
    dest = &(iphdr->dest);
  806a2e:	8b 46 04             	mov    0x4(%esi),%eax
  806a31:	83 c0 10             	add    $0x10,%eax
  806a34:	89 45 10             	mov    %eax,0x10(%ebp)
  806a37:	eb ac                	jmp    8069e5 <ip_output_if+0x11e>
    return ip_frag(p,netif,dest);
  806a39:	83 ec 04             	sub    $0x4,%esp
  806a3c:	ff 75 10             	pushl  0x10(%ebp)
  806a3f:	ff 75 20             	pushl  0x20(%ebp)
  806a42:	56                   	push   %esi
  806a43:	e8 5e 07 00 00       	call   8071a6 <ip_frag>
  806a48:	83 c4 10             	add    $0x10,%esp
  806a4b:	eb bd                	jmp    806a0a <ip_output_if+0x143>
      return ERR_BUF;
  806a4d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  806a52:	eb b6                	jmp    806a0a <ip_output_if+0x143>

00806a54 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806a54:	55                   	push   %ebp
  806a55:	89 e5                	mov    %esp,%ebp
  806a57:	57                   	push   %edi
  806a58:	56                   	push   %esi
  806a59:	53                   	push   %ebx
  806a5a:	83 ec 18             	sub    $0x18,%esp
  806a5d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806a60:	8b 75 18             	mov    0x18(%ebp),%esi
  806a63:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806a66:	ff 75 10             	pushl  0x10(%ebp)
  806a69:	e8 d6 fa ff ff       	call   806544 <ip_route>
  806a6e:	83 c4 10             	add    $0x10,%esp
  806a71:	85 c0                	test   %eax,%eax
  806a73:	74 2d                	je     806aa2 <ip_output+0x4e>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  806a75:	83 ec 04             	sub    $0x4,%esp
  806a78:	50                   	push   %eax
  806a79:	89 f8                	mov    %edi,%eax
  806a7b:	0f b6 f8             	movzbl %al,%edi
  806a7e:	57                   	push   %edi
  806a7f:	89 f0                	mov    %esi,%eax
  806a81:	0f b6 f0             	movzbl %al,%esi
  806a84:	56                   	push   %esi
  806a85:	0f b6 db             	movzbl %bl,%ebx
  806a88:	53                   	push   %ebx
  806a89:	ff 75 10             	pushl  0x10(%ebp)
  806a8c:	ff 75 0c             	pushl  0xc(%ebp)
  806a8f:	ff 75 08             	pushl  0x8(%ebp)
  806a92:	e8 30 fe ff ff       	call   8068c7 <ip_output_if>
  806a97:	83 c4 20             	add    $0x20,%esp
}
  806a9a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806a9d:	5b                   	pop    %ebx
  806a9e:	5e                   	pop    %esi
  806a9f:	5f                   	pop    %edi
  806aa0:	5d                   	pop    %ebp
  806aa1:	c3                   	ret    
    return ERR_RTE;
  806aa2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  806aa7:	eb f1                	jmp    806a9a <ip_output+0x46>

00806aa9 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  806aa9:	55                   	push   %ebp
  806aaa:	89 e5                	mov    %esp,%ebp
  806aac:	83 ec 08             	sub    $0x8,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  806aaf:	39 05 e0 49 b3 00    	cmp    %eax,0xb349e0
  806ab5:	74 18                	je     806acf <ip_reass_dequeue_datagram+0x26>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806ab7:	85 d2                	test   %edx,%edx
  806ab9:	74 1e                	je     806ad9 <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
  806abb:	8b 08                	mov    (%eax),%ecx
  806abd:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  806abf:	83 ec 08             	sub    $0x8,%esp
  806ac2:	50                   	push   %eax
  806ac3:	6a 05                	push   $0x5
  806ac5:	e8 73 da ff ff       	call   80453d <memp_free>
}
  806aca:	83 c4 10             	add    $0x10,%esp
  806acd:	c9                   	leave  
  806ace:	c3                   	ret    
    reassdatagrams = ipr->next;
  806acf:	8b 10                	mov    (%eax),%edx
  806ad1:	89 15 e0 49 b3 00    	mov    %edx,0xb349e0
  806ad7:	eb e6                	jmp    806abf <ip_reass_dequeue_datagram+0x16>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  806ad9:	83 ec 04             	sub    $0x4,%esp
  806adc:	68 f1 23 81 00       	push   $0x8123f1
  806ae1:	68 29 01 00 00       	push   $0x129
  806ae6:	68 0a 24 81 00       	push   $0x81240a
  806aeb:	e8 a9 7b 00 00       	call   80e699 <_panic>

00806af0 <ip_reass_free_complete_datagram>:
{
  806af0:	55                   	push   %ebp
  806af1:	89 e5                	mov    %esp,%ebp
  806af3:	57                   	push   %edi
  806af4:	56                   	push   %esi
  806af5:	53                   	push   %ebx
  806af6:	83 ec 1c             	sub    $0x1c,%esp
  806af9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806afc:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806aff:	39 c2                	cmp    %eax,%edx
  806b01:	74 53                	je     806b56 <ip_reass_free_complete_datagram+0x66>
  if (prev != NULL) {
  806b03:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806b06:	85 c0                	test   %eax,%eax
  806b08:	74 07                	je     806b11 <ip_reass_free_complete_datagram+0x21>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806b0a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806b0d:	39 10                	cmp    %edx,(%eax)
  806b0f:	75 5c                	jne    806b6d <ip_reass_free_complete_datagram+0x7d>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  806b11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b14:	8b 58 04             	mov    0x4(%eax),%ebx
  806b17:	8b 43 04             	mov    0x4(%ebx),%eax
  int pbufs_freed = 0;
  806b1a:	be 00 00 00 00       	mov    $0x0,%esi
  if (iprh->start == 0) {
  806b1f:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  806b24:	74 5e                	je     806b84 <ip_reass_free_complete_datagram+0x94>
  p = ipr->p;
  806b26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806b29:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  806b2c:	85 db                	test   %ebx,%ebx
  806b2e:	0f 84 8f 00 00 00    	je     806bc3 <ip_reass_free_complete_datagram+0xd3>
    iprh = (struct ip_reass_helper *)p->payload;
  806b34:	8b 43 04             	mov    0x4(%ebx),%eax
    p = iprh->next_pbuf;
  806b37:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  806b39:	83 ec 0c             	sub    $0xc,%esp
  806b3c:	53                   	push   %ebx
  806b3d:	e8 92 e1 ff ff       	call   804cd4 <pbuf_clen>
  806b42:	0f b6 c0             	movzbl %al,%eax
  806b45:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  806b47:	89 1c 24             	mov    %ebx,(%esp)
  806b4a:	e8 3b dd ff ff       	call   80488a <pbuf_free>
  806b4f:	83 c4 10             	add    $0x10,%esp
    p = iprh->next_pbuf;
  806b52:	89 fb                	mov    %edi,%ebx
  806b54:	eb d6                	jmp    806b2c <ip_reass_free_complete_datagram+0x3c>
  LWIP_ASSERT("prev != ipr", prev != ipr);
  806b56:	83 ec 04             	sub    $0x4,%esp
  806b59:	68 27 24 81 00       	push   $0x812427
  806b5e:	68 99 00 00 00       	push   $0x99
  806b63:	68 0a 24 81 00       	push   $0x81240a
  806b68:	e8 2c 7b 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  806b6d:	83 ec 04             	sub    $0x4,%esp
  806b70:	68 33 24 81 00       	push   $0x812433
  806b75:	68 9b 00 00 00       	push   $0x9b
  806b7a:	68 0a 24 81 00       	push   $0x81240a
  806b7f:	e8 15 7b 00 00       	call   80e699 <_panic>
    ipr->p = iprh->next_pbuf;
  806b84:	8b 00                	mov    (%eax),%eax
  806b86:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806b89:	89 41 04             	mov    %eax,0x4(%ecx)
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  806b8c:	83 ec 04             	sub    $0x4,%esp
  806b8f:	6a 14                	push   $0x14
  806b91:	8d 41 08             	lea    0x8(%ecx),%eax
  806b94:	50                   	push   %eax
  806b95:	ff 73 04             	pushl  0x4(%ebx)
  806b98:	e8 41 85 00 00       	call   80f0de <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  806b9d:	83 c4 08             	add    $0x8,%esp
  806ba0:	6a 01                	push   $0x1
  806ba2:	53                   	push   %ebx
  806ba3:	e8 01 79 00 00       	call   80e4a9 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  806ba8:	89 1c 24             	mov    %ebx,(%esp)
  806bab:	e8 24 e1 ff ff       	call   804cd4 <pbuf_clen>
  806bb0:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  806bb3:	89 1c 24             	mov    %ebx,(%esp)
  806bb6:	e8 cf dc ff ff       	call   80488a <pbuf_free>
  806bbb:	83 c4 10             	add    $0x10,%esp
  806bbe:	e9 63 ff ff ff       	jmp    806b26 <ip_reass_free_complete_datagram+0x36>
  ip_reass_dequeue_datagram(ipr, prev);
  806bc3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806bc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806bc9:	e8 db fe ff ff       	call   806aa9 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806bce:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806bd5:	0f b7 d0             	movzwl %ax,%edx
  806bd8:	39 f2                	cmp    %esi,%edx
  806bda:	7c 12                	jl     806bee <ip_reass_free_complete_datagram+0xfe>
  ip_reass_pbufcount -= pbufs_freed;
  806bdc:	29 f0                	sub    %esi,%eax
  806bde:	66 a3 dc 49 b3 00    	mov    %ax,0xb349dc
}
  806be4:	89 f0                	mov    %esi,%eax
  806be6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806be9:	5b                   	pop    %ebx
  806bea:	5e                   	pop    %esi
  806beb:	5f                   	pop    %edi
  806bec:	5d                   	pop    %ebp
  806bed:	c3                   	ret    
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  806bee:	83 ec 04             	sub    $0x4,%esp
  806bf1:	68 45 24 81 00       	push   $0x812445
  806bf6:	68 bc 00 00 00       	push   $0xbc
  806bfb:	68 0a 24 81 00       	push   $0x81240a
  806c00:	e8 94 7a 00 00       	call   80e699 <_panic>

00806c05 <ip_reass_remove_oldest_datagram>:
{
  806c05:	55                   	push   %ebp
  806c06:	89 e5                	mov    %esp,%ebp
  806c08:	57                   	push   %edi
  806c09:	56                   	push   %esi
  806c0a:	53                   	push   %ebx
  806c0b:	83 ec 1c             	sub    $0x1c,%esp
  806c0e:	89 c6                	mov    %eax,%esi
  806c10:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  806c13:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806c1a:	eb 5b                	jmp    806c77 <ip_reass_remove_oldest_datagram+0x72>
        other_datagrams++;
  806c1c:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  806c20:	85 c0                	test   %eax,%eax
  806c22:	74 33                	je     806c57 <ip_reass_remove_oldest_datagram+0x52>
          oldest = r;
  806c24:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  806c28:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  806c2b:	0f 46 c1             	cmovbe %ecx,%eax
      if (r->next != NULL) {
  806c2e:	8b 39                	mov    (%ecx),%edi
        prev = r;
  806c30:	85 ff                	test   %edi,%edi
  806c32:	0f 45 d1             	cmovne %ecx,%edx
  806c35:	89 f9                	mov    %edi,%ecx
    while (r != NULL) {
  806c37:	85 c9                	test   %ecx,%ecx
  806c39:	74 20                	je     806c5b <ip_reass_remove_oldest_datagram+0x56>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  806c3b:	8b 5e 0c             	mov    0xc(%esi),%ebx
  806c3e:	39 59 14             	cmp    %ebx,0x14(%ecx)
  806c41:	75 d9                	jne    806c1c <ip_reass_remove_oldest_datagram+0x17>
  806c43:	8b 7e 10             	mov    0x10(%esi),%edi
  806c46:	39 79 18             	cmp    %edi,0x18(%ecx)
  806c49:	75 d1                	jne    806c1c <ip_reass_remove_oldest_datagram+0x17>
  806c4b:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  806c4f:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  806c53:	75 c7                	jne    806c1c <ip_reass_remove_oldest_datagram+0x17>
  806c55:	eb d7                	jmp    806c2e <ip_reass_remove_oldest_datagram+0x29>
          oldest = r;
  806c57:	89 c8                	mov    %ecx,%eax
  806c59:	eb d3                	jmp    806c2e <ip_reass_remove_oldest_datagram+0x29>
  806c5b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    if (oldest != NULL) {
  806c5e:	85 c0                	test   %eax,%eax
  806c60:	74 08                	je     806c6a <ip_reass_remove_oldest_datagram+0x65>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  806c62:	e8 89 fe ff ff       	call   806af0 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  806c67:	01 45 e0             	add    %eax,-0x20(%ebp)
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  806c6a:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806c6d:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  806c70:	7d 1f                	jge    806c91 <ip_reass_remove_oldest_datagram+0x8c>
  806c72:	83 fb 01             	cmp    $0x1,%ebx
  806c75:	7e 1a                	jle    806c91 <ip_reass_remove_oldest_datagram+0x8c>
    r = reassdatagrams;
  806c77:	8b 0d e0 49 b3 00    	mov    0xb349e0,%ecx
    other_datagrams = 0;
  806c7d:	bb 00 00 00 00       	mov    $0x0,%ebx
    prev = NULL;
  806c82:	ba 00 00 00 00       	mov    $0x0,%edx
    oldest = NULL;
  806c87:	b8 00 00 00 00       	mov    $0x0,%eax
  806c8c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    while (r != NULL) {
  806c8f:	eb a6                	jmp    806c37 <ip_reass_remove_oldest_datagram+0x32>
}
  806c91:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806c94:	83 c4 1c             	add    $0x1c,%esp
  806c97:	5b                   	pop    %ebx
  806c98:	5e                   	pop    %esi
  806c99:	5f                   	pop    %edi
  806c9a:	5d                   	pop    %ebp
  806c9b:	c3                   	ret    

00806c9c <ip_reass_tmr>:
{
  806c9c:	55                   	push   %ebp
  806c9d:	89 e5                	mov    %esp,%ebp
  806c9f:	56                   	push   %esi
  806ca0:	53                   	push   %ebx
  r = reassdatagrams;
  806ca1:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  struct ip_reassdata *r, *prev = NULL;
  806ca6:	bb 00 00 00 00       	mov    $0x0,%ebx
  while (r != NULL) {
  806cab:	eb 0b                	jmp    806cb8 <ip_reass_tmr+0x1c>
      r = r->next;
  806cad:	8b 30                	mov    (%eax),%esi
      ip_reass_free_complete_datagram(tmp, prev);
  806caf:	89 da                	mov    %ebx,%edx
  806cb1:	e8 3a fe ff ff       	call   806af0 <ip_reass_free_complete_datagram>
      r = r->next;
  806cb6:	89 f0                	mov    %esi,%eax
  while (r != NULL) {
  806cb8:	85 c0                	test   %eax,%eax
  806cba:	74 14                	je     806cd0 <ip_reass_tmr+0x34>
    if (r->timer > 0) {
  806cbc:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  806cc0:	84 d2                	test   %dl,%dl
  806cc2:	74 e9                	je     806cad <ip_reass_tmr+0x11>
      r->timer--;
  806cc4:	83 ea 01             	sub    $0x1,%edx
  806cc7:	88 50 1f             	mov    %dl,0x1f(%eax)
      prev = r;
  806cca:	89 c3                	mov    %eax,%ebx
      r = r->next;
  806ccc:	8b 00                	mov    (%eax),%eax
  806cce:	eb e8                	jmp    806cb8 <ip_reass_tmr+0x1c>
}
  806cd0:	5b                   	pop    %ebx
  806cd1:	5e                   	pop    %esi
  806cd2:	5d                   	pop    %ebp
  806cd3:	c3                   	ret    

00806cd4 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  806cd4:	55                   	push   %ebp
  806cd5:	89 e5                	mov    %esp,%ebp
  806cd7:	57                   	push   %edi
  806cd8:	56                   	push   %esi
  806cd9:	53                   	push   %ebx
  806cda:	83 ec 38             	sub    $0x38,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  806cdd:	8b 45 08             	mov    0x8(%ebp),%eax
  806ce0:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  806ce3:	0f b7 03             	movzwl (%ebx),%eax
  806ce6:	50                   	push   %eax
  806ce7:	e8 85 0a 00 00       	call   807771 <ntohs>
  806cec:	66 c1 e8 08          	shr    $0x8,%ax
  806cf0:	83 e0 0f             	and    $0xf,%eax
  806cf3:	83 c4 10             	add    $0x10,%esp
  806cf6:	83 f8 05             	cmp    $0x5,%eax
  806cf9:	0f 85 dc 01 00 00    	jne    806edb <ip_reass+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806cff:	83 ec 0c             	sub    $0xc,%esp
  806d02:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806d06:	50                   	push   %eax
  806d07:	e8 65 0a 00 00       	call   807771 <ntohs>
  806d0c:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806d10:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806d14:	89 04 24             	mov    %eax,(%esp)
  806d17:	e8 55 0a 00 00       	call   807771 <ntohs>
  806d1c:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  806d20:	0f b7 03             	movzwl (%ebx),%eax
  806d23:	89 04 24             	mov    %eax,(%esp)
  806d26:	e8 46 0a 00 00       	call   807771 <ntohs>
  806d2b:	66 89 45 d8          	mov    %ax,-0x28(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  806d2f:	83 c4 04             	add    $0x4,%esp
  806d32:	ff 75 08             	pushl  0x8(%ebp)
  806d35:	e8 9a df ff ff       	call   804cd4 <pbuf_clen>
  806d3a:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  806d3d:	0f b6 f0             	movzbl %al,%esi
  806d40:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d47:	01 f0                	add    %esi,%eax
  806d49:	83 c4 10             	add    $0x10,%esp
  806d4c:	83 f8 0a             	cmp    $0xa,%eax
  806d4f:	7f 0d                	jg     806d5e <ip_reass+0x8a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d51:	8b 3d e0 49 b3 00    	mov    0xb349e0,%edi
  struct ip_reassdata *ipr_prev = NULL;
  806d57:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d5c:	eb 28                	jmp    806d86 <ip_reass+0xb2>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806d5e:	89 f2                	mov    %esi,%edx
  806d60:	89 d8                	mov    %ebx,%eax
  806d62:	e8 9e fe ff ff       	call   806c05 <ip_reass_remove_oldest_datagram>
  806d67:	85 c0                	test   %eax,%eax
  806d69:	0f 84 6c 01 00 00    	je     806edb <ip_reass+0x207>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  806d6f:	0f b7 05 dc 49 b3 00 	movzwl 0xb349dc,%eax
  806d76:	01 f0                	add    %esi,%eax
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  806d78:	83 f8 0a             	cmp    $0xa,%eax
  806d7b:	7e d4                	jle    806d51 <ip_reass+0x7d>
  806d7d:	e9 59 01 00 00       	jmp    806edb <ip_reass+0x207>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  806d82:	89 f8                	mov    %edi,%eax
  806d84:	8b 3f                	mov    (%edi),%edi
  806d86:	85 ff                	test   %edi,%edi
  806d88:	0f 84 f5 00 00 00    	je     806e83 <ip_reass+0x1af>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  806d8e:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  806d91:	39 4f 14             	cmp    %ecx,0x14(%edi)
  806d94:	75 ec                	jne    806d82 <ip_reass+0xae>
  806d96:	8b 53 10             	mov    0x10(%ebx),%edx
  806d99:	39 57 18             	cmp    %edx,0x18(%edi)
  806d9c:	75 e4                	jne    806d82 <ip_reass+0xae>
  806d9e:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  806da2:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  806da6:	75 da                	jne    806d82 <ip_reass+0xae>
  806da8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806dab:	83 ec 0c             	sub    $0xc,%esp
  806dae:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806db2:	50                   	push   %eax
  806db3:	e8 b9 09 00 00       	call   807771 <ntohs>
  806db8:	83 c4 10             	add    $0x10,%esp
  806dbb:	66 a9 ff 1f          	test   $0x1fff,%ax
  806dbf:	0f 84 4b 01 00 00    	je     806f10 <ip_reass+0x23c>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  806dc5:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806dc9:	66 01 05 dc 49 b3 00 	add    %ax,0xb349dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  806dd0:	83 ec 0c             	sub    $0xc,%esp
  806dd3:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806dd7:	50                   	push   %eax
  806dd8:	e8 94 09 00 00       	call   807771 <ntohs>
  806ddd:	83 c4 10             	add    $0x10,%esp
  806de0:	f6 c4 20             	test   $0x20,%ah
  806de3:	75 20                	jne    806e05 <ip_reass+0x131>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  806de5:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    ipr->datagram_len = offset + len;
  806de9:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  806ded:	0f b7 75 de          	movzwl -0x22(%ebp),%esi
  806df1:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806df4:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  806df8:	66 c1 ea 06          	shr    $0x6,%dx
  806dfc:	83 e2 3c             	and    $0x3c,%edx
    ipr->datagram_len = offset + len;
  806dff:	29 d0                	sub    %edx,%eax
  806e01:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  fraghdr = (struct ip_hdr*)new_p->payload; 
  806e05:	8b 45 08             	mov    0x8(%ebp),%eax
  806e08:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e0b:	83 ec 0c             	sub    $0xc,%esp
  806e0e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  806e12:	50                   	push   %eax
  806e13:	e8 59 09 00 00       	call   807771 <ntohs>
  806e18:	89 c6                	mov    %eax,%esi
  806e1a:	0f b7 03             	movzwl (%ebx),%eax
  806e1d:	89 04 24             	mov    %eax,(%esp)
  806e20:	e8 4c 09 00 00       	call   807771 <ntohs>
  806e25:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  806e29:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  806e2d:	89 04 24             	mov    %eax,(%esp)
  806e30:	e8 3c 09 00 00       	call   807771 <ntohs>
  806e35:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  iprh = (struct ip_reass_helper*)new_p->payload;
  806e3c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  806e3f:	8b 51 04             	mov    0x4(%ecx),%edx
  806e42:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  806e45:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  806e4b:	66 89 5a 04          	mov    %bx,0x4(%edx)
  iprh->end = offset + len;
  806e4f:	01 de                	add    %ebx,%esi
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  806e51:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  806e55:	66 c1 e8 06          	shr    $0x6,%ax
  806e59:	83 e0 3c             	and    $0x3c,%eax
  iprh->end = offset + len;
  806e5c:	29 c6                	sub    %eax,%esi
  806e5e:	66 89 75 de          	mov    %si,-0x22(%ebp)
  806e62:	66 89 72 06          	mov    %si,0x6(%edx)
  for (q = ipr->p; q != NULL;) {
  806e66:	8b 47 04             	mov    0x4(%edi),%eax
  806e69:	89 45 d8             	mov    %eax,-0x28(%ebp)
  806e6c:	83 c4 10             	add    $0x10,%esp
  int valid = 1;
  806e6f:	b9 01 00 00 00       	mov    $0x1,%ecx
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  806e74:	be 00 00 00 00       	mov    $0x0,%esi
  806e79:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  806e7c:	89 cf                	mov    %ecx,%edi
  806e7e:	e9 25 01 00 00       	jmp    806fa8 <ip_reass+0x2d4>
  806e83:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  ipr = memp_malloc(MEMP_REASSDATA);
  806e86:	83 ec 0c             	sub    $0xc,%esp
  806e89:	6a 05                	push   $0x5
  806e8b:	e8 57 d6 ff ff       	call   8044e7 <memp_malloc>
  806e90:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  806e92:	83 c4 10             	add    $0x10,%esp
  806e95:	85 c0                	test   %eax,%eax
  806e97:	74 35                	je     806ece <ip_reass+0x1fa>
  memset(ipr, 0, sizeof(struct ip_reassdata));
  806e99:	83 ec 04             	sub    $0x4,%esp
  806e9c:	6a 20                	push   $0x20
  806e9e:	6a 00                	push   $0x0
  806ea0:	57                   	push   %edi
  806ea1:	e8 8e 81 00 00       	call   80f034 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  806ea6:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)
  ipr->next = reassdatagrams;
  806eaa:	a1 e0 49 b3 00       	mov    0xb349e0,%eax
  806eaf:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  806eb1:	89 3d e0 49 b3 00    	mov    %edi,0xb349e0
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  806eb7:	83 c4 0c             	add    $0xc,%esp
  806eba:	6a 14                	push   $0x14
  806ebc:	53                   	push   %ebx
  806ebd:	8d 47 08             	lea    0x8(%edi),%eax
  806ec0:	50                   	push   %eax
  806ec1:	e8 18 82 00 00       	call   80f0de <memcpy>
  806ec6:	83 c4 10             	add    $0x10,%esp
  806ec9:	e9 f7 fe ff ff       	jmp    806dc5 <ip_reass+0xf1>
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  806ece:	89 f2                	mov    %esi,%edx
  806ed0:	89 d8                	mov    %ebx,%eax
  806ed2:	e8 2e fd ff ff       	call   806c05 <ip_reass_remove_oldest_datagram>
  806ed7:	39 c6                	cmp    %eax,%esi
  806ed9:	7e 20                	jle    806efb <ip_reass+0x227>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  806edb:	83 ec 0c             	sub    $0xc,%esp
  806ede:	ff 75 08             	pushl  0x8(%ebp)
  806ee1:	e8 a4 d9 ff ff       	call   80488a <pbuf_free>
  return NULL;
  806ee6:	83 c4 10             	add    $0x10,%esp
  806ee9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  806ef0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ef3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  806ef6:	5b                   	pop    %ebx
  806ef7:	5e                   	pop    %esi
  806ef8:	5f                   	pop    %edi
  806ef9:	5d                   	pop    %ebp
  806efa:	c3                   	ret    
      ipr = memp_malloc(MEMP_REASSDATA);
  806efb:	83 ec 0c             	sub    $0xc,%esp
  806efe:	6a 05                	push   $0x5
  806f00:	e8 e2 d5 ff ff       	call   8044e7 <memp_malloc>
  806f05:	89 c7                	mov    %eax,%edi
    if (ipr == NULL)
  806f07:	83 c4 10             	add    $0x10,%esp
  806f0a:	85 c0                	test   %eax,%eax
  806f0c:	75 8b                	jne    806e99 <ip_reass+0x1c5>
  806f0e:	eb cb                	jmp    806edb <ip_reass+0x207>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  806f10:	83 ec 0c             	sub    $0xc,%esp
  806f13:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  806f17:	50                   	push   %eax
  806f18:	e8 54 08 00 00       	call   807771 <ntohs>
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  806f1d:	83 c4 10             	add    $0x10,%esp
  806f20:	66 a9 ff 1f          	test   $0x1fff,%ax
  806f24:	0f 84 9b fe ff ff    	je     806dc5 <ip_reass+0xf1>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  806f2a:	83 ec 04             	sub    $0x4,%esp
  806f2d:	6a 14                	push   $0x14
  806f2f:	53                   	push   %ebx
  806f30:	8d 47 08             	lea    0x8(%edi),%eax
  806f33:	50                   	push   %eax
  806f34:	e8 a5 81 00 00       	call   80f0de <memcpy>
  806f39:	83 c4 10             	add    $0x10,%esp
  806f3c:	e9 84 fe ff ff       	jmp    806dc5 <ip_reass+0xf1>
  806f41:	89 7d d0             	mov    %edi,-0x30(%ebp)
  806f44:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      iprh->next_pbuf = q;
  806f47:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f4a:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  806f4c:	85 f6                	test   %esi,%esi
  806f4e:	74 4c                	je     806f9c <ip_reass+0x2c8>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  806f50:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  806f54:	0f 82 c5 01 00 00    	jb     80711f <ip_reass+0x44b>
  806f5a:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  806f5e:	66 3b 42 04          	cmp    0x4(%edx),%ax
  806f62:	0f 87 b7 01 00 00    	ja     80711f <ip_reass+0x44b>
        iprh_prev->next_pbuf = new_p;
  806f68:	8b 45 08             	mov    0x8(%ebp),%eax
  806f6b:	89 06                	mov    %eax,(%esi)
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  806f6d:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  806f71:	0f 84 cb 01 00 00    	je     807142 <ip_reass+0x46e>
    if (valid) {
  806f77:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  806f7b:	0f 84 c1 01 00 00    	je     807142 <ip_reass+0x46e>
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  806f81:	8b 4f 04             	mov    0x4(%edi),%ecx
  806f84:	8b 59 04             	mov    0x4(%ecx),%ebx
  806f87:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  806f8c:	0f 85 b0 01 00 00    	jne    807142 <ip_reass+0x46e>
        q = iprh->next_pbuf;
  806f92:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806f95:	8b 16                	mov    (%esi),%edx
  806f97:	e9 85 00 00 00       	jmp    807021 <ip_reass+0x34d>
        ipr->p = new_p;
  806f9c:	8b 45 08             	mov    0x8(%ebp),%eax
  806f9f:	89 47 04             	mov    %eax,0x4(%edi)
  806fa2:	eb c9                	jmp    806f6d <ip_reass+0x299>
    q = iprh_tmp->next_pbuf;
  806fa4:	8b 02                	mov    (%edx),%eax
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806fa6:	89 d6                	mov    %edx,%esi
  for (q = ipr->p; q != NULL;) {
  806fa8:	85 c0                	test   %eax,%eax
  806faa:	0f 84 c8 01 00 00    	je     807178 <ip_reass+0x4a4>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  806fb0:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  806fb3:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  806fb7:	66 39 cb             	cmp    %cx,%bx
  806fba:	72 85                	jb     806f41 <ip_reass+0x26d>
    } else if(iprh->start == iprh_tmp->start) {
  806fbc:	0f 84 5d 01 00 00    	je     80711f <ip_reass+0x44b>
    } else if(iprh->start < iprh_tmp->end) {
  806fc2:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  806fc6:	0f 82 53 01 00 00    	jb     80711f <ip_reass+0x44b>
      if (iprh_prev != NULL) {
  806fcc:	85 f6                	test   %esi,%esi
  806fce:	74 d4                	je     806fa4 <ip_reass+0x2d0>
          valid = 0;
  806fd0:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  806fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  806fd9:	0f 45 f8             	cmovne %eax,%edi
  806fdc:	eb c6                	jmp    806fa4 <ip_reass+0x2d0>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  806fde:	83 ec 04             	sub    $0x4,%esp
  806fe1:	68 60 24 81 00       	push   $0x812460
  806fe6:	68 83 01 00 00       	push   $0x183
  806feb:	68 0a 24 81 00       	push   $0x81240a
  806ff0:	e8 a4 76 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  806ff5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  806ff9:	75 0b                	jne    807006 <ip_reass+0x332>
      ipr->p = new_p;
  806ffb:	8b 45 08             	mov    0x8(%ebp),%eax
  806ffe:	89 47 04             	mov    %eax,0x4(%edi)
  807001:	e9 67 ff ff ff       	jmp    806f6d <ip_reass+0x299>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807006:	83 ec 04             	sub    $0x4,%esp
  807009:	68 8c 24 81 00       	push   $0x81248c
  80700e:	68 8c 01 00 00       	push   $0x18c
  807013:	68 0a 24 81 00       	push   $0x81240a
  807018:	e8 7c 76 00 00       	call   80e699 <_panic>
          q = iprh->next_pbuf;
  80701d:	8b 10                	mov    (%eax),%edx
          iprh = (struct ip_reass_helper*)q->payload;
  80701f:	89 c6                	mov    %eax,%esi
        while (q != NULL) {
  807021:	85 d2                	test   %edx,%edx
  807023:	74 12                	je     807037 <ip_reass+0x363>
          iprh = (struct ip_reass_helper*)q->payload;
  807025:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  807028:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  80702c:	66 39 56 06          	cmp    %dx,0x6(%esi)
  807030:	74 eb                	je     80701d <ip_reass+0x349>
  807032:	e9 0b 01 00 00       	jmp    807142 <ip_reass+0x46e>
  807037:	89 75 e0             	mov    %esi,-0x20(%ebp)
          LWIP_ASSERT("sanity check",
  80703a:	39 f3                	cmp    %esi,%ebx
  80703c:	0f 84 98 00 00 00    	je     8070da <ip_reass+0x406>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  807042:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807045:	83 38 00             	cmpl   $0x0,(%eax)
  807048:	0f 85 a3 00 00 00    	jne    8070f1 <ip_reass+0x41d>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80704e:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807052:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807055:	66 39 46 06          	cmp    %ax,0x6(%esi)
  807059:	0f 85 a9 00 00 00    	jne    807108 <ip_reass+0x434>
    ipr->datagram_len += IP_HLEN;
  80705f:	83 c0 14             	add    $0x14,%eax
  807062:	66 89 47 1c          	mov    %ax,0x1c(%edi)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  807066:	8b 71 04             	mov    0x4(%ecx),%esi
  807069:	8b 1e                	mov    (%esi),%ebx
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80706b:	83 ec 04             	sub    $0x4,%esp
  80706e:	6a 14                	push   $0x14
  807070:	8d 47 08             	lea    0x8(%edi),%eax
  807073:	50                   	push   %eax
  807074:	56                   	push   %esi
  807075:	e8 64 80 00 00       	call   80f0de <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80707a:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80707e:	89 04 24             	mov    %eax,(%esp)
  807081:	e8 de 06 00 00       	call   807764 <htons>
  807086:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  80708a:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  807090:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807096:	83 c4 08             	add    $0x8,%esp
  807099:	6a 14                	push   $0x14
  80709b:	56                   	push   %esi
  80709c:	e8 95 05 00 00       	call   807636 <inet_chksum>
  8070a1:	66 89 46 0a          	mov    %ax,0xa(%esi)
    p = ipr->p;
  8070a5:	8b 47 04             	mov    0x4(%edi),%eax
  8070a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    while(r != NULL) {
  8070ab:	83 c4 10             	add    $0x10,%esp
  8070ae:	89 7d e0             	mov    %edi,-0x20(%ebp)
  8070b1:	89 c7                	mov    %eax,%edi
  8070b3:	85 db                	test   %ebx,%ebx
  8070b5:	0f 84 93 00 00 00    	je     80714e <ip_reass+0x47a>
      iprh = (struct ip_reass_helper*)r->payload;
  8070bb:	8b 73 04             	mov    0x4(%ebx),%esi
      pbuf_header(r, -IP_HLEN);
  8070be:	83 ec 08             	sub    $0x8,%esp
  8070c1:	6a ec                	push   $0xffffffec
  8070c3:	53                   	push   %ebx
  8070c4:	e8 f4 d6 ff ff       	call   8047bd <pbuf_header>
      pbuf_cat(p, r);
  8070c9:	83 c4 08             	add    $0x8,%esp
  8070cc:	53                   	push   %ebx
  8070cd:	57                   	push   %edi
  8070ce:	e8 2a dc ff ff       	call   804cfd <pbuf_cat>
      r = iprh->next_pbuf;
  8070d3:	8b 1e                	mov    (%esi),%ebx
  8070d5:	83 c4 10             	add    $0x10,%esp
  8070d8:	eb d9                	jmp    8070b3 <ip_reass+0x3df>
          LWIP_ASSERT("sanity check",
  8070da:	83 ec 04             	sub    $0x4,%esp
  8070dd:	68 7e 24 81 00       	push   $0x81247e
  8070e2:	68 ae 01 00 00       	push   $0x1ae
  8070e7:	68 0a 24 81 00       	push   $0x81240a
  8070ec:	e8 a8 75 00 00       	call   80e699 <_panic>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8070f1:	83 ec 04             	sub    $0x4,%esp
  8070f4:	68 c4 24 81 00       	push   $0x8124c4
  8070f9:	68 b0 01 00 00       	push   $0x1b0
  8070fe:	68 0a 24 81 00       	push   $0x81240a
  807103:	e8 91 75 00 00       	call   80e699 <_panic>
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807108:	83 ec 04             	sub    $0x4,%esp
  80710b:	68 e8 24 81 00       	push   $0x8124e8
  807110:	68 b2 01 00 00       	push   $0x1b2
  807115:	68 0a 24 81 00       	push   $0x81240a
  80711a:	e8 7a 75 00 00       	call   80e699 <_panic>
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80711f:	83 ec 0c             	sub    $0xc,%esp
  807122:	ff 75 08             	pushl  0x8(%ebp)
  807125:	e8 aa db ff ff       	call   804cd4 <pbuf_clen>
  80712a:	0f b6 c0             	movzbl %al,%eax
  80712d:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
  pbuf_free(new_p);
  807134:	83 c4 04             	add    $0x4,%esp
  807137:	ff 75 08             	pushl  0x8(%ebp)
  80713a:	e8 4b d7 ff ff       	call   80488a <pbuf_free>
  80713f:	83 c4 10             	add    $0x10,%esp
  return NULL;
  807142:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807149:	e9 a2 fd ff ff       	jmp    806ef0 <ip_reass+0x21c>
  80714e:	8b 7d e0             	mov    -0x20(%ebp),%edi
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  807151:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807154:	89 f8                	mov    %edi,%eax
  807156:	e8 4e f9 ff ff       	call   806aa9 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
  80715b:	83 ec 0c             	sub    $0xc,%esp
  80715e:	ff 75 e4             	pushl  -0x1c(%ebp)
  807161:	e8 6e db ff ff       	call   804cd4 <pbuf_clen>
  807166:	0f b6 c0             	movzbl %al,%eax
  807169:	66 29 05 dc 49 b3 00 	sub    %ax,0xb349dc
    return p;
  807170:	83 c4 10             	add    $0x10,%esp
  807173:	e9 78 fd ff ff       	jmp    806ef0 <ip_reass+0x21c>
  807178:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80717b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    if (iprh_prev != NULL) {
  80717e:	85 f6                	test   %esi,%esi
  807180:	0f 84 6f fe ff ff    	je     806ff5 <ip_reass+0x321>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807186:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80718a:	66 39 c3             	cmp    %ax,%bx
  80718d:	0f 82 4b fe ff ff    	jb     806fde <ip_reass+0x30a>
      iprh_prev->next_pbuf = new_p;
  807193:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807196:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807198:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80719b:	66 3b 46 04          	cmp    0x4(%esi),%ax
  80719f:	75 a1                	jne    807142 <ip_reass+0x46e>
  8071a1:	e9 c7 fd ff ff       	jmp    806f6d <ip_reass+0x299>

008071a6 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8071a6:	55                   	push   %ebp
  8071a7:	89 e5                	mov    %esp,%ebp
  8071a9:	57                   	push   %edi
  8071aa:	56                   	push   %esi
  8071ab:	53                   	push   %ebx
  8071ac:	83 ec 30             	sub    $0x30,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8071af:	8b 45 0c             	mov    0xc(%ebp),%eax
  8071b2:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8071b6:	6a 02                	push   $0x2
  8071b8:	6a 00                	push   $0x0
  8071ba:	6a 02                	push   $0x2
  8071bc:	e8 8f d7 ff ff       	call   804950 <pbuf_alloc>
  8071c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8071c4:	83 c4 10             	add    $0x10,%esp
  8071c7:	85 c0                	test   %eax,%eax
  8071c9:	0f 84 c2 00 00 00    	je     807291 <ip_frag+0xeb>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8071cf:	66 89 70 0a          	mov    %si,0xa(%eax)
  8071d3:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8071d7:	bb 03 44 b3 00       	mov    $0xb34403,%ebx
  8071dc:	83 e3 fc             	and    $0xfffffffc,%ebx
  8071df:	89 58 04             	mov    %ebx,0x4(%eax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  8071e2:	83 ec 04             	sub    $0x4,%esp
  8071e5:	6a 14                	push   $0x14
  8071e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8071ea:	ff 70 04             	pushl  0x4(%eax)
  8071ed:	53                   	push   %ebx
  8071ee:	e8 eb 7e 00 00       	call   80f0de <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  8071f3:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8071f7:	89 04 24             	mov    %eax,(%esp)
  8071fa:	e8 72 05 00 00       	call   807771 <ntohs>
  ofo = tmp & IP_OFFMASK;
  8071ff:	89 c7                	mov    %eax,%edi
  807201:	66 81 e7 ff 1f       	and    $0x1fff,%di
  807206:	66 89 7d e4          	mov    %di,-0x1c(%ebp)
  omf = tmp & IP_MF;
  80720a:	66 25 00 20          	and    $0x2000,%ax
  80720e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  left = p->tot_len - IP_HLEN;
  807212:	8b 45 08             	mov    0x8(%ebp),%eax
  807215:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807219:	8d 78 ec             	lea    -0x14(%eax),%edi

  nfb = (mtu - IP_HLEN) / 8;
  80721c:	0f b7 f6             	movzwl %si,%esi
  80721f:	8d 46 f3             	lea    -0xd(%esi),%eax
  807222:	83 c4 10             	add    $0x10,%esp
  807225:	89 f2                	mov    %esi,%edx
  807227:	83 ea 14             	sub    $0x14,%edx
  80722a:	0f 49 c2             	cmovns %edx,%eax
  80722d:	c1 f8 03             	sar    $0x3,%eax
  807230:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807234:	c1 e0 03             	shl    $0x3,%eax
  807237:	66 89 45 d0          	mov    %ax,-0x30(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80723b:	0f b7 c8             	movzwl %ax,%ecx
  80723e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807241:	83 c0 14             	add    $0x14,%eax
  807244:	0f b7 c0             	movzwl %ax,%eax
  807247:	89 45 c8             	mov    %eax,-0x38(%ebp)
  u16_t poff = IP_HLEN;
  80724a:	66 c7 45 e6 14 00    	movw   $0x14,-0x1a(%ebp)
    last = (left <= mtu - IP_HLEN);
  807250:	8d 46 ed             	lea    -0x13(%esi),%eax
  807253:	89 45 d8             	mov    %eax,-0x28(%ebp)
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807256:	8d 43 14             	lea    0x14(%ebx),%eax
  807259:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (left) {
  80725c:	e9 e3 00 00 00       	jmp    807344 <ip_frag+0x19e>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  807261:	83 ec 0c             	sub    $0xc,%esp
  807264:	ff 75 dc             	pushl  -0x24(%ebp)
  807267:	e8 1e d6 ff ff       	call   80488a <pbuf_free>
      return ERR_MEM;
  80726c:	83 c4 10             	add    $0x10,%esp
  80726f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807274:	eb 13                	jmp    807289 <ip_frag+0xe3>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  807276:	83 ec 0c             	sub    $0xc,%esp
  807279:	ff 75 dc             	pushl  -0x24(%ebp)
  80727c:	e8 09 d6 ff ff       	call   80488a <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  807281:	83 c4 10             	add    $0x10,%esp
  807284:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807289:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80728c:	5b                   	pop    %ebx
  80728d:	5e                   	pop    %esi
  80728e:	5f                   	pop    %edi
  80728f:	5d                   	pop    %ebp
  807290:	c3                   	ret    
    return ERR_MEM;
  807291:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807296:	eb f1                	jmp    807289 <ip_frag+0xe3>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807298:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80729c:	52                   	push   %edx
  80729d:	50                   	push   %eax
  80729e:	ff 75 d4             	pushl  -0x2c(%ebp)
  8072a1:	ff 75 08             	pushl  0x8(%ebp)
  8072a4:	e8 5d dd ff ff       	call   805006 <pbuf_copy_partial>
  8072a9:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8072ad:	0f b7 f6             	movzwl %si,%esi
  8072b0:	89 34 24             	mov    %esi,(%esp)
  8072b3:	e8 ac 04 00 00       	call   807764 <htons>
  8072b8:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8072bc:	8d 77 14             	lea    0x14(%edi),%esi
  8072bf:	0f b7 f6             	movzwl %si,%esi
  8072c2:	89 34 24             	mov    %esi,(%esp)
  8072c5:	e8 9a 04 00 00       	call   807764 <htons>
  8072ca:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  8072ce:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8072d4:	83 c4 08             	add    $0x8,%esp
  8072d7:	6a 14                	push   $0x14
  8072d9:	53                   	push   %ebx
  8072da:	e8 57 03 00 00       	call   807636 <inet_chksum>
  8072df:	66 89 43 0a          	mov    %ax,0xa(%ebx)
      pbuf_realloc(rambuf, left + IP_HLEN);
  8072e3:	83 c4 08             	add    $0x8,%esp
  8072e6:	56                   	push   %esi
  8072e7:	ff 75 dc             	pushl  -0x24(%ebp)
  8072ea:	e8 d3 d8 ff ff       	call   804bc2 <pbuf_realloc>
  8072ef:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8072f2:	66 89 7d e2          	mov    %di,-0x1e(%ebp)
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  8072f6:	83 ec 04             	sub    $0x4,%esp
  8072f9:	6a 00                	push   $0x0
  8072fb:	6a 00                	push   $0x0
  8072fd:	6a 02                	push   $0x2
  8072ff:	e8 4c d6 ff ff       	call   804950 <pbuf_alloc>
  807304:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  807306:	83 c4 10             	add    $0x10,%esp
  807309:	85 c0                	test   %eax,%eax
  80730b:	0f 84 50 ff ff ff    	je     807261 <ip_frag+0xbb>
      pbuf_chain(header, rambuf);
  807311:	83 ec 08             	sub    $0x8,%esp
  807314:	ff 75 dc             	pushl  -0x24(%ebp)
  807317:	50                   	push   %eax
  807318:	e8 4e da ff ff       	call   804d6b <pbuf_chain>
      netif->output(netif, header, dest);
  80731d:	83 c4 0c             	add    $0xc,%esp
  807320:	ff 75 10             	pushl  0x10(%ebp)
  807323:	56                   	push   %esi
  807324:	ff 75 0c             	pushl  0xc(%ebp)
  807327:	8b 45 0c             	mov    0xc(%ebp),%eax
  80732a:	ff 50 14             	call   *0x14(%eax)
      pbuf_free(header);
  80732d:	89 34 24             	mov    %esi,(%esp)
  807330:	e8 55 d5 ff ff       	call   80488a <pbuf_free>
    left -= cop;
  807335:	66 2b 7d e2          	sub    -0x1e(%ebp),%di
    ofo += nfb;
  807339:	0f b7 4d d2          	movzwl -0x2e(%ebp),%ecx
  80733d:	66 01 4d e4          	add    %cx,-0x1c(%ebp)
  807341:	83 c4 10             	add    $0x10,%esp
  while (left) {
  807344:	66 85 ff             	test   %di,%di
  807347:	0f 84 29 ff ff ff    	je     807276 <ip_frag+0xd0>
    last = (left <= mtu - IP_HLEN);
  80734d:	0f b7 c7             	movzwl %di,%eax
    tmp = omf | (IP_OFFMASK & (ofo));
  807350:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  807354:	66 81 e6 ff 1f       	and    $0x1fff,%si
  807359:	66 0b 75 e0          	or     -0x20(%ebp),%si
    if (!last)
  80735d:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807360:	0f 8f 32 ff ff ff    	jg     807298 <ip_frag+0xf2>
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  807366:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80736a:	50                   	push   %eax
  80736b:	ff 75 cc             	pushl  -0x34(%ebp)
  80736e:	ff 75 d4             	pushl  -0x2c(%ebp)
  807371:	ff 75 08             	pushl  0x8(%ebp)
  807374:	e8 8d dc ff ff       	call   805006 <pbuf_copy_partial>
  807379:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
      tmp = tmp | IP_MF;
  80737d:	66 81 ce 00 20       	or     $0x2000,%si
    IPH_OFFSET_SET(iphdr, htons(tmp));
  807382:	0f b7 f6             	movzwl %si,%esi
  807385:	89 34 24             	mov    %esi,(%esp)
  807388:	e8 d7 03 00 00       	call   807764 <htons>
  80738d:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  807391:	83 c4 04             	add    $0x4,%esp
  807394:	ff 75 c8             	pushl  -0x38(%ebp)
  807397:	e8 c8 03 00 00       	call   807764 <htons>
  80739c:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  8073a0:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8073a6:	83 c4 08             	add    $0x8,%esp
  8073a9:	6a 14                	push   $0x14
  8073ab:	53                   	push   %ebx
  8073ac:	e8 85 02 00 00       	call   807636 <inet_chksum>
  8073b1:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  8073b5:	83 c4 10             	add    $0x10,%esp
    cop = last ? left : nfb * 8;
  8073b8:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  8073bc:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  8073c0:	e9 31 ff ff ff       	jmp    8072f6 <ip_frag+0x150>

008073c5 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8073c5:	55                   	push   %ebp
  8073c6:	89 e5                	mov    %esp,%ebp
  8073c8:	57                   	push   %edi
  8073c9:	56                   	push   %esi
  8073ca:	53                   	push   %ebx
  8073cb:	83 ec 1c             	sub    $0x1c,%esp
  8073ce:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8073d1:	89 d7                	mov    %edx,%edi
  8073d3:	66 d1 ef             	shr    %di
  8073d6:	0f b7 d7             	movzwl %di,%edx
  8073d9:	8d 34 50             	lea    (%eax,%edx,2),%esi
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8073dc:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8073e1:	39 f0                	cmp    %esi,%eax
  8073e3:	74 18                	je     8073fd <lwip_standard_chksum+0x38>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8073e5:	0f b6 10             	movzbl (%eax),%edx
  8073e8:	89 d1                	mov    %edx,%ecx
  8073ea:	c1 e1 08             	shl    $0x8,%ecx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8073ed:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  8073f1:	09 ca                	or     %ecx,%edx
  8073f3:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8073f6:	0f b7 d2             	movzwl %dx,%edx
  8073f9:	01 d3                	add    %edx,%ebx
  8073fb:	eb e4                	jmp    8073e1 <lwip_standard_chksum+0x1c>
    len -= 2;
  }
  if (len > 0) {
  8073fd:	01 ff                	add    %edi,%edi
  8073ff:	66 3b 7d e4          	cmp    -0x1c(%ebp),%di
  807403:	74 0b                	je     807410 <lwip_standard_chksum+0x4b>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  807405:	0f b6 00             	movzbl (%eax),%eax
  807408:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  80740b:	0f b7 c0             	movzwl %ax,%eax
  80740e:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807410:	89 d8                	mov    %ebx,%eax
  807412:	c1 e8 10             	shr    $0x10,%eax
  807415:	0f b7 db             	movzwl %bx,%ebx
  807418:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  80741a:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807420:	74 0a                	je     80742c <lwip_standard_chksum+0x67>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807422:	89 d8                	mov    %ebx,%eax
  807424:	c1 e8 10             	shr    $0x10,%eax
  807427:	0f b7 db             	movzwl %bx,%ebx
  80742a:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80742c:	83 ec 0c             	sub    $0xc,%esp
  80742f:	0f b7 db             	movzwl %bx,%ebx
  807432:	53                   	push   %ebx
  807433:	e8 2c 03 00 00       	call   807764 <htons>
}
  807438:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80743b:	5b                   	pop    %ebx
  80743c:	5e                   	pop    %esi
  80743d:	5f                   	pop    %edi
  80743e:	5d                   	pop    %ebp
  80743f:	c3                   	ret    

00807440 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807440:	55                   	push   %ebp
  807441:	89 e5                	mov    %esp,%ebp
  807443:	57                   	push   %edi
  807444:	56                   	push   %esi
  807445:	53                   	push   %ebx
  807446:	83 ec 1c             	sub    $0x1c,%esp
  807449:	8b 75 08             	mov    0x8(%ebp),%esi
  80744c:	8b 45 14             	mov    0x14(%ebp),%eax
  80744f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807452:	8b 45 18             	mov    0x18(%ebp),%eax
  807455:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807458:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  80745d:	bb 00 00 00 00       	mov    $0x0,%ebx
  807462:	89 f8                	mov    %edi,%eax
  807464:	89 df                	mov    %ebx,%edi
  807466:	89 c3                	mov    %eax,%ebx
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807468:	eb 02                	jmp    80746c <inet_chksum_pseudo+0x2c>
  80746a:	8b 36                	mov    (%esi),%esi
  80746c:	85 f6                	test   %esi,%esi
  80746e:	74 3d                	je     8074ad <inet_chksum_pseudo+0x6d>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807470:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807474:	8b 46 04             	mov    0x4(%esi),%eax
  807477:	e8 49 ff ff ff       	call   8073c5 <lwip_standard_chksum>
  80747c:	0f b7 c0             	movzwl %ax,%eax
  80747f:	01 f8                	add    %edi,%eax
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807481:	89 c7                	mov    %eax,%edi
  807483:	c1 ef 10             	shr    $0x10,%edi
  807486:	0f b7 c0             	movzwl %ax,%eax
  807489:	01 c7                	add    %eax,%edi
    if (q->len % 2 != 0) {
  80748b:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  80748f:	74 d9                	je     80746a <inet_chksum_pseudo+0x2a>
      swapped = 1 - swapped;
  807491:	b8 01 00 00 00       	mov    $0x1,%eax
  807496:	29 d8                	sub    %ebx,%eax
  807498:	89 c3                	mov    %eax,%ebx
      acc = SWAP_BYTES_IN_WORD(acc);
  80749a:	89 fa                	mov    %edi,%edx
  80749c:	c1 e2 08             	shl    $0x8,%edx
  80749f:	0f b7 d2             	movzwl %dx,%edx
  8074a2:	89 f8                	mov    %edi,%eax
  8074a4:	0f b6 c4             	movzbl %ah,%eax
  8074a7:	09 c2                	or     %eax,%edx
  8074a9:	89 d7                	mov    %edx,%edi
  8074ab:	eb bd                	jmp    80746a <inet_chksum_pseudo+0x2a>
  8074ad:	89 d8                	mov    %ebx,%eax
  8074af:	89 fb                	mov    %edi,%ebx
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8074b1:	84 c0                	test   %al,%al
  8074b3:	74 0d                	je     8074c2 <inet_chksum_pseudo+0x82>
    acc = SWAP_BYTES_IN_WORD(acc);
  8074b5:	89 f8                	mov    %edi,%eax
  8074b7:	c1 e0 08             	shl    $0x8,%eax
  8074ba:	0f b7 c0             	movzwl %ax,%eax
  8074bd:	0f b6 df             	movzbl %bh,%ebx
  8074c0:	09 c3                	or     %eax,%ebx
  }
  acc += (src->addr & 0xffffUL);
  8074c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074c5:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8074c7:	8b 55 10             	mov    0x10(%ebp),%edx
  8074ca:	8b 12                	mov    (%edx),%edx
  8074cc:	0f b7 ca             	movzwl %dx,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074cf:	c1 ea 10             	shr    $0x10,%edx
  8074d2:	01 ca                	add    %ecx,%edx
  acc += (src->addr & 0xffffUL);
  8074d4:	0f b7 c8             	movzwl %ax,%ecx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074d7:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  8074d9:	c1 e8 10             	shr    $0x10,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  8074dc:	01 d0                	add    %edx,%eax
  8074de:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons((u16_t)proto);
  8074e0:	83 ec 0c             	sub    $0xc,%esp
  8074e3:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8074e7:	50                   	push   %eax
  8074e8:	e8 77 02 00 00       	call   807764 <htons>
  8074ed:	0f b7 c0             	movzwl %ax,%eax
  8074f0:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  8074f2:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8074f6:	89 04 24             	mov    %eax,(%esp)
  8074f9:	e8 66 02 00 00       	call   807764 <htons>
  8074fe:	0f b7 c0             	movzwl %ax,%eax
  807501:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807503:	89 d8                	mov    %ebx,%eax
  807505:	c1 e8 10             	shr    $0x10,%eax
  807508:	0f b7 db             	movzwl %bx,%ebx
  80750b:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  80750d:	89 d8                	mov    %ebx,%eax
  80750f:	c1 e8 10             	shr    $0x10,%eax
  807512:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807514:	f7 d0                	not    %eax
}
  807516:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807519:	5b                   	pop    %ebx
  80751a:	5e                   	pop    %esi
  80751b:	5f                   	pop    %edi
  80751c:	5d                   	pop    %ebp
  80751d:	c3                   	ret    

0080751e <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80751e:	55                   	push   %ebp
  80751f:	89 e5                	mov    %esp,%ebp
  807521:	57                   	push   %edi
  807522:	56                   	push   %esi
  807523:	53                   	push   %ebx
  807524:	83 ec 1c             	sub    $0x1c,%esp
  807527:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80752a:	8b 45 14             	mov    0x14(%ebp),%eax
  80752d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807530:	8b 45 18             	mov    0x18(%ebp),%eax
  807533:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807536:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80753a:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  acc = 0;
  80753e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807545:	eb 19                	jmp    807560 <inet_chksum_pseudo_partial+0x42>
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807547:	83 ec 04             	sub    $0x4,%esp
  80754a:	68 15 25 81 00       	push   $0x812515
  80754f:	68 60 01 00 00       	push   $0x160
  807554:	68 20 25 81 00       	push   $0x812520
  807559:	e8 3b 71 00 00       	call   80e699 <_panic>
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80755e:	8b 1b                	mov    (%ebx),%ebx
  807560:	85 db                	test   %ebx,%ebx
  807562:	74 5c                	je     8075c0 <inet_chksum_pseudo_partial+0xa2>
  807564:	66 85 f6             	test   %si,%si
  807567:	74 57                	je     8075c0 <inet_chksum_pseudo_partial+0xa2>
    chklen = q->len;
  807569:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  80756d:	66 39 fe             	cmp    %di,%si
  807570:	0f 46 fe             	cmovbe %esi,%edi
    acc += LWIP_CHKSUM(q->payload, chklen);
  807573:	0f b7 d7             	movzwl %di,%edx
  807576:	8b 43 04             	mov    0x4(%ebx),%eax
  807579:	e8 47 fe ff ff       	call   8073c5 <lwip_standard_chksum>
  80757e:	0f b7 c0             	movzwl %ax,%eax
  807581:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807584:	29 fe                	sub    %edi,%esi
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807586:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80758b:	77 ba                	ja     807547 <inet_chksum_pseudo_partial+0x29>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80758d:	89 c2                	mov    %eax,%edx
  80758f:	c1 ea 10             	shr    $0x10,%edx
  807592:	0f b7 c0             	movzwl %ax,%eax
  807595:	8d 3c 02             	lea    (%edx,%eax,1),%edi
  807598:	89 7d e4             	mov    %edi,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80759b:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80759f:	74 bd                	je     80755e <inet_chksum_pseudo_partial+0x40>
      swapped = 1 - swapped;
  8075a1:	b8 01 00 00 00       	mov    $0x1,%eax
  8075a6:	2a 45 e3             	sub    -0x1d(%ebp),%al
  8075a9:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8075ac:	89 fa                	mov    %edi,%edx
  8075ae:	c1 e2 08             	shl    $0x8,%edx
  8075b1:	0f b7 d2             	movzwl %dx,%edx
  8075b4:	89 f8                	mov    %edi,%eax
  8075b6:	0f b6 c4             	movzbl %ah,%eax
  8075b9:	09 c2                	or     %eax,%edx
  8075bb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  8075be:	eb 9e                	jmp    80755e <inet_chksum_pseudo_partial+0x40>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8075c0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8075c4:	74 13                	je     8075d9 <inet_chksum_pseudo_partial+0xbb>
    acc = SWAP_BYTES_IN_WORD(acc);
  8075c6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8075c9:	89 c8                	mov    %ecx,%eax
  8075cb:	c1 e0 08             	shl    $0x8,%eax
  8075ce:	0f b7 c0             	movzwl %ax,%eax
  8075d1:	0f b6 d5             	movzbl %ch,%edx
  8075d4:	09 d0                	or     %edx,%eax
  8075d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  8075d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8075dc:	8b 18                	mov    (%eax),%ebx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  8075de:	8b 45 10             	mov    0x10(%ebp),%eax
  8075e1:	8b 00                	mov    (%eax),%eax
  8075e3:	0f b7 d0             	movzwl %ax,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075e6:	c1 e8 10             	shr    $0x10,%eax
  8075e9:	01 d0                	add    %edx,%eax
  acc += (src->addr & 0xffffUL);
  8075eb:	0f b7 d3             	movzwl %bx,%edx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075ee:	01 d0                	add    %edx,%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  8075f0:	c1 eb 10             	shr    $0x10,%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  8075f3:	01 c3                	add    %eax,%ebx
  8075f5:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  8075f8:	83 ec 0c             	sub    $0xc,%esp
  8075fb:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  8075ff:	50                   	push   %eax
  807600:	e8 5f 01 00 00       	call   807764 <htons>
  807605:	0f b7 f0             	movzwl %ax,%esi
  807608:	01 de                	add    %ebx,%esi
  acc += (u32_t)htons(proto_len);
  80760a:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  80760e:	89 04 24             	mov    %eax,(%esp)
  807611:	e8 4e 01 00 00       	call   807764 <htons>
  807616:	0f b7 d8             	movzwl %ax,%ebx
  807619:	01 f3                	add    %esi,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80761b:	89 d8                	mov    %ebx,%eax
  80761d:	c1 e8 10             	shr    $0x10,%eax
  807620:	0f b7 db             	movzwl %bx,%ebx
  807623:	01 c3                	add    %eax,%ebx
  acc = FOLD_U32T(acc);
  807625:	89 d8                	mov    %ebx,%eax
  807627:	c1 e8 10             	shr    $0x10,%eax
  80762a:	01 d8                	add    %ebx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80762c:	f7 d0                	not    %eax
}
  80762e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807631:	5b                   	pop    %ebx
  807632:	5e                   	pop    %esi
  807633:	5f                   	pop    %edi
  807634:	5d                   	pop    %ebp
  807635:	c3                   	ret    

00807636 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807636:	55                   	push   %ebp
  807637:	89 e5                	mov    %esp,%ebp
  807639:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80763c:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807640:	8b 45 08             	mov    0x8(%ebp),%eax
  807643:	e8 7d fd ff ff       	call   8073c5 <lwip_standard_chksum>
  807648:	f7 d0                	not    %eax
}
  80764a:	c9                   	leave  
  80764b:	c3                   	ret    

0080764c <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80764c:	55                   	push   %ebp
  80764d:	89 e5                	mov    %esp,%ebp
  80764f:	57                   	push   %edi
  807650:	56                   	push   %esi
  807651:	53                   	push   %ebx
  807652:	83 ec 0c             	sub    $0xc,%esp
  807655:	8b 75 08             	mov    0x8(%ebp),%esi
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807658:	bf 00 00 00 00       	mov    $0x0,%edi
  acc = 0;
  80765d:	bb 00 00 00 00       	mov    $0x0,%ebx
  for(q = p; q != NULL; q = q->next) {
  807662:	eb 02                	jmp    807666 <inet_chksum_pbuf+0x1a>
  807664:	8b 36                	mov    (%esi),%esi
  807666:	85 f6                	test   %esi,%esi
  807668:	74 3b                	je     8076a5 <inet_chksum_pbuf+0x59>
    acc += LWIP_CHKSUM(q->payload, q->len);
  80766a:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  80766e:	8b 46 04             	mov    0x4(%esi),%eax
  807671:	e8 4f fd ff ff       	call   8073c5 <lwip_standard_chksum>
  807676:	0f b7 c0             	movzwl %ax,%eax
  807679:	01 c3                	add    %eax,%ebx
    acc = FOLD_U32T(acc);
  80767b:	89 d8                	mov    %ebx,%eax
  80767d:	c1 e8 10             	shr    $0x10,%eax
  807680:	0f b7 db             	movzwl %bx,%ebx
  807683:	01 c3                	add    %eax,%ebx
    if (q->len % 2 != 0) {
  807685:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807689:	74 d9                	je     807664 <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
  80768b:	b8 01 00 00 00       	mov    $0x1,%eax
  807690:	89 f9                	mov    %edi,%ecx
  807692:	29 c8                	sub    %ecx,%eax
  807694:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807696:	89 da                	mov    %ebx,%edx
  807698:	c1 e2 08             	shl    $0x8,%edx
  80769b:	0f b7 d2             	movzwl %dx,%edx
  80769e:	0f b6 df             	movzbl %bh,%ebx
  8076a1:	09 d3                	or     %edx,%ebx
  8076a3:	eb bf                	jmp    807664 <inet_chksum_pbuf+0x18>
    }
  }

  if (swapped) {
  8076a5:	89 f8                	mov    %edi,%eax
  8076a7:	84 c0                	test   %al,%al
  8076a9:	74 0d                	je     8076b8 <inet_chksum_pbuf+0x6c>
    acc = SWAP_BYTES_IN_WORD(acc);
  8076ab:	89 da                	mov    %ebx,%edx
  8076ad:	c1 e2 08             	shl    $0x8,%edx
  8076b0:	0f b7 d2             	movzwl %dx,%edx
  8076b3:	0f b6 df             	movzbl %bh,%ebx
  8076b6:	09 d3                	or     %edx,%ebx
  }
  return (u16_t)~(acc & 0xffffUL);
  8076b8:	89 d8                	mov    %ebx,%eax
  8076ba:	f7 d0                	not    %eax
}
  8076bc:	83 c4 0c             	add    $0xc,%esp
  8076bf:	5b                   	pop    %ebx
  8076c0:	5e                   	pop    %esi
  8076c1:	5f                   	pop    %edi
  8076c2:	5d                   	pop    %ebp
  8076c3:	c3                   	ret    

008076c4 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  8076c4:	55                   	push   %ebp
  8076c5:	89 e5                	mov    %esp,%ebp
  8076c7:	57                   	push   %edi
  8076c8:	56                   	push   %esi
  8076c9:	53                   	push   %ebx
  8076ca:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  8076cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8076d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  8076d3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
  ap = (u8_t *)&s_addr;
  8076d7:	8d 75 f0             	lea    -0x10(%ebp),%esi
  rp = str;
  8076da:	bf e4 49 b3 00       	mov    $0xb349e4,%edi
  8076df:	eb 1a                	jmp    8076fb <inet_ntoa+0x37>
  8076e1:	0f b6 db             	movzbl %bl,%ebx
  8076e4:	01 fb                	add    %edi,%ebx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  8076e6:	8d 7b 01             	lea    0x1(%ebx),%edi
  8076e9:	c6 03 2e             	movb   $0x2e,(%ebx)
  8076ec:	83 c6 01             	add    $0x1,%esi
  for(n = 0; n < 4; n++) {
  8076ef:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
  8076f3:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
  8076f7:	3c 04                	cmp    $0x4,%al
  8076f9:	74 59                	je     807754 <inet_ntoa+0x90>
  rp = str;
  8076fb:	ba 00 00 00 00       	mov    $0x0,%edx
      rem = *ap % (u8_t)10;
  807700:	0f b6 0e             	movzbl (%esi),%ecx
      *ap /= (u8_t)10;
  807703:	0f b6 d9             	movzbl %cl,%ebx
  807706:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  807709:	8d 04 c3             	lea    (%ebx,%eax,8),%eax
  80770c:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80770f:	66 c1 e8 0b          	shr    $0xb,%ax
  807713:	88 06                	mov    %al,(%esi)
      inv[i++] = '0' + rem;
  807715:	8d 5a 01             	lea    0x1(%edx),%ebx
  807718:	0f b6 d2             	movzbl %dl,%edx
  80771b:	89 55 e0             	mov    %edx,-0x20(%ebp)
      rem = *ap % (u8_t)10;
  80771e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807721:	01 c0                	add    %eax,%eax
  807723:	89 ca                	mov    %ecx,%edx
  807725:	29 c2                	sub    %eax,%edx
  807727:	89 d0                	mov    %edx,%eax
      inv[i++] = '0' + rem;
  807729:	83 c0 30             	add    $0x30,%eax
  80772c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80772f:	88 44 15 ed          	mov    %al,-0x13(%ebp,%edx,1)
  807733:	89 da                	mov    %ebx,%edx
    } while(*ap);
  807735:	80 f9 09             	cmp    $0x9,%cl
  807738:	77 c6                	ja     807700 <inet_ntoa+0x3c>
  80773a:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80773c:	89 d8                	mov    %ebx,%eax
    while(i--)
  80773e:	83 e8 01             	sub    $0x1,%eax
  807741:	3c ff                	cmp    $0xff,%al
  807743:	74 9c                	je     8076e1 <inet_ntoa+0x1d>
      *rp++ = inv[i];
  807745:	0f b6 c8             	movzbl %al,%ecx
  807748:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  80774d:	88 0a                	mov    %cl,(%edx)
  80774f:	83 c2 01             	add    $0x1,%edx
  807752:	eb ea                	jmp    80773e <inet_ntoa+0x7a>
    ap++;
  }
  *--rp = 0;
  807754:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  807757:	b8 e4 49 b3 00       	mov    $0xb349e4,%eax
  80775c:	83 c4 18             	add    $0x18,%esp
  80775f:	5b                   	pop    %ebx
  807760:	5e                   	pop    %esi
  807761:	5f                   	pop    %edi
  807762:	5d                   	pop    %ebp
  807763:	c3                   	ret    

00807764 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807764:	55                   	push   %ebp
  807765:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807767:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80776b:	66 c1 c0 08          	rol    $0x8,%ax
}
  80776f:	5d                   	pop    %ebp
  807770:	c3                   	ret    

00807771 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807771:	55                   	push   %ebp
  807772:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807774:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807778:	66 c1 c0 08          	rol    $0x8,%ax
  return htons(n);
}
  80777c:	5d                   	pop    %ebp
  80777d:	c3                   	ret    

0080777e <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80777e:	55                   	push   %ebp
  80777f:	89 e5                	mov    %esp,%ebp
  807781:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
  807784:	89 d0                	mov    %edx,%eax
  807786:	c1 e0 18             	shl    $0x18,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807789:	89 d1                	mov    %edx,%ecx
  80778b:	c1 e9 18             	shr    $0x18,%ecx
    ((n & 0xff0000UL) >> 8) |
  80778e:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807790:	89 d1                	mov    %edx,%ecx
  807792:	c1 e1 08             	shl    $0x8,%ecx
  807795:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
    ((n & 0xff0000UL) >> 8) |
  80779b:	09 c8                	or     %ecx,%eax
  80779d:	c1 ea 08             	shr    $0x8,%edx
  8077a0:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  8077a6:	09 d0                	or     %edx,%eax
}
  8077a8:	5d                   	pop    %ebp
  8077a9:	c3                   	ret    

008077aa <inet_aton>:
{
  8077aa:	55                   	push   %ebp
  8077ab:	89 e5                	mov    %esp,%ebp
  8077ad:	57                   	push   %edi
  8077ae:	56                   	push   %esi
  8077af:	53                   	push   %ebx
  8077b0:	83 ec 2c             	sub    $0x2c,%esp
  8077b3:	8b 45 08             	mov    0x8(%ebp),%eax
  c = *cp;
  8077b6:	0f be 10             	movsbl (%eax),%edx
  u32_t *pp = parts;
  8077b9:	8d 75 d8             	lea    -0x28(%ebp),%esi
  8077bc:	89 75 cc             	mov    %esi,-0x34(%ebp)
  8077bf:	e9 a7 00 00 00       	jmp    80786b <inet_aton+0xc1>
      c = *++cp;
  8077c4:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  8077c8:	89 d1                	mov    %edx,%ecx
  8077ca:	83 e1 df             	and    $0xffffffdf,%ecx
  8077cd:	80 f9 58             	cmp    $0x58,%cl
  8077d0:	74 10                	je     8077e2 <inet_aton+0x38>
      c = *++cp;
  8077d2:	83 c0 01             	add    $0x1,%eax
  8077d5:	0f be d2             	movsbl %dl,%edx
        base = 8;
  8077d8:	be 08 00 00 00       	mov    $0x8,%esi
  8077dd:	e9 a3 00 00 00       	jmp    807885 <inet_aton+0xdb>
        c = *++cp;
  8077e2:	0f be 50 02          	movsbl 0x2(%eax),%edx
  8077e6:	8d 40 02             	lea    0x2(%eax),%eax
        base = 16;
  8077e9:	be 10 00 00 00       	mov    $0x10,%esi
  8077ee:	e9 92 00 00 00       	jmp    807885 <inet_aton+0xdb>
      } else if (base == 16 && isxdigit(c)) {
  8077f3:	83 fe 10             	cmp    $0x10,%esi
  8077f6:	75 4d                	jne    807845 <inet_aton+0x9b>
  8077f8:	8d 4f 9f             	lea    -0x61(%edi),%ecx
  8077fb:	88 4d d3             	mov    %cl,-0x2d(%ebp)
  8077fe:	89 d1                	mov    %edx,%ecx
  807800:	83 e1 df             	and    $0xffffffdf,%ecx
  807803:	83 e9 41             	sub    $0x41,%ecx
  807806:	80 f9 05             	cmp    $0x5,%cl
  807809:	77 3a                	ja     807845 <inet_aton+0x9b>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80780b:	c1 e3 04             	shl    $0x4,%ebx
  80780e:	83 c2 0a             	add    $0xa,%edx
  807811:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  807815:	19 c9                	sbb    %ecx,%ecx
  807817:	83 e1 20             	and    $0x20,%ecx
  80781a:	83 c1 41             	add    $0x41,%ecx
  80781d:	29 ca                	sub    %ecx,%edx
  80781f:	09 d3                	or     %edx,%ebx
        c = *++cp;
  807821:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  807824:	0f be 57 01          	movsbl 0x1(%edi),%edx
  807828:	83 c0 01             	add    $0x1,%eax
  80782b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (isdigit(c)) {
  80782e:	89 d7                	mov    %edx,%edi
  807830:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807833:	80 f9 09             	cmp    $0x9,%cl
  807836:	77 bb                	ja     8077f3 <inet_aton+0x49>
        val = (val * base) + (int)(c - '0');
  807838:	0f af de             	imul   %esi,%ebx
  80783b:	8d 5c 1a d0          	lea    -0x30(%edx,%ebx,1),%ebx
        c = *++cp;
  80783f:	0f be 50 01          	movsbl 0x1(%eax),%edx
  807843:	eb e3                	jmp    807828 <inet_aton+0x7e>
    if (c == '.') {
  807845:	83 fa 2e             	cmp    $0x2e,%edx
  807848:	75 42                	jne    80788c <inet_aton+0xe2>
      if (pp >= parts + 3)
  80784a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80784d:	8b 75 cc             	mov    -0x34(%ebp),%esi
  807850:	39 c6                	cmp    %eax,%esi
  807852:	0f 84 0e 01 00 00    	je     807966 <inet_aton+0x1bc>
      *pp++ = val;
  807858:	83 c6 04             	add    $0x4,%esi
  80785b:	89 75 cc             	mov    %esi,-0x34(%ebp)
  80785e:	89 5e fc             	mov    %ebx,-0x4(%esi)
      c = *++cp;
  807861:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  807864:	8d 46 01             	lea    0x1(%esi),%eax
  807867:	0f be 56 01          	movsbl 0x1(%esi),%edx
    if (!isdigit(c))
  80786b:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80786e:	80 f9 09             	cmp    $0x9,%cl
  807871:	0f 87 e8 00 00 00    	ja     80795f <inet_aton+0x1b5>
    base = 10;
  807877:	be 0a 00 00 00       	mov    $0xa,%esi
    if (c == '0') {
  80787c:	83 fa 30             	cmp    $0x30,%edx
  80787f:	0f 84 3f ff ff ff    	je     8077c4 <inet_aton+0x1a>
    base = 10;
  807885:	bb 00 00 00 00       	mov    $0x0,%ebx
  80788a:	eb 9f                	jmp    80782b <inet_aton+0x81>
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80788c:	85 d2                	test   %edx,%edx
  80788e:	74 26                	je     8078b6 <inet_aton+0x10c>
    return (0);
  807890:	b8 00 00 00 00       	mov    $0x0,%eax
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807895:	89 f9                	mov    %edi,%ecx
  807897:	80 f9 1f             	cmp    $0x1f,%cl
  80789a:	0f 86 cb 00 00 00    	jbe    80796b <inet_aton+0x1c1>
  8078a0:	84 d2                	test   %dl,%dl
  8078a2:	0f 88 c3 00 00 00    	js     80796b <inet_aton+0x1c1>
  8078a8:	83 fa 20             	cmp    $0x20,%edx
  8078ab:	74 09                	je     8078b6 <inet_aton+0x10c>
  8078ad:	83 fa 0c             	cmp    $0xc,%edx
  8078b0:	0f 85 b5 00 00 00    	jne    80796b <inet_aton+0x1c1>
  n = pp - parts + 1;
  8078b6:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8078b9:	8b 75 cc             	mov    -0x34(%ebp),%esi
  8078bc:	29 c6                	sub    %eax,%esi
  8078be:	89 f0                	mov    %esi,%eax
  8078c0:	c1 f8 02             	sar    $0x2,%eax
  8078c3:	83 c0 01             	add    $0x1,%eax
  switch (n) {
  8078c6:	83 f8 02             	cmp    $0x2,%eax
  8078c9:	74 5e                	je     807929 <inet_aton+0x17f>
  8078cb:	7e 35                	jle    807902 <inet_aton+0x158>
  8078cd:	83 f8 03             	cmp    $0x3,%eax
  8078d0:	74 6e                	je     807940 <inet_aton+0x196>
  8078d2:	83 f8 04             	cmp    $0x4,%eax
  8078d5:	75 2f                	jne    807906 <inet_aton+0x15c>
      return (0);
  8078d7:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xff)
  8078dc:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  8078e2:	0f 87 83 00 00 00    	ja     80796b <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  8078e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8078eb:	c1 e0 18             	shl    $0x18,%eax
  8078ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8078f1:	c1 e2 10             	shl    $0x10,%edx
  8078f4:	09 d0                	or     %edx,%eax
  8078f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8078f9:	c1 e2 08             	shl    $0x8,%edx
  8078fc:	09 d0                	or     %edx,%eax
  8078fe:	09 c3                	or     %eax,%ebx
    break;
  807900:	eb 04                	jmp    807906 <inet_aton+0x15c>
  switch (n) {
  807902:	85 c0                	test   %eax,%eax
  807904:	74 65                	je     80796b <inet_aton+0x1c1>
  return (1);
  807906:	b8 01 00 00 00       	mov    $0x1,%eax
  if (addr)
  80790b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80790f:	74 5a                	je     80796b <inet_aton+0x1c1>
    addr->s_addr = htonl(val);
  807911:	83 ec 0c             	sub    $0xc,%esp
  807914:	53                   	push   %ebx
  807915:	e8 64 fe ff ff       	call   80777e <htonl>
  80791a:	83 c4 10             	add    $0x10,%esp
  80791d:	8b 75 0c             	mov    0xc(%ebp),%esi
  807920:	89 06                	mov    %eax,(%esi)
  return (1);
  807922:	b8 01 00 00 00       	mov    $0x1,%eax
  807927:	eb 42                	jmp    80796b <inet_aton+0x1c1>
      return (0);
  807929:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffffffUL)
  80792e:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  807934:	77 35                	ja     80796b <inet_aton+0x1c1>
    val |= parts[0] << 24;
  807936:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807939:	c1 e0 18             	shl    $0x18,%eax
  80793c:	09 c3                	or     %eax,%ebx
    break;
  80793e:	eb c6                	jmp    807906 <inet_aton+0x15c>
      return (0);
  807940:	b8 00 00 00 00       	mov    $0x0,%eax
    if (val > 0xffff)
  807945:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80794b:	77 1e                	ja     80796b <inet_aton+0x1c1>
    val |= (parts[0] << 24) | (parts[1] << 16);
  80794d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807950:	c1 e0 18             	shl    $0x18,%eax
  807953:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807956:	c1 e2 10             	shl    $0x10,%edx
  807959:	09 d0                	or     %edx,%eax
  80795b:	09 c3                	or     %eax,%ebx
    break;
  80795d:	eb a7                	jmp    807906 <inet_aton+0x15c>
      return (0);
  80795f:	b8 00 00 00 00       	mov    $0x0,%eax
  807964:	eb 05                	jmp    80796b <inet_aton+0x1c1>
        return (0);
  807966:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80796b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80796e:	5b                   	pop    %ebx
  80796f:	5e                   	pop    %esi
  807970:	5f                   	pop    %edi
  807971:	5d                   	pop    %ebp
  807972:	c3                   	ret    

00807973 <inet_addr>:
{
  807973:	55                   	push   %ebp
  807974:	89 e5                	mov    %esp,%ebp
  807976:	83 ec 20             	sub    $0x20,%esp
  if (inet_aton(cp, &val)) {
  807979:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80797c:	50                   	push   %eax
  80797d:	ff 75 08             	pushl  0x8(%ebp)
  807980:	e8 25 fe ff ff       	call   8077aa <inet_aton>
  807985:	83 c4 10             	add    $0x10,%esp
    return (val.s_addr);
  807988:	85 c0                	test   %eax,%eax
  80798a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80798f:	0f 45 45 f4          	cmovne -0xc(%ebp),%eax
}
  807993:	c9                   	leave  
  807994:	c3                   	ret    

00807995 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807995:	55                   	push   %ebp
  807996:	89 e5                	mov    %esp,%ebp
  807998:	83 ec 14             	sub    $0x14,%esp
  return htonl(n);
  80799b:	ff 75 08             	pushl  0x8(%ebp)
  80799e:	e8 db fd ff ff       	call   80777e <htonl>
  8079a3:	83 c4 10             	add    $0x10,%esp
}
  8079a6:	c9                   	leave  
  8079a7:	c3                   	ret    

008079a8 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  8079a8:	55                   	push   %ebp
  8079a9:	89 e5                	mov    %esp,%ebp
  8079ab:	57                   	push   %edi
  8079ac:	56                   	push   %esi
  8079ad:	53                   	push   %ebx
  8079ae:	83 ec 3c             	sub    $0x3c,%esp
  8079b1:	8b 7d 08             	mov    0x8(%ebp),%edi
  8079b4:	8b 75 10             	mov    0x10(%ebp),%esi
  8079b7:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  8079ba:	8b 55 14             	mov    0x14(%ebp),%edx
  8079bd:	89 55 bc             	mov    %edx,-0x44(%ebp)
  8079c0:	8b 5d 18             	mov    0x18(%ebp),%ebx
  8079c3:	89 5d b8             	mov    %ebx,-0x48(%ebp)
  8079c6:	8b 45 20             	mov    0x20(%ebp),%eax
  8079c9:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  8079cd:	88 55 dd             	mov    %dl,-0x23(%ebp)
  8079d0:	89 da                	mov    %ebx,%edx
  8079d2:	88 45 dc             	mov    %al,-0x24(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  8079d5:	66 85 f6             	test   %si,%si
  8079d8:	74 04                	je     8079de <tcp_enqueue+0x36>
  8079da:	84 c0                	test   %al,%al
  8079dc:	75 54                	jne    807a32 <tcp_enqueue+0x8a>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  8079de:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8079e2:	74 06                	je     8079ea <tcp_enqueue+0x42>
  8079e4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8079e8:	75 5f                	jne    807a49 <tcp_enqueue+0xa1>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  8079ea:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  8079ee:	66 39 4f 6e          	cmp    %cx,0x6e(%edi)
  8079f2:	72 6c                	jb     807a60 <tcp_enqueue+0xb8>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8079f4:	8b 4f 68             	mov    0x68(%edi),%ecx
  8079f7:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8079fa:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8079fe:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807a02:	66 83 f9 1f          	cmp    $0x1f,%cx
  807a06:	77 66                	ja     807a6e <tcp_enqueue+0xc6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
  807a08:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  807a0d:	74 6d                	je     807a7c <tcp_enqueue+0xd4>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  807a0f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807a13:	75 7b                	jne    807a90 <tcp_enqueue+0xe8>
  807a15:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a19:	75 75                	jne    807a90 <tcp_enqueue+0xe8>
  807a1b:	83 ec 04             	sub    $0x4,%esp
  807a1e:	68 cc 25 81 00       	push   $0x8125cc
  807a23:	68 ae 00 00 00       	push   $0xae
  807a28:	68 e6 26 81 00       	push   $0x8126e6
  807a2d:	e8 67 6c 00 00       	call   80e699 <_panic>
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  807a32:	83 ec 04             	sub    $0x4,%esp
  807a35:	68 44 25 81 00       	push   $0x812544
  807a3a:	68 90 00 00 00       	push   $0x90
  807a3f:	68 e6 26 81 00       	push   $0x8126e6
  807a44:	e8 50 6c 00 00       	call   80e699 <_panic>
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  807a49:	83 ec 04             	sub    $0x4,%esp
  807a4c:	68 84 25 81 00       	push   $0x812584
  807a51:	68 92 00 00 00       	push   $0x92
  807a56:	68 e6 26 81 00       	push   $0x8126e6
  807a5b:	e8 39 6c 00 00       	call   80e699 <_panic>
    pcb->flags |= TF_NAGLEMEMERR;
  807a60:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807a64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a69:	e9 a4 03 00 00       	jmp    807e12 <tcp_enqueue+0x46a>
    pcb->flags |= TF_NAGLEMEMERR;
  807a6e:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  807a72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807a77:	e9 96 03 00 00       	jmp    807e12 <tcp_enqueue+0x46a>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807a7c:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807a80:	0f 85 05 02 00 00    	jne    807c8b <tcp_enqueue+0x2e3>
  807a86:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807a8a:	0f 85 fb 01 00 00    	jne    807c8b <tcp_enqueue+0x2e3>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807a90:	c0 e8 02             	shr    $0x2,%al
  807a93:	c1 e0 0c             	shl    $0xc,%eax
  807a96:	66 05 00 50          	add    $0x5000,%ax
  807a9a:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
  807a9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807aa1:	89 45 d0             	mov    %eax,-0x30(%ebp)
  807aa4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807aa8:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  807aac:	be 00 00 00 00       	mov    $0x0,%esi
  while (queue == NULL || left > 0) {
  807ab1:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807ab5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807abc:	83 e2 01             	and    $0x1,%edx
  807abf:	88 55 c9             	mov    %dl,-0x37(%ebp)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807ac2:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807ac6:	89 45 cc             	mov    %eax,-0x34(%ebp)
    seglen = left > pcb->mss? pcb->mss: left;
  807ac9:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  807acd:	66 39 47 34          	cmp    %ax,0x34(%edi)
  807ad1:	66 0f 46 47 34       	cmovbe 0x34(%edi),%ax
  807ad6:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
    seg = memp_malloc(MEMP_TCP_SEG);
  807ada:	83 ec 0c             	sub    $0xc,%esp
  807add:	6a 04                	push   $0x4
  807adf:	e8 03 ca ff ff       	call   8044e7 <memp_malloc>
  807ae4:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  807ae6:	83 c4 10             	add    $0x10,%esp
  807ae9:	85 c0                	test   %eax,%eax
  807aeb:	0f 84 e6 02 00 00    	je     807dd7 <tcp_enqueue+0x42f>
    seg->next = NULL;
  807af1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  807af7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    if (queue == NULL) {
  807afe:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
  807b02:	0f 85 b1 01 00 00    	jne    807cb9 <tcp_enqueue+0x311>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807b08:	85 f6                	test   %esi,%esi
  807b0a:	0f 84 92 01 00 00    	je     807ca2 <tcp_enqueue+0x2fa>
      useg->next = seg;
  807b10:	89 06                	mov    %eax,(%esi)
    if (optdata != NULL) {
  807b12:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807b16:	0f 84 bc 01 00 00    	je     807cd8 <tcp_enqueue+0x330>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  807b1c:	83 ec 04             	sub    $0x4,%esp
  807b1f:	6a 00                	push   $0x0
  807b21:	ff 75 cc             	pushl  -0x34(%ebp)
  807b24:	6a 00                	push   $0x0
  807b26:	e8 25 ce ff ff       	call   804950 <pbuf_alloc>
  807b2b:	89 43 04             	mov    %eax,0x4(%ebx)
  807b2e:	83 c4 10             	add    $0x10,%esp
  807b31:	85 c0                	test   %eax,%eax
  807b33:	0f 84 9e 02 00 00    	je     807dd7 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807b39:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
  807b3d:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  807b41:	0f 82 7a 01 00 00    	jb     807cc1 <tcp_enqueue+0x319>
      queuelen += pbuf_clen(seg->p);
  807b47:	83 ec 0c             	sub    $0xc,%esp
  807b4a:	50                   	push   %eax
  807b4b:	e8 84 d1 ff ff       	call   804cd4 <pbuf_clen>
  807b50:	0f b6 c0             	movzbl %al,%eax
  807b53:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      seg->dataptr = seg->p->payload;
  807b57:	8b 43 04             	mov    0x4(%ebx),%eax
  807b5a:	8b 40 04             	mov    0x4(%eax),%eax
  807b5d:	89 43 08             	mov    %eax,0x8(%ebx)
  807b60:	83 c4 10             	add    $0x10,%esp
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  807b63:	66 83 7d e0 20       	cmpw   $0x20,-0x20(%ebp)
  807b68:	0f 87 69 02 00 00    	ja     807dd7 <tcp_enqueue+0x42f>
    seg->len = seglen;
  807b6e:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807b72:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    if (pbuf_header(seg->p, TCP_HLEN)) {
  807b76:	83 ec 08             	sub    $0x8,%esp
  807b79:	6a 14                	push   $0x14
  807b7b:	ff 73 04             	pushl  0x4(%ebx)
  807b7e:	e8 3a cc ff ff       	call   8047bd <pbuf_header>
  807b83:	83 c4 10             	add    $0x10,%esp
  807b86:	84 c0                	test   %al,%al
  807b88:	0f 85 49 02 00 00    	jne    807dd7 <tcp_enqueue+0x42f>
    seg->tcphdr = seg->p->payload;
  807b8e:	8b 43 04             	mov    0x4(%ebx),%eax
  807b91:	8b 70 04             	mov    0x4(%eax),%esi
  807b94:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  807b97:	83 ec 0c             	sub    $0xc,%esp
  807b9a:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807b9e:	50                   	push   %eax
  807b9f:	e8 c0 fb ff ff       	call   807764 <htons>
  807ba4:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  807ba7:	8b 73 10             	mov    0x10(%ebx),%esi
  807baa:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  807bae:	89 04 24             	mov    %eax,(%esp)
  807bb1:	e8 ae fb ff ff       	call   807764 <htons>
  807bb6:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  807bba:	8b 73 10             	mov    0x10(%ebx),%esi
  807bbd:	83 c4 04             	add    $0x4,%esp
  807bc0:	ff 75 d8             	pushl  -0x28(%ebp)
  807bc3:	e8 b6 fb ff ff       	call   80777e <htonl>
  807bc8:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  807bcb:	8b 43 10             	mov    0x10(%ebx),%eax
  807bce:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  807bd4:	8b 43 10             	mov    0x10(%ebx),%eax
  807bd7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807bdb:	89 04 24             	mov    %eax,(%esp)
  807bde:	e8 8e fb ff ff       	call   807771 <ntohs>
  807be3:	8b 73 10             	mov    0x10(%ebx),%esi
  807be6:	83 e0 c0             	and    $0xffffffc0,%eax
  807be9:	0f b6 55 dd          	movzbl -0x23(%ebp),%edx
  807bed:	09 d0                	or     %edx,%eax
  807bef:	0f b7 c0             	movzwl %ax,%eax
  807bf2:	89 04 24             	mov    %eax,(%esp)
  807bf5:	e8 6a fb ff ff       	call   807764 <htons>
  807bfa:	66 89 46 0c          	mov    %ax,0xc(%esi)
    if (optdata == NULL) {
  807bfe:	83 c4 10             	add    $0x10,%esp
  807c01:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  807c05:	0f 84 0f 02 00 00    	je     807e1a <tcp_enqueue+0x472>
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  807c0b:	83 ec 0c             	sub    $0xc,%esp
  807c0e:	8b 43 10             	mov    0x10(%ebx),%eax
  807c11:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807c15:	50                   	push   %eax
  807c16:	e8 56 fb ff ff       	call   807771 <ntohs>
  807c1b:	8b 73 10             	mov    0x10(%ebx),%esi
  807c1e:	83 e0 3f             	and    $0x3f,%eax
  807c21:	66 0b 45 ca          	or     -0x36(%ebp),%ax
  807c25:	0f b7 c0             	movzwl %ax,%eax
  807c28:	89 04 24             	mov    %eax,(%esp)
  807c2b:	e8 34 fb ff ff       	call   807764 <htons>
  807c30:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  807c34:	83 c4 0c             	add    $0xc,%esp
  807c37:	ff 75 cc             	pushl  -0x34(%ebp)
  807c3a:	ff 75 1c             	pushl  0x1c(%ebp)
  807c3d:	ff 73 08             	pushl  0x8(%ebx)
  807c40:	e8 99 74 00 00       	call   80f0de <memcpy>
  807c45:	83 c4 10             	add    $0x10,%esp
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  807c48:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  807c4c:	0f b7 c1             	movzwl %cx,%eax
  807c4f:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  807c52:	01 45 d0             	add    %eax,-0x30(%ebp)
  while (queue == NULL || left > 0) {
  807c55:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807c59:	0f 94 45 e4          	sete   -0x1c(%ebp)
  807c5d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    seg = memp_malloc(MEMP_TCP_SEG);
  807c61:	89 de                	mov    %ebx,%esi
  while (queue == NULL || left > 0) {
  807c63:	66 29 4d de          	sub    %cx,-0x22(%ebp)
  807c67:	0f 85 5c fe ff ff    	jne    807ac9 <tcp_enqueue+0x121>
  807c6d:	84 c0                	test   %al,%al
  807c6f:	0f 85 54 fe ff ff    	jne    807ac9 <tcp_enqueue+0x121>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  807c75:	8b 47 74             	mov    0x74(%edi),%eax
  807c78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807c7b:	85 c0                	test   %eax,%eax
  807c7d:	0f 84 c1 03 00 00    	je     808044 <tcp_enqueue+0x69c>
  807c83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807c86:	e9 be 01 00 00       	jmp    807e49 <tcp_enqueue+0x4a1>
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  807c8b:	83 ec 04             	sub    $0x4,%esp
  807c8e:	68 08 26 81 00       	push   $0x812608
  807c93:	68 b1 00 00 00       	push   $0xb1
  807c98:	68 e6 26 81 00       	push   $0x8126e6
  807c9d:	e8 f7 69 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("useg != NULL", useg != NULL);
  807ca2:	83 ec 04             	sub    $0x4,%esp
  807ca5:	68 fe 26 81 00       	push   $0x8126fe
  807caa:	68 ce 00 00 00       	push   $0xce
  807caf:	68 e6 26 81 00       	push   $0x8126e6
  807cb4:	e8 e0 69 00 00       	call   80e699 <_panic>
    seg = memp_malloc(MEMP_TCP_SEG);
  807cb9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  807cbc:	e9 51 fe ff ff       	jmp    807b12 <tcp_enqueue+0x16a>
      LWIP_ASSERT("check that first pbuf can hold optlen",
  807cc1:	83 ec 04             	sub    $0x4,%esp
  807cc4:	68 3c 26 81 00       	push   $0x81263c
  807cc9:	68 df 00 00 00       	push   $0xdf
  807cce:	68 e6 26 81 00       	push   $0x8126e6
  807cd3:	e8 c1 69 00 00       	call   80e699 <_panic>
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  807cd8:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  807cdc:	74 7f                	je     807d5d <tcp_enqueue+0x3b5>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  807cde:	83 ec 04             	sub    $0x4,%esp
  807ce1:	6a 00                	push   $0x0
  807ce3:	0f b7 75 e2          	movzwl -0x1e(%ebp),%esi
  807ce7:	0f b7 c6             	movzwl %si,%eax
  807cea:	50                   	push   %eax
  807ceb:	6a 00                	push   $0x0
  807ced:	e8 5e cc ff ff       	call   804950 <pbuf_alloc>
  807cf2:	89 43 04             	mov    %eax,0x4(%ebx)
  807cf5:	83 c4 10             	add    $0x10,%esp
  807cf8:	85 c0                	test   %eax,%eax
  807cfa:	0f 84 d7 00 00 00    	je     807dd7 <tcp_enqueue+0x42f>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d00:	66 39 70 0a          	cmp    %si,0xa(%eax)
  807d04:	72 40                	jb     807d46 <tcp_enqueue+0x39e>
      queuelen += pbuf_clen(seg->p);
  807d06:	83 ec 0c             	sub    $0xc,%esp
  807d09:	50                   	push   %eax
  807d0a:	e8 c5 cf ff ff       	call   804cd4 <pbuf_clen>
  807d0f:	0f b6 c0             	movzbl %al,%eax
  807d12:	66 01 45 e0          	add    %ax,-0x20(%ebp)
      if (arg != NULL) {
  807d16:	83 c4 10             	add    $0x10,%esp
  807d19:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d1d:	74 19                	je     807d38 <tcp_enqueue+0x390>
        MEMCPY(seg->p->payload, ptr, seglen);
  807d1f:	83 ec 04             	sub    $0x4,%esp
  807d22:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d26:	50                   	push   %eax
  807d27:	ff 75 d0             	pushl  -0x30(%ebp)
  807d2a:	8b 43 04             	mov    0x4(%ebx),%eax
  807d2d:	ff 70 04             	pushl  0x4(%eax)
  807d30:	e8 a9 73 00 00       	call   80f0de <memcpy>
  807d35:	83 c4 10             	add    $0x10,%esp
      seg->dataptr = seg->p->payload;
  807d38:	8b 43 04             	mov    0x4(%ebx),%eax
  807d3b:	8b 40 04             	mov    0x4(%eax),%eax
  807d3e:	89 43 08             	mov    %eax,0x8(%ebx)
  807d41:	e9 1d fe ff ff       	jmp    807b63 <tcp_enqueue+0x1bb>
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  807d46:	83 ec 04             	sub    $0x4,%esp
  807d49:	68 64 26 81 00       	push   $0x812664
  807d4e:	68 ea 00 00 00       	push   $0xea
  807d53:	68 e6 26 81 00       	push   $0x8126e6
  807d58:	e8 3c 69 00 00       	call   80e699 <_panic>
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  807d5d:	83 ec 04             	sub    $0x4,%esp
  807d60:	6a 01                	push   $0x1
  807d62:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  807d66:	50                   	push   %eax
  807d67:	6a 00                	push   $0x0
  807d69:	e8 e2 cb ff ff       	call   804950 <pbuf_alloc>
  807d6e:	89 c6                	mov    %eax,%esi
  807d70:	83 c4 10             	add    $0x10,%esp
  807d73:	85 c0                	test   %eax,%eax
  807d75:	74 60                	je     807dd7 <tcp_enqueue+0x42f>
      ++queuelen;
  807d77:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807d7b:	83 c0 01             	add    $0x1,%eax
  807d7e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      p->payload = ptr;
  807d82:	8b 45 d0             	mov    -0x30(%ebp),%eax
  807d85:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  807d88:	89 43 08             	mov    %eax,0x8(%ebx)
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  807d8b:	83 ec 04             	sub    $0x4,%esp
  807d8e:	6a 00                	push   $0x0
  807d90:	6a 00                	push   $0x0
  807d92:	6a 00                	push   $0x0
  807d94:	e8 b7 cb ff ff       	call   804950 <pbuf_alloc>
  807d99:	89 43 04             	mov    %eax,0x4(%ebx)
  807d9c:	83 c4 10             	add    $0x10,%esp
  807d9f:	85 c0                	test   %eax,%eax
  807da1:	74 28                	je     807dcb <tcp_enqueue+0x423>
      queuelen += pbuf_clen(seg->p);
  807da3:	83 ec 0c             	sub    $0xc,%esp
  807da6:	50                   	push   %eax
  807da7:	e8 28 cf ff ff       	call   804cd4 <pbuf_clen>
  807dac:	0f b6 c0             	movzbl %al,%eax
  807daf:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  807db3:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
      pbuf_cat(seg->p/*header*/, p/*data*/);
  807db7:	83 c4 08             	add    $0x8,%esp
  807dba:	56                   	push   %esi
  807dbb:	ff 73 04             	pushl  0x4(%ebx)
  807dbe:	e8 3a cf ff ff       	call   804cfd <pbuf_cat>
  807dc3:	83 c4 10             	add    $0x10,%esp
  807dc6:	e9 98 fd ff ff       	jmp    807b63 <tcp_enqueue+0x1bb>
        pbuf_free(p);
  807dcb:	83 ec 0c             	sub    $0xc,%esp
  807dce:	56                   	push   %esi
  807dcf:	e8 b6 ca ff ff       	call   80488a <pbuf_free>
        goto memerr;
  807dd4:	83 c4 10             	add    $0x10,%esp
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  807dd7:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  807ddb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807dde:	85 c0                	test   %eax,%eax
  807de0:	74 0c                	je     807dee <tcp_enqueue+0x446>
    tcp_segs_free(queue);
  807de2:	83 ec 0c             	sub    $0xc,%esp
  807de5:	50                   	push   %eax
  807de6:	e8 f6 d9 ff ff       	call   8057e1 <tcp_segs_free>
  807deb:	83 c4 10             	add    $0x10,%esp
  }
  if (pcb->snd_queuelen != 0) {
  807dee:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  807df3:	0f 84 37 02 00 00    	je     808030 <tcp_enqueue+0x688>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  807df9:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807dfd:	0f 85 37 02 00 00    	jne    80803a <tcp_enqueue+0x692>
  807e03:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807e07:	0f 84 02 02 00 00    	je     80800f <tcp_enqueue+0x667>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  807e0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  807e12:	8d 65 f4             	lea    -0xc(%ebp),%esp
  807e15:	5b                   	pop    %ebx
  807e16:	5e                   	pop    %esi
  807e17:	5f                   	pop    %edi
  807e18:	5d                   	pop    %ebp
  807e19:	c3                   	ret    
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  807e1a:	83 ec 0c             	sub    $0xc,%esp
  807e1d:	8b 43 10             	mov    0x10(%ebx),%eax
  807e20:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e24:	50                   	push   %eax
  807e25:	e8 47 f9 ff ff       	call   807771 <ntohs>
  807e2a:	8b 73 10             	mov    0x10(%ebx),%esi
  807e2d:	83 e0 3f             	and    $0x3f,%eax
  807e30:	80 cc 50             	or     $0x50,%ah
  807e33:	89 04 24             	mov    %eax,(%esp)
  807e36:	e8 29 f9 ff ff       	call   807764 <htons>
  807e3b:	66 89 46 0c          	mov    %ax,0xc(%esi)
  807e3f:	83 c4 10             	add    $0x10,%esp
  807e42:	e9 01 fe ff ff       	jmp    807c48 <tcp_enqueue+0x2a0>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  807e47:	89 f0                	mov    %esi,%eax
  807e49:	8b 30                	mov    (%eax),%esi
  807e4b:	85 f6                	test   %esi,%esi
  807e4d:	75 f8                	jne    807e47 <tcp_enqueue+0x49f>
  807e4f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  807e52:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  807e56:	66 89 55 de          	mov    %dx,-0x22(%ebp)
  807e5a:	83 ec 0c             	sub    $0xc,%esp
  807e5d:	8b 40 10             	mov    0x10(%eax),%eax
  807e60:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e64:	50                   	push   %eax
  807e65:	e8 07 f9 ff ff       	call   807771 <ntohs>
  807e6a:	83 c4 10             	add    $0x10,%esp
  807e6d:	a8 01                	test   $0x1,%al
  807e6f:	0f 84 96 00 00 00    	je     807f0b <tcp_enqueue+0x563>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807e75:	83 ec 0c             	sub    $0xc,%esp
  807e78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807e7b:	8b 40 10             	mov    0x10(%eax),%eax
  807e7e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807e82:	50                   	push   %eax
  807e83:	e8 e9 f8 ff ff       	call   807771 <ntohs>
    TCP_TCPLEN(useg) != 0 &&
  807e88:	83 c4 10             	add    $0x10,%esp
  807e8b:	a8 03                	test   $0x3,%al
  807e8d:	0f 85 a0 00 00 00    	jne    807f33 <tcp_enqueue+0x58b>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  807e93:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  807e97:	0f 85 96 00 00 00    	jne    807f33 <tcp_enqueue+0x58b>
    useg->len + queue->len <= pcb->mss) {
  807e9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807ea0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807ea4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807ea7:	0f b7 52 0c          	movzwl 0xc(%edx),%edx
  807eab:	01 d0                	add    %edx,%eax
  807ead:	0f b7 57 34          	movzwl 0x34(%edi),%edx
    !(flags & (TCP_SYN | TCP_FIN)) &&
  807eb1:	39 d0                	cmp    %edx,%eax
  807eb3:	7f 7e                	jg     807f33 <tcp_enqueue+0x58b>
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  807eb5:	83 ec 08             	sub    $0x8,%esp
  807eb8:	6a ec                	push   $0xffffffec
  807eba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  807ebd:	ff 70 04             	pushl  0x4(%eax)
  807ec0:	e8 f8 c8 ff ff       	call   8047bd <pbuf_header>
  807ec5:	83 c4 10             	add    $0x10,%esp
  807ec8:	84 c0                	test   %al,%al
  807eca:	0f 85 0b 01 00 00    	jne    807fdb <tcp_enqueue+0x633>
    pbuf_cat(useg->p, queue->p);
  807ed0:	83 ec 08             	sub    $0x8,%esp
  807ed3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807ed6:	ff 72 04             	pushl  0x4(%edx)
  807ed9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807edc:	ff 71 04             	pushl  0x4(%ecx)
  807edf:	e8 19 ce ff ff       	call   804cfd <pbuf_cat>
    useg->len += queue->len;
  807ee4:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807ee7:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807eeb:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807eee:	66 01 41 0c          	add    %ax,0xc(%ecx)
    useg->next = queue->next;
  807ef2:	8b 02                	mov    (%edx),%eax
  807ef4:	89 01                	mov    %eax,(%ecx)
    if (seg == queue) {
  807ef6:	83 c4 08             	add    $0x8,%esp
      seg = NULL;
  807ef9:	39 da                	cmp    %ebx,%edx
  807efb:	0f 44 de             	cmove  %esi,%ebx
    memp_free(MEMP_TCP_SEG, queue);
  807efe:	52                   	push   %edx
  807eff:	6a 04                	push   $0x4
  807f01:	e8 37 c6 ff ff       	call   80453d <memp_free>
  807f06:	83 c4 10             	add    $0x10,%esp
  807f09:	eb 49                	jmp    807f54 <tcp_enqueue+0x5ac>
    TCP_TCPLEN(useg) != 0 &&
  807f0b:	83 ec 0c             	sub    $0xc,%esp
  807f0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f11:	8b 40 10             	mov    0x10(%eax),%eax
  807f14:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  807f18:	50                   	push   %eax
  807f19:	e8 53 f8 ff ff       	call   807771 <ntohs>
  807f1e:	66 d1 e8             	shr    %ax
  807f21:	83 e0 01             	and    $0x1,%eax
  807f24:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  if (useg != NULL &&
  807f28:	83 c4 10             	add    $0x10,%esp
  807f2b:	01 d0                	add    %edx,%eax
  807f2d:	0f 85 42 ff ff ff    	jne    807e75 <tcp_enqueue+0x4cd>
      useg->next = queue;
  807f33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f36:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  807f39:	89 10                	mov    %edx,(%eax)
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  807f3b:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  807f3f:	83 e2 03             	and    $0x3,%edx
    ++len;
  807f42:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  807f46:	83 c0 01             	add    $0x1,%eax
  807f49:	84 d2                	test   %dl,%dl
  807f4b:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  807f50:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  if (flags & TCP_FIN) {
  807f54:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  807f58:	74 04                	je     807f5e <tcp_enqueue+0x5b6>
    pcb->flags |= TF_FIN;
  807f5a:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  pcb->snd_lbb += len;
  807f5e:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  807f62:	0f b7 c2             	movzwl %dx,%eax
  807f65:	01 47 68             	add    %eax,0x68(%edi)
  pcb->snd_buf -= len;
  807f68:	66 29 57 6e          	sub    %dx,0x6e(%edi)
  pcb->snd_queuelen = queuelen;
  807f6c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807f70:	66 89 47 70          	mov    %ax,0x70(%edi)
  if (pcb->snd_queuelen != 0) {
  807f74:	66 85 c0             	test   %ax,%ax
  807f77:	74 06                	je     807f7f <tcp_enqueue+0x5d7>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807f79:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  807f7d:	74 73                	je     807ff2 <tcp_enqueue+0x64a>
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807f7f:	85 db                	test   %ebx,%ebx
  807f81:	0f 84 9f 00 00 00    	je     808026 <tcp_enqueue+0x67e>
  807f87:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  807f8c:	0f 84 94 00 00 00    	je     808026 <tcp_enqueue+0x67e>
  807f92:	8b 53 10             	mov    0x10(%ebx),%edx
  return ERR_OK;
  807f95:	b8 00 00 00 00       	mov    $0x0,%eax
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  807f9a:	85 d2                	test   %edx,%edx
  807f9c:	0f 84 70 fe ff ff    	je     807e12 <tcp_enqueue+0x46a>
  807fa2:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  807fa6:	0f 85 66 fe ff ff    	jne    807e12 <tcp_enqueue+0x46a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  807fac:	83 ec 0c             	sub    $0xc,%esp
  807faf:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  807fb3:	50                   	push   %eax
  807fb4:	e8 b8 f7 ff ff       	call   807771 <ntohs>
  807fb9:	8b 5b 10             	mov    0x10(%ebx),%ebx
  807fbc:	83 c8 08             	or     $0x8,%eax
  807fbf:	0f b7 c0             	movzwl %ax,%eax
  807fc2:	89 04 24             	mov    %eax,(%esp)
  807fc5:	e8 9a f7 ff ff       	call   807764 <htons>
  807fca:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  807fce:	83 c4 10             	add    $0x10,%esp
  return ERR_OK;
  807fd1:	b8 00 00 00 00       	mov    $0x0,%eax
  807fd6:	e9 37 fe ff ff       	jmp    807e12 <tcp_enqueue+0x46a>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  807fdb:	83 ec 04             	sub    $0x4,%esp
  807fde:	68 0b 27 81 00       	push   $0x81270b
  807fe3:	68 52 01 00 00       	push   $0x152
  807fe8:	68 e6 26 81 00       	push   $0x8126e6
  807fed:	e8 a7 66 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  807ff2:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  807ff6:	75 87                	jne    807f7f <tcp_enqueue+0x5d7>
  807ff8:	83 ec 04             	sub    $0x4,%esp
  807ffb:	68 98 26 81 00       	push   $0x812698
  808000:	68 7a 01 00 00       	push   $0x17a
  808005:	68 e6 26 81 00       	push   $0x8126e6
  80800a:	e8 8a 66 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80800f:	83 ec 04             	sub    $0x4,%esp
  808012:	68 98 26 81 00       	push   $0x812698
  808017:	68 8d 01 00 00       	push   $0x18d
  80801c:	68 e6 26 81 00       	push   $0x8126e6
  808021:	e8 73 66 00 00       	call   80e699 <_panic>
  return ERR_OK;
  808026:	b8 00 00 00 00       	mov    $0x0,%eax
  80802b:	e9 e2 fd ff ff       	jmp    807e12 <tcp_enqueue+0x46a>
  return ERR_MEM;
  808030:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808035:	e9 d8 fd ff ff       	jmp    807e12 <tcp_enqueue+0x46a>
  80803a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80803f:	e9 ce fd ff ff       	jmp    807e12 <tcp_enqueue+0x46a>
      pcb->unsent = queue;
  808044:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  808047:	89 47 74             	mov    %eax,0x74(%edi)
  80804a:	e9 ec fe ff ff       	jmp    807f3b <tcp_enqueue+0x593>

0080804f <tcp_send_ctrl>:
{
  80804f:	55                   	push   %ebp
  808050:	89 e5                	mov    %esp,%ebp
  808052:	83 ec 0c             	sub    $0xc,%esp
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  808055:	6a 00                	push   $0x0
  808057:	6a 00                	push   $0x0
  808059:	6a 01                	push   $0x1
  80805b:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80805f:	50                   	push   %eax
  808060:	6a 00                	push   $0x0
  808062:	6a 00                	push   $0x0
  808064:	ff 75 08             	pushl  0x8(%ebp)
  808067:	e8 3c f9 ff ff       	call   8079a8 <tcp_enqueue>
}
  80806c:	c9                   	leave  
  80806d:	c3                   	ret    

0080806e <tcp_write>:
{
  80806e:	55                   	push   %ebp
  80806f:	89 e5                	mov    %esp,%ebp
  808071:	56                   	push   %esi
  808072:	53                   	push   %ebx
  808073:	8b 4d 08             	mov    0x8(%ebp),%ecx
  808076:	8b 55 10             	mov    0x10(%ebp),%edx
  808079:	8b 75 14             	mov    0x14(%ebp),%esi
  if (pcb->state == ESTABLISHED ||
  80807c:	8b 41 10             	mov    0x10(%ecx),%eax
     pcb->state == CLOSE_WAIT ||
  80807f:	8d 58 fe             	lea    -0x2(%eax),%ebx
     pcb->state == SYN_SENT ||
  808082:	83 fb 02             	cmp    $0x2,%ebx
  808085:	76 05                	jbe    80808c <tcp_write+0x1e>
  808087:	83 f8 07             	cmp    $0x7,%eax
  80808a:	75 32                	jne    8080be <tcp_write+0x50>
    return ERR_OK;
  80808c:	b8 00 00 00 00       	mov    $0x0,%eax
    if (len > 0) {
  808091:	66 85 d2             	test   %dx,%dx
  808094:	75 07                	jne    80809d <tcp_write+0x2f>
}
  808096:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808099:	5b                   	pop    %ebx
  80809a:	5e                   	pop    %esi
  80809b:	5d                   	pop    %ebp
  80809c:	c3                   	ret    
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80809d:	83 ec 04             	sub    $0x4,%esp
  8080a0:	6a 00                	push   $0x0
  8080a2:	6a 00                	push   $0x0
  8080a4:	89 f0                	mov    %esi,%eax
  8080a6:	0f b6 f0             	movzbl %al,%esi
  8080a9:	56                   	push   %esi
  8080aa:	6a 00                	push   $0x0
  8080ac:	0f b7 d2             	movzwl %dx,%edx
  8080af:	52                   	push   %edx
  8080b0:	ff 75 0c             	pushl  0xc(%ebp)
  8080b3:	51                   	push   %ecx
  8080b4:	e8 ef f8 ff ff       	call   8079a8 <tcp_enqueue>
  8080b9:	83 c4 20             	add    $0x20,%esp
  8080bc:	eb d8                	jmp    808096 <tcp_write+0x28>
    return ERR_CONN;
  8080be:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  8080c3:	eb d1                	jmp    808096 <tcp_write+0x28>

008080c5 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8080c5:	55                   	push   %ebp
  8080c6:	89 e5                	mov    %esp,%ebp
  8080c8:	57                   	push   %edi
  8080c9:	56                   	push   %esi
  8080ca:	53                   	push   %ebx
  8080cb:	83 ec 1c             	sub    $0x1c,%esp
  8080ce:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8080d1:	39 3d 58 b2 b3 00    	cmp    %edi,0xb3b258
  8080d7:	0f 84 60 04 00 00    	je     80853d <tcp_output+0x478>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8080dd:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  8080e1:	66 39 47 4e          	cmp    %ax,0x4e(%edi)
  8080e5:	66 0f 46 47 4e       	cmovbe 0x4e(%edi),%ax
  8080ea:	0f b7 c0             	movzwl %ax,%eax
  8080ed:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  8080f0:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  8080f3:	8b 47 78             	mov    0x78(%edi),%eax
  8080f6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8080f9:	8b 55 dc             	mov    -0x24(%ebp),%edx
  if (useg != NULL) {
  8080fc:	85 c0                	test   %eax,%eax
  8080fe:	75 04                	jne    808104 <tcp_output+0x3f>
  808100:	eb 0b                	jmp    80810d <tcp_output+0x48>
    for (; useg->next != NULL; useg = useg->next);
  808102:	89 c2                	mov    %eax,%edx
  808104:	8b 02                	mov    (%edx),%eax
  808106:	85 c0                	test   %eax,%eax
  808108:	75 f8                	jne    808102 <tcp_output+0x3d>
  80810a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80810d:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  808111:	0f 84 e6 03 00 00    	je     8084fd <tcp_output+0x438>
  808117:	85 db                	test   %ebx,%ebx
  808119:	74 23                	je     80813e <tcp_output+0x79>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80811b:	83 ec 0c             	sub    $0xc,%esp
  80811e:	8b 43 10             	mov    0x10(%ebx),%eax
  808121:	ff 70 04             	pushl  0x4(%eax)
  808124:	e8 6c f8 ff ff       	call   807995 <ntohl>
  808129:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80812d:	2b 57 48             	sub    0x48(%edi),%edx
  808130:	01 c2                	add    %eax,%edx
     (seg == NULL ||
  808132:	83 c4 10             	add    $0x10,%esp
  808135:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  808138:	0f 86 bf 03 00 00    	jbe    8084fd <tcp_output+0x438>
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80813e:	83 ec 04             	sub    $0x4,%esp
  808141:	6a 00                	push   $0x0
  808143:	6a 14                	push   $0x14
  808145:	6a 01                	push   $0x1
  808147:	e8 04 c8 ff ff       	call   804950 <pbuf_alloc>
  80814c:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80814e:	83 c4 10             	add    $0x10,%esp
  808151:	85 c0                	test   %eax,%eax
  808153:	0f 84 eb 03 00 00    	je     808544 <tcp_output+0x47f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808159:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  80815d:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808160:	83 ec 0c             	sub    $0xc,%esp
  808163:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  808167:	50                   	push   %eax
  808168:	e8 f7 f5 ff ff       	call   807764 <htons>
  80816d:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808170:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808174:	89 04 24             	mov    %eax,(%esp)
  808177:	e8 e8 f5 ff ff       	call   807764 <htons>
  80817c:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808180:	83 c4 04             	add    $0x4,%esp
  808183:	ff 77 54             	pushl  0x54(%edi)
  808186:	e8 f3 f5 ff ff       	call   80777e <htonl>
  80818b:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80818e:	83 c4 04             	add    $0x4,%esp
  808191:	ff 77 24             	pushl  0x24(%edi)
  808194:	e8 e5 f5 ff ff       	call   80777e <htonl>
  808199:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80819c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8081a0:	89 04 24             	mov    %eax,(%esp)
  8081a3:	e8 c9 f5 ff ff       	call   807771 <ntohs>
  8081a8:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8081ad:	83 c8 10             	or     $0x10,%eax
  8081b0:	89 04 24             	mov    %eax,(%esp)
  8081b3:	e8 ac f5 ff ff       	call   807764 <htons>
  8081b8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8081bc:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8081c0:	89 04 24             	mov    %eax,(%esp)
  8081c3:	e8 9c f5 ff ff       	call   807764 <htons>
  8081c8:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8081cc:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8081d2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8081d6:	89 04 24             	mov    %eax,(%esp)
  8081d9:	e8 93 f5 ff ff       	call   807771 <ntohs>
  8081de:	83 e0 3f             	and    $0x3f,%eax
  8081e1:	80 cc 50             	or     $0x50,%ah
  8081e4:	89 04 24             	mov    %eax,(%esp)
  8081e7:	e8 78 f5 ff ff       	call   807764 <htons>
  8081ec:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  8081f0:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  8081f6:	8d 47 04             	lea    0x4(%edi),%eax
  8081f9:	89 c1                	mov    %eax,%ecx
  8081fb:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8081ff:	89 04 24             	mov    %eax,(%esp)
  808202:	6a 06                	push   $0x6
  808204:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  808207:	51                   	push   %ecx
  808208:	57                   	push   %edi
  808209:	56                   	push   %esi
  80820a:	e8 31 f2 ff ff       	call   807440 <inet_chksum_pseudo>
  80820f:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808213:	83 c4 18             	add    $0x18,%esp
  808216:	6a 06                	push   $0x6
  808218:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  80821c:	50                   	push   %eax
  80821d:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808221:	50                   	push   %eax
  808222:	ff 75 e4             	pushl  -0x1c(%ebp)
  808225:	57                   	push   %edi
  808226:	56                   	push   %esi
  808227:	e8 28 e8 ff ff       	call   806a54 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80822c:	83 c4 14             	add    $0x14,%esp
  80822f:	56                   	push   %esi
  808230:	e8 55 c6 ff ff       	call   80488a <pbuf_free>

    return ERR_OK;
  808235:	83 c4 10             	add    $0x10,%esp
  808238:	b8 00 00 00 00       	mov    $0x0,%eax
  80823d:	e9 1b 03 00 00       	jmp    80855d <tcp_output+0x498>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808242:	83 ec 04             	sub    $0x4,%esp
  808245:	68 1f 27 81 00       	push   $0x81271f
  80824a:	68 05 02 00 00       	push   $0x205
  80824f:	68 e6 26 81 00       	push   $0x8126e6
  808254:	e8 40 64 00 00       	call   80e699 <_panic>
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808259:	83 ec 0c             	sub    $0xc,%esp
  80825c:	8b 43 10             	mov    0x10(%ebx),%eax
  80825f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808263:	50                   	push   %eax
  808264:	e8 08 f5 ff ff       	call   807771 <ntohs>
  808269:	8b 73 10             	mov    0x10(%ebx),%esi
  80826c:	83 c8 10             	or     $0x10,%eax
  80826f:	0f b7 c0             	movzwl %ax,%eax
  808272:	89 04 24             	mov    %eax,(%esp)
  808275:	e8 ea f4 ff ff       	call   807764 <htons>
  80827a:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80827e:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  808282:	83 c4 10             	add    $0x10,%esp
  808285:	e9 06 01 00 00       	jmp    808390 <tcp_output+0x2cb>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
    pcb->rtime = 0;
  80828a:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)
  808290:	e9 49 01 00 00       	jmp    8083de <tcp_output+0x319>

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
  808295:	a1 40 b2 b3 00       	mov    0xb3b240,%eax
  80829a:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80829d:	83 ec 0c             	sub    $0xc,%esp
  8082a0:	8b 43 10             	mov    0x10(%ebx),%eax
  8082a3:	ff 70 04             	pushl  0x4(%eax)
  8082a6:	e8 ea f6 ff ff       	call   807995 <ntohl>
  8082ab:	89 47 3c             	mov    %eax,0x3c(%edi)
  8082ae:	83 c4 10             	add    $0x10,%esp
  8082b1:	e9 32 01 00 00       	jmp    8083e8 <tcp_output+0x323>
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  8082b6:	83 ec 0c             	sub    $0xc,%esp
  8082b9:	8b 43 10             	mov    0x10(%ebx),%eax
  8082bc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082c0:	50                   	push   %eax
  8082c1:	e8 ab f4 ff ff       	call   807771 <ntohs>
  8082c6:	66 d1 e8             	shr    %ax
  8082c9:	89 c2                	mov    %eax,%edx
  8082cb:	83 e2 01             	and    $0x1,%edx
  8082ce:	83 c4 10             	add    $0x10,%esp
  8082d1:	e9 a5 01 00 00       	jmp    80847b <tcp_output+0x3b6>
      pcb->snd_max = pcb->snd_nxt;
  8082d6:	89 77 58             	mov    %esi,0x58(%edi)
  8082d9:	e9 ae 01 00 00       	jmp    80848c <tcp_output+0x3c7>
    if (TCP_TCPLEN(seg) > 0) {
  8082de:	83 ec 0c             	sub    $0xc,%esp
  8082e1:	8b 43 10             	mov    0x10(%ebx),%eax
  8082e4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8082e8:	50                   	push   %eax
  8082e9:	e8 83 f4 ff ff       	call   807771 <ntohs>
  8082ee:	66 d1 e8             	shr    %ax
  8082f1:	83 e0 01             	and    $0x1,%eax
  8082f4:	0f b7 f6             	movzwl %si,%esi
  8082f7:	83 c4 10             	add    $0x10,%esp
  8082fa:	01 f0                	add    %esi,%eax
  8082fc:	0f 85 a9 01 00 00    	jne    8084ab <tcp_output+0x3e6>
      tcp_seg_free(seg);
  808302:	83 ec 0c             	sub    $0xc,%esp
  808305:	53                   	push   %ebx
  808306:	e8 99 d4 ff ff       	call   8057a4 <tcp_seg_free>
  80830b:	83 c4 10             	add    $0x10,%esp
  80830e:	eb 06                	jmp    808316 <tcp_output+0x251>
        pcb->unacked = seg;
  808310:	89 5f 78             	mov    %ebx,0x78(%edi)
  808313:	89 5d dc             	mov    %ebx,-0x24(%ebp)
    seg = pcb->unsent;
  808316:	8b 5f 74             	mov    0x74(%edi),%ebx
  while (seg != NULL &&
  808319:	85 db                	test   %ebx,%ebx
  80831b:	0f 84 33 02 00 00    	je     808554 <tcp_output+0x48f>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808321:	83 ec 0c             	sub    $0xc,%esp
  808324:	8b 43 10             	mov    0x10(%ebx),%eax
  808327:	ff 70 04             	pushl  0x4(%eax)
  80832a:	e8 66 f6 ff ff       	call   807995 <ntohl>
  80832f:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808333:	2b 57 48             	sub    0x48(%edi),%edx
  808336:	01 c2                	add    %eax,%edx
  while (seg != NULL &&
  808338:	83 c4 10             	add    $0x10,%esp
  80833b:	3b 55 d8             	cmp    -0x28(%ebp),%edx
  80833e:	0f 87 07 02 00 00    	ja     80854b <tcp_output+0x486>
    LWIP_ASSERT("RST not expected here!", 
  808344:	83 ec 0c             	sub    $0xc,%esp
  808347:	8b 43 10             	mov    0x10(%ebx),%eax
  80834a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80834e:	50                   	push   %eax
  80834f:	e8 1d f4 ff ff       	call   807771 <ntohs>
  808354:	83 c4 10             	add    $0x10,%esp
  808357:	a8 04                	test   $0x4,%al
  808359:	0f 85 e3 fe ff ff    	jne    808242 <tcp_output+0x17d>
    if((tcp_do_output_nagle(pcb) == 0) &&
  80835f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808363:	74 1c                	je     808381 <tcp_output+0x2bc>
  808365:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  808369:	a8 40                	test   $0x40,%al
  80836b:	75 14                	jne    808381 <tcp_output+0x2bc>
  80836d:	8b 57 74             	mov    0x74(%edi),%edx
  808370:	85 d2                	test   %edx,%edx
  808372:	74 05                	je     808379 <tcp_output+0x2b4>
  808374:	83 3a 00             	cmpl   $0x0,(%edx)
  808377:	75 08                	jne    808381 <tcp_output+0x2bc>
  808379:	a8 a0                	test   $0xa0,%al
  80837b:	0f 84 ca 01 00 00    	je     80854b <tcp_output+0x486>
    pcb->unsent = seg->next;
  808381:	8b 03                	mov    (%ebx),%eax
  808383:	89 47 74             	mov    %eax,0x74(%edi)
    if (pcb->state != SYN_SENT) {
  808386:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80838a:	0f 85 c9 fe ff ff    	jne    808259 <tcp_output+0x194>
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  808390:	8b 73 10             	mov    0x10(%ebx),%esi
  808393:	83 ec 0c             	sub    $0xc,%esp
  808396:	ff 77 24             	pushl  0x24(%edi)
  808399:	e8 e0 f3 ff ff       	call   80777e <htonl>
  80839e:	89 46 08             	mov    %eax,0x8(%esi)
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8083a1:	8b 73 10             	mov    0x10(%ebx),%esi
  8083a4:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8083a8:	89 04 24             	mov    %eax,(%esp)
  8083ab:	e8 b4 f3 ff ff       	call   807764 <htons>
  8083b0:	66 89 46 0e          	mov    %ax,0xe(%esi)
  if (ip_addr_isany(&(pcb->local_ip))) {
  8083b4:	83 c4 10             	add    $0x10,%esp
  8083b7:	83 3f 00             	cmpl   $0x0,(%edi)
  8083ba:	75 17                	jne    8083d3 <tcp_output+0x30e>
    netif = ip_route(&(pcb->remote_ip));
  8083bc:	83 ec 0c             	sub    $0xc,%esp
  8083bf:	ff 75 e4             	pushl  -0x1c(%ebp)
  8083c2:	e8 7d e1 ff ff       	call   806544 <ip_route>
    if (netif == NULL) {
  8083c7:	83 c4 10             	add    $0x10,%esp
  8083ca:	85 c0                	test   %eax,%eax
  8083cc:	74 79                	je     808447 <tcp_output+0x382>
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8083ce:	8b 40 04             	mov    0x4(%eax),%eax
  8083d1:	89 07                	mov    %eax,(%edi)
  if(pcb->rtime == -1)
  8083d3:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  8083d8:	0f 84 ac fe ff ff    	je     80828a <tcp_output+0x1c5>
  if (pcb->rttest == 0) {
  8083de:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  8083e2:	0f 84 ad fe ff ff    	je     808295 <tcp_output+0x1d0>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8083e8:	8b 53 04             	mov    0x4(%ebx),%edx
  8083eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8083ee:	2b 42 04             	sub    0x4(%edx),%eax

  seg->p->len -= len;
  8083f1:	66 29 42 0a          	sub    %ax,0xa(%edx)
  seg->p->tot_len -= len;
  8083f5:	8b 53 04             	mov    0x4(%ebx),%edx
  8083f8:	66 29 42 08          	sub    %ax,0x8(%edx)

  seg->p->payload = seg->tcphdr;
  8083fc:	8b 53 04             	mov    0x4(%ebx),%edx
  8083ff:	8b 43 10             	mov    0x10(%ebx),%eax
  808402:	89 42 04             	mov    %eax,0x4(%edx)

  seg->tcphdr->chksum = 0;
  808405:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80840b:	8b 43 04             	mov    0x4(%ebx),%eax
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80840e:	8b 73 10             	mov    0x10(%ebx),%esi
  808411:	83 ec 0c             	sub    $0xc,%esp
  808414:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808418:	52                   	push   %edx
  808419:	6a 06                	push   $0x6
  80841b:	ff 75 e4             	pushl  -0x1c(%ebp)
  80841e:	57                   	push   %edi
  80841f:	50                   	push   %eax
  808420:	e8 1b f0 ff ff       	call   807440 <inet_chksum_pseudo>
  808425:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808429:	83 c4 18             	add    $0x18,%esp
  80842c:	6a 06                	push   $0x6
  80842e:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808432:	50                   	push   %eax
  808433:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808437:	50                   	push   %eax
  808438:	ff 75 e4             	pushl  -0x1c(%ebp)
  80843b:	57                   	push   %edi
  80843c:	ff 73 04             	pushl  0x4(%ebx)
  80843f:	e8 10 e6 ff ff       	call   806a54 <ip_output>
  808444:	83 c4 20             	add    $0x20,%esp
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808447:	83 ec 0c             	sub    $0xc,%esp
  80844a:	8b 43 10             	mov    0x10(%ebx),%eax
  80844d:	ff 70 04             	pushl  0x4(%eax)
  808450:	e8 40 f5 ff ff       	call   807995 <ntohl>
  808455:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808458:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80845c:	8b 43 10             	mov    0x10(%ebx),%eax
  80845f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808463:	89 04 24             	mov    %eax,(%esp)
  808466:	e8 06 f3 ff ff       	call   807771 <ntohs>
  80846b:	83 c4 10             	add    $0x10,%esp
  80846e:	ba 01 00 00 00       	mov    $0x1,%edx
  808473:	a8 01                	test   $0x1,%al
  808475:	0f 84 3b fe ff ff    	je     8082b6 <tcp_output+0x1f1>
  80847b:	01 d6                	add    %edx,%esi
  80847d:	03 75 e0             	add    -0x20(%ebp),%esi
  808480:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  808483:	39 77 58             	cmp    %esi,0x58(%edi)
  808486:	0f 88 4a fe ff ff    	js     8082d6 <tcp_output+0x211>
    if (TCP_TCPLEN(seg) > 0) {
  80848c:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808490:	83 ec 0c             	sub    $0xc,%esp
  808493:	8b 43 10             	mov    0x10(%ebx),%eax
  808496:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80849a:	50                   	push   %eax
  80849b:	e8 d1 f2 ff ff       	call   807771 <ntohs>
  8084a0:	83 c4 10             	add    $0x10,%esp
  8084a3:	a8 01                	test   $0x1,%al
  8084a5:	0f 84 33 fe ff ff    	je     8082de <tcp_output+0x219>
      seg->next = NULL;
  8084ab:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      if (pcb->unacked == NULL) {
  8084b1:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8084b5:	0f 84 55 fe ff ff    	je     808310 <tcp_output+0x24b>
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  8084bb:	83 ec 0c             	sub    $0xc,%esp
  8084be:	8b 43 10             	mov    0x10(%ebx),%eax
  8084c1:	ff 70 04             	pushl  0x4(%eax)
  8084c4:	e8 cc f4 ff ff       	call   807995 <ntohl>
  8084c9:	89 c6                	mov    %eax,%esi
  8084cb:	83 c4 04             	add    $0x4,%esp
  8084ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8084d1:	8b 40 10             	mov    0x10(%eax),%eax
  8084d4:	ff 70 04             	pushl  0x4(%eax)
  8084d7:	e8 b9 f4 ff ff       	call   807995 <ntohl>
  8084dc:	83 c4 10             	add    $0x10,%esp
  8084df:	39 c6                	cmp    %eax,%esi
  8084e1:	78 0d                	js     8084f0 <tcp_output+0x42b>
          useg->next = seg;
  8084e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8084e6:	89 18                	mov    %ebx,(%eax)
  8084e8:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  8084eb:	e9 26 fe ff ff       	jmp    808316 <tcp_output+0x251>
          seg->next = pcb->unacked;
  8084f0:	8b 47 78             	mov    0x78(%edi),%eax
  8084f3:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  8084f5:	89 5f 78             	mov    %ebx,0x78(%edi)
  8084f8:	e9 19 fe ff ff       	jmp    808316 <tcp_output+0x251>
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8084fd:	8d 47 04             	lea    0x4(%edi),%eax
  808500:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808503:	e9 11 fe ff ff       	jmp    808319 <tcp_output+0x254>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808508:	83 ec 0c             	sub    $0xc,%esp
  80850b:	8b 43 10             	mov    0x10(%ebx),%eax
  80850e:	ff 70 04             	pushl  0x4(%eax)
  808511:	e8 7f f4 ff ff       	call   807995 <ntohl>
  808516:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80851a:	2b 57 48             	sub    0x48(%edi),%edx
  80851d:	01 c2                	add    %eax,%edx
  80851f:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  if (seg != NULL && pcb->persist_backoff == 0 && 
  808523:	83 c4 10             	add    $0x10,%esp
  808526:	39 c2                	cmp    %eax,%edx
  808528:	76 2a                	jbe    808554 <tcp_output+0x48f>
    pcb->persist_cnt = 0;
  80852a:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808531:	00 00 00 
    pcb->persist_backoff = 1;
  808534:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  80853b:	eb 17                	jmp    808554 <tcp_output+0x48f>
    return ERR_OK;
  80853d:	b8 00 00 00 00       	mov    $0x0,%eax
  808542:	eb 19                	jmp    80855d <tcp_output+0x498>
      return ERR_BUF;
  808544:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808549:	eb 12                	jmp    80855d <tcp_output+0x498>
  if (seg != NULL && pcb->persist_backoff == 0 && 
  80854b:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808552:	74 b4                	je     808508 <tcp_output+0x443>
  pcb->flags &= ~TF_NAGLEMEMERR;
  808554:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808558:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80855d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808560:	5b                   	pop    %ebx
  808561:	5e                   	pop    %esi
  808562:	5f                   	pop    %edi
  808563:	5d                   	pop    %ebp
  808564:	c3                   	ret    

00808565 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808565:	55                   	push   %ebp
  808566:	89 e5                	mov    %esp,%ebp
  808568:	57                   	push   %edi
  808569:	56                   	push   %esi
  80856a:	53                   	push   %ebx
  80856b:	83 ec 20             	sub    $0x20,%esp
  80856e:	8b 7d 18             	mov    0x18(%ebp),%edi
  808571:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808574:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808577:	6a 00                	push   $0x0
  808579:	6a 14                	push   $0x14
  80857b:	6a 01                	push   $0x1
  80857d:	e8 ce c3 ff ff       	call   804950 <pbuf_alloc>
  if (p == NULL) {
  808582:	83 c4 10             	add    $0x10,%esp
  808585:	85 c0                	test   %eax,%eax
  808587:	0f 84 e2 00 00 00    	je     80866f <tcp_rst+0x10a>
  80858d:	89 c6                	mov    %eax,%esi
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80858f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808594:	0f 86 dd 00 00 00    	jbe    808677 <tcp_rst+0x112>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80859a:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80859d:	83 ec 0c             	sub    $0xc,%esp
  8085a0:	0f b7 ff             	movzwl %di,%edi
  8085a3:	57                   	push   %edi
  8085a4:	e8 bb f1 ff ff       	call   807764 <htons>
  8085a9:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  8085ac:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8085b0:	89 04 24             	mov    %eax,(%esp)
  8085b3:	e8 ac f1 ff ff       	call   807764 <htons>
  8085b8:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  8085bc:	83 c4 04             	add    $0x4,%esp
  8085bf:	ff 75 08             	pushl  0x8(%ebp)
  8085c2:	e8 b7 f1 ff ff       	call   80777e <htonl>
  8085c7:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  8085ca:	83 c4 04             	add    $0x4,%esp
  8085cd:	ff 75 0c             	pushl  0xc(%ebp)
  8085d0:	e8 a9 f1 ff ff       	call   80777e <htonl>
  8085d5:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8085d8:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8085dc:	89 04 24             	mov    %eax,(%esp)
  8085df:	e8 8d f1 ff ff       	call   807771 <ntohs>
  8085e4:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8085e9:	83 c8 14             	or     $0x14,%eax
  8085ec:	89 04 24             	mov    %eax,(%esp)
  8085ef:	e8 70 f1 ff ff       	call   807764 <htons>
  8085f4:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  8085f8:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  8085ff:	e8 60 f1 ff ff       	call   807764 <htons>
  808604:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808608:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80860e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808612:	89 04 24             	mov    %eax,(%esp)
  808615:	e8 57 f1 ff ff       	call   807771 <ntohs>
  80861a:	83 e0 3f             	and    $0x3f,%eax
  80861d:	80 cc 50             	or     $0x50,%ah
  808620:	89 04 24             	mov    %eax,(%esp)
  808623:	e8 3c f1 ff ff       	call   807764 <htons>
  808628:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80862c:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808632:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808636:	89 04 24             	mov    %eax,(%esp)
  808639:	6a 06                	push   $0x6
  80863b:	ff 75 14             	pushl  0x14(%ebp)
  80863e:	ff 75 10             	pushl  0x10(%ebp)
  808641:	56                   	push   %esi
  808642:	e8 f9 ed ff ff       	call   807440 <inet_chksum_pseudo>
  808647:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80864b:	83 c4 18             	add    $0x18,%esp
  80864e:	6a 06                	push   $0x6
  808650:	6a 00                	push   $0x0
  808652:	68 ff 00 00 00       	push   $0xff
  808657:	ff 75 14             	pushl  0x14(%ebp)
  80865a:	ff 75 10             	pushl  0x10(%ebp)
  80865d:	56                   	push   %esi
  80865e:	e8 f1 e3 ff ff       	call   806a54 <ip_output>
  pbuf_free(p);
  808663:	83 c4 14             	add    $0x14,%esp
  808666:	56                   	push   %esi
  808667:	e8 1e c2 ff ff       	call   80488a <pbuf_free>
  80866c:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80866f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808672:	5b                   	pop    %ebx
  808673:	5e                   	pop    %esi
  808674:	5f                   	pop    %edi
  808675:	5d                   	pop    %ebp
  808676:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808677:	83 ec 04             	sub    $0x4,%esp
  80867a:	68 b8 26 81 00       	push   $0x8126b8
  80867f:	68 be 02 00 00       	push   $0x2be
  808684:	68 e6 26 81 00       	push   $0x8126e6
  808689:	e8 0b 60 00 00       	call   80e699 <_panic>

0080868e <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80868e:	55                   	push   %ebp
  80868f:	89 e5                	mov    %esp,%ebp
  808691:	53                   	push   %ebx
  808692:	83 ec 04             	sub    $0x4,%esp
  808695:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808698:	8b 53 78             	mov    0x78(%ebx),%edx
  80869b:	85 d2                	test   %edx,%edx
  80869d:	75 04                	jne    8086a3 <tcp_rexmit_rto+0x15>
  80869f:	eb 41                	jmp    8086e2 <tcp_rexmit_rto+0x54>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  8086a1:	89 c2                	mov    %eax,%edx
  8086a3:	8b 02                	mov    (%edx),%eax
  8086a5:	85 c0                	test   %eax,%eax
  8086a7:	75 f8                	jne    8086a1 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  8086a9:	8b 43 74             	mov    0x74(%ebx),%eax
  8086ac:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  8086ae:	8b 43 78             	mov    0x78(%ebx),%eax
  8086b1:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  8086b4:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  8086bb:	83 ec 0c             	sub    $0xc,%esp
  8086be:	8b 40 10             	mov    0x10(%eax),%eax
  8086c1:	ff 70 04             	pushl  0x4(%eax)
  8086c4:	e8 cc f2 ff ff       	call   807995 <ntohl>
  8086c9:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  8086cc:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  8086d0:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8086d7:	89 1c 24             	mov    %ebx,(%esp)
  8086da:	e8 e6 f9 ff ff       	call   8080c5 <tcp_output>
  8086df:	83 c4 10             	add    $0x10,%esp
}
  8086e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8086e5:	c9                   	leave  
  8086e6:	c3                   	ret    

008086e7 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8086e7:	55                   	push   %ebp
  8086e8:	89 e5                	mov    %esp,%ebp
  8086ea:	53                   	push   %ebx
  8086eb:	83 ec 04             	sub    $0x4,%esp
  8086ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8086f1:	8b 43 78             	mov    0x78(%ebx),%eax
  8086f4:	85 c0                	test   %eax,%eax
  8086f6:	74 37                	je     80872f <tcp_rexmit+0x48>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  8086f8:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  8086fa:	8b 4b 74             	mov    0x74(%ebx),%ecx
  8086fd:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  8086ff:	8b 43 78             	mov    0x78(%ebx),%eax
  808702:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808705:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808708:	83 ec 0c             	sub    $0xc,%esp
  80870b:	8b 40 10             	mov    0x10(%eax),%eax
  80870e:	ff 70 04             	pushl  0x4(%eax)
  808711:	e8 7f f2 ff ff       	call   807995 <ntohl>
  808716:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808719:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80871d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808724:	89 1c 24             	mov    %ebx,(%esp)
  808727:	e8 99 f9 ff ff       	call   8080c5 <tcp_output>
  80872c:	83 c4 10             	add    $0x10,%esp
}
  80872f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  808732:	c9                   	leave  
  808733:	c3                   	ret    

00808734 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808734:	55                   	push   %ebp
  808735:	89 e5                	mov    %esp,%ebp
  808737:	57                   	push   %edi
  808738:	56                   	push   %esi
  808739:	53                   	push   %ebx
  80873a:	83 ec 20             	sub    $0x20,%esp
  80873d:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808740:	6a 00                	push   $0x0
  808742:	6a 14                	push   $0x14
  808744:	6a 01                	push   $0x1
  808746:	e8 05 c2 ff ff       	call   804950 <pbuf_alloc>
   
  if(p == NULL) {
  80874b:	83 c4 10             	add    $0x10,%esp
  80874e:	85 c0                	test   %eax,%eax
  808750:	0f 84 e5 00 00 00    	je     80883b <tcp_keepalive+0x107>
  808756:	89 c7                	mov    %eax,%edi
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808758:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80875d:	0f 86 e0 00 00 00    	jbe    808843 <tcp_keepalive+0x10f>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808763:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808766:	83 ec 0c             	sub    $0xc,%esp
  808769:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80876d:	50                   	push   %eax
  80876e:	e8 f1 ef ff ff       	call   807764 <htons>
  808773:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808776:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80877a:	89 04 24             	mov    %eax,(%esp)
  80877d:	e8 e2 ef ff ff       	call   807764 <htons>
  808782:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808786:	8b 46 54             	mov    0x54(%esi),%eax
  808789:	83 e8 01             	sub    $0x1,%eax
  80878c:	89 04 24             	mov    %eax,(%esp)
  80878f:	e8 ea ef ff ff       	call   80777e <htonl>
  808794:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808797:	83 c4 04             	add    $0x4,%esp
  80879a:	ff 76 24             	pushl  0x24(%esi)
  80879d:	e8 dc ef ff ff       	call   80777e <htonl>
  8087a2:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8087a5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087a9:	89 04 24             	mov    %eax,(%esp)
  8087ac:	e8 c0 ef ff ff       	call   807771 <ntohs>
  8087b1:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8087b6:	89 04 24             	mov    %eax,(%esp)
  8087b9:	e8 a6 ef ff ff       	call   807764 <htons>
  8087be:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8087c2:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8087c6:	89 04 24             	mov    %eax,(%esp)
  8087c9:	e8 96 ef ff ff       	call   807764 <htons>
  8087ce:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  8087d2:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8087d8:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8087dc:	89 04 24             	mov    %eax,(%esp)
  8087df:	e8 8d ef ff ff       	call   807771 <ntohs>
  8087e4:	83 e0 3f             	and    $0x3f,%eax
  8087e7:	80 cc 50             	or     $0x50,%ah
  8087ea:	89 04 24             	mov    %eax,(%esp)
  8087ed:	e8 72 ef ff ff       	call   807764 <htons>
  8087f2:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  8087f6:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  8087fc:	8d 46 04             	lea    0x4(%esi),%eax
  8087ff:	89 c2                	mov    %eax,%edx
  808801:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808805:	89 04 24             	mov    %eax,(%esp)
  808808:	6a 06                	push   $0x6
  80880a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80880d:	52                   	push   %edx
  80880e:	56                   	push   %esi
  80880f:	57                   	push   %edi
  808810:	e8 2b ec ff ff       	call   807440 <inet_chksum_pseudo>
  808815:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808819:	83 c4 18             	add    $0x18,%esp
  80881c:	6a 06                	push   $0x6
  80881e:	6a 00                	push   $0x0
  808820:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808824:	50                   	push   %eax
  808825:	ff 75 e4             	pushl  -0x1c(%ebp)
  808828:	56                   	push   %esi
  808829:	57                   	push   %edi
  80882a:	e8 25 e2 ff ff       	call   806a54 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80882f:	83 c4 14             	add    $0x14,%esp
  808832:	57                   	push   %edi
  808833:	e8 52 c0 ff ff       	call   80488a <pbuf_free>
  808838:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80883b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80883e:	5b                   	pop    %ebx
  80883f:	5e                   	pop    %esi
  808840:	5f                   	pop    %edi
  808841:	5d                   	pop    %ebp
  808842:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808843:	83 ec 04             	sub    $0x4,%esp
  808846:	68 b8 26 81 00       	push   $0x8126b8
  80884b:	68 3a 03 00 00       	push   $0x33a
  808850:	68 e6 26 81 00       	push   $0x8126e6
  808855:	e8 3f 5e 00 00       	call   80e699 <_panic>

0080885a <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80885a:	55                   	push   %ebp
  80885b:	89 e5                	mov    %esp,%ebp
  80885d:	57                   	push   %edi
  80885e:	56                   	push   %esi
  80885f:	53                   	push   %ebx
  808860:	83 ec 1c             	sub    $0x1c,%esp
  808863:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808866:	8b 46 78             	mov    0x78(%esi),%eax
  808869:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80886c:	85 c0                	test   %eax,%eax
  80886e:	0f 84 10 01 00 00    	je     808984 <tcp_zero_window_probe+0x12a>
    seg = pcb->unsent;

  if(seg == NULL)
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808874:	83 ec 04             	sub    $0x4,%esp
  808877:	6a 00                	push   $0x0
  808879:	6a 15                	push   $0x15
  80887b:	6a 01                	push   $0x1
  80887d:	e8 ce c0 ff ff       	call   804950 <pbuf_alloc>
  808882:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808884:	83 c4 10             	add    $0x10,%esp
  808887:	85 c0                	test   %eax,%eax
  808889:	0f 84 ed 00 00 00    	je     80897c <tcp_zero_window_probe+0x122>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80888f:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808894:	0f 86 f9 00 00 00    	jbe    808993 <tcp_zero_window_probe+0x139>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80889a:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80889d:	83 ec 0c             	sub    $0xc,%esp
  8088a0:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  8088a4:	50                   	push   %eax
  8088a5:	e8 ba ee ff ff       	call   807764 <htons>
  8088aa:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  8088ad:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  8088b1:	89 04 24             	mov    %eax,(%esp)
  8088b4:	e8 ab ee ff ff       	call   807764 <htons>
  8088b9:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  8088bd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8088c0:	8b 40 10             	mov    0x10(%eax),%eax
  8088c3:	8b 40 04             	mov    0x4(%eax),%eax
  8088c6:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8088c9:	83 c4 04             	add    $0x4,%esp
  8088cc:	ff 76 24             	pushl  0x24(%esi)
  8088cf:	e8 aa ee ff ff       	call   80777e <htonl>
  8088d4:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8088d7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8088db:	89 04 24             	mov    %eax,(%esp)
  8088de:	e8 8e ee ff ff       	call   807771 <ntohs>
  8088e3:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8088e8:	89 04 24             	mov    %eax,(%esp)
  8088eb:	e8 74 ee ff ff       	call   807764 <htons>
  8088f0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8088f4:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  8088f8:	89 04 24             	mov    %eax,(%esp)
  8088fb:	e8 64 ee ff ff       	call   807764 <htons>
  808900:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808904:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80890a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80890e:	89 04 24             	mov    %eax,(%esp)
  808911:	e8 5b ee ff ff       	call   807771 <ntohs>
  808916:	83 e0 3f             	and    $0x3f,%eax
  808919:	80 cc 50             	or     $0x50,%ah
  80891c:	89 04 24             	mov    %eax,(%esp)
  80891f:	e8 40 ee ff ff       	call   807764 <htons>
  808924:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  808928:	8b 47 04             	mov    0x4(%edi),%eax
  80892b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80892e:	8b 51 08             	mov    0x8(%ecx),%edx
  808931:	0f b6 12             	movzbl (%edx),%edx
  808934:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  808937:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80893d:	8d 46 04             	lea    0x4(%esi),%eax
  808940:	89 c1                	mov    %eax,%ecx
  808942:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808946:	89 04 24             	mov    %eax,(%esp)
  808949:	6a 06                	push   $0x6
  80894b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80894e:	51                   	push   %ecx
  80894f:	56                   	push   %esi
  808950:	57                   	push   %edi
  808951:	e8 ea ea ff ff       	call   807440 <inet_chksum_pseudo>
  808956:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80895a:	83 c4 18             	add    $0x18,%esp
  80895d:	6a 06                	push   $0x6
  80895f:	6a 00                	push   $0x0
  808961:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808965:	50                   	push   %eax
  808966:	ff 75 e4             	pushl  -0x1c(%ebp)
  808969:	56                   	push   %esi
  80896a:	57                   	push   %edi
  80896b:	e8 e4 e0 ff ff       	call   806a54 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808970:	83 c4 14             	add    $0x14,%esp
  808973:	57                   	push   %edi
  808974:	e8 11 bf ff ff       	call   80488a <pbuf_free>
  808979:	83 c4 10             	add    $0x10,%esp

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80897c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80897f:	5b                   	pop    %ebx
  808980:	5e                   	pop    %esi
  808981:	5f                   	pop    %edi
  808982:	5d                   	pop    %ebp
  808983:	c3                   	ret    
    seg = pcb->unsent;
  808984:	8b 46 74             	mov    0x74(%esi),%eax
  808987:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(seg == NULL)
  80898a:	85 c0                	test   %eax,%eax
  80898c:	74 ee                	je     80897c <tcp_zero_window_probe+0x122>
  80898e:	e9 e1 fe ff ff       	jmp    808874 <tcp_zero_window_probe+0x1a>
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808993:	83 ec 04             	sub    $0x4,%esp
  808996:	68 b8 26 81 00       	push   $0x8126b8
  80899b:	68 8d 03 00 00       	push   $0x38d
  8089a0:	68 e6 26 81 00       	push   $0x8126e6
  8089a5:	e8 ef 5c 00 00       	call   80e699 <_panic>

008089aa <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8089aa:	55                   	push   %ebp
  8089ab:	89 e5                	mov    %esp,%ebp
  8089ad:	57                   	push   %edi
  8089ae:	56                   	push   %esi
  8089af:	53                   	push   %ebx
  8089b0:	83 ec 38             	sub    $0x38,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8089b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8089b6:	8b 78 04             	mov    0x4(%eax),%edi

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  8089b9:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8089bd:	0f b7 07             	movzwl (%edi),%eax
  8089c0:	50                   	push   %eax
  8089c1:	e8 ab ed ff ff       	call   807771 <ntohs>
  8089c6:	66 c1 e8 08          	shr    $0x8,%ax
  8089ca:	83 e0 0f             	and    $0xf,%eax
  8089cd:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8089d4:	83 c4 10             	add    $0x10,%esp
  8089d7:	39 c3                	cmp    %eax,%ebx
  8089d9:	7c 29                	jl     808a04 <udp_input+0x5a>
  8089db:	83 ec 0c             	sub    $0xc,%esp
  8089de:	0f b7 07             	movzwl (%edi),%eax
  8089e1:	50                   	push   %eax
  8089e2:	e8 8a ed ff ff       	call   807771 <ntohs>
  8089e7:	83 c4 08             	add    $0x8,%esp
  8089ea:	66 c1 e8 06          	shr    $0x6,%ax
  8089ee:	83 e0 3c             	and    $0x3c,%eax
  8089f1:	f7 d8                	neg    %eax
  8089f3:	98                   	cwtl   
  8089f4:	50                   	push   %eax
  8089f5:	ff 75 08             	pushl  0x8(%ebp)
  8089f8:	e8 c0 bd ff ff       	call   8047bd <pbuf_header>
  8089fd:	83 c4 10             	add    $0x10,%esp
  808a00:	84 c0                	test   %al,%al
  808a02:	74 16                	je     808a1a <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  808a04:	83 ec 0c             	sub    $0xc,%esp
  808a07:	ff 75 08             	pushl  0x8(%ebp)
  808a0a:	e8 7b be ff ff       	call   80488a <pbuf_free>
    goto end;
  808a0f:	83 c4 10             	add    $0x10,%esp
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  808a12:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808a15:	5b                   	pop    %ebx
  808a16:	5e                   	pop    %esi
  808a17:	5f                   	pop    %edi
  808a18:	5d                   	pop    %ebp
  808a19:	c3                   	ret    
  udphdr = (struct udp_hdr *)p->payload;
  808a1a:	8b 45 08             	mov    0x8(%ebp),%eax
  808a1d:	8b 70 04             	mov    0x4(%eax),%esi
  808a20:	89 75 d8             	mov    %esi,-0x28(%ebp)
  src = ntohs(udphdr->src);
  808a23:	83 ec 0c             	sub    $0xc,%esp
  808a26:	0f b7 06             	movzwl (%esi),%eax
  808a29:	50                   	push   %eax
  808a2a:	e8 42 ed ff ff       	call   807771 <ntohs>
  808a2f:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  808a33:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  808a37:	89 04 24             	mov    %eax,(%esp)
  808a3a:	e8 32 ed ff ff       	call   807771 <ntohs>
  808a3f:	89 c6                	mov    %eax,%esi
  if (dest == DHCP_CLIENT_PORT) {
  808a41:	83 c4 10             	add    $0x10,%esp
  808a44:	66 83 f8 44          	cmp    $0x44,%ax
  808a48:	74 1f                	je     808a69 <udp_input+0xbf>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808a4a:	8b 1d 54 b2 b3 00    	mov    0xb3b254,%ebx
    uncon_pcb = NULL;
  808a50:	b9 00 00 00 00       	mov    $0x0,%ecx
    prev = NULL;
  808a55:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808a5c:	8d 47 10             	lea    0x10(%edi),%eax
  808a5f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  808a62:	89 7d dc             	mov    %edi,-0x24(%ebp)
  808a65:	89 cf                	mov    %ecx,%edi
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808a67:	eb 51                	jmp    808aba <udp_input+0x110>
    if (src == DHCP_SERVER_PORT) {
  808a69:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  808a6e:	0f 85 c8 01 00 00    	jne    808c3c <udp_input+0x292>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  808a74:	8b 45 0c             	mov    0xc(%ebp),%eax
  808a77:	8b 40 20             	mov    0x20(%eax),%eax
  808a7a:	85 c0                	test   %eax,%eax
  808a7c:	0f 84 ba 01 00 00    	je     808c3c <udp_input+0x292>
  808a82:	8b 58 08             	mov    0x8(%eax),%ebx
  808a85:	85 db                	test   %ebx,%ebx
  808a87:	0f 84 af 01 00 00    	je     808c3c <udp_input+0x292>
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  808a8d:	8b 43 04             	mov    0x4(%ebx),%eax
  808a90:	85 c0                	test   %eax,%eax
  808a92:	0f 84 b4 01 00 00    	je     808c4c <udp_input+0x2a2>
  808a98:	3b 47 0c             	cmp    0xc(%edi),%eax
  808a9b:	0f 85 9b 01 00 00    	jne    808c3c <udp_input+0x292>
  808aa1:	e9 a6 01 00 00       	jmp    808c4c <udp_input+0x2a2>
        if ((uncon_pcb == NULL) && 
  808aa6:	85 ff                	test   %edi,%edi
  808aa8:	74 43                	je     808aed <udp_input+0x143>
      if ((local_match != 0) &&
  808aaa:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  808aae:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  808ab2:	74 45                	je     808af9 <udp_input+0x14f>
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  808ab4:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  808ab7:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808aba:	85 db                	test   %ebx,%ebx
  808abc:	0f 84 6d 01 00 00    	je     808c2f <udp_input+0x285>
      if ((pcb->local_port == dest) &&
  808ac2:	66 3b 73 12          	cmp    0x12(%ebx),%si
  808ac6:	75 ec                	jne    808ab4 <udp_input+0x10a>
          (ip_addr_isany(&pcb->local_ip) ||
  808ac8:	8b 03                	mov    (%ebx),%eax
  808aca:	85 c0                	test   %eax,%eax
  808acc:	74 d8                	je     808aa6 <udp_input+0xfc>
  808ace:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  808ad1:	3b 41 10             	cmp    0x10(%ecx),%eax
  808ad4:	74 d0                	je     808aa6 <udp_input+0xfc>
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  808ad6:	83 ec 08             	sub    $0x8,%esp
  808ad9:	ff 75 0c             	pushl  0xc(%ebp)
  808adc:	ff 75 d4             	pushl  -0x2c(%ebp)
  808adf:	e8 1d da ff ff       	call   806501 <ip_addr_isbroadcast>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  808ae4:	83 c4 10             	add    $0x10,%esp
  808ae7:	84 c0                	test   %al,%al
  808ae9:	74 c9                	je     808ab4 <udp_input+0x10a>
  808aeb:	eb b9                	jmp    808aa6 <udp_input+0xfc>
        if ((uncon_pcb == NULL) && 
  808aed:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  808af1:	83 e0 04             	and    $0x4,%eax
  808af4:	0f 44 fb             	cmove  %ebx,%edi
  808af7:	eb b1                	jmp    808aaa <udp_input+0x100>
          (ip_addr_isany(&pcb->remote_ip) ||
  808af9:	8b 43 04             	mov    0x4(%ebx),%eax
  808afc:	85 c0                	test   %eax,%eax
  808afe:	74 08                	je     808b08 <udp_input+0x15e>
  808b00:	8b 55 dc             	mov    -0x24(%ebp),%edx
  808b03:	3b 42 0c             	cmp    0xc(%edx),%eax
  808b06:	75 ac                	jne    808ab4 <udp_input+0x10a>
  808b08:	8b 7d dc             	mov    -0x24(%ebp),%edi
        if (prev != NULL) {
  808b0b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808b0e:	85 d2                	test   %edx,%edx
  808b10:	0f 84 36 01 00 00    	je     808c4c <udp_input+0x2a2>
          prev->next = pcb->next;
  808b16:	8b 43 0c             	mov    0xc(%ebx),%eax
  808b19:	89 42 0c             	mov    %eax,0xc(%edx)
          pcb->next = udp_pcbs;
  808b1c:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808b21:	89 43 0c             	mov    %eax,0xc(%ebx)
          udp_pcbs = pcb;
  808b24:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  808b2a:	e9 1d 01 00 00       	jmp    808c4c <udp_input+0x2a2>
  808b2f:	89 c3                	mov    %eax,%ebx
  808b31:	e9 16 01 00 00       	jmp    808c4c <udp_input+0x2a2>
          pbuf_free(p);
  808b36:	83 ec 0c             	sub    $0xc,%esp
  808b39:	ff 75 08             	pushl  0x8(%ebp)
  808b3c:	e8 49 bd ff ff       	call   80488a <pbuf_free>
          goto end;
  808b41:	83 c4 10             	add    $0x10,%esp
  808b44:	e9 c9 fe ff ff       	jmp    808a12 <udp_input+0x68>
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808b49:	83 ec 04             	sub    $0x4,%esp
  808b4c:	68 0b 27 81 00       	push   $0x81270b
  808b51:	68 0a 01 00 00       	push   $0x10a
  808b56:	68 36 27 81 00       	push   $0x812736
  808b5b:	e8 39 5b 00 00       	call   80e699 <_panic>
        pbuf_free(p);
  808b60:	83 ec 0c             	sub    $0xc,%esp
  808b63:	ff 75 08             	pushl  0x8(%ebp)
  808b66:	e8 1f bd ff ff       	call   80488a <pbuf_free>
        goto end;
  808b6b:	83 c4 10             	add    $0x10,%esp
  808b6e:	e9 9f fe ff ff       	jmp    808a12 <udp_input+0x68>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808b73:	83 ec 08             	sub    $0x8,%esp
  808b76:	ff 75 0c             	pushl  0xc(%ebp)
  808b79:	8d 47 10             	lea    0x10(%edi),%eax
  808b7c:	50                   	push   %eax
  808b7d:	e8 7f d9 ff ff       	call   806501 <ip_addr_isbroadcast>
  808b82:	83 c4 10             	add    $0x10,%esp
  808b85:	84 c0                	test   %al,%al
  808b87:	75 25                	jne    808bae <udp_input+0x204>
          !ip_addr_ismulticast(&iphdr->dest)) {
  808b89:	8b 5f 10             	mov    0x10(%edi),%ebx
  808b8c:	83 ec 0c             	sub    $0xc,%esp
  808b8f:	68 00 00 00 f0       	push   $0xf0000000
  808b94:	e8 fc ed ff ff       	call   807995 <ntohl>
  808b99:	21 c3                	and    %eax,%ebx
  808b9b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  808ba2:	e8 ee ed ff ff       	call   807995 <ntohl>
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  808ba7:	83 c4 10             	add    $0x10,%esp
  808baa:	39 c3                	cmp    %eax,%ebx
  808bac:	75 13                	jne    808bc1 <udp_input+0x217>
      pbuf_free(p);
  808bae:	83 ec 0c             	sub    $0xc,%esp
  808bb1:	ff 75 08             	pushl  0x8(%ebp)
  808bb4:	e8 d1 bc ff ff       	call   80488a <pbuf_free>
  808bb9:	83 c4 10             	add    $0x10,%esp
  808bbc:	e9 51 fe ff ff       	jmp    808a12 <udp_input+0x68>
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  808bc1:	83 ec 0c             	sub    $0xc,%esp
  808bc4:	0f b7 07             	movzwl (%edi),%eax
  808bc7:	50                   	push   %eax
  808bc8:	e8 a4 eb ff ff       	call   807771 <ntohs>
  808bcd:	83 c4 08             	add    $0x8,%esp
  808bd0:	66 c1 e8 08          	shr    $0x8,%ax
  808bd4:	83 e0 0f             	and    $0xf,%eax
  808bd7:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  808bde:	98                   	cwtl   
  808bdf:	50                   	push   %eax
  808be0:	ff 75 08             	pushl  0x8(%ebp)
  808be3:	e8 d5 bb ff ff       	call   8047bd <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808be8:	83 c4 10             	add    $0x10,%esp
  808beb:	8b 45 08             	mov    0x8(%ebp),%eax
  808bee:	3b 78 04             	cmp    0x4(%eax),%edi
  808bf1:	75 12                	jne    808c05 <udp_input+0x25b>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  808bf3:	83 ec 08             	sub    $0x8,%esp
  808bf6:	6a 03                	push   $0x3
  808bf8:	ff 75 08             	pushl  0x8(%ebp)
  808bfb:	e8 c6 57 00 00       	call   80e3c6 <icmp_dest_unreach>
  808c00:	83 c4 10             	add    $0x10,%esp
  808c03:	eb a9                	jmp    808bae <udp_input+0x204>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  808c05:	83 ec 04             	sub    $0x4,%esp
  808c08:	68 4a 27 81 00       	push   $0x81274a
  808c0d:	68 25 01 00 00       	push   $0x125
  808c12:	68 36 27 81 00       	push   $0x812736
  808c17:	e8 7d 5a 00 00       	call   80e699 <_panic>
    pbuf_free(p);
  808c1c:	83 ec 0c             	sub    $0xc,%esp
  808c1f:	ff 75 08             	pushl  0x8(%ebp)
  808c22:	e8 63 bc ff ff       	call   80488a <pbuf_free>
  808c27:	83 c4 10             	add    $0x10,%esp
}
  808c2a:	e9 e3 fd ff ff       	jmp    808a12 <udp_input+0x68>
  808c2f:	89 f8                	mov    %edi,%eax
  808c31:	8b 7d dc             	mov    -0x24(%ebp),%edi
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  808c34:	85 c0                	test   %eax,%eax
  808c36:	0f 85 f3 fe ff ff    	jne    808b2f <udp_input+0x185>
  808c3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  808c3f:	8b 57 10             	mov    0x10(%edi),%edx
  808c42:	bb 00 00 00 00       	mov    $0x0,%ebx
  808c47:	39 50 04             	cmp    %edx,0x4(%eax)
  808c4a:	75 d0                	jne    808c1c <udp_input+0x272>
      if (udphdr->chksum != 0) {
  808c4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  808c4f:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  808c54:	74 29                	je     808c7f <udp_input+0x2d5>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  808c56:	83 ec 0c             	sub    $0xc,%esp
  808c59:	8b 45 08             	mov    0x8(%ebp),%eax
  808c5c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  808c60:	50                   	push   %eax
  808c61:	6a 11                	push   $0x11
  808c63:	8d 47 10             	lea    0x10(%edi),%eax
  808c66:	50                   	push   %eax
  808c67:	8d 47 0c             	lea    0xc(%edi),%eax
  808c6a:	50                   	push   %eax
  808c6b:	ff 75 08             	pushl  0x8(%ebp)
  808c6e:	e8 cd e7 ff ff       	call   807440 <inet_chksum_pseudo>
  808c73:	83 c4 20             	add    $0x20,%esp
  808c76:	66 85 c0             	test   %ax,%ax
  808c79:	0f 85 b7 fe ff ff    	jne    808b36 <udp_input+0x18c>
    if(pbuf_header(p, -UDP_HLEN)) {
  808c7f:	83 ec 08             	sub    $0x8,%esp
  808c82:	6a f8                	push   $0xfffffff8
  808c84:	ff 75 08             	pushl  0x8(%ebp)
  808c87:	e8 31 bb ff ff       	call   8047bd <pbuf_header>
  808c8c:	83 c4 10             	add    $0x10,%esp
  808c8f:	84 c0                	test   %al,%al
  808c91:	0f 85 b2 fe ff ff    	jne    808b49 <udp_input+0x19f>
    if (pcb != NULL) {
  808c97:	85 db                	test   %ebx,%ebx
  808c99:	0f 84 d4 fe ff ff    	je     808b73 <udp_input+0x1c9>
      if (pcb->recv != NULL) {
  808c9f:	8b 43 18             	mov    0x18(%ebx),%eax
  808ca2:	85 c0                	test   %eax,%eax
  808ca4:	0f 84 b6 fe ff ff    	je     808b60 <udp_input+0x1b6>
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  808caa:	83 ec 0c             	sub    $0xc,%esp
  808cad:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  808cb1:	52                   	push   %edx
  808cb2:	83 c7 0c             	add    $0xc,%edi
  808cb5:	57                   	push   %edi
  808cb6:	ff 75 08             	pushl  0x8(%ebp)
  808cb9:	53                   	push   %ebx
  808cba:	ff 73 1c             	pushl  0x1c(%ebx)
  808cbd:	ff d0                	call   *%eax
  808cbf:	83 c4 20             	add    $0x20,%esp
  808cc2:	e9 4b fd ff ff       	jmp    808a12 <udp_input+0x68>

00808cc7 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808cc7:	55                   	push   %ebp
  808cc8:	89 e5                	mov    %esp,%ebp
  808cca:	57                   	push   %edi
  808ccb:	56                   	push   %esi
  808ccc:	53                   	push   %ebx
  808ccd:	83 ec 0c             	sub    $0xc,%esp
  808cd0:	8b 55 08             	mov    0x8(%ebp),%edx
  808cd3:	8b 7d 10             	mov    0x10(%ebp),%edi
  808cd6:	89 f9                	mov    %edi,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808cd8:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  rebind = 0;
  808cdd:	bb 00 00 00 00       	mov    $0x0,%ebx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
  808ce2:	be 01 00 00 00       	mov    $0x1,%esi
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808ce7:	eb 1a                	jmp    808d03 <udp_bind+0x3c>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808ce9:	83 ec 04             	sub    $0x4,%esp
  808cec:	68 5e 27 81 00       	push   $0x81275e
  808cf1:	68 41 02 00 00       	push   $0x241
  808cf6:	68 36 27 81 00       	push   $0x812736
  808cfb:	e8 99 59 00 00       	call   80e699 <_panic>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808d00:	8b 40 0c             	mov    0xc(%eax),%eax
  808d03:	85 c0                	test   %eax,%eax
  808d05:	74 0c                	je     808d13 <udp_bind+0x4c>
    if (pcb == ipcb) {
  808d07:	39 d0                	cmp    %edx,%eax
  808d09:	75 f5                	jne    808d00 <udp_bind+0x39>
      LWIP_ASSERT("rebind == 0", rebind == 0);
  808d0b:	84 db                	test   %bl,%bl
  808d0d:	75 da                	jne    808ce9 <udp_bind+0x22>
      rebind = 1;
  808d0f:	89 f3                	mov    %esi,%ebx
  808d11:	eb ed                	jmp    808d00 <udp_bind+0x39>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  808d13:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  808d17:	74 05                	je     808d1e <udp_bind+0x57>
  808d19:	8b 45 0c             	mov    0xc(%ebp),%eax
  808d1c:	8b 00                	mov    (%eax),%eax
  808d1e:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  808d20:	66 85 ff             	test   %di,%di
  808d23:	75 2e                	jne    808d53 <udp_bind+0x8c>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  808d25:	8b 35 54 b2 b3 00    	mov    0xb3b254,%esi
  808d2b:	89 f0                	mov    %esi,%eax
    port = UDP_LOCAL_PORT_RANGE_START;
  808d2d:	b9 00 10 00 00       	mov    $0x1000,%ecx
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808d32:	eb 03                	jmp    808d37 <udp_bind+0x70>
        port++;
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  808d34:	8b 40 0c             	mov    0xc(%eax),%eax
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  808d37:	85 c0                	test   %eax,%eax
  808d39:	74 14                	je     808d4f <udp_bind+0x88>
  808d3b:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  808d40:	74 0d                	je     808d4f <udp_bind+0x88>
      if (ipcb->local_port == port) {
  808d42:	66 39 48 12          	cmp    %cx,0x12(%eax)
  808d46:	75 ec                	jne    808d34 <udp_bind+0x6d>
        port++;
  808d48:	83 c1 01             	add    $0x1,%ecx
        ipcb = udp_pcbs;
  808d4b:	89 f0                	mov    %esi,%eax
  808d4d:	eb e8                	jmp    808d37 <udp_bind+0x70>
    }
    if (ipcb != NULL) {
  808d4f:	85 c0                	test   %eax,%eax
  808d51:	75 28                	jne    808d7b <udp_bind+0xb4>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  808d53:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  808d57:	b8 00 00 00 00       	mov    $0x0,%eax
  if (rebind == 0) {
  808d5c:	84 db                	test   %bl,%bl
  808d5e:	75 13                	jne    808d73 <udp_bind+0xac>
    pcb->next = udp_pcbs;
  808d60:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  808d65:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  808d68:	89 15 54 b2 b3 00    	mov    %edx,0xb3b254
  return ERR_OK;
  808d6e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808d73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808d76:	5b                   	pop    %ebx
  808d77:	5e                   	pop    %esi
  808d78:	5f                   	pop    %edi
  808d79:	5d                   	pop    %ebp
  808d7a:	c3                   	ret    
      return ERR_USE;
  808d7b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  808d80:	eb f1                	jmp    808d73 <udp_bind+0xac>

00808d82 <udp_sendto_if>:
{
  808d82:	55                   	push   %ebp
  808d83:	89 e5                	mov    %esp,%ebp
  808d85:	57                   	push   %edi
  808d86:	56                   	push   %esi
  808d87:	53                   	push   %ebx
  808d88:	83 ec 1c             	sub    $0x1c,%esp
  808d8b:	8b 75 08             	mov    0x8(%ebp),%esi
  808d8e:	8b 45 14             	mov    0x14(%ebp),%eax
  808d91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (pcb->local_port == 0) {
  808d94:	66 83 7e 12 00       	cmpw   $0x0,0x12(%esi)
  808d99:	75 19                	jne    808db4 <udp_sendto_if+0x32>
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808d9b:	83 ec 04             	sub    $0x4,%esp
  808d9e:	6a 00                	push   $0x0
  808da0:	56                   	push   %esi
  808da1:	56                   	push   %esi
  808da2:	e8 20 ff ff ff       	call   808cc7 <udp_bind>
  808da7:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  808da9:	83 c4 10             	add    $0x10,%esp
  808dac:	84 c0                	test   %al,%al
  808dae:	0f 85 b7 00 00 00    	jne    808e6b <udp_sendto_if+0xe9>
  if (pbuf_header(p, UDP_HLEN)) {
  808db4:	83 ec 08             	sub    $0x8,%esp
  808db7:	6a 08                	push   $0x8
  808db9:	ff 75 0c             	pushl  0xc(%ebp)
  808dbc:	e8 fc b9 ff ff       	call   8047bd <pbuf_header>
  808dc1:	83 c4 10             	add    $0x10,%esp
    q = p;
  808dc4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (pbuf_header(p, UDP_HLEN)) {
  808dc7:	84 c0                	test   %al,%al
  808dc9:	0f 85 a6 00 00 00    	jne    808e75 <udp_sendto_if+0xf3>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808dcf:	66 83 7b 0a 07       	cmpw   $0x7,0xa(%ebx)
  808dd4:	0f 86 ca 00 00 00    	jbe    808ea4 <udp_sendto_if+0x122>
  udphdr = q->payload;
  808dda:	8b 7b 04             	mov    0x4(%ebx),%edi
  udphdr->src = htons(pcb->local_port);
  808ddd:	83 ec 0c             	sub    $0xc,%esp
  808de0:	0f b7 46 12          	movzwl 0x12(%esi),%eax
  808de4:	50                   	push   %eax
  808de5:	e8 7a e9 ff ff       	call   807764 <htons>
  808dea:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  808ded:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808df1:	89 04 24             	mov    %eax,(%esp)
  808df4:	e8 6b e9 ff ff       	call   807764 <htons>
  808df9:	66 89 47 02          	mov    %ax,0x2(%edi)
  udphdr->chksum = 0x0000; 
  808dfd:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)
  if (ip_addr_isany(&pcb->local_ip)) {
  808e03:	8b 06                	mov    (%esi),%eax
  808e05:	83 c4 10             	add    $0x10,%esp
  808e08:	85 c0                	test   %eax,%eax
  808e0a:	0f 85 ab 00 00 00    	jne    808ebb <udp_sendto_if+0x139>
    src_ip = &(netif->ip_addr);
  808e10:	8b 45 18             	mov    0x18(%ebp),%eax
  808e13:	83 c0 04             	add    $0x4,%eax
  808e16:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    udphdr->len = htons(q->tot_len);
  808e19:	83 ec 0c             	sub    $0xc,%esp
  808e1c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808e20:	50                   	push   %eax
  808e21:	e8 3e e9 ff ff       	call   807764 <htons>
  808e26:	66 89 47 04          	mov    %ax,0x4(%edi)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  808e2a:	83 c4 10             	add    $0x10,%esp
  808e2d:	f6 46 10 01          	testb  $0x1,0x10(%esi)
  808e31:	0f 84 ac 00 00 00    	je     808ee3 <udp_sendto_if+0x161>
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  808e37:	83 ec 04             	sub    $0x4,%esp
  808e3a:	ff 75 18             	pushl  0x18(%ebp)
  808e3d:	6a 11                	push   $0x11
  808e3f:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  808e43:	50                   	push   %eax
  808e44:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808e48:	50                   	push   %eax
  808e49:	ff 75 10             	pushl  0x10(%ebp)
  808e4c:	ff 75 e4             	pushl  -0x1c(%ebp)
  808e4f:	53                   	push   %ebx
  808e50:	e8 72 da ff ff       	call   8068c7 <ip_output_if>
  808e55:	89 c7                	mov    %eax,%edi
  if (q != p) {
  808e57:	83 c4 20             	add    $0x20,%esp
  808e5a:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808e5d:	74 0c                	je     808e6b <udp_sendto_if+0xe9>
    pbuf_free(q);
  808e5f:	83 ec 0c             	sub    $0xc,%esp
  808e62:	53                   	push   %ebx
  808e63:	e8 22 ba ff ff       	call   80488a <pbuf_free>
  808e68:	83 c4 10             	add    $0x10,%esp
}
  808e6b:	89 f8                	mov    %edi,%eax
  808e6d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808e70:	5b                   	pop    %ebx
  808e71:	5e                   	pop    %esi
  808e72:	5f                   	pop    %edi
  808e73:	5d                   	pop    %ebp
  808e74:	c3                   	ret    
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  808e75:	83 ec 04             	sub    $0x4,%esp
  808e78:	6a 00                	push   $0x0
  808e7a:	6a 08                	push   $0x8
  808e7c:	6a 01                	push   $0x1
  808e7e:	e8 cd ba ff ff       	call   804950 <pbuf_alloc>
  808e83:	89 c3                	mov    %eax,%ebx
    if (q == NULL) {
  808e85:	83 c4 10             	add    $0x10,%esp
  808e88:	85 c0                	test   %eax,%eax
  808e8a:	0f 84 80 00 00 00    	je     808f10 <udp_sendto_if+0x18e>
    pbuf_chain(q, p);
  808e90:	83 ec 08             	sub    $0x8,%esp
  808e93:	ff 75 0c             	pushl  0xc(%ebp)
  808e96:	50                   	push   %eax
  808e97:	e8 cf be ff ff       	call   804d6b <pbuf_chain>
  808e9c:	83 c4 10             	add    $0x10,%esp
  808e9f:	e9 2b ff ff ff       	jmp    808dcf <udp_sendto_if+0x4d>
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  808ea4:	83 ec 04             	sub    $0x4,%esp
  808ea7:	68 6c 27 81 00       	push   $0x81276c
  808eac:	68 b2 01 00 00       	push   $0x1b2
  808eb1:	68 36 27 81 00       	push   $0x812736
  808eb6:	e8 de 57 00 00       	call   80e699 <_panic>
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808ebb:	8b 4d 18             	mov    0x18(%ebp),%ecx
  808ebe:	3b 41 04             	cmp    0x4(%ecx),%eax
  808ec1:	75 08                	jne    808ecb <udp_sendto_if+0x149>
  if (ip_addr_isany(&pcb->local_ip)) {
  808ec3:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  808ec6:	e9 4e ff ff ff       	jmp    808e19 <udp_sendto_if+0x97>
      return ERR_VAL;
  808ecb:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
      if (q != p) {
  808ed0:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  808ed3:	74 96                	je     808e6b <udp_sendto_if+0xe9>
        pbuf_free(q);
  808ed5:	83 ec 0c             	sub    $0xc,%esp
  808ed8:	53                   	push   %ebx
  808ed9:	e8 ac b9 ff ff       	call   80488a <pbuf_free>
  808ede:	83 c4 10             	add    $0x10,%esp
  808ee1:	eb 88                	jmp    808e6b <udp_sendto_if+0xe9>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808ee3:	83 ec 0c             	sub    $0xc,%esp
  808ee6:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808eea:	50                   	push   %eax
  808eeb:	6a 11                	push   $0x11
  808eed:	ff 75 10             	pushl  0x10(%ebp)
  808ef0:	ff 75 e4             	pushl  -0x1c(%ebp)
  808ef3:	53                   	push   %ebx
  808ef4:	e8 47 e5 ff ff       	call   807440 <inet_chksum_pseudo>
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  808ef9:	83 c4 20             	add    $0x20,%esp
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  808efc:	66 85 c0             	test   %ax,%ax
  808eff:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  808f04:	0f 44 c2             	cmove  %edx,%eax
  808f07:	66 89 47 06          	mov    %ax,0x6(%edi)
  808f0b:	e9 27 ff ff ff       	jmp    808e37 <udp_sendto_if+0xb5>
      return ERR_MEM;
  808f10:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  808f15:	e9 51 ff ff ff       	jmp    808e6b <udp_sendto_if+0xe9>

00808f1a <udp_sendto>:
{
  808f1a:	55                   	push   %ebp
  808f1b:	89 e5                	mov    %esp,%ebp
  808f1d:	56                   	push   %esi
  808f1e:	53                   	push   %ebx
  808f1f:	8b 75 10             	mov    0x10(%ebp),%esi
  808f22:	8b 5d 14             	mov    0x14(%ebp),%ebx
  netif = ip_route(dst_ip);
  808f25:	83 ec 0c             	sub    $0xc,%esp
  808f28:	56                   	push   %esi
  808f29:	e8 16 d6 ff ff       	call   806544 <ip_route>
  if (netif == NULL) {
  808f2e:	83 c4 10             	add    $0x10,%esp
  808f31:	85 c0                	test   %eax,%eax
  808f33:	74 1e                	je     808f53 <udp_sendto+0x39>
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  808f35:	83 ec 0c             	sub    $0xc,%esp
  808f38:	50                   	push   %eax
  808f39:	0f b7 db             	movzwl %bx,%ebx
  808f3c:	53                   	push   %ebx
  808f3d:	56                   	push   %esi
  808f3e:	ff 75 0c             	pushl  0xc(%ebp)
  808f41:	ff 75 08             	pushl  0x8(%ebp)
  808f44:	e8 39 fe ff ff       	call   808d82 <udp_sendto_if>
  808f49:	83 c4 20             	add    $0x20,%esp
}
  808f4c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  808f4f:	5b                   	pop    %ebx
  808f50:	5e                   	pop    %esi
  808f51:	5d                   	pop    %ebp
  808f52:	c3                   	ret    
    return ERR_RTE;
  808f53:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  808f58:	eb f2                	jmp    808f4c <udp_sendto+0x32>

00808f5a <udp_send>:
{
  808f5a:	55                   	push   %ebp
  808f5b:	89 e5                	mov    %esp,%ebp
  808f5d:	83 ec 08             	sub    $0x8,%esp
  808f60:	8b 45 08             	mov    0x8(%ebp),%eax
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  808f63:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  808f67:	52                   	push   %edx
  808f68:	8d 50 04             	lea    0x4(%eax),%edx
  808f6b:	52                   	push   %edx
  808f6c:	ff 75 0c             	pushl  0xc(%ebp)
  808f6f:	50                   	push   %eax
  808f70:	e8 a5 ff ff ff       	call   808f1a <udp_sendto>
}
  808f75:	c9                   	leave  
  808f76:	c3                   	ret    

00808f77 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808f77:	55                   	push   %ebp
  808f78:	89 e5                	mov    %esp,%ebp
  808f7a:	57                   	push   %edi
  808f7b:	56                   	push   %esi
  808f7c:	53                   	push   %ebx
  808f7d:	83 ec 0c             	sub    $0xc,%esp
  808f80:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808f83:	8b 75 0c             	mov    0xc(%ebp),%esi
  808f86:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  808f89:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  808f8e:	74 2b                	je     808fbb <udp_connect+0x44>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    if (err != ERR_OK)
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  808f90:	b8 00 00 00 00       	mov    $0x0,%eax
  808f95:	85 f6                	test   %esi,%esi
  808f97:	74 02                	je     808f9b <udp_connect+0x24>
  808f99:	8b 06                	mov    (%esi),%eax
  808f9b:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  808f9e:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  808fa2:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808fa6:	8b 15 54 b2 b3 00    	mov    0xb3b254,%edx
  808fac:	89 d0                	mov    %edx,%eax
  808fae:	85 c0                	test   %eax,%eax
  808fb0:	74 1e                	je     808fd0 <udp_connect+0x59>
    if (pcb == ipcb) {
  808fb2:	39 d8                	cmp    %ebx,%eax
  808fb4:	74 2b                	je     808fe1 <udp_connect+0x6a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  808fb6:	8b 40 0c             	mov    0xc(%eax),%eax
  808fb9:	eb f3                	jmp    808fae <udp_connect+0x37>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  808fbb:	83 ec 04             	sub    $0x4,%esp
  808fbe:	6a 00                	push   $0x0
  808fc0:	53                   	push   %ebx
  808fc1:	53                   	push   %ebx
  808fc2:	e8 00 fd ff ff       	call   808cc7 <udp_bind>
    if (err != ERR_OK)
  808fc7:	83 c4 10             	add    $0x10,%esp
  808fca:	84 c0                	test   %al,%al
  808fcc:	74 c2                	je     808f90 <udp_connect+0x19>
  808fce:	eb 09                	jmp    808fd9 <udp_connect+0x62>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  808fd0:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  808fd3:	89 1d 54 b2 b3 00    	mov    %ebx,0xb3b254
  return ERR_OK;
}
  808fd9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  808fdc:	5b                   	pop    %ebx
  808fdd:	5e                   	pop    %esi
  808fde:	5f                   	pop    %edi
  808fdf:	5d                   	pop    %ebp
  808fe0:	c3                   	ret    
      return ERR_OK;
  808fe1:	b8 00 00 00 00       	mov    $0x0,%eax
  808fe6:	eb f1                	jmp    808fd9 <udp_connect+0x62>

00808fe8 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  808fe8:	55                   	push   %ebp
  808fe9:	89 e5                	mov    %esp,%ebp
  808feb:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  808fee:	8b 15 a8 23 81 00    	mov    0x8123a8,%edx
  808ff4:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  808ff7:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  808ffd:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  809001:	5d                   	pop    %ebp
  809002:	c3                   	ret    

00809003 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  809003:	55                   	push   %ebp
  809004:	89 e5                	mov    %esp,%ebp
  809006:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809009:	8b 55 0c             	mov    0xc(%ebp),%edx
  80900c:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80900f:	8b 55 10             	mov    0x10(%ebp),%edx
  809012:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  809015:	5d                   	pop    %ebp
  809016:	c3                   	ret    

00809017 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  809017:	55                   	push   %ebp
  809018:	89 e5                	mov    %esp,%ebp
  80901a:	83 ec 08             	sub    $0x8,%esp
  80901d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809020:	a1 54 b2 b3 00       	mov    0xb3b254,%eax
  809025:	39 c8                	cmp    %ecx,%eax
  809027:	75 1b                	jne    809044 <udp_remove+0x2d>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809029:	8b 41 0c             	mov    0xc(%ecx),%eax
  80902c:	a3 54 b2 b3 00       	mov    %eax,0xb3b254
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809031:	83 ec 08             	sub    $0x8,%esp
  809034:	51                   	push   %ecx
  809035:	6a 01                	push   $0x1
  809037:	e8 01 b5 ff ff       	call   80453d <memp_free>
}
  80903c:	83 c4 10             	add    $0x10,%esp
  80903f:	c9                   	leave  
  809040:	c3                   	ret    
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  809041:	8b 40 0c             	mov    0xc(%eax),%eax
  809044:	85 c0                	test   %eax,%eax
  809046:	74 e9                	je     809031 <udp_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  809048:	8b 50 0c             	mov    0xc(%eax),%edx
  80904b:	39 ca                	cmp    %ecx,%edx
  80904d:	75 f2                	jne    809041 <udp_remove+0x2a>
  80904f:	85 d2                	test   %edx,%edx
  809051:	74 ee                	je     809041 <udp_remove+0x2a>
        pcb2->next = pcb->next;
  809053:	8b 51 0c             	mov    0xc(%ecx),%edx
  809056:	89 50 0c             	mov    %edx,0xc(%eax)
  809059:	eb e6                	jmp    809041 <udp_remove+0x2a>

0080905b <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80905b:	55                   	push   %ebp
  80905c:	89 e5                	mov    %esp,%ebp
  80905e:	53                   	push   %ebx
  80905f:	83 ec 10             	sub    $0x10,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  809062:	6a 01                	push   $0x1
  809064:	e8 7e b4 ff ff       	call   8044e7 <memp_malloc>
  809069:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80906b:	83 c4 10             	add    $0x10,%esp
  80906e:	85 c0                	test   %eax,%eax
  809070:	74 14                	je     809086 <udp_new+0x2b>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  809072:	83 ec 04             	sub    $0x4,%esp
  809075:	6a 20                	push   $0x20
  809077:	6a 00                	push   $0x0
  809079:	50                   	push   %eax
  80907a:	e8 b5 5f 00 00       	call   80f034 <memset>
    pcb->ttl = UDP_TTL;
  80907f:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  809083:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  809086:	89 d8                	mov    %ebx,%eax
  809088:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80908b:	c9                   	leave  
  80908c:	c3                   	ret    

0080908d <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80908d:	55                   	push   %ebp
  80908e:	89 e5                	mov    %esp,%ebp
  809090:	56                   	push   %esi
  809091:	53                   	push   %ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  809092:	85 c0                	test   %eax,%eax
  809094:	74 35                	je     8090cb <free_etharp_q+0x3e>
  809096:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  809098:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80909c:	74 44                	je     8090e2 <free_etharp_q+0x55>
  while (q) {
    r = q;
    q = q->next;
  80909e:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8090a0:	8b 43 04             	mov    0x4(%ebx),%eax
  8090a3:	85 c0                	test   %eax,%eax
  8090a5:	74 52                	je     8090f9 <free_etharp_q+0x6c>
    pbuf_free(r->p);
  8090a7:	83 ec 0c             	sub    $0xc,%esp
  8090aa:	50                   	push   %eax
  8090ab:	e8 da b7 ff ff       	call   80488a <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  8090b0:	83 c4 08             	add    $0x8,%esp
  8090b3:	53                   	push   %ebx
  8090b4:	6a 0a                	push   $0xa
  8090b6:	e8 82 b4 ff ff       	call   80453d <memp_free>
    q = q->next;
  8090bb:	89 f3                	mov    %esi,%ebx
  while (q) {
  8090bd:	83 c4 10             	add    $0x10,%esp
  8090c0:	85 f6                	test   %esi,%esi
  8090c2:	75 da                	jne    80909e <free_etharp_q+0x11>
  }
}
  8090c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8090c7:	5b                   	pop    %ebx
  8090c8:	5e                   	pop    %esi
  8090c9:	5d                   	pop    %ebp
  8090ca:	c3                   	ret    
  LWIP_ASSERT("q != NULL", q != NULL);
  8090cb:	83 ec 04             	sub    $0x4,%esp
  8090ce:	68 ac 1e 81 00       	push   $0x811eac
  8090d3:	68 93 00 00 00       	push   $0x93
  8090d8:	68 9a 27 81 00       	push   $0x81279a
  8090dd:	e8 b7 55 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8090e2:	83 ec 04             	sub    $0x4,%esp
  8090e5:	68 b2 27 81 00       	push   $0x8127b2
  8090ea:	68 94 00 00 00       	push   $0x94
  8090ef:	68 9a 27 81 00       	push   $0x81279a
  8090f4:	e8 a0 55 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8090f9:	83 ec 04             	sub    $0x4,%esp
  8090fc:	68 bf 27 81 00       	push   $0x8127bf
  809101:	68 98 00 00 00       	push   $0x98
  809106:	68 9a 27 81 00       	push   $0x81279a
  80910b:	e8 89 55 00 00       	call   80e699 <_panic>

00809110 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809110:	55                   	push   %ebp
  809111:	89 e5                	mov    %esp,%ebp
  809113:	57                   	push   %edi
  809114:	56                   	push   %esi
  809115:	53                   	push   %ebx
  809116:	83 ec 1c             	sub    $0x1c,%esp
  809119:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80911c:	85 c0                	test   %eax,%eax
  80911e:	0f 84 e9 00 00 00    	je     80920d <find_entry+0xfd>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809124:	0f b6 15 00 4a b3 00 	movzbl 0xb34a00,%edx
  80912b:	0f b6 ca             	movzbl %dl,%ecx
  80912e:	6b d9 1c             	imul   $0x1c,%ecx,%ebx
  809131:	83 bb 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%ebx)
  809138:	0f 84 9f 00 00 00    	je     8091dd <find_entry+0xcd>
  80913e:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809142:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809146:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80914a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80914e:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809152:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809156:	ba 00 00 00 00       	mov    $0x0,%edx
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80915b:	0f b6 ca             	movzbl %dl,%ecx
  80915e:	6b c9 1c             	imul   $0x1c,%ecx,%ecx
  809161:	83 b9 30 4a b3 00 00 	cmpl   $0x0,0xb34a30(%ecx)
  809168:	0f 85 c1 00 00 00    	jne    80922f <find_entry+0x11f>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  80916e:	89 d1                	mov    %edx,%ecx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809170:	83 c2 01             	add    $0x1,%edx
  809173:	80 fa 09             	cmp    $0x9,%dl
  809176:	0f 86 02 01 00 00    	jbe    80927e <find_entry+0x16e>
  80917c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80917f:	89 c3                	mov    %eax,%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809181:	80 f9 0a             	cmp    $0xa,%cl
  809184:	0f 84 69 01 00 00    	je     8092f3 <find_entry+0x1e3>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  80918a:	f6 c2 02             	test   $0x2,%dl
  80918d:	0f 85 ff 01 00 00    	jne    809392 <find_entry+0x282>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  809193:	89 ce                	mov    %ecx,%esi
  if (empty < ARP_TABLE_SIZE) {
  809195:	80 f9 09             	cmp    $0x9,%cl
  809198:	0f 8f 67 01 00 00    	jg     809305 <find_entry+0x1f5>
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80919e:	89 f0                	mov    %esi,%eax
  8091a0:	3c 09                	cmp    $0x9,%al
  8091a2:	0f 87 c9 01 00 00    	ja     809371 <find_entry+0x261>

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  8091a8:	0f b6 c0             	movzbl %al,%eax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  8091ab:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8091ae:	c7 82 30 4a b3 00 00 	movl   $0x0,0xb34a30(%edx)
  8091b5:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  8091b8:	85 db                	test   %ebx,%ebx
  8091ba:	74 08                	je     8091c4 <find_entry+0xb4>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  8091bc:	8b 0b                	mov    (%ebx),%ecx
  8091be:	89 8a 24 4a b3 00    	mov    %ecx,0xb34a24(%edx)
  }
  arp_table[i].ctime = 0;
  8091c4:	6b c0 1c             	imul   $0x1c,%eax,%eax
  8091c7:	c6 80 34 4a b3 00 00 	movb   $0x0,0xb34a34(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  8091ce:	89 f0                	mov    %esi,%eax
  8091d0:	a2 00 4a b3 00       	mov    %al,0xb34a00
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  8091d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8091d8:	5b                   	pop    %ebx
  8091d9:	5e                   	pop    %esi
  8091da:	5f                   	pop    %edi
  8091db:	5d                   	pop    %ebp
  8091dc:	c3                   	ret    
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8091dd:	8b bb 24 4a b3 00    	mov    0xb34a24(%ebx),%edi
  8091e3:	39 38                	cmp    %edi,(%eax)
  8091e5:	74 22                	je     809209 <find_entry+0xf9>
  8091e7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  8091eb:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  8091ef:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  8091f3:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  8091f7:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  8091fb:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  8091ff:	ba 00 00 00 00       	mov    $0x0,%edx
  809204:	e9 52 ff ff ff       	jmp    80915b <find_entry+0x4b>
        return etharp_cached_entry;
  809209:	89 d0                	mov    %edx,%eax
  80920b:	eb c8                	jmp    8091d5 <find_entry+0xc5>
  80920d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  809211:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  809215:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  809219:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80921d:	c6 45 e2 0a          	movb   $0xa,-0x1e(%ebp)
  809221:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  809225:	ba 00 00 00 00       	mov    $0x0,%edx
  80922a:	e9 2c ff ff ff       	jmp    80915b <find_entry+0x4b>
  80922f:	b9 0a 00 00 00       	mov    $0xa,%ecx
  809234:	eb 48                	jmp    80927e <find_entry+0x16e>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809236:	85 c0                	test   %eax,%eax
  809238:	74 0d                	je     809247 <find_entry+0x137>
  80923a:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80923d:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  809243:	39 38                	cmp    %edi,(%eax)
  809245:	74 79                	je     8092c0 <find_entry+0x1b0>
      } else if (arp_table[i].q != NULL) {
  809247:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80924a:	83 be 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%esi)
  809251:	74 7a                	je     8092cd <find_entry+0x1bd>
        if (arp_table[i].ctime >= age_queue) {
  809253:	0f b6 9e 34 4a b3 00 	movzbl 0xb34a34(%esi),%ebx
  80925a:	89 cf                	mov    %ecx,%edi
  80925c:	3a 5d e7             	cmp    -0x19(%ebp),%bl
  80925f:	72 06                	jb     809267 <find_entry+0x157>
          old_queue = i;
  809261:	88 55 e3             	mov    %dl,-0x1d(%ebp)
          age_queue = arp_table[i].ctime;
  809264:	88 5d e7             	mov    %bl,-0x19(%ebp)
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809267:	83 c2 01             	add    $0x1,%edx
  80926a:	80 fa 09             	cmp    $0x9,%dl
  80926d:	0f 87 09 ff ff ff    	ja     80917c <find_entry+0x6c>
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  809273:	80 f9 0a             	cmp    $0xa,%cl
  809276:	0f 84 df fe ff ff    	je     80915b <find_entry+0x4b>
  80927c:	89 f9                	mov    %edi,%ecx
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80927e:	0f b6 da             	movzbl %dl,%ebx
  809281:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  809284:	8b b6 30 4a b3 00    	mov    0xb34a30(%esi),%esi
  80928a:	83 fe 01             	cmp    $0x1,%esi
  80928d:	74 a7                	je     809236 <find_entry+0x126>
  80928f:	89 cf                	mov    %ecx,%edi
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809291:	83 fe 02             	cmp    $0x2,%esi
  809294:	75 d1                	jne    809267 <find_entry+0x157>
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809296:	85 c0                	test   %eax,%eax
  809298:	74 0d                	je     8092a7 <find_entry+0x197>
  80929a:	6b f3 1c             	imul   $0x1c,%ebx,%esi
  80929d:	8b be 24 4a b3 00    	mov    0xb34a24(%esi),%edi
  8092a3:	39 38                	cmp    %edi,(%eax)
  8092a5:	74 3f                	je     8092e6 <find_entry+0x1d6>
      } else if (arp_table[i].ctime >= age_stable) {
  8092a7:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  8092aa:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  8092b1:	89 cf                	mov    %ecx,%edi
  8092b3:	3a 5d e6             	cmp    -0x1a(%ebp),%bl
  8092b6:	72 af                	jb     809267 <find_entry+0x157>
        old_stable = i;
  8092b8:	88 55 e5             	mov    %dl,-0x1b(%ebp)
        age_stable = arp_table[i].ctime;
  8092bb:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  8092be:	eb a7                	jmp    809267 <find_entry+0x157>
        etharp_cached_entry = i;
  8092c0:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  8092c6:	89 d0                	mov    %edx,%eax
  8092c8:	e9 08 ff ff ff       	jmp    8091d5 <find_entry+0xc5>
        if (arp_table[i].ctime >= age_pending) {
  8092cd:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  8092d0:	0f b6 9b 34 4a b3 00 	movzbl 0xb34a34(%ebx),%ebx
  8092d7:	89 cf                	mov    %ecx,%edi
  8092d9:	3a 5d e4             	cmp    -0x1c(%ebp),%bl
  8092dc:	72 89                	jb     809267 <find_entry+0x157>
          old_pending = i;
  8092de:	88 55 e2             	mov    %dl,-0x1e(%ebp)
          age_pending = arp_table[i].ctime;
  8092e1:	88 5d e4             	mov    %bl,-0x1c(%ebp)
  8092e4:	eb 81                	jmp    809267 <find_entry+0x157>
        etharp_cached_entry = i;
  8092e6:	88 15 00 4a b3 00    	mov    %dl,0xb34a00
        return i;
  8092ec:	89 d0                	mov    %edx,%eax
  8092ee:	e9 e2 fe ff ff       	jmp    8091d5 <find_entry+0xc5>
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  8092f3:	f6 c2 01             	test   $0x1,%dl
  8092f6:	0f 84 8c 00 00 00    	je     809388 <find_entry+0x278>
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  8092fc:	f6 c2 02             	test   $0x2,%dl
  8092ff:	0f 85 a1 00 00 00    	jne    8093a6 <find_entry+0x296>
  else if (old_stable < ARP_TABLE_SIZE) {
  809305:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  809309:	3c 09                	cmp    $0x9,%al
  80930b:	7f 2c                	jg     809339 <find_entry+0x229>
    i = old_stable;
  80930d:	89 c6                	mov    %eax,%esi
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80930f:	0f b6 c0             	movzbl %al,%eax
  809312:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809315:	83 b8 20 4a b3 00 00 	cmpl   $0x0,0xb34a20(%eax)
  80931c:	0f 84 7c fe ff ff    	je     80919e <find_entry+0x8e>
  809322:	83 ec 04             	sub    $0x4,%esp
  809325:	68 cc 27 81 00       	push   $0x8127cc
  80932a:	68 75 01 00 00       	push   $0x175
  80932f:	68 9a 27 81 00       	push   $0x81279a
  809334:	e8 60 53 00 00       	call   80e699 <_panic>
  } else if (old_pending < ARP_TABLE_SIZE) {
  809339:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
    i = old_pending;
  80933d:	89 c6                	mov    %eax,%esi
  } else if (old_pending < ARP_TABLE_SIZE) {
  80933f:	3c 09                	cmp    $0x9,%al
  809341:	0f 8e 57 fe ff ff    	jle    80919e <find_entry+0x8e>
  } else if (old_queue < ARP_TABLE_SIZE) {
  809347:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
  80934b:	3c 09                	cmp    $0x9,%al
  80934d:	7f 4d                	jg     80939c <find_entry+0x28c>
    i = old_queue;
  80934f:	89 c6                	mov    %eax,%esi
    free_etharp_q(arp_table[i].q);
  809351:	0f b6 f8             	movzbl %al,%edi
  809354:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809357:	8b 87 20 4a b3 00    	mov    0xb34a20(%edi),%eax
  80935d:	e8 2b fd ff ff       	call   80908d <free_etharp_q>
    arp_table[i].q = NULL;
  809362:	c7 87 20 4a b3 00 00 	movl   $0x0,0xb34a20(%edi)
  809369:	00 00 00 
  80936c:	e9 2d fe ff ff       	jmp    80919e <find_entry+0x8e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809371:	83 ec 04             	sub    $0x4,%esp
  809374:	68 e3 27 81 00       	push   $0x8127e3
  809379:	68 8b 01 00 00       	push   $0x18b
  80937e:	68 9a 27 81 00       	push   $0x81279a
  809383:	e8 11 53 00 00       	call   80e699 <_panic>
    return (s8_t)ERR_MEM;
  809388:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80938d:	e9 43 fe ff ff       	jmp    8091d5 <find_entry+0xc5>
  809392:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809397:	e9 39 fe ff ff       	jmp    8091d5 <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  80939c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093a1:	e9 2f fe ff ff       	jmp    8091d5 <find_entry+0xc5>
    return (s8_t)ERR_MEM;
  8093a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8093ab:	e9 25 fe ff ff       	jmp    8091d5 <find_entry+0xc5>

008093b0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  8093b0:	55                   	push   %ebp
  8093b1:	89 e5                	mov    %esp,%ebp
  8093b3:	57                   	push   %edi
  8093b4:	56                   	push   %esi
  8093b5:	53                   	push   %ebx
  8093b6:	83 ec 1c             	sub    $0x1c,%esp
  8093b9:	89 d7                	mov    %edx,%edi
  8093bb:	8b 55 08             	mov    0x8(%ebp),%edx
  struct eth_hdr *ethhdr = p->payload;
  8093be:	8b 5f 04             	mov    0x4(%edi),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8093c1:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8093c5:	75 45                	jne    80940c <etharp_send_ip+0x5c>
  8093c7:	89 c6                	mov    %eax,%esi
  8093c9:	b8 05 00 00 00       	mov    $0x5,%eax
  8093ce:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
  8093d1:	0f b6 0c 02          	movzbl (%edx,%eax,1),%ecx
  8093d5:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  8093d8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8093db:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  8093df:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  8093e3:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  8093e6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8093e9:	75 e6                	jne    8093d1 <etharp_send_ip+0x21>
  }
  ethhdr->type = htons(ETHTYPE_IP);
  8093eb:	83 ec 0c             	sub    $0xc,%esp
  8093ee:	68 00 08 00 00       	push   $0x800
  8093f3:	e8 6c e3 ff ff       	call   807764 <htons>
  8093f8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  8093fc:	83 c4 08             	add    $0x8,%esp
  8093ff:	57                   	push   %edi
  809400:	56                   	push   %esi
  809401:	ff 56 18             	call   *0x18(%esi)
}
  809404:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809407:	5b                   	pop    %ebx
  809408:	5e                   	pop    %esi
  809409:	5f                   	pop    %edi
  80940a:	5d                   	pop    %ebp
  80940b:	c3                   	ret    
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80940c:	83 ec 04             	sub    $0x4,%esp
  80940f:	68 10 28 81 00       	push   $0x812810
  809414:	68 b3 01 00 00       	push   $0x1b3
  809419:	68 9a 27 81 00       	push   $0x81279a
  80941e:	e8 76 52 00 00       	call   80e699 <_panic>

00809423 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809423:	55                   	push   %ebp
  809424:	89 e5                	mov    %esp,%ebp
  809426:	57                   	push   %edi
  809427:	56                   	push   %esi
  809428:	53                   	push   %ebx
  809429:	83 ec 1c             	sub    $0x1c,%esp
  80942c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80942f:	89 cb                	mov    %ecx,%ebx
  809431:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809434:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809437:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80943b:	0f 85 e9 00 00 00    	jne    80952a <update_arp_entry+0x107>
  809441:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809443:	85 d2                	test   %edx,%edx
  809445:	0f 84 f6 00 00 00    	je     809541 <update_arp_entry+0x11e>
  80944b:	83 3a 00             	cmpl   $0x0,(%edx)
  80944e:	0f 84 f4 00 00 00    	je     809548 <update_arp_entry+0x125>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809454:	83 ec 08             	sub    $0x8,%esp
  809457:	ff 75 e4             	pushl  -0x1c(%ebp)
  80945a:	52                   	push   %edx
  80945b:	e8 a1 d0 ff ff       	call   806501 <ip_addr_isbroadcast>
  if (ip_addr_isany(ipaddr) ||
  809460:	83 c4 10             	add    $0x10,%esp
  809463:	84 c0                	test   %al,%al
  809465:	0f 85 ea 00 00 00    	jne    809555 <update_arp_entry+0x132>
      ip_addr_ismulticast(ipaddr)) {
  80946b:	8b 3e                	mov    (%esi),%edi
  80946d:	83 ec 0c             	sub    $0xc,%esp
  809470:	68 00 00 00 f0       	push   $0xf0000000
  809475:	e8 1b e5 ff ff       	call   807995 <ntohl>
  80947a:	21 c7                	and    %eax,%edi
  80947c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809483:	e8 0d e5 ff ff       	call   807995 <ntohl>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809488:	83 c4 10             	add    $0x10,%esp
  80948b:	39 c7                	cmp    %eax,%edi
  80948d:	0f 84 c9 00 00 00    	je     80955c <update_arp_entry+0x139>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809493:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809497:	89 f0                	mov    %esi,%eax
  809499:	e8 72 fc ff ff       	call   809110 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80949e:	84 c0                	test   %al,%al
  8094a0:	0f 88 a7 00 00 00    	js     80954d <update_arp_entry+0x12a>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  8094a6:	0f be c0             	movsbl %al,%eax
  8094a9:	6b f0 1c             	imul   $0x1c,%eax,%esi
  8094ac:	c7 86 30 4a b3 00 02 	movl   $0x2,0xb34a30(%esi)
  8094b3:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  8094b6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8094b9:	89 8e 38 4a b3 00    	mov    %ecx,0xb34a38(%esi)
  8094bf:	ba 00 00 00 00       	mov    $0x0,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8094c4:	0f b6 4c 13 05       	movzbl 0x5(%ebx,%edx,1),%ecx
  8094c9:	88 8c 16 2d 4a b3 00 	mov    %cl,0xb34a2d(%esi,%edx,1)
  8094d0:	83 ea 01             	sub    $0x1,%edx
  while (k > 0) {
  8094d3:	83 fa fa             	cmp    $0xfffffffa,%edx
  8094d6:	75 ec                	jne    8094c4 <update_arp_entry+0xa1>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  8094d8:	6b d0 1c             	imul   $0x1c,%eax,%edx
  8094db:	c6 82 34 4a b3 00 00 	movb   $0x0,0xb34a34(%edx)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  8094e2:	89 d6                	mov    %edx,%esi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8094e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8094e7:	83 c0 25             	add    $0x25,%eax
  8094ea:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
  8094ed:	8b 86 20 4a b3 00    	mov    0xb34a20(%esi),%eax
  8094f3:	85 c0                	test   %eax,%eax
  8094f5:	74 56                	je     80954d <update_arp_entry+0x12a>
    arp_table[i].q = q->next;
  8094f7:	8b 10                	mov    (%eax),%edx
  8094f9:	89 96 20 4a b3 00    	mov    %edx,0xb34a20(%esi)
    p = q->p;
  8094ff:	8b 78 04             	mov    0x4(%eax),%edi
    memp_free(MEMP_ARP_QUEUE, q);
  809502:	83 ec 08             	sub    $0x8,%esp
  809505:	50                   	push   %eax
  809506:	6a 0a                	push   $0xa
  809508:	e8 30 b0 ff ff       	call   80453d <memp_free>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80950d:	89 1c 24             	mov    %ebx,(%esp)
  809510:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809513:	89 fa                	mov    %edi,%edx
  809515:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809518:	e8 93 fe ff ff       	call   8093b0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80951d:	89 3c 24             	mov    %edi,(%esp)
  809520:	e8 65 b3 ff ff       	call   80488a <pbuf_free>
  809525:	83 c4 10             	add    $0x10,%esp
  809528:	eb c3                	jmp    8094ed <update_arp_entry+0xca>
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80952a:	83 ec 04             	sub    $0x4,%esp
  80952d:	68 54 28 81 00       	push   $0x812854
  809532:	68 d9 01 00 00       	push   $0x1d9
  809537:	68 9a 27 81 00       	push   $0x81279a
  80953c:	e8 58 51 00 00       	call   80e699 <_panic>
    return ERR_ARG;
  809541:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809546:	eb 05                	jmp    80954d <update_arp_entry+0x12a>
  809548:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  }
#endif
  return ERR_OK;
}
  80954d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809550:	5b                   	pop    %ebx
  809551:	5e                   	pop    %esi
  809552:	5f                   	pop    %edi
  809553:	5d                   	pop    %ebp
  809554:	c3                   	ret    
    return ERR_ARG;
  809555:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80955a:	eb f1                	jmp    80954d <update_arp_entry+0x12a>
  80955c:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809561:	eb ea                	jmp    80954d <update_arp_entry+0x12a>

00809563 <etharp_tmr>:
{
  809563:	55                   	push   %ebp
  809564:	89 e5                	mov    %esp,%ebp
  809566:	57                   	push   %edi
  809567:	56                   	push   %esi
  809568:	53                   	push   %ebx
  809569:	83 ec 0c             	sub    $0xc,%esp
  80956c:	bb 20 4a b3 00       	mov    $0xb34a20,%ebx
  809571:	bf 38 4b b3 00       	mov    $0xb34b38,%edi
  809576:	eb 1f                	jmp    809597 <etharp_tmr+0x34>
      if (arp_table[i].q != NULL) {
  809578:	8b 06                	mov    (%esi),%eax
  80957a:	85 c0                	test   %eax,%eax
  80957c:	74 0b                	je     809589 <etharp_tmr+0x26>
        free_etharp_q(arp_table[i].q);
  80957e:	e8 0a fb ff ff       	call   80908d <free_etharp_q>
        arp_table[i].q = NULL;
  809583:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809589:	c7 46 10 00 00 00 00 	movl   $0x0,0x10(%esi)
  809590:	83 c3 1c             	add    $0x1c,%ebx
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809593:	39 fb                	cmp    %edi,%ebx
  809595:	74 23                	je     8095ba <etharp_tmr+0x57>
  809597:	89 de                	mov    %ebx,%esi
    arp_table[i].ctime++;
  809599:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80959d:	83 c0 01             	add    $0x1,%eax
  8095a0:	88 43 14             	mov    %al,0x14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8095a3:	8b 53 10             	mov    0x10(%ebx),%edx
  8095a6:	3c ef                	cmp    $0xef,%al
  8095a8:	76 05                	jbe    8095af <etharp_tmr+0x4c>
  8095aa:	83 fa 02             	cmp    $0x2,%edx
  8095ad:	74 c9                	je     809578 <etharp_tmr+0x15>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8095af:	3c 01                	cmp    $0x1,%al
  8095b1:	76 dd                	jbe    809590 <etharp_tmr+0x2d>
  8095b3:	83 fa 01             	cmp    $0x1,%edx
  8095b6:	75 d8                	jne    809590 <etharp_tmr+0x2d>
  8095b8:	eb be                	jmp    809578 <etharp_tmr+0x15>
}
  8095ba:	83 c4 0c             	add    $0xc,%esp
  8095bd:	5b                   	pop    %ebx
  8095be:	5e                   	pop    %esi
  8095bf:	5f                   	pop    %edi
  8095c0:	5d                   	pop    %ebp
  8095c1:	c3                   	ret    

008095c2 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  8095c2:	55                   	push   %ebp
  8095c3:	89 e5                	mov    %esp,%ebp
  8095c5:	53                   	push   %ebx
  8095c6:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  8095c9:	ba 02 00 00 00       	mov    $0x2,%edx
  8095ce:	8b 45 0c             	mov    0xc(%ebp),%eax
  8095d1:	e8 3a fb ff ff       	call   809110 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  8095d6:	84 c0                	test   %al,%al
  8095d8:	78 31                	js     80960b <etharp_find_addr+0x49>
  8095da:	0f be d0             	movsbl %al,%edx
  8095dd:	6b d2 1c             	imul   $0x1c,%edx,%edx
  8095e0:	83 ba 30 4a b3 00 02 	cmpl   $0x2,0xb34a30(%edx)
  8095e7:	75 29                	jne    809612 <etharp_find_addr+0x50>
  8095e9:	0f be d0             	movsbl %al,%edx
  8095ec:	6b d2 1c             	imul   $0x1c,%edx,%edx
      *eth_ret = &arp_table[i].ethaddr;
  8095ef:	8d 9a 28 4a b3 00    	lea    0xb34a28(%edx),%ebx
  8095f5:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8095f8:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  8095fa:	81 c2 24 4a b3 00    	add    $0xb34a24,%edx
  809600:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809603:	89 11                	mov    %edx,(%ecx)
      return i;
  }
  return -1;
}
  809605:	83 c4 04             	add    $0x4,%esp
  809608:	5b                   	pop    %ebx
  809609:	5d                   	pop    %ebp
  80960a:	c3                   	ret    
  return -1;
  80960b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809610:	eb f3                	jmp    809605 <etharp_find_addr+0x43>
  809612:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809617:	eb ec                	jmp    809605 <etharp_find_addr+0x43>

00809619 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809619:	55                   	push   %ebp
  80961a:	89 e5                	mov    %esp,%ebp
  80961c:	83 ec 08             	sub    $0x8,%esp
  80961f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809622:	85 c0                	test   %eax,%eax
  809624:	74 13                	je     809639 <etharp_ip_input+0x20>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809626:	8b 55 0c             	mov    0xc(%ebp),%edx
  809629:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80962c:	8b 4a 1c             	mov    0x1c(%edx),%ecx
  80962f:	33 48 04             	xor    0x4(%eax),%ecx
  809632:	85 48 08             	test   %ecx,0x8(%eax)
  809635:	74 19                	je     809650 <etharp_ip_input+0x37>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  809637:	c9                   	leave  
  809638:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809639:	83 ec 04             	sub    $0x4,%esp
  80963c:	68 22 1b 81 00       	push   $0x811b22
  809641:	68 48 02 00 00       	push   $0x248
  809646:	68 9a 27 81 00       	push   $0x81279a
  80964b:	e8 49 50 00 00       	call   80e699 <_panic>
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809650:	8d 4a 06             	lea    0x6(%edx),%ecx
  809653:	83 c2 1c             	add    $0x1c,%edx
  809656:	83 ec 0c             	sub    $0xc,%esp
  809659:	6a 00                	push   $0x0
  80965b:	e8 c3 fd ff ff       	call   809423 <update_arp_entry>
  809660:	83 c4 10             	add    $0x10,%esp
  809663:	eb d2                	jmp    809637 <etharp_ip_input+0x1e>

00809665 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809665:	55                   	push   %ebp
  809666:	89 e5                	mov    %esp,%ebp
  809668:	57                   	push   %edi
  809669:	56                   	push   %esi
  80966a:	53                   	push   %ebx
  80966b:	83 ec 1c             	sub    $0x1c,%esp
  80966e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809671:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809675:	74 4d                	je     8096c4 <etharp_arp_input+0x5f>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809677:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80967c:	76 5d                	jbe    8096db <etharp_arp_input+0x76>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  hdr = p->payload;
  80967e:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809681:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809685:	83 ec 0c             	sub    $0xc,%esp
  809688:	6a 01                	push   $0x1
  80968a:	e8 d5 e0 ff ff       	call   807764 <htons>
  80968f:	83 c4 10             	add    $0x10,%esp
  809692:	66 39 c7             	cmp    %ax,%di
  809695:	75 19                	jne    8096b0 <etharp_arp_input+0x4b>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809697:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80969b:	83 ec 0c             	sub    $0xc,%esp
  80969e:	68 04 06 00 00       	push   $0x604
  8096a3:	e8 bc e0 ff ff       	call   807764 <htons>
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  8096a8:	83 c4 10             	add    $0x10,%esp
  8096ab:	66 39 c7             	cmp    %ax,%di
  8096ae:	74 39                	je     8096e9 <etharp_arp_input+0x84>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8096b0:	83 ec 0c             	sub    $0xc,%esp
  8096b3:	53                   	push   %ebx
  8096b4:	e8 d1 b1 ff ff       	call   80488a <pbuf_free>
    return;
  8096b9:	83 c4 10             	add    $0x10,%esp
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  8096bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  8096bf:	5b                   	pop    %ebx
  8096c0:	5e                   	pop    %esi
  8096c1:	5f                   	pop    %edi
  8096c2:	5d                   	pop    %ebp
  8096c3:	c3                   	ret    
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8096c4:	83 ec 04             	sub    $0x4,%esp
  8096c7:	68 22 1b 81 00       	push   $0x811b22
  8096cc:	68 75 02 00 00       	push   $0x275
  8096d1:	68 9a 27 81 00       	push   $0x81279a
  8096d6:	e8 be 4f 00 00       	call   80e699 <_panic>
    pbuf_free(p);
  8096db:	83 ec 0c             	sub    $0xc,%esp
  8096de:	53                   	push   %ebx
  8096df:	e8 a6 b1 ff ff       	call   80488a <pbuf_free>
    return;
  8096e4:	83 c4 10             	add    $0x10,%esp
  8096e7:	eb d3                	jmp    8096bc <etharp_arp_input+0x57>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  8096e9:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  8096ed:	83 ec 0c             	sub    $0xc,%esp
  8096f0:	68 00 08 00 00       	push   $0x800
  8096f5:	e8 6a e0 ff ff       	call   807764 <htons>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  8096fa:	83 c4 10             	add    $0x10,%esp
  8096fd:	66 39 c7             	cmp    %ax,%di
  809700:	75 ae                	jne    8096b0 <etharp_arp_input+0x4b>
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809702:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809706:	83 ec 0c             	sub    $0xc,%esp
  809709:	68 06 08 00 00       	push   $0x806
  80970e:	e8 51 e0 ff ff       	call   807764 <htons>
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809713:	83 c4 10             	add    $0x10,%esp
  809716:	66 39 c7             	cmp    %ax,%di
  809719:	75 95                	jne    8096b0 <etharp_arp_input+0x4b>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80971b:	83 ec 04             	sub    $0x4,%esp
  80971e:	6a 04                	push   $0x4
  809720:	8d 46 1c             	lea    0x1c(%esi),%eax
  809723:	50                   	push   %eax
  809724:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809727:	50                   	push   %eax
  809728:	e8 b1 59 00 00       	call   80f0de <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80972d:	83 c4 0c             	add    $0xc,%esp
  809730:	6a 04                	push   $0x4
  809732:	8d 46 26             	lea    0x26(%esi),%eax
  809735:	50                   	push   %eax
  809736:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809739:	50                   	push   %eax
  80973a:	e8 9f 59 00 00       	call   80f0de <memcpy>
  if (netif->ip_addr.addr == 0) {
  80973f:	8b 45 08             	mov    0x8(%ebp),%eax
  809742:	8b 40 04             	mov    0x4(%eax),%eax
  809745:	83 c4 10             	add    $0x10,%esp
  809748:	85 c0                	test   %eax,%eax
  80974a:	74 05                	je     809751 <etharp_arp_input+0xec>
  if (for_us) {
  80974c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80974f:	74 39                	je     80978a <etharp_arp_input+0x125>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809751:	8d 4e 16             	lea    0x16(%esi),%ecx
  809754:	83 ec 0c             	sub    $0xc,%esp
  809757:	6a 00                	push   $0x0
  809759:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80975c:	8b 45 08             	mov    0x8(%ebp),%eax
  80975f:	e8 bf fc ff ff       	call   809423 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  809764:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809768:	89 04 24             	mov    %eax,(%esp)
  80976b:	e8 f4 df ff ff       	call   807764 <htons>
  809770:	83 c4 10             	add    $0x10,%esp
  809773:	66 83 f8 02          	cmp    $0x2,%ax
  809777:	74 3f                	je     8097b8 <etharp_arp_input+0x153>
  pbuf_free(p);
  809779:	83 ec 0c             	sub    $0xc,%esp
  80977c:	53                   	push   %ebx
  80977d:	e8 08 b1 ff ff       	call   80488a <pbuf_free>
  809782:	83 c4 10             	add    $0x10,%esp
  809785:	e9 32 ff ff ff       	jmp    8096bc <etharp_arp_input+0x57>
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80978a:	8d 4e 16             	lea    0x16(%esi),%ecx
  80978d:	83 ec 0c             	sub    $0xc,%esp
  809790:	6a 01                	push   $0x1
  809792:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809795:	8b 45 08             	mov    0x8(%ebp),%eax
  809798:	e8 86 fc ff ff       	call   809423 <update_arp_entry>
  switch (htons(hdr->opcode)) {
  80979d:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  8097a1:	89 04 24             	mov    %eax,(%esp)
  8097a4:	e8 bb df ff ff       	call   807764 <htons>
  8097a9:	83 c4 10             	add    $0x10,%esp
  8097ac:	66 83 f8 01          	cmp    $0x1,%ax
  8097b0:	74 1a                	je     8097cc <etharp_arp_input+0x167>
  8097b2:	66 83 f8 02          	cmp    $0x2,%ax
  8097b6:	75 c1                	jne    809779 <etharp_arp_input+0x114>
    dhcp_arp_reply(netif, &sipaddr);
  8097b8:	83 ec 08             	sub    $0x8,%esp
  8097bb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8097be:	50                   	push   %eax
  8097bf:	ff 75 08             	pushl  0x8(%ebp)
  8097c2:	e8 70 a1 ff ff       	call   803937 <dhcp_arp_reply>
    break;
  8097c7:	83 c4 10             	add    $0x10,%esp
  8097ca:	eb ad                	jmp    809779 <etharp_arp_input+0x114>
      hdr->opcode = htons(ARP_REPLY);
  8097cc:	83 ec 0c             	sub    $0xc,%esp
  8097cf:	6a 02                	push   $0x2
  8097d1:	e8 8e df ff ff       	call   807764 <htons>
  8097d6:	66 89 46 14          	mov    %ax,0x14(%esi)
      hdr->dipaddr = hdr->sipaddr;
  8097da:	8b 46 1c             	mov    0x1c(%esi),%eax
  8097dd:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8097e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8097e3:	8b 40 04             	mov    0x4(%eax),%eax
  8097e6:	89 46 1c             	mov    %eax,0x1c(%esi)
      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8097e9:	83 c4 10             	add    $0x10,%esp
  8097ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8097ef:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  8097f3:	75 0b                	jne    809800 <etharp_arp_input+0x19b>
  8097f5:	8d 46 05             	lea    0x5(%esi),%eax
  8097f8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8097fb:	83 c2 05             	add    $0x5,%edx
  8097fe:	eb 19                	jmp    809819 <etharp_arp_input+0x1b4>
  809800:	83 ec 04             	sub    $0x4,%esp
  809803:	68 10 28 81 00       	push   $0x812810
  809808:	68 c7 02 00 00       	push   $0x2c7
  80980d:	68 9a 27 81 00       	push   $0x81279a
  809812:	e8 82 4e 00 00       	call   80e699 <_panic>
  809817:	89 c8                	mov    %ecx,%eax
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809819:	0f b6 48 16          	movzbl 0x16(%eax),%ecx
  80981d:	88 48 20             	mov    %cl,0x20(%eax)
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809820:	88 08                	mov    %cl,(%eax)
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809822:	0f b6 0a             	movzbl (%edx),%ecx
  809825:	88 48 16             	mov    %cl,0x16(%eax)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809828:	88 48 06             	mov    %cl,0x6(%eax)
  80982b:	8d 48 ff             	lea    -0x1(%eax),%ecx
  80982e:	83 ea 01             	sub    $0x1,%edx
      while(i > 0) {
  809831:	39 f0                	cmp    %esi,%eax
  809833:	75 e2                	jne    809817 <etharp_arp_input+0x1b2>
      netif->linkoutput(netif, p);
  809835:	83 ec 08             	sub    $0x8,%esp
  809838:	53                   	push   %ebx
  809839:	ff 75 08             	pushl  0x8(%ebp)
  80983c:	8b 45 08             	mov    0x8(%ebp),%eax
  80983f:	ff 50 18             	call   *0x18(%eax)
  809842:	83 c4 10             	add    $0x10,%esp
  809845:	e9 2f ff ff ff       	jmp    809779 <etharp_arp_input+0x114>

0080984a <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80984a:	55                   	push   %ebp
  80984b:	89 e5                	mov    %esp,%ebp
  80984d:	57                   	push   %edi
  80984e:	56                   	push   %esi
  80984f:	53                   	push   %ebx
  809850:	83 ec 10             	sub    $0x10,%esp
  809853:	8b 75 08             	mov    0x8(%ebp),%esi
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  809856:	6a 00                	push   $0x0
  809858:	6a 2a                	push   $0x2a
  80985a:	6a 02                	push   $0x2
  80985c:	e8 ef b0 ff ff       	call   804950 <pbuf_alloc>
  if (p == NULL) {
  809861:	83 c4 10             	add    $0x10,%esp
  809864:	85 c0                	test   %eax,%eax
  809866:	0f 84 f8 00 00 00    	je     809964 <etharp_request+0x11a>
  80986c:	89 c7                	mov    %eax,%edi
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80986e:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  809873:	0f 86 bd 00 00 00    	jbe    809936 <etharp_request+0xec>
  hdr = p->payload;
  809879:	8b 58 04             	mov    0x4(%eax),%ebx
  hdr->opcode = htons(opcode);
  80987c:	83 ec 0c             	sub    $0xc,%esp
  80987f:	6a 01                	push   $0x1
  809881:	e8 de de ff ff       	call   807764 <htons>
  809886:	66 89 43 14          	mov    %ax,0x14(%ebx)
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80988a:	83 c4 10             	add    $0x10,%esp
  80988d:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809891:	0f 85 b6 00 00 00    	jne    80994d <etharp_request+0x103>
  809897:	b8 05 00 00 00       	mov    $0x5,%eax
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80989c:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8098a1:	88 54 03 16          	mov    %dl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  8098a5:	0f b6 90 fc 28 81 00 	movzbl 0x8128fc(%eax),%edx
  8098ac:	88 54 03 20          	mov    %dl,0x20(%ebx,%eax,1)
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  8098b0:	0f b6 90 04 29 81 00 	movzbl 0x812904(%eax),%edx
  8098b7:	88 14 03             	mov    %dl,(%ebx,%eax,1)
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  8098ba:	0f b6 54 06 25       	movzbl 0x25(%esi,%eax,1),%edx
  8098bf:	88 54 03 06          	mov    %dl,0x6(%ebx,%eax,1)
  8098c3:	83 e8 01             	sub    $0x1,%eax
  while(k > 0) {
  8098c6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8098c9:	75 d1                	jne    80989c <etharp_request+0x52>
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  8098cb:	8b 46 04             	mov    0x4(%esi),%eax
  8098ce:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  8098d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8098d4:	8b 00                	mov    (%eax),%eax
  8098d6:	89 43 26             	mov    %eax,0x26(%ebx)
  hdr->hwtype = htons(HWTYPE_ETHERNET);
  8098d9:	83 ec 0c             	sub    $0xc,%esp
  8098dc:	6a 01                	push   $0x1
  8098de:	e8 81 de ff ff       	call   807764 <htons>
  8098e3:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  8098e7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  8098ee:	e8 71 de ff ff       	call   807764 <htons>
  8098f3:	66 89 43 10          	mov    %ax,0x10(%ebx)
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  8098f7:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  8098fe:	e8 61 de ff ff       	call   807764 <htons>
  809903:	66 89 43 12          	mov    %ax,0x12(%ebx)
  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  809907:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80990e:	e8 51 de ff ff       	call   807764 <htons>
  809913:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  result = netif->linkoutput(netif, p);
  809917:	83 c4 08             	add    $0x8,%esp
  80991a:	57                   	push   %edi
  80991b:	56                   	push   %esi
  80991c:	ff 56 18             	call   *0x18(%esi)
  80991f:	89 c3                	mov    %eax,%ebx
  pbuf_free(p);
  809921:	89 3c 24             	mov    %edi,(%esp)
  809924:	e8 61 af ff ff       	call   80488a <pbuf_free>
  809929:	83 c4 10             	add    $0x10,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80992c:	89 d8                	mov    %ebx,%eax
  80992e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809931:	5b                   	pop    %ebx
  809932:	5e                   	pop    %esi
  809933:	5f                   	pop    %edi
  809934:	5d                   	pop    %ebp
  809935:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  809936:	83 ec 04             	sub    $0x4,%esp
  809939:	68 7c 28 81 00       	push   $0x81287c
  80993e:	68 1c 04 00 00       	push   $0x41c
  809943:	68 9a 27 81 00       	push   $0x81279a
  809948:	e8 4c 4d 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80994d:	83 ec 04             	sub    $0x4,%esp
  809950:	68 10 28 81 00       	push   $0x812810
  809955:	68 23 04 00 00       	push   $0x423
  80995a:	68 9a 27 81 00       	push   $0x81279a
  80995f:	e8 35 4d 00 00       	call   80e699 <_panic>
    return ERR_MEM;
  809964:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  809969:	eb c1                	jmp    80992c <etharp_request+0xe2>

0080996b <etharp_query>:
{
  80996b:	55                   	push   %ebp
  80996c:	89 e5                	mov    %esp,%ebp
  80996e:	57                   	push   %edi
  80996f:	56                   	push   %esi
  809970:	53                   	push   %ebx
  809971:	83 ec 14             	sub    $0x14,%esp
  809974:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  809977:	ff 75 08             	pushl  0x8(%ebp)
  80997a:	53                   	push   %ebx
  80997b:	e8 81 cb ff ff       	call   806501 <ip_addr_isbroadcast>
  809980:	83 c4 10             	add    $0x10,%esp
  809983:	84 c0                	test   %al,%al
  809985:	0f 85 a2 01 00 00    	jne    809b2d <etharp_query+0x1c2>
      ip_addr_ismulticast(ipaddr) ||
  80998b:	8b 33                	mov    (%ebx),%esi
  80998d:	83 ec 0c             	sub    $0xc,%esp
  809990:	68 00 00 00 f0       	push   $0xf0000000
  809995:	e8 fb df ff ff       	call   807995 <ntohl>
  80999a:	21 c6                	and    %eax,%esi
  80999c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8099a3:	e8 ed df ff ff       	call   807995 <ntohl>
  8099a8:	83 c4 10             	add    $0x10,%esp
  8099ab:	39 c6                	cmp    %eax,%esi
  8099ad:	0f 84 84 01 00 00    	je     809b37 <etharp_query+0x1cc>
      ip_addr_isany(ipaddr)) {
  8099b3:	83 3b 00             	cmpl   $0x0,(%ebx)
  8099b6:	0f 84 85 01 00 00    	je     809b41 <etharp_query+0x1d6>
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  8099bc:	ba 01 00 00 00       	mov    $0x1,%edx
  8099c1:	89 d8                	mov    %ebx,%eax
  8099c3:	e8 48 f7 ff ff       	call   809110 <find_entry>
  8099c8:	89 c6                	mov    %eax,%esi
  if (i < 0) {
  8099ca:	84 c0                	test   %al,%al
  8099cc:	0f 88 79 01 00 00    	js     809b4b <etharp_query+0x1e0>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  8099d2:	0f be f8             	movsbl %al,%edi
  8099d5:	6b c7 1c             	imul   $0x1c,%edi,%eax
  8099d8:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  8099de:	85 c0                	test   %eax,%eax
  8099e0:	75 26                	jne    809a08 <etharp_query+0x9d>
    arp_table[i].state = ETHARP_STATE_PENDING;
  8099e2:	6b c7 1c             	imul   $0x1c,%edi,%eax
  8099e5:	c7 80 30 4a b3 00 01 	movl   $0x1,0xb34a30(%eax)
  8099ec:	00 00 00 
    result = etharp_request(netif, ipaddr);
  8099ef:	83 ec 08             	sub    $0x8,%esp
  8099f2:	53                   	push   %ebx
  8099f3:	ff 75 08             	pushl  0x8(%ebp)
  8099f6:	e8 4f fe ff ff       	call   80984a <etharp_request>
  8099fb:	89 c3                	mov    %eax,%ebx
  if (q != NULL) {
  8099fd:	83 c4 10             	add    $0x10,%esp
  809a00:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a04:	74 2d                	je     809a33 <etharp_query+0xc8>
  809a06:	eb 18                	jmp    809a20 <etharp_query+0xb5>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809a08:	8d 50 ff             	lea    -0x1(%eax),%edx
  809a0b:	83 fa 01             	cmp    $0x1,%edx
  809a0e:	77 2d                	ja     809a3d <etharp_query+0xd2>
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  809a10:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  809a14:	74 d9                	je     8099ef <etharp_query+0x84>
  809a16:	83 f8 01             	cmp    $0x1,%eax
  809a19:	74 d4                	je     8099ef <etharp_query+0x84>
  err_t result = ERR_MEM;
  809a1b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  809a20:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809a23:	8b 80 30 4a b3 00    	mov    0xb34a30(%eax),%eax
  809a29:	83 f8 02             	cmp    $0x2,%eax
  809a2c:	74 26                	je     809a54 <etharp_query+0xe9>
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  809a2e:	83 f8 01             	cmp    $0x1,%eax
  809a31:	74 4a                	je     809a7d <etharp_query+0x112>
}
  809a33:	89 d8                	mov    %ebx,%eax
  809a35:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809a38:	5b                   	pop    %ebx
  809a39:	5e                   	pop    %esi
  809a3a:	5f                   	pop    %edi
  809a3b:	5d                   	pop    %ebp
  809a3c:	c3                   	ret    
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  809a3d:	83 ec 04             	sub    $0x4,%esp
  809a40:	68 b0 28 81 00       	push   $0x8128b0
  809a45:	68 92 03 00 00       	push   $0x392
  809a4a:	68 9a 27 81 00       	push   $0x81279a
  809a4f:	e8 45 4c 00 00       	call   80e699 <_panic>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  809a54:	8b 45 08             	mov    0x8(%ebp),%eax
  809a57:	8d 48 25             	lea    0x25(%eax),%ecx
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  809a5a:	83 ec 0c             	sub    $0xc,%esp
  809a5d:	89 f0                	mov    %esi,%eax
  809a5f:	0f be c0             	movsbl %al,%eax
  809a62:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809a65:	05 28 4a b3 00       	add    $0xb34a28,%eax
  809a6a:	50                   	push   %eax
  809a6b:	8b 55 10             	mov    0x10(%ebp),%edx
  809a6e:	8b 45 08             	mov    0x8(%ebp),%eax
  809a71:	e8 3a f9 ff ff       	call   8093b0 <etharp_send_ip>
  809a76:	89 c3                	mov    %eax,%ebx
  809a78:	83 c4 10             	add    $0x10,%esp
  809a7b:	eb b6                	jmp    809a33 <etharp_query+0xc8>
      p = q;
  809a7d:	8b 45 10             	mov    0x10(%ebp),%eax
  809a80:	eb 27                	jmp    809aa9 <etharp_query+0x13e>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809a82:	83 ec 04             	sub    $0x4,%esp
  809a85:	68 f6 27 81 00       	push   $0x8127f6
  809a8a:	68 b1 03 00 00       	push   $0x3b1
  809a8f:	68 9a 27 81 00       	push   $0x81279a
  809a94:	e8 00 4c 00 00       	call   80e699 <_panic>
        if(p->type != PBUF_ROM) {
  809a99:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809a9d:	75 23                	jne    809ac2 <etharp_query+0x157>
        p = p->next;
  809a9f:	8b 00                	mov    (%eax),%eax
      while (p) {
  809aa1:	85 c0                	test   %eax,%eax
  809aa3:	0f 84 a9 00 00 00    	je     809b52 <etharp_query+0x1e7>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  809aa9:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  809aad:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  809ab1:	75 e6                	jne    809a99 <etharp_query+0x12e>
  809ab3:	83 38 00             	cmpl   $0x0,(%eax)
  809ab6:	75 ca                	jne    809a82 <etharp_query+0x117>
        if(p->type != PBUF_ROM) {
  809ab8:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  809abc:	0f 84 90 00 00 00    	je     809b52 <etharp_query+0x1e7>
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809ac2:	83 ec 04             	sub    $0x4,%esp
  809ac5:	6a 00                	push   $0x0
  809ac7:	0f b7 d2             	movzwl %dx,%edx
  809aca:	52                   	push   %edx
  809acb:	6a 03                	push   $0x3
  809acd:	e8 7e ae ff ff       	call   804950 <pbuf_alloc>
  809ad2:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  809ad4:	83 c4 10             	add    $0x10,%esp
  809ad7:	85 c0                	test   %eax,%eax
  809ad9:	0f 84 54 ff ff ff    	je     809a33 <etharp_query+0xc8>
          if (pbuf_copy(p, q) != ERR_OK) {
  809adf:	83 ec 08             	sub    $0x8,%esp
  809ae2:	ff 75 10             	pushl  0x10(%ebp)
  809ae5:	56                   	push   %esi
  809ae6:	e8 47 b3 ff ff       	call   804e32 <pbuf_copy>
  809aeb:	83 c4 10             	add    $0x10,%esp
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  809aee:	89 75 10             	mov    %esi,0x10(%ebp)
          if (pbuf_copy(p, q) != ERR_OK) {
  809af1:	84 c0                	test   %al,%al
  809af3:	74 6b                	je     809b60 <etharp_query+0x1f5>
            pbuf_free(p);
  809af5:	83 ec 0c             	sub    $0xc,%esp
  809af8:	56                   	push   %esi
  809af9:	e8 8c ad ff ff       	call   80488a <pbuf_free>
  809afe:	83 c4 10             	add    $0x10,%esp
  809b01:	e9 2d ff ff ff       	jmp    809a33 <etharp_query+0xc8>
              r = r->next;
  809b06:	89 d1                	mov    %edx,%ecx
            while (r->next != NULL) {
  809b08:	8b 11                	mov    (%ecx),%edx
  809b0a:	85 d2                	test   %edx,%edx
  809b0c:	75 f8                	jne    809b06 <etharp_query+0x19b>
            r->next = new_entry;
  809b0e:	89 01                	mov    %eax,(%ecx)
          result = ERR_OK;
  809b10:	bb 00 00 00 00       	mov    $0x0,%ebx
  809b15:	e9 19 ff ff ff       	jmp    809a33 <etharp_query+0xc8>
          pbuf_free(p);
  809b1a:	83 ec 0c             	sub    $0xc,%esp
  809b1d:	ff 75 10             	pushl  0x10(%ebp)
  809b20:	e8 65 ad ff ff       	call   80488a <pbuf_free>
  809b25:	83 c4 10             	add    $0x10,%esp
  809b28:	e9 06 ff ff ff       	jmp    809a33 <etharp_query+0xc8>
    return ERR_ARG;
  809b2d:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b32:	e9 fc fe ff ff       	jmp    809a33 <etharp_query+0xc8>
  809b37:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b3c:	e9 f2 fe ff ff       	jmp    809a33 <etharp_query+0xc8>
  809b41:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  809b46:	e9 e8 fe ff ff       	jmp    809a33 <etharp_query+0xc8>
    return (err_t)i;
  809b4b:	89 c3                	mov    %eax,%ebx
  809b4d:	e9 e1 fe ff ff       	jmp    809a33 <etharp_query+0xc8>
        pbuf_ref(p);
  809b52:	83 ec 0c             	sub    $0xc,%esp
  809b55:	ff 75 10             	pushl  0x10(%ebp)
  809b58:	e8 8f b1 ff ff       	call   804cec <pbuf_ref>
  809b5d:	83 c4 10             	add    $0x10,%esp
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  809b60:	83 ec 0c             	sub    $0xc,%esp
  809b63:	6a 0a                	push   $0xa
  809b65:	e8 7d a9 ff ff       	call   8044e7 <memp_malloc>
        if (new_entry != NULL) {
  809b6a:	83 c4 10             	add    $0x10,%esp
  809b6d:	85 c0                	test   %eax,%eax
  809b6f:	74 a9                	je     809b1a <etharp_query+0x1af>
          new_entry->next = 0;
  809b71:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  809b77:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809b7a:	89 48 04             	mov    %ecx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  809b7d:	6b d7 1c             	imul   $0x1c,%edi,%edx
  809b80:	8b 8a 20 4a b3 00    	mov    0xb34a20(%edx),%ecx
  809b86:	85 c9                	test   %ecx,%ecx
  809b88:	0f 85 7a ff ff ff    	jne    809b08 <etharp_query+0x19d>
            arp_table[i].q = new_entry;
  809b8e:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809b91:	89 87 20 4a b3 00    	mov    %eax,0xb34a20(%edi)
          result = ERR_OK;
  809b97:	bb 00 00 00 00       	mov    $0x0,%ebx
  809b9c:	e9 92 fe ff ff       	jmp    809a33 <etharp_query+0xc8>

00809ba1 <etharp_output>:
{
  809ba1:	55                   	push   %ebp
  809ba2:	89 e5                	mov    %esp,%ebp
  809ba4:	57                   	push   %edi
  809ba5:	56                   	push   %esi
  809ba6:	53                   	push   %ebx
  809ba7:	83 ec 24             	sub    $0x24,%esp
  809baa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809bad:	8b 75 10             	mov    0x10(%ebp),%esi
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  809bb0:	6a 0e                	push   $0xe
  809bb2:	ff 75 0c             	pushl  0xc(%ebp)
  809bb5:	e8 03 ac ff ff       	call   8047bd <pbuf_header>
  809bba:	83 c4 10             	add    $0x10,%esp
  809bbd:	84 c0                	test   %al,%al
  809bbf:	0f 85 c0 00 00 00    	jne    809c85 <etharp_output+0xe4>
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  809bc5:	83 ec 08             	sub    $0x8,%esp
  809bc8:	53                   	push   %ebx
  809bc9:	56                   	push   %esi
  809bca:	e8 32 c9 ff ff       	call   806501 <ip_addr_isbroadcast>
  809bcf:	83 c4 10             	add    $0x10,%esp
  809bd2:	84 c0                	test   %al,%al
  809bd4:	0f 85 8a 00 00 00    	jne    809c64 <etharp_output+0xc3>
  } else if (ip_addr_ismulticast(ipaddr)) {
  809bda:	8b 3e                	mov    (%esi),%edi
  809bdc:	83 ec 0c             	sub    $0xc,%esp
  809bdf:	68 00 00 00 f0       	push   $0xf0000000
  809be4:	e8 ac dd ff ff       	call   807995 <ntohl>
  809be9:	21 c7                	and    %eax,%edi
  809beb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809bf2:	e8 9e dd ff ff       	call   807995 <ntohl>
  809bf7:	83 c4 10             	add    $0x10,%esp
  809bfa:	39 c7                	cmp    %eax,%edi
  809bfc:	74 25                	je     809c23 <etharp_output+0x82>
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  809bfe:	8b 06                	mov    (%esi),%eax
  809c00:	33 43 04             	xor    0x4(%ebx),%eax
  809c03:	85 43 08             	test   %eax,0x8(%ebx)
  809c06:	74 09                	je     809c11 <etharp_output+0x70>
      if (netif->gw.addr != 0) {
  809c08:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  809c0c:	74 7e                	je     809c8c <etharp_output+0xeb>
        ipaddr = &(netif->gw);
  809c0e:	8d 73 0c             	lea    0xc(%ebx),%esi
    return etharp_query(netif, ipaddr, q);
  809c11:	83 ec 04             	sub    $0x4,%esp
  809c14:	ff 75 0c             	pushl  0xc(%ebp)
  809c17:	56                   	push   %esi
  809c18:	53                   	push   %ebx
  809c19:	e8 4d fd ff ff       	call   80996b <etharp_query>
  809c1e:	83 c4 10             	add    $0x10,%esp
  809c21:	eb 5a                	jmp    809c7d <etharp_output+0xdc>
    mcastaddr.addr[0] = 0x01;
  809c23:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  809c27:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  809c2b:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  809c2f:	83 ec 0c             	sub    $0xc,%esp
  809c32:	ff 36                	pushl  (%esi)
  809c34:	e8 5c dd ff ff       	call   807995 <ntohl>
  809c39:	c1 e8 10             	shr    $0x10,%eax
  809c3c:	83 e0 7f             	and    $0x7f,%eax
  809c3f:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  809c42:	83 c4 04             	add    $0x4,%esp
  809c45:	ff 36                	pushl  (%esi)
  809c47:	e8 49 dd ff ff       	call   807995 <ntohl>
  809c4c:	88 65 e6             	mov    %ah,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  809c4f:	83 c4 04             	add    $0x4,%esp
  809c52:	ff 36                	pushl  (%esi)
  809c54:	e8 3c dd ff ff       	call   807995 <ntohl>
  809c59:	88 45 e7             	mov    %al,-0x19(%ebp)
  809c5c:	83 c4 10             	add    $0x10,%esp
    dest = &mcastaddr;
  809c5f:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  809c62:	eb 05                	jmp    809c69 <etharp_output+0xc8>
    dest = (struct eth_addr *)&ethbroadcast;
  809c64:	b8 04 29 81 00       	mov    $0x812904,%eax
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  809c69:	8d 4b 25             	lea    0x25(%ebx),%ecx
  809c6c:	83 ec 0c             	sub    $0xc,%esp
  809c6f:	50                   	push   %eax
  809c70:	8b 55 0c             	mov    0xc(%ebp),%edx
  809c73:	89 d8                	mov    %ebx,%eax
  809c75:	e8 36 f7 ff ff       	call   8093b0 <etharp_send_ip>
  809c7a:	83 c4 10             	add    $0x10,%esp
}
  809c7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  809c80:	5b                   	pop    %ebx
  809c81:	5e                   	pop    %esi
  809c82:	5f                   	pop    %edi
  809c83:	5d                   	pop    %ebp
  809c84:	c3                   	ret    
    return ERR_BUF;
  809c85:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  809c8a:	eb f1                	jmp    809c7d <etharp_output+0xdc>
        return ERR_RTE;
  809c8c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809c91:	eb ea                	jmp    809c7d <etharp_output+0xdc>

00809c93 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  809c93:	55                   	push   %ebp
  809c94:	89 e5                	mov    %esp,%ebp
  809c96:	56                   	push   %esi
  809c97:	53                   	push   %ebx
  809c98:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809c9b:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  809c9e:	83 ec 0c             	sub    $0xc,%esp
  809ca1:	8b 43 04             	mov    0x4(%ebx),%eax
  809ca4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  809ca8:	50                   	push   %eax
  809ca9:	e8 b6 da ff ff       	call   807764 <htons>
  809cae:	83 c4 10             	add    $0x10,%esp
  809cb1:	66 3d 00 08          	cmp    $0x800,%ax
  809cb5:	74 14                	je     809ccb <ethernet_input+0x38>
  809cb7:	66 3d 06 08          	cmp    $0x806,%ax
  809cbb:	74 50                	je     809d0d <ethernet_input+0x7a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  809cbd:	83 ec 0c             	sub    $0xc,%esp
  809cc0:	53                   	push   %ebx
  809cc1:	e8 c4 ab ff ff       	call   80488a <pbuf_free>
      p = NULL;
      break;
  809cc6:	83 c4 10             	add    $0x10,%esp
  809cc9:	eb 53                	jmp    809d1e <ethernet_input+0x8b>
      etharp_ip_input(netif, p);
  809ccb:	83 ec 08             	sub    $0x8,%esp
  809cce:	53                   	push   %ebx
  809ccf:	56                   	push   %esi
  809cd0:	e8 44 f9 ff ff       	call   809619 <etharp_ip_input>
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  809cd5:	83 c4 08             	add    $0x8,%esp
  809cd8:	6a f2                	push   $0xfffffff2
  809cda:	53                   	push   %ebx
  809cdb:	e8 dd aa ff ff       	call   8047bd <pbuf_header>
  809ce0:	83 c4 10             	add    $0x10,%esp
  809ce3:	84 c0                	test   %al,%al
  809ce5:	75 0f                	jne    809cf6 <ethernet_input+0x63>
        ip_input(p, netif);
  809ce7:	83 ec 08             	sub    $0x8,%esp
  809cea:	56                   	push   %esi
  809ceb:	53                   	push   %ebx
  809cec:	e8 b0 c8 ff ff       	call   8065a1 <ip_input>
      break;
  809cf1:	83 c4 10             	add    $0x10,%esp
  809cf4:	eb 28                	jmp    809d1e <ethernet_input+0x8b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  809cf6:	83 ec 04             	sub    $0x4,%esp
  809cf9:	68 d8 28 81 00       	push   $0x8128d8
  809cfe:	68 7e 04 00 00       	push   $0x47e
  809d03:	68 9a 27 81 00       	push   $0x81279a
  809d08:	e8 8c 49 00 00       	call   80e699 <_panic>
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  809d0d:	83 ec 04             	sub    $0x4,%esp
  809d10:	53                   	push   %ebx
  809d11:	8d 46 25             	lea    0x25(%esi),%eax
  809d14:	50                   	push   %eax
  809d15:	56                   	push   %esi
  809d16:	e8 4a f9 ff ff       	call   809665 <etharp_arp_input>
      break;
  809d1b:	83 c4 10             	add    $0x10,%esp
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  809d1e:	b8 00 00 00 00       	mov    $0x0,%eax
  809d23:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809d26:	5b                   	pop    %ebx
  809d27:	5e                   	pop    %esi
  809d28:	5d                   	pop    %ebp
  809d29:	c3                   	ret    

00809d2a <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  809d2a:	55                   	push   %ebp
  809d2b:	89 e5                	mov    %esp,%ebp
  809d2d:	53                   	push   %ebx
  809d2e:	83 ec 10             	sub    $0x10,%esp
  809d31:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  809d34:	ff 73 04             	pushl  0x4(%ebx)
  809d37:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  809d39:	89 1c 24             	mov    %ebx,(%esp)
  809d3c:	e8 ea 6a 00 00       	call   81082b <free>
}
  809d41:	83 c4 10             	add    $0x10,%esp
  809d44:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809d47:	c9                   	leave  
  809d48:	c3                   	ret    

00809d49 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  809d49:	55                   	push   %ebp
  809d4a:	89 e5                	mov    %esp,%ebp
  809d4c:	83 ec 08             	sub    $0x8,%esp
  809d4f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809d52:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  809d57:	89 c8                	mov    %ecx,%eax
  809d59:	f7 e2                	mul    %edx
  809d5b:	c1 ea 08             	shr    $0x8,%edx
  809d5e:	89 d0                	mov    %edx,%eax
  809d60:	c1 e0 08             	shl    $0x8,%eax
  809d63:	01 c2                	add    %eax,%edx
  809d65:	89 c8                	mov    %ecx,%eax
  809d67:	29 d0                	sub    %edx,%eax
  809d69:	8b 04 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%eax
  809d70:	85 c0                	test   %eax,%eax
  809d72:	74 2a                	je     809d9e <timeout_cleanup+0x55>
	if (t->tid == tid) {
  809d74:	39 08                	cmp    %ecx,(%eax)
  809d76:	74 05                	je     809d7d <timeout_cleanup+0x34>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  809d78:	8b 40 08             	mov    0x8(%eax),%eax
  809d7b:	eb f3                	jmp    809d70 <timeout_cleanup+0x27>
	    LIST_REMOVE(t, link);
  809d7d:	8b 50 08             	mov    0x8(%eax),%edx
  809d80:	85 d2                	test   %edx,%edx
  809d82:	74 06                	je     809d8a <timeout_cleanup+0x41>
  809d84:	8b 48 0c             	mov    0xc(%eax),%ecx
  809d87:	89 4a 0c             	mov    %ecx,0xc(%edx)
  809d8a:	8b 50 0c             	mov    0xc(%eax),%edx
  809d8d:	8b 48 08             	mov    0x8(%eax),%ecx
  809d90:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  809d92:	83 ec 0c             	sub    $0xc,%esp
  809d95:	50                   	push   %eax
  809d96:	e8 90 6a 00 00       	call   81082b <free>
	    goto done;
  809d9b:	83 c4 10             	add    $0x10,%esp
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  809d9e:	c9                   	leave  
  809d9f:	c3                   	ret    

00809da0 <sys_init>:
{
  809da0:	55                   	push   %ebp
  809da1:	89 e5                	mov    %esp,%ebp
  809da3:	56                   	push   %esi
  809da4:	53                   	push   %ebx
  809da5:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809dab:	b8 80 9d b3 00       	mov    $0xb39d80,%eax
  809db0:	be 80 b1 b3 00       	mov    $0xb3b180,%esi
  809db5:	eb 10                	jmp    809dc7 <sys_init+0x27>
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809db7:	c7 41 10 60 9d b3 00 	movl   $0xb39d60,0x10(%ecx)
  809dbe:	83 c0 14             	add    $0x14,%eax
  809dc1:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NSEM; i++) {
  809dc3:	39 f0                	cmp    %esi,%eax
  809dc5:	74 17                	je     809dde <sys_init+0x3e>
  809dc7:	89 c1                	mov    %eax,%ecx
	sems[i].freed = 1;
  809dc9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  809dcf:	89 50 0c             	mov    %edx,0xc(%eax)
  809dd2:	85 d2                	test   %edx,%edx
  809dd4:	74 e1                	je     809db7 <sys_init+0x17>
  809dd6:	8d 58 0c             	lea    0xc(%eax),%ebx
  809dd9:	89 5a 10             	mov    %ebx,0x10(%edx)
  809ddc:	eb d9                	jmp    809db7 <sys_init+0x17>
  809dde:	c7 05 60 9d b3 00 6c 	movl   $0xb3b16c,0xb39d60
  809de5:	b1 b3 00 
  809de8:	8b 15 44 4f b3 00    	mov    0xb34f44,%edx
  809dee:	b8 60 4f b3 00       	mov    $0xb34f60,%eax
  809df3:	be 60 9d b3 00       	mov    $0xb39d60,%esi
  809df8:	eb 15                	jmp    809e0f <sys_init+0x6f>
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809dfa:	c7 81 98 00 00 00 44 	movl   $0xb34f44,0x98(%ecx)
  809e01:	4f b3 00 
  809e04:	05 9c 00 00 00       	add    $0x9c,%eax
  809e09:	89 ca                	mov    %ecx,%edx
    for (i = 0; i < NMBOX; i++) {
  809e0b:	39 f0                	cmp    %esi,%eax
  809e0d:	74 20                	je     809e2f <sys_init+0x8f>
  809e0f:	89 c1                	mov    %eax,%ecx
	mboxes[i].freed = 1;
  809e11:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  809e17:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  809e1d:	85 d2                	test   %edx,%edx
  809e1f:	74 d9                	je     809dfa <sys_init+0x5a>
  809e21:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  809e27:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  809e2d:	eb cb                	jmp    809dfa <sys_init+0x5a>
  809e2f:	c7 05 44 4f b3 00 c4 	movl   $0xb39cc4,0xb34f44
  809e36:	9c b3 00 
}
  809e39:	5b                   	pop    %ebx
  809e3a:	5e                   	pop    %esi
  809e3b:	5d                   	pop    %ebp
  809e3c:	c3                   	ret    

00809e3d <sys_sem_new>:
{
  809e3d:	55                   	push   %ebp
  809e3e:	89 e5                	mov    %esp,%ebp
  809e40:	53                   	push   %ebx
  809e41:	83 ec 04             	sub    $0x4,%esp
  809e44:	8b 55 08             	mov    0x8(%ebp),%edx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  809e47:	a1 60 9d b3 00       	mov    0xb39d60,%eax
    if (!se) {
  809e4c:	85 c0                	test   %eax,%eax
  809e4e:	74 3e                	je     809e8e <sys_sem_new+0x51>
    LIST_REMOVE(se, link);
  809e50:	8b 48 0c             	mov    0xc(%eax),%ecx
  809e53:	85 c9                	test   %ecx,%ecx
  809e55:	74 06                	je     809e5d <sys_sem_new+0x20>
  809e57:	8b 58 10             	mov    0x10(%eax),%ebx
  809e5a:	89 59 10             	mov    %ebx,0x10(%ecx)
  809e5d:	8b 48 10             	mov    0x10(%eax),%ecx
  809e60:	8b 58 0c             	mov    0xc(%eax),%ebx
  809e63:	89 19                	mov    %ebx,(%ecx)
    assert(se->freed);
  809e65:	83 38 00             	cmpl   $0x0,(%eax)
  809e68:	74 3b                	je     809ea5 <sys_sem_new+0x68>
    se->freed = 0;
  809e6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    se->counter = count;
  809e70:	0f b6 d2             	movzbl %dl,%edx
  809e73:	66 89 50 08          	mov    %dx,0x8(%eax)
    se->gen++;
  809e77:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  809e7b:	2d 80 9d b3 00       	sub    $0xb39d80,%eax
  809e80:	c1 f8 02             	sar    $0x2,%eax
  809e83:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  809e89:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  809e8c:	c9                   	leave  
  809e8d:	c3                   	ret    
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  809e8e:	83 ec 0c             	sub    $0xc,%esp
  809e91:	68 0c 29 81 00       	push   $0x81290c
  809e96:	e8 f4 48 00 00       	call   80e78f <cprintf>
	return SYS_SEM_NULL;
  809e9b:	83 c4 10             	add    $0x10,%esp
  809e9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ea3:	eb e4                	jmp    809e89 <sys_sem_new+0x4c>
    assert(se->freed);
  809ea5:	68 81 2a 81 00       	push   $0x812a81
  809eaa:	68 8b 2a 81 00       	push   $0x812a8b
  809eaf:	68 8d 00 00 00       	push   $0x8d
  809eb4:	68 a0 2a 81 00       	push   $0x812aa0
  809eb9:	e8 db 47 00 00       	call   80e699 <_panic>

00809ebe <sys_sem_free>:
{
  809ebe:	55                   	push   %ebp
  809ebf:	89 e5                	mov    %esp,%ebp
  809ec1:	83 ec 08             	sub    $0x8,%esp
  809ec4:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  809ec7:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809eca:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  809ed1:	00 
  809ed2:	75 5a                	jne    809f2e <sys_sem_free+0x70>
    sems[sem].freed = 1;
  809ed4:	8d 14 80             	lea    (%eax,%eax,4),%edx
  809ed7:	c1 e2 02             	shl    $0x2,%edx
  809eda:	8d 8a 80 9d b3 00    	lea    0xb39d80(%edx),%ecx
  809ee0:	c7 82 80 9d b3 00 01 	movl   $0x1,0xb39d80(%edx)
  809ee7:	00 00 00 
    sems[sem].gen++;
  809eea:	83 41 04 01          	addl   $0x1,0x4(%ecx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  809eee:	8b 15 60 9d b3 00    	mov    0xb39d60,%edx
  809ef4:	89 51 0c             	mov    %edx,0xc(%ecx)
  809ef7:	85 d2                	test   %edx,%edx
  809ef9:	74 0d                	je     809f08 <sys_sem_free+0x4a>
  809efb:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  809efe:	8d 0c 8d 8c 9d b3 00 	lea    0xb39d8c(,%ecx,4),%ecx
  809f05:	89 4a 10             	mov    %ecx,0x10(%edx)
  809f08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  809f0f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  809f12:	8d 0c 8d 80 9d b3 00 	lea    0xb39d80(,%ecx,4),%ecx
  809f19:	89 0d 60 9d b3 00    	mov    %ecx,0xb39d60
  809f1f:	01 d0                	add    %edx,%eax
  809f21:	c7 04 85 90 9d b3 00 	movl   $0xb39d60,0xb39d90(,%eax,4)
  809f28:	60 9d b3 00 
}
  809f2c:	c9                   	leave  
  809f2d:	c3                   	ret    
    assert(!sems[sem].freed);
  809f2e:	68 bd 2a 81 00       	push   $0x812abd
  809f33:	68 8b 2a 81 00       	push   $0x812a8b
  809f38:	68 98 00 00 00       	push   $0x98
  809f3d:	68 a0 2a 81 00       	push   $0x812aa0
  809f42:	e8 52 47 00 00       	call   80e699 <_panic>

00809f47 <sys_mbox_free>:
{
  809f47:	55                   	push   %ebp
  809f48:	89 e5                	mov    %esp,%ebp
  809f4a:	56                   	push   %esi
  809f4b:	53                   	push   %ebx
  809f4c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  809f4f:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  809f55:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  809f5c:	75 72                	jne    809fd0 <sys_mbox_free+0x89>
    sys_sem_free(mboxes[mbox].queued_msg);
  809f5e:	83 ec 0c             	sub    $0xc,%esp
  809f61:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  809f67:	ff b6 ec 4f b3 00    	pushl  0xb34fec(%esi)
  809f6d:	e8 4c ff ff ff       	call   809ebe <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  809f72:	83 c4 04             	add    $0x4,%esp
  809f75:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  809f7b:	e8 3e ff ff ff       	call   809ebe <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  809f80:	a1 44 4f b3 00       	mov    0xb34f44,%eax
  809f85:	89 86 f4 4f b3 00    	mov    %eax,0xb34ff4(%esi)
  809f8b:	83 c4 10             	add    $0x10,%esp
  809f8e:	85 c0                	test   %eax,%eax
  809f90:	74 12                	je     809fa4 <sys_mbox_free+0x5d>
  809f92:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  809f98:	81 c2 f4 4f b3 00    	add    $0xb34ff4,%edx
  809f9e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  809fa4:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  809faa:	8d 83 60 4f b3 00    	lea    0xb34f60(%ebx),%eax
  809fb0:	a3 44 4f b3 00       	mov    %eax,0xb34f44
  809fb5:	c7 83 f8 4f b3 00 44 	movl   $0xb34f44,0xb34ff8(%ebx)
  809fbc:	4f b3 00 
    mboxes[mbox].freed = 1;
  809fbf:	c7 83 60 4f b3 00 01 	movl   $0x1,0xb34f60(%ebx)
  809fc6:	00 00 00 
}
  809fc9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  809fcc:	5b                   	pop    %ebx
  809fcd:	5e                   	pop    %esi
  809fce:	5d                   	pop    %ebp
  809fcf:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  809fd0:	68 ce 2a 81 00       	push   $0x812ace
  809fd5:	68 8b 2a 81 00       	push   $0x812a8b
  809fda:	6a 62                	push   $0x62
  809fdc:	68 a0 2a 81 00       	push   $0x812aa0
  809fe1:	e8 b3 46 00 00       	call   80e699 <_panic>

00809fe6 <sys_mbox_new>:
{
  809fe6:	55                   	push   %ebp
  809fe7:	89 e5                	mov    %esp,%ebp
  809fe9:	57                   	push   %edi
  809fea:	56                   	push   %esi
  809feb:	53                   	push   %ebx
  809fec:	83 ec 0c             	sub    $0xc,%esp
    assert(size < MBOXSLOTS);
  809fef:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  809ff3:	0f 8f 9f 00 00 00    	jg     80a098 <sys_mbox_new+0xb2>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  809ff9:	8b 1d 44 4f b3 00    	mov    0xb34f44,%ebx
    if (!mbe) {
  809fff:	85 db                	test   %ebx,%ebx
  80a001:	0f 84 a7 00 00 00    	je     80a0ae <sys_mbox_new+0xc8>
    LIST_REMOVE(mbe, link);
  80a007:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a00d:	85 c0                	test   %eax,%eax
  80a00f:	74 0c                	je     80a01d <sys_mbox_new+0x37>
  80a011:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a017:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a01d:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a023:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a029:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a02b:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a02e:	0f 84 91 00 00 00    	je     80a0c5 <sys_mbox_new+0xdf>
    mbe->freed = 0;
  80a034:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    int i = mbe - &mboxes[0];
  80a03a:	89 de                	mov    %ebx,%esi
  80a03c:	81 ee 60 4f b3 00    	sub    $0xb34f60,%esi
  80a042:	c1 fe 02             	sar    $0x2,%esi
  80a045:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
  80a04b:	89 f7                	mov    %esi,%edi
    mbe->head = -1;
  80a04d:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a054:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a05b:	83 ec 0c             	sub    $0xc,%esp
  80a05e:	6a 00                	push   $0x0
  80a060:	e8 d8 fd ff ff       	call   809e3d <sys_sem_new>
  80a065:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a06b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a072:	e8 c6 fd ff ff       	call   809e3d <sys_sem_new>
  80a077:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a07d:	83 c4 10             	add    $0x10,%esp
  80a080:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a087:	74 52                	je     80a0db <sys_mbox_new+0xf5>
  80a089:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a08c:	74 4d                	je     80a0db <sys_mbox_new+0xf5>
}
  80a08e:	89 f8                	mov    %edi,%eax
  80a090:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a093:	5b                   	pop    %ebx
  80a094:	5e                   	pop    %esi
  80a095:	5f                   	pop    %edi
  80a096:	5d                   	pop    %ebp
  80a097:	c3                   	ret    
    assert(size < MBOXSLOTS);
  80a098:	68 e2 2a 81 00       	push   $0x812ae2
  80a09d:	68 8b 2a 81 00       	push   $0x812a8b
  80a0a2:	6a 45                	push   $0x45
  80a0a4:	68 a0 2a 81 00       	push   $0x812aa0
  80a0a9:	e8 eb 45 00 00       	call   80e699 <_panic>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a0ae:	83 ec 0c             	sub    $0xc,%esp
  80a0b1:	68 34 29 81 00       	push   $0x812934
  80a0b6:	e8 d4 46 00 00       	call   80e78f <cprintf>
	return SYS_MBOX_NULL;
  80a0bb:	83 c4 10             	add    $0x10,%esp
  80a0be:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a0c3:	eb c9                	jmp    80a08e <sys_mbox_new+0xa8>
    assert(mbe->freed);
  80a0c5:	68 f3 2a 81 00       	push   $0x812af3
  80a0ca:	68 8b 2a 81 00       	push   $0x812a8b
  80a0cf:	6a 4c                	push   $0x4c
  80a0d1:	68 a0 2a 81 00       	push   $0x812aa0
  80a0d6:	e8 be 45 00 00       	call   80e699 <_panic>
	sys_mbox_free(i);
  80a0db:	83 ec 0c             	sub    $0xc,%esp
  80a0de:	56                   	push   %esi
  80a0df:	e8 63 fe ff ff       	call   809f47 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a0e4:	c7 04 24 5c 29 81 00 	movl   $0x81295c,(%esp)
  80a0eb:	e8 9f 46 00 00       	call   80e78f <cprintf>
	return SYS_MBOX_NULL;
  80a0f0:	83 c4 10             	add    $0x10,%esp
  80a0f3:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a0f8:	eb 94                	jmp    80a08e <sys_mbox_new+0xa8>

0080a0fa <sys_sem_signal>:
{
  80a0fa:	55                   	push   %ebp
  80a0fb:	89 e5                	mov    %esp,%ebp
  80a0fd:	83 ec 08             	sub    $0x8,%esp
  80a100:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a103:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a106:	83 3c 95 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%edx,4)
  80a10d:	00 
  80a10e:	75 18                	jne    80a128 <sys_sem_signal+0x2e>
    sems[sem].counter++;
  80a110:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a113:	8d 14 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%edx
  80a11a:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a11f:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a124:	75 1b                	jne    80a141 <sys_sem_signal+0x47>
}
  80a126:	c9                   	leave  
  80a127:	c3                   	ret    
    assert(!sems[sem].freed);
  80a128:	68 bd 2a 81 00       	push   $0x812abd
  80a12d:	68 8b 2a 81 00       	push   $0x812a8b
  80a132:	68 a1 00 00 00       	push   $0xa1
  80a137:	68 a0 2a 81 00       	push   $0x812aa0
  80a13c:	e8 58 45 00 00       	call   80e699 <_panic>
	sems[sem].waiters = 0;
  80a141:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a148:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a14b:	66 c7 04 8d 8a 9d b3 	movw   $0x0,0xb39d8a(,%ecx,4)
  80a152:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a155:	83 ec 0c             	sub    $0xc,%esp
  80a158:	8d 04 8d 88 9d b3 00 	lea    0xb39d88(,%ecx,4),%eax
  80a15f:	50                   	push   %eax
  80a160:	e8 a4 04 00 00       	call   80a609 <thread_wakeup>
  80a165:	83 c4 10             	add    $0x10,%esp
}
  80a168:	eb bc                	jmp    80a126 <sys_sem_signal+0x2c>

0080a16a <sys_arch_sem_wait>:
{
  80a16a:	55                   	push   %ebp
  80a16b:	89 e5                	mov    %esp,%ebp
  80a16d:	57                   	push   %edi
  80a16e:	56                   	push   %esi
  80a16f:	53                   	push   %ebx
  80a170:	83 ec 1c             	sub    $0x1c,%esp
  80a173:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    assert(!sems[sem].freed);
  80a176:	8b 45 08             	mov    0x8(%ebp),%eax
  80a179:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a17c:	83 3c 85 80 9d b3 00 	cmpl   $0x0,0xb39d80(,%eax,4)
  80a183:	00 
  80a184:	75 2c                	jne    80a1b2 <sys_arch_sem_wait+0x48>
    int gen = sems[sem].gen;
  80a186:	8b 45 08             	mov    0x8(%ebp),%eax
  80a189:	c1 e0 02             	shl    $0x2,%eax
  80a18c:	89 c2                	mov    %eax,%edx
  80a18e:	03 55 08             	add    0x8(%ebp),%edx
  80a191:	8b 3c 95 84 9d b3 00 	mov    0xb39d84(,%edx,4),%edi
  80a198:	89 7d d8             	mov    %edi,-0x28(%ebp)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a19b:	8d 04 95 88 9d b3 00 	lea    0xb39d88(,%edx,4),%eax
  80a1a2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    u32_t waited = 0;
  80a1a5:	bf 00 00 00 00       	mov    $0x0,%edi
	if (sems[sem].counter > 0) {
  80a1aa:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    while (tm_msec == 0 || waited < tm_msec) {
  80a1ad:	e9 80 00 00 00       	jmp    80a232 <sys_arch_sem_wait+0xc8>
    assert(!sems[sem].freed);
  80a1b2:	68 bd 2a 81 00       	push   $0x812abd
  80a1b7:	68 8b 2a 81 00       	push   $0x812a8b
  80a1bc:	68 ac 00 00 00       	push   $0xac
  80a1c1:	68 a0 2a 81 00       	push   $0x812aa0
  80a1c6:	e8 ce 44 00 00       	call   80e699 <_panic>
	if (sems[sem].counter > 0) {
  80a1cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a1ce:	0f b7 04 85 88 9d b3 	movzwl 0xb39d88(,%eax,4),%eax
  80a1d5:	00 
  80a1d6:	66 85 c0             	test   %ax,%ax
  80a1d9:	75 6e                	jne    80a249 <sys_arch_sem_wait+0xdf>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80a1db:	83 fb fe             	cmp    $0xfffffffe,%ebx
  80a1de:	0f 84 8f 00 00 00    	je     80a273 <sys_arch_sem_wait+0x109>
	    uint32_t a = sys_time_msec();
  80a1e4:	e8 29 53 00 00       	call   80f512 <sys_time_msec>
  80a1e9:	89 c1                	mov    %eax,%ecx
  80a1eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80a1ee:	89 d8                	mov    %ebx,%eax
  80a1f0:	29 f8                	sub    %edi,%eax
  80a1f2:	01 c8                	add    %ecx,%eax
  80a1f4:	85 db                	test   %ebx,%ebx
  80a1f6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80a1fb:	0f 44 c2             	cmove  %edx,%eax
	    sems[sem].waiters = 1;
  80a1fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a201:	8d 34 95 80 9d b3 00 	lea    0xb39d80(,%edx,4),%esi
  80a208:	66 c7 46 0a 01 00    	movw   $0x1,0xa(%esi)
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80a20e:	83 ec 04             	sub    $0x4,%esp
  80a211:	50                   	push   %eax
  80a212:	ff 76 08             	pushl  0x8(%esi)
  80a215:	ff 75 dc             	pushl  -0x24(%ebp)
  80a218:	e8 02 06 00 00       	call   80a81f <thread_wait>
	    if (gen != sems[sem].gen) {
  80a21d:	83 c4 10             	add    $0x10,%esp
  80a220:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a223:	39 46 04             	cmp    %eax,0x4(%esi)
  80a226:	75 34                	jne    80a25c <sys_arch_sem_wait+0xf2>
	    uint32_t b = sys_time_msec();
  80a228:	e8 e5 52 00 00       	call   80f512 <sys_time_msec>
	    waited += (b - a);
  80a22d:	2b 45 e0             	sub    -0x20(%ebp),%eax
  80a230:	01 c7                	add    %eax,%edi
    while (tm_msec == 0 || waited < tm_msec) {
  80a232:	85 db                	test   %ebx,%ebx
  80a234:	74 95                	je     80a1cb <sys_arch_sem_wait+0x61>
  80a236:	39 df                	cmp    %ebx,%edi
  80a238:	72 91                	jb     80a1cb <sys_arch_sem_wait+0x61>
    return SYS_ARCH_TIMEOUT;
  80a23a:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  80a23f:	89 f8                	mov    %edi,%eax
  80a241:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a244:	5b                   	pop    %ebx
  80a245:	5e                   	pop    %esi
  80a246:	5f                   	pop    %edi
  80a247:	5d                   	pop    %ebp
  80a248:	c3                   	ret    
	    sems[sem].counter--;
  80a249:	8b 55 08             	mov    0x8(%ebp),%edx
  80a24c:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80a24f:	83 e8 01             	sub    $0x1,%eax
  80a252:	66 89 04 95 88 9d b3 	mov    %ax,0xb39d88(,%edx,4)
  80a259:	00 
	    return waited;
  80a25a:	eb e3                	jmp    80a23f <sys_arch_sem_wait+0xd5>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80a25c:	83 ec 0c             	sub    $0xc,%esp
  80a25f:	68 88 29 81 00       	push   $0x812988
  80a264:	e8 26 45 00 00       	call   80e78f <cprintf>
		return SYS_ARCH_TIMEOUT;
  80a269:	83 c4 10             	add    $0x10,%esp
  80a26c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a271:	eb cc                	jmp    80a23f <sys_arch_sem_wait+0xd5>
	    return SYS_ARCH_TIMEOUT;
  80a273:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80a278:	eb c5                	jmp    80a23f <sys_arch_sem_wait+0xd5>

0080a27a <sys_mbox_trypost>:
{
  80a27a:	55                   	push   %ebp
  80a27b:	89 e5                	mov    %esp,%ebp
  80a27d:	57                   	push   %edi
  80a27e:	56                   	push   %esi
  80a27f:	53                   	push   %ebx
  80a280:	83 ec 0c             	sub    $0xc,%esp
  80a283:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a286:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a28c:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a293:	75 7f                	jne    80a314 <sys_mbox_trypost+0x9a>
    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80a295:	83 ec 08             	sub    $0x8,%esp
  80a298:	6a 00                	push   $0x0
  80a29a:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a2a0:	ff b6 f0 4f b3 00    	pushl  0xb34ff0(%esi)
  80a2a6:	e8 bf fe ff ff       	call   80a16a <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80a2ab:	8b 96 68 4f b3 00    	mov    0xb34f68(%esi),%edx
  80a2b1:	8b 8e 64 4f b3 00    	mov    0xb34f64(%esi),%ecx
  80a2b7:	83 c4 10             	add    $0x10,%esp
  80a2ba:	39 ca                	cmp    %ecx,%edx
  80a2bc:	74 7a                	je     80a338 <sys_mbox_trypost+0xbe>
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80a2be:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a2c4:	8d 42 01             	lea    0x1(%edx),%eax
  80a2c7:	89 c7                	mov    %eax,%edi
  80a2c9:	c1 ff 1f             	sar    $0x1f,%edi
  80a2cc:	c1 ef 1b             	shr    $0x1b,%edi
  80a2cf:	01 f8                	add    %edi,%eax
  80a2d1:	83 e0 1f             	and    $0x1f,%eax
  80a2d4:	29 f8                	sub    %edi,%eax
  80a2d6:	89 86 68 4f b3 00    	mov    %eax,0xb34f68(%esi)
    mboxes[mbox].msg[slot] = msg;
  80a2dc:	6b c3 27             	imul   $0x27,%ebx,%eax
  80a2df:	01 d0                	add    %edx,%eax
  80a2e1:	8b 75 0c             	mov    0xc(%ebp),%esi
  80a2e4:	89 34 85 6c 4f b3 00 	mov    %esi,0xb34f6c(,%eax,4)
    if (mboxes[mbox].head == -1)
  80a2eb:	83 f9 ff             	cmp    $0xffffffff,%ecx
  80a2ee:	74 3a                	je     80a32a <sys_mbox_trypost+0xb0>
    sys_sem_signal(mboxes[mbox].queued_msg);
  80a2f0:	83 ec 0c             	sub    $0xc,%esp
  80a2f3:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a2f9:	ff b3 ec 4f b3 00    	pushl  0xb34fec(%ebx)
  80a2ff:	e8 f6 fd ff ff       	call   80a0fa <sys_sem_signal>
    return ERR_OK;
  80a304:	83 c4 10             	add    $0x10,%esp
  80a307:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a30c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a30f:	5b                   	pop    %ebx
  80a310:	5e                   	pop    %esi
  80a311:	5f                   	pop    %edi
  80a312:	5d                   	pop    %ebp
  80a313:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a314:	68 ce 2a 81 00       	push   $0x812ace
  80a319:	68 8b 2a 81 00       	push   $0x812a8b
  80a31e:	6a 72                	push   $0x72
  80a320:	68 a0 2a 81 00       	push   $0x812aa0
  80a325:	e8 6f 43 00 00       	call   80e699 <_panic>
	mboxes[mbox].head = slot;
  80a32a:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a330:	89 90 64 4f b3 00    	mov    %edx,0xb34f64(%eax)
  80a336:	eb b8                	jmp    80a2f0 <sys_mbox_trypost+0x76>
	return ERR_MEM;
  80a338:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a33d:	eb cd                	jmp    80a30c <sys_mbox_trypost+0x92>

0080a33f <sys_mbox_post>:
{
  80a33f:	55                   	push   %ebp
  80a340:	89 e5                	mov    %esp,%ebp
  80a342:	83 ec 10             	sub    $0x10,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a345:	ff 75 0c             	pushl  0xc(%ebp)
  80a348:	ff 75 08             	pushl  0x8(%ebp)
  80a34b:	e8 2a ff ff ff       	call   80a27a <sys_mbox_trypost>
  80a350:	83 c4 10             	add    $0x10,%esp
  80a353:	84 c0                	test   %al,%al
  80a355:	75 02                	jne    80a359 <sys_mbox_post+0x1a>
}
  80a357:	c9                   	leave  
  80a358:	c3                   	ret    
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80a359:	68 b4 29 81 00       	push   $0x8129b4
  80a35e:	68 8b 2a 81 00       	push   $0x812a8b
  80a363:	6a 6c                	push   $0x6c
  80a365:	68 a0 2a 81 00       	push   $0x812aa0
  80a36a:	e8 2a 43 00 00       	call   80e699 <_panic>

0080a36f <sys_arch_mbox_fetch>:
{
  80a36f:	55                   	push   %ebp
  80a370:	89 e5                	mov    %esp,%ebp
  80a372:	57                   	push   %edi
  80a373:	56                   	push   %esi
  80a374:	53                   	push   %ebx
  80a375:	83 ec 0c             	sub    $0xc,%esp
  80a378:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a37b:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80a37e:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a384:	83 b8 60 4f b3 00 00 	cmpl   $0x0,0xb34f60(%eax)
  80a38b:	0f 85 8a 00 00 00    	jne    80a41b <sys_arch_mbox_fetch+0xac>
    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80a391:	83 ec 08             	sub    $0x8,%esp
  80a394:	ff 75 10             	pushl  0x10(%ebp)
  80a397:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a39d:	ff b0 ec 4f b3 00    	pushl  0xb34fec(%eax)
  80a3a3:	e8 c2 fd ff ff       	call   80a16a <sys_arch_sem_wait>
  80a3a8:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80a3aa:	83 c4 10             	add    $0x10,%esp
  80a3ad:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a3b0:	74 5f                	je     80a411 <sys_arch_mbox_fetch+0xa2>
    int slot = mboxes[mbox].head;
  80a3b2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a3b8:	8b 80 64 4f b3 00    	mov    0xb34f64(%eax),%eax
    if (slot == -1)
  80a3be:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a3c1:	74 71                	je     80a434 <sys_arch_mbox_fetch+0xc5>
    if (msg)
  80a3c3:	85 ff                	test   %edi,%edi
  80a3c5:	74 0e                	je     80a3d5 <sys_arch_mbox_fetch+0x66>
	*msg = mboxes[mbox].msg[slot];
  80a3c7:	6b d3 27             	imul   $0x27,%ebx,%edx
  80a3ca:	01 c2                	add    %eax,%edx
  80a3cc:	8b 14 95 6c 4f b3 00 	mov    0xb34f6c(,%edx,4),%edx
  80a3d3:	89 17                	mov    %edx,(%edi)
    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80a3d5:	83 c0 01             	add    $0x1,%eax
  80a3d8:	99                   	cltd   
  80a3d9:	c1 ea 1b             	shr    $0x1b,%edx
  80a3dc:	01 d0                	add    %edx,%eax
  80a3de:	83 e0 1f             	and    $0x1f,%eax
  80a3e1:	29 d0                	sub    %edx,%eax
  80a3e3:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80a3e9:	89 82 64 4f b3 00    	mov    %eax,0xb34f64(%edx)
  80a3ef:	81 c2 60 4f b3 00    	add    $0xb34f60,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80a3f5:	3b 42 08             	cmp    0x8(%edx),%eax
  80a3f8:	74 51                	je     80a44b <sys_arch_mbox_fetch+0xdc>
    sys_sem_signal(mboxes[mbox].free_msg);
  80a3fa:	83 ec 0c             	sub    $0xc,%esp
  80a3fd:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a403:	ff b3 f0 4f b3 00    	pushl  0xb34ff0(%ebx)
  80a409:	e8 ec fc ff ff       	call   80a0fa <sys_sem_signal>
    return waited;
  80a40e:	83 c4 10             	add    $0x10,%esp
}
  80a411:	89 f0                	mov    %esi,%eax
  80a413:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a416:	5b                   	pop    %ebx
  80a417:	5e                   	pop    %esi
  80a418:	5f                   	pop    %edi
  80a419:	5d                   	pop    %ebp
  80a41a:	c3                   	ret    
    assert(!mboxes[mbox].freed);
  80a41b:	68 ce 2a 81 00       	push   $0x812ace
  80a420:	68 8b 2a 81 00       	push   $0x812a8b
  80a425:	68 ce 00 00 00       	push   $0xce
  80a42a:	68 a0 2a 81 00       	push   $0x812aa0
  80a42f:	e8 65 42 00 00       	call   80e699 <_panic>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80a434:	83 ec 04             	sub    $0x4,%esp
  80a437:	68 dc 29 81 00       	push   $0x8129dc
  80a43c:	68 d6 00 00 00       	push   $0xd6
  80a441:	68 a0 2a 81 00       	push   $0x812aa0
  80a446:	e8 4e 42 00 00       	call   80e699 <_panic>
	mboxes[mbox].head = -1;
  80a44b:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a451:	c7 80 64 4f b3 00 ff 	movl   $0xffffffff,0xb34f64(%eax)
  80a458:	ff ff ff 
  80a45b:	eb 9d                	jmp    80a3fa <sys_arch_mbox_fetch+0x8b>

0080a45d <sys_arch_mbox_tryfetch>:
{
  80a45d:	55                   	push   %ebp
  80a45e:	89 e5                	mov    %esp,%ebp
  80a460:	83 ec 0c             	sub    $0xc,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80a463:	6a fe                	push   $0xfffffffe
  80a465:	ff 75 0c             	pushl  0xc(%ebp)
  80a468:	ff 75 08             	pushl  0x8(%ebp)
  80a46b:	e8 ff fe ff ff       	call   80a36f <sys_arch_mbox_fetch>
}
  80a470:	c9                   	leave  
  80a471:	c3                   	ret    

0080a472 <sys_thread_new>:
{
  80a472:	55                   	push   %ebp
  80a473:	89 e5                	mov    %esp,%ebp
  80a475:	83 ec 24             	sub    $0x24,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80a478:	6a 08                	push   $0x8
  80a47a:	e8 58 64 00 00       	call   8108d7 <malloc>
    if (lt == 0)
  80a47f:	83 c4 10             	add    $0x10,%esp
  80a482:	85 c0                	test   %eax,%eax
  80a484:	74 32                	je     80a4b8 <sys_thread_new+0x46>
    if (stacksize > PGSIZE)
  80a486:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80a48d:	7f 40                	jg     80a4cf <sys_thread_new+0x5d>
    lt->func = thread;
  80a48f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a492:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80a494:	8b 55 10             	mov    0x10(%ebp),%edx
  80a497:	89 50 04             	mov    %edx,0x4(%eax)
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80a49a:	50                   	push   %eax
  80a49b:	68 2a 9d 80 00       	push   $0x809d2a
  80a4a0:	ff 75 08             	pushl  0x8(%ebp)
  80a4a3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80a4a6:	50                   	push   %eax
  80a4a7:	e8 c7 01 00 00       	call   80a673 <thread_create>
    if (r < 0)
  80a4ac:	83 c4 10             	add    $0x10,%esp
  80a4af:	85 c0                	test   %eax,%eax
  80a4b1:	78 33                	js     80a4e6 <sys_thread_new+0x74>
}
  80a4b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80a4b6:	c9                   	leave  
  80a4b7:	c3                   	ret    
	panic("sys_thread_new: cannot allocate thread struct");
  80a4b8:	83 ec 04             	sub    $0x4,%esp
  80a4bb:	68 04 2a 81 00       	push   $0x812a04
  80a4c0:	68 fd 00 00 00       	push   $0xfd
  80a4c5:	68 a0 2a 81 00       	push   $0x812aa0
  80a4ca:	e8 ca 41 00 00       	call   80e699 <_panic>
	panic("large stack %d", stacksize);
  80a4cf:	ff 75 14             	pushl  0x14(%ebp)
  80a4d2:	68 fe 2a 81 00       	push   $0x812afe
  80a4d7:	68 00 01 00 00       	push   $0x100
  80a4dc:	68 a0 2a 81 00       	push   $0x812aa0
  80a4e1:	e8 b3 41 00 00       	call   80e699 <_panic>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80a4e6:	83 ec 0c             	sub    $0xc,%esp
  80a4e9:	50                   	push   %eax
  80a4ea:	e8 ba 04 00 00       	call   80a9a9 <e2s>
  80a4ef:	50                   	push   %eax
  80a4f0:	68 34 2a 81 00       	push   $0x812a34
  80a4f5:	68 09 01 00 00       	push   $0x109
  80a4fa:	68 a0 2a 81 00       	push   $0x812aa0
  80a4ff:	e8 95 41 00 00       	call   80e699 <_panic>

0080a504 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80a504:	55                   	push   %ebp
  80a505:	89 e5                	mov    %esp,%ebp
  80a507:	57                   	push   %edi
  80a508:	56                   	push   %esi
  80a509:	53                   	push   %ebx
  80a50a:	83 ec 0c             	sub    $0xc,%esp
    thread_id_t tid = thread_id();
  80a50d:	e8 ef 00 00 00       	call   80a601 <thread_id>
  80a512:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a514:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a519:	f7 e2                	mul    %edx
  80a51b:	c1 ea 08             	shr    $0x8,%edx
  80a51e:	89 d7                	mov    %edx,%edi
  80a520:	c1 e2 08             	shl    $0x8,%edx
  80a523:	01 d7                	add    %edx,%edi
  80a525:	89 f0                	mov    %esi,%eax
  80a527:	29 f8                	sub    %edi,%eax
  80a529:	89 c7                	mov    %eax,%edi
  80a52b:	8b 1c 85 40 4b b3 00 	mov    0xb34b40(,%eax,4),%ebx
  80a532:	85 db                	test   %ebx,%ebx
  80a534:	74 09                	je     80a53f <sys_arch_timeouts+0x3b>
	if (t->tid == tid)
  80a536:	39 33                	cmp    %esi,(%ebx)
  80a538:	74 66                	je     80a5a0 <sys_arch_timeouts+0x9c>
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a53a:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80a53d:	eb f3                	jmp    80a532 <sys_arch_timeouts+0x2e>
	    goto out;

    t = malloc(sizeof(*t));
  80a53f:	83 ec 0c             	sub    $0xc,%esp
  80a542:	6a 10                	push   $0x10
  80a544:	e8 8e 63 00 00       	call   8108d7 <malloc>
  80a549:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80a54b:	83 c4 10             	add    $0x10,%esp
  80a54e:	85 c0                	test   %eax,%eax
  80a550:	74 59                	je     80a5ab <sys_arch_timeouts+0xa7>
	panic("sys_arch_timeouts: cannot malloc");

    int r = thread_onhalt(timeout_cleanup);
  80a552:	83 ec 0c             	sub    $0xc,%esp
  80a555:	68 49 9d 80 00       	push   $0x809d49
  80a55a:	e8 ea 00 00 00       	call   80a649 <thread_onhalt>
    if (r < 0)
  80a55f:	83 c4 10             	add    $0x10,%esp
  80a562:	85 c0                	test   %eax,%eax
  80a564:	78 5c                	js     80a5c2 <sys_arch_timeouts+0xbe>
	panic("thread_onhalt failed: %s", e2s(r));

    t->tid = tid;
  80a566:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80a568:	83 ec 04             	sub    $0x4,%esp
  80a56b:	6a 04                	push   $0x4
  80a56d:	6a 00                	push   $0x0
  80a56f:	8d 43 04             	lea    0x4(%ebx),%eax
  80a572:	50                   	push   %eax
  80a573:	e8 bc 4a 00 00       	call   80f034 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80a578:	8b 04 bd 40 4b b3 00 	mov    0xb34b40(,%edi,4),%eax
  80a57f:	89 43 08             	mov    %eax,0x8(%ebx)
  80a582:	83 c4 10             	add    $0x10,%esp
  80a585:	85 c0                	test   %eax,%eax
  80a587:	74 06                	je     80a58f <sys_arch_timeouts+0x8b>
  80a589:	8d 53 08             	lea    0x8(%ebx),%edx
  80a58c:	89 50 0c             	mov    %edx,0xc(%eax)
  80a58f:	89 1c bd 40 4b b3 00 	mov    %ebx,0xb34b40(,%edi,4)
  80a596:	8d 04 bd 40 4b b3 00 	lea    0xb34b40(,%edi,4),%eax
  80a59d:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80a5a0:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80a5a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a5a6:	5b                   	pop    %ebx
  80a5a7:	5e                   	pop    %esi
  80a5a8:	5f                   	pop    %edi
  80a5a9:	5d                   	pop    %ebp
  80a5aa:	c3                   	ret    
	panic("sys_arch_timeouts: cannot malloc");
  80a5ab:	83 ec 04             	sub    $0x4,%esp
  80a5ae:	68 60 2a 81 00       	push   $0x812a60
  80a5b3:	68 2c 01 00 00       	push   $0x12c
  80a5b8:	68 a0 2a 81 00       	push   $0x812aa0
  80a5bd:	e8 d7 40 00 00       	call   80e699 <_panic>
	panic("thread_onhalt failed: %s", e2s(r));
  80a5c2:	83 ec 0c             	sub    $0xc,%esp
  80a5c5:	50                   	push   %eax
  80a5c6:	e8 de 03 00 00       	call   80a9a9 <e2s>
  80a5cb:	50                   	push   %eax
  80a5cc:	68 0d 2b 81 00       	push   $0x812b0d
  80a5d1:	68 30 01 00 00       	push   $0x130
  80a5d6:	68 a0 2a 81 00       	push   $0x812aa0
  80a5db:	e8 b9 40 00 00       	call   80e699 <_panic>

0080a5e0 <lwip_core_lock>:

void
lwip_core_lock(void)
{
}
  80a5e0:	c3                   	ret    

0080a5e1 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
}
  80a5e1:	c3                   	ret    

0080a5e2 <thread_init>:
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80a5e2:	c7 05 88 b1 b3 00 00 	movl   $0x0,0xb3b188
  80a5e9:	00 00 00 
    tq->tq_last = 0;
  80a5ec:	c7 05 8c b1 b3 00 00 	movl   $0x0,0xb3b18c
  80a5f3:	00 00 00 
static struct thread_queue kill_queue;

void
thread_init(void) {
    threadq_init(&thread_queue);
    max_tid = 0;
  80a5f6:	c7 05 94 b1 b3 00 00 	movl   $0x0,0xb3b194
  80a5fd:	00 00 00 
}
  80a600:	c3                   	ret    

0080a601 <thread_id>:

uint32_t
thread_id(void) {
    return cur_tc->tc_tid;
  80a601:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a606:	8b 00                	mov    (%eax),%eax
}
  80a608:	c3                   	ret    

0080a609 <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80a609:	55                   	push   %ebp
  80a60a:	89 e5                	mov    %esp,%ebp
  80a60c:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80a60f:	a1 88 b1 b3 00       	mov    0xb3b188,%eax
    while (tc) {
  80a614:	eb 07                	jmp    80a61d <thread_wakeup+0x14>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
  80a616:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80a61a:	8b 40 64             	mov    0x64(%eax),%eax
    while (tc) {
  80a61d:	85 c0                	test   %eax,%eax
  80a61f:	74 07                	je     80a628 <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80a621:	39 50 48             	cmp    %edx,0x48(%eax)
  80a624:	75 f4                	jne    80a61a <thread_wakeup+0x11>
  80a626:	eb ee                	jmp    80a616 <thread_wakeup+0xd>
    }
}
  80a628:	5d                   	pop    %ebp
  80a629:	c3                   	ret    

0080a62a <thread_wakeups_pending>:
}

int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
  80a62a:	8b 15 88 b1 b3 00    	mov    0xb3b188,%edx
    int n = 0;
  80a630:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80a635:	85 d2                	test   %edx,%edx
  80a637:	74 0f                	je     80a648 <thread_wakeups_pending+0x1e>
	if (tc->tc_wakeup)
  80a639:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80a63d:	80 f9 01             	cmp    $0x1,%cl
  80a640:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80a643:	8b 52 64             	mov    0x64(%edx),%edx
  80a646:	eb ed                	jmp    80a635 <thread_wakeups_pending+0xb>
    }
    return n;
}
  80a648:	c3                   	ret    

0080a649 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80a649:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a64e:	8b 50 60             	mov    0x60(%eax),%edx
  80a651:	83 fa 03             	cmp    $0x3,%edx
  80a654:	7f 17                	jg     80a66d <thread_onhalt+0x24>
thread_onhalt(void (*fun)(thread_id_t)) {
  80a656:	55                   	push   %ebp
  80a657:	89 e5                	mov    %esp,%ebp
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80a659:	8d 4a 01             	lea    0x1(%edx),%ecx
  80a65c:	89 48 60             	mov    %ecx,0x60(%eax)
  80a65f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a662:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80a666:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a66b:	5d                   	pop    %ebp
  80a66c:	c3                   	ret    
	return -E_NO_MEM;
  80a66d:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  80a672:	c3                   	ret    

0080a673 <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80a673:	55                   	push   %ebp
  80a674:	89 e5                	mov    %esp,%ebp
  80a676:	57                   	push   %edi
  80a677:	56                   	push   %esi
  80a678:	53                   	push   %ebx
  80a679:	83 ec 18             	sub    $0x18,%esp
  80a67c:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80a67f:	6a 68                	push   $0x68
  80a681:	e8 51 62 00 00       	call   8108d7 <malloc>
    if (!tc)
  80a686:	83 c4 10             	add    $0x10,%esp
  80a689:	85 c0                	test   %eax,%eax
  80a68b:	0f 84 04 01 00 00    	je     80a795 <thread_create+0x122>
  80a691:	89 c3                	mov    %eax,%ebx
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80a693:	83 ec 04             	sub    $0x4,%esp
  80a696:	6a 68                	push   $0x68
  80a698:	6a 00                	push   $0x0
  80a69a:	50                   	push   %eax
  80a69b:	e8 94 49 00 00       	call   80f034 <memset>
    strncpy(tc->tc_name, name, name_size - 1);
  80a6a0:	83 c4 0c             	add    $0xc,%esp
  80a6a3:	6a 1f                	push   $0x1f
  80a6a5:	ff 75 0c             	pushl  0xc(%ebp)
  80a6a8:	8d 43 08             	lea    0x8(%ebx),%eax
  80a6ab:	50                   	push   %eax
  80a6ac:	e8 82 48 00 00       	call   80ef33 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80a6b1:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    int tid = max_tid++;
  80a6b5:	a1 94 b1 b3 00       	mov    0xb3b194,%eax
  80a6ba:	8d 50 01             	lea    0x1(%eax),%edx
  80a6bd:	89 15 94 b1 b3 00    	mov    %edx,0xb3b194
    if (max_tid == (uint32_t)~0)
  80a6c3:	83 c4 10             	add    $0x10,%esp
  80a6c6:	83 fa ff             	cmp    $0xffffffff,%edx
  80a6c9:	0f 84 91 00 00 00    	je     80a760 <thread_create+0xed>
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80a6cf:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80a6d1:	83 ec 0c             	sub    $0xc,%esp
  80a6d4:	68 00 10 00 00       	push   $0x1000
  80a6d9:	e8 f9 61 00 00       	call   8108d7 <malloc>
  80a6de:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80a6e1:	83 c4 10             	add    $0x10,%esp
  80a6e4:	85 c0                	test   %eax,%eax
  80a6e6:	0f 84 88 00 00 00    	je     80a774 <thread_create+0x101>
	return -E_NO_MEM;
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80a6ec:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80a6f2:	83 ec 04             	sub    $0x4,%esp
  80a6f5:	6a 04                	push   $0x4
  80a6f7:	6a 00                	push   $0x0
  80a6f9:	57                   	push   %edi
  80a6fa:	e8 35 49 00 00       	call   80f034 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80a6ff:	83 c4 0c             	add    $0xc,%esp
  80a702:	6a 18                	push   $0x18
  80a704:	6a 00                	push   $0x0
  80a706:	8d 43 30             	lea    0x30(%ebx),%eax
  80a709:	50                   	push   %eax
  80a70a:	e8 25 49 00 00       	call   80f034 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80a70f:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80a712:	c7 43 30 20 a9 80 00 	movl   $0x80a920,0x30(%ebx)
    tc->tc_entry = entry;
  80a719:	8b 45 10             	mov    0x10(%ebp),%eax
  80a71c:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80a71f:	8b 45 14             	mov    0x14(%ebp),%eax
  80a722:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80a725:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80a72c:	83 c4 10             	add    $0x10,%esp
  80a72f:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a736:	74 4f                	je     80a787 <thread_create+0x114>
	tq->tq_first = tc;
	tq->tq_last = tc;
    } else {
	tq->tq_last->tc_queue_link = tc;
  80a738:	a1 8c b1 b3 00       	mov    0xb3b18c,%eax
  80a73d:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80a740:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80a746:	b8 00 00 00 00       	mov    $0x0,%eax
    if (tid)
  80a74b:	85 f6                	test   %esi,%esi
  80a74d:	74 09                	je     80a758 <thread_create+0xe5>
	*tid = tc->tc_tid;
  80a74f:	8b 03                	mov    (%ebx),%eax
  80a751:	89 06                	mov    %eax,(%esi)
    return 0;
  80a753:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80a758:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80a75b:	5b                   	pop    %ebx
  80a75c:	5e                   	pop    %esi
  80a75d:	5f                   	pop    %edi
  80a75e:	5d                   	pop    %ebp
  80a75f:	c3                   	ret    
	panic("alloc_tid: no more thread ids");
  80a760:	83 ec 04             	sub    $0x4,%esp
  80a763:	68 26 2b 81 00       	push   $0x812b26
  80a768:	6a 54                	push   $0x54
  80a76a:	68 44 2b 81 00       	push   $0x812b44
  80a76f:	e8 25 3f 00 00       	call   80e699 <_panic>
	free(tc);
  80a774:	83 ec 0c             	sub    $0xc,%esp
  80a777:	53                   	push   %ebx
  80a778:	e8 ae 60 00 00       	call   81082b <free>
	return -E_NO_MEM;
  80a77d:	83 c4 10             	add    $0x10,%esp
  80a780:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a785:	eb d1                	jmp    80a758 <thread_create+0xe5>
	tq->tq_first = tc;
  80a787:	89 1d 88 b1 b3 00    	mov    %ebx,0xb3b188
	tq->tq_last = tc;
  80a78d:	89 1d 8c b1 b3 00    	mov    %ebx,0xb3b18c
  80a793:	eb b1                	jmp    80a746 <thread_create+0xd3>
	return -E_NO_MEM;
  80a795:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80a79a:	eb bc                	jmp    80a758 <thread_create+0xe5>

0080a79c <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80a79c:	55                   	push   %ebp
  80a79d:	89 e5                	mov    %esp,%ebp
  80a79f:	53                   	push   %ebx
  80a7a0:	83 ec 04             	sub    $0x4,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80a7a3:	8b 1d 88 b1 b3 00    	mov    0xb3b188,%ebx
  80a7a9:	85 db                	test   %ebx,%ebx
  80a7ab:	74 2b                	je     80a7d8 <thread_yield+0x3c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80a7ad:	8b 43 64             	mov    0x64(%ebx),%eax
  80a7b0:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
    tc->tc_queue_link = 0;
  80a7b5:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80a7bc:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a7c1:	85 c0                	test   %eax,%eax
  80a7c3:	74 3b                	je     80a800 <thread_yield+0x64>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80a7c5:	83 ec 0c             	sub    $0xc,%esp
  80a7c8:	83 c0 30             	add    $0x30,%eax
  80a7cb:	50                   	push   %eax
  80a7cc:	e8 6f 01 00 00       	call   80a940 <jos_setjmp>
  80a7d1:	83 c4 10             	add    $0x10,%esp
  80a7d4:	85 c0                	test   %eax,%eax
  80a7d6:	74 05                	je     80a7dd <thread_yield+0x41>
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  80a7d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80a7db:	c9                   	leave  
  80a7dc:	c3                   	ret    
	threadq_push(&thread_queue, cur_tc);
  80a7dd:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a7e2:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a7e9:	83 3d 88 b1 b3 00 00 	cmpl   $0x0,0xb3b188
  80a7f0:	74 21                	je     80a813 <thread_yield+0x77>
	tq->tq_last->tc_queue_link = tc;
  80a7f2:	8b 15 8c b1 b3 00    	mov    0xb3b18c,%edx
  80a7f8:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a7fb:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
    cur_tc = next_tc;
  80a800:	89 1d 90 b1 b3 00    	mov    %ebx,0xb3b190
    jos_longjmp(&cur_tc->tc_jb, 1);
  80a806:	8d 43 30             	lea    0x30(%ebx),%eax
  80a809:	ba 01 00 00 00       	mov    $0x1,%edx
  80a80e:	e8 5d 01 00 00       	call   80a970 <jos_longjmp>
	tq->tq_first = tc;
  80a813:	a3 88 b1 b3 00       	mov    %eax,0xb3b188
	tq->tq_last = tc;
  80a818:	a3 8c b1 b3 00       	mov    %eax,0xb3b18c
  80a81d:	eb e1                	jmp    80a800 <thread_yield+0x64>

0080a81f <thread_wait>:
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80a81f:	55                   	push   %ebp
  80a820:	89 e5                	mov    %esp,%ebp
  80a822:	57                   	push   %edi
  80a823:	56                   	push   %esi
  80a824:	53                   	push   %ebx
  80a825:	83 ec 0c             	sub    $0xc,%esp
  80a828:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a82b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80a82e:	e8 df 4c 00 00       	call   80f512 <sys_time_msec>
  80a833:	89 c6                	mov    %eax,%esi
    cur_tc->tc_wait_addr = addr;
  80a835:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a83a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a83d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
    uint32_t p = s;
  80a841:	89 f0                	mov    %esi,%eax
    while (p < msec) {
  80a843:	eb 17                	jmp    80a85c <thread_wait+0x3d>
	if (cur_tc->tc_wakeup)
  80a845:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a84a:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80a84e:	84 c0                	test   %al,%al
  80a850:	75 1d                	jne    80a86f <thread_wait+0x50>
	thread_yield();
  80a852:	e8 45 ff ff ff       	call   80a79c <thread_yield>
	p = sys_time_msec();
  80a857:	e8 b6 4c 00 00       	call   80f512 <sys_time_msec>
	if (p < s)
  80a85c:	39 f0                	cmp    %esi,%eax
  80a85e:	72 0f                	jb     80a86f <thread_wait+0x50>
  80a860:	39 f8                	cmp    %edi,%eax
  80a862:	73 0b                	jae    80a86f <thread_wait+0x50>
	if (addr && *addr != val)
  80a864:	85 db                	test   %ebx,%ebx
  80a866:	74 dd                	je     80a845 <thread_wait+0x26>
  80a868:	8b 03                	mov    (%ebx),%eax
  80a86a:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80a86d:	74 d6                	je     80a845 <thread_wait+0x26>
    cur_tc->tc_wait_addr = 0;
  80a86f:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a874:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80a87b:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80a87f:	83 c4 0c             	add    $0xc,%esp
  80a882:	5b                   	pop    %ebx
  80a883:	5e                   	pop    %esi
  80a884:	5f                   	pop    %edi
  80a885:	5d                   	pop    %ebp
  80a886:	c3                   	ret    

0080a887 <thread_halt>:
thread_halt() {
  80a887:	55                   	push   %ebp
  80a888:	89 e5                	mov    %esp,%ebp
  80a88a:	56                   	push   %esi
  80a88b:	53                   	push   %ebx
    if (!tq->tq_first)
  80a88c:	8b 1d 80 b1 b3 00    	mov    0xb3b180,%ebx
  80a892:	85 db                	test   %ebx,%ebx
  80a894:	74 40                	je     80a8d6 <thread_halt+0x4f>
    tq->tq_first = tc->tc_queue_link;
  80a896:	8b 43 64             	mov    0x64(%ebx),%eax
  80a899:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
    tc->tc_queue_link = 0;
  80a89e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a8a5:	be 00 00 00 00       	mov    $0x0,%esi
  80a8aa:	eb 0f                	jmp    80a8bb <thread_halt+0x34>
	tc->tc_onhalt[i](tc->tc_tid);
  80a8ac:	83 ec 0c             	sub    $0xc,%esp
  80a8af:	ff 33                	pushl  (%ebx)
  80a8b1:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
    for (i = 0; i < tc->tc_nonhalt; i++)
  80a8b5:	83 c6 01             	add    $0x1,%esi
  80a8b8:	83 c4 10             	add    $0x10,%esp
  80a8bb:	3b 73 60             	cmp    0x60(%ebx),%esi
  80a8be:	7c ec                	jl     80a8ac <thread_halt+0x25>
    free(tc->tc_stack_bottom);
  80a8c0:	83 ec 0c             	sub    $0xc,%esp
  80a8c3:	ff 73 04             	pushl  0x4(%ebx)
  80a8c6:	e8 60 5f 00 00       	call   81082b <free>
    free(tc);
  80a8cb:	89 1c 24             	mov    %ebx,(%esp)
  80a8ce:	e8 58 5f 00 00       	call   81082b <free>
  80a8d3:	83 c4 10             	add    $0x10,%esp
    threadq_push(&kill_queue, cur_tc);
  80a8d6:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
    tc->tc_queue_link = 0;
  80a8db:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80a8e2:	83 3d 80 b1 b3 00 00 	cmpl   $0x0,0xb3b180
  80a8e9:	74 29                	je     80a914 <thread_halt+0x8d>
	tq->tq_last->tc_queue_link = tc;
  80a8eb:	8b 15 84 b1 b3 00    	mov    0xb3b184,%edx
  80a8f1:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80a8f4:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
    cur_tc = NULL;
  80a8f9:	c7 05 90 b1 b3 00 00 	movl   $0x0,0xb3b190
  80a900:	00 00 00 
    thread_yield();
  80a903:	e8 94 fe ff ff       	call   80a79c <thread_yield>
    exit();
  80a908:	e8 58 3d 00 00       	call   80e665 <exit>
}
  80a90d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80a910:	5b                   	pop    %ebx
  80a911:	5e                   	pop    %esi
  80a912:	5d                   	pop    %ebp
  80a913:	c3                   	ret    
	tq->tq_first = tc;
  80a914:	a3 80 b1 b3 00       	mov    %eax,0xb3b180
	tq->tq_last = tc;
  80a919:	a3 84 b1 b3 00       	mov    %eax,0xb3b184
  80a91e:	eb d9                	jmp    80a8f9 <thread_halt+0x72>

0080a920 <thread_entry>:
thread_entry(void) {
  80a920:	55                   	push   %ebp
  80a921:	89 e5                	mov    %esp,%ebp
  80a923:	83 ec 14             	sub    $0x14,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80a926:	a1 90 b1 b3 00       	mov    0xb3b190,%eax
  80a92b:	ff 70 2c             	pushl  0x2c(%eax)
  80a92e:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80a931:	e8 51 ff ff ff       	call   80a887 <thread_halt>
}
  80a936:	83 c4 10             	add    $0x10,%esp
  80a939:	c9                   	leave  
  80a93a:	c3                   	ret    
  80a93b:	66 90                	xchg   %ax,%ax
  80a93d:	66 90                	xchg   %ax,%ax
  80a93f:	90                   	nop

0080a940 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80a940:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80a944:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80a947:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80a949:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80a94d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80a950:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80a953:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80a956:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80a959:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80a95c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80a961:	c3                   	ret    
  80a962:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80a969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0080a970 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80a970:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80a972:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80a975:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80a978:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80a97b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80a97e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80a981:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80a983:	ff e1                	jmp    *%ecx

0080a985 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80a985:	55                   	push   %ebp
  80a986:	89 e5                	mov    %esp,%ebp
  80a988:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80a98b:	a1 e0 b1 b3 00       	mov    0xb3b1e0,%eax
	cprintf("%s: %s\n", s, e2s(err));
  80a990:	ff 34 85 20 40 81 00 	pushl  0x814020(,%eax,4)
  80a997:	ff 75 08             	pushl  0x8(%ebp)
  80a99a:	68 5f 2b 81 00       	push   $0x812b5f
  80a99f:	e8 eb 3d 00 00       	call   80e78f <cprintf>
}
  80a9a4:	83 c4 10             	add    $0x10,%esp
  80a9a7:	c9                   	leave  
  80a9a8:	c3                   	ret    

0080a9a9 <e2s>:
e2s(int err) {
  80a9a9:	55                   	push   %ebp
  80a9aa:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80a9ac:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9af:	8b 04 85 20 40 81 00 	mov    0x814020(,%eax,4),%eax
}
  80a9b6:	5d                   	pop    %ebp
  80a9b7:	c3                   	ret    

0080a9b8 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80a9b8:	55                   	push   %ebp
  80a9b9:	89 e5                	mov    %esp,%ebp
  80a9bb:	57                   	push   %edi
  80a9bc:	56                   	push   %esi
  80a9bd:	53                   	push   %ebx
  80a9be:	83 ec 20             	sub    $0x20,%esp
  80a9c1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80a9c4:	6a 07                	push   $0x7
  80a9c6:	68 00 00 00 10       	push   $0x10000000
  80a9cb:	6a 00                	push   $0x0
  80a9cd:	e8 0e 49 00 00       	call   80f2e0 <sys_page_alloc>
    if (r < 0)
  80a9d2:	83 c4 10             	add    $0x10,%esp
  80a9d5:	85 c0                	test   %eax,%eax
  80a9d7:	78 49                	js     80aa22 <low_level_output+0x6a>
	panic("jif: could not allocate page of memory");
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80a9d9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9dc:	8b 40 1c             	mov    0x1c(%eax),%eax
  80a9df:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80a9e2:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80a9e7:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80a9ec:	85 db                	test   %ebx,%ebx
  80a9ee:	74 5c                	je     80aa4c <low_level_output+0x94>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80a9f0:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a9f4:	0f b7 d0             	movzwl %ax,%edx
  80a9f7:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80a9fa:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80aa00:	7f 34                	jg     80aa36 <low_level_output+0x7e>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
  80aa02:	83 ec 04             	sub    $0x4,%esp
  80aa05:	0f b7 c0             	movzwl %ax,%eax
  80aa08:	50                   	push   %eax
  80aa09:	ff 73 04             	pushl  0x4(%ebx)
  80aa0c:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80aa0f:	50                   	push   %eax
  80aa10:	e8 c9 46 00 00       	call   80f0de <memcpy>
	txsize += q->len;
  80aa15:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80aa19:	01 c6                	add    %eax,%esi
    for (q = p; q != NULL; q = q->next) {
  80aa1b:	8b 1b                	mov    (%ebx),%ebx
  80aa1d:	83 c4 10             	add    $0x10,%esp
  80aa20:	eb ca                	jmp    80a9ec <low_level_output+0x34>
	panic("jif: could not allocate page of memory");
  80aa22:	83 ec 04             	sub    $0x4,%esp
  80aa25:	68 44 30 81 00       	push   $0x813044
  80aa2a:	6a 55                	push   $0x55
  80aa2c:	68 95 30 81 00       	push   $0x813095
  80aa31:	e8 63 3c 00 00       	call   80e699 <_panic>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80aa36:	83 ec 0c             	sub    $0xc,%esp
  80aa39:	56                   	push   %esi
  80aa3a:	52                   	push   %edx
  80aa3b:	68 6c 30 81 00       	push   $0x81306c
  80aa40:	6a 64                	push   $0x64
  80aa42:	68 95 30 81 00       	push   $0x813095
  80aa47:	e8 4d 3c 00 00       	call   80e699 <_panic>
    }

    pkt->jp_len = txsize;
  80aa4c:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80aa52:	6a 07                	push   $0x7
  80aa54:	68 00 00 00 10       	push   $0x10000000
  80aa59:	6a 0b                	push   $0xb
  80aa5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aa5e:	ff 70 04             	pushl  0x4(%eax)
  80aa61:	e8 9f 50 00 00       	call   80fb05 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80aa66:	83 c4 08             	add    $0x8,%esp
  80aa69:	68 00 00 00 10       	push   $0x10000000
  80aa6e:	6a 00                	push   $0x0
  80aa70:	e8 f0 48 00 00       	call   80f365 <sys_page_unmap>

    return ERR_OK;
}
  80aa75:	b8 00 00 00 00       	mov    $0x0,%eax
  80aa7a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80aa7d:	5b                   	pop    %ebx
  80aa7e:	5e                   	pop    %esi
  80aa7f:	5f                   	pop    %edi
  80aa80:	5d                   	pop    %ebp
  80aa81:	c3                   	ret    

0080aa82 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80aa82:	55                   	push   %ebp
  80aa83:	89 e5                	mov    %esp,%ebp
  80aa85:	83 ec 0c             	sub    $0xc,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80aa88:	ff 75 10             	pushl  0x10(%ebp)
  80aa8b:	ff 75 0c             	pushl  0xc(%ebp)
  80aa8e:	ff 75 08             	pushl  0x8(%ebp)
  80aa91:	e8 0b f1 ff ff       	call   809ba1 <etharp_output>
}
  80aa96:	c9                   	leave  
  80aa97:	c3                   	ret    

0080aa98 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80aa98:	55                   	push   %ebp
  80aa99:	89 e5                	mov    %esp,%ebp
  80aa9b:	57                   	push   %edi
  80aa9c:	56                   	push   %esi
  80aa9d:	53                   	push   %ebx
  80aa9e:	83 ec 20             	sub    $0x20,%esp
  80aaa1:	8b 75 0c             	mov    0xc(%ebp),%esi
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80aaa4:	8b 45 08             	mov    0x8(%ebp),%eax
  80aaa7:	8b 40 1c             	mov    0x1c(%eax),%eax
  80aaaa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    s16_t len = pkt->jp_len;
  80aaad:	8b 06                	mov    (%esi),%eax
  80aaaf:	89 c3                	mov    %eax,%ebx
    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80aab1:	6a 03                	push   $0x3
  80aab3:	0f b7 c0             	movzwl %ax,%eax
  80aab6:	50                   	push   %eax
  80aab7:	6a 03                	push   $0x3
  80aab9:	e8 92 9e ff ff       	call   804950 <pbuf_alloc>
    if (p == 0)
  80aabe:	83 c4 10             	add    $0x10,%esp
  80aac1:	85 c0                	test   %eax,%eax
  80aac3:	0f 84 9c 00 00 00    	je     80ab65 <jif_input+0xcd>
  80aac9:	89 c7                	mov    %eax,%edi
    void *rxbuf = (void *) pkt->jp_data;
  80aacb:	8d 46 04             	lea    0x4(%esi),%eax
  80aace:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for (q = p; q != NULL; q = q->next) {
  80aad1:	89 fe                	mov    %edi,%esi
    int copied = 0;
  80aad3:	ba 00 00 00 00       	mov    $0x0,%edx
	if (bytes > (len - copied))
  80aad8:	0f bf c3             	movswl %bx,%eax
  80aadb:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80aade:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80aae1:	89 d7                	mov    %edx,%edi
	int bytes = q->len;
  80aae3:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
	if (bytes > (len - copied))
  80aae7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80aaea:	29 fb                	sub    %edi,%ebx
  80aaec:	39 c3                	cmp    %eax,%ebx
  80aaee:	0f 4f d8             	cmovg  %eax,%ebx
	memcpy(q->payload, rxbuf + copied, bytes);
  80aaf1:	83 ec 04             	sub    $0x4,%esp
  80aaf4:	53                   	push   %ebx
  80aaf5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80aaf8:	01 f8                	add    %edi,%eax
  80aafa:	50                   	push   %eax
  80aafb:	ff 76 04             	pushl  0x4(%esi)
  80aafe:	e8 db 45 00 00       	call   80f0de <memcpy>
	copied += bytes;
  80ab03:	01 df                	add    %ebx,%edi
    for (q = p; q != NULL; q = q->next) {
  80ab05:	8b 36                	mov    (%esi),%esi
  80ab07:	83 c4 10             	add    $0x10,%esp
  80ab0a:	85 f6                	test   %esi,%esi
  80ab0c:	75 d5                	jne    80aae3 <jif_input+0x4b>
  80ab0e:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80ab11:	83 ec 0c             	sub    $0xc,%esp
  80ab14:	8b 47 04             	mov    0x4(%edi),%eax
  80ab17:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ab1b:	50                   	push   %eax
  80ab1c:	e8 43 cc ff ff       	call   807764 <htons>
  80ab21:	83 c4 10             	add    $0x10,%esp
  80ab24:	66 3d 00 08          	cmp    $0x800,%ax
  80ab28:	74 14                	je     80ab3e <jif_input+0xa6>
  80ab2a:	66 3d 06 08          	cmp    $0x806,%ax
  80ab2e:	74 3d                	je     80ab6d <jif_input+0xd5>
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
	break;

    default:
	pbuf_free(p);
  80ab30:	83 ec 0c             	sub    $0xc,%esp
  80ab33:	57                   	push   %edi
  80ab34:	e8 51 9d ff ff       	call   80488a <pbuf_free>
  80ab39:	83 c4 10             	add    $0x10,%esp
  80ab3c:	eb 27                	jmp    80ab65 <jif_input+0xcd>
	etharp_ip_input(netif, p);
  80ab3e:	83 ec 08             	sub    $0x8,%esp
  80ab41:	57                   	push   %edi
  80ab42:	ff 75 08             	pushl  0x8(%ebp)
  80ab45:	e8 cf ea ff ff       	call   809619 <etharp_ip_input>
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80ab4a:	83 c4 08             	add    $0x8,%esp
  80ab4d:	6a f2                	push   $0xfffffff2
  80ab4f:	57                   	push   %edi
  80ab50:	e8 68 9c ff ff       	call   8047bd <pbuf_header>
	netif->input(p, netif);
  80ab55:	83 c4 08             	add    $0x8,%esp
  80ab58:	ff 75 08             	pushl  0x8(%ebp)
  80ab5b:	57                   	push   %edi
  80ab5c:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab5f:	ff 50 10             	call   *0x10(%eax)
	break;
  80ab62:	83 c4 10             	add    $0x10,%esp
    }
}
  80ab65:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ab68:	5b                   	pop    %ebx
  80ab69:	5e                   	pop    %esi
  80ab6a:	5f                   	pop    %edi
  80ab6b:	5d                   	pop    %ebp
  80ab6c:	c3                   	ret    
	etharp_arp_input(netif, jif->ethaddr, p);
  80ab6d:	83 ec 04             	sub    $0x4,%esp
  80ab70:	57                   	push   %edi
  80ab71:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ab74:	ff 30                	pushl  (%eax)
  80ab76:	ff 75 08             	pushl  0x8(%ebp)
  80ab79:	e8 e7 ea ff ff       	call   809665 <etharp_arp_input>
	break;
  80ab7e:	83 c4 10             	add    $0x10,%esp
  80ab81:	eb e2                	jmp    80ab65 <jif_input+0xcd>

0080ab83 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80ab83:	55                   	push   %ebp
  80ab84:	89 e5                	mov    %esp,%ebp
  80ab86:	57                   	push   %edi
  80ab87:	56                   	push   %esi
  80ab88:	53                   	push   %ebx
  80ab89:	83 ec 28             	sub    $0x28,%esp
  80ab8c:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80ab8f:	6a 08                	push   $0x8
  80ab91:	e8 fd 96 ff ff       	call   804293 <mem_malloc>

    if (jif == NULL) {
  80ab96:	83 c4 10             	add    $0x10,%esp
  80ab99:	85 c0                	test   %eax,%eax
  80ab9b:	0f 84 87 00 00 00    	je     80ac28 <jif_init+0xa5>
  80aba1:	89 c6                	mov    %eax,%esi
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80aba3:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80aba6:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80aba9:	c7 43 14 82 aa 80 00 	movl   $0x80aa82,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80abb0:	c7 43 18 b8 a9 80 00 	movl   $0x80a9b8,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80abb7:	83 ec 04             	sub    $0x4,%esp
  80abba:	6a 02                	push   $0x2
  80abbc:	68 b0 3e 81 00       	push   $0x813eb0
  80abc1:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80abc4:	50                   	push   %eax
  80abc5:	e8 14 45 00 00       	call   80f0de <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80abca:	8d 43 25             	lea    0x25(%ebx),%eax
  80abcd:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80abcf:	8b 07                	mov    (%edi),%eax
  80abd1:	89 46 04             	mov    %eax,0x4(%esi)
    netif->hwaddr_len = 6;
  80abd4:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80abd8:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80abde:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[0] = 0x52;
  80abe2:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80abe6:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80abea:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80abee:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80abf2:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80abf6:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80abfa:	c7 04 24 6b 14 81 00 	movl   $0x81146b,(%esp)
  80ac01:	e8 6d cd ff ff       	call   807973 <inet_addr>
  80ac06:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ac09:	83 c4 0c             	add    $0xc,%esp
  80ac0c:	6a 00                	push   $0x0
  80ac0e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac11:	50                   	push   %eax
  80ac12:	53                   	push   %ebx
  80ac13:	e8 53 ed ff ff       	call   80996b <etharp_query>

    return ERR_OK;
  80ac18:	83 c4 10             	add    $0x10,%esp
  80ac1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ac20:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ac23:	5b                   	pop    %ebx
  80ac24:	5e                   	pop    %esi
  80ac25:	5f                   	pop    %edi
  80ac26:	5d                   	pop    %ebp
  80ac27:	c3                   	ret    
	return ERR_MEM;
  80ac28:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ac2d:	eb f1                	jmp    80ac20 <jif_init+0x9d>

0080ac2f <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ac2f:	55                   	push   %ebp
  80ac30:	89 e5                	mov    %esp,%ebp
  80ac32:	56                   	push   %esi
  80ac33:	53                   	push   %ebx
  80ac34:	83 ec 28             	sub    $0x28,%esp
  80ac37:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ac3a:	ff 75 10             	pushl  0x10(%ebp)
  80ac3d:	ff 75 08             	pushl  0x8(%ebp)
  80ac40:	e8 47 0f 00 00       	call   80bb8c <netconn_alloc>
  80ac45:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ac47:	83 c4 10             	add    $0x10,%esp
  80ac4a:	85 c0                	test   %eax,%eax
  80ac4c:	74 63                	je     80acb1 <netconn_new_with_proto_and_callback+0x82>
    msg.function = do_newconn;
  80ac4e:	c7 45 e4 83 ba 80 00 	movl   $0x80ba83,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ac55:	89 f0                	mov    %esi,%eax
  80ac57:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ac5a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ac5d:	83 ec 0c             	sub    $0xc,%esp
  80ac60:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ac63:	50                   	push   %eax
  80ac64:	e8 98 77 ff ff       	call   802401 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ac69:	83 c4 10             	add    $0x10,%esp
  80ac6c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ac70:	74 3f                	je     80acb1 <netconn_new_with_proto_and_callback+0x82>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ac72:	8b 73 08             	mov    0x8(%ebx),%esi
  80ac75:	85 f6                	test   %esi,%esi
  80ac77:	75 41                	jne    80acba <netconn_new_with_proto_and_callback+0x8b>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ac79:	8b 43 10             	mov    0x10(%ebx),%eax
  80ac7c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ac7f:	74 4d                	je     80acce <netconn_new_with_proto_and_callback+0x9f>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ac81:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ac85:	74 5b                	je     80ace2 <netconn_new_with_proto_and_callback+0xb3>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ac87:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ac8b:	75 69                	jne    80acf6 <netconn_new_with_proto_and_callback+0xc7>
      sys_sem_free(conn->op_completed);
  80ac8d:	83 ec 0c             	sub    $0xc,%esp
  80ac90:	50                   	push   %eax
  80ac91:	e8 28 f2 ff ff       	call   809ebe <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ac96:	83 c4 04             	add    $0x4,%esp
  80ac99:	ff 73 14             	pushl  0x14(%ebx)
  80ac9c:	e8 a6 f2 ff ff       	call   809f47 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80aca1:	83 c4 08             	add    $0x8,%esp
  80aca4:	53                   	push   %ebx
  80aca5:	6a 07                	push   $0x7
  80aca7:	e8 91 98 ff ff       	call   80453d <memp_free>
      return NULL;
  80acac:	83 c4 10             	add    $0x10,%esp
  80acaf:	89 f3                	mov    %esi,%ebx
    }
  }
  return conn;
}
  80acb1:	89 d8                	mov    %ebx,%eax
  80acb3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80acb6:	5b                   	pop    %ebx
  80acb7:	5e                   	pop    %esi
  80acb8:	5d                   	pop    %ebp
  80acb9:	c3                   	ret    
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80acba:	83 ec 04             	sub    $0x4,%esp
  80acbd:	68 ac 30 81 00       	push   $0x8130ac
  80acc2:	6a 52                	push   $0x52
  80acc4:	68 5e 31 81 00       	push   $0x81315e
  80acc9:	e8 cb 39 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80acce:	83 ec 04             	sub    $0x4,%esp
  80acd1:	68 75 31 81 00       	push   $0x813175
  80acd6:	6a 53                	push   $0x53
  80acd8:	68 5e 31 81 00       	push   $0x81315e
  80acdd:	e8 b7 39 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ace2:	83 ec 04             	sub    $0x4,%esp
  80ace5:	68 8e 31 81 00       	push   $0x81318e
  80acea:	6a 54                	push   $0x54
  80acec:	68 5e 31 81 00       	push   $0x81315e
  80acf1:	e8 a3 39 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80acf6:	83 ec 04             	sub    $0x4,%esp
  80acf9:	68 d0 30 81 00       	push   $0x8130d0
  80acfe:	6a 55                	push   $0x55
  80ad00:	68 5e 31 81 00       	push   $0x81315e
  80ad05:	e8 8f 39 00 00       	call   80e699 <_panic>

0080ad0a <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80ad0a:	55                   	push   %ebp
  80ad0b:	89 e5                	mov    %esp,%ebp
  80ad0d:	53                   	push   %ebx
  80ad0e:	83 ec 24             	sub    $0x24,%esp
  80ad11:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80ad14:	85 db                	test   %ebx,%ebx
  80ad16:	74 28                	je     80ad40 <netconn_delete+0x36>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80ad18:	c7 45 e4 cb bd 80 00 	movl   $0x80bdcb,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad1f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ad22:	83 ec 0c             	sub    $0xc,%esp
  80ad25:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ad28:	50                   	push   %eax
  80ad29:	e8 d3 76 ff ff       	call   802401 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ad2e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ad35:	89 1c 24             	mov    %ebx,(%esp)
  80ad38:	e8 fd 0e 00 00       	call   80bc3a <netconn_free>

  return ERR_OK;
  80ad3d:	83 c4 10             	add    $0x10,%esp
}
  80ad40:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad45:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ad48:	c9                   	leave  
  80ad49:	c3                   	ret    

0080ad4a <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80ad4a:	55                   	push   %ebp
  80ad4b:	89 e5                	mov    %esp,%ebp
  80ad4d:	83 ec 08             	sub    $0x8,%esp
  80ad50:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ad53:	85 c0                	test   %eax,%eax
  80ad55:	74 04                	je     80ad5b <netconn_type+0x11>
  80ad57:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80ad59:	c9                   	leave  
  80ad5a:	c3                   	ret    
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80ad5b:	83 ec 04             	sub    $0x4,%esp
  80ad5e:	68 a3 31 81 00       	push   $0x8131a3
  80ad63:	68 84 00 00 00       	push   $0x84
  80ad68:	68 5e 31 81 00       	push   $0x81315e
  80ad6d:	e8 27 39 00 00       	call   80e699 <_panic>

0080ad72 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80ad72:	55                   	push   %ebp
  80ad73:	89 e5                	mov    %esp,%ebp
  80ad75:	53                   	push   %ebx
  80ad76:	83 ec 24             	sub    $0x24,%esp
  80ad79:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ad7c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad7f:	8b 45 10             	mov    0x10(%ebp),%eax
  80ad82:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80ad85:	85 db                	test   %ebx,%ebx
  80ad87:	74 30                	je     80adb9 <netconn_getaddr+0x47>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80ad89:	85 d2                	test   %edx,%edx
  80ad8b:	74 43                	je     80add0 <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ad8d:	85 c0                	test   %eax,%eax
  80ad8f:	74 56                	je     80ade7 <netconn_getaddr+0x75>

  msg.function = do_getaddr;
  80ad91:	c7 45 e4 1a c2 80 00 	movl   $0x80c21a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ad98:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80ad9b:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80ad9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80ada1:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80ada4:	83 ec 0c             	sub    $0xc,%esp
  80ada7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80adaa:	50                   	push   %eax
  80adab:	e8 51 76 ff ff       	call   802401 <tcpip_apimsg>

  return conn->err;
  80adb0:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80adb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80adb7:	c9                   	leave  
  80adb8:	c3                   	ret    
  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80adb9:	83 ec 04             	sub    $0x4,%esp
  80adbc:	68 be 31 81 00       	push   $0x8131be
  80adc1:	68 98 00 00 00       	push   $0x98
  80adc6:	68 5e 31 81 00       	push   $0x81315e
  80adcb:	e8 c9 38 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80add0:	83 ec 04             	sub    $0x4,%esp
  80add3:	68 dc 31 81 00       	push   $0x8131dc
  80add8:	68 99 00 00 00       	push   $0x99
  80addd:	68 5e 31 81 00       	push   $0x81315e
  80ade2:	e8 b2 38 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80ade7:	83 ec 04             	sub    $0x4,%esp
  80adea:	68 fa 31 81 00       	push   $0x8131fa
  80adef:	68 9a 00 00 00       	push   $0x9a
  80adf4:	68 5e 31 81 00       	push   $0x81315e
  80adf9:	e8 9b 38 00 00       	call   80e699 <_panic>

0080adfe <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80adfe:	55                   	push   %ebp
  80adff:	89 e5                	mov    %esp,%ebp
  80ae01:	53                   	push   %ebx
  80ae02:	83 ec 24             	sub    $0x24,%esp
  80ae05:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae08:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae0b:	85 db                	test   %ebx,%ebx
  80ae0d:	74 29                	je     80ae38 <netconn_bind+0x3a>

  msg.function = do_bind;
  80ae0f:	c7 45 e4 74 be 80 00 	movl   $0x80be74,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae16:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ae19:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ae1c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ae1f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80ae23:	83 ec 0c             	sub    $0xc,%esp
  80ae26:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae29:	50                   	push   %eax
  80ae2a:	e8 d2 75 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80ae2f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae36:	c9                   	leave  
  80ae37:	c3                   	ret    
  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae38:	83 ec 04             	sub    $0x4,%esp
  80ae3b:	68 18 32 81 00       	push   $0x813218
  80ae40:	68 b5 00 00 00       	push   $0xb5
  80ae45:	68 5e 31 81 00       	push   $0x81315e
  80ae4a:	e8 4a 38 00 00       	call   80e699 <_panic>

0080ae4f <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80ae4f:	55                   	push   %ebp
  80ae50:	89 e5                	mov    %esp,%ebp
  80ae52:	53                   	push   %ebx
  80ae53:	83 ec 24             	sub    $0x24,%esp
  80ae56:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae59:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae5c:	85 db                	test   %ebx,%ebx
  80ae5e:	74 29                	je     80ae89 <netconn_connect+0x3a>

  msg.function = do_connect;
  80ae60:	c7 45 e4 04 bf 80 00 	movl   $0x80bf04,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ae67:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80ae6a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ae6d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80ae70:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80ae74:	83 ec 0c             	sub    $0xc,%esp
  80ae77:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ae7a:	50                   	push   %eax
  80ae7b:	e8 81 75 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80ae80:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80ae84:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ae87:	c9                   	leave  
  80ae88:	c3                   	ret    
  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80ae89:	83 ec 04             	sub    $0x4,%esp
  80ae8c:	68 33 32 81 00       	push   $0x813233
  80ae91:	68 cc 00 00 00       	push   $0xcc
  80ae96:	68 5e 31 81 00       	push   $0x81315e
  80ae9b:	e8 f9 37 00 00       	call   80e699 <_panic>

0080aea0 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80aea0:	55                   	push   %ebp
  80aea1:	89 e5                	mov    %esp,%ebp
  80aea3:	53                   	push   %ebx
  80aea4:	83 ec 24             	sub    $0x24,%esp
  80aea7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aeaa:	85 db                	test   %ebx,%ebx
  80aeac:	74 1f                	je     80aecd <netconn_disconnect+0x2d>

  msg.function = do_disconnect;
  80aeae:	c7 45 e4 b9 bf 80 00 	movl   $0x80bfb9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aeb5:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80aeb8:	83 ec 0c             	sub    $0xc,%esp
  80aebb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80aebe:	50                   	push   %eax
  80aebf:	e8 3d 75 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80aec4:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80aec8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80aecb:	c9                   	leave  
  80aecc:	c3                   	ret    
  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80aecd:	83 ec 04             	sub    $0x4,%esp
  80aed0:	68 f4 30 81 00       	push   $0x8130f4
  80aed5:	68 e2 00 00 00       	push   $0xe2
  80aeda:	68 5e 31 81 00       	push   $0x81315e
  80aedf:	e8 b5 37 00 00       	call   80e699 <_panic>

0080aee4 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80aee4:	55                   	push   %ebp
  80aee5:	89 e5                	mov    %esp,%ebp
  80aee7:	53                   	push   %ebx
  80aee8:	83 ec 24             	sub    $0x24,%esp
  80aeeb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80aeee:	85 db                	test   %ebx,%ebx
  80aef0:	74 1f                	je     80af11 <netconn_listen_with_backlog+0x2d>

  msg.function = do_listen;
  80aef2:	c7 45 e4 f6 bf 80 00 	movl   $0x80bff6,-0x1c(%ebp)
  msg.msg.conn = conn;
  80aef9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80aefc:	83 ec 0c             	sub    $0xc,%esp
  80aeff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af02:	50                   	push   %eax
  80af03:	e8 f9 74 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80af08:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80af0c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af0f:	c9                   	leave  
  80af10:	c3                   	ret    
  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80af11:	83 ec 04             	sub    $0x4,%esp
  80af14:	68 51 32 81 00       	push   $0x813251
  80af19:	68 fa 00 00 00       	push   $0xfa
  80af1e:	68 5e 31 81 00       	push   $0x81315e
  80af23:	e8 71 37 00 00       	call   80e699 <_panic>

0080af28 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80af28:	55                   	push   %ebp
  80af29:	89 e5                	mov    %esp,%ebp
  80af2b:	53                   	push   %ebx
  80af2c:	83 ec 14             	sub    $0x14,%esp
  80af2f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80af32:	85 db                	test   %ebx,%ebx
  80af34:	74 36                	je     80af6c <netconn_accept+0x44>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80af36:	8b 43 18             	mov    0x18(%ebx),%eax
  80af39:	83 f8 ff             	cmp    $0xffffffff,%eax
  80af3c:	74 45                	je     80af83 <netconn_accept+0x5b>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80af3e:	83 ec 04             	sub    $0x4,%esp
  80af41:	6a 00                	push   $0x0
  80af43:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80af46:	52                   	push   %edx
  80af47:	50                   	push   %eax
  80af48:	e8 22 f4 ff ff       	call   80a36f <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80af4d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80af50:	83 c4 10             	add    $0x10,%esp
  80af53:	85 c0                	test   %eax,%eax
  80af55:	74 0d                	je     80af64 <netconn_accept+0x3c>
  80af57:	83 ec 04             	sub    $0x4,%esp
  80af5a:	6a 00                	push   $0x0
  80af5c:	6a 01                	push   $0x1
  80af5e:	53                   	push   %ebx
  80af5f:	ff d0                	call   *%eax
  80af61:	83 c4 10             	add    $0x10,%esp
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80af64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80af67:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80af6a:	c9                   	leave  
  80af6b:	c3                   	ret    
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80af6c:	83 ec 04             	sub    $0x4,%esp
  80af6f:	68 6e 32 81 00       	push   $0x81326e
  80af74:	68 10 01 00 00       	push   $0x110
  80af79:	68 5e 31 81 00       	push   $0x81315e
  80af7e:	e8 16 37 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80af83:	83 ec 04             	sub    $0x4,%esp
  80af86:	68 18 31 81 00       	push   $0x813118
  80af8b:	68 11 01 00 00       	push   $0x111
  80af90:	68 5e 31 81 00       	push   $0x81315e
  80af95:	e8 ff 36 00 00       	call   80e699 <_panic>

0080af9a <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80af9a:	55                   	push   %ebp
  80af9b:	89 e5                	mov    %esp,%ebp
  80af9d:	53                   	push   %ebx
  80af9e:	83 ec 24             	sub    $0x24,%esp
  80afa1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80afa4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80afab:	85 db                	test   %ebx,%ebx
  80afad:	0f 84 cc 00 00 00    	je     80b07f <netconn_recv+0xe5>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80afb3:	8b 43 14             	mov    0x14(%ebx),%eax
  80afb6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80afb9:	0f 84 d7 00 00 00    	je     80b096 <netconn_recv+0xfc>
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  80afbf:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80afc3:	0f 8c 27 01 00 00    	jl     80b0f0 <netconn_recv+0x156>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80afc9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80afcc:	0f 85 e0 00 00 00    	jne    80b0b2 <netconn_recv+0x118>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80afd2:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80afd6:	0f 84 c5 00 00 00    	je     80b0a1 <netconn_recv+0x107>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
      return NULL;
    }

    buf = memp_malloc(MEMP_NETBUF);
  80afdc:	83 ec 0c             	sub    $0xc,%esp
  80afdf:	6a 06                	push   $0x6
  80afe1:	e8 01 95 ff ff       	call   8044e7 <memp_malloc>
  80afe6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80afe9:	83 c4 10             	add    $0x10,%esp
  80afec:	85 c0                	test   %eax,%eax
  80afee:	0f 84 b8 00 00 00    	je     80b0ac <netconn_recv+0x112>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80aff4:	83 ec 04             	sub    $0x4,%esp
  80aff7:	6a 00                	push   $0x0
  80aff9:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80affc:	50                   	push   %eax
  80affd:	ff 73 14             	pushl  0x14(%ebx)
  80b000:	e8 6a f3 ff ff       	call   80a36f <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80b005:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b008:	83 c4 10             	add    $0x10,%esp
  80b00b:	85 c0                	test   %eax,%eax
  80b00d:	0f 84 e4 00 00 00    	je     80b0f7 <netconn_recv+0x15d>
      len = p->tot_len;
  80b013:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80b017:	66 29 53 20          	sub    %dx,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b01b:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
  80b01e:	85 c9                	test   %ecx,%ecx
  80b020:	74 1a                	je     80b03c <netconn_recv+0xa2>
  80b022:	83 ec 04             	sub    $0x4,%esp
  80b025:	0f b7 d2             	movzwl %dx,%edx
  80b028:	52                   	push   %edx
  80b029:	6a 01                	push   $0x1
  80b02b:	53                   	push   %ebx
  80b02c:	ff d1                	call   *%ecx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80b02e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b031:	83 c4 10             	add    $0x10,%esp
  80b034:	85 c0                	test   %eax,%eax
  80b036:	0f 84 cb 00 00 00    	je     80b107 <netconn_recv+0x16d>
        conn->err = ERR_CLSD;
      }
      return NULL;
    }

    buf->p = p;
  80b03c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b03f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80b041:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b044:	89 42 04             	mov    %eax,0x4(%edx)
    buf->port = 0;
  80b047:	66 c7 42 0c 00 00    	movw   $0x0,0xc(%edx)
    buf->addr = NULL;
  80b04d:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80b054:	c7 45 e4 84 c1 80 00 	movl   $0x80c184,-0x1c(%ebp)
    msg.msg.conn = conn;
  80b05b:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
      msg.msg.msg.r.len = buf->p->tot_len;
  80b05e:	8b 02                	mov    (%edx),%eax
  80b060:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b064:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    } else {
      msg.msg.msg.r.len = 1;
    }
    TCPIP_APIMSG(&msg);
  80b068:	83 ec 0c             	sub    $0xc,%esp
  80b06b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b06e:	50                   	push   %eax
  80b06f:	e8 8d 73 ff ff       	call   802401 <tcpip_apimsg>
  80b074:	83 c4 10             	add    $0x10,%esp
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80b077:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
  80b07a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b07d:	c9                   	leave  
  80b07e:	c3                   	ret    
  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b07f:	83 ec 04             	sub    $0x4,%esp
  80b082:	68 8b 32 81 00       	push   $0x81328b
  80b087:	68 3a 01 00 00       	push   $0x13a
  80b08c:	68 5e 31 81 00       	push   $0x81315e
  80b091:	e8 03 36 00 00       	call   80e699 <_panic>
    conn->err = ERR_CONN;
  80b096:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b09a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b09f:	eb d9                	jmp    80b07a <netconn_recv+0xe0>
      conn->err = ERR_CONN;
  80b0a1:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b0a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0aa:	eb ce                	jmp    80b07a <netconn_recv+0xe0>
      conn->err = ERR_MEM;
  80b0ac:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b0b0:	eb c8                	jmp    80b07a <netconn_recv+0xe0>
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80b0b2:	83 ec 04             	sub    $0x4,%esp
  80b0b5:	6a 00                	push   $0x0
  80b0b7:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80b0ba:	52                   	push   %edx
  80b0bb:	50                   	push   %eax
  80b0bc:	e8 ae f2 ff ff       	call   80a36f <sys_arch_mbox_fetch>
    if (buf!=NULL) {
  80b0c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b0c4:	83 c4 10             	add    $0x10,%esp
  80b0c7:	85 c0                	test   %eax,%eax
  80b0c9:	74 ac                	je     80b077 <netconn_recv+0xdd>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80b0cb:	8b 10                	mov    (%eax),%edx
  80b0cd:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80b0d1:	66 29 53 20          	sub    %dx,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80b0d5:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b0d8:	85 d2                	test   %edx,%edx
  80b0da:	74 9b                	je     80b077 <netconn_recv+0xdd>
  80b0dc:	83 ec 04             	sub    $0x4,%esp
  80b0df:	8b 00                	mov    (%eax),%eax
  80b0e1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b0e5:	50                   	push   %eax
  80b0e6:	6a 01                	push   $0x1
  80b0e8:	53                   	push   %ebx
  80b0e9:	ff d2                	call   *%edx
  80b0eb:	83 c4 10             	add    $0x10,%esp
  80b0ee:	eb 87                	jmp    80b077 <netconn_recv+0xdd>
    return NULL;
  80b0f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b0f5:	eb 83                	jmp    80b07a <netconn_recv+0xe0>
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b0f7:	8b 4b 2c             	mov    0x2c(%ebx),%ecx
      len = 0;
  80b0fa:	ba 00 00 00 00       	mov    $0x0,%edx
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80b0ff:	85 c9                	test   %ecx,%ecx
  80b101:	0f 85 1b ff ff ff    	jne    80b022 <netconn_recv+0x88>
      memp_free(MEMP_NETBUF, buf);
  80b107:	83 ec 08             	sub    $0x8,%esp
  80b10a:	ff 75 e0             	pushl  -0x20(%ebp)
  80b10d:	6a 06                	push   $0x6
  80b10f:	e8 29 94 ff ff       	call   80453d <memp_free>
      if (conn->err == ERR_OK) {
  80b114:	83 c4 10             	add    $0x10,%esp
      return NULL;
  80b117:	b8 00 00 00 00       	mov    $0x0,%eax
      if (conn->err == ERR_OK) {
  80b11c:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b120:	0f 85 54 ff ff ff    	jne    80b07a <netconn_recv+0xe0>
        conn->err = ERR_CLSD;
  80b126:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80b12a:	e9 4b ff ff ff       	jmp    80b07a <netconn_recv+0xe0>

0080b12f <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80b12f:	55                   	push   %ebp
  80b130:	89 e5                	mov    %esp,%ebp
  80b132:	53                   	push   %ebx
  80b133:	83 ec 24             	sub    $0x24,%esp
  80b136:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b139:	85 db                	test   %ebx,%ebx
  80b13b:	74 25                	je     80b162 <netconn_send+0x33>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80b13d:	c7 45 e4 de c0 80 00 	movl   $0x80c0de,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b144:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80b147:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b14a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80b14d:	83 ec 0c             	sub    $0xc,%esp
  80b150:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b153:	50                   	push   %eax
  80b154:	e8 a8 72 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80b159:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b15d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b160:	c9                   	leave  
  80b161:	c3                   	ret    
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b162:	83 ec 04             	sub    $0x4,%esp
  80b165:	68 a6 32 81 00       	push   $0x8132a6
  80b16a:	68 b9 01 00 00       	push   $0x1b9
  80b16f:	68 5e 31 81 00       	push   $0x81315e
  80b174:	e8 20 35 00 00       	call   80e699 <_panic>

0080b179 <netconn_sendto>:
{
  80b179:	55                   	push   %ebp
  80b17a:	89 e5                	mov    %esp,%ebp
  80b17c:	83 ec 08             	sub    $0x8,%esp
  80b17f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b182:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80b185:	85 c0                	test   %eax,%eax
  80b187:	74 1b                	je     80b1a4 <netconn_sendto+0x2b>
    buf->addr = addr;
  80b189:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80b18c:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80b18f:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80b193:	83 ec 08             	sub    $0x8,%esp
  80b196:	50                   	push   %eax
  80b197:	ff 75 08             	pushl  0x8(%ebp)
  80b19a:	e8 90 ff ff ff       	call   80b12f <netconn_send>
  80b19f:	83 c4 10             	add    $0x10,%esp
}
  80b1a2:	c9                   	leave  
  80b1a3:	c3                   	ret    
  return ERR_VAL;
  80b1a4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b1a9:	eb f7                	jmp    80b1a2 <netconn_sendto+0x29>

0080b1ab <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80b1ab:	55                   	push   %ebp
  80b1ac:	89 e5                	mov    %esp,%ebp
  80b1ae:	53                   	push   %ebx
  80b1af:	83 ec 24             	sub    $0x24,%esp
  80b1b2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b1b5:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b1b8:	85 db                	test   %ebx,%ebx
  80b1ba:	74 33                	je     80b1ef <netconn_write+0x44>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b1bc:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b1bf:	75 45                	jne    80b206 <netconn_write+0x5b>

  msg.function = do_write;
  80b1c1:	c7 45 e4 ca c1 80 00 	movl   $0x80c1ca,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b1c8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80b1cb:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b1ce:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80b1d1:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80b1d4:	8b 45 10             	mov    0x10(%ebp),%eax
  80b1d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80b1da:	83 ec 0c             	sub    $0xc,%esp
  80b1dd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b1e0:	50                   	push   %eax
  80b1e1:	e8 1b 72 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80b1e6:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b1ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b1ed:	c9                   	leave  
  80b1ee:	c3                   	ret    
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b1ef:	83 ec 04             	sub    $0x4,%esp
  80b1f2:	68 c1 32 81 00       	push   $0x8132c1
  80b1f7:	68 d3 01 00 00       	push   $0x1d3
  80b1fc:	68 5e 31 81 00       	push   $0x81315e
  80b201:	e8 93 34 00 00       	call   80e699 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80b206:	83 ec 04             	sub    $0x4,%esp
  80b209:	68 3c 31 81 00       	push   $0x81313c
  80b20e:	68 d4 01 00 00       	push   $0x1d4
  80b213:	68 5e 31 81 00       	push   $0x81315e
  80b218:	e8 7c 34 00 00       	call   80e699 <_panic>

0080b21d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80b21d:	55                   	push   %ebp
  80b21e:	89 e5                	mov    %esp,%ebp
  80b220:	53                   	push   %ebx
  80b221:	83 ec 24             	sub    $0x24,%esp
  80b224:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b227:	85 db                	test   %ebx,%ebx
  80b229:	74 1f                	je     80b24a <netconn_close+0x2d>

  msg.function = do_close;
  80b22b:	c7 45 e4 e1 c2 80 00 	movl   $0x80c2e1,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b232:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b235:	83 ec 0c             	sub    $0xc,%esp
  80b238:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b23b:	50                   	push   %eax
  80b23c:	e8 c0 71 ff ff       	call   802401 <tcpip_apimsg>
  return conn->err;
  80b241:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b245:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b248:	c9                   	leave  
  80b249:	c3                   	ret    
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80b24a:	83 ec 04             	sub    $0x4,%esp
  80b24d:	68 dd 32 81 00       	push   $0x8132dd
  80b252:	68 ed 01 00 00       	push   $0x1ed
  80b257:	68 5e 31 81 00       	push   $0x81315e
  80b25c:	e8 38 34 00 00       	call   80e699 <_panic>

0080b261 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80b261:	55                   	push   %ebp
  80b262:	89 e5                	mov    %esp,%ebp
  80b264:	56                   	push   %esi
  80b265:	53                   	push   %ebx
  80b266:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b269:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b26c:	8b 75 10             	mov    0x10(%ebp),%esi
  80b26f:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b272:	85 c0                	test   %eax,%eax
  80b274:	74 5a                	je     80b2d0 <recv_tcp+0x6f>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b276:	85 db                	test   %ebx,%ebx
  80b278:	74 6d                	je     80b2e7 <recv_tcp+0x86>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b27a:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b27d:	75 7f                	jne    80b2fe <recv_tcp+0x9d>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b27f:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b283:	0f 84 8c 00 00 00    	je     80b315 <recv_tcp+0xb4>
    return ERR_VAL;
  }

  conn->err = err;
  80b289:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  80b28c:	b8 00 00 00 00       	mov    $0x0,%eax
  if (p != NULL) {
  80b291:	85 f6                	test   %esi,%esi
  80b293:	74 08                	je     80b29d <recv_tcp+0x3c>
    len = p->tot_len;
  80b295:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80b299:	66 01 43 20          	add    %ax,0x20(%ebx)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80b29d:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80b2a0:	85 d2                	test   %edx,%edx
  80b2a2:	74 0f                	je     80b2b3 <recv_tcp+0x52>
  80b2a4:	83 ec 04             	sub    $0x4,%esp
  80b2a7:	0f b7 c0             	movzwl %ax,%eax
  80b2aa:	50                   	push   %eax
  80b2ab:	6a 00                	push   $0x0
  80b2ad:	53                   	push   %ebx
  80b2ae:	ff d2                	call   *%edx
  80b2b0:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80b2b3:	83 ec 08             	sub    $0x8,%esp
  80b2b6:	56                   	push   %esi
  80b2b7:	ff 73 14             	pushl  0x14(%ebx)
  80b2ba:	e8 bb ef ff ff       	call   80a27a <sys_mbox_trypost>
  80b2bf:	83 c4 10             	add    $0x10,%esp
  80b2c2:	84 c0                	test   %al,%al
  80b2c4:	0f 95 c0             	setne  %al
  80b2c7:	f7 d8                	neg    %eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80b2c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80b2cc:	5b                   	pop    %ebx
  80b2cd:	5e                   	pop    %esi
  80b2ce:	5d                   	pop    %ebp
  80b2cf:	c3                   	ret    
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80b2d0:	83 ec 04             	sub    $0x4,%esp
  80b2d3:	68 fc 32 81 00       	push   $0x8132fc
  80b2d8:	68 c1 00 00 00       	push   $0xc1
  80b2dd:	68 46 34 81 00       	push   $0x813446
  80b2e2:	e8 b2 33 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80b2e7:	83 ec 04             	sub    $0x4,%esp
  80b2ea:	68 20 33 81 00       	push   $0x813320
  80b2ef:	68 c2 00 00 00       	push   $0xc2
  80b2f4:	68 46 34 81 00       	push   $0x813446
  80b2f9:	e8 9b 33 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80b2fe:	83 ec 04             	sub    $0x4,%esp
  80b301:	68 5d 34 81 00       	push   $0x81345d
  80b306:	68 c4 00 00 00       	push   $0xc4
  80b30b:	68 46 34 81 00       	push   $0x813446
  80b310:	e8 84 33 00 00       	call   80e699 <_panic>
    return ERR_VAL;
  80b315:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b31a:	eb ad                	jmp    80b2c9 <recv_tcp+0x68>

0080b31c <recv_udp>:
{
  80b31c:	55                   	push   %ebp
  80b31d:	89 e5                	mov    %esp,%ebp
  80b31f:	57                   	push   %edi
  80b320:	56                   	push   %esi
  80b321:	53                   	push   %ebx
  80b322:	83 ec 1c             	sub    $0x1c,%esp
  80b325:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b328:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b32b:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b32e:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80b331:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b334:	85 c0                	test   %eax,%eax
  80b336:	74 7f                	je     80b3b7 <recv_udp+0x9b>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b338:	85 db                	test   %ebx,%ebx
  80b33a:	0f 84 8e 00 00 00    	je     80b3ce <recv_udp+0xb2>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b340:	39 43 08             	cmp    %eax,0x8(%ebx)
  80b343:	0f 85 9c 00 00 00    	jne    80b3e5 <recv_udp+0xc9>
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80b349:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b34d:	0f 84 a9 00 00 00    	je     80b3fc <recv_udp+0xe0>
  buf = memp_malloc(MEMP_NETBUF);
  80b353:	83 ec 0c             	sub    $0xc,%esp
  80b356:	6a 06                	push   $0x6
  80b358:	e8 8a 91 ff ff       	call   8044e7 <memp_malloc>
  80b35d:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80b35f:	83 c4 10             	add    $0x10,%esp
  80b362:	85 c0                	test   %eax,%eax
  80b364:	0f 84 a0 00 00 00    	je     80b40a <recv_udp+0xee>
    buf->p = p;
  80b36a:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80b36c:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80b36f:	8b 45 14             	mov    0x14(%ebp),%eax
  80b372:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80b375:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b379:	66 89 46 0c          	mov    %ax,0xc(%esi)
  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80b37d:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b381:	66 01 43 20          	add    %ax,0x20(%ebx)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80b385:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b388:	85 c0                	test   %eax,%eax
  80b38a:	74 10                	je     80b39c <recv_udp+0x80>
  80b38c:	83 ec 04             	sub    $0x4,%esp
  80b38f:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80b393:	52                   	push   %edx
  80b394:	6a 00                	push   $0x0
  80b396:	53                   	push   %ebx
  80b397:	ff d0                	call   *%eax
  80b399:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b39c:	83 ec 08             	sub    $0x8,%esp
  80b39f:	56                   	push   %esi
  80b3a0:	ff 73 14             	pushl  0x14(%ebx)
  80b3a3:	e8 d2 ee ff ff       	call   80a27a <sys_mbox_trypost>
  80b3a8:	83 c4 10             	add    $0x10,%esp
  80b3ab:	84 c0                	test   %al,%al
  80b3ad:	75 69                	jne    80b418 <recv_udp+0xfc>
}
  80b3af:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b3b2:	5b                   	pop    %ebx
  80b3b3:	5e                   	pop    %esi
  80b3b4:	5f                   	pop    %edi
  80b3b5:	5d                   	pop    %ebp
  80b3b6:	c3                   	ret    
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80b3b7:	83 ec 04             	sub    $0x4,%esp
  80b3ba:	68 40 33 81 00       	push   $0x813340
  80b3bf:	68 8e 00 00 00       	push   $0x8e
  80b3c4:	68 46 34 81 00       	push   $0x813446
  80b3c9:	e8 cb 32 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80b3ce:	83 ec 04             	sub    $0x4,%esp
  80b3d1:	68 64 33 81 00       	push   $0x813364
  80b3d6:	68 8f 00 00 00       	push   $0x8f
  80b3db:	68 46 34 81 00       	push   $0x813446
  80b3e0:	e8 b4 32 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80b3e5:	83 ec 04             	sub    $0x4,%esp
  80b3e8:	68 7b 34 81 00       	push   $0x81347b
  80b3ed:	68 91 00 00 00       	push   $0x91
  80b3f2:	68 46 34 81 00       	push   $0x813446
  80b3f7:	e8 9d 32 00 00       	call   80e699 <_panic>
    pbuf_free(p);
  80b3fc:	83 ec 0c             	sub    $0xc,%esp
  80b3ff:	57                   	push   %edi
  80b400:	e8 85 94 ff ff       	call   80488a <pbuf_free>
    return;
  80b405:	83 c4 10             	add    $0x10,%esp
  80b408:	eb a5                	jmp    80b3af <recv_udp+0x93>
    pbuf_free(p);
  80b40a:	83 ec 0c             	sub    $0xc,%esp
  80b40d:	57                   	push   %edi
  80b40e:	e8 77 94 ff ff       	call   80488a <pbuf_free>
    return;
  80b413:	83 c4 10             	add    $0x10,%esp
  80b416:	eb 97                	jmp    80b3af <recv_udp+0x93>
    netbuf_delete(buf);
  80b418:	83 ec 0c             	sub    $0xc,%esp
  80b41b:	56                   	push   %esi
  80b41c:	e8 d0 70 ff ff       	call   8024f1 <netbuf_delete>
    return;
  80b421:	83 c4 10             	add    $0x10,%esp
  80b424:	eb 89                	jmp    80b3af <recv_udp+0x93>

0080b426 <recv_raw>:
{
  80b426:	55                   	push   %ebp
  80b427:	89 e5                	mov    %esp,%ebp
  80b429:	57                   	push   %edi
  80b42a:	56                   	push   %esi
  80b42b:	53                   	push   %ebx
  80b42c:	83 ec 0c             	sub    $0xc,%esp
  80b42f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80b432:	85 db                	test   %ebx,%ebx
  80b434:	74 06                	je     80b43c <recv_raw+0x16>
  80b436:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b43a:	75 0d                	jne    80b449 <recv_raw+0x23>
}
  80b43c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b441:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b444:	5b                   	pop    %ebx
  80b445:	5e                   	pop    %esi
  80b446:	5f                   	pop    %edi
  80b447:	5d                   	pop    %ebp
  80b448:	c3                   	ret    
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80b449:	83 ec 04             	sub    $0x4,%esp
  80b44c:	6a 00                	push   $0x0
  80b44e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b451:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80b455:	50                   	push   %eax
  80b456:	6a 03                	push   $0x3
  80b458:	e8 f3 94 ff ff       	call   804950 <pbuf_alloc>
  80b45d:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80b45f:	83 c4 10             	add    $0x10,%esp
  80b462:	85 c0                	test   %eax,%eax
  80b464:	74 d6                	je     80b43c <recv_raw+0x16>
      if (pbuf_copy(q, p) != ERR_OK) {
  80b466:	83 ec 08             	sub    $0x8,%esp
  80b469:	ff 75 10             	pushl  0x10(%ebp)
  80b46c:	50                   	push   %eax
  80b46d:	e8 c0 99 ff ff       	call   804e32 <pbuf_copy>
  80b472:	83 c4 10             	add    $0x10,%esp
  80b475:	84 c0                	test   %al,%al
  80b477:	75 73                	jne    80b4ec <recv_raw+0xc6>
      buf = memp_malloc(MEMP_NETBUF);
  80b479:	83 ec 0c             	sub    $0xc,%esp
  80b47c:	6a 06                	push   $0x6
  80b47e:	e8 64 90 ff ff       	call   8044e7 <memp_malloc>
  80b483:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80b485:	83 c4 10             	add    $0x10,%esp
  80b488:	85 c0                	test   %eax,%eax
  80b48a:	74 71                	je     80b4fd <recv_raw+0xd7>
      buf->p = q;
  80b48c:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80b48e:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80b491:	8b 46 04             	mov    0x4(%esi),%eax
  80b494:	83 c0 0c             	add    $0xc,%eax
  80b497:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80b49a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b49d:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80b4a1:	66 89 47 0c          	mov    %ax,0xc(%edi)
      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80b4a5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b4a9:	66 01 43 20          	add    %ax,0x20(%ebx)
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80b4ad:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b4b0:	85 c0                	test   %eax,%eax
  80b4b2:	74 10                	je     80b4c4 <recv_raw+0x9e>
  80b4b4:	83 ec 04             	sub    $0x4,%esp
  80b4b7:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80b4bb:	52                   	push   %edx
  80b4bc:	6a 00                	push   $0x0
  80b4be:	53                   	push   %ebx
  80b4bf:	ff d0                	call   *%eax
  80b4c1:	83 c4 10             	add    $0x10,%esp
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80b4c4:	83 ec 08             	sub    $0x8,%esp
  80b4c7:	57                   	push   %edi
  80b4c8:	ff 73 14             	pushl  0x14(%ebx)
  80b4cb:	e8 aa ed ff ff       	call   80a27a <sys_mbox_trypost>
  80b4d0:	83 c4 10             	add    $0x10,%esp
  80b4d3:	84 c0                	test   %al,%al
  80b4d5:	0f 84 61 ff ff ff    	je     80b43c <recv_raw+0x16>
        netbuf_delete(buf);
  80b4db:	83 ec 0c             	sub    $0xc,%esp
  80b4de:	57                   	push   %edi
  80b4df:	e8 0d 70 ff ff       	call   8024f1 <netbuf_delete>
  80b4e4:	83 c4 10             	add    $0x10,%esp
  80b4e7:	e9 50 ff ff ff       	jmp    80b43c <recv_raw+0x16>
        pbuf_free(q);
  80b4ec:	83 ec 0c             	sub    $0xc,%esp
  80b4ef:	56                   	push   %esi
  80b4f0:	e8 95 93 ff ff       	call   80488a <pbuf_free>
  80b4f5:	83 c4 10             	add    $0x10,%esp
  80b4f8:	e9 3f ff ff ff       	jmp    80b43c <recv_raw+0x16>
        pbuf_free(q);
  80b4fd:	83 ec 0c             	sub    $0xc,%esp
  80b500:	56                   	push   %esi
  80b501:	e8 84 93 ff ff       	call   80488a <pbuf_free>
        return 0;
  80b506:	83 c4 10             	add    $0x10,%esp
  80b509:	e9 2e ff ff ff       	jmp    80b43c <recv_raw+0x16>

0080b50e <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80b50e:	55                   	push   %ebp
  80b50f:	89 e5                	mov    %esp,%ebp
  80b511:	53                   	push   %ebx
  80b512:	83 ec 0c             	sub    $0xc,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80b515:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80b518:	50                   	push   %eax
  80b519:	53                   	push   %ebx
  80b51a:	e8 38 a3 ff ff       	call   805857 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80b51f:	83 c4 08             	add    $0x8,%esp
  80b522:	68 61 b2 80 00       	push   $0x80b261
  80b527:	53                   	push   %ebx
  80b528:	e8 38 a3 ff ff       	call   805865 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80b52d:	83 c4 08             	add    $0x8,%esp
  80b530:	68 f0 b9 80 00       	push   $0x80b9f0
  80b535:	53                   	push   %ebx
  80b536:	e8 3b a3 ff ff       	call   805876 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80b53b:	83 c4 0c             	add    $0xc,%esp
  80b53e:	6a 04                	push   $0x4
  80b540:	68 aa b9 80 00       	push   $0x80b9aa
  80b545:	53                   	push   %ebx
  80b546:	e8 5b a3 ff ff       	call   8058a6 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80b54b:	83 c4 08             	add    $0x8,%esp
  80b54e:	68 ad b5 80 00       	push   $0x80b5ad
  80b553:	53                   	push   %ebx
  80b554:	e8 2e a3 ff ff       	call   805887 <tcp_err>
}
  80b559:	83 c4 10             	add    $0x10,%esp
  80b55c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b55f:	c9                   	leave  
  80b560:	c3                   	ret    

0080b561 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80b561:	55                   	push   %ebp
  80b562:	89 e5                	mov    %esp,%ebp
  80b564:	53                   	push   %ebx
  80b565:	83 ec 04             	sub    $0x4,%esp
  80b568:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b56b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80b56e:	85 db                	test   %ebx,%ebx
  80b570:	74 34                	je     80b5a6 <do_connected+0x45>
    return ERR_VAL;
  }

  conn->err = err;
  80b572:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80b575:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b578:	75 04                	jne    80b57e <do_connected+0x1d>
  80b57a:	84 c0                	test   %al,%al
  80b57c:	74 1f                	je     80b59d <do_connected+0x3c>
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  80b57e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80b585:	83 ec 0c             	sub    $0xc,%esp
  80b588:	ff 73 10             	pushl  0x10(%ebx)
  80b58b:	e8 6a eb ff ff       	call   80a0fa <sys_sem_signal>
  return ERR_OK;
  80b590:	83 c4 10             	add    $0x10,%esp
  80b593:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b598:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b59b:	c9                   	leave  
  80b59c:	c3                   	ret    
    setup_tcp(conn);
  80b59d:	89 d8                	mov    %ebx,%eax
  80b59f:	e8 6a ff ff ff       	call   80b50e <setup_tcp>
  80b5a4:	eb d8                	jmp    80b57e <do_connected+0x1d>
    return ERR_VAL;
  80b5a6:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80b5ab:	eb eb                	jmp    80b598 <do_connected+0x37>

0080b5ad <err_tcp>:
{
  80b5ad:	55                   	push   %ebp
  80b5ae:	89 e5                	mov    %esp,%ebp
  80b5b0:	53                   	push   %ebx
  80b5b1:	83 ec 04             	sub    $0x4,%esp
  80b5b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b5b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b5ba:	85 db                	test   %ebx,%ebx
  80b5bc:	74 7e                	je     80b63c <err_tcp+0x8f>
  conn->pcb.tcp = NULL;
  80b5be:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  conn->err = err;
  80b5c5:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80b5c8:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b5cc:	74 24                	je     80b5f2 <err_tcp+0x45>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b5ce:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b5d1:	85 c0                	test   %eax,%eax
  80b5d3:	74 0d                	je     80b5e2 <err_tcp+0x35>
  80b5d5:	83 ec 04             	sub    $0x4,%esp
  80b5d8:	6a 00                	push   $0x0
  80b5da:	6a 00                	push   $0x0
  80b5dc:	53                   	push   %ebx
  80b5dd:	ff d0                	call   *%eax
  80b5df:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->recvmbox, NULL);
  80b5e2:	83 ec 08             	sub    $0x8,%esp
  80b5e5:	6a 00                	push   $0x0
  80b5e7:	ff 73 14             	pushl  0x14(%ebx)
  80b5ea:	e8 50 ed ff ff       	call   80a33f <sys_mbox_post>
  80b5ef:	83 c4 10             	add    $0x10,%esp
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80b5f2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b5f5:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b5f8:	74 06                	je     80b600 <err_tcp+0x53>
  80b5fa:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80b5fe:	74 53                	je     80b653 <err_tcp+0xa6>
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80b600:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b604:	74 24                	je     80b62a <err_tcp+0x7d>
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b606:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b609:	85 c0                	test   %eax,%eax
  80b60b:	74 0d                	je     80b61a <err_tcp+0x6d>
  80b60d:	83 ec 04             	sub    $0x4,%esp
  80b610:	6a 00                	push   $0x0
  80b612:	6a 00                	push   $0x0
  80b614:	53                   	push   %ebx
  80b615:	ff d0                	call   *%eax
  80b617:	83 c4 10             	add    $0x10,%esp
    sys_mbox_post(conn->acceptmbox, NULL);
  80b61a:	83 ec 08             	sub    $0x8,%esp
  80b61d:	6a 00                	push   $0x0
  80b61f:	ff 73 18             	pushl  0x18(%ebx)
  80b622:	e8 18 ed ff ff       	call   80a33f <sys_mbox_post>
  80b627:	83 c4 10             	add    $0x10,%esp
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80b62a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b62d:	83 f8 01             	cmp    $0x1,%eax
  80b630:	74 36                	je     80b668 <err_tcp+0xbb>
  80b632:	83 f8 04             	cmp    $0x4,%eax
  80b635:	74 31                	je     80b668 <err_tcp+0xbb>
}
  80b637:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b63a:	c9                   	leave  
  80b63b:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b63c:	83 ec 04             	sub    $0x4,%esp
  80b63f:	68 99 34 81 00       	push   $0x813499
  80b644:	68 22 01 00 00       	push   $0x122
  80b649:	68 46 34 81 00       	push   $0x813446
  80b64e:	e8 46 30 00 00       	call   80e699 <_panic>
    conn->state = NETCONN_NONE;
  80b653:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b65a:	83 ec 0c             	sub    $0xc,%esp
  80b65d:	50                   	push   %eax
  80b65e:	e8 97 ea ff ff       	call   80a0fa <sys_sem_signal>
  80b663:	83 c4 10             	add    $0x10,%esp
  80b666:	eb 98                	jmp    80b600 <err_tcp+0x53>
    conn->state = NETCONN_NONE;
  80b668:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80b66f:	83 ec 0c             	sub    $0xc,%esp
  80b672:	ff 73 10             	pushl  0x10(%ebx)
  80b675:	e8 80 ea ff ff       	call   80a0fa <sys_sem_signal>
  80b67a:	83 c4 10             	add    $0x10,%esp
}
  80b67d:	eb b8                	jmp    80b637 <err_tcp+0x8a>

0080b67f <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80b67f:	55                   	push   %ebp
  80b680:	89 e5                	mov    %esp,%ebp
  80b682:	57                   	push   %edi
  80b683:	56                   	push   %esi
  80b684:	53                   	push   %ebx
  80b685:	83 ec 0c             	sub    $0xc,%esp
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b688:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80b68c:	0f 85 c9 00 00 00    	jne    80b75b <do_writemore+0xdc>
  80b692:	89 c6                	mov    %eax,%esi

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80b694:	8b 40 24             	mov    0x24(%eax),%eax
  80b697:	8b 7e 28             	mov    0x28(%esi),%edi
  80b69a:	89 fa                	mov    %edi,%edx
  80b69c:	03 50 04             	add    0x4(%eax),%edx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80b69f:	8b 58 08             	mov    0x8(%eax),%ebx
  80b6a2:	89 d9                	mov    %ebx,%ecx
  80b6a4:	29 f9                	sub    %edi,%ecx
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80b6a6:	29 fb                	sub    %edi,%ebx
  80b6a8:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80b6ae:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80b6b3:	0f 4d d9             	cmovge %ecx,%ebx
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80b6b6:	8b 4e 08             	mov    0x8(%esi),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80b6b9:	66 39 59 6e          	cmp    %bx,0x6e(%ecx)
  80b6bd:	66 0f 46 59 6e       	cmovbe 0x6e(%ecx),%bx
  80b6c2:	0f b7 db             	movzwl %bx,%ebx
  80b6c5:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80b6c9:	50                   	push   %eax
  80b6ca:	53                   	push   %ebx
  80b6cb:	52                   	push   %edx
  80b6cc:	51                   	push   %ecx
  80b6cd:	e8 9c c9 ff ff       	call   80806e <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b6d2:	89 da                	mov    %ebx,%edx
  80b6d4:	03 56 28             	add    0x28(%esi),%edx
  80b6d7:	8b 4e 24             	mov    0x24(%esi),%ecx
  80b6da:	83 c4 10             	add    $0x10,%esp
  80b6dd:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b6e0:	0f 8f 8c 00 00 00    	jg     80b772 <do_writemore+0xf3>
  if (err == ERR_OK) {
  80b6e6:	84 c0                	test   %al,%al
  80b6e8:	0f 85 bf 00 00 00    	jne    80b7ad <do_writemore+0x12e>
    conn->write_offset += len;
  80b6ee:	89 56 28             	mov    %edx,0x28(%esi)
  u8_t write_finished = 0;
  80b6f1:	bf 00 00 00 00       	mov    $0x0,%edi
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80b6f6:	3b 51 08             	cmp    0x8(%ecx),%edx
  80b6f9:	0f 84 8a 00 00 00    	je     80b789 <do_writemore+0x10a>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80b6ff:	8b 46 08             	mov    0x8(%esi),%eax
  80b702:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80b706:	74 1a                	je     80b722 <do_writemore+0xa3>
  80b708:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80b70c:	75 14                	jne    80b722 <do_writemore+0xa3>
  80b70e:	8b 50 74             	mov    0x74(%eax),%edx
  80b711:	85 d2                	test   %edx,%edx
  80b713:	0f 84 88 00 00 00    	je     80b7a1 <do_writemore+0x122>
  80b719:	83 3a 00             	cmpl   $0x0,(%edx)
  80b71c:	0f 84 85 00 00 00    	je     80b7a7 <do_writemore+0x128>
  80b722:	83 ec 0c             	sub    $0xc,%esp
  80b725:	50                   	push   %eax
  80b726:	e8 9a c9 ff ff       	call   8080c5 <tcp_output>
    conn->err = err;
  80b72b:	88 46 0c             	mov    %al,0xc(%esi)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80b72e:	83 c4 10             	add    $0x10,%esp
  80b731:	84 c0                	test   %al,%al
  80b733:	75 1e                	jne    80b753 <do_writemore+0xd4>
  80b735:	8b 46 08             	mov    0x8(%esi),%eax
  80b738:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80b73e:	77 13                	ja     80b753 <do_writemore+0xd4>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80b740:	8b 46 2c             	mov    0x2c(%esi),%eax
  80b743:	85 c0                	test   %eax,%eax
  80b745:	74 0c                	je     80b753 <do_writemore+0xd4>
  80b747:	83 ec 04             	sub    $0x4,%esp
  80b74a:	53                   	push   %ebx
  80b74b:	6a 03                	push   $0x3
  80b74d:	56                   	push   %esi
  80b74e:	ff d0                	call   *%eax
  80b750:	83 c4 10             	add    $0x10,%esp
       the error to the application thread. */
    conn->err = err;
    write_finished = 1;
  }

  if (write_finished) {
  80b753:	89 f8                	mov    %edi,%eax
  80b755:	84 c0                	test   %al,%al
  80b757:	74 70                	je     80b7c9 <do_writemore+0x14a>
  80b759:	eb 59                	jmp    80b7b4 <do_writemore+0x135>
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80b75b:	83 ec 04             	sub    $0x4,%esp
  80b75e:	68 a6 34 81 00       	push   $0x8134a6
  80b763:	68 b8 03 00 00       	push   $0x3b8
  80b768:	68 46 34 81 00       	push   $0x813446
  80b76d:	e8 27 2f 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80b772:	83 ec 04             	sub    $0x4,%esp
  80b775:	68 c3 34 81 00       	push   $0x8134c3
  80b77a:	68 cd 03 00 00       	push   $0x3cd
  80b77f:	68 46 34 81 00       	push   $0x813446
  80b784:	e8 10 2f 00 00       	call   80e699 <_panic>
      conn->write_msg = NULL;
  80b789:	c7 46 24 00 00 00 00 	movl   $0x0,0x24(%esi)
      conn->write_offset = 0;
  80b790:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
      write_finished = 1;
  80b797:	bf 01 00 00 00       	mov    $0x1,%edi
  80b79c:	e9 5e ff ff ff       	jmp    80b6ff <do_writemore+0x80>
    conn->err = err;
  80b7a1:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b7a5:	eb 8e                	jmp    80b735 <do_writemore+0xb6>
  80b7a7:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80b7ab:	eb 88                	jmp    80b735 <do_writemore+0xb6>
  } else if (err == ERR_MEM) {
  80b7ad:	3c ff                	cmp    $0xff,%al
  80b7af:	74 25                	je     80b7d6 <do_writemore+0x157>
    conn->err = err;
  80b7b1:	88 46 0c             	mov    %al,0xc(%esi)
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80b7b4:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80b7bb:	83 ec 0c             	sub    $0xc,%esp
  80b7be:	ff 76 10             	pushl  0x10(%esi)
  80b7c1:	e8 34 e9 ff ff       	call   80a0fa <sys_sem_signal>
  80b7c6:	83 c4 10             	add    $0x10,%esp
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80b7c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80b7ce:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80b7d1:	5b                   	pop    %ebx
  80b7d2:	5e                   	pop    %esi
  80b7d3:	5f                   	pop    %edi
  80b7d4:	5d                   	pop    %ebp
  80b7d5:	c3                   	ret    
    err = tcp_output(conn->pcb.tcp);
  80b7d6:	83 ec 0c             	sub    $0xc,%esp
  80b7d9:	ff 76 08             	pushl  0x8(%esi)
  80b7dc:	e8 e4 c8 ff ff       	call   8080c5 <tcp_output>
  80b7e1:	83 c4 10             	add    $0x10,%esp
  80b7e4:	eb e3                	jmp    80b7c9 <do_writemore+0x14a>

0080b7e6 <do_close_internal>:
{
  80b7e6:	55                   	push   %ebp
  80b7e7:	89 e5                	mov    %esp,%ebp
  80b7e9:	53                   	push   %ebx
  80b7ea:	83 ec 04             	sub    $0x4,%esp
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b7ed:	85 c0                	test   %eax,%eax
  80b7ef:	0f 84 e2 00 00 00    	je     80b8d7 <do_close_internal+0xf1>
  80b7f5:	89 c3                	mov    %eax,%ebx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b7f7:	83 38 10             	cmpl   $0x10,(%eax)
  80b7fa:	0f 85 ee 00 00 00    	jne    80b8ee <do_close_internal+0x108>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b800:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80b804:	0f 85 fb 00 00 00    	jne    80b905 <do_close_internal+0x11f>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b80a:	8b 40 08             	mov    0x8(%eax),%eax
  80b80d:	85 c0                	test   %eax,%eax
  80b80f:	0f 84 07 01 00 00    	je     80b91c <do_close_internal+0x136>
  tcp_arg(conn->pcb.tcp, NULL);
  80b815:	83 ec 08             	sub    $0x8,%esp
  80b818:	6a 00                	push   $0x0
  80b81a:	50                   	push   %eax
  80b81b:	e8 37 a0 ff ff       	call   805857 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80b820:	8b 43 08             	mov    0x8(%ebx),%eax
  80b823:	83 c4 10             	add    $0x10,%esp
  80b826:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b82a:	0f 84 03 01 00 00    	je     80b933 <do_close_internal+0x14d>
    tcp_recv(conn->pcb.tcp, NULL);
  80b830:	83 ec 08             	sub    $0x8,%esp
  80b833:	6a 00                	push   $0x0
  80b835:	50                   	push   %eax
  80b836:	e8 2a a0 ff ff       	call   805865 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80b83b:	83 c4 08             	add    $0x8,%esp
  80b83e:	6a 00                	push   $0x0
  80b840:	ff 73 08             	pushl  0x8(%ebx)
  80b843:	e8 50 a0 ff ff       	call   805898 <tcp_accept>
    tcp_sent(conn->pcb.tcp, NULL);
  80b848:	83 c4 08             	add    $0x8,%esp
  80b84b:	6a 00                	push   $0x0
  80b84d:	ff 73 08             	pushl  0x8(%ebx)
  80b850:	e8 21 a0 ff ff       	call   805876 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80b855:	83 c4 0c             	add    $0xc,%esp
  80b858:	6a 04                	push   $0x4
  80b85a:	6a 00                	push   $0x0
  80b85c:	ff 73 08             	pushl  0x8(%ebx)
  80b85f:	e8 42 a0 ff ff       	call   8058a6 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80b864:	83 c4 08             	add    $0x8,%esp
  80b867:	6a 00                	push   $0x0
  80b869:	ff 73 08             	pushl  0x8(%ebx)
  80b86c:	e8 16 a0 ff ff       	call   805887 <tcp_err>
  80b871:	83 c4 10             	add    $0x10,%esp
  err = tcp_close(conn->pcb.tcp);
  80b874:	83 ec 0c             	sub    $0xc,%esp
  80b877:	ff 73 08             	pushl  0x8(%ebx)
  80b87a:	e8 da a1 ff ff       	call   805a59 <tcp_close>
  if (err == ERR_OK) {
  80b87f:	83 c4 10             	add    $0x10,%esp
  80b882:	84 c0                	test   %al,%al
  80b884:	0f 85 bc 00 00 00    	jne    80b946 <do_close_internal+0x160>
    conn->state = NETCONN_NONE;
  80b88a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    conn->pcb.tcp = NULL;
  80b891:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80b898:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80b89c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b89f:	85 c0                	test   %eax,%eax
  80b8a1:	74 21                	je     80b8c4 <do_close_internal+0xde>
  80b8a3:	83 ec 04             	sub    $0x4,%esp
  80b8a6:	6a 00                	push   $0x0
  80b8a8:	6a 00                	push   $0x0
  80b8aa:	53                   	push   %ebx
  80b8ab:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80b8ad:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b8b0:	83 c4 10             	add    $0x10,%esp
  80b8b3:	85 c0                	test   %eax,%eax
  80b8b5:	74 0d                	je     80b8c4 <do_close_internal+0xde>
  80b8b7:	83 ec 04             	sub    $0x4,%esp
  80b8ba:	6a 00                	push   $0x0
  80b8bc:	6a 02                	push   $0x2
  80b8be:	53                   	push   %ebx
  80b8bf:	ff d0                	call   *%eax
  80b8c1:	83 c4 10             	add    $0x10,%esp
    sys_sem_signal(conn->op_completed);
  80b8c4:	83 ec 0c             	sub    $0xc,%esp
  80b8c7:	ff 73 10             	pushl  0x10(%ebx)
  80b8ca:	e8 2b e8 ff ff       	call   80a0fa <sys_sem_signal>
  80b8cf:	83 c4 10             	add    $0x10,%esp
}
  80b8d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80b8d5:	c9                   	leave  
  80b8d6:	c3                   	ret    
  LWIP_ASSERT("invalid conn", (conn != NULL));
  80b8d7:	83 ec 04             	sub    $0x4,%esp
  80b8da:	68 b4 32 81 00       	push   $0x8132b4
  80b8df:	68 53 02 00 00       	push   $0x253
  80b8e4:	68 46 34 81 00       	push   $0x813446
  80b8e9:	e8 ab 2d 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80b8ee:	83 ec 04             	sub    $0x4,%esp
  80b8f1:	68 e1 34 81 00       	push   $0x8134e1
  80b8f6:	68 54 02 00 00       	push   $0x254
  80b8fb:	68 46 34 81 00       	push   $0x813446
  80b900:	e8 94 2d 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80b905:	83 ec 04             	sub    $0x4,%esp
  80b908:	68 84 33 81 00       	push   $0x813384
  80b90d:	68 55 02 00 00       	push   $0x255
  80b912:	68 46 34 81 00       	push   $0x813446
  80b917:	e8 7d 2d 00 00       	call   80e699 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80b91c:	83 ec 04             	sub    $0x4,%esp
  80b91f:	68 ff 34 81 00       	push   $0x8134ff
  80b924:	68 56 02 00 00       	push   $0x256
  80b929:	68 46 34 81 00       	push   $0x813446
  80b92e:	e8 66 2d 00 00       	call   80e699 <_panic>
    tcp_accept(conn->pcb.tcp, NULL);
  80b933:	83 ec 08             	sub    $0x8,%esp
  80b936:	6a 00                	push   $0x0
  80b938:	50                   	push   %eax
  80b939:	e8 5a 9f ff ff       	call   805898 <tcp_accept>
  80b93e:	83 c4 10             	add    $0x10,%esp
  80b941:	e9 2e ff ff ff       	jmp    80b874 <do_close_internal+0x8e>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b946:	8b 43 08             	mov    0x8(%ebx),%eax
  80b949:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80b94d:	74 44                	je     80b993 <do_close_internal+0x1ad>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80b94f:	83 ec 08             	sub    $0x8,%esp
  80b952:	68 f0 b9 80 00       	push   $0x80b9f0
  80b957:	50                   	push   %eax
  80b958:	e8 19 9f ff ff       	call   805876 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80b95d:	83 c4 0c             	add    $0xc,%esp
  80b960:	6a 04                	push   $0x4
  80b962:	68 aa b9 80 00       	push   $0x80b9aa
  80b967:	ff 73 08             	pushl  0x8(%ebx)
  80b96a:	e8 37 9f ff ff       	call   8058a6 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80b96f:	83 c4 08             	add    $0x8,%esp
  80b972:	68 ad b5 80 00       	push   $0x80b5ad
  80b977:	ff 73 08             	pushl  0x8(%ebx)
  80b97a:	e8 08 9f ff ff       	call   805887 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80b97f:	83 c4 08             	add    $0x8,%esp
  80b982:	53                   	push   %ebx
  80b983:	ff 73 08             	pushl  0x8(%ebx)
  80b986:	e8 cc 9e ff ff       	call   805857 <tcp_arg>
  80b98b:	83 c4 10             	add    $0x10,%esp
}
  80b98e:	e9 3f ff ff ff       	jmp    80b8d2 <do_close_internal+0xec>
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80b993:	83 ec 04             	sub    $0x4,%esp
  80b996:	68 a8 33 81 00       	push   $0x8133a8
  80b99b:	68 75 02 00 00       	push   $0x275
  80b9a0:	68 46 34 81 00       	push   $0x813446
  80b9a5:	e8 ef 2c 00 00       	call   80e699 <_panic>

0080b9aa <poll_tcp>:
{
  80b9aa:	55                   	push   %ebp
  80b9ab:	89 e5                	mov    %esp,%ebp
  80b9ad:	83 ec 08             	sub    $0x8,%esp
  80b9b0:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b9b3:	85 c0                	test   %eax,%eax
  80b9b5:	74 14                	je     80b9cb <poll_tcp+0x21>
  if (conn->state == NETCONN_WRITE) {
  80b9b7:	8b 50 04             	mov    0x4(%eax),%edx
  80b9ba:	83 fa 01             	cmp    $0x1,%edx
  80b9bd:	74 23                	je     80b9e2 <poll_tcp+0x38>
  } else if (conn->state == NETCONN_CLOSE) {
  80b9bf:	83 fa 04             	cmp    $0x4,%edx
  80b9c2:	74 25                	je     80b9e9 <poll_tcp+0x3f>
}
  80b9c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9c9:	c9                   	leave  
  80b9ca:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b9cb:	83 ec 04             	sub    $0x4,%esp
  80b9ce:	68 99 34 81 00       	push   $0x813499
  80b9d3:	68 eb 00 00 00       	push   $0xeb
  80b9d8:	68 46 34 81 00       	push   $0x813446
  80b9dd:	e8 b7 2c 00 00       	call   80e699 <_panic>
    do_writemore(conn);
  80b9e2:	e8 98 fc ff ff       	call   80b67f <do_writemore>
  80b9e7:	eb db                	jmp    80b9c4 <poll_tcp+0x1a>
    do_close_internal(conn);
  80b9e9:	e8 f8 fd ff ff       	call   80b7e6 <do_close_internal>
  80b9ee:	eb d4                	jmp    80b9c4 <poll_tcp+0x1a>

0080b9f0 <sent_tcp>:
{
  80b9f0:	55                   	push   %ebp
  80b9f1:	89 e5                	mov    %esp,%ebp
  80b9f3:	56                   	push   %esi
  80b9f4:	53                   	push   %ebx
  80b9f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b9f8:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80b9fb:	85 db                	test   %ebx,%ebx
  80b9fd:	74 3e                	je     80ba3d <sent_tcp+0x4d>
  if (conn->state == NETCONN_WRITE) {
  80b9ff:	8b 43 04             	mov    0x4(%ebx),%eax
  80ba02:	83 f8 01             	cmp    $0x1,%eax
  80ba05:	74 4d                	je     80ba54 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
  80ba07:	83 f8 04             	cmp    $0x4,%eax
  80ba0a:	74 6e                	je     80ba7a <sent_tcp+0x8a>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80ba0c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ba0f:	85 c0                	test   %eax,%eax
  80ba11:	74 1e                	je     80ba31 <sent_tcp+0x41>
  80ba13:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ba19:	76 16                	jbe    80ba31 <sent_tcp+0x41>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80ba1b:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba1e:	85 c0                	test   %eax,%eax
  80ba20:	74 0f                	je     80ba31 <sent_tcp+0x41>
  80ba22:	83 ec 04             	sub    $0x4,%esp
  80ba25:	0f b7 f6             	movzwl %si,%esi
  80ba28:	56                   	push   %esi
  80ba29:	6a 02                	push   $0x2
  80ba2b:	53                   	push   %ebx
  80ba2c:	ff d0                	call   *%eax
  80ba2e:	83 c4 10             	add    $0x10,%esp
}
  80ba31:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba36:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80ba39:	5b                   	pop    %ebx
  80ba3a:	5e                   	pop    %esi
  80ba3b:	5d                   	pop    %ebp
  80ba3c:	c3                   	ret    
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ba3d:	83 ec 04             	sub    $0x4,%esp
  80ba40:	68 99 34 81 00       	push   $0x813499
  80ba45:	68 03 01 00 00       	push   $0x103
  80ba4a:	68 46 34 81 00       	push   $0x813446
  80ba4f:	e8 45 2c 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80ba54:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ba58:	74 09                	je     80ba63 <sent_tcp+0x73>
    do_writemore(conn);
  80ba5a:	89 d8                	mov    %ebx,%eax
  80ba5c:	e8 1e fc ff ff       	call   80b67f <do_writemore>
  80ba61:	eb a9                	jmp    80ba0c <sent_tcp+0x1c>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80ba63:	83 ec 04             	sub    $0x4,%esp
  80ba66:	68 12 35 81 00       	push   $0x813512
  80ba6b:	68 06 01 00 00       	push   $0x106
  80ba70:	68 46 34 81 00       	push   $0x813446
  80ba75:	e8 1f 2c 00 00       	call   80e699 <_panic>
    do_close_internal(conn);
  80ba7a:	89 d8                	mov    %ebx,%eax
  80ba7c:	e8 65 fd ff ff       	call   80b7e6 <do_close_internal>
  80ba81:	eb 89                	jmp    80ba0c <sent_tcp+0x1c>

0080ba83 <do_newconn>:
{
  80ba83:	55                   	push   %ebp
  80ba84:	89 e5                	mov    %esp,%ebp
  80ba86:	56                   	push   %esi
  80ba87:	53                   	push   %ebx
  80ba88:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80ba8b:	8b 03                	mov    (%ebx),%eax
  80ba8d:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ba91:	74 17                	je     80baaa <do_newconn+0x27>
   TCPIP_APIMSG_ACK(msg);
  80ba93:	83 ec 0c             	sub    $0xc,%esp
  80ba96:	8b 03                	mov    (%ebx),%eax
  80ba98:	ff 70 10             	pushl  0x10(%eax)
  80ba9b:	e8 5a e6 ff ff       	call   80a0fa <sys_sem_signal>
}
  80baa0:	83 c4 10             	add    $0x10,%esp
  80baa3:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80baa6:	5b                   	pop    %ebx
  80baa7:	5e                   	pop    %esi
  80baa8:	5d                   	pop    %ebp
  80baa9:	c3                   	ret    
   msg->conn->err = ERR_OK;
  80baaa:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80baae:	8b 33                	mov    (%ebx),%esi
  80bab0:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80bab4:	75 20                	jne    80bad6 <do_newconn+0x53>
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80bab6:	8b 06                	mov    (%esi),%eax
  80bab8:	25 f0 00 00 00       	and    $0xf0,%eax
  80babd:	83 f8 20             	cmp    $0x20,%eax
  80bac0:	74 67                	je     80bb29 <do_newconn+0xa6>
  80bac2:	83 f8 40             	cmp    $0x40,%eax
  80bac5:	74 26                	je     80baed <do_newconn+0x6a>
  80bac7:	83 f8 10             	cmp    $0x10,%eax
  80baca:	0f 84 99 00 00 00    	je     80bb69 <do_newconn+0xe6>
     msg->conn->err = ERR_VAL;
  80bad0:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bad4:	eb bd                	jmp    80ba93 <do_newconn+0x10>
   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80bad6:	83 ec 04             	sub    $0x4,%esp
  80bad9:	68 cc 33 81 00       	push   $0x8133cc
  80bade:	68 8a 01 00 00       	push   $0x18a
  80bae3:	68 46 34 81 00       	push   $0x813446
  80bae8:	e8 ac 2b 00 00       	call   80e699 <_panic>
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80baed:	83 ec 0c             	sub    $0xc,%esp
  80baf0:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80baf4:	50                   	push   %eax
  80baf5:	e8 67 25 00 00       	call   80e061 <raw_new>
  80bafa:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80bafd:	8b 03                	mov    (%ebx),%eax
  80baff:	8b 50 08             	mov    0x8(%eax),%edx
  80bb02:	83 c4 10             	add    $0x10,%esp
  80bb05:	85 d2                	test   %edx,%edx
  80bb07:	74 17                	je     80bb20 <do_newconn+0x9d>
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80bb09:	83 ec 04             	sub    $0x4,%esp
  80bb0c:	50                   	push   %eax
  80bb0d:	68 26 b4 80 00       	push   $0x80b426
  80bb12:	52                   	push   %edx
  80bb13:	e8 cd 23 00 00       	call   80dee5 <raw_recv>
  80bb18:	83 c4 10             	add    $0x10,%esp
  80bb1b:	e9 73 ff ff ff       	jmp    80ba93 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bb20:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bb24:	e9 6a ff ff ff       	jmp    80ba93 <do_newconn+0x10>
     msg->conn->pcb.udp = udp_new();
  80bb29:	e8 2d d5 ff ff       	call   80905b <udp_new>
  80bb2e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80bb31:	8b 03                	mov    (%ebx),%eax
  80bb33:	8b 50 08             	mov    0x8(%eax),%edx
  80bb36:	85 d2                	test   %edx,%edx
  80bb38:	74 20                	je     80bb5a <do_newconn+0xd7>
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80bb3a:	83 38 22             	cmpl   $0x22,(%eax)
  80bb3d:	74 24                	je     80bb63 <do_newconn+0xe0>
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80bb3f:	8b 03                	mov    (%ebx),%eax
  80bb41:	83 ec 04             	sub    $0x4,%esp
  80bb44:	50                   	push   %eax
  80bb45:	68 1c b3 80 00       	push   $0x80b31c
  80bb4a:	ff 70 08             	pushl  0x8(%eax)
  80bb4d:	e8 b1 d4 ff ff       	call   809003 <udp_recv>
  80bb52:	83 c4 10             	add    $0x10,%esp
  80bb55:	e9 39 ff ff ff       	jmp    80ba93 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bb5a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bb5e:	e9 30 ff ff ff       	jmp    80ba93 <do_newconn+0x10>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80bb63:	c6 42 10 01          	movb   $0x1,0x10(%edx)
  80bb67:	eb d6                	jmp    80bb3f <do_newconn+0xbc>
     msg->conn->pcb.tcp = tcp_new();
  80bb69:	e8 b9 a7 ff ff       	call   806327 <tcp_new>
  80bb6e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80bb71:	8b 03                	mov    (%ebx),%eax
  80bb73:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80bb77:	74 0a                	je     80bb83 <do_newconn+0x100>
     setup_tcp(msg->conn);
  80bb79:	e8 90 f9 ff ff       	call   80b50e <setup_tcp>
  80bb7e:	e9 10 ff ff ff       	jmp    80ba93 <do_newconn+0x10>
       msg->conn->err = ERR_MEM;
  80bb83:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80bb87:	e9 07 ff ff ff       	jmp    80ba93 <do_newconn+0x10>

0080bb8c <netconn_alloc>:
{
  80bb8c:	55                   	push   %ebp
  80bb8d:	89 e5                	mov    %esp,%ebp
  80bb8f:	53                   	push   %ebx
  80bb90:	83 ec 10             	sub    $0x10,%esp
  conn = memp_malloc(MEMP_NETCONN);
  80bb93:	6a 07                	push   $0x7
  80bb95:	e8 4d 89 ff ff       	call   8044e7 <memp_malloc>
  80bb9a:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80bb9c:	83 c4 10             	add    $0x10,%esp
  80bb9f:	85 c0                	test   %eax,%eax
  80bba1:	74 5b                	je     80bbfe <netconn_alloc+0x72>
  conn->err = ERR_OK;
  80bba3:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80bba7:	8b 45 08             	mov    0x8(%ebp),%eax
  80bbaa:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80bbac:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80bbb3:	83 ec 0c             	sub    $0xc,%esp
  80bbb6:	6a 00                	push   $0x0
  80bbb8:	e8 80 e2 ff ff       	call   809e3d <sys_sem_new>
  80bbbd:	89 43 10             	mov    %eax,0x10(%ebx)
  80bbc0:	83 c4 10             	add    $0x10,%esp
  80bbc3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bbc6:	74 3d                	je     80bc05 <netconn_alloc+0x79>
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80bbc8:	83 ec 0c             	sub    $0xc,%esp
  80bbcb:	6a 00                	push   $0x0
  80bbcd:	e8 14 e4 ff ff       	call   809fe6 <sys_mbox_new>
  80bbd2:	89 43 14             	mov    %eax,0x14(%ebx)
  80bbd5:	83 c4 10             	add    $0x10,%esp
  80bbd8:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bbdb:	74 3d                	je     80bc1a <netconn_alloc+0x8e>
  conn->acceptmbox   = SYS_MBOX_NULL;
  80bbdd:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80bbe4:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  conn->socket       = -1;
  80bbeb:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80bbf2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bbf5:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80bbf8:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
}
  80bbfe:	89 d8                	mov    %ebx,%eax
  80bc00:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bc03:	c9                   	leave  
  80bc04:	c3                   	ret    
    memp_free(MEMP_NETCONN, conn);
  80bc05:	83 ec 08             	sub    $0x8,%esp
  80bc08:	53                   	push   %ebx
  80bc09:	6a 07                	push   $0x7
  80bc0b:	e8 2d 89 ff ff       	call   80453d <memp_free>
    return NULL;
  80bc10:	83 c4 10             	add    $0x10,%esp
  80bc13:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bc18:	eb e4                	jmp    80bbfe <netconn_alloc+0x72>
    sys_sem_free(conn->op_completed);
  80bc1a:	83 ec 0c             	sub    $0xc,%esp
  80bc1d:	ff 73 10             	pushl  0x10(%ebx)
  80bc20:	e8 99 e2 ff ff       	call   809ebe <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80bc25:	83 c4 08             	add    $0x8,%esp
  80bc28:	53                   	push   %ebx
  80bc29:	6a 07                	push   $0x7
  80bc2b:	e8 0d 89 ff ff       	call   80453d <memp_free>
    return NULL;
  80bc30:	83 c4 10             	add    $0x10,%esp
  80bc33:	bb 00 00 00 00       	mov    $0x0,%ebx
  80bc38:	eb c4                	jmp    80bbfe <netconn_alloc+0x72>

0080bc3a <netconn_free>:
{
  80bc3a:	55                   	push   %ebp
  80bc3b:	89 e5                	mov    %esp,%ebp
  80bc3d:	56                   	push   %esi
  80bc3e:	53                   	push   %ebx
  80bc3f:	83 ec 10             	sub    $0x10,%esp
  80bc42:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bc45:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80bc49:	75 0b                	jne    80bc56 <netconn_free+0x1c>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc4b:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80bc4e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bc52:	75 27                	jne    80bc7b <netconn_free+0x41>
  80bc54:	eb 68                	jmp    80bcbe <netconn_free+0x84>
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80bc56:	83 ec 04             	sub    $0x4,%esp
  80bc59:	68 ec 33 81 00       	push   $0x8133ec
  80bc5e:	68 26 02 00 00       	push   $0x226
  80bc63:	68 46 34 81 00       	push   $0x813446
  80bc68:	e8 2c 2a 00 00       	call   80e699 <_panic>
        netbuf_delete((struct netbuf *)mem);
  80bc6d:	83 ec 0c             	sub    $0xc,%esp
  80bc70:	ff 75 f4             	pushl  -0xc(%ebp)
  80bc73:	e8 79 68 ff ff       	call   8024f1 <netbuf_delete>
  80bc78:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80bc7b:	83 ec 08             	sub    $0x8,%esp
  80bc7e:	56                   	push   %esi
  80bc7f:	ff 73 14             	pushl  0x14(%ebx)
  80bc82:	e8 d6 e7 ff ff       	call   80a45d <sys_arch_mbox_tryfetch>
  80bc87:	83 c4 10             	add    $0x10,%esp
  80bc8a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bc8d:	74 1a                	je     80bca9 <netconn_free+0x6f>
      if (conn->type == NETCONN_TCP) {
  80bc8f:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bc92:	75 d9                	jne    80bc6d <netconn_free+0x33>
        if(mem != NULL) {
  80bc94:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80bc97:	85 c0                	test   %eax,%eax
  80bc99:	74 e0                	je     80bc7b <netconn_free+0x41>
          pbuf_free((struct pbuf *)mem);
  80bc9b:	83 ec 0c             	sub    $0xc,%esp
  80bc9e:	50                   	push   %eax
  80bc9f:	e8 e6 8b ff ff       	call   80488a <pbuf_free>
  80bca4:	83 c4 10             	add    $0x10,%esp
  80bca7:	eb d2                	jmp    80bc7b <netconn_free+0x41>
    sys_mbox_free(conn->recvmbox);
  80bca9:	83 ec 0c             	sub    $0xc,%esp
  80bcac:	ff 73 14             	pushl  0x14(%ebx)
  80bcaf:	e8 93 e2 ff ff       	call   809f47 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80bcb4:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  80bcbb:	83 c4 10             	add    $0x10,%esp
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bcbe:	8d 75 f4             	lea    -0xc(%ebp),%esi
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80bcc1:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bcc5:	74 39                	je     80bd00 <netconn_free+0xc6>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80bcc7:	83 ec 08             	sub    $0x8,%esp
  80bcca:	56                   	push   %esi
  80bccb:	ff 73 18             	pushl  0x18(%ebx)
  80bcce:	e8 8a e7 ff ff       	call   80a45d <sys_arch_mbox_tryfetch>
  80bcd3:	83 c4 10             	add    $0x10,%esp
  80bcd6:	83 f8 ff             	cmp    $0xffffffff,%eax
  80bcd9:	74 10                	je     80bceb <netconn_free+0xb1>
      netconn_delete((struct netconn *)mem);
  80bcdb:	83 ec 0c             	sub    $0xc,%esp
  80bcde:	ff 75 f4             	pushl  -0xc(%ebp)
  80bce1:	e8 24 f0 ff ff       	call   80ad0a <netconn_delete>
  80bce6:	83 c4 10             	add    $0x10,%esp
  80bce9:	eb dc                	jmp    80bcc7 <netconn_free+0x8d>
    sys_mbox_free(conn->acceptmbox);
  80bceb:	83 ec 0c             	sub    $0xc,%esp
  80bcee:	ff 73 18             	pushl  0x18(%ebx)
  80bcf1:	e8 51 e2 ff ff       	call   809f47 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80bcf6:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  80bcfd:	83 c4 10             	add    $0x10,%esp
  sys_sem_free(conn->op_completed);
  80bd00:	83 ec 0c             	sub    $0xc,%esp
  80bd03:	ff 73 10             	pushl  0x10(%ebx)
  80bd06:	e8 b3 e1 ff ff       	call   809ebe <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80bd0b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  memp_free(MEMP_NETCONN, conn);
  80bd12:	83 c4 08             	add    $0x8,%esp
  80bd15:	53                   	push   %ebx
  80bd16:	6a 07                	push   $0x7
  80bd18:	e8 20 88 ff ff       	call   80453d <memp_free>
}
  80bd1d:	83 c4 10             	add    $0x10,%esp
  80bd20:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bd23:	5b                   	pop    %ebx
  80bd24:	5e                   	pop    %esi
  80bd25:	5d                   	pop    %ebp
  80bd26:	c3                   	ret    

0080bd27 <accept_function>:
{
  80bd27:	55                   	push   %ebp
  80bd28:	89 e5                	mov    %esp,%ebp
  80bd2a:	57                   	push   %edi
  80bd2b:	56                   	push   %esi
  80bd2c:	53                   	push   %ebx
  80bd2d:	83 ec 0c             	sub    $0xc,%esp
  80bd30:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd33:	8b 7d 10             	mov    0x10(%ebp),%edi
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bd36:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80bd3a:	74 57                	je     80bd93 <accept_function+0x6c>
  newconn = netconn_alloc(conn->type, conn->callback);
  80bd3c:	83 ec 08             	sub    $0x8,%esp
  80bd3f:	ff 73 2c             	pushl  0x2c(%ebx)
  80bd42:	ff 33                	pushl  (%ebx)
  80bd44:	e8 43 fe ff ff       	call   80bb8c <netconn_alloc>
  80bd49:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80bd4b:	83 c4 10             	add    $0x10,%esp
  80bd4e:	85 c0                	test   %eax,%eax
  80bd50:	74 72                	je     80bdc4 <accept_function+0x9d>
  newconn->pcb.tcp = newpcb;
  80bd52:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd55:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80bd58:	89 f0                	mov    %esi,%eax
  80bd5a:	e8 af f7 ff ff       	call   80b50e <setup_tcp>
  newconn->err = err;
  80bd5f:	89 f8                	mov    %edi,%eax
  80bd61:	88 46 0c             	mov    %al,0xc(%esi)
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80bd64:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bd67:	85 c0                	test   %eax,%eax
  80bd69:	74 0d                	je     80bd78 <accept_function+0x51>
  80bd6b:	83 ec 04             	sub    $0x4,%esp
  80bd6e:	6a 00                	push   $0x0
  80bd70:	6a 00                	push   $0x0
  80bd72:	53                   	push   %ebx
  80bd73:	ff d0                	call   *%eax
  80bd75:	83 c4 10             	add    $0x10,%esp
  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80bd78:	83 ec 08             	sub    $0x8,%esp
  80bd7b:	56                   	push   %esi
  80bd7c:	ff 73 18             	pushl  0x18(%ebx)
  80bd7f:	e8 f6 e4 ff ff       	call   80a27a <sys_mbox_trypost>
  80bd84:	83 c4 10             	add    $0x10,%esp
  80bd87:	84 c0                	test   %al,%al
  80bd89:	75 1f                	jne    80bdaa <accept_function+0x83>
}
  80bd8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80bd8e:	5b                   	pop    %ebx
  80bd8f:	5e                   	pop    %esi
  80bd90:	5f                   	pop    %edi
  80bd91:	5d                   	pop    %ebp
  80bd92:	c3                   	ret    
  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80bd93:	83 ec 04             	sub    $0x4,%esp
  80bd96:	68 1c 34 81 00       	push   $0x81341c
  80bd9b:	68 65 01 00 00       	push   $0x165
  80bda0:	68 46 34 81 00       	push   $0x813446
  80bda5:	e8 ef 28 00 00       	call   80e699 <_panic>
    newconn->pcb.tcp = NULL;
  80bdaa:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80bdb1:	83 ec 0c             	sub    $0xc,%esp
  80bdb4:	56                   	push   %esi
  80bdb5:	e8 80 fe ff ff       	call   80bc3a <netconn_free>
    return ERR_MEM;
  80bdba:	83 c4 10             	add    $0x10,%esp
  80bdbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bdc2:	eb c7                	jmp    80bd8b <accept_function+0x64>
    return ERR_MEM;
  80bdc4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bdc9:	eb c0                	jmp    80bd8b <accept_function+0x64>

0080bdcb <do_delconn>:
{
  80bdcb:	55                   	push   %ebp
  80bdcc:	89 e5                	mov    %esp,%ebp
  80bdce:	53                   	push   %ebx
  80bdcf:	83 ec 04             	sub    $0x4,%esp
  80bdd2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80bdd5:	8b 13                	mov    (%ebx),%edx
  80bdd7:	8b 4a 08             	mov    0x8(%edx),%ecx
  80bdda:	85 c9                	test   %ecx,%ecx
  80bddc:	74 16                	je     80bdf4 <do_delconn+0x29>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bdde:	8b 02                	mov    (%edx),%eax
  80bde0:	25 f0 00 00 00       	and    $0xf0,%eax
  80bde5:	83 f8 20             	cmp    $0x20,%eax
  80bde8:	74 53                	je     80be3d <do_delconn+0x72>
  80bdea:	83 f8 40             	cmp    $0x40,%eax
  80bded:	74 40                	je     80be2f <do_delconn+0x64>
  80bdef:	83 f8 10             	cmp    $0x10,%eax
  80bdf2:	74 62                	je     80be56 <do_delconn+0x8b>
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80bdf4:	8b 13                	mov    (%ebx),%edx
  80bdf6:	8b 42 2c             	mov    0x2c(%edx),%eax
  80bdf9:	85 c0                	test   %eax,%eax
  80bdfb:	74 23                	je     80be20 <do_delconn+0x55>
  80bdfd:	83 ec 04             	sub    $0x4,%esp
  80be00:	6a 00                	push   $0x0
  80be02:	6a 00                	push   $0x0
  80be04:	52                   	push   %edx
  80be05:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80be07:	8b 13                	mov    (%ebx),%edx
  80be09:	8b 42 2c             	mov    0x2c(%edx),%eax
  80be0c:	83 c4 10             	add    $0x10,%esp
  80be0f:	85 c0                	test   %eax,%eax
  80be11:	74 0d                	je     80be20 <do_delconn+0x55>
  80be13:	83 ec 04             	sub    $0x4,%esp
  80be16:	6a 00                	push   $0x0
  80be18:	6a 02                	push   $0x2
  80be1a:	52                   	push   %edx
  80be1b:	ff d0                	call   *%eax
  80be1d:	83 c4 10             	add    $0x10,%esp
  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80be20:	8b 03                	mov    (%ebx),%eax
  80be22:	8b 40 10             	mov    0x10(%eax),%eax
  80be25:	83 f8 ff             	cmp    $0xffffffff,%eax
  80be28:	75 3c                	jne    80be66 <do_delconn+0x9b>
}
  80be2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80be2d:	c9                   	leave  
  80be2e:	c3                   	ret    
      raw_remove(msg->conn->pcb.raw);
  80be2f:	83 ec 0c             	sub    $0xc,%esp
  80be32:	51                   	push   %ecx
  80be33:	e8 e5 21 00 00       	call   80e01d <raw_remove>
      break;
  80be38:	83 c4 10             	add    $0x10,%esp
  80be3b:	eb b7                	jmp    80bdf4 <do_delconn+0x29>
      msg->conn->pcb.udp->recv_arg = NULL;
  80be3d:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80be44:	83 ec 0c             	sub    $0xc,%esp
  80be47:	8b 03                	mov    (%ebx),%eax
  80be49:	ff 70 08             	pushl  0x8(%eax)
  80be4c:	e8 c6 d1 ff ff       	call   809017 <udp_remove>
      break;
  80be51:	83 c4 10             	add    $0x10,%esp
  80be54:	eb 9e                	jmp    80bdf4 <do_delconn+0x29>
      msg->conn->state = NETCONN_CLOSE;
  80be56:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
      do_close_internal(msg->conn);
  80be5d:	8b 03                	mov    (%ebx),%eax
  80be5f:	e8 82 f9 ff ff       	call   80b7e6 <do_close_internal>
      return;
  80be64:	eb c4                	jmp    80be2a <do_delconn+0x5f>
    sys_sem_signal(msg->conn->op_completed);
  80be66:	83 ec 0c             	sub    $0xc,%esp
  80be69:	50                   	push   %eax
  80be6a:	e8 8b e2 ff ff       	call   80a0fa <sys_sem_signal>
  80be6f:	83 c4 10             	add    $0x10,%esp
  80be72:	eb b6                	jmp    80be2a <do_delconn+0x5f>

0080be74 <do_bind>:
{
  80be74:	55                   	push   %ebp
  80be75:	89 e5                	mov    %esp,%ebp
  80be77:	56                   	push   %esi
  80be78:	53                   	push   %ebx
  80be79:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80be7c:	8b 33                	mov    (%ebx),%esi
  80be7e:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80be82:	7c 1d                	jl     80bea1 <do_bind+0x2d>
    if (msg->conn->pcb.tcp != NULL) {
  80be84:	8b 56 08             	mov    0x8(%esi),%edx
  80be87:	85 d2                	test   %edx,%edx
  80be89:	74 73                	je     80befe <do_bind+0x8a>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80be8b:	8b 06                	mov    (%esi),%eax
  80be8d:	25 f0 00 00 00       	and    $0xf0,%eax
  80be92:	83 f8 20             	cmp    $0x20,%eax
  80be95:	74 35                	je     80becc <do_bind+0x58>
  80be97:	83 f8 40             	cmp    $0x40,%eax
  80be9a:	74 1c                	je     80beb8 <do_bind+0x44>
  80be9c:	83 f8 10             	cmp    $0x10,%eax
  80be9f:	74 44                	je     80bee5 <do_bind+0x71>
  TCPIP_APIMSG_ACK(msg);
  80bea1:	83 ec 0c             	sub    $0xc,%esp
  80bea4:	8b 03                	mov    (%ebx),%eax
  80bea6:	ff 70 10             	pushl  0x10(%eax)
  80bea9:	e8 4c e2 ff ff       	call   80a0fa <sys_sem_signal>
}
  80beae:	83 c4 10             	add    $0x10,%esp
  80beb1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80beb4:	5b                   	pop    %ebx
  80beb5:	5e                   	pop    %esi
  80beb6:	5d                   	pop    %ebp
  80beb7:	c3                   	ret    
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80beb8:	83 ec 08             	sub    $0x8,%esp
  80bebb:	ff 73 04             	pushl  0x4(%ebx)
  80bebe:	52                   	push   %edx
  80bebf:	e8 e6 1f 00 00       	call   80deaa <raw_bind>
  80bec4:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bec7:	83 c4 10             	add    $0x10,%esp
  80beca:	eb d5                	jmp    80bea1 <do_bind+0x2d>
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80becc:	83 ec 04             	sub    $0x4,%esp
  80becf:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bed3:	50                   	push   %eax
  80bed4:	ff 73 04             	pushl  0x4(%ebx)
  80bed7:	52                   	push   %edx
  80bed8:	e8 ea cd ff ff       	call   808cc7 <udp_bind>
  80bedd:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bee0:	83 c4 10             	add    $0x10,%esp
  80bee3:	eb bc                	jmp    80bea1 <do_bind+0x2d>
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bee5:	83 ec 04             	sub    $0x4,%esp
  80bee8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80beec:	50                   	push   %eax
  80beed:	ff 73 04             	pushl  0x4(%ebx)
  80bef0:	52                   	push   %edx
  80bef1:	e8 44 95 ff ff       	call   80543a <tcp_bind>
  80bef6:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80bef9:	83 c4 10             	add    $0x10,%esp
  80befc:	eb a3                	jmp    80bea1 <do_bind+0x2d>
      msg->conn->err = ERR_VAL;
  80befe:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
  80bf02:	eb 9d                	jmp    80bea1 <do_bind+0x2d>

0080bf04 <do_connect>:
{
  80bf04:	55                   	push   %ebp
  80bf05:	89 e5                	mov    %esp,%ebp
  80bf07:	56                   	push   %esi
  80bf08:	53                   	push   %ebx
  80bf09:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80bf0c:	8b 33                	mov    (%ebx),%esi
  80bf0e:	8b 56 08             	mov    0x8(%esi),%edx
  80bf11:	85 d2                	test   %edx,%edx
  80bf13:	74 1d                	je     80bf32 <do_connect+0x2e>
  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80bf15:	8b 06                	mov    (%esi),%eax
  80bf17:	25 f0 00 00 00       	and    $0xf0,%eax
  80bf1c:	83 f8 20             	cmp    $0x20,%eax
  80bf1f:	74 42                	je     80bf63 <do_connect+0x5f>
  80bf21:	83 f8 40             	cmp    $0x40,%eax
  80bf24:	74 1c                	je     80bf42 <do_connect+0x3e>
  80bf26:	83 f8 10             	cmp    $0x10,%eax
  80bf29:	74 5e                	je     80bf89 <do_connect+0x85>
}
  80bf2b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80bf2e:	5b                   	pop    %ebx
  80bf2f:	5e                   	pop    %esi
  80bf30:	5d                   	pop    %ebp
  80bf31:	c3                   	ret    
    sys_sem_signal(msg->conn->op_completed);
  80bf32:	83 ec 0c             	sub    $0xc,%esp
  80bf35:	ff 76 10             	pushl  0x10(%esi)
  80bf38:	e8 bd e1 ff ff       	call   80a0fa <sys_sem_signal>
    return;
  80bf3d:	83 c4 10             	add    $0x10,%esp
  80bf40:	eb e9                	jmp    80bf2b <do_connect+0x27>
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80bf42:	83 ec 08             	sub    $0x8,%esp
  80bf45:	ff 73 04             	pushl  0x4(%ebx)
  80bf48:	52                   	push   %edx
  80bf49:	e8 79 1f 00 00       	call   80dec7 <raw_connect>
  80bf4e:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bf51:	83 c4 04             	add    $0x4,%esp
  80bf54:	8b 03                	mov    (%ebx),%eax
  80bf56:	ff 70 10             	pushl  0x10(%eax)
  80bf59:	e8 9c e1 ff ff       	call   80a0fa <sys_sem_signal>
    break;
  80bf5e:	83 c4 10             	add    $0x10,%esp
  80bf61:	eb c8                	jmp    80bf2b <do_connect+0x27>
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80bf63:	83 ec 04             	sub    $0x4,%esp
  80bf66:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bf6a:	50                   	push   %eax
  80bf6b:	ff 73 04             	pushl  0x4(%ebx)
  80bf6e:	52                   	push   %edx
  80bf6f:	e8 03 d0 ff ff       	call   808f77 <udp_connect>
  80bf74:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80bf77:	83 c4 04             	add    $0x4,%esp
  80bf7a:	8b 03                	mov    (%ebx),%eax
  80bf7c:	ff 70 10             	pushl  0x10(%eax)
  80bf7f:	e8 76 e1 ff ff       	call   80a0fa <sys_sem_signal>
    break;
  80bf84:	83 c4 10             	add    $0x10,%esp
  80bf87:	eb a2                	jmp    80bf2b <do_connect+0x27>
    msg->conn->state = NETCONN_CONNECT;
  80bf89:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80bf90:	8b 03                	mov    (%ebx),%eax
  80bf92:	e8 77 f5 ff ff       	call   80b50e <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80bf97:	8b 33                	mov    (%ebx),%esi
  80bf99:	68 61 b5 80 00       	push   $0x80b561
  80bf9e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80bfa2:	50                   	push   %eax
  80bfa3:	ff 73 04             	pushl  0x4(%ebx)
  80bfa6:	ff 76 08             	pushl  0x8(%esi)
  80bfa9:	e8 c1 a3 ff ff       	call   80636f <tcp_connect>
  80bfae:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80bfb1:	83 c4 10             	add    $0x10,%esp
  80bfb4:	e9 72 ff ff ff       	jmp    80bf2b <do_connect+0x27>

0080bfb9 <do_disconnect>:
{
  80bfb9:	55                   	push   %ebp
  80bfba:	89 e5                	mov    %esp,%ebp
  80bfbc:	53                   	push   %ebx
  80bfbd:	83 ec 04             	sub    $0x4,%esp
  80bfc0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80bfc3:	8b 13                	mov    (%ebx),%edx
  80bfc5:	8b 02                	mov    (%edx),%eax
  80bfc7:	25 f0 00 00 00       	and    $0xf0,%eax
  80bfcc:	83 f8 20             	cmp    $0x20,%eax
  80bfcf:	74 15                	je     80bfe6 <do_disconnect+0x2d>
  TCPIP_APIMSG_ACK(msg);
  80bfd1:	83 ec 0c             	sub    $0xc,%esp
  80bfd4:	8b 03                	mov    (%ebx),%eax
  80bfd6:	ff 70 10             	pushl  0x10(%eax)
  80bfd9:	e8 1c e1 ff ff       	call   80a0fa <sys_sem_signal>
}
  80bfde:	83 c4 10             	add    $0x10,%esp
  80bfe1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80bfe4:	c9                   	leave  
  80bfe5:	c3                   	ret    
    udp_disconnect(msg->conn->pcb.udp);
  80bfe6:	83 ec 0c             	sub    $0xc,%esp
  80bfe9:	ff 72 08             	pushl  0x8(%edx)
  80bfec:	e8 f7 cf ff ff       	call   808fe8 <udp_disconnect>
  80bff1:	83 c4 10             	add    $0x10,%esp
  80bff4:	eb db                	jmp    80bfd1 <do_disconnect+0x18>

0080bff6 <do_listen>:
{
  80bff6:	55                   	push   %ebp
  80bff7:	89 e5                	mov    %esp,%ebp
  80bff9:	57                   	push   %edi
  80bffa:	56                   	push   %esi
  80bffb:	53                   	push   %ebx
  80bffc:	83 ec 0c             	sub    $0xc,%esp
  80bfff:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c002:	8b 03                	mov    (%ebx),%eax
  80c004:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c008:	7c 0c                	jl     80c016 <do_listen+0x20>
    if (msg->conn->pcb.tcp != NULL) {
  80c00a:	8b 50 08             	mov    0x8(%eax),%edx
  80c00d:	85 d2                	test   %edx,%edx
  80c00f:	74 05                	je     80c016 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
  80c011:	83 38 10             	cmpl   $0x10,(%eax)
  80c014:	74 18                	je     80c02e <do_listen+0x38>
  TCPIP_APIMSG_ACK(msg);
  80c016:	83 ec 0c             	sub    $0xc,%esp
  80c019:	8b 03                	mov    (%ebx),%eax
  80c01b:	ff 70 10             	pushl  0x10(%eax)
  80c01e:	e8 d7 e0 ff ff       	call   80a0fa <sys_sem_signal>
}
  80c023:	83 c4 10             	add    $0x10,%esp
  80c026:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c029:	5b                   	pop    %ebx
  80c02a:	5e                   	pop    %esi
  80c02b:	5f                   	pop    %edi
  80c02c:	5d                   	pop    %ebp
  80c02d:	c3                   	ret    
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80c02e:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80c032:	74 06                	je     80c03a <do_listen+0x44>
          msg->conn->err = ERR_CONN;
  80c034:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
  80c038:	eb dc                	jmp    80c016 <do_listen+0x20>
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80c03a:	83 ec 08             	sub    $0x8,%esp
  80c03d:	68 ff 00 00 00       	push   $0xff
  80c042:	52                   	push   %edx
  80c043:	e8 3d 95 ff ff       	call   805585 <tcp_listen_with_backlog>
  80c048:	89 c6                	mov    %eax,%esi
          if (lpcb == NULL) {
  80c04a:	83 c4 10             	add    $0x10,%esp
  80c04d:	85 c0                	test   %eax,%eax
  80c04f:	74 4e                	je     80c09f <do_listen+0xa9>
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80c051:	8b 03                	mov    (%ebx),%eax
  80c053:	8b 40 14             	mov    0x14(%eax),%eax
  80c056:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c059:	75 4f                	jne    80c0aa <do_listen+0xb4>
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80c05b:	8b 3b                	mov    (%ebx),%edi
  80c05d:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80c061:	74 5e                	je     80c0c1 <do_listen+0xcb>
            if (msg->conn->err == ERR_OK) {
  80c063:	8b 03                	mov    (%ebx),%eax
  80c065:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c069:	75 ab                	jne    80c016 <do_listen+0x20>
              msg->conn->state = NETCONN_LISTEN;
  80c06b:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80c072:	8b 03                	mov    (%ebx),%eax
  80c074:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80c077:	8b 03                	mov    (%ebx),%eax
  80c079:	83 ec 08             	sub    $0x8,%esp
  80c07c:	50                   	push   %eax
  80c07d:	ff 70 08             	pushl  0x8(%eax)
  80c080:	e8 d2 97 ff ff       	call   805857 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80c085:	83 c4 08             	add    $0x8,%esp
  80c088:	68 27 bd 80 00       	push   $0x80bd27
  80c08d:	8b 03                	mov    (%ebx),%eax
  80c08f:	ff 70 08             	pushl  0x8(%eax)
  80c092:	e8 01 98 ff ff       	call   805898 <tcp_accept>
  80c097:	83 c4 10             	add    $0x10,%esp
  80c09a:	e9 77 ff ff ff       	jmp    80c016 <do_listen+0x20>
            msg->conn->err = ERR_MEM;
  80c09f:	8b 03                	mov    (%ebx),%eax
  80c0a1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c0a5:	e9 6c ff ff ff       	jmp    80c016 <do_listen+0x20>
              sys_mbox_free(msg->conn->recvmbox);
  80c0aa:	83 ec 0c             	sub    $0xc,%esp
  80c0ad:	50                   	push   %eax
  80c0ae:	e8 94 de ff ff       	call   809f47 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80c0b3:	8b 03                	mov    (%ebx),%eax
  80c0b5:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
  80c0bc:	83 c4 10             	add    $0x10,%esp
  80c0bf:	eb 9a                	jmp    80c05b <do_listen+0x65>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80c0c1:	83 ec 0c             	sub    $0xc,%esp
  80c0c4:	6a 00                	push   $0x0
  80c0c6:	e8 1b df ff ff       	call   809fe6 <sys_mbox_new>
  80c0cb:	89 47 18             	mov    %eax,0x18(%edi)
  80c0ce:	83 c4 10             	add    $0x10,%esp
  80c0d1:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c0d4:	75 8d                	jne    80c063 <do_listen+0x6d>
                msg->conn->err = ERR_MEM;
  80c0d6:	8b 03                	mov    (%ebx),%eax
  80c0d8:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c0dc:	eb 85                	jmp    80c063 <do_listen+0x6d>

0080c0de <do_send>:
{
  80c0de:	55                   	push   %ebp
  80c0df:	89 e5                	mov    %esp,%ebp
  80c0e1:	57                   	push   %edi
  80c0e2:	56                   	push   %esi
  80c0e3:	53                   	push   %ebx
  80c0e4:	83 ec 0c             	sub    $0xc,%esp
  80c0e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c0ea:	8b 33                	mov    (%ebx),%esi
  80c0ec:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c0f0:	7c 34                	jl     80c126 <do_send+0x48>
    if (msg->conn->pcb.tcp != NULL) {
  80c0f2:	8b 56 08             	mov    0x8(%esi),%edx
  80c0f5:	85 d2                	test   %edx,%edx
  80c0f7:	74 2d                	je     80c126 <do_send+0x48>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c0f9:	8b 06                	mov    (%esi),%eax
  80c0fb:	25 f0 00 00 00       	and    $0xf0,%eax
  80c100:	83 f8 20             	cmp    $0x20,%eax
  80c103:	74 4c                	je     80c151 <do_send+0x73>
  80c105:	83 f8 40             	cmp    $0x40,%eax
  80c108:	75 1c                	jne    80c126 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c10a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c10d:	8b 48 08             	mov    0x8(%eax),%ecx
  80c110:	85 c9                	test   %ecx,%ecx
  80c112:	74 2a                	je     80c13e <do_send+0x60>
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80c114:	83 ec 04             	sub    $0x4,%esp
  80c117:	51                   	push   %ecx
  80c118:	ff 30                	pushl  (%eax)
  80c11a:	52                   	push   %edx
  80c11b:	e8 d9 1d 00 00       	call   80def9 <raw_sendto>
  80c120:	88 46 0c             	mov    %al,0xc(%esi)
  80c123:	83 c4 10             	add    $0x10,%esp
  TCPIP_APIMSG_ACK(msg);
  80c126:	83 ec 0c             	sub    $0xc,%esp
  80c129:	8b 03                	mov    (%ebx),%eax
  80c12b:	ff 70 10             	pushl  0x10(%eax)
  80c12e:	e8 c7 df ff ff       	call   80a0fa <sys_sem_signal>
}
  80c133:	83 c4 10             	add    $0x10,%esp
  80c136:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c139:	5b                   	pop    %ebx
  80c13a:	5e                   	pop    %esi
  80c13b:	5f                   	pop    %edi
  80c13c:	5d                   	pop    %ebp
  80c13d:	c3                   	ret    
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80c13e:	83 ec 08             	sub    $0x8,%esp
  80c141:	ff 30                	pushl  (%eax)
  80c143:	52                   	push   %edx
  80c144:	e8 bc 1e 00 00       	call   80e005 <raw_send>
  80c149:	88 46 0c             	mov    %al,0xc(%esi)
  80c14c:	83 c4 10             	add    $0x10,%esp
  80c14f:	eb d5                	jmp    80c126 <do_send+0x48>
        if (msg->msg.b->addr == NULL) {
  80c151:	8b 43 04             	mov    0x4(%ebx),%eax
  80c154:	8b 48 08             	mov    0x8(%eax),%ecx
  80c157:	85 c9                	test   %ecx,%ecx
  80c159:	74 16                	je     80c171 <do_send+0x93>
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80c15b:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80c15f:	57                   	push   %edi
  80c160:	51                   	push   %ecx
  80c161:	ff 30                	pushl  (%eax)
  80c163:	52                   	push   %edx
  80c164:	e8 b1 cd ff ff       	call   808f1a <udp_sendto>
  80c169:	88 46 0c             	mov    %al,0xc(%esi)
  80c16c:	83 c4 10             	add    $0x10,%esp
  80c16f:	eb b5                	jmp    80c126 <do_send+0x48>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80c171:	83 ec 08             	sub    $0x8,%esp
  80c174:	ff 30                	pushl  (%eax)
  80c176:	52                   	push   %edx
  80c177:	e8 de cd ff ff       	call   808f5a <udp_send>
  80c17c:	88 46 0c             	mov    %al,0xc(%esi)
  80c17f:	83 c4 10             	add    $0x10,%esp
  80c182:	eb a2                	jmp    80c126 <do_send+0x48>

0080c184 <do_recv>:
{
  80c184:	55                   	push   %ebp
  80c185:	89 e5                	mov    %esp,%ebp
  80c187:	53                   	push   %ebx
  80c188:	83 ec 04             	sub    $0x4,%esp
  80c18b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c18e:	8b 03                	mov    (%ebx),%eax
  80c190:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c194:	7c 0c                	jl     80c1a2 <do_recv+0x1e>
    if (msg->conn->pcb.tcp != NULL) {
  80c196:	8b 50 08             	mov    0x8(%eax),%edx
  80c199:	85 d2                	test   %edx,%edx
  80c19b:	74 05                	je     80c1a2 <do_recv+0x1e>
      if (msg->conn->type == NETCONN_TCP) {
  80c19d:	83 38 10             	cmpl   $0x10,(%eax)
  80c1a0:	74 15                	je     80c1b7 <do_recv+0x33>
  TCPIP_APIMSG_ACK(msg);
  80c1a2:	83 ec 0c             	sub    $0xc,%esp
  80c1a5:	8b 03                	mov    (%ebx),%eax
  80c1a7:	ff 70 10             	pushl  0x10(%eax)
  80c1aa:	e8 4b df ff ff       	call   80a0fa <sys_sem_signal>
}
  80c1af:	83 c4 10             	add    $0x10,%esp
  80c1b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80c1b5:	c9                   	leave  
  80c1b6:	c3                   	ret    
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80c1b7:	83 ec 08             	sub    $0x8,%esp
  80c1ba:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80c1be:	50                   	push   %eax
  80c1bf:	52                   	push   %edx
  80c1c0:	e8 d8 94 ff ff       	call   80569d <tcp_recved>
  80c1c5:	83 c4 10             	add    $0x10,%esp
  80c1c8:	eb d8                	jmp    80c1a2 <do_recv+0x1e>

0080c1ca <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80c1ca:	55                   	push   %ebp
  80c1cb:	89 e5                	mov    %esp,%ebp
  80c1cd:	83 ec 08             	sub    $0x8,%esp
  80c1d0:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c1d3:	8b 02                	mov    (%edx),%eax
  80c1d5:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80c1d9:	7c 0f                	jl     80c1ea <do_write+0x20>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c1db:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c1df:	74 05                	je     80c1e6 <do_write+0x1c>
  80c1e1:	83 38 10             	cmpl   $0x10,(%eax)
  80c1e4:	74 16                	je     80c1fc <do_write+0x32>
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80c1e6:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c1ea:	83 ec 0c             	sub    $0xc,%esp
  80c1ed:	8b 02                	mov    (%edx),%eax
  80c1ef:	ff 70 10             	pushl  0x10(%eax)
  80c1f2:	e8 03 df ff ff       	call   80a0fa <sys_sem_signal>
  80c1f7:	83 c4 10             	add    $0x10,%esp
}
  80c1fa:	c9                   	leave  
  80c1fb:	c3                   	ret    
      msg->conn->state = NETCONN_WRITE;
  80c1fc:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      msg->conn->write_msg = msg;
  80c203:	8b 02                	mov    (%edx),%eax
  80c205:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80c208:	8b 02                	mov    (%edx),%eax
  80c20a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
      do_writemore(msg->conn);
  80c211:	8b 02                	mov    (%edx),%eax
  80c213:	e8 67 f4 ff ff       	call   80b67f <do_writemore>
      return;
  80c218:	eb e0                	jmp    80c1fa <do_write+0x30>

0080c21a <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80c21a:	55                   	push   %ebp
  80c21b:	89 e5                	mov    %esp,%ebp
  80c21d:	83 ec 08             	sub    $0x8,%esp
  80c220:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80c223:	8b 08                	mov    (%eax),%ecx
  80c225:	8b 51 08             	mov    0x8(%ecx),%edx
  80c228:	85 d2                	test   %edx,%edx
  80c22a:	0f 84 a8 00 00 00    	je     80c2d8 <do_getaddr+0xbe>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c230:	8b 48 04             	mov    0x4(%eax),%ecx
  80c233:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c237:	74 2f                	je     80c268 <do_getaddr+0x4e>
  80c239:	8b 12                	mov    (%edx),%edx
  80c23b:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c23d:	8b 08                	mov    (%eax),%ecx
  80c23f:	8b 11                	mov    (%ecx),%edx
  80c241:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c247:	83 fa 20             	cmp    $0x20,%edx
  80c24a:	74 3e                	je     80c28a <do_getaddr+0x70>
  80c24c:	83 fa 40             	cmp    $0x40,%edx
  80c24f:	74 1e                	je     80c26f <do_getaddr+0x55>
  80c251:	83 fa 10             	cmp    $0x10,%edx
  80c254:	74 64                	je     80c2ba <do_getaddr+0xa0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
  80c256:	83 ec 0c             	sub    $0xc,%esp
  80c259:	8b 00                	mov    (%eax),%eax
  80c25b:	ff 70 10             	pushl  0x10(%eax)
  80c25e:	e8 97 de ff ff       	call   80a0fa <sys_sem_signal>
}
  80c263:	83 c4 10             	add    $0x10,%esp
  80c266:	c9                   	leave  
  80c267:	c3                   	ret    
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80c268:	8b 52 04             	mov    0x4(%edx),%edx
  80c26b:	89 11                	mov    %edx,(%ecx)
  80c26d:	eb ce                	jmp    80c23d <do_getaddr+0x23>
      if (msg->msg.ad.local) {
  80c26f:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c273:	74 0f                	je     80c284 <do_getaddr+0x6a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80c275:	8b 50 08             	mov    0x8(%eax),%edx
  80c278:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c27b:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80c27f:	66 89 0a             	mov    %cx,(%edx)
  80c282:	eb d2                	jmp    80c256 <do_getaddr+0x3c>
        msg->conn->err = ERR_CONN;
  80c284:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c288:	eb cc                	jmp    80c256 <do_getaddr+0x3c>
      if (msg->msg.ad.local) {
  80c28a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c28e:	74 0f                	je     80c29f <do_getaddr+0x85>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80c290:	8b 50 08             	mov    0x8(%eax),%edx
  80c293:	8b 49 08             	mov    0x8(%ecx),%ecx
  80c296:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80c29a:	66 89 0a             	mov    %cx,(%edx)
  80c29d:	eb b7                	jmp    80c256 <do_getaddr+0x3c>
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80c29f:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2a2:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80c2a6:	75 06                	jne    80c2ae <do_getaddr+0x94>
          msg->conn->err = ERR_CONN;
  80c2a8:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c2ac:	eb a8                	jmp    80c256 <do_getaddr+0x3c>
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80c2ae:	8b 48 08             	mov    0x8(%eax),%ecx
  80c2b1:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80c2b5:	66 89 11             	mov    %dx,(%ecx)
  80c2b8:	eb 9c                	jmp    80c256 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c2ba:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80c2be:	74 0f                	je     80c2cf <do_getaddr+0xb5>
  80c2c0:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2c3:	0f b7 4a 1c          	movzwl 0x1c(%edx),%ecx
  80c2c7:	8b 50 08             	mov    0x8(%eax),%edx
  80c2ca:	66 89 0a             	mov    %cx,(%edx)
      break;
  80c2cd:	eb 87                	jmp    80c256 <do_getaddr+0x3c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80c2cf:	8b 51 08             	mov    0x8(%ecx),%edx
  80c2d2:	0f b7 4a 1e          	movzwl 0x1e(%edx),%ecx
  80c2d6:	eb ef                	jmp    80c2c7 <do_getaddr+0xad>
    msg->conn->err = ERR_CONN;
  80c2d8:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80c2dc:	e9 75 ff ff ff       	jmp    80c256 <do_getaddr+0x3c>

0080c2e1 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80c2e1:	55                   	push   %ebp
  80c2e2:	89 e5                	mov    %esp,%ebp
  80c2e4:	83 ec 08             	sub    $0x8,%esp
  80c2e7:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80c2ea:	8b 02                	mov    (%edx),%eax
  80c2ec:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c2f0:	74 05                	je     80c2f7 <do_close+0x16>
  80c2f2:	83 38 10             	cmpl   $0x10,(%eax)
  80c2f5:	74 16                	je     80c30d <do_close+0x2c>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80c2f7:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80c2fb:	83 ec 0c             	sub    $0xc,%esp
  80c2fe:	8b 02                	mov    (%edx),%eax
  80c300:	ff 70 10             	pushl  0x10(%eax)
  80c303:	e8 f2 dd ff ff       	call   80a0fa <sys_sem_signal>
  80c308:	83 c4 10             	add    $0x10,%esp
  }
}
  80c30b:	c9                   	leave  
  80c30c:	c3                   	ret    
      msg->conn->state = NETCONN_CLOSE;
  80c30d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c314:	8b 02                	mov    (%edx),%eax
  80c316:	e8 cb f4 ff ff       	call   80b7e6 <do_close_internal>
  80c31b:	eb ee                	jmp    80c30b <do_close+0x2a>

0080c31d <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80c31d:	55                   	push   %ebp
  80c31e:	89 e5                	mov    %esp,%ebp
  80c320:	57                   	push   %edi
  80c321:	56                   	push   %esi
  80c322:	53                   	push   %ebx
  80c323:	83 ec 18             	sub    $0x18,%esp
  80c326:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c328:	8b 35 b0 b1 b3 00    	mov    0xb3b1b0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80c32e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80c332:	50                   	push   %eax
  80c333:	e8 39 b4 ff ff       	call   807771 <ntohs>
  80c338:	83 c4 10             	add    $0x10,%esp
  80c33b:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80c33f:	0f 86 84 00 00 00    	jbe    80c3c9 <tcp_parseopt+0xac>
  opts = (u8_t *)tcphdr + TCP_HLEN;
  80c345:	83 c6 14             	add    $0x14,%esi
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c348:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c34d:	eb 10                	jmp    80c35f <tcp_parseopt+0x42>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
  80c34f:	83 c3 01             	add    $0x1,%ebx
  80c352:	eb 0b                	jmp    80c35f <tcp_parseopt+0x42>
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;

        /* And we are done processing options. */
        break;
      } else {
        if (opts[c + 1] == 0) {
  80c354:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80c359:	84 c0                	test   %al,%al
  80c35b:	74 6c                	je     80c3c9 <tcp_parseopt+0xac>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80c35d:	01 c3                	add    %eax,%ebx
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80c35f:	83 ec 0c             	sub    $0xc,%esp
  80c362:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80c367:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c36b:	50                   	push   %eax
  80c36c:	e8 00 b4 ff ff       	call   807771 <ntohs>
  80c371:	0f b6 d3             	movzbl %bl,%edx
  80c374:	66 c1 e8 0c          	shr    $0xc,%ax
  80c378:	0f b7 c0             	movzwl %ax,%eax
  80c37b:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80c382:	83 c4 10             	add    $0x10,%esp
  80c385:	39 c2                	cmp    %eax,%edx
  80c387:	7d 40                	jge    80c3c9 <tcp_parseopt+0xac>
      opt = opts[c];
  80c389:	0f b6 d3             	movzbl %bl,%edx
  80c38c:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80c390:	84 c0                	test   %al,%al
  80c392:	74 35                	je     80c3c9 <tcp_parseopt+0xac>
      } else if (opt == 0x01) {
  80c394:	3c 01                	cmp    $0x1,%al
  80c396:	74 b7                	je     80c34f <tcp_parseopt+0x32>
      } else if (opt == 0x02 &&
  80c398:	3c 02                	cmp    $0x2,%al
  80c39a:	75 b8                	jne    80c354 <tcp_parseopt+0x37>
  80c39c:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80c3a1:	75 b1                	jne    80c354 <tcp_parseopt+0x37>
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80c3a3:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
  80c3a8:	c1 e1 08             	shl    $0x8,%ecx
  80c3ab:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80c3b0:	89 d0                	mov    %edx,%eax
  80c3b2:	09 c8                	or     %ecx,%eax
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80c3b4:	83 e8 01             	sub    $0x1,%eax
  80c3b7:	09 d1                	or     %edx,%ecx
  80c3b9:	66 3d b4 05          	cmp    $0x5b4,%ax
  80c3bd:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80c3c2:	0f 42 c1             	cmovb  %ecx,%eax
  80c3c5:	66 89 47 34          	mov    %ax,0x34(%edi)
      }
    }
  }
}
  80c3c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80c3cc:	5b                   	pop    %ebx
  80c3cd:	5e                   	pop    %esi
  80c3ce:	5f                   	pop    %edi
  80c3cf:	5d                   	pop    %ebp
  80c3d0:	c3                   	ret    

0080c3d1 <tcp_receive>:
{
  80c3d1:	55                   	push   %ebp
  80c3d2:	89 e5                	mov    %esp,%ebp
  80c3d4:	57                   	push   %edi
  80c3d5:	56                   	push   %esi
  80c3d6:	53                   	push   %ebx
  80c3d7:	83 ec 1c             	sub    $0x1c,%esp
  80c3da:	89 c7                	mov    %eax,%edi
  if (flags & TCP_ACK) {
  80c3dc:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80c3e3:	0f 84 22 04 00 00    	je     80c80b <tcp_receive+0x43a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c3e9:	0f b7 48 5c          	movzwl 0x5c(%eax),%ecx
  80c3ed:	8b 50 60             	mov    0x60(%eax),%edx
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80c3f0:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80c3f5:	39 c2                	cmp    %eax,%edx
  80c3f7:	78 53                	js     80c44c <tcp_receive+0x7b>
  80c3f9:	39 c2                	cmp    %eax,%edx
  80c3fb:	74 36                	je     80c433 <tcp_receive+0x62>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c3fd:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c403:	39 77 64             	cmp    %esi,0x64(%edi)
  80c406:	74 38                	je     80c440 <tcp_receive+0x6f>
    if (pcb->lastack == ackno) {
  80c408:	8b 5f 48             	mov    0x48(%edi),%ebx
  80c40b:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c410:	39 c3                	cmp    %eax,%ebx
  80c412:	74 68                	je     80c47c <tcp_receive+0xab>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80c414:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c417:	39 da                	cmp    %ebx,%edx
  80c419:	78 0d                	js     80c428 <tcp_receive+0x57>
  80c41b:	89 c2                	mov    %eax,%edx
  80c41d:	2b 57 58             	sub    0x58(%edi),%edx
  80c420:	85 d2                	test   %edx,%edx
  80c422:	0f 8e fa 00 00 00    	jle    80c522 <tcp_receive+0x151>
      pcb->acked = 0;
  80c428:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80c42e:	e9 c2 02 00 00       	jmp    80c6f5 <tcp_receive+0x324>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80c433:	8b 35 a4 b1 b3 00    	mov    0xb3b1a4,%esi
  80c439:	39 77 64             	cmp    %esi,0x64(%edi)
  80c43c:	79 bf                	jns    80c3fd <tcp_receive+0x2c>
  80c43e:	eb 0c                	jmp    80c44c <tcp_receive+0x7b>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80c440:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c446:	66 3b 4b 0e          	cmp    0xe(%ebx),%cx
  80c44a:	73 bc                	jae    80c408 <tcp_receive+0x37>
      pcb->snd_wnd = tcphdr->wnd;
  80c44c:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80c452:	0f b7 5b 0e          	movzwl 0xe(%ebx),%ebx
  80c456:	66 89 5f 5c          	mov    %bx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80c45a:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80c45d:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c462:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80c465:	66 85 db             	test   %bx,%bx
  80c468:	74 9e                	je     80c408 <tcp_receive+0x37>
  80c46a:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80c471:	74 95                	je     80c408 <tcp_receive+0x37>
          pcb->persist_backoff = 0;
  80c473:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
  80c47a:	eb 8c                	jmp    80c408 <tcp_receive+0x37>
      pcb->acked = 0;
  80c47c:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c482:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c486:	03 47 60             	add    0x60(%edi),%eax
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80c489:	0f b7 c9             	movzwl %cx,%ecx
  80c48c:	01 ca                	add    %ecx,%edx
      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80c48e:	39 d0                	cmp    %edx,%eax
  80c490:	0f 85 5f 02 00 00    	jne    80c6f5 <tcp_receive+0x324>
        ++pcb->dupacks;
  80c496:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80c49a:	83 c0 01             	add    $0x1,%eax
  80c49d:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80c4a0:	3c 02                	cmp    $0x2,%al
  80c4a2:	0f 86 4d 02 00 00    	jbe    80c6f5 <tcp_receive+0x324>
  80c4a8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c4ac:	0f 84 43 02 00 00    	je     80c6f5 <tcp_receive+0x324>
          if (!(pcb->flags & TF_INFR)) {
  80c4b2:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80c4b6:	74 1c                	je     80c4d4 <tcp_receive+0x103>
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c4b8:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80c4bc:	89 d0                	mov    %edx,%eax
  80c4be:	66 03 47 34          	add    0x34(%edi),%ax
  80c4c2:	66 39 c2             	cmp    %ax,%dx
  80c4c5:	0f 83 2a 02 00 00    	jae    80c6f5 <tcp_receive+0x324>
              pcb->cwnd += pcb->mss;
  80c4cb:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c4cf:	e9 21 02 00 00       	jmp    80c6f5 <tcp_receive+0x324>
            tcp_rexmit(pcb);
  80c4d4:	83 ec 0c             	sub    $0xc,%esp
  80c4d7:	57                   	push   %edi
  80c4d8:	e8 0a c2 ff ff       	call   8086e7 <tcp_rexmit>
            if (pcb->cwnd > pcb->snd_wnd)
  80c4dd:	0f b7 5f 4e          	movzwl 0x4e(%edi),%ebx
  80c4e1:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80c4e5:	83 c4 10             	add    $0x10,%esp
              pcb->ssthresh = pcb->snd_wnd / 2;
  80c4e8:	89 c2                	mov    %eax,%edx
  80c4ea:	66 d1 ea             	shr    %dx
  80c4ed:	89 d9                	mov    %ebx,%ecx
  80c4ef:	66 d1 e9             	shr    %cx
  80c4f2:	66 39 c3             	cmp    %ax,%bx
  80c4f5:	0f 47 ca             	cmova  %edx,%ecx
            if (pcb->ssthresh < 2*pcb->mss) {
  80c4f8:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c4fc:	0f b7 f1             	movzwl %cx,%esi
  80c4ff:	0f b7 d8             	movzwl %ax,%ebx
  80c502:	01 db                	add    %ebx,%ebx
              pcb->ssthresh = 2*pcb->mss;
  80c504:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80c507:	39 de                	cmp    %ebx,%esi
  80c509:	0f 4d d1             	cmovge %ecx,%edx
  80c50c:	66 89 57 50          	mov    %dx,0x50(%edi)
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80c510:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80c513:	01 d0                	add    %edx,%eax
  80c515:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80c519:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80c51d:	e9 d3 01 00 00       	jmp    80c6f5 <tcp_receive+0x324>
      if (pcb->flags & TF_INFR) {
  80c522:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80c526:	f6 c2 04             	test   $0x4,%dl
  80c529:	74 0e                	je     80c539 <tcp_receive+0x168>
        pcb->flags &= ~TF_INFR;
  80c52b:	83 e2 fb             	and    $0xfffffffb,%edx
  80c52e:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80c531:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80c535:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      pcb->nrtx = 0;
  80c539:	c6 47 46 00          	movb   $0x0,0x46(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c53d:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c541:	66 c1 fa 03          	sar    $0x3,%dx
  80c545:	66 03 57 42          	add    0x42(%edi),%dx
  80c549:	66 89 57 44          	mov    %dx,0x44(%edi)
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80c54d:	89 c2                	mov    %eax,%edx
  80c54f:	29 da                	sub    %ebx,%edx
  80c551:	66 89 57 6c          	mov    %dx,0x6c(%edi)
      pcb->snd_buf += pcb->acked;
  80c555:	66 01 57 6e          	add    %dx,0x6e(%edi)
      pcb->dupacks = 0;
  80c559:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80c55d:	89 47 48             	mov    %eax,0x48(%edi)
      if (pcb->state >= ESTABLISHED) {
  80c560:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80c564:	76 1d                	jbe    80c583 <tcp_receive+0x1b2>
        if (pcb->cwnd < pcb->ssthresh) {
  80c566:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80c56a:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80c56e:	0f 83 d7 00 00 00    	jae    80c64b <tcp_receive+0x27a>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80c574:	89 c8                	mov    %ecx,%eax
  80c576:	66 03 47 34          	add    0x34(%edi),%ax
  80c57a:	66 39 c1             	cmp    %ax,%cx
  80c57d:	73 04                	jae    80c583 <tcp_receive+0x1b2>
            pcb->cwnd += pcb->mss;
  80c57f:	66 89 47 4e          	mov    %ax,0x4e(%edi)
      while (pcb->unacked != NULL &&
  80c583:	8b 47 78             	mov    0x78(%edi),%eax
  80c586:	85 c0                	test   %eax,%eax
  80c588:	0f 84 18 01 00 00    	je     80c6a6 <tcp_receive+0x2d5>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c58e:	83 ec 0c             	sub    $0xc,%esp
  80c591:	8b 40 10             	mov    0x10(%eax),%eax
  80c594:	ff 70 04             	pushl  0x4(%eax)
  80c597:	e8 f9 b3 ff ff       	call   807995 <ntohl>
  80c59c:	89 c3                	mov    %eax,%ebx
  80c59e:	8b 47 78             	mov    0x78(%edi),%eax
  80c5a1:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c5a5:	8b 40 10             	mov    0x10(%eax),%eax
  80c5a8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c5ac:	89 04 24             	mov    %eax,(%esp)
  80c5af:	e8 bd b1 ff ff       	call   807771 <ntohs>
  80c5b4:	83 c4 10             	add    $0x10,%esp
  80c5b7:	ba 01 00 00 00       	mov    $0x1,%edx
  80c5bc:	a8 01                	test   $0x1,%al
  80c5be:	0f 84 bf 00 00 00    	je     80c683 <tcp_receive+0x2b2>
  80c5c4:	2b 1d a4 b1 b3 00    	sub    0xb3b1a4,%ebx
  80c5ca:	01 d6                	add    %edx,%esi
  80c5cc:	01 f3                	add    %esi,%ebx
      while (pcb->unacked != NULL &&
  80c5ce:	85 db                	test   %ebx,%ebx
  80c5d0:	0f 8f d0 00 00 00    	jg     80c6a6 <tcp_receive+0x2d5>
        next = pcb->unacked;
  80c5d6:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80c5d9:	8b 03                	mov    (%ebx),%eax
  80c5db:	89 47 78             	mov    %eax,0x78(%edi)
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c5de:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c5e2:	83 ec 0c             	sub    $0xc,%esp
  80c5e5:	ff 73 04             	pushl  0x4(%ebx)
  80c5e8:	e8 e7 86 ff ff       	call   804cd4 <pbuf_clen>
  80c5ed:	0f b6 c0             	movzbl %al,%eax
  80c5f0:	83 c4 10             	add    $0x10,%esp
  80c5f3:	66 39 c6             	cmp    %ax,%si
  80c5f6:	72 74                	jb     80c66c <tcp_receive+0x29b>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80c5f8:	83 ec 0c             	sub    $0xc,%esp
  80c5fb:	ff 73 04             	pushl  0x4(%ebx)
  80c5fe:	e8 d1 86 ff ff       	call   804cd4 <pbuf_clen>
  80c603:	0f b6 c0             	movzbl %al,%eax
  80c606:	66 29 47 70          	sub    %ax,0x70(%edi)
        tcp_seg_free(next);
  80c60a:	89 1c 24             	mov    %ebx,(%esp)
  80c60d:	e8 92 91 ff ff       	call   8057a4 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
  80c612:	83 c4 10             	add    $0x10,%esp
  80c615:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c61a:	0f 84 63 ff ff ff    	je     80c583 <tcp_receive+0x1b2>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80c620:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c624:	0f 85 59 ff ff ff    	jne    80c583 <tcp_receive+0x1b2>
  80c62a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c62e:	0f 85 4f ff ff ff    	jne    80c583 <tcp_receive+0x1b2>
  80c634:	83 ec 04             	sub    $0x4,%esp
  80c637:	68 50 35 81 00       	push   $0x813550
  80c63c:	68 5c 03 00 00       	push   $0x35c
  80c641:	68 94 36 81 00       	push   $0x813694
  80c646:	e8 4e 20 00 00       	call   80e699 <_panic>
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80c64b:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80c64f:	0f af c0             	imul   %eax,%eax
  80c652:	0f b7 d9             	movzwl %cx,%ebx
  80c655:	99                   	cltd   
  80c656:	f7 fb                	idiv   %ebx
  80c658:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80c65a:	66 39 c1             	cmp    %ax,%cx
  80c65d:	0f 83 20 ff ff ff    	jae    80c583 <tcp_receive+0x1b2>
            pcb->cwnd = new_cwnd;
  80c663:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80c667:	e9 17 ff ff ff       	jmp    80c583 <tcp_receive+0x1b2>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c66c:	83 ec 04             	sub    $0x4,%esp
  80c66f:	68 28 35 81 00       	push   $0x813528
  80c674:	68 55 03 00 00       	push   $0x355
  80c679:	68 94 36 81 00       	push   $0x813694
  80c67e:	e8 16 20 00 00       	call   80e699 <_panic>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80c683:	83 ec 0c             	sub    $0xc,%esp
  80c686:	8b 47 78             	mov    0x78(%edi),%eax
  80c689:	8b 40 10             	mov    0x10(%eax),%eax
  80c68c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c690:	50                   	push   %eax
  80c691:	e8 db b0 ff ff       	call   807771 <ntohs>
  80c696:	66 d1 e8             	shr    %ax
  80c699:	89 c2                	mov    %eax,%edx
  80c69b:	83 e2 01             	and    $0x1,%edx
  80c69e:	83 c4 10             	add    $0x10,%esp
  80c6a1:	e9 1e ff ff ff       	jmp    80c5c4 <tcp_receive+0x1f3>
      if(pcb->unacked == NULL)
  80c6a6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c6aa:	0f 94 c0             	sete   %al
  80c6ad:	0f b6 c0             	movzbl %al,%eax
  80c6b0:	f7 d8                	neg    %eax
  80c6b2:	66 89 47 32          	mov    %ax,0x32(%edi)
      pcb->polltmr = 0;
  80c6b6:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80c6ba:	eb 39                	jmp    80c6f5 <tcp_receive+0x324>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c6bc:	83 ec 04             	sub    $0x4,%esp
  80c6bf:	68 28 35 81 00       	push   $0x813528
  80c6c4:	68 7f 03 00 00       	push   $0x37f
  80c6c9:	68 94 36 81 00       	push   $0x813694
  80c6ce:	e8 c6 1f 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c6d3:	83 ec 04             	sub    $0x4,%esp
  80c6d6:	68 50 35 81 00       	push   $0x813550
  80c6db:	68 85 03 00 00       	push   $0x385
  80c6e0:	68 94 36 81 00       	push   $0x813694
  80c6e5:	e8 af 1f 00 00       	call   80e699 <_panic>
      if (pcb->unsent != NULL) {
  80c6ea:	8b 47 74             	mov    0x74(%edi),%eax
  80c6ed:	85 c0                	test   %eax,%eax
  80c6ef:	0f 85 c8 00 00 00    	jne    80c7bd <tcp_receive+0x3ec>
    while (pcb->unsent != NULL &&
  80c6f5:	8b 47 74             	mov    0x74(%edi),%eax
  80c6f8:	85 c0                	test   %eax,%eax
  80c6fa:	0f 84 f9 00 00 00    	je     80c7f9 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c700:	8b 1d a4 b1 b3 00    	mov    0xb3b1a4,%ebx
  80c706:	83 ec 0c             	sub    $0xc,%esp
  80c709:	8b 40 10             	mov    0x10(%eax),%eax
  80c70c:	ff 70 04             	pushl  0x4(%eax)
  80c70f:	e8 81 b2 ff ff       	call   807995 <ntohl>
  80c714:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c717:	8b 47 74             	mov    0x74(%edi),%eax
  80c71a:	0f b7 70 0c          	movzwl 0xc(%eax),%esi
  80c71e:	8b 40 10             	mov    0x10(%eax),%eax
  80c721:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c725:	89 04 24             	mov    %eax,(%esp)
  80c728:	e8 44 b0 ff ff       	call   807771 <ntohs>
  80c72d:	83 c4 10             	add    $0x10,%esp
  80c730:	ba 01 00 00 00       	mov    $0x1,%edx
  80c735:	a8 01                	test   $0x1,%al
  80c737:	0f 84 99 00 00 00    	je     80c7d6 <tcp_receive+0x405>
  80c73d:	2b 5d e4             	sub    -0x1c(%ebp),%ebx
  80c740:	01 d6                	add    %edx,%esi
    while (pcb->unsent != NULL &&
  80c742:	39 f3                	cmp    %esi,%ebx
  80c744:	0f 88 af 00 00 00    	js     80c7f9 <tcp_receive+0x428>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c74a:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80c74f:	2b 47 58             	sub    0x58(%edi),%eax
  80c752:	85 c0                	test   %eax,%eax
  80c754:	0f 8f 9f 00 00 00    	jg     80c7f9 <tcp_receive+0x428>
      next = pcb->unsent;
  80c75a:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80c75d:	8b 03                	mov    (%ebx),%eax
  80c75f:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80c762:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80c766:	83 ec 0c             	sub    $0xc,%esp
  80c769:	ff 73 04             	pushl  0x4(%ebx)
  80c76c:	e8 63 85 ff ff       	call   804cd4 <pbuf_clen>
  80c771:	0f b6 c0             	movzbl %al,%eax
  80c774:	83 c4 10             	add    $0x10,%esp
  80c777:	66 39 c6             	cmp    %ax,%si
  80c77a:	0f 82 3c ff ff ff    	jb     80c6bc <tcp_receive+0x2eb>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80c780:	83 ec 0c             	sub    $0xc,%esp
  80c783:	ff 73 04             	pushl  0x4(%ebx)
  80c786:	e8 49 85 ff ff       	call   804cd4 <pbuf_clen>
  80c78b:	0f b6 c0             	movzbl %al,%eax
  80c78e:	66 29 47 70          	sub    %ax,0x70(%edi)
      tcp_seg_free(next);
  80c792:	89 1c 24             	mov    %ebx,(%esp)
  80c795:	e8 0a 90 ff ff       	call   8057a4 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
  80c79a:	83 c4 10             	add    $0x10,%esp
  80c79d:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80c7a2:	0f 84 42 ff ff ff    	je     80c6ea <tcp_receive+0x319>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80c7a8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c7ac:	0f 85 38 ff ff ff    	jne    80c6ea <tcp_receive+0x319>
  80c7b2:	8b 47 74             	mov    0x74(%edi),%eax
  80c7b5:	85 c0                	test   %eax,%eax
  80c7b7:	0f 84 16 ff ff ff    	je     80c6d3 <tcp_receive+0x302>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80c7bd:	83 ec 0c             	sub    $0xc,%esp
  80c7c0:	8b 40 10             	mov    0x10(%eax),%eax
  80c7c3:	ff 70 04             	pushl  0x4(%eax)
  80c7c6:	e8 b3 af ff ff       	call   80777e <htonl>
  80c7cb:	89 47 54             	mov    %eax,0x54(%edi)
  80c7ce:	83 c4 10             	add    $0x10,%esp
  80c7d1:	e9 1f ff ff ff       	jmp    80c6f5 <tcp_receive+0x324>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80c7d6:	83 ec 0c             	sub    $0xc,%esp
  80c7d9:	8b 47 74             	mov    0x74(%edi),%eax
  80c7dc:	8b 40 10             	mov    0x10(%eax),%eax
  80c7df:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80c7e3:	50                   	push   %eax
  80c7e4:	e8 88 af ff ff       	call   807771 <ntohs>
  80c7e9:	66 d1 e8             	shr    %ax
  80c7ec:	89 c2                	mov    %eax,%edx
  80c7ee:	83 e2 01             	and    $0x1,%edx
  80c7f1:	83 c4 10             	add    $0x10,%esp
  80c7f4:	e9 44 ff ff ff       	jmp    80c73d <tcp_receive+0x36c>
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80c7f9:	8b 47 38             	mov    0x38(%edi),%eax
  80c7fc:	85 c0                	test   %eax,%eax
  80c7fe:	74 0b                	je     80c80b <tcp_receive+0x43a>
  80c800:	8b 0d a4 b1 b3 00    	mov    0xb3b1a4,%ecx
  80c806:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80c809:	78 70                	js     80c87b <tcp_receive+0x4aa>
  if (tcplen > 0) {
  80c80b:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80c812:	66 85 c0             	test   %ax,%ax
  80c815:	0f 84 52 08 00 00    	je     80d06d <tcp_receive+0xc9c>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80c81b:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c81e:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c824:	89 d9                	mov    %ebx,%ecx
  80c826:	29 d1                	sub    %edx,%ecx
  80c828:	89 ce                	mov    %ecx,%esi
  80c82a:	83 ee 01             	sub    $0x1,%esi
  80c82d:	78 16                	js     80c845 <tcp_receive+0x474>
  80c82f:	be 01 00 00 00       	mov    $0x1,%esi
  80c834:	29 d6                	sub    %edx,%esi
  80c836:	0f b7 c0             	movzwl %ax,%eax
  80c839:	29 c6                	sub    %eax,%esi
  80c83b:	01 de                	add    %ebx,%esi
  80c83d:	85 f6                	test   %esi,%esi
  80c83f:	0f 8e 84 00 00 00    	jle    80c8c9 <tcp_receive+0x4f8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80c845:	39 da                	cmp    %ebx,%edx
  80c847:	0f 88 bd 01 00 00    	js     80ca0a <tcp_receive+0x639>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c84d:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80c851:	89 d1                	mov    %edx,%ecx
  80c853:	29 c1                	sub    %eax,%ecx
  80c855:	8d 41 01             	lea    0x1(%ecx),%eax
  80c858:	29 d8                	sub    %ebx,%eax
  80c85a:	85 c0                	test   %eax,%eax
  80c85c:	0f 8e bd 01 00 00    	jle    80ca1f <tcp_receive+0x64e>
      tcp_ack_now(pcb);
  80c862:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80c866:	83 ec 0c             	sub    $0xc,%esp
  80c869:	57                   	push   %edi
  80c86a:	e8 56 b8 ff ff       	call   8080c5 <tcp_output>
  80c86f:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80c872:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80c876:	e9 25 08 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c87b:	8b 35 40 b2 b3 00    	mov    0xb3b240,%esi
      m = m - (pcb->sa >> 3);
  80c881:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80c885:	89 d3                	mov    %edx,%ebx
  80c887:	66 c1 fb 03          	sar    $0x3,%bx
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80c88b:	89 f1                	mov    %esi,%ecx
  80c88d:	29 c1                	sub    %eax,%ecx
      m = m - (pcb->sa >> 3);
  80c88f:	29 d9                	sub    %ebx,%ecx
      pcb->sa += m;
  80c891:	01 ca                	add    %ecx,%edx
  80c893:	66 89 57 40          	mov    %dx,0x40(%edi)
        m = -m;
  80c897:	29 f0                	sub    %esi,%eax
  80c899:	01 d8                	add    %ebx,%eax
  80c89b:	66 85 c9             	test   %cx,%cx
  80c89e:	0f 49 c1             	cmovns %ecx,%eax
      m = m - (pcb->sv >> 2);
  80c8a1:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80c8a5:	89 cb                	mov    %ecx,%ebx
  80c8a7:	66 c1 fb 02          	sar    $0x2,%bx
      pcb->sv += m;
  80c8ab:	29 d9                	sub    %ebx,%ecx
  80c8ad:	01 c8                	add    %ecx,%eax
  80c8af:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80c8b3:	66 c1 fa 03          	sar    $0x3,%dx
  80c8b7:	01 d0                	add    %edx,%eax
  80c8b9:	66 89 47 44          	mov    %ax,0x44(%edi)
      pcb->rttest = 0;
  80c8bd:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
  80c8c4:	e9 42 ff ff ff       	jmp    80c80b <tcp_receive+0x43a>
      off = pcb->rcv_nxt - seqno;
  80c8c9:	89 c8                	mov    %ecx,%eax
      p = inseg.p;
  80c8cb:	8b 1d b8 b1 b3 00    	mov    0xb3b1b8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c8d1:	85 db                	test   %ebx,%ebx
  80c8d3:	0f 84 a4 00 00 00    	je     80c97d <tcp_receive+0x5ac>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c8d9:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80c8df:	0f 8f af 00 00 00    	jg     80c994 <tcp_receive+0x5c3>
      if (inseg.p->len < off) {
  80c8e5:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c8e9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80c8ec:	39 ca                	cmp    %ecx,%edx
  80c8ee:	0f 8d e5 00 00 00    	jge    80c9d9 <tcp_receive+0x608>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c8f4:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80c8f8:	0f b7 d6             	movzwl %si,%edx
  80c8fb:	39 ca                	cmp    %ecx,%edx
  80c8fd:	0f 8c a8 00 00 00    	jl     80c9ab <tcp_receive+0x5da>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80c903:	29 ce                	sub    %ecx,%esi
  80c905:	89 f1                	mov    %esi,%ecx
  80c907:	8b 55 e4             	mov    -0x1c(%ebp),%edx
          off -= p->len;
  80c90a:	29 d0                	sub    %edx,%eax
          p->tot_len = new_tot_len;
  80c90c:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80c910:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80c916:	8b 1b                	mov    (%ebx),%ebx
        while (p->len < off) {
  80c918:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c91c:	39 c2                	cmp    %eax,%edx
  80c91e:	7c ea                	jl     80c90a <tcp_receive+0x539>
        if(pbuf_header(p, (s16_t)-off)) {
  80c920:	83 ec 08             	sub    $0x8,%esp
  80c923:	f7 d8                	neg    %eax
  80c925:	98                   	cwtl   
  80c926:	50                   	push   %eax
  80c927:	53                   	push   %ebx
  80c928:	e8 90 7e ff ff       	call   8047bd <pbuf_header>
  80c92d:	83 c4 10             	add    $0x10,%esp
  80c930:	84 c0                	test   %al,%al
  80c932:	0f 85 8a 00 00 00    	jne    80c9c2 <tcp_receive+0x5f1>
      inseg.dataptr = p->payload;
  80c938:	8b 43 04             	mov    0x4(%ebx),%eax
  80c93b:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80c940:	8b 57 24             	mov    0x24(%edi),%edx
  80c943:	0f b7 05 c0 b1 b3 00 	movzwl 0xb3b1c0,%eax
  80c94a:	66 03 05 a8 b1 b3 00 	add    0xb3b1a8,%ax
  80c951:	29 d0                	sub    %edx,%eax
  80c953:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80c959:	89 15 a8 b1 b3 00    	mov    %edx,0xb3b1a8
  80c95f:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80c964:	89 50 04             	mov    %edx,0x4(%eax)
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80c967:	8b 15 a8 b1 b3 00    	mov    0xb3b1a8,%edx
  80c96d:	8b 5f 24             	mov    0x24(%edi),%ebx
  80c970:	39 da                	cmp    %ebx,%edx
  80c972:	0f 88 ea fe ff ff    	js     80c862 <tcp_receive+0x491>
  80c978:	e9 d0 fe ff ff       	jmp    80c84d <tcp_receive+0x47c>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80c97d:	83 ec 04             	sub    $0x4,%esp
  80c980:	68 ab 36 81 00       	push   $0x8136ab
  80c985:	68 e5 03 00 00       	push   $0x3e5
  80c98a:	68 94 36 81 00       	push   $0x813694
  80c98f:	e8 05 1d 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80c994:	83 ec 04             	sub    $0x4,%esp
  80c997:	68 bb 36 81 00       	push   $0x8136bb
  80c99c:	68 e6 03 00 00       	push   $0x3e6
  80c9a1:	68 94 36 81 00       	push   $0x813694
  80c9a6:	e8 ee 1c 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80c9ab:	83 ec 04             	sub    $0x4,%esp
  80c9ae:	68 ca 36 81 00       	push   $0x8136ca
  80c9b3:	68 e8 03 00 00       	push   $0x3e8
  80c9b8:	68 94 36 81 00       	push   $0x813694
  80c9bd:	e8 d7 1c 00 00       	call   80e699 <_panic>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c9c2:	83 ec 04             	sub    $0x4,%esp
  80c9c5:	68 da 36 81 00       	push   $0x8136da
  80c9ca:	68 f5 03 00 00       	push   $0x3f5
  80c9cf:	68 94 36 81 00       	push   $0x813694
  80c9d4:	e8 c0 1c 00 00       	call   80e699 <_panic>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80c9d9:	83 ec 08             	sub    $0x8,%esp
  80c9dc:	f7 d9                	neg    %ecx
  80c9de:	0f bf c1             	movswl %cx,%eax
  80c9e1:	50                   	push   %eax
  80c9e2:	53                   	push   %ebx
  80c9e3:	e8 d5 7d ff ff       	call   8047bd <pbuf_header>
  80c9e8:	83 c4 10             	add    $0x10,%esp
  80c9eb:	84 c0                	test   %al,%al
  80c9ed:	0f 84 45 ff ff ff    	je     80c938 <tcp_receive+0x567>
          LWIP_ASSERT("pbuf_header failed", 0);
  80c9f3:	83 ec 04             	sub    $0x4,%esp
  80c9f6:	68 da 36 81 00       	push   $0x8136da
  80c9fb:	68 fa 03 00 00       	push   $0x3fa
  80ca00:	68 94 36 81 00       	push   $0x813694
  80ca05:	e8 8f 1c 00 00       	call   80e699 <_panic>
        tcp_ack_now(pcb);
  80ca0a:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80ca0e:	83 ec 0c             	sub    $0xc,%esp
  80ca11:	57                   	push   %edi
  80ca12:	e8 ae b6 ff ff       	call   8080c5 <tcp_output>
  80ca17:	83 c4 10             	add    $0x10,%esp
  80ca1a:	e9 48 ff ff ff       	jmp    80c967 <tcp_receive+0x596>
      if (pcb->rcv_nxt == seqno) {
  80ca1f:	39 da                	cmp    %ebx,%edx
  80ca21:	0f 85 d2 03 00 00    	jne    80cdf9 <tcp_receive+0xa28>
        if (pcb->ooseq != NULL &&
  80ca27:	8b 47 7c             	mov    0x7c(%edi),%eax
  80ca2a:	85 c0                	test   %eax,%eax
  80ca2c:	74 1d                	je     80ca4b <tcp_receive+0x67a>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80ca2e:	8b 48 10             	mov    0x10(%eax),%ecx
  80ca31:	8b 59 04             	mov    0x4(%ecx),%ebx
  80ca34:	0f b7 0d c0 b1 b3 00 	movzwl 0xb3b1c0,%ecx
  80ca3b:	89 de                	mov    %ebx,%esi
  80ca3d:	29 ce                	sub    %ecx,%esi
  80ca3f:	89 f1                	mov    %esi,%ecx
  80ca41:	29 d1                	sub    %edx,%ecx
        if (pcb->ooseq != NULL &&
  80ca43:	85 c9                	test   %ecx,%ecx
  80ca45:	0f 8e b0 00 00 00    	jle    80cafb <tcp_receive+0x72a>
        tcplen = TCP_TCPLEN(&inseg);
  80ca4b:	0f b7 1d c0 b1 b3 00 	movzwl 0xb3b1c0,%ebx
  80ca52:	83 ec 0c             	sub    $0xc,%esp
  80ca55:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80ca5a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ca5e:	50                   	push   %eax
  80ca5f:	e8 0d ad ff ff       	call   807771 <ntohs>
  80ca64:	83 c4 10             	add    $0x10,%esp
  80ca67:	ba 01 00 00 00       	mov    $0x1,%edx
  80ca6c:	a8 01                	test   $0x1,%al
  80ca6e:	0f 84 00 01 00 00    	je     80cb74 <tcp_receive+0x7a3>
  80ca74:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80ca77:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
        if (pcb->state != CLOSE_WAIT) {
  80ca7d:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80ca81:	74 06                	je     80ca89 <tcp_receive+0x6b8>
          pcb->rcv_nxt += tcplen;
  80ca83:	0f b7 d0             	movzwl %ax,%edx
  80ca86:	01 57 24             	add    %edx,0x24(%edi)
        if (pcb->rcv_wnd < tcplen) {
  80ca89:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
          pcb->rcv_wnd -= tcplen;
  80ca8d:	89 ca                	mov    %ecx,%edx
  80ca8f:	29 c2                	sub    %eax,%edx
  80ca91:	66 39 c8             	cmp    %cx,%ax
  80ca94:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ca99:	0f 47 d1             	cmova  %ecx,%edx
  80ca9c:	66 89 57 28          	mov    %dx,0x28(%edi)
        if (pcb->rcv_ann_wnd < tcplen) {
  80caa0:	0f b7 4f 2a          	movzwl 0x2a(%edi),%ecx
          pcb->rcv_ann_wnd -= tcplen;
  80caa4:	89 ca                	mov    %ecx,%edx
  80caa6:	29 c2                	sub    %eax,%edx
  80caa8:	66 39 c8             	cmp    %cx,%ax
  80caab:	b8 00 00 00 00       	mov    $0x0,%eax
  80cab0:	0f 46 c2             	cmovbe %edx,%eax
  80cab3:	66 89 47 2a          	mov    %ax,0x2a(%edi)
        if (inseg.p->tot_len > 0) {
  80cab7:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80cabc:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cac1:	74 0f                	je     80cad2 <tcp_receive+0x701>
          recv_data = inseg.p;
  80cac3:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
          inseg.p = NULL;
  80cac8:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80cacf:	00 00 00 
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80cad2:	83 ec 0c             	sub    $0xc,%esp
  80cad5:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cada:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cade:	50                   	push   %eax
  80cadf:	e8 8d ac ff ff       	call   807771 <ntohs>
  80cae4:	83 c4 10             	add    $0x10,%esp
  80cae7:	a8 01                	test   $0x1,%al
  80cae9:	0f 84 e4 01 00 00    	je     80ccd3 <tcp_receive+0x902>
          recv_flags = TF_GOT_FIN;
  80caef:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
  80caf6:	e9 d8 01 00 00       	jmp    80ccd3 <tcp_receive+0x902>
          if (pcb->ooseq->len > 0) {
  80cafb:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80cb00:	74 23                	je     80cb25 <tcp_receive+0x754>
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80cb02:	29 d3                	sub    %edx,%ebx
  80cb04:	66 89 1d c0 b1 b3 00 	mov    %bx,0xb3b1c0
            pbuf_realloc(inseg.p, inseg.len);
  80cb0b:	83 ec 08             	sub    $0x8,%esp
  80cb0e:	0f b7 db             	movzwl %bx,%ebx
  80cb11:	53                   	push   %ebx
  80cb12:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cb18:	e8 a5 80 ff ff       	call   804bc2 <pbuf_realloc>
  80cb1d:	83 c4 10             	add    $0x10,%esp
  80cb20:	e9 26 ff ff ff       	jmp    80ca4b <tcp_receive+0x67a>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cb25:	83 ec 0c             	sub    $0xc,%esp
  80cb28:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cb2d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb31:	50                   	push   %eax
  80cb32:	e8 3a ac ff ff       	call   807771 <ntohs>
  80cb37:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80cb39:	8b 47 7c             	mov    0x7c(%edi),%eax
  80cb3c:	8b 40 10             	mov    0x10(%eax),%eax
  80cb3f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb43:	89 04 24             	mov    %eax,(%esp)
  80cb46:	e8 26 ac ff ff       	call   807771 <ntohs>
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80cb4b:	31 c3                	xor    %eax,%ebx
  80cb4d:	83 c4 10             	add    $0x10,%esp
  80cb50:	f6 c3 03             	test   $0x3,%bl
  80cb53:	0f 85 f2 fe ff ff    	jne    80ca4b <tcp_receive+0x67a>
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80cb59:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80cb5c:	8b 10                	mov    (%eax),%edx
  80cb5e:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80cb61:	83 ec 08             	sub    $0x8,%esp
  80cb64:	50                   	push   %eax
  80cb65:	6a 04                	push   $0x4
  80cb67:	e8 d1 79 ff ff       	call   80453d <memp_free>
  80cb6c:	83 c4 10             	add    $0x10,%esp
  80cb6f:	e9 d7 fe ff ff       	jmp    80ca4b <tcp_receive+0x67a>
        tcplen = TCP_TCPLEN(&inseg);
  80cb74:	83 ec 0c             	sub    $0xc,%esp
  80cb77:	a1 c4 b1 b3 00       	mov    0xb3b1c4,%eax
  80cb7c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb80:	50                   	push   %eax
  80cb81:	e8 eb ab ff ff       	call   807771 <ntohs>
  80cb86:	66 d1 e8             	shr    %ax
  80cb89:	89 c2                	mov    %eax,%edx
  80cb8b:	83 e2 01             	and    $0x1,%edx
  80cb8e:	83 c4 10             	add    $0x10,%esp
  80cb91:	e9 de fe ff ff       	jmp    80ca74 <tcp_receive+0x6a3>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80cb96:	83 ec 0c             	sub    $0xc,%esp
  80cb99:	8b 43 10             	mov    0x10(%ebx),%eax
  80cb9c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cba0:	50                   	push   %eax
  80cba1:	e8 cb ab ff ff       	call   807771 <ntohs>
  80cba6:	66 d1 e8             	shr    %ax
  80cba9:	89 c2                	mov    %eax,%edx
  80cbab:	83 e2 01             	and    $0x1,%edx
  80cbae:	83 c4 10             	add    $0x10,%esp
  80cbb1:	e9 5d 01 00 00       	jmp    80cd13 <tcp_receive+0x942>
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cbb6:	83 ec 0c             	sub    $0xc,%esp
  80cbb9:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbbc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbc0:	50                   	push   %eax
  80cbc1:	e8 ab ab ff ff       	call   807771 <ntohs>
  80cbc6:	66 d1 e8             	shr    %ax
  80cbc9:	89 c2                	mov    %eax,%edx
  80cbcb:	83 e2 01             	and    $0x1,%edx
  80cbce:	83 c4 10             	add    $0x10,%esp
  80cbd1:	e9 6d 01 00 00       	jmp    80cd43 <tcp_receive+0x972>
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80cbd6:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cbda:	83 ec 0c             	sub    $0xc,%esp
  80cbdd:	8b 43 10             	mov    0x10(%ebx),%eax
  80cbe0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cbe4:	50                   	push   %eax
  80cbe5:	e8 87 ab ff ff       	call   807771 <ntohs>
  80cbea:	83 c4 10             	add    $0x10,%esp
  80cbed:	ba 01 00 00 00       	mov    $0x1,%edx
  80cbf2:	a8 01                	test   $0x1,%al
  80cbf4:	74 0b                	je     80cc01 <tcp_receive+0x830>
  80cbf6:	01 d6                	add    %edx,%esi
  80cbf8:	66 29 77 28          	sub    %si,0x28(%edi)
  80cbfc:	e9 53 01 00 00       	jmp    80cd54 <tcp_receive+0x983>
  80cc01:	83 ec 0c             	sub    $0xc,%esp
  80cc04:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc07:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc0b:	50                   	push   %eax
  80cc0c:	e8 60 ab ff ff       	call   807771 <ntohs>
  80cc11:	66 d1 e8             	shr    %ax
  80cc14:	89 c2                	mov    %eax,%edx
  80cc16:	83 e2 01             	and    $0x1,%edx
  80cc19:	83 c4 10             	add    $0x10,%esp
  80cc1c:	eb d8                	jmp    80cbf6 <tcp_receive+0x825>
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cc1e:	83 ec 0c             	sub    $0xc,%esp
  80cc21:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc24:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc28:	50                   	push   %eax
  80cc29:	e8 43 ab ff ff       	call   807771 <ntohs>
  80cc2e:	66 d1 e8             	shr    %ax
  80cc31:	89 c2                	mov    %eax,%edx
  80cc33:	83 e2 01             	and    $0x1,%edx
  80cc36:	83 c4 10             	add    $0x10,%esp
  80cc39:	e9 41 01 00 00       	jmp    80cd7f <tcp_receive+0x9ae>
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80cc3e:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cc42:	83 ec 0c             	sub    $0xc,%esp
  80cc45:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc48:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc4c:	50                   	push   %eax
  80cc4d:	e8 1f ab ff ff       	call   807771 <ntohs>
  80cc52:	83 c4 10             	add    $0x10,%esp
  80cc55:	ba 01 00 00 00       	mov    $0x1,%edx
  80cc5a:	a8 01                	test   $0x1,%al
  80cc5c:	74 0b                	je     80cc69 <tcp_receive+0x898>
  80cc5e:	01 d6                	add    %edx,%esi
  80cc60:	66 29 77 2a          	sub    %si,0x2a(%edi)
  80cc64:	e9 27 01 00 00       	jmp    80cd90 <tcp_receive+0x9bf>
  80cc69:	83 ec 0c             	sub    $0xc,%esp
  80cc6c:	8b 43 10             	mov    0x10(%ebx),%eax
  80cc6f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cc73:	50                   	push   %eax
  80cc74:	e8 f8 aa ff ff       	call   807771 <ntohs>
  80cc79:	66 d1 e8             	shr    %ax
  80cc7c:	89 c2                	mov    %eax,%edx
  80cc7e:	83 e2 01             	and    $0x1,%edx
  80cc81:	83 c4 10             	add    $0x10,%esp
  80cc84:	eb d8                	jmp    80cc5e <tcp_receive+0x88d>
              pbuf_cat(recv_data, cseg->p);
  80cc86:	83 ec 08             	sub    $0x8,%esp
  80cc89:	50                   	push   %eax
  80cc8a:	52                   	push   %edx
  80cc8b:	e8 6d 80 ff ff       	call   804cfd <pbuf_cat>
  80cc90:	83 c4 10             	add    $0x10,%esp
            cseg->p = NULL;
  80cc93:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80cc9a:	83 ec 0c             	sub    $0xc,%esp
  80cc9d:	8b 43 10             	mov    0x10(%ebx),%eax
  80cca0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cca4:	50                   	push   %eax
  80cca5:	e8 c7 aa ff ff       	call   807771 <ntohs>
  80ccaa:	83 c4 10             	add    $0x10,%esp
  80ccad:	a8 01                	test   $0x1,%al
  80ccaf:	74 11                	je     80ccc2 <tcp_receive+0x8f1>
            recv_flags = TF_GOT_FIN;
  80ccb1:	c6 05 9c b1 b3 00 20 	movb   $0x20,0xb3b19c
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80ccb8:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80ccbc:	0f 84 f4 00 00 00    	je     80cdb6 <tcp_receive+0x9e5>
          pcb->ooseq = cseg->next;
  80ccc2:	8b 03                	mov    (%ebx),%eax
  80ccc4:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80ccc7:	83 ec 0c             	sub    $0xc,%esp
  80ccca:	53                   	push   %ebx
  80cccb:	e8 d4 8a ff ff       	call   8057a4 <tcp_seg_free>
  80ccd0:	83 c4 10             	add    $0x10,%esp
        while (pcb->ooseq != NULL &&
  80ccd3:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80ccd6:	85 db                	test   %ebx,%ebx
  80ccd8:	0f 84 e4 00 00 00    	je     80cdc2 <tcp_receive+0x9f1>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80ccde:	8b 53 10             	mov    0x10(%ebx),%edx
  80cce1:	8b 42 04             	mov    0x4(%edx),%eax
        while (pcb->ooseq != NULL &&
  80cce4:	3b 47 24             	cmp    0x24(%edi),%eax
  80cce7:	0f 85 d5 00 00 00    	jne    80cdc2 <tcp_receive+0x9f1>
          seqno = pcb->ooseq->tcphdr->seqno;
  80cced:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80ccf2:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80ccf6:	83 ec 0c             	sub    $0xc,%esp
  80ccf9:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80ccfd:	50                   	push   %eax
  80ccfe:	e8 6e aa ff ff       	call   807771 <ntohs>
  80cd03:	83 c4 10             	add    $0x10,%esp
  80cd06:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd0b:	a8 01                	test   $0x1,%al
  80cd0d:	0f 84 83 fe ff ff    	je     80cb96 <tcp_receive+0x7c5>
  80cd13:	01 d6                	add    %edx,%esi
  80cd15:	01 77 24             	add    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80cd18:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80cd1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cd1f:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd23:	83 ec 0c             	sub    $0xc,%esp
  80cd26:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd29:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd2d:	50                   	push   %eax
  80cd2e:	e8 3e aa ff ff       	call   807771 <ntohs>
  80cd33:	83 c4 10             	add    $0x10,%esp
  80cd36:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd3b:	a8 01                	test   $0x1,%al
  80cd3d:	0f 84 73 fe ff ff    	je     80cbb6 <tcp_receive+0x7e5>
  80cd43:	01 d6                	add    %edx,%esi
  80cd45:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cd48:	0f 8d 88 fe ff ff    	jge    80cbd6 <tcp_receive+0x805>
            pcb->rcv_wnd = 0;
  80cd4e:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80cd54:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80cd58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cd5b:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80cd5f:	83 ec 0c             	sub    $0xc,%esp
  80cd62:	8b 43 10             	mov    0x10(%ebx),%eax
  80cd65:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cd69:	50                   	push   %eax
  80cd6a:	e8 02 aa ff ff       	call   807771 <ntohs>
  80cd6f:	83 c4 10             	add    $0x10,%esp
  80cd72:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd77:	a8 01                	test   $0x1,%al
  80cd79:	0f 84 9f fe ff ff    	je     80cc1e <tcp_receive+0x84d>
  80cd7f:	01 d6                	add    %edx,%esi
  80cd81:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80cd84:	0f 8d b4 fe ff ff    	jge    80cc3e <tcp_receive+0x86d>
            pcb->rcv_ann_wnd = 0;
  80cd8a:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
          if (cseg->p->tot_len > 0) {
  80cd90:	8b 43 04             	mov    0x4(%ebx),%eax
  80cd93:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80cd98:	0f 84 fc fe ff ff    	je     80cc9a <tcp_receive+0x8c9>
            if (recv_data) {
  80cd9e:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80cda4:	85 d2                	test   %edx,%edx
  80cda6:	0f 85 da fe ff ff    	jne    80cc86 <tcp_receive+0x8b5>
              recv_data = cseg->p;
  80cdac:	a3 98 b1 b3 00       	mov    %eax,0xb3b198
  80cdb1:	e9 dd fe ff ff       	jmp    80cc93 <tcp_receive+0x8c2>
              pcb->state = CLOSE_WAIT;
  80cdb6:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
  80cdbd:	e9 00 ff ff ff       	jmp    80ccc2 <tcp_receive+0x8f1>
        tcp_ack(pcb);
  80cdc2:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80cdc6:	89 c1                	mov    %eax,%ecx
  80cdc8:	83 e1 01             	and    $0x1,%ecx
  80cdcb:	88 4d e4             	mov    %cl,-0x1c(%ebp)
  80cdce:	75 0f                	jne    80cddf <tcp_receive+0xa0e>
  80cdd0:	83 c8 01             	or     $0x1,%eax
  80cdd3:	88 47 20             	mov    %al,0x20(%edi)
        accepted_inseq = 1; 
  80cdd6:	c6 45 e4 01          	movb   $0x1,-0x1c(%ebp)
  80cdda:	e9 c1 02 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
        tcp_ack(pcb);
  80cddf:	83 e0 fe             	and    $0xfffffffe,%eax
  80cde2:	83 c8 02             	or     $0x2,%eax
  80cde5:	88 47 20             	mov    %al,0x20(%edi)
  80cde8:	83 ec 0c             	sub    $0xc,%esp
  80cdeb:	57                   	push   %edi
  80cdec:	e8 d4 b2 ff ff       	call   8080c5 <tcp_output>
  80cdf1:	83 c4 10             	add    $0x10,%esp
  80cdf4:	e9 a7 02 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
        tcp_ack_now(pcb);
  80cdf9:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80cdfd:	83 ec 0c             	sub    $0xc,%esp
  80ce00:	57                   	push   %edi
  80ce01:	e8 bf b2 ff ff       	call   8080c5 <tcp_output>
        if (pcb->ooseq == NULL) {
  80ce06:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80ce09:	83 c4 10             	add    $0x10,%esp
  80ce0c:	85 db                	test   %ebx,%ebx
  80ce0e:	74 1e                	je     80ce2e <tcp_receive+0xa5d>
            if (seqno == next->tcphdr->seqno) {
  80ce10:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80ce16:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80ce19:	8d 51 01             	lea    0x1(%ecx),%edx
  80ce1c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
          prev = NULL;
  80ce1f:	be 00 00 00 00       	mov    $0x0,%esi
  80ce24:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80ce27:	89 c7                	mov    %eax,%edi
  80ce29:	e9 d7 00 00 00       	jmp    80cf05 <tcp_receive+0xb34>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80ce2e:	83 ec 0c             	sub    $0xc,%esp
  80ce31:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ce36:	e8 e2 89 ff ff       	call   80581d <tcp_seg_copy>
  80ce3b:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ce3e:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce41:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80ce45:	e9 56 02 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
  80ce4a:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80ce4d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (inseg.len > next->len) {
  80ce51:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ce55:	66 39 05 c0 b1 b3 00 	cmp    %ax,0xb3b1c0
  80ce5c:	0f 86 3e 02 00 00    	jbe    80d0a0 <tcp_receive+0xccf>
                cseg = tcp_seg_copy(&inseg);
  80ce62:	83 ec 0c             	sub    $0xc,%esp
  80ce65:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80ce6a:	e8 ae 89 ff ff       	call   80581d <tcp_seg_copy>
  80ce6f:	89 c1                	mov    %eax,%ecx
  80ce71:	89 45 e0             	mov    %eax,-0x20(%ebp)
                if (cseg != NULL) {
  80ce74:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce77:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80ce7b:	85 c0                	test   %eax,%eax
  80ce7d:	0f 84 1d 02 00 00    	je     80d0a0 <tcp_receive+0xccf>
                  cseg->next = next->next;
  80ce83:	8b 03                	mov    (%ebx),%eax
  80ce85:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80ce87:	85 f6                	test   %esi,%esi
  80ce89:	74 5c                	je     80cee7 <tcp_receive+0xb16>
                    prev->next = cseg;
  80ce8b:	89 0e                	mov    %ecx,(%esi)
                  tcp_seg_free(next);
  80ce8d:	83 ec 0c             	sub    $0xc,%esp
  80ce90:	53                   	push   %ebx
  80ce91:	e8 0e 89 ff ff       	call   8057a4 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80ce96:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80ce99:	8b 06                	mov    (%esi),%eax
  80ce9b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80ce9e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg->next != NULL) {
  80cea2:	85 c0                	test   %eax,%eax
  80cea4:	0f 84 f6 01 00 00    	je     80d0a0 <tcp_receive+0xccf>
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80ceaa:	8b 0d a8 b1 b3 00    	mov    0xb3b1a8,%ecx
  80ceb0:	8b 40 10             	mov    0x10(%eax),%eax
  80ceb3:	8b 40 04             	mov    0x4(%eax),%eax
  80ceb6:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80ceba:	01 ca                	add    %ecx,%edx
  80cebc:	29 c2                	sub    %eax,%edx
  80cebe:	85 d2                	test   %edx,%edx
  80cec0:	0f 8e da 01 00 00    	jle    80d0a0 <tcp_receive+0xccf>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80cec6:	29 c8                	sub    %ecx,%eax
  80cec8:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80cecc:	83 ec 08             	sub    $0x8,%esp
  80cecf:	0f b7 c0             	movzwl %ax,%eax
  80ced2:	50                   	push   %eax
  80ced3:	ff 76 04             	pushl  0x4(%esi)
  80ced6:	e8 e7 7c ff ff       	call   804bc2 <pbuf_realloc>
  80cedb:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cede:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cee2:	e9 b9 01 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
                    pcb->ooseq = cseg;
  80cee7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ceea:	89 47 7c             	mov    %eax,0x7c(%edi)
  80ceed:	eb 9e                	jmp    80ce8d <tcp_receive+0xabc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80ceef:	39 c1                	cmp    %eax,%ecx
  80cef1:	0f 88 a0 00 00 00    	js     80cf97 <tcp_receive+0xbc6>
              if (next->next == NULL &&
  80cef7:	8b 13                	mov    (%ebx),%edx
  80cef9:	89 de                	mov    %ebx,%esi
  80cefb:	85 d2                	test   %edx,%edx
  80cefd:	0f 84 0d 01 00 00    	je     80d010 <tcp_receive+0xc3f>
  80cf03:	89 d3                	mov    %edx,%ebx
            if (seqno == next->tcphdr->seqno) {
  80cf05:	8b 43 10             	mov    0x10(%ebx),%eax
  80cf08:	8b 40 04             	mov    0x4(%eax),%eax
  80cf0b:	39 c8                	cmp    %ecx,%eax
  80cf0d:	0f 84 37 ff ff ff    	je     80ce4a <tcp_receive+0xa79>
              if (prev == NULL) {
  80cf13:	85 f6                	test   %esi,%esi
  80cf15:	74 d8                	je     80ceef <tcp_receive+0xb1e>
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80cf17:	8b 56 10             	mov    0x10(%esi),%edx
  80cf1a:	3b 7a 04             	cmp    0x4(%edx),%edi
  80cf1d:	78 d8                	js     80cef7 <tcp_receive+0xb26>
  80cf1f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cf22:	29 c2                	sub    %eax,%edx
  80cf24:	85 d2                	test   %edx,%edx
  80cf26:	7f cf                	jg     80cef7 <tcp_receive+0xb26>
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cf28:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cf2f:	01 ca                	add    %ecx,%edx
  80cf31:	29 c2                	sub    %eax,%edx
  80cf33:	85 d2                	test   %edx,%edx
  80cf35:	0f 8f b3 00 00 00    	jg     80cfee <tcp_receive+0xc1d>
                cseg = tcp_seg_copy(&inseg);
  80cf3b:	83 ec 0c             	sub    $0xc,%esp
  80cf3e:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cf43:	e8 d5 88 ff ff       	call   80581d <tcp_seg_copy>
                if (cseg != NULL) {
  80cf48:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf4b:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (cseg != NULL) {
  80cf4f:	85 c0                	test   %eax,%eax
  80cf51:	0f 84 49 01 00 00    	je     80d0a0 <tcp_receive+0xccf>
                  cseg->next = next;
  80cf57:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80cf59:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80cf5b:	8b 46 10             	mov    0x10(%esi),%eax
  80cf5e:	8b 48 04             	mov    0x4(%eax),%ecx
  80cf61:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80cf66:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  80cf6a:	01 ca                	add    %ecx,%edx
  80cf6c:	29 c2                	sub    %eax,%edx
  80cf6e:	85 d2                	test   %edx,%edx
  80cf70:	0f 8e 2a 01 00 00    	jle    80d0a0 <tcp_receive+0xccf>
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80cf76:	29 c8                	sub    %ecx,%eax
  80cf78:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80cf7c:	83 ec 08             	sub    $0x8,%esp
  80cf7f:	0f b7 c0             	movzwl %ax,%eax
  80cf82:	50                   	push   %eax
  80cf83:	ff 76 04             	pushl  0x4(%esi)
  80cf86:	e8 37 7c ff ff       	call   804bc2 <pbuf_realloc>
  80cf8b:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cf8e:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80cf92:	e9 09 01 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
  80cf97:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80cf9a:	0f b7 15 c0 b1 b3 00 	movzwl 0xb3b1c0,%edx
  80cfa1:	01 ca                	add    %ecx,%edx
  80cfa3:	29 c2                	sub    %eax,%edx
  80cfa5:	85 d2                	test   %edx,%edx
  80cfa7:	7f 26                	jg     80cfcf <tcp_receive+0xbfe>
                  cseg = tcp_seg_copy(&inseg);
  80cfa9:	83 ec 0c             	sub    $0xc,%esp
  80cfac:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80cfb1:	e8 67 88 ff ff       	call   80581d <tcp_seg_copy>
                  if (cseg != NULL) {
  80cfb6:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80cfb9:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                  if (cseg != NULL) {
  80cfbd:	85 c0                	test   %eax,%eax
  80cfbf:	0f 84 db 00 00 00    	je     80d0a0 <tcp_receive+0xccf>
                    cseg->next = next;
  80cfc5:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80cfc7:	89 47 7c             	mov    %eax,0x7c(%edi)
  80cfca:	e9 d1 00 00 00       	jmp    80d0a0 <tcp_receive+0xccf>
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cfcf:	29 c8                	sub    %ecx,%eax
  80cfd1:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                    pbuf_realloc(inseg.p, inseg.len);
  80cfd7:	83 ec 08             	sub    $0x8,%esp
  80cfda:	0f b7 c0             	movzwl %ax,%eax
  80cfdd:	50                   	push   %eax
  80cfde:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80cfe4:	e8 d9 7b ff ff       	call   804bc2 <pbuf_realloc>
  80cfe9:	83 c4 10             	add    $0x10,%esp
  80cfec:	eb bb                	jmp    80cfa9 <tcp_receive+0xbd8>
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80cfee:	29 c8                	sub    %ecx,%eax
  80cff0:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
                  pbuf_realloc(inseg.p, inseg.len);
  80cff6:	83 ec 08             	sub    $0x8,%esp
  80cff9:	0f b7 c0             	movzwl %ax,%eax
  80cffc:	50                   	push   %eax
  80cffd:	ff 35 b8 b1 b3 00    	pushl  0xb3b1b8
  80d003:	e8 ba 7b ff ff       	call   804bc2 <pbuf_realloc>
  80d008:	83 c4 10             	add    $0x10,%esp
  80d00b:	e9 2b ff ff ff       	jmp    80cf3b <tcp_receive+0xb6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d010:	29 c1                	sub    %eax,%ecx
  u8_t accepted_inseq = 0;
  80d012:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
              if (next->next == NULL &&
  80d016:	85 c9                	test   %ecx,%ecx
  80d018:	0f 8e 82 00 00 00    	jle    80d0a0 <tcp_receive+0xccf>
                next->next = tcp_seg_copy(&inseg);
  80d01e:	83 ec 0c             	sub    $0xc,%esp
  80d021:	68 b4 b1 b3 00       	push   $0xb3b1b4
  80d026:	e8 f2 87 ff ff       	call   80581d <tcp_seg_copy>
  80d02b:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d02d:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d030:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
                if (next->next != NULL) {
  80d034:	85 c0                	test   %eax,%eax
  80d036:	74 68                	je     80d0a0 <tcp_receive+0xccf>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d038:	8b 43 10             	mov    0x10(%ebx),%eax
  80d03b:	8b 48 04             	mov    0x4(%eax),%ecx
  80d03e:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d043:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d047:	01 ca                	add    %ecx,%edx
  80d049:	29 c2                	sub    %eax,%edx
  80d04b:	85 d2                	test   %edx,%edx
  80d04d:	7e 51                	jle    80d0a0 <tcp_receive+0xccf>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d04f:	29 c8                	sub    %ecx,%eax
  80d051:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d055:	83 ec 08             	sub    $0x8,%esp
  80d058:	0f b7 c0             	movzwl %ax,%eax
  80d05b:	50                   	push   %eax
  80d05c:	ff 73 04             	pushl  0x4(%ebx)
  80d05f:	e8 5e 7b ff ff       	call   804bc2 <pbuf_realloc>
  80d064:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d067:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  80d06b:	eb 33                	jmp    80d0a0 <tcp_receive+0xccf>
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d06d:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d072:	8b 57 24             	mov    0x24(%edi),%edx
  80d075:	39 d0                	cmp    %edx,%eax
  80d077:	78 13                	js     80d08c <tcp_receive+0xcbb>
  80d079:	83 c0 01             	add    $0x1,%eax
  80d07c:	29 d0                	sub    %edx,%eax
  80d07e:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d082:	29 d0                	sub    %edx,%eax
  u8_t accepted_inseq = 0;
  80d084:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80d088:	85 c0                	test   %eax,%eax
  80d08a:	7e 14                	jle    80d0a0 <tcp_receive+0xccf>
      tcp_ack_now(pcb);
  80d08c:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d090:	83 ec 0c             	sub    $0xc,%esp
  80d093:	57                   	push   %edi
  80d094:	e8 2c b0 ff ff       	call   8080c5 <tcp_output>
  80d099:	83 c4 10             	add    $0x10,%esp
  u8_t accepted_inseq = 0;
  80d09c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
}
  80d0a0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80d0a4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d0a7:	5b                   	pop    %ebx
  80d0a8:	5e                   	pop    %esi
  80d0a9:	5f                   	pop    %edi
  80d0aa:	5d                   	pop    %ebp
  80d0ab:	c3                   	ret    

0080d0ac <tcp_input>:
{
  80d0ac:	55                   	push   %ebp
  80d0ad:	89 e5                	mov    %esp,%ebp
  80d0af:	57                   	push   %edi
  80d0b0:	56                   	push   %esi
  80d0b1:	53                   	push   %ebx
  80d0b2:	83 ec 38             	sub    $0x38,%esp
  80d0b5:	8b 75 08             	mov    0x8(%ebp),%esi
  iphdr = p->payload;
  80d0b8:	8b 5e 04             	mov    0x4(%esi),%ebx
  80d0bb:	89 1d ac b1 b3 00    	mov    %ebx,0xb3b1ac
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80d0c1:	0f b7 03             	movzwl (%ebx),%eax
  80d0c4:	50                   	push   %eax
  80d0c5:	e8 a7 a6 ff ff       	call   807771 <ntohs>
  80d0ca:	66 c1 e8 08          	shr    $0x8,%ax
  80d0ce:	83 e0 0f             	and    $0xf,%eax
  80d0d1:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80d0d4:	a3 b0 b1 b3 00       	mov    %eax,0xb3b1b0
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80d0d9:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d0de:	0f b7 00             	movzwl (%eax),%eax
  80d0e1:	89 04 24             	mov    %eax,(%esp)
  80d0e4:	e8 88 a6 ff ff       	call   807771 <ntohs>
  80d0e9:	83 c4 08             	add    $0x8,%esp
  80d0ec:	66 c1 e8 06          	shr    $0x6,%ax
  80d0f0:	83 e0 3c             	and    $0x3c,%eax
  80d0f3:	f7 d8                	neg    %eax
  80d0f5:	98                   	cwtl   
  80d0f6:	50                   	push   %eax
  80d0f7:	56                   	push   %esi
  80d0f8:	e8 c0 76 ff ff       	call   8047bd <pbuf_header>
  80d0fd:	83 c4 10             	add    $0x10,%esp
  80d100:	84 c0                	test   %al,%al
  80d102:	75 07                	jne    80d10b <tcp_input+0x5f>
  80d104:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80d109:	77 14                	ja     80d11f <tcp_input+0x73>
    pbuf_free(p);
  80d10b:	83 ec 0c             	sub    $0xc,%esp
  80d10e:	56                   	push   %esi
  80d10f:	e8 76 77 ff ff       	call   80488a <pbuf_free>
    return;
  80d114:	83 c4 10             	add    $0x10,%esp
}
  80d117:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80d11a:	5b                   	pop    %ebx
  80d11b:	5e                   	pop    %esi
  80d11c:	5f                   	pop    %edi
  80d11d:	5d                   	pop    %ebp
  80d11e:	c3                   	ret    
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d11f:	83 ec 08             	sub    $0x8,%esp
  80d122:	ff 75 0c             	pushl  0xc(%ebp)
  80d125:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d12a:	83 c0 10             	add    $0x10,%eax
  80d12d:	50                   	push   %eax
  80d12e:	e8 ce 93 ff ff       	call   806501 <ip_addr_isbroadcast>
  80d133:	83 c4 10             	add    $0x10,%esp
  80d136:	84 c0                	test   %al,%al
  80d138:	0f 85 54 01 00 00    	jne    80d292 <tcp_input+0x1e6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80d13e:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d143:	8b 58 10             	mov    0x10(%eax),%ebx
  80d146:	83 ec 0c             	sub    $0xc,%esp
  80d149:	68 00 00 00 f0       	push   $0xf0000000
  80d14e:	e8 42 a8 ff ff       	call   807995 <ntohl>
  80d153:	21 c3                	and    %eax,%ebx
  80d155:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d15c:	e8 34 a8 ff ff       	call   807995 <ntohl>
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80d161:	83 c4 10             	add    $0x10,%esp
  80d164:	39 c3                	cmp    %eax,%ebx
  80d166:	0f 84 26 01 00 00    	je     80d292 <tcp_input+0x1e6>
      (struct ip_addr *)&(iphdr->dest),
  80d16c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d171:	83 ec 0c             	sub    $0xc,%esp
  80d174:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80d178:	52                   	push   %edx
  80d179:	6a 06                	push   $0x6
  80d17b:	8d 50 10             	lea    0x10(%eax),%edx
  80d17e:	52                   	push   %edx
  80d17f:	83 c0 0c             	add    $0xc,%eax
  80d182:	50                   	push   %eax
  80d183:	56                   	push   %esi
  80d184:	e8 b7 a2 ff ff       	call   807440 <inet_chksum_pseudo>
  80d189:	83 c4 20             	add    $0x20,%esp
  80d18c:	66 85 c0             	test   %ax,%ax
  80d18f:	0f 85 0e 01 00 00    	jne    80d2a3 <tcp_input+0x1f7>
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d195:	83 ec 0c             	sub    $0xc,%esp
  80d198:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d19d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d1a1:	50                   	push   %eax
  80d1a2:	e8 ca a5 ff ff       	call   807771 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  80d1a7:	83 c4 08             	add    $0x8,%esp
  hdrlen = TCPH_HDRLEN(tcphdr);
  80d1aa:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80d1ae:	f7 d8                	neg    %eax
  80d1b0:	c1 e0 02             	shl    $0x2,%eax
  80d1b3:	98                   	cwtl   
  80d1b4:	50                   	push   %eax
  80d1b5:	56                   	push   %esi
  80d1b6:	e8 02 76 ff ff       	call   8047bd <pbuf_header>
  80d1bb:	83 c4 10             	add    $0x10,%esp
  80d1be:	84 c0                	test   %al,%al
  80d1c0:	0f 85 ee 00 00 00    	jne    80d2b4 <tcp_input+0x208>
  tcphdr->src = ntohs(tcphdr->src);
  80d1c6:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d1cc:	83 ec 0c             	sub    $0xc,%esp
  80d1cf:	0f b7 03             	movzwl (%ebx),%eax
  80d1d2:	50                   	push   %eax
  80d1d3:	e8 99 a5 ff ff       	call   807771 <ntohs>
  80d1d8:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80d1db:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d1e1:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80d1e5:	89 04 24             	mov    %eax,(%esp)
  80d1e8:	e8 84 a5 ff ff       	call   807771 <ntohs>
  80d1ed:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80d1f1:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d1f7:	83 c4 04             	add    $0x4,%esp
  80d1fa:	ff 73 04             	pushl  0x4(%ebx)
  80d1fd:	e8 93 a7 ff ff       	call   807995 <ntohl>
  80d202:	89 43 04             	mov    %eax,0x4(%ebx)
  80d205:	a3 a8 b1 b3 00       	mov    %eax,0xb3b1a8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80d20a:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d210:	83 c4 04             	add    $0x4,%esp
  80d213:	ff 73 08             	pushl  0x8(%ebx)
  80d216:	e8 7a a7 ff ff       	call   807995 <ntohl>
  80d21b:	89 43 08             	mov    %eax,0x8(%ebx)
  80d21e:	a3 a4 b1 b3 00       	mov    %eax,0xb3b1a4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80d223:	8b 1d b0 b1 b3 00    	mov    0xb3b1b0,%ebx
  80d229:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80d22d:	89 04 24             	mov    %eax,(%esp)
  80d230:	e8 3c a5 ff ff       	call   807771 <ntohs>
  80d235:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80d239:	a1 b0 b1 b3 00       	mov    0xb3b1b0,%eax
  80d23e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d242:	89 04 24             	mov    %eax,(%esp)
  80d245:	e8 27 a5 ff ff       	call   807771 <ntohs>
  80d24a:	89 c1                	mov    %eax,%ecx
  80d24c:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80d250:	83 e0 3f             	and    $0x3f,%eax
  80d253:	a2 a0 b1 b3 00       	mov    %al,0xb3b1a0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80d258:	83 c4 10             	add    $0x10,%esp
  80d25b:	f6 c1 03             	test   $0x3,%cl
  80d25e:	0f 95 c0             	setne  %al
  80d261:	0f b6 c0             	movzbl %al,%eax
  80d264:	66 03 46 08          	add    0x8(%esi),%ax
  80d268:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80d26c:	66 a3 9e b1 b3 00    	mov    %ax,0xb3b19e
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d272:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d277:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if (pcb->remote_port == tcphdr->src &&
  80d27a:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d280:	8b 0d ac b1 b3 00    	mov    0xb3b1ac,%ecx
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d286:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  80d288:	bf 00 00 00 00       	mov    $0x0,%edi
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d28d:	e9 ab 00 00 00       	jmp    80d33d <tcp_input+0x291>
    pbuf_free(p);
  80d292:	83 ec 0c             	sub    $0xc,%esp
  80d295:	56                   	push   %esi
  80d296:	e8 ef 75 ff ff       	call   80488a <pbuf_free>
    return;
  80d29b:	83 c4 10             	add    $0x10,%esp
  80d29e:	e9 74 fe ff ff       	jmp    80d117 <tcp_input+0x6b>
    pbuf_free(p);
  80d2a3:	83 ec 0c             	sub    $0xc,%esp
  80d2a6:	56                   	push   %esi
  80d2a7:	e8 de 75 ff ff       	call   80488a <pbuf_free>
    return;
  80d2ac:	83 c4 10             	add    $0x10,%esp
  80d2af:	e9 63 fe ff ff       	jmp    80d117 <tcp_input+0x6b>
    pbuf_free(p);
  80d2b4:	83 ec 0c             	sub    $0xc,%esp
  80d2b7:	56                   	push   %esi
  80d2b8:	e8 cd 75 ff ff       	call   80488a <pbuf_free>
    return;
  80d2bd:	83 c4 10             	add    $0x10,%esp
  80d2c0:	e9 52 fe ff ff       	jmp    80d117 <tcp_input+0x6b>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d2c5:	83 ec 04             	sub    $0x4,%esp
  80d2c8:	68 70 35 81 00       	push   $0x813570
  80d2cd:	68 b5 00 00 00       	push   $0xb5
  80d2d2:	68 94 36 81 00       	push   $0x813694
  80d2d7:	e8 bd 13 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d2dc:	83 ec 04             	sub    $0x4,%esp
  80d2df:	68 98 35 81 00       	push   $0x813598
  80d2e4:	68 b6 00 00 00       	push   $0xb6
  80d2e9:	68 94 36 81 00       	push   $0x813694
  80d2ee:	e8 a6 13 00 00       	call   80e699 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d2f3:	83 ec 04             	sub    $0x4,%esp
  80d2f6:	68 c4 35 81 00       	push   $0x8135c4
  80d2fb:	68 b7 00 00 00       	push   $0xb7
  80d300:	68 94 36 81 00       	push   $0x813694
  80d305:	e8 8f 13 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d30a:	83 ec 04             	sub    $0x4,%esp
  80d30d:	68 ec 35 81 00       	push   $0x8135ec
  80d312:	68 c0 00 00 00       	push   $0xc0
  80d317:	68 94 36 81 00       	push   $0x813694
  80d31c:	e8 78 13 00 00       	call   80e699 <_panic>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d321:	83 ec 04             	sub    $0x4,%esp
  80d324:	68 18 36 81 00       	push   $0x813618
  80d329:	68 c6 00 00 00       	push   $0xc6
  80d32e:	68 94 36 81 00       	push   $0x813694
  80d333:	e8 61 13 00 00       	call   80e699 <_panic>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80d338:	89 df                	mov    %ebx,%edi
  80d33a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d33d:	85 db                	test   %ebx,%ebx
  80d33f:	0f 84 b3 0a 00 00    	je     80ddf8 <tcp_input+0xd4c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80d345:	8b 43 10             	mov    0x10(%ebx),%eax
  80d348:	85 c0                	test   %eax,%eax
  80d34a:	0f 84 75 ff ff ff    	je     80d2c5 <tcp_input+0x219>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80d350:	83 f8 0a             	cmp    $0xa,%eax
  80d353:	74 87                	je     80d2dc <tcp_input+0x230>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80d355:	83 f8 01             	cmp    $0x1,%eax
  80d358:	74 99                	je     80d2f3 <tcp_input+0x247>
    if (pcb->remote_port == tcphdr->src &&
  80d35a:	0f b7 02             	movzwl (%edx),%eax
  80d35d:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d361:	75 d5                	jne    80d338 <tcp_input+0x28c>
  80d363:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d367:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d36b:	75 cb                	jne    80d338 <tcp_input+0x28c>
       pcb->local_port == tcphdr->dest &&
  80d36d:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d370:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d373:	75 c3                	jne    80d338 <tcp_input+0x28c>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d375:	8b 41 10             	mov    0x10(%ecx),%eax
  80d378:	39 03                	cmp    %eax,(%ebx)
  80d37a:	75 bc                	jne    80d338 <tcp_input+0x28c>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80d37c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d37f:	39 c3                	cmp    %eax,%ebx
  80d381:	74 87                	je     80d30a <tcp_input+0x25e>
      if (prev != NULL) {
  80d383:	85 ff                	test   %edi,%edi
  80d385:	74 13                	je     80d39a <tcp_input+0x2ee>
        prev->next = pcb->next;
  80d387:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80d38a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d38d:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80d390:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80d396:	39 c3                	cmp    %eax,%ebx
  80d398:	74 87                	je     80d321 <tcp_input+0x275>
    inseg.next = NULL;
  80d39a:	c7 05 b4 b1 b3 00 00 	movl   $0x0,0xb3b1b4
  80d3a1:	00 00 00 
    inseg.len = p->tot_len;
  80d3a4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d3a8:	66 a3 c0 b1 b3 00    	mov    %ax,0xb3b1c0
    inseg.dataptr = p->payload;
  80d3ae:	8b 46 04             	mov    0x4(%esi),%eax
  80d3b1:	a3 bc b1 b3 00       	mov    %eax,0xb3b1bc
    inseg.p = p;
  80d3b6:	89 35 b8 b1 b3 00    	mov    %esi,0xb3b1b8
    inseg.tcphdr = tcphdr;
  80d3bc:	89 15 c4 b1 b3 00    	mov    %edx,0xb3b1c4
    recv_data = NULL;
  80d3c2:	c7 05 98 b1 b3 00 00 	movl   $0x0,0xb3b198
  80d3c9:	00 00 00 
    recv_flags = 0;
  80d3cc:	c6 05 9c b1 b3 00 00 	movb   $0x0,0xb3b19c
    if (pcb->refused_data != NULL) {
  80d3d3:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80d3d9:	85 c0                	test   %eax,%eax
  80d3db:	74 2c                	je     80d409 <tcp_input+0x35d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d3dd:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80d3e3:	85 d2                	test   %edx,%edx
  80d3e5:	0f 84 07 03 00 00    	je     80d6f2 <tcp_input+0x646>
  80d3eb:	6a 00                	push   $0x0
  80d3ed:	50                   	push   %eax
  80d3ee:	53                   	push   %ebx
  80d3ef:	ff 73 18             	pushl  0x18(%ebx)
  80d3f2:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80d3f4:	83 c4 10             	add    $0x10,%esp
  80d3f7:	84 c0                	test   %al,%al
  80d3f9:	0f 85 04 03 00 00    	jne    80d703 <tcp_input+0x657>
        pcb->refused_data = NULL;
  80d3ff:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80d406:	00 00 00 
    tcp_input_pcb = pcb;
  80d409:	89 1d 58 b2 b3 00    	mov    %ebx,0xb3b258
  if (flags & TCP_RST) {
  80d40f:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80d416:	a8 04                	test   $0x4,%al
  80d418:	0f 84 20 03 00 00    	je     80d73e <tcp_input+0x692>
    if (pcb->state == SYN_SENT) {
  80d41e:	8b 53 10             	mov    0x10(%ebx),%edx
  80d421:	83 fa 02             	cmp    $0x2,%edx
  80d424:	0f 84 ea 02 00 00    	je     80d714 <tcp_input+0x668>
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d42a:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d42f:	2b 43 24             	sub    0x24(%ebx),%eax
  80d432:	78 1d                	js     80d451 <tcp_input+0x3a5>
  80d434:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80d438:	29 c8                	sub    %ecx,%eax
  80d43a:	85 c0                	test   %eax,%eax
  80d43c:	7f 13                	jg     80d451 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d43e:	85 d2                	test   %edx,%edx
  80d440:	0f 84 e1 02 00 00    	je     80d727 <tcp_input+0x67b>
      recv_flags = TF_RESET;
  80d446:	c6 05 9c b1 b3 00 08 	movb   $0x8,0xb3b19c
      pcb->flags &= ~TF_ACK_DELAY;
  80d44d:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
    tcp_input_pcb = NULL;
  80d451:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d458:	00 00 00 
      if (recv_flags & TF_RESET) {
  80d45b:	0f b6 05 9c b1 b3 00 	movzbl 0xb3b19c,%eax
  80d462:	a8 08                	test   $0x8,%al
  80d464:	0f 84 37 08 00 00    	je     80dca1 <tcp_input+0xbf5>
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80d46a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d470:	85 c0                	test   %eax,%eax
  80d472:	74 0d                	je     80d481 <tcp_input+0x3d5>
  80d474:	83 ec 08             	sub    $0x8,%esp
  80d477:	6a fa                	push   $0xfffffffa
  80d479:	ff 73 18             	pushl  0x18(%ebx)
  80d47c:	ff d0                	call   *%eax
  80d47e:	83 c4 10             	add    $0x10,%esp
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80d481:	83 ec 08             	sub    $0x8,%esp
  80d484:	53                   	push   %ebx
  80d485:	68 3c b2 b3 00       	push   $0xb3b23c
  80d48a:	e8 ab 84 ff ff       	call   80593a <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80d48f:	83 c4 08             	add    $0x8,%esp
  80d492:	53                   	push   %ebx
  80d493:	6a 02                	push   $0x2
  80d495:	e8 a3 70 ff ff       	call   80453d <memp_free>
  80d49a:	83 c4 10             	add    $0x10,%esp
    if (inseg.p != NULL)
  80d49d:	a1 b8 b1 b3 00       	mov    0xb3b1b8,%eax
  80d4a2:	85 c0                	test   %eax,%eax
  80d4a4:	0f 84 6d fc ff ff    	je     80d117 <tcp_input+0x6b>
      pbuf_free(inseg.p);
  80d4aa:	83 ec 0c             	sub    $0xc,%esp
  80d4ad:	50                   	push   %eax
  80d4ae:	e8 d7 73 ff ff       	call   80488a <pbuf_free>
      inseg.p = NULL;
  80d4b3:	c7 05 b8 b1 b3 00 00 	movl   $0x0,0xb3b1b8
  80d4ba:	00 00 00 
  80d4bd:	83 c4 10             	add    $0x10,%esp
  80d4c0:	e9 52 fc ff ff       	jmp    80d117 <tcp_input+0x6b>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d4c5:	83 ec 04             	sub    $0x4,%esp
  80d4c8:	68 44 36 81 00       	push   $0x813644
  80d4cd:	68 d0 00 00 00       	push   $0xd0
  80d4d2:	68 94 36 81 00       	push   $0x813694
  80d4d7:	e8 bd 11 00 00       	call   80e699 <_panic>
    tcp_ack_now(pcb);
  80d4dc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d4e0:	83 ec 0c             	sub    $0xc,%esp
  80d4e3:	53                   	push   %ebx
  80d4e4:	e8 dc ab ff ff       	call   8080c5 <tcp_output>
  80d4e9:	83 c4 10             	add    $0x10,%esp
  80d4ec:	eb 4c                	jmp    80d53a <tcp_input+0x48e>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80d4ee:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80d4f1:	85 db                	test   %ebx,%ebx
  80d4f3:	74 5e                	je     80d553 <tcp_input+0x4a7>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80d4f5:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80d4f9:	75 ca                	jne    80d4c5 <tcp_input+0x419>
      if (pcb->remote_port == tcphdr->src &&
  80d4fb:	0f b7 02             	movzwl (%edx),%eax
  80d4fe:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80d502:	75 ea                	jne    80d4ee <tcp_input+0x442>
  80d504:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d508:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80d50c:	75 e0                	jne    80d4ee <tcp_input+0x442>
         pcb->local_port == tcphdr->dest &&
  80d50e:	8b 41 0c             	mov    0xc(%ecx),%eax
  80d511:	39 43 04             	cmp    %eax,0x4(%ebx)
  80d514:	75 d8                	jne    80d4ee <tcp_input+0x442>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80d516:	8b 41 10             	mov    0x10(%ecx),%eax
  80d519:	39 03                	cmp    %eax,(%ebx)
  80d51b:	75 d1                	jne    80d4ee <tcp_input+0x442>
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80d51d:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d521:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d527:	89 c2                	mov    %eax,%edx
  80d529:	2b 53 24             	sub    0x24(%ebx),%edx
  80d52c:	85 d2                	test   %edx,%edx
  80d52e:	7e 03                	jle    80d533 <tcp_input+0x487>
    pcb->rcv_nxt = seqno + tcplen;
  80d530:	89 43 24             	mov    %eax,0x24(%ebx)
  if (tcplen > 0) {
  80d533:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%ebp)
  80d538:	75 a2                	jne    80d4dc <tcp_input+0x430>
  return tcp_output(pcb);
  80d53a:	83 ec 0c             	sub    $0xc,%esp
  80d53d:	53                   	push   %ebx
  80d53e:	e8 82 ab ff ff       	call   8080c5 <tcp_output>
        pbuf_free(p);
  80d543:	89 34 24             	mov    %esi,(%esp)
  80d546:	e8 3f 73 ff ff       	call   80488a <pbuf_free>
        return;
  80d54b:	83 c4 10             	add    $0x10,%esp
  80d54e:	e9 c4 fb ff ff       	jmp    80d117 <tcp_input+0x6b>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d553:	a1 44 b2 b3 00       	mov    0xb3b244,%eax
  80d558:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80d55b:	89 c7                	mov    %eax,%edi
  80d55d:	eb 0f                	jmp    80d56e <tcp_input+0x4c2>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80d55f:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d563:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  80d567:	74 1a                	je     80d583 <tcp_input+0x4d7>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80d569:	89 fb                	mov    %edi,%ebx
  80d56b:	8b 7f 0c             	mov    0xc(%edi),%edi
  80d56e:	85 ff                	test   %edi,%edi
  80d570:	0f 84 5d 08 00 00    	je     80ddd3 <tcp_input+0xd27>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80d576:	8b 07                	mov    (%edi),%eax
  80d578:	85 c0                	test   %eax,%eax
  80d57a:	74 e3                	je     80d55f <tcp_input+0x4b3>
  80d57c:	3b 41 10             	cmp    0x10(%ecx),%eax
  80d57f:	75 e8                	jne    80d569 <tcp_input+0x4bd>
  80d581:	eb dc                	jmp    80d55f <tcp_input+0x4b3>
        if (prev != NULL) {
  80d583:	85 db                	test   %ebx,%ebx
  80d585:	74 12                	je     80d599 <tcp_input+0x4ed>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80d587:	8b 47 0c             	mov    0xc(%edi),%eax
  80d58a:	89 43 0c             	mov    %eax,0xc(%ebx)
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80d58d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80d590:	89 47 0c             	mov    %eax,0xc(%edi)
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80d593:	89 3d 44 b2 b3 00    	mov    %edi,0xb3b244
  if (flags & TCP_ACK) {
  80d599:	f6 45 d6 10          	testb  $0x10,-0x2a(%ebp)
  80d59d:	75 17                	jne    80d5b6 <tcp_input+0x50a>
  } else if (flags & TCP_SYN) {
  80d59f:	f6 45 d6 02          	testb  $0x2,-0x2a(%ebp)
  80d5a3:	75 43                	jne    80d5e8 <tcp_input+0x53c>
        pbuf_free(p);
  80d5a5:	83 ec 0c             	sub    $0xc,%esp
  80d5a8:	56                   	push   %esi
  80d5a9:	e8 dc 72 ff ff       	call   80488a <pbuf_free>
        return;
  80d5ae:	83 c4 10             	add    $0x10,%esp
  80d5b1:	e9 61 fb ff ff       	jmp    80d117 <tcp_input+0x6b>
    tcp_rst(ackno + 1, seqno + tcplen,
  80d5b6:	83 ec 08             	sub    $0x8,%esp
  80d5b9:	0f b7 02             	movzwl (%edx),%eax
  80d5bc:	50                   	push   %eax
  80d5bd:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80d5c1:	50                   	push   %eax
  80d5c2:	8d 41 0c             	lea    0xc(%ecx),%eax
  80d5c5:	50                   	push   %eax
  80d5c6:	83 c1 10             	add    $0x10,%ecx
  80d5c9:	51                   	push   %ecx
  80d5ca:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80d5ce:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d5d4:	50                   	push   %eax
  80d5d5:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d5da:	83 c0 01             	add    $0x1,%eax
  80d5dd:	50                   	push   %eax
  80d5de:	e8 82 af ff ff       	call   808565 <tcp_rst>
  80d5e3:	83 c4 20             	add    $0x20,%esp
  80d5e6:	eb bd                	jmp    80d5a5 <tcp_input+0x4f9>
    npcb = tcp_alloc(pcb->prio);
  80d5e8:	83 ec 0c             	sub    $0xc,%esp
  80d5eb:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  80d5ef:	50                   	push   %eax
  80d5f0:	e8 a3 8b ff ff       	call   806198 <tcp_alloc>
  80d5f5:	89 c3                	mov    %eax,%ebx
    if (npcb == NULL) {
  80d5f7:	83 c4 10             	add    $0x10,%esp
  80d5fa:	85 c0                	test   %eax,%eax
  80d5fc:	74 a7                	je     80d5a5 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d5fe:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d603:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80d606:	0f 84 c5 00 00 00    	je     80d6d1 <tcp_input+0x625>
  80d60c:	8b 50 10             	mov    0x10(%eax),%edx
  80d60f:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  80d611:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d615:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d619:	8b 50 0c             	mov    0xc(%eax),%edx
  80d61c:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  80d61f:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d625:	0f b7 02             	movzwl (%edx),%eax
  80d628:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  80d62c:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  80d633:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d638:	8d 48 01             	lea    0x1(%eax),%ecx
  80d63b:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  80d63e:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d642:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  80d646:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80d64a:	83 e8 01             	sub    $0x1,%eax
  80d64d:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  80d650:	8b 47 18             	mov    0x18(%edi),%eax
  80d653:	89 43 18             	mov    %eax,0x18(%ebx)
    npcb->accept = pcb->accept;
  80d656:	8b 47 20             	mov    0x20(%edi),%eax
  80d659:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80d65f:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d663:	66 25 99 01          	and    $0x199,%ax
  80d667:	66 89 43 08          	mov    %ax,0x8(%ebx)
    TCP_REG(&tcp_active_pcbs, npcb);
  80d66b:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80d670:	89 43 0c             	mov    %eax,0xc(%ebx)
  80d673:	89 1d 3c b2 b3 00    	mov    %ebx,0xb3b23c
  80d679:	e8 e2 4b ff ff       	call   802260 <tcp_timer_needed>
    tcp_parseopt(npcb);
  80d67e:	89 d8                	mov    %ebx,%eax
  80d680:	e8 98 ec ff ff       	call   80c31d <tcp_parseopt>
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80d685:	83 ec 08             	sub    $0x8,%esp
  80d688:	8d 43 04             	lea    0x4(%ebx),%eax
  80d68b:	50                   	push   %eax
  80d68c:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d690:	50                   	push   %eax
  80d691:	e8 a0 8c ff ff       	call   806336 <tcp_eff_send_mss>
  80d696:	66 89 43 34          	mov    %ax,0x34(%ebx)
    optdata = TCP_BUILD_MSS_OPTION();
  80d69a:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80d6a1:	e8 d8 a0 ff ff       	call   80777e <htonl>
  80d6a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80d6a9:	83 c4 0c             	add    $0xc,%esp
  80d6ac:	6a 04                	push   $0x4
  80d6ae:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d6b1:	50                   	push   %eax
  80d6b2:	6a 00                	push   $0x0
  80d6b4:	6a 12                	push   $0x12
  80d6b6:	6a 00                	push   $0x0
  80d6b8:	6a 00                	push   $0x0
  80d6ba:	53                   	push   %ebx
  80d6bb:	e8 e8 a2 ff ff       	call   8079a8 <tcp_enqueue>
    return tcp_output(npcb);
  80d6c0:	83 c4 14             	add    $0x14,%esp
  80d6c3:	53                   	push   %ebx
  80d6c4:	e8 fc a9 ff ff       	call   8080c5 <tcp_output>
  80d6c9:	83 c4 10             	add    $0x10,%esp
  80d6cc:	e9 d4 fe ff ff       	jmp    80d5a5 <tcp_input+0x4f9>
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80d6d1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    npcb->local_port = pcb->local_port;
  80d6d7:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  80d6db:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80d6df:	ba 00 00 00 00       	mov    $0x0,%edx
  80d6e4:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80d6e7:	0f 84 2f ff ff ff    	je     80d61c <tcp_input+0x570>
  80d6ed:	e9 27 ff ff ff       	jmp    80d619 <tcp_input+0x56d>
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80d6f2:	83 ec 0c             	sub    $0xc,%esp
  80d6f5:	50                   	push   %eax
  80d6f6:	e8 8f 71 ff ff       	call   80488a <pbuf_free>
  80d6fb:	83 c4 10             	add    $0x10,%esp
  80d6fe:	e9 fc fc ff ff       	jmp    80d3ff <tcp_input+0x353>
        pbuf_free(p);
  80d703:	83 ec 0c             	sub    $0xc,%esp
  80d706:	56                   	push   %esi
  80d707:	e8 7e 71 ff ff       	call   80488a <pbuf_free>
        return;
  80d70c:	83 c4 10             	add    $0x10,%esp
  80d70f:	e9 03 fa ff ff       	jmp    80d117 <tcp_input+0x6b>
      if (ackno == pcb->snd_nxt) {
  80d714:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80d719:	39 43 54             	cmp    %eax,0x54(%ebx)
  80d71c:	0f 84 24 fd ff ff    	je     80d446 <tcp_input+0x39a>
  80d722:	e9 2a fd ff ff       	jmp    80d451 <tcp_input+0x3a5>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80d727:	83 ec 04             	sub    $0x4,%esp
  80d72a:	68 74 36 81 00       	push   $0x813674
  80d72f:	68 09 02 00 00       	push   $0x209
  80d734:	68 94 36 81 00       	push   $0x813694
  80d739:	e8 5b 0f 00 00       	call   80e699 <_panic>
  pcb->tmr = tcp_ticks;
  80d73e:	8b 15 40 b2 b3 00    	mov    0xb3b240,%edx
  80d744:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80d747:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  switch (pcb->state) {
  80d74e:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80d752:	0f 87 3a 05 00 00    	ja     80dc92 <tcp_input+0xbe6>
  80d758:	8b 53 10             	mov    0x10(%ebx),%edx
  80d75b:	ff 24 95 18 37 81 00 	jmp    *0x813718(,%edx,4)
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80d762:	83 e0 12             	and    $0x12,%eax
  80d765:	3c 12                	cmp    $0x12,%al
  80d767:	74 4d                	je     80d7b6 <tcp_input+0x70a>
    else if (flags & TCP_ACK) {
  80d769:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80d770:	0f 84 db fc ff ff    	je     80d451 <tcp_input+0x3a5>
        tcphdr->dest, tcphdr->src);
  80d776:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d77c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d781:	83 ec 08             	sub    $0x8,%esp
  80d784:	0f b7 0a             	movzwl (%edx),%ecx
  80d787:	51                   	push   %ecx
  80d788:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80d78c:	52                   	push   %edx
  80d78d:	8d 50 0c             	lea    0xc(%eax),%edx
  80d790:	52                   	push   %edx
  80d791:	83 c0 10             	add    $0x10,%eax
  80d794:	50                   	push   %eax
  80d795:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d79c:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d7a2:	50                   	push   %eax
  80d7a3:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80d7a9:	e8 b7 ad ff ff       	call   808565 <tcp_rst>
  80d7ae:	83 c4 20             	add    $0x20,%esp
  80d7b1:	e9 9b fc ff ff       	jmp    80d451 <tcp_input+0x3a5>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80d7b6:	83 ec 0c             	sub    $0xc,%esp
  80d7b9:	8b 43 78             	mov    0x78(%ebx),%eax
  80d7bc:	8b 40 10             	mov    0x10(%eax),%eax
  80d7bf:	ff 70 04             	pushl  0x4(%eax)
  80d7c2:	e8 ce a1 ff ff       	call   807995 <ntohl>
  80d7c7:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d7cd:	83 c0 01             	add    $0x1,%eax
  80d7d0:	83 c4 10             	add    $0x10,%esp
  80d7d3:	39 d0                	cmp    %edx,%eax
  80d7d5:	75 92                	jne    80d769 <tcp_input+0x6bd>
      pcb->snd_buf++;
  80d7d7:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80d7dc:	a1 a8 b1 b3 00       	mov    0xb3b1a8,%eax
  80d7e1:	8d 48 01             	lea    0x1(%eax),%ecx
  80d7e4:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80d7e7:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80d7ea:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
  80d7f0:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80d7f4:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80d7f8:	83 e8 01             	sub    $0x1,%eax
  80d7fb:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80d7fe:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
      tcp_parseopt(pcb);
  80d805:	89 d8                	mov    %ebx,%eax
  80d807:	e8 11 eb ff ff       	call   80c31d <tcp_parseopt>
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80d80c:	83 ec 08             	sub    $0x8,%esp
  80d80f:	8d 43 04             	lea    0x4(%ebx),%eax
  80d812:	50                   	push   %eax
  80d813:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80d817:	50                   	push   %eax
  80d818:	e8 19 8b ff ff       	call   806336 <tcp_eff_send_mss>
  80d81d:	66 89 43 34          	mov    %ax,0x34(%ebx)
      pcb->ssthresh = pcb->mss * 10;
  80d821:	6b d0 0a             	imul   $0xa,%eax,%edx
  80d824:	66 89 53 50          	mov    %dx,0x50(%ebx)
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d828:	83 c4 10             	add    $0x10,%esp
  80d82b:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80d830:	74 63                	je     80d895 <tcp_input+0x7e9>
  80d832:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d836:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80d83a:	66 85 c0             	test   %ax,%ax
  80d83d:	74 5a                	je     80d899 <tcp_input+0x7ed>
      --pcb->snd_queuelen;
  80d83f:	83 e8 01             	sub    $0x1,%eax
  80d842:	66 89 43 70          	mov    %ax,0x70(%ebx)
      rseg = pcb->unacked;
  80d846:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80d849:	8b 10                	mov    (%eax),%edx
  80d84b:	89 53 78             	mov    %edx,0x78(%ebx)
      if(pcb->unacked == NULL)
  80d84e:	85 d2                	test   %edx,%edx
  80d850:	74 5e                	je     80d8b0 <tcp_input+0x804>
        pcb->rtime = 0;
  80d852:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80d858:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      tcp_seg_free(rseg);
  80d85c:	83 ec 0c             	sub    $0xc,%esp
  80d85f:	50                   	push   %eax
  80d860:	e8 3f 7f ff ff       	call   8057a4 <tcp_seg_free>
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80d865:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80d86b:	83 c4 10             	add    $0x10,%esp
  80d86e:	85 c0                	test   %eax,%eax
  80d870:	74 0e                	je     80d880 <tcp_input+0x7d4>
  80d872:	83 ec 04             	sub    $0x4,%esp
  80d875:	6a 00                	push   $0x0
  80d877:	53                   	push   %ebx
  80d878:	ff 73 18             	pushl  0x18(%ebx)
  80d87b:	ff d0                	call   *%eax
  80d87d:	83 c4 10             	add    $0x10,%esp
      tcp_ack_now(pcb);
  80d880:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d884:	83 ec 0c             	sub    $0xc,%esp
  80d887:	53                   	push   %ebx
  80d888:	e8 38 a8 ff ff       	call   8080c5 <tcp_output>
  80d88d:	83 c4 10             	add    $0x10,%esp
  80d890:	e9 bc fb ff ff       	jmp    80d451 <tcp_input+0x3a5>
      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d895:	01 c0                	add    %eax,%eax
  80d897:	eb 99                	jmp    80d832 <tcp_input+0x786>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80d899:	83 ec 04             	sub    $0x4,%esp
  80d89c:	68 ed 36 81 00       	push   $0x8136ed
  80d8a1:	68 35 02 00 00       	push   $0x235
  80d8a6:	68 94 36 81 00       	push   $0x813694
  80d8ab:	e8 e9 0d 00 00       	call   80e699 <_panic>
        pcb->rtime = -1;
  80d8b0:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80d8b6:	eb a4                	jmp    80d85c <tcp_input+0x7b0>
    if (flags & TCP_ACK &&
  80d8b8:	83 e0 14             	and    $0x14,%eax
  80d8bb:	3c 10                	cmp    $0x10,%al
  80d8bd:	0f 85 8e fb ff ff    	jne    80d451 <tcp_input+0x3a5>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80d8c3:	8b 15 a4 b1 b3 00    	mov    0xb3b1a4,%edx
  80d8c9:	8d 42 ff             	lea    -0x1(%edx),%eax
  80d8cc:	3b 43 48             	cmp    0x48(%ebx),%eax
  80d8cf:	78 09                	js     80d8da <tcp_input+0x82e>
  80d8d1:	89 d0                	mov    %edx,%eax
  80d8d3:	2b 43 54             	sub    0x54(%ebx),%eax
  80d8d6:	85 c0                	test   %eax,%eax
  80d8d8:	7e 3b                	jle    80d915 <tcp_input+0x869>
                tcphdr->dest, tcphdr->src);
  80d8da:	8b 0d b0 b1 b3 00    	mov    0xb3b1b0,%ecx
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80d8e0:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
  80d8e5:	83 ec 08             	sub    $0x8,%esp
  80d8e8:	0f b7 31             	movzwl (%ecx),%esi
  80d8eb:	56                   	push   %esi
  80d8ec:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80d8f0:	51                   	push   %ecx
  80d8f1:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d8f4:	51                   	push   %ecx
  80d8f5:	83 c0 10             	add    $0x10,%eax
  80d8f8:	50                   	push   %eax
  80d8f9:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80d900:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80d906:	50                   	push   %eax
  80d907:	52                   	push   %edx
  80d908:	e8 58 ac ff ff       	call   808565 <tcp_rst>
  80d90d:	83 c4 20             	add    $0x20,%esp
  80d910:	e9 3c fb ff ff       	jmp    80d451 <tcp_input+0x3a5>
        pcb->state = ESTABLISHED;
  80d915:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d91c:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80d922:	85 c0                	test   %eax,%eax
  80d924:	74 5c                	je     80d982 <tcp_input+0x8d6>
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80d926:	83 ec 04             	sub    $0x4,%esp
  80d929:	6a 00                	push   $0x0
  80d92b:	53                   	push   %ebx
  80d92c:	ff 73 18             	pushl  0x18(%ebx)
  80d92f:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80d931:	83 c4 10             	add    $0x10,%esp
  80d934:	84 c0                	test   %al,%al
  80d936:	75 61                	jne    80d999 <tcp_input+0x8ed>
        old_cwnd = pcb->cwnd;
  80d938:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        accepted_inseq = tcp_receive(pcb);
  80d93c:	89 d8                	mov    %ebx,%eax
  80d93e:	e8 8e ea ff ff       	call   80c3d1 <tcp_receive>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d943:	66 83 fe 01          	cmp    $0x1,%si
  80d947:	74 6b                	je     80d9b4 <tcp_input+0x908>
  80d949:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80d94d:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
        if ((flags & TCP_FIN) && accepted_inseq) {
  80d951:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d958:	0f 84 f3 fa ff ff    	je     80d451 <tcp_input+0x3a5>
  80d95e:	84 c0                	test   %al,%al
  80d960:	0f 84 eb fa ff ff    	je     80d451 <tcp_input+0x3a5>
          tcp_ack_now(pcb);
  80d966:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d96a:	83 ec 0c             	sub    $0xc,%esp
  80d96d:	53                   	push   %ebx
  80d96e:	e8 52 a7 ff ff       	call   8080c5 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80d973:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d97a:	83 c4 10             	add    $0x10,%esp
  80d97d:	e9 cf fa ff ff       	jmp    80d451 <tcp_input+0x3a5>
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80d982:	83 ec 04             	sub    $0x4,%esp
  80d985:	68 03 37 81 00       	push   $0x813703
  80d98a:	68 5b 02 00 00       	push   $0x25b
  80d98f:	68 94 36 81 00       	push   $0x813694
  80d994:	e8 00 0d 00 00       	call   80e699 <_panic>
          tcp_abort(pcb);
  80d999:	83 ec 0c             	sub    $0xc,%esp
  80d99c:	53                   	push   %ebx
  80d99d:	e8 4e 82 ff ff       	call   805bf0 <tcp_abort>
    tcp_input_pcb = NULL;
  80d9a2:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80d9a9:	00 00 00 
  80d9ac:	83 c4 10             	add    $0x10,%esp
  80d9af:	e9 e9 fa ff ff       	jmp    80d49d <tcp_input+0x3f1>
        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80d9b4:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80d9b8:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80d9bb:	eb 90                	jmp    80d94d <tcp_input+0x8a1>
    accepted_inseq = tcp_receive(pcb);
  80d9bd:	89 d8                	mov    %ebx,%eax
  80d9bf:	e8 0d ea ff ff       	call   80c3d1 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80d9c4:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80d9cb:	0f 84 80 fa ff ff    	je     80d451 <tcp_input+0x3a5>
  80d9d1:	84 c0                	test   %al,%al
  80d9d3:	0f 84 78 fa ff ff    	je     80d451 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80d9d9:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80d9dd:	83 ec 0c             	sub    $0xc,%esp
  80d9e0:	53                   	push   %ebx
  80d9e1:	e8 df a6 ff ff       	call   8080c5 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80d9e6:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80d9ed:	83 c4 10             	add    $0x10,%esp
  80d9f0:	e9 5c fa ff ff       	jmp    80d451 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80d9f5:	89 d8                	mov    %ebx,%eax
  80d9f7:	e8 d5 e9 ff ff       	call   80c3d1 <tcp_receive>
    if (flags & TCP_FIN) {
  80d9fc:	0f b6 05 a0 b1 b3 00 	movzbl 0xb3b1a0,%eax
  80da03:	a8 01                	test   $0x1,%al
  80da05:	0f 84 c7 00 00 00    	je     80dad2 <tcp_input+0xa26>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80da0b:	a8 10                	test   $0x10,%al
  80da0d:	74 0a                	je     80da19 <tcp_input+0x96d>
  80da0f:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80da14:	39 43 54             	cmp    %eax,0x54(%ebx)
  80da17:	74 1c                	je     80da35 <tcp_input+0x989>
        tcp_ack_now(pcb);
  80da19:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da1d:	83 ec 0c             	sub    $0xc,%esp
  80da20:	53                   	push   %ebx
  80da21:	e8 9f a6 ff ff       	call   8080c5 <tcp_output>
        pcb->state = CLOSING;
  80da26:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80da2d:	83 c4 10             	add    $0x10,%esp
  80da30:	e9 1c fa ff ff       	jmp    80d451 <tcp_input+0x3a5>
        tcp_ack_now(pcb);
  80da35:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80da39:	83 ec 0c             	sub    $0xc,%esp
  80da3c:	53                   	push   %ebx
  80da3d:	e8 83 a6 ff ff       	call   8080c5 <tcp_output>
        tcp_pcb_purge(pcb);
  80da42:	89 1c 24             	mov    %ebx,(%esp)
  80da45:	e8 73 7e ff ff       	call   8058bd <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80da4a:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80da4f:	83 c4 10             	add    $0x10,%esp
  80da52:	39 c3                	cmp    %eax,%ebx
  80da54:	74 2c                	je     80da82 <tcp_input+0x9d6>
  80da56:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80da5b:	ba 00 00 00 00       	mov    $0x0,%edx
  80da60:	89 de                	mov    %ebx,%esi
  80da62:	89 d7                	mov    %edx,%edi
  80da64:	85 c0                	test   %eax,%eax
  80da66:	74 56                	je     80dabe <tcp_input+0xa12>
  80da68:	8b 48 0c             	mov    0xc(%eax),%ecx
  80da6b:	39 ce                	cmp    %ecx,%esi
  80da6d:	0f 94 c3             	sete   %bl
  80da70:	85 c9                	test   %ecx,%ecx
  80da72:	0f 95 c2             	setne  %dl
  80da75:	84 d3                	test   %dl,%bl
  80da77:	75 30                	jne    80daa9 <tcp_input+0x9fd>
  80da79:	bf 01 00 00 00       	mov    $0x1,%edi
  80da7e:	89 c8                	mov    %ecx,%eax
  80da80:	eb e2                	jmp    80da64 <tcp_input+0x9b8>
  80da82:	8b 40 0c             	mov    0xc(%eax),%eax
  80da85:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
        pcb->state = TIME_WAIT;
  80da8a:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80da91:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80da96:	89 43 0c             	mov    %eax,0xc(%ebx)
  80da99:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80da9f:	e8 bc 47 ff ff       	call   802260 <tcp_timer_needed>
  80daa4:	e9 a8 f9 ff ff       	jmp    80d451 <tcp_input+0x3a5>
  80daa9:	89 f3                	mov    %esi,%ebx
  80daab:	89 fa                	mov    %edi,%edx
  80daad:	84 d2                	test   %dl,%dl
  80daaf:	74 05                	je     80dab6 <tcp_input+0xa0a>
  80dab1:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
        TCP_RMV(&tcp_active_pcbs, pcb);
  80dab6:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dab9:	89 50 0c             	mov    %edx,0xc(%eax)
  80dabc:	eb cc                	jmp    80da8a <tcp_input+0x9de>
  80dabe:	89 f3                	mov    %esi,%ebx
  80dac0:	89 fa                	mov    %edi,%edx
  80dac2:	84 d2                	test   %dl,%dl
  80dac4:	74 c4                	je     80da8a <tcp_input+0x9de>
  80dac6:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dacd:	00 00 00 
  80dad0:	eb b8                	jmp    80da8a <tcp_input+0x9de>
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dad2:	a8 10                	test   $0x10,%al
  80dad4:	0f 84 77 f9 ff ff    	je     80d451 <tcp_input+0x3a5>
  80dada:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dadf:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dae2:	0f 85 69 f9 ff ff    	jne    80d451 <tcp_input+0x3a5>
      pcb->state = FIN_WAIT_2;
  80dae8:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80daef:	e9 5d f9 ff ff       	jmp    80d451 <tcp_input+0x3a5>
    tcp_receive(pcb);
  80daf4:	89 d8                	mov    %ebx,%eax
  80daf6:	e8 d6 e8 ff ff       	call   80c3d1 <tcp_receive>
    if (flags & TCP_FIN) {
  80dafb:	f6 05 a0 b1 b3 00 01 	testb  $0x1,0xb3b1a0
  80db02:	0f 84 49 f9 ff ff    	je     80d451 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80db08:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80db0c:	83 ec 0c             	sub    $0xc,%esp
  80db0f:	53                   	push   %ebx
  80db10:	e8 b0 a5 ff ff       	call   8080c5 <tcp_output>
      tcp_pcb_purge(pcb);
  80db15:	89 1c 24             	mov    %ebx,(%esp)
  80db18:	e8 a0 7d ff ff       	call   8058bd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db1d:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80db22:	83 c4 10             	add    $0x10,%esp
  80db25:	39 c3                	cmp    %eax,%ebx
  80db27:	74 2c                	je     80db55 <tcp_input+0xaa9>
  80db29:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80db2e:	b9 00 00 00 00       	mov    $0x0,%ecx
  80db33:	89 de                	mov    %ebx,%esi
  80db35:	89 cf                	mov    %ecx,%edi
  80db37:	85 c0                	test   %eax,%eax
  80db39:	74 56                	je     80db91 <tcp_input+0xae5>
  80db3b:	8b 50 0c             	mov    0xc(%eax),%edx
  80db3e:	85 d2                	test   %edx,%edx
  80db40:	0f 95 c3             	setne  %bl
  80db43:	39 d6                	cmp    %edx,%esi
  80db45:	0f 94 c1             	sete   %cl
  80db48:	84 cb                	test   %cl,%bl
  80db4a:	75 30                	jne    80db7c <tcp_input+0xad0>
  80db4c:	bf 01 00 00 00       	mov    $0x1,%edi
  80db51:	89 d0                	mov    %edx,%eax
  80db53:	eb e2                	jmp    80db37 <tcp_input+0xa8b>
  80db55:	8b 40 0c             	mov    0xc(%eax),%eax
  80db58:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80db5d:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80db64:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80db69:	89 43 0c             	mov    %eax,0xc(%ebx)
  80db6c:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80db72:	e8 e9 46 ff ff       	call   802260 <tcp_timer_needed>
  80db77:	e9 d5 f8 ff ff       	jmp    80d451 <tcp_input+0x3a5>
  80db7c:	89 f3                	mov    %esi,%ebx
  80db7e:	89 f9                	mov    %edi,%ecx
  80db80:	84 c9                	test   %cl,%cl
  80db82:	74 05                	je     80db89 <tcp_input+0xadd>
  80db84:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80db89:	8b 53 0c             	mov    0xc(%ebx),%edx
  80db8c:	89 50 0c             	mov    %edx,0xc(%eax)
  80db8f:	eb cc                	jmp    80db5d <tcp_input+0xab1>
  80db91:	89 f3                	mov    %esi,%ebx
  80db93:	89 f9                	mov    %edi,%ecx
  80db95:	84 c9                	test   %cl,%cl
  80db97:	74 c4                	je     80db5d <tcp_input+0xab1>
  80db99:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dba0:	00 00 00 
  80dba3:	eb b8                	jmp    80db5d <tcp_input+0xab1>
    tcp_receive(pcb);
  80dba5:	89 d8                	mov    %ebx,%eax
  80dba7:	e8 25 e8 ff ff       	call   80c3d1 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dbac:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dbb3:	0f 84 98 f8 ff ff    	je     80d451 <tcp_input+0x3a5>
  80dbb9:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dbbe:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dbc1:	0f 85 8a f8 ff ff    	jne    80d451 <tcp_input+0x3a5>
      tcp_ack_now(pcb);
  80dbc7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80dbcb:	83 ec 0c             	sub    $0xc,%esp
  80dbce:	53                   	push   %ebx
  80dbcf:	e8 f1 a4 ff ff       	call   8080c5 <tcp_output>
      tcp_pcb_purge(pcb);
  80dbd4:	89 1c 24             	mov    %ebx,(%esp)
  80dbd7:	e8 e1 7c ff ff       	call   8058bd <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dbdc:	a1 3c b2 b3 00       	mov    0xb3b23c,%eax
  80dbe1:	83 c4 10             	add    $0x10,%esp
  80dbe4:	39 c3                	cmp    %eax,%ebx
  80dbe6:	74 2c                	je     80dc14 <tcp_input+0xb68>
  80dbe8:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
  80dbed:	ba 00 00 00 00       	mov    $0x0,%edx
  80dbf2:	89 de                	mov    %ebx,%esi
  80dbf4:	89 d7                	mov    %edx,%edi
  80dbf6:	85 c0                	test   %eax,%eax
  80dbf8:	74 56                	je     80dc50 <tcp_input+0xba4>
  80dbfa:	8b 48 0c             	mov    0xc(%eax),%ecx
  80dbfd:	85 c9                	test   %ecx,%ecx
  80dbff:	0f 95 c3             	setne  %bl
  80dc02:	39 ce                	cmp    %ecx,%esi
  80dc04:	0f 94 c2             	sete   %dl
  80dc07:	84 d3                	test   %dl,%bl
  80dc09:	75 30                	jne    80dc3b <tcp_input+0xb8f>
  80dc0b:	bf 01 00 00 00       	mov    $0x1,%edi
  80dc10:	89 c8                	mov    %ecx,%eax
  80dc12:	eb e2                	jmp    80dbf6 <tcp_input+0xb4a>
  80dc14:	8b 40 0c             	mov    0xc(%eax),%eax
  80dc17:	a3 3c b2 b3 00       	mov    %eax,0xb3b23c
      pcb->state = TIME_WAIT;
  80dc1c:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80dc23:	a1 50 b2 b3 00       	mov    0xb3b250,%eax
  80dc28:	89 43 0c             	mov    %eax,0xc(%ebx)
  80dc2b:	89 1d 50 b2 b3 00    	mov    %ebx,0xb3b250
  80dc31:	e8 2a 46 ff ff       	call   802260 <tcp_timer_needed>
  80dc36:	e9 16 f8 ff ff       	jmp    80d451 <tcp_input+0x3a5>
  80dc3b:	89 f3                	mov    %esi,%ebx
  80dc3d:	89 fa                	mov    %edi,%edx
  80dc3f:	84 d2                	test   %dl,%dl
  80dc41:	74 05                	je     80dc48 <tcp_input+0xb9c>
  80dc43:	a3 48 b2 b3 00       	mov    %eax,0xb3b248
      TCP_RMV(&tcp_active_pcbs, pcb);
  80dc48:	8b 53 0c             	mov    0xc(%ebx),%edx
  80dc4b:	89 50 0c             	mov    %edx,0xc(%eax)
  80dc4e:	eb cc                	jmp    80dc1c <tcp_input+0xb70>
  80dc50:	89 f3                	mov    %esi,%ebx
  80dc52:	89 fa                	mov    %edi,%edx
  80dc54:	84 d2                	test   %dl,%dl
  80dc56:	74 c4                	je     80dc1c <tcp_input+0xb70>
  80dc58:	c7 05 48 b2 b3 00 00 	movl   $0x0,0xb3b248
  80dc5f:	00 00 00 
  80dc62:	eb b8                	jmp    80dc1c <tcp_input+0xb70>
    tcp_receive(pcb);
  80dc64:	89 d8                	mov    %ebx,%eax
  80dc66:	e8 66 e7 ff ff       	call   80c3d1 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80dc6b:	f6 05 a0 b1 b3 00 10 	testb  $0x10,0xb3b1a0
  80dc72:	0f 84 d9 f7 ff ff    	je     80d451 <tcp_input+0x3a5>
  80dc78:	a1 a4 b1 b3 00       	mov    0xb3b1a4,%eax
  80dc7d:	39 43 54             	cmp    %eax,0x54(%ebx)
  80dc80:	0f 85 cb f7 ff ff    	jne    80d451 <tcp_input+0x3a5>
      recv_flags = TF_CLOSED;
  80dc86:	c6 05 9c b1 b3 00 10 	movb   $0x10,0xb3b19c
  80dc8d:	e9 bf f7 ff ff       	jmp    80d451 <tcp_input+0x3a5>
    tcp_input_pcb = NULL;
  80dc92:	c7 05 58 b2 b3 00 00 	movl   $0x0,0xb3b258
  80dc99:	00 00 00 
  80dc9c:	e9 ba f7 ff ff       	jmp    80d45b <tcp_input+0x3af>
      } else if (recv_flags & TF_CLOSED) {
  80dca1:	a8 10                	test   $0x10,%al
  80dca3:	0f 85 96 00 00 00    	jne    80dd3f <tcp_input+0xc93>
        if (pcb->acked > 0) {
  80dca9:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        err = ERR_OK;
  80dcad:	b8 00 00 00 00       	mov    $0x0,%eax
        if (pcb->acked > 0) {
  80dcb2:	66 85 d2             	test   %dx,%dx
  80dcb5:	74 1a                	je     80dcd1 <tcp_input+0xc25>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80dcb7:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80dcbd:	85 c9                	test   %ecx,%ecx
  80dcbf:	74 10                	je     80dcd1 <tcp_input+0xc25>
  80dcc1:	83 ec 04             	sub    $0x4,%esp
  80dcc4:	0f b7 d2             	movzwl %dx,%edx
  80dcc7:	52                   	push   %edx
  80dcc8:	53                   	push   %ebx
  80dcc9:	ff 73 18             	pushl  0x18(%ebx)
  80dccc:	ff d1                	call   *%ecx
  80dcce:	83 c4 10             	add    $0x10,%esp
        if (recv_data != NULL) {
  80dcd1:	8b 15 98 b1 b3 00    	mov    0xb3b198,%edx
  80dcd7:	85 d2                	test   %edx,%edx
  80dcd9:	0f 84 a9 00 00 00    	je     80dd88 <tcp_input+0xcdc>
          if(flags & TCP_PSH) {
  80dcdf:	f6 05 a0 b1 b3 00 08 	testb  $0x8,0xb3b1a0
  80dce6:	74 04                	je     80dcec <tcp_input+0xc40>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80dce8:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dcec:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dcf2:	85 c0                	test   %eax,%eax
  80dcf4:	74 6a                	je     80dd60 <tcp_input+0xcb4>
  80dcf6:	6a 00                	push   $0x0
  80dcf8:	52                   	push   %edx
  80dcf9:	53                   	push   %ebx
  80dcfa:	ff 73 18             	pushl  0x18(%ebx)
  80dcfd:	ff d0                	call   *%eax
          if (err != ERR_OK) {
  80dcff:	83 c4 10             	add    $0x10,%esp
  80dd02:	84 c0                	test   %al,%al
  80dd04:	75 68                	jne    80dd6e <tcp_input+0xcc2>
        if (recv_flags & TF_GOT_FIN) {
  80dd06:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd0d:	74 1f                	je     80dd2e <tcp_input+0xc82>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80dd0f:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dd15:	85 c0                	test   %eax,%eax
  80dd17:	74 15                	je     80dd2e <tcp_input+0xc82>
  80dd19:	6a 00                	push   $0x0
  80dd1b:	6a 00                	push   $0x0
  80dd1d:	53                   	push   %ebx
  80dd1e:	ff 73 18             	pushl  0x18(%ebx)
  80dd21:	ff d0                	call   *%eax
  80dd23:	83 c4 10             	add    $0x10,%esp
        if (err == ERR_OK) {
  80dd26:	84 c0                	test   %al,%al
  80dd28:	0f 85 6f f7 ff ff    	jne    80d49d <tcp_input+0x3f1>
          tcp_output(pcb);
  80dd2e:	83 ec 0c             	sub    $0xc,%esp
  80dd31:	53                   	push   %ebx
  80dd32:	e8 8e a3 ff ff       	call   8080c5 <tcp_output>
  80dd37:	83 c4 10             	add    $0x10,%esp
  80dd3a:	e9 5e f7 ff ff       	jmp    80d49d <tcp_input+0x3f1>
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80dd3f:	83 ec 08             	sub    $0x8,%esp
  80dd42:	53                   	push   %ebx
  80dd43:	68 3c b2 b3 00       	push   $0xb3b23c
  80dd48:	e8 ed 7b ff ff       	call   80593a <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80dd4d:	83 c4 08             	add    $0x8,%esp
  80dd50:	53                   	push   %ebx
  80dd51:	6a 02                	push   $0x2
  80dd53:	e8 e5 67 ff ff       	call   80453d <memp_free>
  80dd58:	83 c4 10             	add    $0x10,%esp
  80dd5b:	e9 3d f7 ff ff       	jmp    80d49d <tcp_input+0x3f1>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80dd60:	83 ec 0c             	sub    $0xc,%esp
  80dd63:	52                   	push   %edx
  80dd64:	e8 21 6b ff ff       	call   80488a <pbuf_free>
  80dd69:	83 c4 10             	add    $0x10,%esp
  80dd6c:	eb 98                	jmp    80dd06 <tcp_input+0xc5a>
            pcb->refused_data = recv_data;
  80dd6e:	a1 98 b1 b3 00       	mov    0xb3b198,%eax
  80dd73:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
        if (recv_flags & TF_GOT_FIN) {
  80dd79:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd80:	0f 84 17 f7 ff ff    	je     80d49d <tcp_input+0x3f1>
  80dd86:	eb 87                	jmp    80dd0f <tcp_input+0xc63>
  80dd88:	f6 05 9c b1 b3 00 20 	testb  $0x20,0xb3b19c
  80dd8f:	74 95                	je     80dd26 <tcp_input+0xc7a>
  80dd91:	e9 79 ff ff ff       	jmp    80dd0f <tcp_input+0xc63>
        tcphdr->dest, tcphdr->src);
  80dd96:	8b 15 b0 b1 b3 00    	mov    0xb3b1b0,%edx
        &(iphdr->dest), &(iphdr->src),
  80dd9c:	a1 ac b1 b3 00       	mov    0xb3b1ac,%eax
      tcp_rst(ackno, seqno + tcplen,
  80dda1:	83 ec 08             	sub    $0x8,%esp
  80dda4:	0f b7 0a             	movzwl (%edx),%ecx
  80dda7:	51                   	push   %ecx
  80dda8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80ddac:	52                   	push   %edx
  80ddad:	8d 50 0c             	lea    0xc(%eax),%edx
  80ddb0:	52                   	push   %edx
  80ddb1:	83 c0 10             	add    $0x10,%eax
  80ddb4:	50                   	push   %eax
  80ddb5:	0f b7 05 9e b1 b3 00 	movzwl 0xb3b19e,%eax
  80ddbc:	03 05 a8 b1 b3 00    	add    0xb3b1a8,%eax
  80ddc2:	50                   	push   %eax
  80ddc3:	ff 35 a4 b1 b3 00    	pushl  0xb3b1a4
  80ddc9:	e8 97 a7 ff ff       	call   808565 <tcp_rst>
  80ddce:	83 c4 20             	add    $0x20,%esp
  80ddd1:	eb 14                	jmp    80dde7 <tcp_input+0xd3b>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80ddd3:	83 ec 0c             	sub    $0xc,%esp
  80ddd6:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80ddda:	50                   	push   %eax
  80dddb:	e8 91 99 ff ff       	call   807771 <ntohs>
  80dde0:	83 c4 10             	add    $0x10,%esp
  80dde3:	a8 04                	test   $0x4,%al
  80dde5:	74 af                	je     80dd96 <tcp_input+0xcea>
    pbuf_free(p);
  80dde7:	83 ec 0c             	sub    $0xc,%esp
  80ddea:	56                   	push   %esi
  80ddeb:	e8 9a 6a ff ff       	call   80488a <pbuf_free>
  80ddf0:	83 c4 10             	add    $0x10,%esp
  80ddf3:	e9 1f f3 ff ff       	jmp    80d117 <tcp_input+0x6b>
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80ddf8:	8b 1d 50 b2 b3 00    	mov    0xb3b250,%ebx
  80ddfe:	e9 ee f6 ff ff       	jmp    80d4f1 <tcp_input+0x445>

0080de03 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80de03:	55                   	push   %ebp
  80de04:	89 e5                	mov    %esp,%ebp
  80de06:	57                   	push   %edi
  80de07:	56                   	push   %esi
  80de08:	53                   	push   %ebx
  80de09:	83 ec 28             	sub    $0x28,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80de0c:	8b 45 08             	mov    0x8(%ebp),%eax
  80de0f:	8b 78 04             	mov    0x4(%eax),%edi
  proto = IPH_PROTO(iphdr);
  80de12:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80de16:	50                   	push   %eax
  80de17:	e8 55 99 ff ff       	call   807771 <ntohs>
  80de1c:	89 c2                	mov    %eax,%edx

  prev = NULL;
  pcb = raw_pcbs;
  80de1e:	8b 1d c8 b1 b3 00    	mov    0xb3b1c8,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80de24:	83 c4 10             	add    $0x10,%esp
  u8_t eaten = 0;
  80de27:	b8 00 00 00 00       	mov    $0x0,%eax
  prev = NULL;
  80de2c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    if (pcb->protocol == proto) {
  80de33:	0f b6 f2             	movzbl %dl,%esi
  while ((eaten == 0) && (pcb != NULL)) {
  80de36:	eb 11                	jmp    80de49 <raw_input+0x46>
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80de38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80de3b:	89 45 08             	mov    %eax,0x8(%ebp)
          eaten = 1;
  80de3e:	b8 01 00 00 00       	mov    $0x1,%eax
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80de43:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    pcb = pcb->next;
  80de46:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  while ((eaten == 0) && (pcb != NULL)) {
  80de49:	84 c0                	test   %al,%al
  80de4b:	75 55                	jne    80dea2 <raw_input+0x9f>
  80de4d:	85 db                	test   %ebx,%ebx
  80de4f:	74 51                	je     80dea2 <raw_input+0x9f>
    if (pcb->protocol == proto) {
  80de51:	0f b6 53 10          	movzbl 0x10(%ebx),%edx
  80de55:	b8 00 00 00 00       	mov    $0x0,%eax
  80de5a:	39 f2                	cmp    %esi,%edx
  80de5c:	75 e5                	jne    80de43 <raw_input+0x40>
      if (pcb->recv != NULL) {
  80de5e:	8b 53 14             	mov    0x14(%ebx),%edx
  80de61:	85 d2                	test   %edx,%edx
  80de63:	74 de                	je     80de43 <raw_input+0x40>
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80de65:	8d 47 0c             	lea    0xc(%edi),%eax
  80de68:	50                   	push   %eax
  80de69:	ff 75 08             	pushl  0x8(%ebp)
  80de6c:	53                   	push   %ebx
  80de6d:	ff 73 18             	pushl  0x18(%ebx)
  80de70:	ff d2                	call   *%edx
  80de72:	83 c4 10             	add    $0x10,%esp
  80de75:	84 c0                	test   %al,%al
  80de77:	74 ca                	je     80de43 <raw_input+0x40>
          if (prev != NULL) {
  80de79:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80de7c:	85 c9                	test   %ecx,%ecx
  80de7e:	74 b8                	je     80de38 <raw_input+0x35>
            prev->next = pcb->next;
  80de80:	8b 43 0c             	mov    0xc(%ebx),%eax
  80de83:	89 41 0c             	mov    %eax,0xc(%ecx)
            pcb->next = raw_pcbs;
  80de86:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80de8b:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80de8e:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
          eaten = 1;
  80de94:	b8 01 00 00 00       	mov    $0x1,%eax
          p = NULL;
  80de99:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80dea0:	eb a1                	jmp    80de43 <raw_input+0x40>
  }
  return eaten;
}
  80dea2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dea5:	5b                   	pop    %ebx
  80dea6:	5e                   	pop    %esi
  80dea7:	5f                   	pop    %edi
  80dea8:	5d                   	pop    %ebp
  80dea9:	c3                   	ret    

0080deaa <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80deaa:	55                   	push   %ebp
  80deab:	89 e5                	mov    %esp,%ebp
  80dead:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  80deb0:	b8 00 00 00 00       	mov    $0x0,%eax
  80deb5:	85 d2                	test   %edx,%edx
  80deb7:	74 02                	je     80debb <raw_bind+0x11>
  80deb9:	8b 02                	mov    (%edx),%eax
  80debb:	8b 55 08             	mov    0x8(%ebp),%edx
  80debe:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  80dec0:	b8 00 00 00 00       	mov    $0x0,%eax
  80dec5:	5d                   	pop    %ebp
  80dec6:	c3                   	ret    

0080dec7 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80dec7:	55                   	push   %ebp
  80dec8:	89 e5                	mov    %esp,%ebp
  80deca:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80decd:	b8 00 00 00 00       	mov    $0x0,%eax
  80ded2:	85 d2                	test   %edx,%edx
  80ded4:	74 02                	je     80ded8 <raw_connect+0x11>
  80ded6:	8b 02                	mov    (%edx),%eax
  80ded8:	8b 55 08             	mov    0x8(%ebp),%edx
  80dedb:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  80dede:	b8 00 00 00 00       	mov    $0x0,%eax
  80dee3:	5d                   	pop    %ebp
  80dee4:	c3                   	ret    

0080dee5 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80dee5:	55                   	push   %ebp
  80dee6:	89 e5                	mov    %esp,%ebp
  80dee8:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80deeb:	8b 55 0c             	mov    0xc(%ebp),%edx
  80deee:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80def1:	8b 55 10             	mov    0x10(%ebp),%edx
  80def4:	89 50 18             	mov    %edx,0x18(%eax)
}
  80def7:	5d                   	pop    %ebp
  80def8:	c3                   	ret    

0080def9 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80def9:	55                   	push   %ebp
  80defa:	89 e5                	mov    %esp,%ebp
  80defc:	57                   	push   %edi
  80defd:	56                   	push   %esi
  80defe:	53                   	push   %ebx
  80deff:	83 ec 14             	sub    $0x14,%esp
  80df02:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80df05:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80df08:	6a 14                	push   $0x14
  80df0a:	57                   	push   %edi
  80df0b:	e8 ad 68 ff ff       	call   8047bd <pbuf_header>
  80df10:	83 c4 10             	add    $0x10,%esp
  80df13:	84 c0                	test   %al,%al
  80df15:	74 52                	je     80df69 <raw_sendto+0x70>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80df17:	83 ec 04             	sub    $0x4,%esp
  80df1a:	6a 00                	push   $0x0
  80df1c:	6a 00                	push   $0x0
  80df1e:	6a 01                	push   $0x1
  80df20:	e8 2b 6a ff ff       	call   804950 <pbuf_alloc>
  80df25:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80df27:	83 c4 10             	add    $0x10,%esp
  80df2a:	85 c0                	test   %eax,%eax
  80df2c:	0f 84 be 00 00 00    	je     80dff0 <raw_sendto+0xf7>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80df32:	83 ec 08             	sub    $0x8,%esp
  80df35:	57                   	push   %edi
  80df36:	50                   	push   %eax
  80df37:	e8 2f 6e ff ff       	call   804d6b <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80df3c:	83 c4 04             	add    $0x4,%esp
  80df3f:	ff 75 10             	pushl  0x10(%ebp)
  80df42:	e8 fd 85 ff ff       	call   806544 <ip_route>
  80df47:	83 c4 10             	add    $0x10,%esp
  80df4a:	85 c0                	test   %eax,%eax
  80df4c:	75 41                	jne    80df8f <raw_sendto+0x96>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80df4e:	39 f7                	cmp    %esi,%edi
  80df50:	0f 84 a1 00 00 00    	je     80dff7 <raw_sendto+0xfe>
      pbuf_free(q);
  80df56:	83 ec 0c             	sub    $0xc,%esp
  80df59:	56                   	push   %esi
  80df5a:	e8 2b 69 ff ff       	call   80488a <pbuf_free>
  80df5f:	83 c4 10             	add    $0x10,%esp
    }
    return ERR_RTE;
  80df62:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80df67:	eb 66                	jmp    80dfcf <raw_sendto+0xd6>
    if(pbuf_header(q, -IP_HLEN)) {
  80df69:	83 ec 08             	sub    $0x8,%esp
  80df6c:	6a ec                	push   $0xffffffec
  80df6e:	57                   	push   %edi
  80df6f:	e8 49 68 ff ff       	call   8047bd <pbuf_header>
  80df74:	83 c4 10             	add    $0x10,%esp
  80df77:	84 c0                	test   %al,%al
  80df79:	75 5e                	jne    80dfd9 <raw_sendto+0xe0>
  if ((netif = ip_route(ipaddr)) == NULL) {
  80df7b:	83 ec 0c             	sub    $0xc,%esp
  80df7e:	ff 75 10             	pushl  0x10(%ebp)
  80df81:	e8 be 85 ff ff       	call   806544 <ip_route>
  80df86:	83 c4 10             	add    $0x10,%esp
  80df89:	85 c0                	test   %eax,%eax
  80df8b:	74 71                	je     80dffe <raw_sendto+0x105>
    q = p;
  80df8d:	89 fe                	mov    %edi,%esi
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80df8f:	89 da                	mov    %ebx,%edx
  80df91:	85 db                	test   %ebx,%ebx
  80df93:	74 05                	je     80df9a <raw_sendto+0xa1>
  80df95:	83 3b 00             	cmpl   $0x0,(%ebx)
  80df98:	75 03                	jne    80df9d <raw_sendto+0xa4>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80df9a:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80df9d:	83 ec 04             	sub    $0x4,%esp
  80dfa0:	50                   	push   %eax
  80dfa1:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80dfa5:	50                   	push   %eax
  80dfa6:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80dfaa:	50                   	push   %eax
  80dfab:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80dfaf:	50                   	push   %eax
  80dfb0:	ff 75 10             	pushl  0x10(%ebp)
  80dfb3:	52                   	push   %edx
  80dfb4:	56                   	push   %esi
  80dfb5:	e8 0d 89 ff ff       	call   8068c7 <ip_output_if>
  80dfba:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80dfbc:	83 c4 20             	add    $0x20,%esp
  80dfbf:	39 f7                	cmp    %esi,%edi
  80dfc1:	74 0c                	je     80dfcf <raw_sendto+0xd6>
    /* free the header */
    pbuf_free(q);
  80dfc3:	83 ec 0c             	sub    $0xc,%esp
  80dfc6:	56                   	push   %esi
  80dfc7:	e8 be 68 ff ff       	call   80488a <pbuf_free>
  80dfcc:	83 c4 10             	add    $0x10,%esp
  }
  return err;
}
  80dfcf:	89 d8                	mov    %ebx,%eax
  80dfd1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80dfd4:	5b                   	pop    %ebx
  80dfd5:	5e                   	pop    %esi
  80dfd6:	5f                   	pop    %edi
  80dfd7:	5d                   	pop    %ebp
  80dfd8:	c3                   	ret    
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80dfd9:	83 ec 04             	sub    $0x4,%esp
  80dfdc:	68 40 37 81 00       	push   $0x813740
  80dfe1:	68 e3 00 00 00       	push   $0xe3
  80dfe6:	68 66 37 81 00       	push   $0x813766
  80dfeb:	e8 a9 06 00 00       	call   80e699 <_panic>
      return ERR_MEM;
  80dff0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80dff5:	eb d8                	jmp    80dfcf <raw_sendto+0xd6>
    return ERR_RTE;
  80dff7:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80dffc:	eb d1                	jmp    80dfcf <raw_sendto+0xd6>
  80dffe:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
  80e003:	eb ca                	jmp    80dfcf <raw_sendto+0xd6>

0080e005 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80e005:	55                   	push   %ebp
  80e006:	89 e5                	mov    %esp,%ebp
  80e008:	83 ec 0c             	sub    $0xc,%esp
  80e00b:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80e00e:	8d 50 04             	lea    0x4(%eax),%edx
  80e011:	52                   	push   %edx
  80e012:	ff 75 0c             	pushl  0xc(%ebp)
  80e015:	50                   	push   %eax
  80e016:	e8 de fe ff ff       	call   80def9 <raw_sendto>
}
  80e01b:	c9                   	leave  
  80e01c:	c3                   	ret    

0080e01d <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80e01d:	55                   	push   %ebp
  80e01e:	89 e5                	mov    %esp,%ebp
  80e020:	83 ec 08             	sub    $0x8,%esp
  80e023:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80e026:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e02b:	39 c8                	cmp    %ecx,%eax
  80e02d:	75 1b                	jne    80e04a <raw_remove+0x2d>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80e02f:	8b 41 0c             	mov    0xc(%ecx),%eax
  80e032:	a3 c8 b1 b3 00       	mov    %eax,0xb3b1c8
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80e037:	83 ec 08             	sub    $0x8,%esp
  80e03a:	51                   	push   %ecx
  80e03b:	6a 00                	push   $0x0
  80e03d:	e8 fb 64 ff ff       	call   80453d <memp_free>
}
  80e042:	83 c4 10             	add    $0x10,%esp
  80e045:	c9                   	leave  
  80e046:	c3                   	ret    
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80e047:	8b 40 0c             	mov    0xc(%eax),%eax
  80e04a:	85 c0                	test   %eax,%eax
  80e04c:	74 e9                	je     80e037 <raw_remove+0x1a>
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80e04e:	8b 50 0c             	mov    0xc(%eax),%edx
  80e051:	39 ca                	cmp    %ecx,%edx
  80e053:	75 f2                	jne    80e047 <raw_remove+0x2a>
  80e055:	85 d2                	test   %edx,%edx
  80e057:	74 ee                	je     80e047 <raw_remove+0x2a>
        pcb2->next = pcb->next;
  80e059:	8b 51 0c             	mov    0xc(%ecx),%edx
  80e05c:	89 50 0c             	mov    %edx,0xc(%eax)
  80e05f:	eb e6                	jmp    80e047 <raw_remove+0x2a>

0080e061 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80e061:	55                   	push   %ebp
  80e062:	89 e5                	mov    %esp,%ebp
  80e064:	56                   	push   %esi
  80e065:	53                   	push   %ebx
  80e066:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80e069:	83 ec 0c             	sub    $0xc,%esp
  80e06c:	6a 00                	push   $0x0
  80e06e:	e8 74 64 ff ff       	call   8044e7 <memp_malloc>
  80e073:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80e075:	83 c4 10             	add    $0x10,%esp
  80e078:	85 c0                	test   %eax,%eax
  80e07a:	74 27                	je     80e0a3 <raw_new+0x42>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80e07c:	83 ec 04             	sub    $0x4,%esp
  80e07f:	6a 1c                	push   $0x1c
  80e081:	6a 00                	push   $0x0
  80e083:	50                   	push   %eax
  80e084:	e8 ab 0f 00 00       	call   80f034 <memset>
    pcb->protocol = proto;
  80e089:	89 f0                	mov    %esi,%eax
  80e08b:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80e08e:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80e092:	a1 c8 b1 b3 00       	mov    0xb3b1c8,%eax
  80e097:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80e09a:	89 1d c8 b1 b3 00    	mov    %ebx,0xb3b1c8
  80e0a0:	83 c4 10             	add    $0x10,%esp
  }
  return pcb;
}
  80e0a3:	89 d8                	mov    %ebx,%eax
  80e0a5:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80e0a8:	5b                   	pop    %ebx
  80e0a9:	5e                   	pop    %esi
  80e0aa:	5d                   	pop    %ebp
  80e0ab:	c3                   	ret    

0080e0ac <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80e0ac:	55                   	push   %ebp
  80e0ad:	89 e5                	mov    %esp,%ebp
  80e0af:	57                   	push   %edi
  80e0b0:	56                   	push   %esi
  80e0b1:	53                   	push   %ebx
  80e0b2:	83 ec 28             	sub    $0x28,%esp
  80e0b5:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80e0b8:	8b 7b 04             	mov    0x4(%ebx),%edi
  hlen = IPH_HL(iphdr) * 4;
  80e0bb:	0f b7 07             	movzwl (%edi),%eax
  80e0be:	50                   	push   %eax
  80e0bf:	e8 ad 96 ff ff       	call   807771 <ntohs>
  80e0c4:	66 c1 e8 06          	shr    $0x6,%ax
  80e0c8:	83 e0 3c             	and    $0x3c,%eax
  80e0cb:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80e0cf:	89 c6                	mov    %eax,%esi
  80e0d1:	f7 de                	neg    %esi
  80e0d3:	0f bf f6             	movswl %si,%esi
  80e0d6:	83 c4 08             	add    $0x8,%esp
  80e0d9:	56                   	push   %esi
  80e0da:	53                   	push   %ebx
  80e0db:	e8 dd 66 ff ff       	call   8047bd <pbuf_header>
  80e0e0:	83 c4 10             	add    $0x10,%esp
  80e0e3:	84 c0                	test   %al,%al
  80e0e5:	75 67                	jne    80e14e <icmp_input+0xa2>
  80e0e7:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80e0ec:	76 60                	jbe    80e14e <icmp_input+0xa2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80e0ee:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80e0f1:	80 38 08             	cmpb   $0x8,(%eax)
  80e0f4:	74 0e                	je     80e104 <icmp_input+0x58>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80e0f6:	83 ec 0c             	sub    $0xc,%esp
  80e0f9:	53                   	push   %ebx
  80e0fa:	e8 8b 67 ff ff       	call   80488a <pbuf_free>
  return;
  80e0ff:	83 c4 10             	add    $0x10,%esp
  80e102:	eb 56                	jmp    80e15a <icmp_input+0xae>
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80e104:	83 ec 08             	sub    $0x8,%esp
  80e107:	ff 75 0c             	pushl  0xc(%ebp)
  80e10a:	8d 47 10             	lea    0x10(%edi),%eax
  80e10d:	50                   	push   %eax
  80e10e:	e8 ee 83 ff ff       	call   806501 <ip_addr_isbroadcast>
  80e113:	83 c4 10             	add    $0x10,%esp
  80e116:	84 c0                	test   %al,%al
  80e118:	75 48                	jne    80e162 <icmp_input+0xb6>
  80e11a:	8b 47 10             	mov    0x10(%edi),%eax
  80e11d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e120:	83 ec 0c             	sub    $0xc,%esp
  80e123:	68 00 00 00 f0       	push   $0xf0000000
  80e128:	e8 68 98 ff ff       	call   807995 <ntohl>
  80e12d:	23 45 e0             	and    -0x20(%ebp),%eax
  80e130:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e133:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e13a:	e8 56 98 ff ff       	call   807995 <ntohl>
  80e13f:	83 c4 10             	add    $0x10,%esp
  80e142:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80e145:	74 1b                	je     80e162 <icmp_input+0xb6>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80e147:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80e14c:	77 22                	ja     80e170 <icmp_input+0xc4>
lenerr:
  pbuf_free(p);
  80e14e:	83 ec 0c             	sub    $0xc,%esp
  80e151:	53                   	push   %ebx
  80e152:	e8 33 67 ff ff       	call   80488a <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80e157:	83 c4 10             	add    $0x10,%esp
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80e15a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e15d:	5b                   	pop    %ebx
  80e15e:	5e                   	pop    %esi
  80e15f:	5f                   	pop    %edi
  80e160:	5d                   	pop    %ebp
  80e161:	c3                   	ret    
      pbuf_free(p);
  80e162:	83 ec 0c             	sub    $0xc,%esp
  80e165:	53                   	push   %ebx
  80e166:	e8 1f 67 ff ff       	call   80488a <pbuf_free>
      return;
  80e16b:	83 c4 10             	add    $0x10,%esp
  80e16e:	eb ea                	jmp    80e15a <icmp_input+0xae>
    if (inet_chksum_pbuf(p) != 0) {
  80e170:	83 ec 0c             	sub    $0xc,%esp
  80e173:	53                   	push   %ebx
  80e174:	e8 d3 94 ff ff       	call   80764c <inet_chksum_pbuf>
  80e179:	83 c4 10             	add    $0x10,%esp
  80e17c:	66 85 c0             	test   %ax,%ax
  80e17f:	0f 85 96 00 00 00    	jne    80e21b <icmp_input+0x16f>
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e185:	83 ec 08             	sub    $0x8,%esp
  80e188:	6a 22                	push   $0x22
  80e18a:	53                   	push   %ebx
  80e18b:	e8 2d 66 ff ff       	call   8047bd <pbuf_header>
  80e190:	83 c4 10             	add    $0x10,%esp
  80e193:	84 c0                	test   %al,%al
  80e195:	0f 84 fb 00 00 00    	je     80e296 <icmp_input+0x1ea>
      if (pbuf_header(p, hlen)) {
  80e19b:	83 ec 08             	sub    $0x8,%esp
  80e19e:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e1a2:	50                   	push   %eax
  80e1a3:	53                   	push   %ebx
  80e1a4:	e8 14 66 ff ff       	call   8047bd <pbuf_header>
  80e1a9:	83 c4 10             	add    $0x10,%esp
  80e1ac:	84 c0                	test   %al,%al
  80e1ae:	75 7c                	jne    80e22c <icmp_input+0x180>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80e1b0:	83 ec 04             	sub    $0x4,%esp
  80e1b3:	6a 00                	push   $0x0
  80e1b5:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80e1b9:	50                   	push   %eax
  80e1ba:	6a 02                	push   $0x2
  80e1bc:	e8 8f 67 ff ff       	call   804950 <pbuf_alloc>
  80e1c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80e1c4:	83 c4 10             	add    $0x10,%esp
  80e1c7:	85 c0                	test   %eax,%eax
  80e1c9:	74 75                	je     80e240 <icmp_input+0x194>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e1cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e1ce:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80e1d2:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e1d6:	83 c0 08             	add    $0x8,%eax
  80e1d9:	39 c2                	cmp    %eax,%edx
  80e1db:	72 74                	jb     80e251 <icmp_input+0x1a5>
      if (pbuf_copy(r, p) != ERR_OK) {
  80e1dd:	83 ec 08             	sub    $0x8,%esp
  80e1e0:	53                   	push   %ebx
  80e1e1:	ff 75 e0             	pushl  -0x20(%ebp)
  80e1e4:	e8 49 6c ff ff       	call   804e32 <pbuf_copy>
  80e1e9:	83 c4 10             	add    $0x10,%esp
  80e1ec:	84 c0                	test   %al,%al
  80e1ee:	75 78                	jne    80e268 <icmp_input+0x1bc>
      iphdr = r->payload;
  80e1f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e1f3:	8b 78 04             	mov    0x4(%eax),%edi
      if (pbuf_header(r, -hlen)) {
  80e1f6:	83 ec 08             	sub    $0x8,%esp
  80e1f9:	56                   	push   %esi
  80e1fa:	50                   	push   %eax
  80e1fb:	e8 bd 65 ff ff       	call   8047bd <pbuf_header>
  80e200:	83 c4 10             	add    $0x10,%esp
  80e203:	84 c0                	test   %al,%al
  80e205:	75 78                	jne    80e27f <icmp_input+0x1d3>
      pbuf_free(p);
  80e207:	83 ec 0c             	sub    $0xc,%esp
  80e20a:	53                   	push   %ebx
  80e20b:	e8 7a 66 ff ff       	call   80488a <pbuf_free>
  80e210:	83 c4 10             	add    $0x10,%esp
      p = r;
  80e213:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80e216:	e9 91 00 00 00       	jmp    80e2ac <icmp_input+0x200>
      pbuf_free(p);
  80e21b:	83 ec 0c             	sub    $0xc,%esp
  80e21e:	53                   	push   %ebx
  80e21f:	e8 66 66 ff ff       	call   80488a <pbuf_free>
      return;
  80e224:	83 c4 10             	add    $0x10,%esp
  80e227:	e9 2e ff ff ff       	jmp    80e15a <icmp_input+0xae>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80e22c:	83 ec 04             	sub    $0x4,%esp
  80e22f:	68 7c 37 81 00       	push   $0x81377c
  80e234:	6a 7b                	push   $0x7b
  80e236:	68 70 38 81 00       	push   $0x813870
  80e23b:	e8 59 04 00 00       	call   80e699 <_panic>
  pbuf_free(p);
  80e240:	83 ec 0c             	sub    $0xc,%esp
  80e243:	53                   	push   %ebx
  80e244:	e8 41 66 ff ff       	call   80488a <pbuf_free>
  return;
  80e249:	83 c4 10             	add    $0x10,%esp
  80e24c:	e9 09 ff ff ff       	jmp    80e15a <icmp_input+0xae>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80e251:	83 ec 04             	sub    $0x4,%esp
  80e254:	68 b0 37 81 00       	push   $0x8137b0
  80e259:	68 85 00 00 00       	push   $0x85
  80e25e:	68 70 38 81 00       	push   $0x813870
  80e263:	e8 31 04 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80e268:	83 ec 04             	sub    $0x4,%esp
  80e26b:	68 e8 37 81 00       	push   $0x8137e8
  80e270:	68 88 00 00 00       	push   $0x88
  80e275:	68 70 38 81 00       	push   $0x813870
  80e27a:	e8 1a 04 00 00       	call   80e699 <_panic>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e27f:	83 ec 04             	sub    $0x4,%esp
  80e282:	68 10 38 81 00       	push   $0x813810
  80e287:	68 8e 00 00 00       	push   $0x8e
  80e28c:	68 70 38 81 00       	push   $0x813870
  80e291:	e8 03 04 00 00       	call   80e699 <_panic>
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80e296:	83 ec 08             	sub    $0x8,%esp
  80e299:	6a de                	push   $0xffffffde
  80e29b:	53                   	push   %ebx
  80e29c:	e8 1c 65 ff ff       	call   8047bd <pbuf_header>
  80e2a1:	83 c4 10             	add    $0x10,%esp
  80e2a4:	84 c0                	test   %al,%al
  80e2a6:	0f 85 d3 00 00 00    	jne    80e37f <icmp_input+0x2d3>
    iecho = p->payload;
  80e2ac:	8b 73 04             	mov    0x4(%ebx),%esi
    tmpaddr.addr = iphdr->src.addr;
  80e2af:	8b 47 0c             	mov    0xc(%edi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80e2b2:	8b 57 10             	mov    0x10(%edi),%edx
  80e2b5:	89 57 0c             	mov    %edx,0xc(%edi)
    iphdr->dest.addr = tmpaddr.addr;
  80e2b8:	89 47 10             	mov    %eax,0x10(%edi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80e2bb:	83 ec 0c             	sub    $0xc,%esp
  80e2be:	0f b7 06             	movzwl (%esi),%eax
  80e2c1:	50                   	push   %eax
  80e2c2:	e8 aa 94 ff ff       	call   807771 <ntohs>
  80e2c7:	0f b6 c0             	movzbl %al,%eax
  80e2ca:	89 04 24             	mov    %eax,(%esp)
  80e2cd:	e8 92 94 ff ff       	call   807764 <htons>
  80e2d2:	66 89 06             	mov    %ax,(%esi)
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80e2d5:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80e2d9:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80e2dd:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80e2e4:	e8 7b 94 ff ff       	call   807764 <htons>
  80e2e9:	83 c4 10             	add    $0x10,%esp
  80e2ec:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80e2f0:	0f 82 a0 00 00 00    	jb     80e396 <icmp_input+0x2ea>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80e2f6:	83 ec 0c             	sub    $0xc,%esp
  80e2f9:	68 00 08 00 00       	push   $0x800
  80e2fe:	e8 61 94 ff ff       	call   807764 <htons>
  80e303:	0f b7 56 02          	movzwl 0x2(%esi),%edx
  80e307:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  80e30b:	66 89 46 02          	mov    %ax,0x2(%esi)
  80e30f:	83 c4 10             	add    $0x10,%esp
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80e312:	83 ec 0c             	sub    $0xc,%esp
  80e315:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80e319:	50                   	push   %eax
  80e31a:	e8 52 94 ff ff       	call   807771 <ntohs>
  80e31f:	66 0d 00 ff          	or     $0xff00,%ax
  80e323:	0f b7 c0             	movzwl %ax,%eax
  80e326:	89 04 24             	mov    %eax,(%esp)
  80e329:	e8 36 94 ff ff       	call   807764 <htons>
  80e32e:	66 89 47 08          	mov    %ax,0x8(%edi)
    IPH_CHKSUM_SET(iphdr, 0);
  80e332:	66 c7 47 0a 00 00    	movw   $0x0,0xa(%edi)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80e338:	83 c4 08             	add    $0x8,%esp
  80e33b:	6a 14                	push   $0x14
  80e33d:	57                   	push   %edi
  80e33e:	e8 f3 92 ff ff       	call   807636 <inet_chksum>
  80e343:	66 89 47 0a          	mov    %ax,0xa(%edi)
    if(pbuf_header(p, hlen)) {
  80e347:	83 c4 08             	add    $0x8,%esp
  80e34a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80e34e:	50                   	push   %eax
  80e34f:	53                   	push   %ebx
  80e350:	e8 68 64 ff ff       	call   8047bd <pbuf_header>
  80e355:	83 c4 10             	add    $0x10,%esp
  80e358:	84 c0                	test   %al,%al
  80e35a:	75 53                	jne    80e3af <icmp_input+0x303>
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80e35c:	83 ec 04             	sub    $0x4,%esp
  80e35f:	ff 75 0c             	pushl  0xc(%ebp)
  80e362:	6a 01                	push   $0x1
  80e364:	6a 00                	push   $0x0
  80e366:	68 ff 00 00 00       	push   $0xff
  80e36b:	6a 00                	push   $0x0
  80e36d:	83 c7 0c             	add    $0xc,%edi
  80e370:	57                   	push   %edi
  80e371:	53                   	push   %ebx
  80e372:	e8 50 85 ff ff       	call   8068c7 <ip_output_if>
  80e377:	83 c4 20             	add    $0x20,%esp
  80e37a:	e9 77 fd ff ff       	jmp    80e0f6 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80e37f:	83 ec 04             	sub    $0x4,%esp
  80e382:	68 10 38 81 00       	push   $0x813810
  80e387:	68 98 00 00 00       	push   $0x98
  80e38c:	68 70 38 81 00       	push   $0x813870
  80e391:	e8 03 03 00 00       	call   80e699 <_panic>
      iecho->chksum += htons(ICMP_ECHO << 8);
  80e396:	83 ec 0c             	sub    $0xc,%esp
  80e399:	68 00 08 00 00       	push   $0x800
  80e39e:	e8 c1 93 ff ff       	call   807764 <htons>
  80e3a3:	66 01 46 02          	add    %ax,0x2(%esi)
  80e3a7:	83 c4 10             	add    $0x10,%esp
  80e3aa:	e9 63 ff ff ff       	jmp    80e312 <icmp_input+0x266>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80e3af:	83 ec 04             	sub    $0x4,%esp
  80e3b2:	68 d8 28 81 00       	push   $0x8128d8
  80e3b7:	68 b9 00 00 00       	push   $0xb9
  80e3bc:	68 70 38 81 00       	push   $0x813870
  80e3c1:	e8 d3 02 00 00       	call   80e699 <_panic>

0080e3c6 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80e3c6:	55                   	push   %ebp
  80e3c7:	89 e5                	mov    %esp,%ebp
  80e3c9:	57                   	push   %edi
  80e3ca:	56                   	push   %esi
  80e3cb:	53                   	push   %ebx
  80e3cc:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e3cf:	6a 00                	push   $0x0
  80e3d1:	6a 24                	push   $0x24
  80e3d3:	6a 01                	push   $0x1
  80e3d5:	e8 76 65 ff ff       	call   804950 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e3da:	83 c4 10             	add    $0x10,%esp
  80e3dd:	85 c0                	test   %eax,%eax
  80e3df:	0f 84 a5 00 00 00    	je     80e48a <icmp_dest_unreach+0xc4>
  80e3e5:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e3e7:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e3ec:	0f 86 a0 00 00 00    	jbe    80e492 <icmp_dest_unreach+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e3f2:	8b 45 08             	mov    0x8(%ebp),%eax
  80e3f5:	8b 78 04             	mov    0x4(%eax),%edi

  idur = q->payload;
  80e3f8:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80e3fb:	83 ec 0c             	sub    $0xc,%esp
  80e3fe:	0f b7 06             	movzwl (%esi),%eax
  80e401:	50                   	push   %eax
  80e402:	e8 6a 93 ff ff       	call   807771 <ntohs>
  80e407:	0f b6 c0             	movzbl %al,%eax
  80e40a:	80 cc 03             	or     $0x3,%ah
  80e40d:	89 04 24             	mov    %eax,(%esp)
  80e410:	e8 4f 93 ff ff       	call   807764 <htons>
  80e415:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80e418:	0f b7 c0             	movzwl %ax,%eax
  80e41b:	89 04 24             	mov    %eax,(%esp)
  80e41e:	e8 4e 93 ff ff       	call   807771 <ntohs>
  80e423:	b0 00                	mov    $0x0,%al
  80e425:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e429:	0f b7 c0             	movzwl %ax,%eax
  80e42c:	89 04 24             	mov    %eax,(%esp)
  80e42f:	e8 30 93 ff ff       	call   807764 <htons>
  80e434:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80e437:	83 c4 0c             	add    $0xc,%esp
  80e43a:	6a 1c                	push   $0x1c
  80e43c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e43f:	ff 70 04             	pushl  0x4(%eax)
  80e442:	8b 43 04             	mov    0x4(%ebx),%eax
  80e445:	83 c0 08             	add    $0x8,%eax
  80e448:	50                   	push   %eax
  80e449:	e8 90 0c 00 00       	call   80f0de <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80e44e:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80e454:	83 c4 08             	add    $0x8,%esp
  80e457:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e45b:	50                   	push   %eax
  80e45c:	56                   	push   %esi
  80e45d:	e8 d4 91 ff ff       	call   807636 <inet_chksum>
  80e462:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e466:	83 c4 08             	add    $0x8,%esp
  80e469:	6a 01                	push   $0x1
  80e46b:	6a 00                	push   $0x0
  80e46d:	68 ff 00 00 00       	push   $0xff
  80e472:	83 c7 0c             	add    $0xc,%edi
  80e475:	57                   	push   %edi
  80e476:	6a 00                	push   $0x0
  80e478:	53                   	push   %ebx
  80e479:	e8 d6 85 ff ff       	call   806a54 <ip_output>
  pbuf_free(q);
  80e47e:	83 c4 14             	add    $0x14,%esp
  80e481:	53                   	push   %ebx
  80e482:	e8 03 64 ff ff       	call   80488a <pbuf_free>
  80e487:	83 c4 10             	add    $0x10,%esp
}
  80e48a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e48d:	5b                   	pop    %ebx
  80e48e:	5e                   	pop    %esi
  80e48f:	5f                   	pop    %edi
  80e490:	5d                   	pop    %ebp
  80e491:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e492:	83 ec 04             	sub    $0x4,%esp
  80e495:	68 44 38 81 00       	push   $0x813844
  80e49a:	68 ef 00 00 00       	push   $0xef
  80e49f:	68 70 38 81 00       	push   $0x813870
  80e4a4:	e8 f0 01 00 00       	call   80e699 <_panic>

0080e4a9 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80e4a9:	55                   	push   %ebp
  80e4aa:	89 e5                	mov    %esp,%ebp
  80e4ac:	57                   	push   %edi
  80e4ad:	56                   	push   %esi
  80e4ae:	53                   	push   %ebx
  80e4af:	83 ec 10             	sub    $0x10,%esp
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80e4b2:	6a 00                	push   $0x0
  80e4b4:	6a 24                	push   $0x24
  80e4b6:	6a 01                	push   $0x1
  80e4b8:	e8 93 64 ff ff       	call   804950 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
  80e4bd:	83 c4 10             	add    $0x10,%esp
  80e4c0:	85 c0                	test   %eax,%eax
  80e4c2:	0f 84 a5 00 00 00    	je     80e56d <icmp_time_exceeded+0xc4>
  80e4c8:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e4ca:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80e4cf:	0f 86 a0 00 00 00    	jbe    80e575 <icmp_time_exceeded+0xcc>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80e4d5:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4d8:	8b 78 04             	mov    0x4(%eax),%edi
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80e4db:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80e4de:	83 ec 0c             	sub    $0xc,%esp
  80e4e1:	0f b7 06             	movzwl (%esi),%eax
  80e4e4:	50                   	push   %eax
  80e4e5:	e8 87 92 ff ff       	call   807771 <ntohs>
  80e4ea:	0f b6 c0             	movzbl %al,%eax
  80e4ed:	80 cc 0b             	or     $0xb,%ah
  80e4f0:	89 04 24             	mov    %eax,(%esp)
  80e4f3:	e8 6c 92 ff ff       	call   807764 <htons>
  80e4f8:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80e4fb:	0f b7 c0             	movzwl %ax,%eax
  80e4fe:	89 04 24             	mov    %eax,(%esp)
  80e501:	e8 6b 92 ff ff       	call   807771 <ntohs>
  80e506:	b0 00                	mov    $0x0,%al
  80e508:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80e50c:	0f b7 c0             	movzwl %ax,%eax
  80e50f:	89 04 24             	mov    %eax,(%esp)
  80e512:	e8 4d 92 ff ff       	call   807764 <htons>
  80e517:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80e51a:	83 c4 0c             	add    $0xc,%esp
  80e51d:	6a 1c                	push   $0x1c
  80e51f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e522:	ff 70 04             	pushl  0x4(%eax)
  80e525:	8b 43 04             	mov    0x4(%ebx),%eax
  80e528:	83 c0 08             	add    $0x8,%eax
  80e52b:	50                   	push   %eax
  80e52c:	e8 ad 0b 00 00       	call   80f0de <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80e531:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80e537:	83 c4 08             	add    $0x8,%esp
  80e53a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e53e:	50                   	push   %eax
  80e53f:	56                   	push   %esi
  80e540:	e8 f1 90 ff ff       	call   807636 <inet_chksum>
  80e545:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80e549:	83 c4 08             	add    $0x8,%esp
  80e54c:	6a 01                	push   $0x1
  80e54e:	6a 00                	push   $0x0
  80e550:	68 ff 00 00 00       	push   $0xff
  80e555:	83 c7 0c             	add    $0xc,%edi
  80e558:	57                   	push   %edi
  80e559:	6a 00                	push   $0x0
  80e55b:	53                   	push   %ebx
  80e55c:	e8 f3 84 ff ff       	call   806a54 <ip_output>
  pbuf_free(q);
  80e561:	83 c4 14             	add    $0x14,%esp
  80e564:	53                   	push   %ebx
  80e565:	e8 20 63 ff ff       	call   80488a <pbuf_free>
  80e56a:	83 c4 10             	add    $0x10,%esp
}
  80e56d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e570:	5b                   	pop    %ebx
  80e571:	5e                   	pop    %esi
  80e572:	5f                   	pop    %edi
  80e573:	5d                   	pop    %ebp
  80e574:	c3                   	ret    
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80e575:	83 ec 04             	sub    $0x4,%esp
  80e578:	68 44 38 81 00       	push   $0x813844
  80e57d:	68 1e 01 00 00       	push   $0x11e
  80e582:	68 70 38 81 00       	push   $0x813870
  80e587:	e8 0d 01 00 00       	call   80e699 <_panic>

0080e58c <libmain>:
        return &envs[ENVX(sys_getenvid())];
} 

void
libmain(int argc, char **argv)
{
  80e58c:	55                   	push   %ebp
  80e58d:	89 e5                	mov    %esp,%ebp
  80e58f:	57                   	push   %edi
  80e590:	56                   	push   %esi
  80e591:	53                   	push   %ebx
  80e592:	83 ec 0c             	sub    $0xc,%esp
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.

	thisenv = 0;
  80e595:	c7 05 5c b2 b3 00 00 	movl   $0x0,0xb3b25c
  80e59c:	00 00 00 
	envid_t find = sys_getenvid();
  80e59f:	e8 fe 0c 00 00       	call   80f2a2 <sys_getenvid>
  80e5a4:	8b 1d 5c b2 b3 00    	mov    0xb3b25c,%ebx
  80e5aa:	be 00 00 00 00       	mov    $0x0,%esi
	for(int i = 0; i < NENV; i++){
  80e5af:	ba 00 00 00 00       	mov    $0x0,%edx
		if(envs[i].env_id == find)
  80e5b4:	bf 01 00 00 00       	mov    $0x1,%edi
  80e5b9:	eb 0b                	jmp    80e5c6 <libmain+0x3a>
	for(int i = 0; i < NENV; i++){
  80e5bb:	83 c2 01             	add    $0x1,%edx
  80e5be:	81 fa 00 04 00 00    	cmp    $0x400,%edx
  80e5c4:	74 21                	je     80e5e7 <libmain+0x5b>
		if(envs[i].env_id == find)
  80e5c6:	89 d1                	mov    %edx,%ecx
  80e5c8:	c1 e1 07             	shl    $0x7,%ecx
  80e5cb:	81 c1 00 00 c0 ee    	add    $0xeec00000,%ecx
  80e5d1:	8b 49 48             	mov    0x48(%ecx),%ecx
  80e5d4:	39 c1                	cmp    %eax,%ecx
  80e5d6:	75 e3                	jne    80e5bb <libmain+0x2f>
  80e5d8:	89 d3                	mov    %edx,%ebx
  80e5da:	c1 e3 07             	shl    $0x7,%ebx
  80e5dd:	81 c3 00 00 c0 ee    	add    $0xeec00000,%ebx
  80e5e3:	89 fe                	mov    %edi,%esi
  80e5e5:	eb d4                	jmp    80e5bb <libmain+0x2f>
  80e5e7:	89 f0                	mov    %esi,%eax
  80e5e9:	84 c0                	test   %al,%al
  80e5eb:	74 06                	je     80e5f3 <libmain+0x67>
  80e5ed:	89 1d 5c b2 b3 00    	mov    %ebx,0xb3b25c
			thisenv = &envs[i];
	}

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80e5f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80e5f7:	7e 0a                	jle    80e603 <libmain+0x77>
		binaryname = argv[0];
  80e5f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e5fc:	8b 00                	mov    (%eax),%eax
  80e5fe:	a3 e8 42 81 00       	mov    %eax,0x8142e8

	cprintf("%d: in libmain.c call umain!\n", thisenv->env_id);
  80e603:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80e608:	8b 40 48             	mov    0x48(%eax),%eax
  80e60b:	83 ec 08             	sub    $0x8,%esp
  80e60e:	50                   	push   %eax
  80e60f:	68 8a 38 81 00       	push   $0x81388a
  80e614:	e8 76 01 00 00       	call   80e78f <cprintf>
	cprintf("before umain\n");
  80e619:	c7 04 24 a8 38 81 00 	movl   $0x8138a8,(%esp)
  80e620:	e8 6a 01 00 00       	call   80e78f <cprintf>
	// call user main routine
	umain(argc, argv);
  80e625:	83 c4 08             	add    $0x8,%esp
  80e628:	ff 75 0c             	pushl  0xc(%ebp)
  80e62b:	ff 75 08             	pushl  0x8(%ebp)
  80e62e:	e8 49 1f ff ff       	call   80057c <umain>
	cprintf("after umain\n");
  80e633:	c7 04 24 b6 38 81 00 	movl   $0x8138b6,(%esp)
  80e63a:	e8 50 01 00 00       	call   80e78f <cprintf>
	cprintf("%d: limain.c exit()\n", thisenv->env_id);
  80e63f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80e644:	8b 40 48             	mov    0x48(%eax),%eax
  80e647:	83 c4 08             	add    $0x8,%esp
  80e64a:	50                   	push   %eax
  80e64b:	68 c3 38 81 00       	push   $0x8138c3
  80e650:	e8 3a 01 00 00       	call   80e78f <cprintf>
	// exit gracefully
	exit();
  80e655:	e8 0b 00 00 00       	call   80e665 <exit>
}
  80e65a:	83 c4 10             	add    $0x10,%esp
  80e65d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e660:	5b                   	pop    %ebx
  80e661:	5e                   	pop    %esi
  80e662:	5f                   	pop    %edi
  80e663:	5d                   	pop    %ebp
  80e664:	c3                   	ret    

0080e665 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80e665:	55                   	push   %ebp
  80e666:	89 e5                	mov    %esp,%ebp
  80e668:	83 ec 0c             	sub    $0xc,%esp
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e66b:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80e670:	8b 40 48             	mov    0x48(%eax),%eax
  80e673:	68 f0 38 81 00       	push   $0x8138f0
  80e678:	50                   	push   %eax
  80e679:	68 e2 38 81 00       	push   $0x8138e2
  80e67e:	e8 0c 01 00 00       	call   80e78f <cprintf>
	close_all();
  80e683:	e8 e8 16 00 00       	call   80fd70 <close_all>
	sys_env_destroy(0);
  80e688:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e68f:	e8 cd 0b 00 00       	call   80f261 <sys_env_destroy>
}
  80e694:	83 c4 10             	add    $0x10,%esp
  80e697:	c9                   	leave  
  80e698:	c3                   	ret    

0080e699 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80e699:	55                   	push   %ebp
  80e69a:	89 e5                	mov    %esp,%ebp
  80e69c:	56                   	push   %esi
  80e69d:	53                   	push   %ebx
	cprintf("%d: in %s\n", thisenv->env_id, __FUNCTION__);
  80e69e:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80e6a3:	8b 40 48             	mov    0x48(%eax),%eax
  80e6a6:	83 ec 04             	sub    $0x4,%esp
  80e6a9:	68 1c 39 81 00       	push   $0x81391c
  80e6ae:	50                   	push   %eax
  80e6af:	68 e2 38 81 00       	push   $0x8138e2
  80e6b4:	e8 d6 00 00 00       	call   80e78f <cprintf>
	va_list ap;

	va_start(ap, fmt);
  80e6b9:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	// cprintf("[%08x] user panic in %s at %s:%d: ",
	// 	sys_getenvid(), binaryname, file, line);
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80e6bc:	8b 35 e8 42 81 00    	mov    0x8142e8,%esi
  80e6c2:	e8 db 0b 00 00       	call   80f2a2 <sys_getenvid>
  80e6c7:	83 c4 04             	add    $0x4,%esp
  80e6ca:	ff 75 0c             	pushl  0xc(%ebp)
  80e6cd:	ff 75 08             	pushl  0x8(%ebp)
  80e6d0:	56                   	push   %esi
  80e6d1:	50                   	push   %eax
  80e6d2:	68 f8 38 81 00       	push   $0x8138f8
  80e6d7:	e8 b3 00 00 00       	call   80e78f <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80e6dc:	83 c4 18             	add    $0x18,%esp
  80e6df:	53                   	push   %ebx
  80e6e0:	ff 75 10             	pushl  0x10(%ebp)
  80e6e3:	e8 56 00 00 00       	call   80e73e <vcprintf>
	cprintf("\n");
  80e6e8:	c7 04 24 a6 38 81 00 	movl   $0x8138a6,(%esp)
  80e6ef:	e8 9b 00 00 00       	call   80e78f <cprintf>
  80e6f4:	83 c4 10             	add    $0x10,%esp

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80e6f7:	cc                   	int3   
  80e6f8:	eb fd                	jmp    80e6f7 <_panic+0x5e>

0080e6fa <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80e6fa:	55                   	push   %ebp
  80e6fb:	89 e5                	mov    %esp,%ebp
  80e6fd:	53                   	push   %ebx
  80e6fe:	83 ec 04             	sub    $0x4,%esp
  80e701:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80e704:	8b 13                	mov    (%ebx),%edx
  80e706:	8d 42 01             	lea    0x1(%edx),%eax
  80e709:	89 03                	mov    %eax,(%ebx)
  80e70b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80e70e:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80e712:	3d ff 00 00 00       	cmp    $0xff,%eax
  80e717:	74 09                	je     80e722 <putch+0x28>
		sys_cputs(b->buf, b->idx);
		b->idx = 0;
	}
	b->cnt++;
  80e719:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80e71d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80e720:	c9                   	leave  
  80e721:	c3                   	ret    
		sys_cputs(b->buf, b->idx);
  80e722:	83 ec 08             	sub    $0x8,%esp
  80e725:	68 ff 00 00 00       	push   $0xff
  80e72a:	8d 43 08             	lea    0x8(%ebx),%eax
  80e72d:	50                   	push   %eax
  80e72e:	e8 f1 0a 00 00       	call   80f224 <sys_cputs>
		b->idx = 0;
  80e733:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80e739:	83 c4 10             	add    $0x10,%esp
  80e73c:	eb db                	jmp    80e719 <putch+0x1f>

0080e73e <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80e73e:	55                   	push   %ebp
  80e73f:	89 e5                	mov    %esp,%ebp
  80e741:	81 ec 18 01 00 00    	sub    $0x118,%esp
	struct printbuf b;

	b.idx = 0;
  80e747:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80e74e:	00 00 00 
	b.cnt = 0;
  80e751:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80e758:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80e75b:	ff 75 0c             	pushl  0xc(%ebp)
  80e75e:	ff 75 08             	pushl  0x8(%ebp)
  80e761:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80e767:	50                   	push   %eax
  80e768:	68 fa e6 80 00       	push   $0x80e6fa
  80e76d:	e8 4a 01 00 00       	call   80e8bc <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80e772:	83 c4 08             	add    $0x8,%esp
  80e775:	ff b5 f0 fe ff ff    	pushl  -0x110(%ebp)
  80e77b:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80e781:	50                   	push   %eax
  80e782:	e8 9d 0a 00 00       	call   80f224 <sys_cputs>

	return b.cnt;
}
  80e787:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80e78d:	c9                   	leave  
  80e78e:	c3                   	ret    

0080e78f <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80e78f:	55                   	push   %ebp
  80e790:	89 e5                	mov    %esp,%ebp
  80e792:	83 ec 10             	sub    $0x10,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80e795:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80e798:	50                   	push   %eax
  80e799:	ff 75 08             	pushl  0x8(%ebp)
  80e79c:	e8 9d ff ff ff       	call   80e73e <vcprintf>
	va_end(ap);

	return cnt;
}
  80e7a1:	c9                   	leave  
  80e7a2:	c3                   	ret    

0080e7a3 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80e7a3:	55                   	push   %ebp
  80e7a4:	89 e5                	mov    %esp,%ebp
  80e7a6:	57                   	push   %edi
  80e7a7:	56                   	push   %esi
  80e7a8:	53                   	push   %ebx
  80e7a9:	83 ec 1c             	sub    $0x1c,%esp
  80e7ac:	89 c6                	mov    %eax,%esi
  80e7ae:	89 d7                	mov    %edx,%edi
  80e7b0:	8b 45 08             	mov    0x8(%ebp),%eax
  80e7b3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e7b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e7b9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80e7bc:	8b 45 10             	mov    0x10(%ebp),%eax
  80e7bf:	8b 5d 14             	mov    0x14(%ebp),%ebx
	// if cprintf'parameter includes pattern of the form "%-", padding
	// space on the right side if neccesary.
	// you can add helper function if needed.
	// your code here:
	if(padc == '-'){
  80e7c2:	83 7d 18 2d          	cmpl   $0x2d,0x18(%ebp)
  80e7c6:	74 2c                	je     80e7f4 <printnum+0x51>
		while (--width > 0)
			putch(padc, putdat);
	}
	else {
		// first recursively print all preceding (more significant) digits
		if (num >= base) {
  80e7c8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e7cb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80e7d2:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e7d5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80e7d8:	39 c2                	cmp    %eax,%edx
  80e7da:	1b 4d dc             	sbb    -0x24(%ebp),%ecx
  80e7dd:	73 43                	jae    80e822 <printnum+0x7f>
			printnum(putch, putdat, num / base, base, width - 1, padc);
		} else {
			// print any needed pad characters before first digit
			while (--width > 0)
  80e7df:	83 eb 01             	sub    $0x1,%ebx
  80e7e2:	85 db                	test   %ebx,%ebx
  80e7e4:	7e 6c                	jle    80e852 <printnum+0xaf>
				putch(padc, putdat);
  80e7e6:	83 ec 08             	sub    $0x8,%esp
  80e7e9:	57                   	push   %edi
  80e7ea:	ff 75 18             	pushl  0x18(%ebp)
  80e7ed:	ff d6                	call   *%esi
  80e7ef:	83 c4 10             	add    $0x10,%esp
  80e7f2:	eb eb                	jmp    80e7df <printnum+0x3c>
		printnum(putch, putdat, num, base, 0, padc);
  80e7f4:	83 ec 0c             	sub    $0xc,%esp
  80e7f7:	6a 20                	push   $0x20
  80e7f9:	6a 00                	push   $0x0
  80e7fb:	50                   	push   %eax
  80e7fc:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e7ff:	ff 75 e0             	pushl  -0x20(%ebp)
  80e802:	89 fa                	mov    %edi,%edx
  80e804:	89 f0                	mov    %esi,%eax
  80e806:	e8 98 ff ff ff       	call   80e7a3 <printnum>
		while (--width > 0)
  80e80b:	83 c4 20             	add    $0x20,%esp
  80e80e:	83 eb 01             	sub    $0x1,%ebx
  80e811:	85 db                	test   %ebx,%ebx
  80e813:	7e 65                	jle    80e87a <printnum+0xd7>
			putch(padc, putdat);
  80e815:	83 ec 08             	sub    $0x8,%esp
  80e818:	57                   	push   %edi
  80e819:	6a 20                	push   $0x20
  80e81b:	ff d6                	call   *%esi
  80e81d:	83 c4 10             	add    $0x10,%esp
  80e820:	eb ec                	jmp    80e80e <printnum+0x6b>
			printnum(putch, putdat, num / base, base, width - 1, padc);
  80e822:	83 ec 0c             	sub    $0xc,%esp
  80e825:	ff 75 18             	pushl  0x18(%ebp)
  80e828:	83 eb 01             	sub    $0x1,%ebx
  80e82b:	53                   	push   %ebx
  80e82c:	50                   	push   %eax
  80e82d:	83 ec 08             	sub    $0x8,%esp
  80e830:	ff 75 dc             	pushl  -0x24(%ebp)
  80e833:	ff 75 d8             	pushl  -0x28(%ebp)
  80e836:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e839:	ff 75 e0             	pushl  -0x20(%ebp)
  80e83c:	e8 1f 28 00 00       	call   811060 <__udivdi3>
  80e841:	83 c4 18             	add    $0x18,%esp
  80e844:	52                   	push   %edx
  80e845:	50                   	push   %eax
  80e846:	89 fa                	mov    %edi,%edx
  80e848:	89 f0                	mov    %esi,%eax
  80e84a:	e8 54 ff ff ff       	call   80e7a3 <printnum>
  80e84f:	83 c4 20             	add    $0x20,%esp
		}

		// then print this (the least significant) digit
		putch("0123456789abcdef"[num % base], putdat);
  80e852:	83 ec 08             	sub    $0x8,%esp
  80e855:	57                   	push   %edi
  80e856:	83 ec 04             	sub    $0x4,%esp
  80e859:	ff 75 dc             	pushl  -0x24(%ebp)
  80e85c:	ff 75 d8             	pushl  -0x28(%ebp)
  80e85f:	ff 75 e4             	pushl  -0x1c(%ebp)
  80e862:	ff 75 e0             	pushl  -0x20(%ebp)
  80e865:	e8 06 29 00 00       	call   811170 <__umoddi3>
  80e86a:	83 c4 14             	add    $0x14,%esp
  80e86d:	0f be 80 23 39 81 00 	movsbl 0x813923(%eax),%eax
  80e874:	50                   	push   %eax
  80e875:	ff d6                	call   *%esi
  80e877:	83 c4 10             	add    $0x10,%esp
	}
}
  80e87a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80e87d:	5b                   	pop    %ebx
  80e87e:	5e                   	pop    %esi
  80e87f:	5f                   	pop    %edi
  80e880:	5d                   	pop    %ebp
  80e881:	c3                   	ret    

0080e882 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80e882:	55                   	push   %ebp
  80e883:	89 e5                	mov    %esp,%ebp
  80e885:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80e888:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80e88c:	8b 10                	mov    (%eax),%edx
  80e88e:	3b 50 04             	cmp    0x4(%eax),%edx
  80e891:	73 0a                	jae    80e89d <sprintputch+0x1b>
		*b->buf++ = ch;
  80e893:	8d 4a 01             	lea    0x1(%edx),%ecx
  80e896:	89 08                	mov    %ecx,(%eax)
  80e898:	8b 45 08             	mov    0x8(%ebp),%eax
  80e89b:	88 02                	mov    %al,(%edx)
}
  80e89d:	5d                   	pop    %ebp
  80e89e:	c3                   	ret    

0080e89f <printfmt>:
{
  80e89f:	55                   	push   %ebp
  80e8a0:	89 e5                	mov    %esp,%ebp
  80e8a2:	83 ec 08             	sub    $0x8,%esp
	va_start(ap, fmt);
  80e8a5:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80e8a8:	50                   	push   %eax
  80e8a9:	ff 75 10             	pushl  0x10(%ebp)
  80e8ac:	ff 75 0c             	pushl  0xc(%ebp)
  80e8af:	ff 75 08             	pushl  0x8(%ebp)
  80e8b2:	e8 05 00 00 00       	call   80e8bc <vprintfmt>
}
  80e8b7:	83 c4 10             	add    $0x10,%esp
  80e8ba:	c9                   	leave  
  80e8bb:	c3                   	ret    

0080e8bc <vprintfmt>:
{
  80e8bc:	55                   	push   %ebp
  80e8bd:	89 e5                	mov    %esp,%ebp
  80e8bf:	57                   	push   %edi
  80e8c0:	56                   	push   %esi
  80e8c1:	53                   	push   %ebx
  80e8c2:	83 ec 3c             	sub    $0x3c,%esp
  80e8c5:	8b 75 08             	mov    0x8(%ebp),%esi
  80e8c8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80e8cb:	8b 7d 10             	mov    0x10(%ebp),%edi
  80e8ce:	e9 32 04 00 00       	jmp    80ed05 <vprintfmt+0x449>
		padc = ' ';
  80e8d3:	c6 45 cf 20          	movb   $0x20,-0x31(%ebp)
		plusflag = 0;
  80e8d7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		altflag = 0;
  80e8de:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		precision = -1;
  80e8e5:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
  80e8ec:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
  80e8f3:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80e8fa:	b9 00 00 00 00       	mov    $0x0,%ecx
		switch (ch = *(unsigned char *) fmt++) {
  80e8ff:	8d 47 01             	lea    0x1(%edi),%eax
  80e902:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e905:	0f b6 17             	movzbl (%edi),%edx
  80e908:	8d 42 dd             	lea    -0x23(%edx),%eax
  80e90b:	3c 55                	cmp    $0x55,%al
  80e90d:	0f 87 12 05 00 00    	ja     80ee25 <vprintfmt+0x569>
  80e913:	0f b6 c0             	movzbl %al,%eax
  80e916:	ff 24 85 00 3b 81 00 	jmp    *0x813b00(,%eax,4)
  80e91d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '-';
  80e920:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
  80e924:	eb d9                	jmp    80e8ff <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80e926:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			padc = '0';
  80e929:	c6 45 cf 30          	movb   $0x30,-0x31(%ebp)
  80e92d:	eb d0                	jmp    80e8ff <vprintfmt+0x43>
		switch (ch = *(unsigned char *) fmt++) {
  80e92f:	0f b6 d2             	movzbl %dl,%edx
  80e932:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			for (precision = 0; ; ++fmt) {
  80e935:	b8 00 00 00 00       	mov    $0x0,%eax
  80e93a:	89 75 08             	mov    %esi,0x8(%ebp)
  80e93d:	eb 03                	jmp    80e942 <vprintfmt+0x86>
  80e93f:	83 c7 01             	add    $0x1,%edi
				precision = precision * 10 + ch - '0';
  80e942:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80e945:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
				ch = *fmt;
  80e949:	0f be 17             	movsbl (%edi),%edx
				if (ch < '0' || ch > '9')
  80e94c:	8d 72 d0             	lea    -0x30(%edx),%esi
  80e94f:	83 fe 09             	cmp    $0x9,%esi
  80e952:	76 eb                	jbe    80e93f <vprintfmt+0x83>
  80e954:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e957:	8b 75 08             	mov    0x8(%ebp),%esi
  80e95a:	eb 14                	jmp    80e970 <vprintfmt+0xb4>
			precision = va_arg(ap, int);
  80e95c:	8b 45 14             	mov    0x14(%ebp),%eax
  80e95f:	8b 00                	mov    (%eax),%eax
  80e961:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80e964:	8b 45 14             	mov    0x14(%ebp),%eax
  80e967:	8d 40 04             	lea    0x4(%eax),%eax
  80e96a:	89 45 14             	mov    %eax,0x14(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e96d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			if (width < 0)
  80e970:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80e974:	79 89                	jns    80e8ff <vprintfmt+0x43>
				width = precision, precision = -1;
  80e976:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80e979:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e97c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
  80e983:	e9 77 ff ff ff       	jmp    80e8ff <vprintfmt+0x43>
  80e988:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e98b:	85 c0                	test   %eax,%eax
  80e98d:	0f 48 c1             	cmovs  %ecx,%eax
  80e990:	89 45 e0             	mov    %eax,-0x20(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e993:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80e996:	e9 64 ff ff ff       	jmp    80e8ff <vprintfmt+0x43>
  80e99b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			altflag = 1;
  80e99e:	c7 45 d0 01 00 00 00 	movl   $0x1,-0x30(%ebp)
			goto reswitch;
  80e9a5:	e9 55 ff ff ff       	jmp    80e8ff <vprintfmt+0x43>
			lflag++;
  80e9aa:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
		switch (ch = *(unsigned char *) fmt++) {
  80e9ae:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			goto reswitch;
  80e9b1:	e9 49 ff ff ff       	jmp    80e8ff <vprintfmt+0x43>
			putch(va_arg(ap, int), putdat);
  80e9b6:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9b9:	8d 78 04             	lea    0x4(%eax),%edi
  80e9bc:	83 ec 08             	sub    $0x8,%esp
  80e9bf:	53                   	push   %ebx
  80e9c0:	ff 30                	pushl  (%eax)
  80e9c2:	ff d6                	call   *%esi
			break;
  80e9c4:	83 c4 10             	add    $0x10,%esp
			putch(va_arg(ap, int), putdat);
  80e9c7:	89 7d 14             	mov    %edi,0x14(%ebp)
			break;
  80e9ca:	e9 33 03 00 00       	jmp    80ed02 <vprintfmt+0x446>
			err = va_arg(ap, int);
  80e9cf:	8b 45 14             	mov    0x14(%ebp),%eax
  80e9d2:	8d 78 04             	lea    0x4(%eax),%edi
  80e9d5:	8b 00                	mov    (%eax),%eax
  80e9d7:	99                   	cltd   
  80e9d8:	31 d0                	xor    %edx,%eax
  80e9da:	29 d0                	sub    %edx,%eax
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80e9dc:	83 f8 11             	cmp    $0x11,%eax
  80e9df:	7f 23                	jg     80ea04 <vprintfmt+0x148>
  80e9e1:	8b 14 85 60 3c 81 00 	mov    0x813c60(,%eax,4),%edx
  80e9e8:	85 d2                	test   %edx,%edx
  80e9ea:	74 18                	je     80ea04 <vprintfmt+0x148>
				printfmt(putch, putdat, "%s", p);
  80e9ec:	52                   	push   %edx
  80e9ed:	68 9d 2a 81 00       	push   $0x812a9d
  80e9f2:	53                   	push   %ebx
  80e9f3:	56                   	push   %esi
  80e9f4:	e8 a6 fe ff ff       	call   80e89f <printfmt>
  80e9f9:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80e9fc:	89 7d 14             	mov    %edi,0x14(%ebp)
  80e9ff:	e9 fe 02 00 00       	jmp    80ed02 <vprintfmt+0x446>
				printfmt(putch, putdat, "error %d", err);
  80ea04:	50                   	push   %eax
  80ea05:	68 3b 39 81 00       	push   $0x81393b
  80ea0a:	53                   	push   %ebx
  80ea0b:	56                   	push   %esi
  80ea0c:	e8 8e fe ff ff       	call   80e89f <printfmt>
  80ea11:	83 c4 10             	add    $0x10,%esp
			err = va_arg(ap, int);
  80ea14:	89 7d 14             	mov    %edi,0x14(%ebp)
				printfmt(putch, putdat, "error %d", err);
  80ea17:	e9 e6 02 00 00       	jmp    80ed02 <vprintfmt+0x446>
			if ((p = va_arg(ap, char *)) == NULL)
  80ea1c:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea1f:	83 c0 04             	add    $0x4,%eax
  80ea22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  80ea25:	8b 45 14             	mov    0x14(%ebp),%eax
  80ea28:	8b 08                	mov    (%eax),%ecx
				p = "(null)";
  80ea2a:	85 c9                	test   %ecx,%ecx
  80ea2c:	b8 34 39 81 00       	mov    $0x813934,%eax
  80ea31:	0f 45 c1             	cmovne %ecx,%eax
  80ea34:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (width > 0 && padc != '-')
  80ea37:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80ea3b:	7e 06                	jle    80ea43 <vprintfmt+0x187>
  80ea3d:	80 7d cf 2d          	cmpb   $0x2d,-0x31(%ebp)
  80ea41:	75 0d                	jne    80ea50 <vprintfmt+0x194>
				for (width -= strnlen(p, precision); width > 0; width--)
  80ea43:	8b 45 c8             	mov    -0x38(%ebp),%eax
  80ea46:	89 c7                	mov    %eax,%edi
  80ea48:	03 45 e0             	add    -0x20(%ebp),%eax
  80ea4b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ea4e:	eb 53                	jmp    80eaa3 <vprintfmt+0x1e7>
  80ea50:	83 ec 08             	sub    $0x8,%esp
  80ea53:	ff 75 d8             	pushl  -0x28(%ebp)
  80ea56:	50                   	push   %eax
  80ea57:	e8 71 04 00 00       	call   80eecd <strnlen>
  80ea5c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ea5f:	29 c1                	sub    %eax,%ecx
  80ea61:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80ea64:	83 c4 10             	add    $0x10,%esp
  80ea67:	89 cf                	mov    %ecx,%edi
					putch(padc, putdat);
  80ea69:	0f be 45 cf          	movsbl -0x31(%ebp),%eax
  80ea6d:	89 45 e0             	mov    %eax,-0x20(%ebp)
				for (width -= strnlen(p, precision); width > 0; width--)
  80ea70:	eb 0f                	jmp    80ea81 <vprintfmt+0x1c5>
					putch(padc, putdat);
  80ea72:	83 ec 08             	sub    $0x8,%esp
  80ea75:	53                   	push   %ebx
  80ea76:	ff 75 e0             	pushl  -0x20(%ebp)
  80ea79:	ff d6                	call   *%esi
				for (width -= strnlen(p, precision); width > 0; width--)
  80ea7b:	83 ef 01             	sub    $0x1,%edi
  80ea7e:	83 c4 10             	add    $0x10,%esp
  80ea81:	85 ff                	test   %edi,%edi
  80ea83:	7f ed                	jg     80ea72 <vprintfmt+0x1b6>
  80ea85:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80ea88:	85 c9                	test   %ecx,%ecx
  80ea8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea8f:	0f 49 c1             	cmovns %ecx,%eax
  80ea92:	29 c1                	sub    %eax,%ecx
  80ea94:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80ea97:	eb aa                	jmp    80ea43 <vprintfmt+0x187>
					putch(ch, putdat);
  80ea99:	83 ec 08             	sub    $0x8,%esp
  80ea9c:	53                   	push   %ebx
  80ea9d:	52                   	push   %edx
  80ea9e:	ff d6                	call   *%esi
  80eaa0:	83 c4 10             	add    $0x10,%esp
  80eaa3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80eaa6:	29 f9                	sub    %edi,%ecx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80eaa8:	83 c7 01             	add    $0x1,%edi
  80eaab:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80eaaf:	0f be d0             	movsbl %al,%edx
  80eab2:	85 d2                	test   %edx,%edx
  80eab4:	74 4b                	je     80eb01 <vprintfmt+0x245>
  80eab6:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80eaba:	78 06                	js     80eac2 <vprintfmt+0x206>
  80eabc:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  80eac0:	78 1e                	js     80eae0 <vprintfmt+0x224>
				if (altflag && (ch < ' ' || ch > '~'))
  80eac2:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80eac6:	74 d1                	je     80ea99 <vprintfmt+0x1dd>
  80eac8:	0f be c0             	movsbl %al,%eax
  80eacb:	83 e8 20             	sub    $0x20,%eax
  80eace:	83 f8 5e             	cmp    $0x5e,%eax
  80ead1:	76 c6                	jbe    80ea99 <vprintfmt+0x1dd>
					putch('?', putdat);
  80ead3:	83 ec 08             	sub    $0x8,%esp
  80ead6:	53                   	push   %ebx
  80ead7:	6a 3f                	push   $0x3f
  80ead9:	ff d6                	call   *%esi
  80eadb:	83 c4 10             	add    $0x10,%esp
  80eade:	eb c3                	jmp    80eaa3 <vprintfmt+0x1e7>
  80eae0:	89 cf                	mov    %ecx,%edi
  80eae2:	eb 0e                	jmp    80eaf2 <vprintfmt+0x236>
				putch(' ', putdat);
  80eae4:	83 ec 08             	sub    $0x8,%esp
  80eae7:	53                   	push   %ebx
  80eae8:	6a 20                	push   $0x20
  80eaea:	ff d6                	call   *%esi
			for (; width > 0; width--)
  80eaec:	83 ef 01             	sub    $0x1,%edi
  80eaef:	83 c4 10             	add    $0x10,%esp
  80eaf2:	85 ff                	test   %edi,%edi
  80eaf4:	7f ee                	jg     80eae4 <vprintfmt+0x228>
			if ((p = va_arg(ap, char *)) == NULL)
  80eaf6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  80eaf9:	89 45 14             	mov    %eax,0x14(%ebp)
  80eafc:	e9 01 02 00 00       	jmp    80ed02 <vprintfmt+0x446>
  80eb01:	89 cf                	mov    %ecx,%edi
  80eb03:	eb ed                	jmp    80eaf2 <vprintfmt+0x236>
		switch (ch = *(unsigned char *) fmt++) {
  80eb05:	8b 7d e4             	mov    -0x1c(%ebp),%edi
			plusflag = 1;
  80eb08:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
			goto reswitch;
  80eb0f:	e9 eb fd ff ff       	jmp    80e8ff <vprintfmt+0x43>
	if (lflag >= 2)
  80eb14:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80eb18:	7f 21                	jg     80eb3b <vprintfmt+0x27f>
	else if (lflag)
  80eb1a:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80eb1e:	74 68                	je     80eb88 <vprintfmt+0x2cc>
		return va_arg(*ap, long);
  80eb20:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb23:	8b 00                	mov    (%eax),%eax
  80eb25:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80eb28:	89 c1                	mov    %eax,%ecx
  80eb2a:	c1 f9 1f             	sar    $0x1f,%ecx
  80eb2d:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80eb30:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb33:	8d 40 04             	lea    0x4(%eax),%eax
  80eb36:	89 45 14             	mov    %eax,0x14(%ebp)
  80eb39:	eb 17                	jmp    80eb52 <vprintfmt+0x296>
		return va_arg(*ap, long long);
  80eb3b:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb3e:	8b 50 04             	mov    0x4(%eax),%edx
  80eb41:	8b 00                	mov    (%eax),%eax
  80eb43:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80eb46:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80eb49:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb4c:	8d 40 08             	lea    0x8(%eax),%eax
  80eb4f:	89 45 14             	mov    %eax,0x14(%ebp)
			num = getint(&ap, lflag);
  80eb52:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80eb55:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80eb58:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eb5b:	89 55 dc             	mov    %edx,-0x24(%ebp)
			if ((long long) num < 0) {
  80eb5e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80eb62:	78 3f                	js     80eba3 <vprintfmt+0x2e7>
			base = 10;
  80eb64:	b8 0a 00 00 00       	mov    $0xa,%eax
			else if(plusflag){
  80eb69:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  80eb6d:	0f 84 71 01 00 00    	je     80ece4 <vprintfmt+0x428>
				putch('+', putdat);
  80eb73:	83 ec 08             	sub    $0x8,%esp
  80eb76:	53                   	push   %ebx
  80eb77:	6a 2b                	push   $0x2b
  80eb79:	ff d6                	call   *%esi
  80eb7b:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80eb7e:	b8 0a 00 00 00       	mov    $0xa,%eax
  80eb83:	e9 5c 01 00 00       	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, int);
  80eb88:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb8b:	8b 00                	mov    (%eax),%eax
  80eb8d:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80eb90:	89 c1                	mov    %eax,%ecx
  80eb92:	c1 f9 1f             	sar    $0x1f,%ecx
  80eb95:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80eb98:	8b 45 14             	mov    0x14(%ebp),%eax
  80eb9b:	8d 40 04             	lea    0x4(%eax),%eax
  80eb9e:	89 45 14             	mov    %eax,0x14(%ebp)
  80eba1:	eb af                	jmp    80eb52 <vprintfmt+0x296>
				putch('-', putdat);
  80eba3:	83 ec 08             	sub    $0x8,%esp
  80eba6:	53                   	push   %ebx
  80eba7:	6a 2d                	push   $0x2d
  80eba9:	ff d6                	call   *%esi
				num = -(long long) num;
  80ebab:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80ebae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ebb1:	f7 d8                	neg    %eax
  80ebb3:	83 d2 00             	adc    $0x0,%edx
  80ebb6:	f7 da                	neg    %edx
  80ebb8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebbb:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ebbe:	83 c4 10             	add    $0x10,%esp
			base = 10;
  80ebc1:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ebc6:	e9 19 01 00 00       	jmp    80ece4 <vprintfmt+0x428>
	if (lflag >= 2)
  80ebcb:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ebcf:	7f 29                	jg     80ebfa <vprintfmt+0x33e>
	else if (lflag)
  80ebd1:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ebd5:	74 44                	je     80ec1b <vprintfmt+0x35f>
		return va_arg(*ap, unsigned long);
  80ebd7:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebda:	8b 00                	mov    (%eax),%eax
  80ebdc:	ba 00 00 00 00       	mov    $0x0,%edx
  80ebe1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ebe4:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ebe7:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebea:	8d 40 04             	lea    0x4(%eax),%eax
  80ebed:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ebf0:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ebf5:	e9 ea 00 00 00       	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ebfa:	8b 45 14             	mov    0x14(%ebp),%eax
  80ebfd:	8b 50 04             	mov    0x4(%eax),%edx
  80ec00:	8b 00                	mov    (%eax),%eax
  80ec02:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec05:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec08:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec0b:	8d 40 08             	lea    0x8(%eax),%eax
  80ec0e:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ec11:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ec16:	e9 c9 00 00 00       	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ec1b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec1e:	8b 00                	mov    (%eax),%eax
  80ec20:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec25:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec28:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec2b:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec2e:	8d 40 04             	lea    0x4(%eax),%eax
  80ec31:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 10;
  80ec34:	b8 0a 00 00 00       	mov    $0xa,%eax
  80ec39:	e9 a6 00 00 00       	jmp    80ece4 <vprintfmt+0x428>
			putch('0', putdat);
  80ec3e:	83 ec 08             	sub    $0x8,%esp
  80ec41:	53                   	push   %ebx
  80ec42:	6a 30                	push   $0x30
  80ec44:	ff d6                	call   *%esi
	if (lflag >= 2)
  80ec46:	83 c4 10             	add    $0x10,%esp
  80ec49:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ec4d:	7f 26                	jg     80ec75 <vprintfmt+0x3b9>
	else if (lflag)
  80ec4f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ec53:	74 3e                	je     80ec93 <vprintfmt+0x3d7>
		return va_arg(*ap, unsigned long);
  80ec55:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec58:	8b 00                	mov    (%eax),%eax
  80ec5a:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec5f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec62:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec65:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec68:	8d 40 04             	lea    0x4(%eax),%eax
  80ec6b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ec6e:	b8 08 00 00 00       	mov    $0x8,%eax
  80ec73:	eb 6f                	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ec75:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec78:	8b 50 04             	mov    0x4(%eax),%edx
  80ec7b:	8b 00                	mov    (%eax),%eax
  80ec7d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ec80:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ec83:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec86:	8d 40 08             	lea    0x8(%eax),%eax
  80ec89:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ec8c:	b8 08 00 00 00       	mov    $0x8,%eax
  80ec91:	eb 51                	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ec93:	8b 45 14             	mov    0x14(%ebp),%eax
  80ec96:	8b 00                	mov    (%eax),%eax
  80ec98:	ba 00 00 00 00       	mov    $0x0,%edx
  80ec9d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eca0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80eca3:	8b 45 14             	mov    0x14(%ebp),%eax
  80eca6:	8d 40 04             	lea    0x4(%eax),%eax
  80eca9:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 8;
  80ecac:	b8 08 00 00 00       	mov    $0x8,%eax
  80ecb1:	eb 31                	jmp    80ece4 <vprintfmt+0x428>
			putch('0', putdat);
  80ecb3:	83 ec 08             	sub    $0x8,%esp
  80ecb6:	53                   	push   %ebx
  80ecb7:	6a 30                	push   $0x30
  80ecb9:	ff d6                	call   *%esi
			putch('x', putdat);
  80ecbb:	83 c4 08             	add    $0x8,%esp
  80ecbe:	53                   	push   %ebx
  80ecbf:	6a 78                	push   $0x78
  80ecc1:	ff d6                	call   *%esi
			num = (unsigned long long)
  80ecc3:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecc6:	8b 00                	mov    (%eax),%eax
  80ecc8:	ba 00 00 00 00       	mov    $0x0,%edx
  80eccd:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ecd0:	89 55 dc             	mov    %edx,-0x24(%ebp)
			goto number;
  80ecd3:	83 c4 10             	add    $0x10,%esp
				(uintptr_t) va_arg(ap, void *);
  80ecd6:	8b 45 14             	mov    0x14(%ebp),%eax
  80ecd9:	8d 40 04             	lea    0x4(%eax),%eax
  80ecdc:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ecdf:	b8 10 00 00 00       	mov    $0x10,%eax
			printnum(putch, putdat, num, base, width, padc);
  80ece4:	83 ec 0c             	sub    $0xc,%esp
  80ece7:	0f be 55 cf          	movsbl -0x31(%ebp),%edx
  80eceb:	52                   	push   %edx
  80ecec:	ff 75 e0             	pushl  -0x20(%ebp)
  80ecef:	50                   	push   %eax
  80ecf0:	ff 75 dc             	pushl  -0x24(%ebp)
  80ecf3:	ff 75 d8             	pushl  -0x28(%ebp)
  80ecf6:	89 da                	mov    %ebx,%edx
  80ecf8:	89 f0                	mov    %esi,%eax
  80ecfa:	e8 a4 fa ff ff       	call   80e7a3 <printnum>
			break;
  80ecff:	83 c4 20             	add    $0x20,%esp
			if ((p = va_arg(ap, char *)) == NULL)
  80ed02:	8b 7d e4             	mov    -0x1c(%ebp),%edi
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80ed05:	83 c7 01             	add    $0x1,%edi
  80ed08:	0f b6 47 ff          	movzbl -0x1(%edi),%eax
  80ed0c:	83 f8 25             	cmp    $0x25,%eax
  80ed0f:	0f 84 be fb ff ff    	je     80e8d3 <vprintfmt+0x17>
			if (ch == '\0')
  80ed15:	85 c0                	test   %eax,%eax
  80ed17:	0f 84 28 01 00 00    	je     80ee45 <vprintfmt+0x589>
			putch(ch, putdat);
  80ed1d:	83 ec 08             	sub    $0x8,%esp
  80ed20:	53                   	push   %ebx
  80ed21:	50                   	push   %eax
  80ed22:	ff d6                	call   *%esi
  80ed24:	83 c4 10             	add    $0x10,%esp
  80ed27:	eb dc                	jmp    80ed05 <vprintfmt+0x449>
	if (lflag >= 2)
  80ed29:	83 7d c8 01          	cmpl   $0x1,-0x38(%ebp)
  80ed2d:	7f 26                	jg     80ed55 <vprintfmt+0x499>
	else if (lflag)
  80ed2f:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80ed33:	74 41                	je     80ed76 <vprintfmt+0x4ba>
		return va_arg(*ap, unsigned long);
  80ed35:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed38:	8b 00                	mov    (%eax),%eax
  80ed3a:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed3f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed42:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed45:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed48:	8d 40 04             	lea    0x4(%eax),%eax
  80ed4b:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ed4e:	b8 10 00 00 00       	mov    $0x10,%eax
  80ed53:	eb 8f                	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned long long);
  80ed55:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed58:	8b 50 04             	mov    0x4(%eax),%edx
  80ed5b:	8b 00                	mov    (%eax),%eax
  80ed5d:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed60:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed63:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed66:	8d 40 08             	lea    0x8(%eax),%eax
  80ed69:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ed6c:	b8 10 00 00 00       	mov    $0x10,%eax
  80ed71:	e9 6e ff ff ff       	jmp    80ece4 <vprintfmt+0x428>
		return va_arg(*ap, unsigned int);
  80ed76:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed79:	8b 00                	mov    (%eax),%eax
  80ed7b:	ba 00 00 00 00       	mov    $0x0,%edx
  80ed80:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80ed83:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80ed86:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed89:	8d 40 04             	lea    0x4(%eax),%eax
  80ed8c:	89 45 14             	mov    %eax,0x14(%ebp)
			base = 16;
  80ed8f:	b8 10 00 00 00       	mov    $0x10,%eax
  80ed94:	e9 4b ff ff ff       	jmp    80ece4 <vprintfmt+0x428>
					if ((p = va_arg(ap, char *)) == NULL){
  80ed99:	8b 45 14             	mov    0x14(%ebp),%eax
  80ed9c:	83 c0 04             	add    $0x4,%eax
  80ed9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80eda2:	8b 45 14             	mov    0x14(%ebp),%eax
  80eda5:	8b 00                	mov    (%eax),%eax
  80eda7:	85 c0                	test   %eax,%eax
  80eda9:	74 14                	je     80edbf <vprintfmt+0x503>
					}else if(*(int *)putdat > 127){
  80edab:	8b 13                	mov    (%ebx),%edx
  80edad:	83 fa 7f             	cmp    $0x7f,%edx
  80edb0:	7f 37                	jg     80ede9 <vprintfmt+0x52d>
						*(char *)p = *(int *)putdat;
  80edb2:	88 10                	mov    %dl,(%eax)
					if ((p = va_arg(ap, char *)) == NULL){
  80edb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80edb7:	89 45 14             	mov    %eax,0x14(%ebp)
  80edba:	e9 43 ff ff ff       	jmp    80ed02 <vprintfmt+0x446>
						for (; (ch = *tmp++) != '\0';){
  80edbf:	b8 0a 00 00 00       	mov    $0xa,%eax
  80edc4:	bf 59 3a 81 00       	mov    $0x813a59,%edi
							putch(ch, putdat);
  80edc9:	83 ec 08             	sub    $0x8,%esp
  80edcc:	53                   	push   %ebx
  80edcd:	50                   	push   %eax
  80edce:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80edd0:	83 c7 01             	add    $0x1,%edi
  80edd3:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80edd7:	83 c4 10             	add    $0x10,%esp
  80edda:	85 c0                	test   %eax,%eax
  80eddc:	75 eb                	jne    80edc9 <vprintfmt+0x50d>
					if ((p = va_arg(ap, char *)) == NULL){
  80edde:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ede1:	89 45 14             	mov    %eax,0x14(%ebp)
  80ede4:	e9 19 ff ff ff       	jmp    80ed02 <vprintfmt+0x446>
						*(char *)p = *(int *)putdat;
  80ede9:	88 10                	mov    %dl,(%eax)
						for (; (ch = *tmp++) != '\0';){
  80edeb:	b8 0a 00 00 00       	mov    $0xa,%eax
  80edf0:	bf 91 3a 81 00       	mov    $0x813a91,%edi
							putch(ch, putdat);
  80edf5:	83 ec 08             	sub    $0x8,%esp
  80edf8:	53                   	push   %ebx
  80edf9:	50                   	push   %eax
  80edfa:	ff d6                	call   *%esi
						for (; (ch = *tmp++) != '\0';){
  80edfc:	83 c7 01             	add    $0x1,%edi
  80edff:	0f be 47 ff          	movsbl -0x1(%edi),%eax
  80ee03:	83 c4 10             	add    $0x10,%esp
  80ee06:	85 c0                	test   %eax,%eax
  80ee08:	75 eb                	jne    80edf5 <vprintfmt+0x539>
					if ((p = va_arg(ap, char *)) == NULL){
  80ee0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ee0d:	89 45 14             	mov    %eax,0x14(%ebp)
  80ee10:	e9 ed fe ff ff       	jmp    80ed02 <vprintfmt+0x446>
			putch(ch, putdat);
  80ee15:	83 ec 08             	sub    $0x8,%esp
  80ee18:	53                   	push   %ebx
  80ee19:	6a 25                	push   $0x25
  80ee1b:	ff d6                	call   *%esi
			break;
  80ee1d:	83 c4 10             	add    $0x10,%esp
  80ee20:	e9 dd fe ff ff       	jmp    80ed02 <vprintfmt+0x446>
			putch('%', putdat);
  80ee25:	83 ec 08             	sub    $0x8,%esp
  80ee28:	53                   	push   %ebx
  80ee29:	6a 25                	push   $0x25
  80ee2b:	ff d6                	call   *%esi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80ee2d:	83 c4 10             	add    $0x10,%esp
  80ee30:	89 f8                	mov    %edi,%eax
  80ee32:	eb 03                	jmp    80ee37 <vprintfmt+0x57b>
  80ee34:	83 e8 01             	sub    $0x1,%eax
  80ee37:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  80ee3b:	75 f7                	jne    80ee34 <vprintfmt+0x578>
  80ee3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ee40:	e9 bd fe ff ff       	jmp    80ed02 <vprintfmt+0x446>
}
  80ee45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ee48:	5b                   	pop    %ebx
  80ee49:	5e                   	pop    %esi
  80ee4a:	5f                   	pop    %edi
  80ee4b:	5d                   	pop    %ebp
  80ee4c:	c3                   	ret    

0080ee4d <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80ee4d:	55                   	push   %ebp
  80ee4e:	89 e5                	mov    %esp,%ebp
  80ee50:	83 ec 18             	sub    $0x18,%esp
  80ee53:	8b 45 08             	mov    0x8(%ebp),%eax
  80ee56:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80ee59:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80ee5c:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80ee60:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80ee63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80ee6a:	85 c0                	test   %eax,%eax
  80ee6c:	74 26                	je     80ee94 <vsnprintf+0x47>
  80ee6e:	85 d2                	test   %edx,%edx
  80ee70:	7e 22                	jle    80ee94 <vsnprintf+0x47>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80ee72:	ff 75 14             	pushl  0x14(%ebp)
  80ee75:	ff 75 10             	pushl  0x10(%ebp)
  80ee78:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80ee7b:	50                   	push   %eax
  80ee7c:	68 82 e8 80 00       	push   $0x80e882
  80ee81:	e8 36 fa ff ff       	call   80e8bc <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80ee86:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80ee89:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80ee8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ee8f:	83 c4 10             	add    $0x10,%esp
}
  80ee92:	c9                   	leave  
  80ee93:	c3                   	ret    
		return -E_INVAL;
  80ee94:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ee99:	eb f7                	jmp    80ee92 <vsnprintf+0x45>

0080ee9b <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80ee9b:	55                   	push   %ebp
  80ee9c:	89 e5                	mov    %esp,%ebp
  80ee9e:	83 ec 08             	sub    $0x8,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80eea1:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80eea4:	50                   	push   %eax
  80eea5:	ff 75 10             	pushl  0x10(%ebp)
  80eea8:	ff 75 0c             	pushl  0xc(%ebp)
  80eeab:	ff 75 08             	pushl  0x8(%ebp)
  80eeae:	e8 9a ff ff ff       	call   80ee4d <vsnprintf>
	va_end(ap);

	return rc;
}
  80eeb3:	c9                   	leave  
  80eeb4:	c3                   	ret    

0080eeb5 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80eeb5:	55                   	push   %ebp
  80eeb6:	89 e5                	mov    %esp,%ebp
  80eeb8:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80eebb:	b8 00 00 00 00       	mov    $0x0,%eax
  80eec0:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80eec4:	74 05                	je     80eecb <strlen+0x16>
		n++;
  80eec6:	83 c0 01             	add    $0x1,%eax
  80eec9:	eb f5                	jmp    80eec0 <strlen+0xb>
	return n;
}
  80eecb:	5d                   	pop    %ebp
  80eecc:	c3                   	ret    

0080eecd <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80eecd:	55                   	push   %ebp
  80eece:	89 e5                	mov    %esp,%ebp
  80eed0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80eed3:	8b 45 0c             	mov    0xc(%ebp),%eax
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80eed6:	ba 00 00 00 00       	mov    $0x0,%edx
  80eedb:	39 c2                	cmp    %eax,%edx
  80eedd:	74 0d                	je     80eeec <strnlen+0x1f>
  80eedf:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
  80eee3:	74 05                	je     80eeea <strnlen+0x1d>
		n++;
  80eee5:	83 c2 01             	add    $0x1,%edx
  80eee8:	eb f1                	jmp    80eedb <strnlen+0xe>
  80eeea:	89 d0                	mov    %edx,%eax
	return n;
}
  80eeec:	5d                   	pop    %ebp
  80eeed:	c3                   	ret    

0080eeee <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80eeee:	55                   	push   %ebp
  80eeef:	89 e5                	mov    %esp,%ebp
  80eef1:	53                   	push   %ebx
  80eef2:	8b 45 08             	mov    0x8(%ebp),%eax
  80eef5:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80eef8:	ba 00 00 00 00       	mov    $0x0,%edx
  80eefd:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80ef01:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  80ef04:	83 c2 01             	add    $0x1,%edx
  80ef07:	84 c9                	test   %cl,%cl
  80ef09:	75 f2                	jne    80eefd <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  80ef0b:	5b                   	pop    %ebx
  80ef0c:	5d                   	pop    %ebp
  80ef0d:	c3                   	ret    

0080ef0e <strcat>:

char *
strcat(char *dst, const char *src)
{
  80ef0e:	55                   	push   %ebp
  80ef0f:	89 e5                	mov    %esp,%ebp
  80ef11:	53                   	push   %ebx
  80ef12:	83 ec 10             	sub    $0x10,%esp
  80ef15:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80ef18:	53                   	push   %ebx
  80ef19:	e8 97 ff ff ff       	call   80eeb5 <strlen>
  80ef1e:	83 c4 08             	add    $0x8,%esp
	strcpy(dst + len, src);
  80ef21:	ff 75 0c             	pushl  0xc(%ebp)
  80ef24:	01 d8                	add    %ebx,%eax
  80ef26:	50                   	push   %eax
  80ef27:	e8 c2 ff ff ff       	call   80eeee <strcpy>
	return dst;
}
  80ef2c:	89 d8                	mov    %ebx,%eax
  80ef2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ef31:	c9                   	leave  
  80ef32:	c3                   	ret    

0080ef33 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80ef33:	55                   	push   %ebp
  80ef34:	89 e5                	mov    %esp,%ebp
  80ef36:	56                   	push   %esi
  80ef37:	53                   	push   %ebx
  80ef38:	8b 45 08             	mov    0x8(%ebp),%eax
  80ef3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef3e:	89 c6                	mov    %eax,%esi
  80ef40:	03 75 10             	add    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80ef43:	89 c2                	mov    %eax,%edx
  80ef45:	39 f2                	cmp    %esi,%edx
  80ef47:	74 11                	je     80ef5a <strncpy+0x27>
		*dst++ = *src;
  80ef49:	83 c2 01             	add    $0x1,%edx
  80ef4c:	0f b6 19             	movzbl (%ecx),%ebx
  80ef4f:	88 5a ff             	mov    %bl,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80ef52:	80 fb 01             	cmp    $0x1,%bl
  80ef55:	83 d9 ff             	sbb    $0xffffffff,%ecx
  80ef58:	eb eb                	jmp    80ef45 <strncpy+0x12>
	}
	return ret;
}
  80ef5a:	5b                   	pop    %ebx
  80ef5b:	5e                   	pop    %esi
  80ef5c:	5d                   	pop    %ebp
  80ef5d:	c3                   	ret    

0080ef5e <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80ef5e:	55                   	push   %ebp
  80ef5f:	89 e5                	mov    %esp,%ebp
  80ef61:	56                   	push   %esi
  80ef62:	53                   	push   %ebx
  80ef63:	8b 75 08             	mov    0x8(%ebp),%esi
  80ef66:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80ef69:	8b 55 10             	mov    0x10(%ebp),%edx
  80ef6c:	89 f0                	mov    %esi,%eax
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80ef6e:	85 d2                	test   %edx,%edx
  80ef70:	74 21                	je     80ef93 <strlcpy+0x35>
  80ef72:	8d 44 16 ff          	lea    -0x1(%esi,%edx,1),%eax
  80ef76:	89 f2                	mov    %esi,%edx
		while (--size > 0 && *src != '\0')
  80ef78:	39 c2                	cmp    %eax,%edx
  80ef7a:	74 14                	je     80ef90 <strlcpy+0x32>
  80ef7c:	0f b6 19             	movzbl (%ecx),%ebx
  80ef7f:	84 db                	test   %bl,%bl
  80ef81:	74 0b                	je     80ef8e <strlcpy+0x30>
			*dst++ = *src++;
  80ef83:	83 c1 01             	add    $0x1,%ecx
  80ef86:	83 c2 01             	add    $0x1,%edx
  80ef89:	88 5a ff             	mov    %bl,-0x1(%edx)
  80ef8c:	eb ea                	jmp    80ef78 <strlcpy+0x1a>
  80ef8e:	89 d0                	mov    %edx,%eax
		*dst = '\0';
  80ef90:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
  80ef93:	29 f0                	sub    %esi,%eax
}
  80ef95:	5b                   	pop    %ebx
  80ef96:	5e                   	pop    %esi
  80ef97:	5d                   	pop    %ebp
  80ef98:	c3                   	ret    

0080ef99 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80ef99:	55                   	push   %ebp
  80ef9a:	89 e5                	mov    %esp,%ebp
  80ef9c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ef9f:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80efa2:	0f b6 01             	movzbl (%ecx),%eax
  80efa5:	84 c0                	test   %al,%al
  80efa7:	74 0c                	je     80efb5 <strcmp+0x1c>
  80efa9:	3a 02                	cmp    (%edx),%al
  80efab:	75 08                	jne    80efb5 <strcmp+0x1c>
		p++, q++;
  80efad:	83 c1 01             	add    $0x1,%ecx
  80efb0:	83 c2 01             	add    $0x1,%edx
  80efb3:	eb ed                	jmp    80efa2 <strcmp+0x9>
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80efb5:	0f b6 c0             	movzbl %al,%eax
  80efb8:	0f b6 12             	movzbl (%edx),%edx
  80efbb:	29 d0                	sub    %edx,%eax
}
  80efbd:	5d                   	pop    %ebp
  80efbe:	c3                   	ret    

0080efbf <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80efbf:	55                   	push   %ebp
  80efc0:	89 e5                	mov    %esp,%ebp
  80efc2:	53                   	push   %ebx
  80efc3:	8b 45 08             	mov    0x8(%ebp),%eax
  80efc6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80efc9:	89 c3                	mov    %eax,%ebx
  80efcb:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80efce:	eb 06                	jmp    80efd6 <strncmp+0x17>
		n--, p++, q++;
  80efd0:	83 c0 01             	add    $0x1,%eax
  80efd3:	83 c2 01             	add    $0x1,%edx
	while (n > 0 && *p && *p == *q)
  80efd6:	39 d8                	cmp    %ebx,%eax
  80efd8:	74 16                	je     80eff0 <strncmp+0x31>
  80efda:	0f b6 08             	movzbl (%eax),%ecx
  80efdd:	84 c9                	test   %cl,%cl
  80efdf:	74 04                	je     80efe5 <strncmp+0x26>
  80efe1:	3a 0a                	cmp    (%edx),%cl
  80efe3:	74 eb                	je     80efd0 <strncmp+0x11>
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80efe5:	0f b6 00             	movzbl (%eax),%eax
  80efe8:	0f b6 12             	movzbl (%edx),%edx
  80efeb:	29 d0                	sub    %edx,%eax
}
  80efed:	5b                   	pop    %ebx
  80efee:	5d                   	pop    %ebp
  80efef:	c3                   	ret    
		return 0;
  80eff0:	b8 00 00 00 00       	mov    $0x0,%eax
  80eff5:	eb f6                	jmp    80efed <strncmp+0x2e>

0080eff7 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80eff7:	55                   	push   %ebp
  80eff8:	89 e5                	mov    %esp,%ebp
  80effa:	8b 45 08             	mov    0x8(%ebp),%eax
  80effd:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f001:	0f b6 10             	movzbl (%eax),%edx
  80f004:	84 d2                	test   %dl,%dl
  80f006:	74 09                	je     80f011 <strchr+0x1a>
		if (*s == c)
  80f008:	38 ca                	cmp    %cl,%dl
  80f00a:	74 0a                	je     80f016 <strchr+0x1f>
	for (; *s; s++)
  80f00c:	83 c0 01             	add    $0x1,%eax
  80f00f:	eb f0                	jmp    80f001 <strchr+0xa>
			return (char *) s;
	return 0;
  80f011:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f016:	5d                   	pop    %ebp
  80f017:	c3                   	ret    

0080f018 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f018:	55                   	push   %ebp
  80f019:	89 e5                	mov    %esp,%ebp
  80f01b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f01e:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f022:	0f b6 10             	movzbl (%eax),%edx
		if (*s == c)
  80f025:	38 ca                	cmp    %cl,%dl
  80f027:	74 09                	je     80f032 <strfind+0x1a>
  80f029:	84 d2                	test   %dl,%dl
  80f02b:	74 05                	je     80f032 <strfind+0x1a>
	for (; *s; s++)
  80f02d:	83 c0 01             	add    $0x1,%eax
  80f030:	eb f0                	jmp    80f022 <strfind+0xa>
			break;
	return (char *) s;
}
  80f032:	5d                   	pop    %ebp
  80f033:	c3                   	ret    

0080f034 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f034:	55                   	push   %ebp
  80f035:	89 e5                	mov    %esp,%ebp
  80f037:	57                   	push   %edi
  80f038:	56                   	push   %esi
  80f039:	53                   	push   %ebx
  80f03a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f03d:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f040:	85 c9                	test   %ecx,%ecx
  80f042:	74 31                	je     80f075 <memset+0x41>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f044:	89 f8                	mov    %edi,%eax
  80f046:	09 c8                	or     %ecx,%eax
  80f048:	a8 03                	test   $0x3,%al
  80f04a:	75 23                	jne    80f06f <memset+0x3b>
		c &= 0xFF;
  80f04c:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f050:	89 d3                	mov    %edx,%ebx
  80f052:	c1 e3 08             	shl    $0x8,%ebx
  80f055:	89 d0                	mov    %edx,%eax
  80f057:	c1 e0 18             	shl    $0x18,%eax
  80f05a:	89 d6                	mov    %edx,%esi
  80f05c:	c1 e6 10             	shl    $0x10,%esi
  80f05f:	09 f0                	or     %esi,%eax
  80f061:	09 c2                	or     %eax,%edx
  80f063:	09 da                	or     %ebx,%edx
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f065:	c1 e9 02             	shr    $0x2,%ecx
		asm volatile("cld; rep stosl\n"
  80f068:	89 d0                	mov    %edx,%eax
  80f06a:	fc                   	cld    
  80f06b:	f3 ab                	rep stos %eax,%es:(%edi)
  80f06d:	eb 06                	jmp    80f075 <memset+0x41>
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f06f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f072:	fc                   	cld    
  80f073:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f075:	89 f8                	mov    %edi,%eax
  80f077:	5b                   	pop    %ebx
  80f078:	5e                   	pop    %esi
  80f079:	5f                   	pop    %edi
  80f07a:	5d                   	pop    %ebp
  80f07b:	c3                   	ret    

0080f07c <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f07c:	55                   	push   %ebp
  80f07d:	89 e5                	mov    %esp,%ebp
  80f07f:	57                   	push   %edi
  80f080:	56                   	push   %esi
  80f081:	8b 45 08             	mov    0x8(%ebp),%eax
  80f084:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f087:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f08a:	39 c6                	cmp    %eax,%esi
  80f08c:	73 32                	jae    80f0c0 <memmove+0x44>
  80f08e:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f091:	39 c2                	cmp    %eax,%edx
  80f093:	76 2b                	jbe    80f0c0 <memmove+0x44>
		s += n;
		d += n;
  80f095:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f098:	89 fe                	mov    %edi,%esi
  80f09a:	09 ce                	or     %ecx,%esi
  80f09c:	09 d6                	or     %edx,%esi
  80f09e:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f0a4:	75 0e                	jne    80f0b4 <memmove+0x38>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f0a6:	83 ef 04             	sub    $0x4,%edi
  80f0a9:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f0ac:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("std; rep movsl\n"
  80f0af:	fd                   	std    
  80f0b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f0b2:	eb 09                	jmp    80f0bd <memmove+0x41>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f0b4:	83 ef 01             	sub    $0x1,%edi
  80f0b7:	8d 72 ff             	lea    -0x1(%edx),%esi
			asm volatile("std; rep movsb\n"
  80f0ba:	fd                   	std    
  80f0bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f0bd:	fc                   	cld    
  80f0be:	eb 1a                	jmp    80f0da <memmove+0x5e>
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f0c0:	89 c2                	mov    %eax,%edx
  80f0c2:	09 ca                	or     %ecx,%edx
  80f0c4:	09 f2                	or     %esi,%edx
  80f0c6:	f6 c2 03             	test   $0x3,%dl
  80f0c9:	75 0a                	jne    80f0d5 <memmove+0x59>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f0cb:	c1 e9 02             	shr    $0x2,%ecx
			asm volatile("cld; rep movsl\n"
  80f0ce:	89 c7                	mov    %eax,%edi
  80f0d0:	fc                   	cld    
  80f0d1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f0d3:	eb 05                	jmp    80f0da <memmove+0x5e>
		else
			asm volatile("cld; rep movsb\n"
  80f0d5:	89 c7                	mov    %eax,%edi
  80f0d7:	fc                   	cld    
  80f0d8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f0da:	5e                   	pop    %esi
  80f0db:	5f                   	pop    %edi
  80f0dc:	5d                   	pop    %ebp
  80f0dd:	c3                   	ret    

0080f0de <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f0de:	55                   	push   %ebp
  80f0df:	89 e5                	mov    %esp,%ebp
  80f0e1:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f0e4:	ff 75 10             	pushl  0x10(%ebp)
  80f0e7:	ff 75 0c             	pushl  0xc(%ebp)
  80f0ea:	ff 75 08             	pushl  0x8(%ebp)
  80f0ed:	e8 8a ff ff ff       	call   80f07c <memmove>
}
  80f0f2:	c9                   	leave  
  80f0f3:	c3                   	ret    

0080f0f4 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f0f4:	55                   	push   %ebp
  80f0f5:	89 e5                	mov    %esp,%ebp
  80f0f7:	56                   	push   %esi
  80f0f8:	53                   	push   %ebx
  80f0f9:	8b 45 08             	mov    0x8(%ebp),%eax
  80f0fc:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f0ff:	89 c6                	mov    %eax,%esi
  80f101:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f104:	39 f0                	cmp    %esi,%eax
  80f106:	74 1c                	je     80f124 <memcmp+0x30>
		if (*s1 != *s2)
  80f108:	0f b6 08             	movzbl (%eax),%ecx
  80f10b:	0f b6 1a             	movzbl (%edx),%ebx
  80f10e:	38 d9                	cmp    %bl,%cl
  80f110:	75 08                	jne    80f11a <memcmp+0x26>
			return (int) *s1 - (int) *s2;
		s1++, s2++;
  80f112:	83 c0 01             	add    $0x1,%eax
  80f115:	83 c2 01             	add    $0x1,%edx
  80f118:	eb ea                	jmp    80f104 <memcmp+0x10>
			return (int) *s1 - (int) *s2;
  80f11a:	0f b6 c1             	movzbl %cl,%eax
  80f11d:	0f b6 db             	movzbl %bl,%ebx
  80f120:	29 d8                	sub    %ebx,%eax
  80f122:	eb 05                	jmp    80f129 <memcmp+0x35>
	}

	return 0;
  80f124:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f129:	5b                   	pop    %ebx
  80f12a:	5e                   	pop    %esi
  80f12b:	5d                   	pop    %ebp
  80f12c:	c3                   	ret    

0080f12d <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80f12d:	55                   	push   %ebp
  80f12e:	89 e5                	mov    %esp,%ebp
  80f130:	8b 45 08             	mov    0x8(%ebp),%eax
  80f133:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80f136:	89 c2                	mov    %eax,%edx
  80f138:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80f13b:	39 d0                	cmp    %edx,%eax
  80f13d:	73 09                	jae    80f148 <memfind+0x1b>
		if (*(const unsigned char *) s == (unsigned char) c)
  80f13f:	38 08                	cmp    %cl,(%eax)
  80f141:	74 05                	je     80f148 <memfind+0x1b>
	for (; s < ends; s++)
  80f143:	83 c0 01             	add    $0x1,%eax
  80f146:	eb f3                	jmp    80f13b <memfind+0xe>
			break;
	return (void *) s;
}
  80f148:	5d                   	pop    %ebp
  80f149:	c3                   	ret    

0080f14a <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80f14a:	55                   	push   %ebp
  80f14b:	89 e5                	mov    %esp,%ebp
  80f14d:	57                   	push   %edi
  80f14e:	56                   	push   %esi
  80f14f:	53                   	push   %ebx
  80f150:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f153:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80f156:	eb 03                	jmp    80f15b <strtol+0x11>
		s++;
  80f158:	83 c1 01             	add    $0x1,%ecx
	while (*s == ' ' || *s == '\t')
  80f15b:	0f b6 01             	movzbl (%ecx),%eax
  80f15e:	3c 20                	cmp    $0x20,%al
  80f160:	74 f6                	je     80f158 <strtol+0xe>
  80f162:	3c 09                	cmp    $0x9,%al
  80f164:	74 f2                	je     80f158 <strtol+0xe>

	// plus/minus sign
	if (*s == '+')
  80f166:	3c 2b                	cmp    $0x2b,%al
  80f168:	74 2a                	je     80f194 <strtol+0x4a>
	int neg = 0;
  80f16a:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;
	else if (*s == '-')
  80f16f:	3c 2d                	cmp    $0x2d,%al
  80f171:	74 2b                	je     80f19e <strtol+0x54>
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f173:	f7 c3 ef ff ff ff    	test   $0xffffffef,%ebx
  80f179:	75 0f                	jne    80f18a <strtol+0x40>
  80f17b:	80 39 30             	cmpb   $0x30,(%ecx)
  80f17e:	74 28                	je     80f1a8 <strtol+0x5e>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80f180:	85 db                	test   %ebx,%ebx
  80f182:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f187:	0f 44 d8             	cmove  %eax,%ebx
  80f18a:	b8 00 00 00 00       	mov    $0x0,%eax
  80f18f:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f192:	eb 50                	jmp    80f1e4 <strtol+0x9a>
		s++;
  80f194:	83 c1 01             	add    $0x1,%ecx
	int neg = 0;
  80f197:	bf 00 00 00 00       	mov    $0x0,%edi
  80f19c:	eb d5                	jmp    80f173 <strtol+0x29>
		s++, neg = 1;
  80f19e:	83 c1 01             	add    $0x1,%ecx
  80f1a1:	bf 01 00 00 00       	mov    $0x1,%edi
  80f1a6:	eb cb                	jmp    80f173 <strtol+0x29>
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80f1a8:	80 79 01 78          	cmpb   $0x78,0x1(%ecx)
  80f1ac:	74 0e                	je     80f1bc <strtol+0x72>
	else if (base == 0 && s[0] == '0')
  80f1ae:	85 db                	test   %ebx,%ebx
  80f1b0:	75 d8                	jne    80f18a <strtol+0x40>
		s++, base = 8;
  80f1b2:	83 c1 01             	add    $0x1,%ecx
  80f1b5:	bb 08 00 00 00       	mov    $0x8,%ebx
  80f1ba:	eb ce                	jmp    80f18a <strtol+0x40>
		s += 2, base = 16;
  80f1bc:	83 c1 02             	add    $0x2,%ecx
  80f1bf:	bb 10 00 00 00       	mov    $0x10,%ebx
  80f1c4:	eb c4                	jmp    80f18a <strtol+0x40>
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
  80f1c6:	8d 72 9f             	lea    -0x61(%edx),%esi
  80f1c9:	89 f3                	mov    %esi,%ebx
  80f1cb:	80 fb 19             	cmp    $0x19,%bl
  80f1ce:	77 29                	ja     80f1f9 <strtol+0xaf>
			dig = *s - 'a' + 10;
  80f1d0:	0f be d2             	movsbl %dl,%edx
  80f1d3:	83 ea 57             	sub    $0x57,%edx
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  80f1d6:	3b 55 10             	cmp    0x10(%ebp),%edx
  80f1d9:	7d 30                	jge    80f20b <strtol+0xc1>
			break;
		s++, val = (val * base) + dig;
  80f1db:	83 c1 01             	add    $0x1,%ecx
  80f1de:	0f af 45 10          	imul   0x10(%ebp),%eax
  80f1e2:	01 d0                	add    %edx,%eax
		if (*s >= '0' && *s <= '9')
  80f1e4:	0f b6 11             	movzbl (%ecx),%edx
  80f1e7:	8d 72 d0             	lea    -0x30(%edx),%esi
  80f1ea:	89 f3                	mov    %esi,%ebx
  80f1ec:	80 fb 09             	cmp    $0x9,%bl
  80f1ef:	77 d5                	ja     80f1c6 <strtol+0x7c>
			dig = *s - '0';
  80f1f1:	0f be d2             	movsbl %dl,%edx
  80f1f4:	83 ea 30             	sub    $0x30,%edx
  80f1f7:	eb dd                	jmp    80f1d6 <strtol+0x8c>
		else if (*s >= 'A' && *s <= 'Z')
  80f1f9:	8d 72 bf             	lea    -0x41(%edx),%esi
  80f1fc:	89 f3                	mov    %esi,%ebx
  80f1fe:	80 fb 19             	cmp    $0x19,%bl
  80f201:	77 08                	ja     80f20b <strtol+0xc1>
			dig = *s - 'A' + 10;
  80f203:	0f be d2             	movsbl %dl,%edx
  80f206:	83 ea 37             	sub    $0x37,%edx
  80f209:	eb cb                	jmp    80f1d6 <strtol+0x8c>
		// we don't properly detect overflow!
	}

	if (endptr)
  80f20b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f20f:	74 05                	je     80f216 <strtol+0xcc>
		*endptr = (char *) s;
  80f211:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f214:	89 0e                	mov    %ecx,(%esi)
	return (neg ? -val : val);
  80f216:	89 c2                	mov    %eax,%edx
  80f218:	f7 da                	neg    %edx
  80f21a:	85 ff                	test   %edi,%edi
  80f21c:	0f 45 c2             	cmovne %edx,%eax
}
  80f21f:	5b                   	pop    %ebx
  80f220:	5e                   	pop    %esi
  80f221:	5f                   	pop    %edi
  80f222:	5d                   	pop    %ebp
  80f223:	c3                   	ret    

0080f224 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80f224:	55                   	push   %ebp
  80f225:	89 e5                	mov    %esp,%ebp
  80f227:	57                   	push   %edi
  80f228:	56                   	push   %esi
  80f229:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f22a:	b8 00 00 00 00       	mov    $0x0,%eax
  80f22f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f232:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f235:	89 c3                	mov    %eax,%ebx
  80f237:	89 c7                	mov    %eax,%edi
  80f239:	89 c6                	mov    %eax,%esi
  80f23b:	cd 30                	int    $0x30
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80f23d:	5b                   	pop    %ebx
  80f23e:	5e                   	pop    %esi
  80f23f:	5f                   	pop    %edi
  80f240:	5d                   	pop    %ebp
  80f241:	c3                   	ret    

0080f242 <sys_cgetc>:

int
sys_cgetc(void)
{
  80f242:	55                   	push   %ebp
  80f243:	89 e5                	mov    %esp,%ebp
  80f245:	57                   	push   %edi
  80f246:	56                   	push   %esi
  80f247:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f248:	ba 00 00 00 00       	mov    $0x0,%edx
  80f24d:	b8 01 00 00 00       	mov    $0x1,%eax
  80f252:	89 d1                	mov    %edx,%ecx
  80f254:	89 d3                	mov    %edx,%ebx
  80f256:	89 d7                	mov    %edx,%edi
  80f258:	89 d6                	mov    %edx,%esi
  80f25a:	cd 30                	int    $0x30
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80f25c:	5b                   	pop    %ebx
  80f25d:	5e                   	pop    %esi
  80f25e:	5f                   	pop    %edi
  80f25f:	5d                   	pop    %ebp
  80f260:	c3                   	ret    

0080f261 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80f261:	55                   	push   %ebp
  80f262:	89 e5                	mov    %esp,%ebp
  80f264:	57                   	push   %edi
  80f265:	56                   	push   %esi
  80f266:	53                   	push   %ebx
  80f267:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f26a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f26f:	8b 55 08             	mov    0x8(%ebp),%edx
  80f272:	b8 03 00 00 00       	mov    $0x3,%eax
  80f277:	89 cb                	mov    %ecx,%ebx
  80f279:	89 cf                	mov    %ecx,%edi
  80f27b:	89 ce                	mov    %ecx,%esi
  80f27d:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f27f:	85 c0                	test   %eax,%eax
  80f281:	7f 08                	jg     80f28b <sys_env_destroy+0x2a>
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80f283:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f286:	5b                   	pop    %ebx
  80f287:	5e                   	pop    %esi
  80f288:	5f                   	pop    %edi
  80f289:	5d                   	pop    %ebp
  80f28a:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f28b:	83 ec 0c             	sub    $0xc,%esp
  80f28e:	50                   	push   %eax
  80f28f:	6a 03                	push   $0x3
  80f291:	68 a8 3c 81 00       	push   $0x813ca8
  80f296:	6a 43                	push   $0x43
  80f298:	68 c5 3c 81 00       	push   $0x813cc5
  80f29d:	e8 f7 f3 ff ff       	call   80e699 <_panic>

0080f2a2 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80f2a2:	55                   	push   %ebp
  80f2a3:	89 e5                	mov    %esp,%ebp
  80f2a5:	57                   	push   %edi
  80f2a6:	56                   	push   %esi
  80f2a7:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f2a8:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2ad:	b8 02 00 00 00       	mov    $0x2,%eax
  80f2b2:	89 d1                	mov    %edx,%ecx
  80f2b4:	89 d3                	mov    %edx,%ebx
  80f2b6:	89 d7                	mov    %edx,%edi
  80f2b8:	89 d6                	mov    %edx,%esi
  80f2ba:	cd 30                	int    $0x30
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80f2bc:	5b                   	pop    %ebx
  80f2bd:	5e                   	pop    %esi
  80f2be:	5f                   	pop    %edi
  80f2bf:	5d                   	pop    %ebp
  80f2c0:	c3                   	ret    

0080f2c1 <sys_yield>:

void
sys_yield(void)
{
  80f2c1:	55                   	push   %ebp
  80f2c2:	89 e5                	mov    %esp,%ebp
  80f2c4:	57                   	push   %edi
  80f2c5:	56                   	push   %esi
  80f2c6:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f2c7:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2cc:	b8 0b 00 00 00       	mov    $0xb,%eax
  80f2d1:	89 d1                	mov    %edx,%ecx
  80f2d3:	89 d3                	mov    %edx,%ebx
  80f2d5:	89 d7                	mov    %edx,%edi
  80f2d7:	89 d6                	mov    %edx,%esi
  80f2d9:	cd 30                	int    $0x30
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80f2db:	5b                   	pop    %ebx
  80f2dc:	5e                   	pop    %esi
  80f2dd:	5f                   	pop    %edi
  80f2de:	5d                   	pop    %ebp
  80f2df:	c3                   	ret    

0080f2e0 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80f2e0:	55                   	push   %ebp
  80f2e1:	89 e5                	mov    %esp,%ebp
  80f2e3:	57                   	push   %edi
  80f2e4:	56                   	push   %esi
  80f2e5:	53                   	push   %ebx
  80f2e6:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f2e9:	be 00 00 00 00       	mov    $0x0,%esi
  80f2ee:	8b 55 08             	mov    0x8(%ebp),%edx
  80f2f1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f2f4:	b8 04 00 00 00       	mov    $0x4,%eax
  80f2f9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f2fc:	89 f7                	mov    %esi,%edi
  80f2fe:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f300:	85 c0                	test   %eax,%eax
  80f302:	7f 08                	jg     80f30c <sys_page_alloc+0x2c>
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80f304:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f307:	5b                   	pop    %ebx
  80f308:	5e                   	pop    %esi
  80f309:	5f                   	pop    %edi
  80f30a:	5d                   	pop    %ebp
  80f30b:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f30c:	83 ec 0c             	sub    $0xc,%esp
  80f30f:	50                   	push   %eax
  80f310:	6a 04                	push   $0x4
  80f312:	68 a8 3c 81 00       	push   $0x813ca8
  80f317:	6a 43                	push   $0x43
  80f319:	68 c5 3c 81 00       	push   $0x813cc5
  80f31e:	e8 76 f3 ff ff       	call   80e699 <_panic>

0080f323 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80f323:	55                   	push   %ebp
  80f324:	89 e5                	mov    %esp,%ebp
  80f326:	57                   	push   %edi
  80f327:	56                   	push   %esi
  80f328:	53                   	push   %ebx
  80f329:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f32c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f32f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f332:	b8 05 00 00 00       	mov    $0x5,%eax
  80f337:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f33a:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f33d:	8b 75 18             	mov    0x18(%ebp),%esi
  80f340:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f342:	85 c0                	test   %eax,%eax
  80f344:	7f 08                	jg     80f34e <sys_page_map+0x2b>
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80f346:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f349:	5b                   	pop    %ebx
  80f34a:	5e                   	pop    %esi
  80f34b:	5f                   	pop    %edi
  80f34c:	5d                   	pop    %ebp
  80f34d:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f34e:	83 ec 0c             	sub    $0xc,%esp
  80f351:	50                   	push   %eax
  80f352:	6a 05                	push   $0x5
  80f354:	68 a8 3c 81 00       	push   $0x813ca8
  80f359:	6a 43                	push   $0x43
  80f35b:	68 c5 3c 81 00       	push   $0x813cc5
  80f360:	e8 34 f3 ff ff       	call   80e699 <_panic>

0080f365 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80f365:	55                   	push   %ebp
  80f366:	89 e5                	mov    %esp,%ebp
  80f368:	57                   	push   %edi
  80f369:	56                   	push   %esi
  80f36a:	53                   	push   %ebx
  80f36b:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f36e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f373:	8b 55 08             	mov    0x8(%ebp),%edx
  80f376:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f379:	b8 06 00 00 00       	mov    $0x6,%eax
  80f37e:	89 df                	mov    %ebx,%edi
  80f380:	89 de                	mov    %ebx,%esi
  80f382:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f384:	85 c0                	test   %eax,%eax
  80f386:	7f 08                	jg     80f390 <sys_page_unmap+0x2b>
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f388:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f38b:	5b                   	pop    %ebx
  80f38c:	5e                   	pop    %esi
  80f38d:	5f                   	pop    %edi
  80f38e:	5d                   	pop    %ebp
  80f38f:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f390:	83 ec 0c             	sub    $0xc,%esp
  80f393:	50                   	push   %eax
  80f394:	6a 06                	push   $0x6
  80f396:	68 a8 3c 81 00       	push   $0x813ca8
  80f39b:	6a 43                	push   $0x43
  80f39d:	68 c5 3c 81 00       	push   $0x813cc5
  80f3a2:	e8 f2 f2 ff ff       	call   80e699 <_panic>

0080f3a7 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80f3a7:	55                   	push   %ebp
  80f3a8:	89 e5                	mov    %esp,%ebp
  80f3aa:	57                   	push   %edi
  80f3ab:	56                   	push   %esi
  80f3ac:	53                   	push   %ebx
  80f3ad:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3b0:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f3b5:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3b8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3bb:	b8 08 00 00 00       	mov    $0x8,%eax
  80f3c0:	89 df                	mov    %ebx,%edi
  80f3c2:	89 de                	mov    %ebx,%esi
  80f3c4:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f3c6:	85 c0                	test   %eax,%eax
  80f3c8:	7f 08                	jg     80f3d2 <sys_env_set_status+0x2b>
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80f3ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f3cd:	5b                   	pop    %ebx
  80f3ce:	5e                   	pop    %esi
  80f3cf:	5f                   	pop    %edi
  80f3d0:	5d                   	pop    %ebp
  80f3d1:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f3d2:	83 ec 0c             	sub    $0xc,%esp
  80f3d5:	50                   	push   %eax
  80f3d6:	6a 08                	push   $0x8
  80f3d8:	68 a8 3c 81 00       	push   $0x813ca8
  80f3dd:	6a 43                	push   $0x43
  80f3df:	68 c5 3c 81 00       	push   $0x813cc5
  80f3e4:	e8 b0 f2 ff ff       	call   80e699 <_panic>

0080f3e9 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80f3e9:	55                   	push   %ebp
  80f3ea:	89 e5                	mov    %esp,%ebp
  80f3ec:	57                   	push   %edi
  80f3ed:	56                   	push   %esi
  80f3ee:	53                   	push   %ebx
  80f3ef:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f3f2:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f3f7:	8b 55 08             	mov    0x8(%ebp),%edx
  80f3fa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f3fd:	b8 09 00 00 00       	mov    $0x9,%eax
  80f402:	89 df                	mov    %ebx,%edi
  80f404:	89 de                	mov    %ebx,%esi
  80f406:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f408:	85 c0                	test   %eax,%eax
  80f40a:	7f 08                	jg     80f414 <sys_env_set_trapframe+0x2b>
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80f40c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f40f:	5b                   	pop    %ebx
  80f410:	5e                   	pop    %esi
  80f411:	5f                   	pop    %edi
  80f412:	5d                   	pop    %ebp
  80f413:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f414:	83 ec 0c             	sub    $0xc,%esp
  80f417:	50                   	push   %eax
  80f418:	6a 09                	push   $0x9
  80f41a:	68 a8 3c 81 00       	push   $0x813ca8
  80f41f:	6a 43                	push   $0x43
  80f421:	68 c5 3c 81 00       	push   $0x813cc5
  80f426:	e8 6e f2 ff ff       	call   80e699 <_panic>

0080f42b <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80f42b:	55                   	push   %ebp
  80f42c:	89 e5                	mov    %esp,%ebp
  80f42e:	57                   	push   %edi
  80f42f:	56                   	push   %esi
  80f430:	53                   	push   %ebx
  80f431:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f434:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f439:	8b 55 08             	mov    0x8(%ebp),%edx
  80f43c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f43f:	b8 0a 00 00 00       	mov    $0xa,%eax
  80f444:	89 df                	mov    %ebx,%edi
  80f446:	89 de                	mov    %ebx,%esi
  80f448:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f44a:	85 c0                	test   %eax,%eax
  80f44c:	7f 08                	jg     80f456 <sys_env_set_pgfault_upcall+0x2b>
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80f44e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f451:	5b                   	pop    %ebx
  80f452:	5e                   	pop    %esi
  80f453:	5f                   	pop    %edi
  80f454:	5d                   	pop    %ebp
  80f455:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f456:	83 ec 0c             	sub    $0xc,%esp
  80f459:	50                   	push   %eax
  80f45a:	6a 0a                	push   $0xa
  80f45c:	68 a8 3c 81 00       	push   $0x813ca8
  80f461:	6a 43                	push   $0x43
  80f463:	68 c5 3c 81 00       	push   $0x813cc5
  80f468:	e8 2c f2 ff ff       	call   80e699 <_panic>

0080f46d <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80f46d:	55                   	push   %ebp
  80f46e:	89 e5                	mov    %esp,%ebp
  80f470:	57                   	push   %edi
  80f471:	56                   	push   %esi
  80f472:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f473:	8b 55 08             	mov    0x8(%ebp),%edx
  80f476:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f479:	b8 0c 00 00 00       	mov    $0xc,%eax
  80f47e:	be 00 00 00 00       	mov    $0x0,%esi
  80f483:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f486:	8b 7d 14             	mov    0x14(%ebp),%edi
  80f489:	cd 30                	int    $0x30
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80f48b:	5b                   	pop    %ebx
  80f48c:	5e                   	pop    %esi
  80f48d:	5f                   	pop    %edi
  80f48e:	5d                   	pop    %ebp
  80f48f:	c3                   	ret    

0080f490 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80f490:	55                   	push   %ebp
  80f491:	89 e5                	mov    %esp,%ebp
  80f493:	57                   	push   %edi
  80f494:	56                   	push   %esi
  80f495:	53                   	push   %ebx
  80f496:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f499:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f49e:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4a1:	b8 0d 00 00 00       	mov    $0xd,%eax
  80f4a6:	89 cb                	mov    %ecx,%ebx
  80f4a8:	89 cf                	mov    %ecx,%edi
  80f4aa:	89 ce                	mov    %ecx,%esi
  80f4ac:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f4ae:	85 c0                	test   %eax,%eax
  80f4b0:	7f 08                	jg     80f4ba <sys_ipc_recv+0x2a>
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80f4b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f4b5:	5b                   	pop    %ebx
  80f4b6:	5e                   	pop    %esi
  80f4b7:	5f                   	pop    %edi
  80f4b8:	5d                   	pop    %ebp
  80f4b9:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f4ba:	83 ec 0c             	sub    $0xc,%esp
  80f4bd:	50                   	push   %eax
  80f4be:	6a 0d                	push   $0xd
  80f4c0:	68 a8 3c 81 00       	push   $0x813ca8
  80f4c5:	6a 43                	push   $0x43
  80f4c7:	68 c5 3c 81 00       	push   $0x813cc5
  80f4cc:	e8 c8 f1 ff ff       	call   80e699 <_panic>

0080f4d1 <sys_map_kernel_page>:

int
sys_map_kernel_page(void* kpage, void* va)
{
  80f4d1:	55                   	push   %ebp
  80f4d2:	89 e5                	mov    %esp,%ebp
  80f4d4:	57                   	push   %edi
  80f4d5:	56                   	push   %esi
  80f4d6:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f4d7:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f4dc:	8b 55 08             	mov    0x8(%ebp),%edx
  80f4df:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f4e2:	b8 0e 00 00 00       	mov    $0xe,%eax
  80f4e7:	89 df                	mov    %ebx,%edi
  80f4e9:	89 de                	mov    %ebx,%esi
  80f4eb:	cd 30                	int    $0x30
	return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}
  80f4ed:	5b                   	pop    %ebx
  80f4ee:	5e                   	pop    %esi
  80f4ef:	5f                   	pop    %edi
  80f4f0:	5d                   	pop    %ebp
  80f4f1:	c3                   	ret    

0080f4f2 <sys_sbrk>:

int
sys_sbrk(uint32_t inc)
{
  80f4f2:	55                   	push   %ebp
  80f4f3:	89 e5                	mov    %esp,%ebp
  80f4f5:	57                   	push   %edi
  80f4f6:	56                   	push   %esi
  80f4f7:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f4f8:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f4fd:	8b 55 08             	mov    0x8(%ebp),%edx
  80f500:	b8 0f 00 00 00       	mov    $0xf,%eax
  80f505:	89 cb                	mov    %ecx,%ebx
  80f507:	89 cf                	mov    %ecx,%edi
  80f509:	89 ce                	mov    %ecx,%esi
  80f50b:	cd 30                	int    $0x30
	return syscall(SYS_sbrk, 0, (uint32_t)inc, (uint32_t)0, 0, 0, 0);
}
  80f50d:	5b                   	pop    %ebx
  80f50e:	5e                   	pop    %esi
  80f50f:	5f                   	pop    %edi
  80f510:	5d                   	pop    %ebp
  80f511:	c3                   	ret    

0080f512 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80f512:	55                   	push   %ebp
  80f513:	89 e5                	mov    %esp,%ebp
  80f515:	57                   	push   %edi
  80f516:	56                   	push   %esi
  80f517:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f518:	ba 00 00 00 00       	mov    $0x0,%edx
  80f51d:	b8 10 00 00 00       	mov    $0x10,%eax
  80f522:	89 d1                	mov    %edx,%ecx
  80f524:	89 d3                	mov    %edx,%ebx
  80f526:	89 d7                	mov    %edx,%edi
  80f528:	89 d6                	mov    %edx,%esi
  80f52a:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80f52c:	5b                   	pop    %ebx
  80f52d:	5e                   	pop    %esi
  80f52e:	5f                   	pop    %edi
  80f52f:	5d                   	pop    %ebp
  80f530:	c3                   	ret    

0080f531 <sys_net_send>:

int
sys_net_send(const void *buf, uint32_t len)
{
  80f531:	55                   	push   %ebp
  80f532:	89 e5                	mov    %esp,%ebp
  80f534:	57                   	push   %edi
  80f535:	56                   	push   %esi
  80f536:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f537:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f53c:	8b 55 08             	mov    0x8(%ebp),%edx
  80f53f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f542:	b8 11 00 00 00       	mov    $0x11,%eax
  80f547:	89 df                	mov    %ebx,%edi
  80f549:	89 de                	mov    %ebx,%esi
  80f54b:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_send, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f54d:	5b                   	pop    %ebx
  80f54e:	5e                   	pop    %esi
  80f54f:	5f                   	pop    %edi
  80f550:	5d                   	pop    %ebp
  80f551:	c3                   	ret    

0080f552 <sys_net_recv>:

int
sys_net_recv(void *buf, uint32_t len)
{
  80f552:	55                   	push   %ebp
  80f553:	89 e5                	mov    %esp,%ebp
  80f555:	57                   	push   %edi
  80f556:	56                   	push   %esi
  80f557:	53                   	push   %ebx
	asm volatile("int %1\n"
  80f558:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f55d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f560:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f563:	b8 12 00 00 00       	mov    $0x12,%eax
  80f568:	89 df                	mov    %ebx,%edi
  80f56a:	89 de                	mov    %ebx,%esi
  80f56c:	cd 30                	int    $0x30
	return (unsigned int) syscall(SYS_net_recv, 0, (uint32_t) buf, len, 0, 0, 0);
}
  80f56e:	5b                   	pop    %ebx
  80f56f:	5e                   	pop    %esi
  80f570:	5f                   	pop    %edi
  80f571:	5d                   	pop    %ebp
  80f572:	c3                   	ret    

0080f573 <sys_clear_access_bit>:
int
sys_clear_access_bit(envid_t envid, void *va)
{
  80f573:	55                   	push   %ebp
  80f574:	89 e5                	mov    %esp,%ebp
  80f576:	57                   	push   %edi
  80f577:	56                   	push   %esi
  80f578:	53                   	push   %ebx
  80f579:	83 ec 0c             	sub    $0xc,%esp
	asm volatile("int %1\n"
  80f57c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f581:	8b 55 08             	mov    0x8(%ebp),%edx
  80f584:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f587:	b8 13 00 00 00       	mov    $0x13,%eax
  80f58c:	89 df                	mov    %ebx,%edi
  80f58e:	89 de                	mov    %ebx,%esi
  80f590:	cd 30                	int    $0x30
	if(check && ret > 0)
  80f592:	85 c0                	test   %eax,%eax
  80f594:	7f 08                	jg     80f59e <sys_clear_access_bit+0x2b>
	return syscall(SYS_clear_access_bit, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80f596:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f599:	5b                   	pop    %ebx
  80f59a:	5e                   	pop    %esi
  80f59b:	5f                   	pop    %edi
  80f59c:	5d                   	pop    %ebp
  80f59d:	c3                   	ret    
		panic("syscall %d returned %d (> 0)", num, ret);
  80f59e:	83 ec 0c             	sub    $0xc,%esp
  80f5a1:	50                   	push   %eax
  80f5a2:	6a 13                	push   $0x13
  80f5a4:	68 a8 3c 81 00       	push   $0x813ca8
  80f5a9:	6a 43                	push   $0x43
  80f5ab:	68 c5 3c 81 00       	push   $0x813cc5
  80f5b0:	e8 e4 f0 ff ff       	call   80e699 <_panic>

0080f5b5 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  80f5b5:	55                   	push   %ebp
  80f5b6:	89 e5                	mov    %esp,%ebp
  80f5b8:	53                   	push   %ebx
  80f5b9:	83 ec 04             	sub    $0x4,%esp
	int r;
	//lab5 bug?
	if((uvpt[pn]) & PTE_SHARE){
  80f5bc:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f5c3:	f6 c5 04             	test   $0x4,%ch
  80f5c6:	75 45                	jne    80f60d <duppage+0x58>
							uvpt[pn] & PTE_SYSCALL);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_W)) == (PTE_P | PTE_U | PTE_W)){
  80f5c8:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f5cf:	83 e1 07             	and    $0x7,%ecx
  80f5d2:	83 f9 07             	cmp    $0x7,%ecx
  80f5d5:	74 6f                	je     80f646 <duppage+0x91>
						 PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U | PTE_COW)) == (PTE_P | PTE_U | PTE_COW)){
  80f5d7:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f5de:	81 e1 05 08 00 00    	and    $0x805,%ecx
  80f5e4:	81 f9 05 08 00 00    	cmp    $0x805,%ecx
  80f5ea:	0f 84 b6 00 00 00    	je     80f6a6 <duppage+0xf1>
						PTE_P | PTE_U | PTE_COW);
		if(r < 0)
			panic("sys_page_map() panic\n");
		return 0;
	}
	if(((uvpt[pn]) & (PTE_P | PTE_U)) == (PTE_P | PTE_U)){
  80f5f0:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
  80f5f7:	83 e1 05             	and    $0x5,%ecx
  80f5fa:	83 f9 05             	cmp    $0x5,%ecx
  80f5fd:	0f 84 d7 00 00 00    	je     80f6da <duppage+0x125>
	}

	// LAB 4: Your code here.
	// panic("duppage not implemented");
	return 0;
}
  80f603:	b8 00 00 00 00       	mov    $0x0,%eax
  80f608:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f60b:	c9                   	leave  
  80f60c:	c3                   	ret    
							uvpt[pn] & PTE_SYSCALL);
  80f60d:	8b 0c 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%ecx
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f614:	c1 e2 0c             	shl    $0xc,%edx
  80f617:	83 ec 0c             	sub    $0xc,%esp
  80f61a:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  80f620:	51                   	push   %ecx
  80f621:	52                   	push   %edx
  80f622:	50                   	push   %eax
  80f623:	52                   	push   %edx
  80f624:	6a 00                	push   $0x0
  80f626:	e8 f8 fc ff ff       	call   80f323 <sys_page_map>
		if(r < 0)
  80f62b:	83 c4 20             	add    $0x20,%esp
  80f62e:	85 c0                	test   %eax,%eax
  80f630:	79 d1                	jns    80f603 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f632:	83 ec 04             	sub    $0x4,%esp
  80f635:	68 d3 3c 81 00       	push   $0x813cd3
  80f63a:	6a 54                	push   $0x54
  80f63c:	68 e9 3c 81 00       	push   $0x813ce9
  80f641:	e8 53 f0 ff ff       	call   80e699 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f646:	89 d3                	mov    %edx,%ebx
  80f648:	c1 e3 0c             	shl    $0xc,%ebx
  80f64b:	83 ec 0c             	sub    $0xc,%esp
  80f64e:	68 05 08 00 00       	push   $0x805
  80f653:	53                   	push   %ebx
  80f654:	50                   	push   %eax
  80f655:	53                   	push   %ebx
  80f656:	6a 00                	push   $0x0
  80f658:	e8 c6 fc ff ff       	call   80f323 <sys_page_map>
		if(r < 0)
  80f65d:	83 c4 20             	add    $0x20,%esp
  80f660:	85 c0                	test   %eax,%eax
  80f662:	78 2e                	js     80f692 <duppage+0xdd>
		r = sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE),
  80f664:	83 ec 0c             	sub    $0xc,%esp
  80f667:	68 05 08 00 00       	push   $0x805
  80f66c:	53                   	push   %ebx
  80f66d:	6a 00                	push   $0x0
  80f66f:	53                   	push   %ebx
  80f670:	6a 00                	push   $0x0
  80f672:	e8 ac fc ff ff       	call   80f323 <sys_page_map>
		if(r < 0)
  80f677:	83 c4 20             	add    $0x20,%esp
  80f67a:	85 c0                	test   %eax,%eax
  80f67c:	79 85                	jns    80f603 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f67e:	83 ec 04             	sub    $0x4,%esp
  80f681:	68 d3 3c 81 00       	push   $0x813cd3
  80f686:	6a 5f                	push   $0x5f
  80f688:	68 e9 3c 81 00       	push   $0x813ce9
  80f68d:	e8 07 f0 ff ff       	call   80e699 <_panic>
			panic("sys_page_map() panic\n");
  80f692:	83 ec 04             	sub    $0x4,%esp
  80f695:	68 d3 3c 81 00       	push   $0x813cd3
  80f69a:	6a 5b                	push   $0x5b
  80f69c:	68 e9 3c 81 00       	push   $0x813ce9
  80f6a1:	e8 f3 ef ff ff       	call   80e699 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f6a6:	c1 e2 0c             	shl    $0xc,%edx
  80f6a9:	83 ec 0c             	sub    $0xc,%esp
  80f6ac:	68 05 08 00 00       	push   $0x805
  80f6b1:	52                   	push   %edx
  80f6b2:	50                   	push   %eax
  80f6b3:	52                   	push   %edx
  80f6b4:	6a 00                	push   $0x0
  80f6b6:	e8 68 fc ff ff       	call   80f323 <sys_page_map>
		if(r < 0)
  80f6bb:	83 c4 20             	add    $0x20,%esp
  80f6be:	85 c0                	test   %eax,%eax
  80f6c0:	0f 89 3d ff ff ff    	jns    80f603 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f6c6:	83 ec 04             	sub    $0x4,%esp
  80f6c9:	68 d3 3c 81 00       	push   $0x813cd3
  80f6ce:	6a 66                	push   $0x66
  80f6d0:	68 e9 3c 81 00       	push   $0x813ce9
  80f6d5:	e8 bf ef ff ff       	call   80e699 <_panic>
		r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), 
  80f6da:	c1 e2 0c             	shl    $0xc,%edx
  80f6dd:	83 ec 0c             	sub    $0xc,%esp
  80f6e0:	6a 05                	push   $0x5
  80f6e2:	52                   	push   %edx
  80f6e3:	50                   	push   %eax
  80f6e4:	52                   	push   %edx
  80f6e5:	6a 00                	push   $0x0
  80f6e7:	e8 37 fc ff ff       	call   80f323 <sys_page_map>
		if(r < 0)
  80f6ec:	83 c4 20             	add    $0x20,%esp
  80f6ef:	85 c0                	test   %eax,%eax
  80f6f1:	0f 89 0c ff ff ff    	jns    80f603 <duppage+0x4e>
			panic("sys_page_map() panic\n");
  80f6f7:	83 ec 04             	sub    $0x4,%esp
  80f6fa:	68 d3 3c 81 00       	push   $0x813cd3
  80f6ff:	6a 6d                	push   $0x6d
  80f701:	68 e9 3c 81 00       	push   $0x813ce9
  80f706:	e8 8e ef ff ff       	call   80e699 <_panic>

0080f70b <pgfault>:
{
  80f70b:	55                   	push   %ebp
  80f70c:	89 e5                	mov    %esp,%ebp
  80f70e:	53                   	push   %ebx
  80f70f:	83 ec 04             	sub    $0x4,%esp
  80f712:	8b 55 08             	mov    0x8(%ebp),%edx
	void *addr = (void *) utf->utf_fault_va;
  80f715:	8b 02                	mov    (%edx),%eax
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f717:	f6 42 04 02          	testb  $0x2,0x4(%edx)
  80f71b:	0f 84 99 00 00 00    	je     80f7ba <pgfault+0xaf>
  80f721:	89 c2                	mov    %eax,%edx
  80f723:	c1 ea 16             	shr    $0x16,%edx
  80f726:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80f72d:	f6 c2 01             	test   $0x1,%dl
  80f730:	0f 84 84 00 00 00    	je     80f7ba <pgfault+0xaf>
		((uvpt[PGNUM(addr)] & (PTE_P | PTE_COW)) 
  80f736:	89 c2                	mov    %eax,%edx
  80f738:	c1 ea 0c             	shr    $0xc,%edx
  80f73b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80f742:	81 e2 01 08 00 00    	and    $0x801,%edx
	if((err & FEC_WR) && (uvpd[PDX(addr)] & PTE_P) &&
  80f748:	81 fa 01 08 00 00    	cmp    $0x801,%edx
  80f74e:	75 6a                	jne    80f7ba <pgfault+0xaf>
	addr = ROUNDDOWN(addr, PGSIZE);
  80f750:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80f755:	89 c3                	mov    %eax,%ebx
	ret = sys_page_alloc(0, (void *)PFTEMP, PTE_P | PTE_U | PTE_W);
  80f757:	83 ec 04             	sub    $0x4,%esp
  80f75a:	6a 07                	push   $0x7
  80f75c:	68 00 f0 7f 00       	push   $0x7ff000
  80f761:	6a 00                	push   $0x0
  80f763:	e8 78 fb ff ff       	call   80f2e0 <sys_page_alloc>
	if(ret < 0)
  80f768:	83 c4 10             	add    $0x10,%esp
  80f76b:	85 c0                	test   %eax,%eax
  80f76d:	78 5f                	js     80f7ce <pgfault+0xc3>
	memcpy((void *)PFTEMP, (void *)addr, PGSIZE);
  80f76f:	83 ec 04             	sub    $0x4,%esp
  80f772:	68 00 10 00 00       	push   $0x1000
  80f777:	53                   	push   %ebx
  80f778:	68 00 f0 7f 00       	push   $0x7ff000
  80f77d:	e8 5c f9 ff ff       	call   80f0de <memcpy>
	ret = sys_page_map(0, PFTEMP, 0, addr,  PTE_P | PTE_U | PTE_W);
  80f782:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f789:	53                   	push   %ebx
  80f78a:	6a 00                	push   $0x0
  80f78c:	68 00 f0 7f 00       	push   $0x7ff000
  80f791:	6a 00                	push   $0x0
  80f793:	e8 8b fb ff ff       	call   80f323 <sys_page_map>
	if(ret < 0)
  80f798:	83 c4 20             	add    $0x20,%esp
  80f79b:	85 c0                	test   %eax,%eax
  80f79d:	78 43                	js     80f7e2 <pgfault+0xd7>
	ret = sys_page_unmap(0, (void *)PFTEMP);
  80f79f:	83 ec 08             	sub    $0x8,%esp
  80f7a2:	68 00 f0 7f 00       	push   $0x7ff000
  80f7a7:	6a 00                	push   $0x0
  80f7a9:	e8 b7 fb ff ff       	call   80f365 <sys_page_unmap>
	if(ret < 0)
  80f7ae:	83 c4 10             	add    $0x10,%esp
  80f7b1:	85 c0                	test   %eax,%eax
  80f7b3:	78 41                	js     80f7f6 <pgfault+0xeb>
}
  80f7b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80f7b8:	c9                   	leave  
  80f7b9:	c3                   	ret    
		panic("panic at pgfault()\n");
  80f7ba:	83 ec 04             	sub    $0x4,%esp
  80f7bd:	68 f4 3c 81 00       	push   $0x813cf4
  80f7c2:	6a 26                	push   $0x26
  80f7c4:	68 e9 3c 81 00       	push   $0x813ce9
  80f7c9:	e8 cb ee ff ff       	call   80e699 <_panic>
		panic("panic in sys_page_alloc()\n");
  80f7ce:	83 ec 04             	sub    $0x4,%esp
  80f7d1:	68 08 3d 81 00       	push   $0x813d08
  80f7d6:	6a 31                	push   $0x31
  80f7d8:	68 e9 3c 81 00       	push   $0x813ce9
  80f7dd:	e8 b7 ee ff ff       	call   80e699 <_panic>
		panic("panic in sys_page_map()\n");
  80f7e2:	83 ec 04             	sub    $0x4,%esp
  80f7e5:	68 23 3d 81 00       	push   $0x813d23
  80f7ea:	6a 36                	push   $0x36
  80f7ec:	68 e9 3c 81 00       	push   $0x813ce9
  80f7f1:	e8 a3 ee ff ff       	call   80e699 <_panic>
		panic("panic in sys_page_unmap()\n");
  80f7f6:	83 ec 04             	sub    $0x4,%esp
  80f7f9:	68 3c 3d 81 00       	push   $0x813d3c
  80f7fe:	6a 39                	push   $0x39
  80f800:	68 e9 3c 81 00       	push   $0x813ce9
  80f805:	e8 8f ee ff ff       	call   80e699 <_panic>

0080f80a <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  80f80a:	55                   	push   %ebp
  80f80b:	89 e5                	mov    %esp,%ebp
  80f80d:	57                   	push   %edi
  80f80e:	56                   	push   %esi
  80f80f:	53                   	push   %ebx
  80f810:	83 ec 18             	sub    $0x18,%esp
	int ret;
	set_pgfault_handler(pgfault);
  80f813:	68 0b f7 80 00       	push   $0x80f70b
  80f818:	e8 6a 17 00 00       	call   810f87 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  80f81d:	b8 07 00 00 00       	mov    $0x7,%eax
  80f822:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f824:	83 c4 10             	add    $0x10,%esp
  80f827:	85 c0                	test   %eax,%eax
  80f829:	78 27                	js     80f852 <fork+0x48>
  80f82b:	89 c6                	mov    %eax,%esi
  80f82d:	89 c7                	mov    %eax,%edi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f82f:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f834:	75 48                	jne    80f87e <fork+0x74>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f836:	e8 67 fa ff ff       	call   80f2a2 <sys_getenvid>
  80f83b:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f840:	c1 e0 07             	shl    $0x7,%eax
  80f843:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f848:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f84d:	e9 90 00 00 00       	jmp    80f8e2 <fork+0xd8>
		panic("the fork panic! at sys_exofork()\n");
  80f852:	83 ec 04             	sub    $0x4,%esp
  80f855:	68 58 3d 81 00       	push   $0x813d58
  80f85a:	68 8c 00 00 00       	push   $0x8c
  80f85f:	68 e9 3c 81 00       	push   $0x813ce9
  80f864:	e8 30 ee ff ff       	call   80e699 <_panic>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
			duppage(child_envid, PGNUM(i));
  80f869:	89 f8                	mov    %edi,%eax
  80f86b:	e8 45 fd ff ff       	call   80f5b5 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f870:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f876:	81 fb 00 e0 bf ee    	cmp    $0xeebfe000,%ebx
  80f87c:	74 26                	je     80f8a4 <fork+0x9a>
		if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U)))
  80f87e:	89 d8                	mov    %ebx,%eax
  80f880:	c1 e8 16             	shr    $0x16,%eax
  80f883:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f88a:	a8 01                	test   $0x1,%al
  80f88c:	74 e2                	je     80f870 <fork+0x66>
  80f88e:	89 da                	mov    %ebx,%edx
  80f890:	c1 ea 0c             	shr    $0xc,%edx
  80f893:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f89a:	83 e0 05             	and    $0x5,%eax
  80f89d:	83 f8 05             	cmp    $0x5,%eax
  80f8a0:	75 ce                	jne    80f870 <fork+0x66>
  80f8a2:	eb c5                	jmp    80f869 <fork+0x5f>
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80f8a4:	83 ec 04             	sub    $0x4,%esp
  80f8a7:	6a 07                	push   $0x7
  80f8a9:	68 00 f0 bf ee       	push   $0xeebff000
  80f8ae:	56                   	push   %esi
  80f8af:	e8 2c fa ff ff       	call   80f2e0 <sys_page_alloc>
	if(ret < 0)
  80f8b4:	83 c4 10             	add    $0x10,%esp
  80f8b7:	85 c0                	test   %eax,%eax
  80f8b9:	78 31                	js     80f8ec <fork+0xe2>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80f8bb:	83 ec 08             	sub    $0x8,%esp
  80f8be:	68 f6 0f 81 00       	push   $0x810ff6
  80f8c3:	56                   	push   %esi
  80f8c4:	e8 62 fb ff ff       	call   80f42b <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80f8c9:	83 c4 10             	add    $0x10,%esp
  80f8cc:	85 c0                	test   %eax,%eax
  80f8ce:	78 33                	js     80f903 <fork+0xf9>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80f8d0:	83 ec 08             	sub    $0x8,%esp
  80f8d3:	6a 02                	push   $0x2
  80f8d5:	56                   	push   %esi
  80f8d6:	e8 cc fa ff ff       	call   80f3a7 <sys_env_set_status>
	if(ret < 0)
  80f8db:	83 c4 10             	add    $0x10,%esp
  80f8de:	85 c0                	test   %eax,%eax
  80f8e0:	78 38                	js     80f91a <fork+0x110>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
	// LAB 4: Your code here.
	// panic("fork not implemented");
}
  80f8e2:	89 f0                	mov    %esi,%eax
  80f8e4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80f8e7:	5b                   	pop    %ebx
  80f8e8:	5e                   	pop    %esi
  80f8e9:	5f                   	pop    %edi
  80f8ea:	5d                   	pop    %ebp
  80f8eb:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80f8ec:	83 ec 04             	sub    $0x4,%esp
  80f8ef:	68 08 3d 81 00       	push   $0x813d08
  80f8f4:	68 98 00 00 00       	push   $0x98
  80f8f9:	68 e9 3c 81 00       	push   $0x813ce9
  80f8fe:	e8 96 ed ff ff       	call   80e699 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80f903:	83 ec 04             	sub    $0x4,%esp
  80f906:	68 7c 3d 81 00       	push   $0x813d7c
  80f90b:	68 9b 00 00 00       	push   $0x9b
  80f910:	68 e9 3c 81 00       	push   $0x813ce9
  80f915:	e8 7f ed ff ff       	call   80e699 <_panic>
		panic("panic in sys_env_set_status()\n");
  80f91a:	83 ec 04             	sub    $0x4,%esp
  80f91d:	68 a4 3d 81 00       	push   $0x813da4
  80f922:	68 9e 00 00 00       	push   $0x9e
  80f927:	68 e9 3c 81 00       	push   $0x813ce9
  80f92c:	e8 68 ed ff ff       	call   80e699 <_panic>

0080f931 <sfork>:

// Challenge!
int
sfork(void)
{
  80f931:	55                   	push   %ebp
  80f932:	89 e5                	mov    %esp,%ebp
  80f934:	57                   	push   %edi
  80f935:	56                   	push   %esi
  80f936:	53                   	push   %ebx
  80f937:	83 ec 18             	sub    $0x18,%esp
	// panic("sfork not implemented");
	// envid_t child_envid = sys_exofork();
	// return -E_INVAL;
	int ret;
	set_pgfault_handler(pgfault);
  80f93a:	68 0b f7 80 00       	push   $0x80f70b
  80f93f:	e8 43 16 00 00       	call   810f87 <set_pgfault_handler>
  80f944:	b8 07 00 00 00       	mov    $0x7,%eax
  80f949:	cd 30                	int    $0x30
	envid_t child_envid = sys_exofork();
	if(child_envid < 0)
  80f94b:	83 c4 10             	add    $0x10,%esp
  80f94e:	85 c0                	test   %eax,%eax
  80f950:	78 27                	js     80f979 <sfork+0x48>
  80f952:	89 c7                	mov    %eax,%edi
  80f954:	89 c6                	mov    %eax,%esi
		panic("the fork panic! at sys_exofork()\n");
	if(child_envid == 0){
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f956:	bb 00 00 80 00       	mov    $0x800000,%ebx
	if(child_envid == 0){
  80f95b:	75 55                	jne    80f9b2 <sfork+0x81>
		thisenv = &envs[ENVX(sys_getenvid())];
  80f95d:	e8 40 f9 ff ff       	call   80f2a2 <sys_getenvid>
  80f962:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f967:	c1 e0 07             	shl    $0x7,%eax
  80f96a:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f96f:	a3 5c b2 b3 00       	mov    %eax,0xb3b25c
		return 0;
  80f974:	e9 d4 00 00 00       	jmp    80fa4d <sfork+0x11c>
		panic("the fork panic! at sys_exofork()\n");
  80f979:	83 ec 04             	sub    $0x4,%esp
  80f97c:	68 58 3d 81 00       	push   $0x813d58
  80f981:	68 af 00 00 00       	push   $0xaf
  80f986:	68 e9 3c 81 00       	push   $0x813ce9
  80f98b:	e8 09 ed ff ff       	call   80e699 <_panic>
		if(i == (USTACKTOP - PGSIZE))
			duppage(child_envid, PGNUM(i));
  80f990:	ba fd eb 0e 00       	mov    $0xeebfd,%edx
  80f995:	89 f0                	mov    %esi,%eax
  80f997:	e8 19 fc ff ff       	call   80f5b5 <duppage>
	for(uintptr_t i = UTEXT; i < USTACKTOP; i+=PGSIZE){	//lab4 bug not TXSTACKTOP
  80f99c:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  80f9a2:	81 fb ff df bf ee    	cmp    $0xeebfdfff,%ebx
  80f9a8:	77 65                	ja     80fa0f <sfork+0xde>
		if(i == (USTACKTOP - PGSIZE))
  80f9aa:	81 fb 00 d0 bf ee    	cmp    $0xeebfd000,%ebx
  80f9b0:	74 de                	je     80f990 <sfork+0x5f>
		else if((uvpd[PDX(i)] & PTE_P) && ((uvpt[PGNUM(i)] & (PTE_P | PTE_U)) == (PTE_P | PTE_U))){
  80f9b2:	89 d8                	mov    %ebx,%eax
  80f9b4:	c1 e8 16             	shr    $0x16,%eax
  80f9b7:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80f9be:	a8 01                	test   $0x1,%al
  80f9c0:	74 da                	je     80f99c <sfork+0x6b>
  80f9c2:	89 da                	mov    %ebx,%edx
  80f9c4:	c1 ea 0c             	shr    $0xc,%edx
  80f9c7:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80f9ce:	83 e0 05             	and    $0x5,%eax
  80f9d1:	83 f8 05             	cmp    $0x5,%eax
  80f9d4:	75 c6                	jne    80f99c <sfork+0x6b>
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
						((uvpt[PGNUM(i)] & (PTE_P | PTE_U | PTE_W)))))
  80f9d6:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
			if(sys_page_map(0, (void *)(PGNUM(i) * PGSIZE), child_envid, (void *)(PGNUM(i) * PGSIZE), 
  80f9dd:	c1 e2 0c             	shl    $0xc,%edx
  80f9e0:	83 ec 0c             	sub    $0xc,%esp
  80f9e3:	83 e0 07             	and    $0x7,%eax
  80f9e6:	50                   	push   %eax
  80f9e7:	52                   	push   %edx
  80f9e8:	56                   	push   %esi
  80f9e9:	52                   	push   %edx
  80f9ea:	6a 00                	push   $0x0
  80f9ec:	e8 32 f9 ff ff       	call   80f323 <sys_page_map>
  80f9f1:	83 c4 20             	add    $0x20,%esp
  80f9f4:	85 c0                	test   %eax,%eax
  80f9f6:	74 a4                	je     80f99c <sfork+0x6b>
				panic("sys_page_map() panic\n");
  80f9f8:	83 ec 04             	sub    $0x4,%esp
  80f9fb:	68 d3 3c 81 00       	push   $0x813cd3
  80fa00:	68 ba 00 00 00       	push   $0xba
  80fa05:	68 e9 3c 81 00       	push   $0x813ce9
  80fa0a:	e8 8a ec ff ff       	call   80e699 <_panic>
		}
	}
	
	ret = sys_page_alloc(child_envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W);
  80fa0f:	83 ec 04             	sub    $0x4,%esp
  80fa12:	6a 07                	push   $0x7
  80fa14:	68 00 f0 bf ee       	push   $0xeebff000
  80fa19:	57                   	push   %edi
  80fa1a:	e8 c1 f8 ff ff       	call   80f2e0 <sys_page_alloc>
	if(ret < 0)
  80fa1f:	83 c4 10             	add    $0x10,%esp
  80fa22:	85 c0                	test   %eax,%eax
  80fa24:	78 31                	js     80fa57 <sfork+0x126>
		panic("panic in sys_page_alloc()\n");
	ret = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall);
  80fa26:	83 ec 08             	sub    $0x8,%esp
  80fa29:	68 f6 0f 81 00       	push   $0x810ff6
  80fa2e:	57                   	push   %edi
  80fa2f:	e8 f7 f9 ff ff       	call   80f42b <sys_env_set_pgfault_upcall>
	if(ret < 0)
  80fa34:	83 c4 10             	add    $0x10,%esp
  80fa37:	85 c0                	test   %eax,%eax
  80fa39:	78 33                	js     80fa6e <sfork+0x13d>
		panic("panic in sys_env_set_pgfault_upcall()\n");
	ret = sys_env_set_status(child_envid, ENV_RUNNABLE);
  80fa3b:	83 ec 08             	sub    $0x8,%esp
  80fa3e:	6a 02                	push   $0x2
  80fa40:	57                   	push   %edi
  80fa41:	e8 61 f9 ff ff       	call   80f3a7 <sys_env_set_status>
	if(ret < 0)
  80fa46:	83 c4 10             	add    $0x10,%esp
  80fa49:	85 c0                	test   %eax,%eax
  80fa4b:	78 38                	js     80fa85 <sfork+0x154>
		panic("panic in sys_env_set_status()\n");
	return child_envid;
  80fa4d:	89 f8                	mov    %edi,%eax
  80fa4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fa52:	5b                   	pop    %ebx
  80fa53:	5e                   	pop    %esi
  80fa54:	5f                   	pop    %edi
  80fa55:	5d                   	pop    %ebp
  80fa56:	c3                   	ret    
		panic("panic in sys_page_alloc()\n");
  80fa57:	83 ec 04             	sub    $0x4,%esp
  80fa5a:	68 08 3d 81 00       	push   $0x813d08
  80fa5f:	68 c0 00 00 00       	push   $0xc0
  80fa64:	68 e9 3c 81 00       	push   $0x813ce9
  80fa69:	e8 2b ec ff ff       	call   80e699 <_panic>
		panic("panic in sys_env_set_pgfault_upcall()\n");
  80fa6e:	83 ec 04             	sub    $0x4,%esp
  80fa71:	68 7c 3d 81 00       	push   $0x813d7c
  80fa76:	68 c3 00 00 00       	push   $0xc3
  80fa7b:	68 e9 3c 81 00       	push   $0x813ce9
  80fa80:	e8 14 ec ff ff       	call   80e699 <_panic>
		panic("panic in sys_env_set_status()\n");
  80fa85:	83 ec 04             	sub    $0x4,%esp
  80fa88:	68 a4 3d 81 00       	push   $0x813da4
  80fa8d:	68 c6 00 00 00       	push   $0xc6
  80fa92:	68 e9 3c 81 00       	push   $0x813ce9
  80fa97:	e8 fd eb ff ff       	call   80e699 <_panic>

0080fa9c <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  80fa9c:	55                   	push   %ebp
  80fa9d:	89 e5                	mov    %esp,%ebp
  80fa9f:	56                   	push   %esi
  80faa0:	53                   	push   %ebx
  80faa1:	8b 75 08             	mov    0x8(%ebp),%esi
  80faa4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80faa7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	// panic("ipc_recv not implemented");
	// cprintf("in %s\n", __FUNCTION__);
	int ret;
	if(!pg)
  80faaa:	85 c0                	test   %eax,%eax
		pg = (void *)UTOP;
  80faac:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  80fab1:	0f 44 c2             	cmove  %edx,%eax
	ret = sys_ipc_recv(pg);
  80fab4:	83 ec 0c             	sub    $0xc,%esp
  80fab7:	50                   	push   %eax
  80fab8:	e8 d3 f9 ff ff       	call   80f490 <sys_ipc_recv>
	if(ret < 0){
  80fabd:	83 c4 10             	add    $0x10,%esp
  80fac0:	85 c0                	test   %eax,%eax
  80fac2:	78 2b                	js     80faef <ipc_recv+0x53>
			*from_env_store = 0;
		if(perm_store)
			*perm_store = 0;
		return ret;
	}
	if(from_env_store){
  80fac4:	85 f6                	test   %esi,%esi
  80fac6:	74 0a                	je     80fad2 <ipc_recv+0x36>
		// *from_env_store = getthisenv()->env_ipc_from;
		*from_env_store = thisenv->env_ipc_from;
  80fac8:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80facd:	8b 40 74             	mov    0x74(%eax),%eax
  80fad0:	89 06                	mov    %eax,(%esi)
	}
	if(perm_store){
  80fad2:	85 db                	test   %ebx,%ebx
  80fad4:	74 0a                	je     80fae0 <ipc_recv+0x44>
		// *perm_store = getthisenv()->env_ipc_perm;
		*perm_store = thisenv->env_ipc_perm;
  80fad6:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fadb:	8b 40 78             	mov    0x78(%eax),%eax
  80fade:	89 03                	mov    %eax,(%ebx)
	}
	// return getthisenv()->env_ipc_value;
	return thisenv->env_ipc_value;
  80fae0:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fae5:	8b 40 70             	mov    0x70(%eax),%eax
}
  80fae8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  80faeb:	5b                   	pop    %ebx
  80faec:	5e                   	pop    %esi
  80faed:	5d                   	pop    %ebp
  80faee:	c3                   	ret    
		if(from_env_store)
  80faef:	85 f6                	test   %esi,%esi
  80faf1:	74 06                	je     80faf9 <ipc_recv+0x5d>
			*from_env_store = 0;
  80faf3:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store)
  80faf9:	85 db                	test   %ebx,%ebx
  80fafb:	74 eb                	je     80fae8 <ipc_recv+0x4c>
			*perm_store = 0;
  80fafd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80fb03:	eb e3                	jmp    80fae8 <ipc_recv+0x4c>

0080fb05 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{	
  80fb05:	55                   	push   %ebp
  80fb06:	89 e5                	mov    %esp,%ebp
  80fb08:	57                   	push   %edi
  80fb09:	56                   	push   %esi
  80fb0a:	53                   	push   %ebx
  80fb0b:	83 ec 0c             	sub    $0xc,%esp
  80fb0e:	8b 7d 08             	mov    0x8(%ebp),%edi
  80fb11:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fb14:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// cprintf("%d: in %s to_env is %d\n", thisenv->env_id, __FUNCTION__, to_env);
	int ret;
	if(!pg)
		pg = (void *)UTOP;
  80fb17:	85 db                	test   %ebx,%ebx
  80fb19:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  80fb1e:	0f 44 d8             	cmove  %eax,%ebx
  80fb21:	eb 05                	jmp    80fb28 <ipc_send+0x23>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
			panic("panic at ipc_send()\n");
		}
		sys_yield();
  80fb23:	e8 99 f7 ff ff       	call   80f2c1 <sys_yield>
	while((ret = sys_ipc_try_send(to_env, val, pg, perm))){
  80fb28:	ff 75 14             	pushl  0x14(%ebp)
  80fb2b:	53                   	push   %ebx
  80fb2c:	56                   	push   %esi
  80fb2d:	57                   	push   %edi
  80fb2e:	e8 3a f9 ff ff       	call   80f46d <sys_ipc_try_send>
  80fb33:	83 c4 10             	add    $0x10,%esp
  80fb36:	85 c0                	test   %eax,%eax
  80fb38:	74 1b                	je     80fb55 <ipc_send+0x50>
		if(ret < 0 && ret != -E_IPC_NOT_RECV){
  80fb3a:	79 e7                	jns    80fb23 <ipc_send+0x1e>
  80fb3c:	83 f8 f9             	cmp    $0xfffffff9,%eax
  80fb3f:	74 e2                	je     80fb23 <ipc_send+0x1e>
			panic("panic at ipc_send()\n");
  80fb41:	83 ec 04             	sub    $0x4,%esp
  80fb44:	68 c3 3d 81 00       	push   $0x813dc3
  80fb49:	6a 4a                	push   $0x4a
  80fb4b:	68 d8 3d 81 00       	push   $0x813dd8
  80fb50:	e8 44 eb ff ff       	call   80e699 <_panic>
	}
	// LAB 4: Your code here.
	// panic("ipc_send not implemented");
}
  80fb55:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fb58:	5b                   	pop    %ebx
  80fb59:	5e                   	pop    %esi
  80fb5a:	5f                   	pop    %edi
  80fb5b:	5d                   	pop    %ebp
  80fb5c:	c3                   	ret    

0080fb5d <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  80fb5d:	55                   	push   %ebp
  80fb5e:	89 e5                	mov    %esp,%ebp
  80fb60:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  80fb63:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  80fb68:	89 c2                	mov    %eax,%edx
  80fb6a:	c1 e2 07             	shl    $0x7,%edx
  80fb6d:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  80fb73:	8b 52 50             	mov    0x50(%edx),%edx
  80fb76:	39 ca                	cmp    %ecx,%edx
  80fb78:	74 11                	je     80fb8b <ipc_find_env+0x2e>
	for (i = 0; i < NENV; i++)
  80fb7a:	83 c0 01             	add    $0x1,%eax
  80fb7d:	3d 00 04 00 00       	cmp    $0x400,%eax
  80fb82:	75 e4                	jne    80fb68 <ipc_find_env+0xb>
			return envs[i].env_id;
	return 0;
  80fb84:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb89:	eb 0b                	jmp    80fb96 <ipc_find_env+0x39>
			return envs[i].env_id;
  80fb8b:	c1 e0 07             	shl    $0x7,%eax
  80fb8e:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80fb93:	8b 40 48             	mov    0x48(%eax),%eax
}
  80fb96:	5d                   	pop    %ebp
  80fb97:	c3                   	ret    

0080fb98 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  80fb98:	55                   	push   %ebp
  80fb99:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fb9b:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb9e:	05 00 00 00 30       	add    $0x30000000,%eax
  80fba3:	c1 e8 0c             	shr    $0xc,%eax
}
  80fba6:	5d                   	pop    %ebp
  80fba7:	c3                   	ret    

0080fba8 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80fba8:	55                   	push   %ebp
  80fba9:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fbab:	8b 45 08             	mov    0x8(%ebp),%eax
  80fbae:	05 00 00 00 30       	add    $0x30000000,%eax
	return INDEX2DATA(fd2num(fd));
  80fbb3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  80fbb8:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  80fbbd:	5d                   	pop    %ebp
  80fbbe:	c3                   	ret    

0080fbbf <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  80fbbf:	55                   	push   %ebp
  80fbc0:	89 e5                	mov    %esp,%ebp
  80fbc2:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80fbc7:	89 c2                	mov    %eax,%edx
  80fbc9:	c1 ea 16             	shr    $0x16,%edx
  80fbcc:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80fbd3:	f6 c2 01             	test   $0x1,%dl
  80fbd6:	74 2d                	je     80fc05 <fd_alloc+0x46>
  80fbd8:	89 c2                	mov    %eax,%edx
  80fbda:	c1 ea 0c             	shr    $0xc,%edx
  80fbdd:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fbe4:	f6 c2 01             	test   $0x1,%dl
  80fbe7:	74 1c                	je     80fc05 <fd_alloc+0x46>
  80fbe9:	05 00 10 00 00       	add    $0x1000,%eax
	for (i = 0; i < MAXFD; i++) {
  80fbee:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  80fbf3:	75 d2                	jne    80fbc7 <fd_alloc+0x8>
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80fbf5:	8b 45 08             	mov    0x8(%ebp),%eax
  80fbf8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_MAX_OPEN;
  80fbfe:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80fc03:	eb 0a                	jmp    80fc0f <fd_alloc+0x50>
			*fd_store = fd;
  80fc05:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80fc08:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fc0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fc0f:	5d                   	pop    %ebp
  80fc10:	c3                   	ret    

0080fc11 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  80fc11:	55                   	push   %ebp
  80fc12:	89 e5                	mov    %esp,%ebp
  80fc14:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  80fc17:	83 f8 1f             	cmp    $0x1f,%eax
  80fc1a:	77 30                	ja     80fc4c <fd_lookup+0x3b>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  80fc1c:	c1 e0 0c             	shl    $0xc,%eax
  80fc1f:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  80fc24:	8b 15 00 dd 7b ef    	mov    0xef7bdd00,%edx
  80fc2a:	f6 c2 01             	test   $0x1,%dl
  80fc2d:	74 24                	je     80fc53 <fd_lookup+0x42>
  80fc2f:	89 c2                	mov    %eax,%edx
  80fc31:	c1 ea 0c             	shr    $0xc,%edx
  80fc34:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  80fc3b:	f6 c2 01             	test   $0x1,%dl
  80fc3e:	74 1a                	je     80fc5a <fd_lookup+0x49>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  80fc40:	8b 55 0c             	mov    0xc(%ebp),%edx
  80fc43:	89 02                	mov    %eax,(%edx)
	return 0;
  80fc45:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fc4a:	5d                   	pop    %ebp
  80fc4b:	c3                   	ret    
		return -E_INVAL;
  80fc4c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc51:	eb f7                	jmp    80fc4a <fd_lookup+0x39>
		return -E_INVAL;
  80fc53:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc58:	eb f0                	jmp    80fc4a <fd_lookup+0x39>
  80fc5a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80fc5f:	eb e9                	jmp    80fc4a <fd_lookup+0x39>

0080fc61 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  80fc61:	55                   	push   %ebp
  80fc62:	89 e5                	mov    %esp,%ebp
  80fc64:	83 ec 08             	sub    $0x8,%esp
  80fc67:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  80fc6a:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc6f:	b8 ec 42 81 00       	mov    $0x8142ec,%eax
		if (devtab[i]->dev_id == dev_id) {
  80fc74:	39 08                	cmp    %ecx,(%eax)
  80fc76:	74 38                	je     80fcb0 <dev_lookup+0x4f>
	for (i = 0; devtab[i]; i++)
  80fc78:	83 c2 01             	add    $0x1,%edx
  80fc7b:	8b 04 95 60 3e 81 00 	mov    0x813e60(,%edx,4),%eax
  80fc82:	85 c0                	test   %eax,%eax
  80fc84:	75 ee                	jne    80fc74 <dev_lookup+0x13>
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  80fc86:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fc8b:	8b 40 48             	mov    0x48(%eax),%eax
  80fc8e:	83 ec 04             	sub    $0x4,%esp
  80fc91:	51                   	push   %ecx
  80fc92:	50                   	push   %eax
  80fc93:	68 e4 3d 81 00       	push   $0x813de4
  80fc98:	e8 f2 ea ff ff       	call   80e78f <cprintf>
	*dev = 0;
  80fc9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fca0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  80fca6:	83 c4 10             	add    $0x10,%esp
  80fca9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  80fcae:	c9                   	leave  
  80fcaf:	c3                   	ret    
			*dev = devtab[i];
  80fcb0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fcb3:	89 01                	mov    %eax,(%ecx)
			return 0;
  80fcb5:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcba:	eb f2                	jmp    80fcae <dev_lookup+0x4d>

0080fcbc <fd_close>:
{
  80fcbc:	55                   	push   %ebp
  80fcbd:	89 e5                	mov    %esp,%ebp
  80fcbf:	57                   	push   %edi
  80fcc0:	56                   	push   %esi
  80fcc1:	53                   	push   %ebx
  80fcc2:	83 ec 24             	sub    $0x24,%esp
  80fcc5:	8b 75 08             	mov    0x8(%ebp),%esi
  80fcc8:	8b 7d 0c             	mov    0xc(%ebp),%edi
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fccb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fcce:	50                   	push   %eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80fccf:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  80fcd5:	c1 e8 0c             	shr    $0xc,%eax
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80fcd8:	50                   	push   %eax
  80fcd9:	e8 33 ff ff ff       	call   80fc11 <fd_lookup>
  80fcde:	89 c3                	mov    %eax,%ebx
  80fce0:	83 c4 10             	add    $0x10,%esp
  80fce3:	85 c0                	test   %eax,%eax
  80fce5:	78 05                	js     80fcec <fd_close+0x30>
	    || fd != fd2)
  80fce7:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80fcea:	74 16                	je     80fd02 <fd_close+0x46>
		return (must_exist ? r : 0);
  80fcec:	89 f8                	mov    %edi,%eax
  80fcee:	84 c0                	test   %al,%al
  80fcf0:	b8 00 00 00 00       	mov    $0x0,%eax
  80fcf5:	0f 44 d8             	cmove  %eax,%ebx
}
  80fcf8:	89 d8                	mov    %ebx,%eax
  80fcfa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fcfd:	5b                   	pop    %ebx
  80fcfe:	5e                   	pop    %esi
  80fcff:	5f                   	pop    %edi
  80fd00:	5d                   	pop    %ebp
  80fd01:	c3                   	ret    
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80fd02:	83 ec 08             	sub    $0x8,%esp
  80fd05:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80fd08:	50                   	push   %eax
  80fd09:	ff 36                	pushl  (%esi)
  80fd0b:	e8 51 ff ff ff       	call   80fc61 <dev_lookup>
  80fd10:	89 c3                	mov    %eax,%ebx
  80fd12:	83 c4 10             	add    $0x10,%esp
  80fd15:	85 c0                	test   %eax,%eax
  80fd17:	78 1a                	js     80fd33 <fd_close+0x77>
		if (dev->dev_close)
  80fd19:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80fd1c:	8b 40 10             	mov    0x10(%eax),%eax
			r = 0;
  80fd1f:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (dev->dev_close)
  80fd24:	85 c0                	test   %eax,%eax
  80fd26:	74 0b                	je     80fd33 <fd_close+0x77>
			r = (*dev->dev_close)(fd);
  80fd28:	83 ec 0c             	sub    $0xc,%esp
  80fd2b:	56                   	push   %esi
  80fd2c:	ff d0                	call   *%eax
  80fd2e:	89 c3                	mov    %eax,%ebx
  80fd30:	83 c4 10             	add    $0x10,%esp
	(void) sys_page_unmap(0, fd);
  80fd33:	83 ec 08             	sub    $0x8,%esp
  80fd36:	56                   	push   %esi
  80fd37:	6a 00                	push   $0x0
  80fd39:	e8 27 f6 ff ff       	call   80f365 <sys_page_unmap>
	return r;
  80fd3e:	83 c4 10             	add    $0x10,%esp
  80fd41:	eb b5                	jmp    80fcf8 <fd_close+0x3c>

0080fd43 <close>:

int
close(int fdnum)
{
  80fd43:	55                   	push   %ebp
  80fd44:	89 e5                	mov    %esp,%ebp
  80fd46:	83 ec 20             	sub    $0x20,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80fd49:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fd4c:	50                   	push   %eax
  80fd4d:	ff 75 08             	pushl  0x8(%ebp)
  80fd50:	e8 bc fe ff ff       	call   80fc11 <fd_lookup>
  80fd55:	83 c4 10             	add    $0x10,%esp
  80fd58:	85 c0                	test   %eax,%eax
  80fd5a:	79 02                	jns    80fd5e <close+0x1b>
		return r;
	else
		return fd_close(fd, 1);
}
  80fd5c:	c9                   	leave  
  80fd5d:	c3                   	ret    
		return fd_close(fd, 1);
  80fd5e:	83 ec 08             	sub    $0x8,%esp
  80fd61:	6a 01                	push   $0x1
  80fd63:	ff 75 f4             	pushl  -0xc(%ebp)
  80fd66:	e8 51 ff ff ff       	call   80fcbc <fd_close>
  80fd6b:	83 c4 10             	add    $0x10,%esp
  80fd6e:	eb ec                	jmp    80fd5c <close+0x19>

0080fd70 <close_all>:

void
close_all(void)
{
  80fd70:	55                   	push   %ebp
  80fd71:	89 e5                	mov    %esp,%ebp
  80fd73:	53                   	push   %ebx
  80fd74:	83 ec 04             	sub    $0x4,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  80fd77:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  80fd7c:	83 ec 0c             	sub    $0xc,%esp
  80fd7f:	53                   	push   %ebx
  80fd80:	e8 be ff ff ff       	call   80fd43 <close>
	for (i = 0; i < MAXFD; i++)
  80fd85:	83 c3 01             	add    $0x1,%ebx
  80fd88:	83 c4 10             	add    $0x10,%esp
  80fd8b:	83 fb 20             	cmp    $0x20,%ebx
  80fd8e:	75 ec                	jne    80fd7c <close_all+0xc>
}
  80fd90:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fd93:	c9                   	leave  
  80fd94:	c3                   	ret    

0080fd95 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80fd95:	55                   	push   %ebp
  80fd96:	89 e5                	mov    %esp,%ebp
  80fd98:	57                   	push   %edi
  80fd99:	56                   	push   %esi
  80fd9a:	53                   	push   %ebx
  80fd9b:	83 ec 24             	sub    $0x24,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80fd9e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80fda1:	50                   	push   %eax
  80fda2:	ff 75 08             	pushl  0x8(%ebp)
  80fda5:	e8 67 fe ff ff       	call   80fc11 <fd_lookup>
  80fdaa:	89 c3                	mov    %eax,%ebx
  80fdac:	83 c4 10             	add    $0x10,%esp
  80fdaf:	85 c0                	test   %eax,%eax
  80fdb1:	0f 88 81 00 00 00    	js     80fe38 <dup+0xa3>
		return r;
	close(newfdnum);
  80fdb7:	83 ec 0c             	sub    $0xc,%esp
  80fdba:	ff 75 0c             	pushl  0xc(%ebp)
  80fdbd:	e8 81 ff ff ff       	call   80fd43 <close>

	newfd = INDEX2FD(newfdnum);
  80fdc2:	8b 75 0c             	mov    0xc(%ebp),%esi
  80fdc5:	c1 e6 0c             	shl    $0xc,%esi
  80fdc8:	81 ee 00 00 00 30    	sub    $0x30000000,%esi
	ova = fd2data(oldfd);
  80fdce:	83 c4 04             	add    $0x4,%esp
  80fdd1:	ff 75 e4             	pushl  -0x1c(%ebp)
  80fdd4:	e8 cf fd ff ff       	call   80fba8 <fd2data>
  80fdd9:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  80fddb:	89 34 24             	mov    %esi,(%esp)
  80fdde:	e8 c5 fd ff ff       	call   80fba8 <fd2data>
  80fde3:	83 c4 10             	add    $0x10,%esp
  80fde6:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  80fde8:	89 d8                	mov    %ebx,%eax
  80fdea:	c1 e8 16             	shr    $0x16,%eax
  80fded:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  80fdf4:	a8 01                	test   $0x1,%al
  80fdf6:	74 11                	je     80fe09 <dup+0x74>
  80fdf8:	89 d8                	mov    %ebx,%eax
  80fdfa:	c1 e8 0c             	shr    $0xc,%eax
  80fdfd:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  80fe04:	f6 c2 01             	test   $0x1,%dl
  80fe07:	75 39                	jne    80fe42 <dup+0xad>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80fe09:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80fe0c:	89 d0                	mov    %edx,%eax
  80fe0e:	c1 e8 0c             	shr    $0xc,%eax
  80fe11:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fe18:	83 ec 0c             	sub    $0xc,%esp
  80fe1b:	25 07 0e 00 00       	and    $0xe07,%eax
  80fe20:	50                   	push   %eax
  80fe21:	56                   	push   %esi
  80fe22:	6a 00                	push   $0x0
  80fe24:	52                   	push   %edx
  80fe25:	6a 00                	push   $0x0
  80fe27:	e8 f7 f4 ff ff       	call   80f323 <sys_page_map>
  80fe2c:	89 c3                	mov    %eax,%ebx
  80fe2e:	83 c4 20             	add    $0x20,%esp
  80fe31:	85 c0                	test   %eax,%eax
  80fe33:	78 31                	js     80fe66 <dup+0xd1>
		goto err;

	return newfdnum;
  80fe35:	8b 5d 0c             	mov    0xc(%ebp),%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  80fe38:	89 d8                	mov    %ebx,%eax
  80fe3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80fe3d:	5b                   	pop    %ebx
  80fe3e:	5e                   	pop    %esi
  80fe3f:	5f                   	pop    %edi
  80fe40:	5d                   	pop    %ebp
  80fe41:	c3                   	ret    
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80fe42:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80fe49:	83 ec 0c             	sub    $0xc,%esp
  80fe4c:	25 07 0e 00 00       	and    $0xe07,%eax
  80fe51:	50                   	push   %eax
  80fe52:	57                   	push   %edi
  80fe53:	6a 00                	push   $0x0
  80fe55:	53                   	push   %ebx
  80fe56:	6a 00                	push   $0x0
  80fe58:	e8 c6 f4 ff ff       	call   80f323 <sys_page_map>
  80fe5d:	89 c3                	mov    %eax,%ebx
  80fe5f:	83 c4 20             	add    $0x20,%esp
  80fe62:	85 c0                	test   %eax,%eax
  80fe64:	79 a3                	jns    80fe09 <dup+0x74>
	sys_page_unmap(0, newfd);
  80fe66:	83 ec 08             	sub    $0x8,%esp
  80fe69:	56                   	push   %esi
  80fe6a:	6a 00                	push   $0x0
  80fe6c:	e8 f4 f4 ff ff       	call   80f365 <sys_page_unmap>
	sys_page_unmap(0, nva);
  80fe71:	83 c4 08             	add    $0x8,%esp
  80fe74:	57                   	push   %edi
  80fe75:	6a 00                	push   $0x0
  80fe77:	e8 e9 f4 ff ff       	call   80f365 <sys_page_unmap>
	return r;
  80fe7c:	83 c4 10             	add    $0x10,%esp
  80fe7f:	eb b7                	jmp    80fe38 <dup+0xa3>

0080fe81 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80fe81:	55                   	push   %ebp
  80fe82:	89 e5                	mov    %esp,%ebp
  80fe84:	53                   	push   %ebx
  80fe85:	83 ec 1c             	sub    $0x1c,%esp
  80fe88:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80fe8b:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80fe8e:	50                   	push   %eax
  80fe8f:	53                   	push   %ebx
  80fe90:	e8 7c fd ff ff       	call   80fc11 <fd_lookup>
  80fe95:	83 c4 10             	add    $0x10,%esp
  80fe98:	85 c0                	test   %eax,%eax
  80fe9a:	78 3f                	js     80fedb <read+0x5a>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80fe9c:	83 ec 08             	sub    $0x8,%esp
  80fe9f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80fea2:	50                   	push   %eax
  80fea3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80fea6:	ff 30                	pushl  (%eax)
  80fea8:	e8 b4 fd ff ff       	call   80fc61 <dev_lookup>
  80fead:	83 c4 10             	add    $0x10,%esp
  80feb0:	85 c0                	test   %eax,%eax
  80feb2:	78 27                	js     80fedb <read+0x5a>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80feb4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80feb7:	8b 42 08             	mov    0x8(%edx),%eax
  80feba:	83 e0 03             	and    $0x3,%eax
  80febd:	83 f8 01             	cmp    $0x1,%eax
  80fec0:	74 1e                	je     80fee0 <read+0x5f>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80fec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80fec5:	8b 40 08             	mov    0x8(%eax),%eax
  80fec8:	85 c0                	test   %eax,%eax
  80feca:	74 35                	je     80ff01 <read+0x80>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80fecc:	83 ec 04             	sub    $0x4,%esp
  80fecf:	ff 75 10             	pushl  0x10(%ebp)
  80fed2:	ff 75 0c             	pushl  0xc(%ebp)
  80fed5:	52                   	push   %edx
  80fed6:	ff d0                	call   *%eax
  80fed8:	83 c4 10             	add    $0x10,%esp
}
  80fedb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80fede:	c9                   	leave  
  80fedf:	c3                   	ret    
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80fee0:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80fee5:	8b 40 48             	mov    0x48(%eax),%eax
  80fee8:	83 ec 04             	sub    $0x4,%esp
  80feeb:	53                   	push   %ebx
  80feec:	50                   	push   %eax
  80feed:	68 25 3e 81 00       	push   $0x813e25
  80fef2:	e8 98 e8 ff ff       	call   80e78f <cprintf>
		return -E_INVAL;
  80fef7:	83 c4 10             	add    $0x10,%esp
  80fefa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80feff:	eb da                	jmp    80fedb <read+0x5a>
		return -E_NOT_SUPP;
  80ff01:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ff06:	eb d3                	jmp    80fedb <read+0x5a>

0080ff08 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80ff08:	55                   	push   %ebp
  80ff09:	89 e5                	mov    %esp,%ebp
  80ff0b:	57                   	push   %edi
  80ff0c:	56                   	push   %esi
  80ff0d:	53                   	push   %ebx
  80ff0e:	83 ec 0c             	sub    $0xc,%esp
  80ff11:	8b 7d 08             	mov    0x8(%ebp),%edi
  80ff14:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80ff17:	bb 00 00 00 00       	mov    $0x0,%ebx
  80ff1c:	39 f3                	cmp    %esi,%ebx
  80ff1e:	73 23                	jae    80ff43 <readn+0x3b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80ff20:	83 ec 04             	sub    $0x4,%esp
  80ff23:	89 f0                	mov    %esi,%eax
  80ff25:	29 d8                	sub    %ebx,%eax
  80ff27:	50                   	push   %eax
  80ff28:	89 d8                	mov    %ebx,%eax
  80ff2a:	03 45 0c             	add    0xc(%ebp),%eax
  80ff2d:	50                   	push   %eax
  80ff2e:	57                   	push   %edi
  80ff2f:	e8 4d ff ff ff       	call   80fe81 <read>
		if (m < 0)
  80ff34:	83 c4 10             	add    $0x10,%esp
  80ff37:	85 c0                	test   %eax,%eax
  80ff39:	78 06                	js     80ff41 <readn+0x39>
			return m;
		if (m == 0)
  80ff3b:	74 06                	je     80ff43 <readn+0x3b>
	for (tot = 0; tot < n; tot += m) {
  80ff3d:	01 c3                	add    %eax,%ebx
  80ff3f:	eb db                	jmp    80ff1c <readn+0x14>
		m = read(fdnum, (char*)buf + tot, n - tot);
  80ff41:	89 c3                	mov    %eax,%ebx
			break;
	}
	return tot;
}
  80ff43:	89 d8                	mov    %ebx,%eax
  80ff45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  80ff48:	5b                   	pop    %ebx
  80ff49:	5e                   	pop    %esi
  80ff4a:	5f                   	pop    %edi
  80ff4b:	5d                   	pop    %ebp
  80ff4c:	c3                   	ret    

0080ff4d <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80ff4d:	55                   	push   %ebp
  80ff4e:	89 e5                	mov    %esp,%ebp
  80ff50:	53                   	push   %ebx
  80ff51:	83 ec 1c             	sub    $0x1c,%esp
  80ff54:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80ff57:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80ff5a:	50                   	push   %eax
  80ff5b:	53                   	push   %ebx
  80ff5c:	e8 b0 fc ff ff       	call   80fc11 <fd_lookup>
  80ff61:	83 c4 10             	add    $0x10,%esp
  80ff64:	85 c0                	test   %eax,%eax
  80ff66:	78 3a                	js     80ffa2 <write+0x55>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80ff68:	83 ec 08             	sub    $0x8,%esp
  80ff6b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ff6e:	50                   	push   %eax
  80ff6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff72:	ff 30                	pushl  (%eax)
  80ff74:	e8 e8 fc ff ff       	call   80fc61 <dev_lookup>
  80ff79:	83 c4 10             	add    $0x10,%esp
  80ff7c:	85 c0                	test   %eax,%eax
  80ff7e:	78 22                	js     80ffa2 <write+0x55>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80ff80:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80ff83:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  80ff87:	74 1e                	je     80ffa7 <write+0x5a>
		return -E_INVAL;
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80ff89:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80ff8c:	8b 52 0c             	mov    0xc(%edx),%edx
  80ff8f:	85 d2                	test   %edx,%edx
  80ff91:	74 35                	je     80ffc8 <write+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80ff93:	83 ec 04             	sub    $0x4,%esp
  80ff96:	ff 75 10             	pushl  0x10(%ebp)
  80ff99:	ff 75 0c             	pushl  0xc(%ebp)
  80ff9c:	50                   	push   %eax
  80ff9d:	ff d2                	call   *%edx
  80ff9f:	83 c4 10             	add    $0x10,%esp
}
  80ffa2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  80ffa5:	c9                   	leave  
  80ffa6:	c3                   	ret    
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  80ffa7:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  80ffac:	8b 40 48             	mov    0x48(%eax),%eax
  80ffaf:	83 ec 04             	sub    $0x4,%esp
  80ffb2:	53                   	push   %ebx
  80ffb3:	50                   	push   %eax
  80ffb4:	68 41 3e 81 00       	push   $0x813e41
  80ffb9:	e8 d1 e7 ff ff       	call   80e78f <cprintf>
		return -E_INVAL;
  80ffbe:	83 c4 10             	add    $0x10,%esp
  80ffc1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80ffc6:	eb da                	jmp    80ffa2 <write+0x55>
		return -E_NOT_SUPP;
  80ffc8:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80ffcd:	eb d3                	jmp    80ffa2 <write+0x55>

0080ffcf <seek>:

int
seek(int fdnum, off_t offset)
{
  80ffcf:	55                   	push   %ebp
  80ffd0:	89 e5                	mov    %esp,%ebp
  80ffd2:	83 ec 20             	sub    $0x20,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80ffd5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ffd8:	50                   	push   %eax
  80ffd9:	ff 75 08             	pushl  0x8(%ebp)
  80ffdc:	e8 30 fc ff ff       	call   80fc11 <fd_lookup>
  80ffe1:	83 c4 10             	add    $0x10,%esp
  80ffe4:	85 c0                	test   %eax,%eax
  80ffe6:	78 0e                	js     80fff6 <seek+0x27>
		return r;
	fd->fd_offset = offset;
  80ffe8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ffeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ffee:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  80fff1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fff6:	c9                   	leave  
  80fff7:	c3                   	ret    

0080fff8 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  80fff8:	55                   	push   %ebp
  80fff9:	89 e5                	mov    %esp,%ebp
  80fffb:	53                   	push   %ebx
  80fffc:	83 ec 1c             	sub    $0x1c,%esp
  80ffff:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  810002:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810005:	50                   	push   %eax
  810006:	53                   	push   %ebx
  810007:	e8 05 fc ff ff       	call   80fc11 <fd_lookup>
  81000c:	83 c4 10             	add    $0x10,%esp
  81000f:	85 c0                	test   %eax,%eax
  810011:	78 37                	js     81004a <ftruncate+0x52>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810013:	83 ec 08             	sub    $0x8,%esp
  810016:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810019:	50                   	push   %eax
  81001a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81001d:	ff 30                	pushl  (%eax)
  81001f:	e8 3d fc ff ff       	call   80fc61 <dev_lookup>
  810024:	83 c4 10             	add    $0x10,%esp
  810027:	85 c0                	test   %eax,%eax
  810029:	78 1f                	js     81004a <ftruncate+0x52>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  81002b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81002e:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810032:	74 1b                	je     81004f <ftruncate+0x57>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  810034:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810037:	8b 52 18             	mov    0x18(%edx),%edx
  81003a:	85 d2                	test   %edx,%edx
  81003c:	74 32                	je     810070 <ftruncate+0x78>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  81003e:	83 ec 08             	sub    $0x8,%esp
  810041:	ff 75 0c             	pushl  0xc(%ebp)
  810044:	50                   	push   %eax
  810045:	ff d2                	call   *%edx
  810047:	83 c4 10             	add    $0x10,%esp
}
  81004a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81004d:	c9                   	leave  
  81004e:	c3                   	ret    
			thisenv->env_id, fdnum);
  81004f:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  810054:	8b 40 48             	mov    0x48(%eax),%eax
  810057:	83 ec 04             	sub    $0x4,%esp
  81005a:	53                   	push   %ebx
  81005b:	50                   	push   %eax
  81005c:	68 04 3e 81 00       	push   $0x813e04
  810061:	e8 29 e7 ff ff       	call   80e78f <cprintf>
		return -E_INVAL;
  810066:	83 c4 10             	add    $0x10,%esp
  810069:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81006e:	eb da                	jmp    81004a <ftruncate+0x52>
		return -E_NOT_SUPP;
  810070:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810075:	eb d3                	jmp    81004a <ftruncate+0x52>

00810077 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810077:	55                   	push   %ebp
  810078:	89 e5                	mov    %esp,%ebp
  81007a:	53                   	push   %ebx
  81007b:	83 ec 1c             	sub    $0x1c,%esp
  81007e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810081:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810084:	50                   	push   %eax
  810085:	ff 75 08             	pushl  0x8(%ebp)
  810088:	e8 84 fb ff ff       	call   80fc11 <fd_lookup>
  81008d:	83 c4 10             	add    $0x10,%esp
  810090:	85 c0                	test   %eax,%eax
  810092:	78 4b                	js     8100df <fstat+0x68>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810094:	83 ec 08             	sub    $0x8,%esp
  810097:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81009a:	50                   	push   %eax
  81009b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81009e:	ff 30                	pushl  (%eax)
  8100a0:	e8 bc fb ff ff       	call   80fc61 <dev_lookup>
  8100a5:	83 c4 10             	add    $0x10,%esp
  8100a8:	85 c0                	test   %eax,%eax
  8100aa:	78 33                	js     8100df <fstat+0x68>
		return r;
	if (!dev->dev_stat)
  8100ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8100af:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  8100b3:	74 2f                	je     8100e4 <fstat+0x6d>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8100b5:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  8100b8:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8100bf:	00 00 00 
	stat->st_isdir = 0;
  8100c2:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8100c9:	00 00 00 
	stat->st_dev = dev;
  8100cc:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8100d2:	83 ec 08             	sub    $0x8,%esp
  8100d5:	53                   	push   %ebx
  8100d6:	ff 75 f0             	pushl  -0x10(%ebp)
  8100d9:	ff 50 14             	call   *0x14(%eax)
  8100dc:	83 c4 10             	add    $0x10,%esp
}
  8100df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8100e2:	c9                   	leave  
  8100e3:	c3                   	ret    
		return -E_NOT_SUPP;
  8100e4:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8100e9:	eb f4                	jmp    8100df <fstat+0x68>

008100eb <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8100eb:	55                   	push   %ebp
  8100ec:	89 e5                	mov    %esp,%ebp
  8100ee:	56                   	push   %esi
  8100ef:	53                   	push   %ebx
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8100f0:	83 ec 08             	sub    $0x8,%esp
  8100f3:	6a 00                	push   $0x0
  8100f5:	ff 75 08             	pushl  0x8(%ebp)
  8100f8:	e8 22 02 00 00       	call   81031f <open>
  8100fd:	89 c3                	mov    %eax,%ebx
  8100ff:	83 c4 10             	add    $0x10,%esp
  810102:	85 c0                	test   %eax,%eax
  810104:	78 1b                	js     810121 <stat+0x36>
		return fd;
	r = fstat(fd, stat);
  810106:	83 ec 08             	sub    $0x8,%esp
  810109:	ff 75 0c             	pushl  0xc(%ebp)
  81010c:	50                   	push   %eax
  81010d:	e8 65 ff ff ff       	call   810077 <fstat>
  810112:	89 c6                	mov    %eax,%esi
	close(fd);
  810114:	89 1c 24             	mov    %ebx,(%esp)
  810117:	e8 27 fc ff ff       	call   80fd43 <close>
	return r;
  81011c:	83 c4 10             	add    $0x10,%esp
  81011f:	89 f3                	mov    %esi,%ebx
}
  810121:	89 d8                	mov    %ebx,%eax
  810123:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810126:	5b                   	pop    %ebx
  810127:	5e                   	pop    %esi
  810128:	5d                   	pop    %ebp
  810129:	c3                   	ret    

0081012a <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  81012a:	55                   	push   %ebp
  81012b:	89 e5                	mov    %esp,%ebp
  81012d:	56                   	push   %esi
  81012e:	53                   	push   %ebx
  81012f:	89 c6                	mov    %eax,%esi
  810131:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  810133:	83 3d cc b1 b3 00 00 	cmpl   $0x0,0xb3b1cc
  81013a:	74 27                	je     810163 <fsipc+0x39>
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  81013c:	6a 07                	push   $0x7
  81013e:	68 00 c0 b3 00       	push   $0xb3c000
  810143:	56                   	push   %esi
  810144:	ff 35 cc b1 b3 00    	pushl  0xb3b1cc
  81014a:	e8 b6 f9 ff ff       	call   80fb05 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  81014f:	83 c4 0c             	add    $0xc,%esp
  810152:	6a 00                	push   $0x0
  810154:	53                   	push   %ebx
  810155:	6a 00                	push   $0x0
  810157:	e8 40 f9 ff ff       	call   80fa9c <ipc_recv>
}
  81015c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  81015f:	5b                   	pop    %ebx
  810160:	5e                   	pop    %esi
  810161:	5d                   	pop    %ebp
  810162:	c3                   	ret    
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810163:	83 ec 0c             	sub    $0xc,%esp
  810166:	6a 01                	push   $0x1
  810168:	e8 f0 f9 ff ff       	call   80fb5d <ipc_find_env>
  81016d:	a3 cc b1 b3 00       	mov    %eax,0xb3b1cc
  810172:	83 c4 10             	add    $0x10,%esp
  810175:	eb c5                	jmp    81013c <fsipc+0x12>

00810177 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  810177:	55                   	push   %ebp
  810178:	89 e5                	mov    %esp,%ebp
  81017a:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  81017d:	8b 45 08             	mov    0x8(%ebp),%eax
  810180:	8b 40 0c             	mov    0xc(%eax),%eax
  810183:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.set_size.req_size = newsize;
  810188:	8b 45 0c             	mov    0xc(%ebp),%eax
  81018b:	a3 04 c0 b3 00       	mov    %eax,0xb3c004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810190:	ba 00 00 00 00       	mov    $0x0,%edx
  810195:	b8 02 00 00 00       	mov    $0x2,%eax
  81019a:	e8 8b ff ff ff       	call   81012a <fsipc>
}
  81019f:	c9                   	leave  
  8101a0:	c3                   	ret    

008101a1 <devfile_flush>:
{
  8101a1:	55                   	push   %ebp
  8101a2:	89 e5                	mov    %esp,%ebp
  8101a4:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  8101a7:	8b 45 08             	mov    0x8(%ebp),%eax
  8101aa:	8b 40 0c             	mov    0xc(%eax),%eax
  8101ad:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	return fsipc(FSREQ_FLUSH, NULL);
  8101b2:	ba 00 00 00 00       	mov    $0x0,%edx
  8101b7:	b8 06 00 00 00       	mov    $0x6,%eax
  8101bc:	e8 69 ff ff ff       	call   81012a <fsipc>
}
  8101c1:	c9                   	leave  
  8101c2:	c3                   	ret    

008101c3 <devfile_stat>:
{
  8101c3:	55                   	push   %ebp
  8101c4:	89 e5                	mov    %esp,%ebp
  8101c6:	53                   	push   %ebx
  8101c7:	83 ec 04             	sub    $0x4,%esp
  8101ca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8101cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8101d0:	8b 40 0c             	mov    0xc(%eax),%eax
  8101d3:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8101d8:	ba 00 00 00 00       	mov    $0x0,%edx
  8101dd:	b8 05 00 00 00       	mov    $0x5,%eax
  8101e2:	e8 43 ff ff ff       	call   81012a <fsipc>
  8101e7:	85 c0                	test   %eax,%eax
  8101e9:	78 2c                	js     810217 <devfile_stat+0x54>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8101eb:	83 ec 08             	sub    $0x8,%esp
  8101ee:	68 00 c0 b3 00       	push   $0xb3c000
  8101f3:	53                   	push   %ebx
  8101f4:	e8 f5 ec ff ff       	call   80eeee <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8101f9:	a1 80 c0 b3 00       	mov    0xb3c080,%eax
  8101fe:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810204:	a1 84 c0 b3 00       	mov    0xb3c084,%eax
  810209:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  81020f:	83 c4 10             	add    $0x10,%esp
  810212:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810217:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  81021a:	c9                   	leave  
  81021b:	c3                   	ret    

0081021c <devfile_write>:
{
  81021c:	55                   	push   %ebp
  81021d:	89 e5                	mov    %esp,%ebp
  81021f:	53                   	push   %ebx
  810220:	83 ec 08             	sub    $0x8,%esp
  810223:	8b 5d 10             	mov    0x10(%ebp),%ebx
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810226:	8b 45 08             	mov    0x8(%ebp),%eax
  810229:	8b 40 0c             	mov    0xc(%eax),%eax
  81022c:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.write.req_n = n;
  810231:	89 1d 04 c0 b3 00    	mov    %ebx,0xb3c004
	memcpy(fsipcbuf.write.req_buf, buf, n);
  810237:	53                   	push   %ebx
  810238:	ff 75 0c             	pushl  0xc(%ebp)
  81023b:	68 08 c0 b3 00       	push   $0xb3c008
  810240:	e8 99 ee ff ff       	call   80f0de <memcpy>
	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  810245:	ba 00 00 00 00       	mov    $0x0,%edx
  81024a:	b8 04 00 00 00       	mov    $0x4,%eax
  81024f:	e8 d6 fe ff ff       	call   81012a <fsipc>
  810254:	83 c4 10             	add    $0x10,%esp
  810257:	85 c0                	test   %eax,%eax
  810259:	78 0b                	js     810266 <devfile_write+0x4a>
	assert(r <= n);
  81025b:	39 d8                	cmp    %ebx,%eax
  81025d:	77 0c                	ja     81026b <devfile_write+0x4f>
	assert(r <= PGSIZE);
  81025f:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810264:	7f 1e                	jg     810284 <devfile_write+0x68>
}
  810266:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810269:	c9                   	leave  
  81026a:	c3                   	ret    
	assert(r <= n);
  81026b:	68 74 3e 81 00       	push   $0x813e74
  810270:	68 8b 2a 81 00       	push   $0x812a8b
  810275:	68 98 00 00 00       	push   $0x98
  81027a:	68 7b 3e 81 00       	push   $0x813e7b
  81027f:	e8 15 e4 ff ff       	call   80e699 <_panic>
	assert(r <= PGSIZE);
  810284:	68 86 3e 81 00       	push   $0x813e86
  810289:	68 8b 2a 81 00       	push   $0x812a8b
  81028e:	68 99 00 00 00       	push   $0x99
  810293:	68 7b 3e 81 00       	push   $0x813e7b
  810298:	e8 fc e3 ff ff       	call   80e699 <_panic>

0081029d <devfile_read>:
{
  81029d:	55                   	push   %ebp
  81029e:	89 e5                	mov    %esp,%ebp
  8102a0:	56                   	push   %esi
  8102a1:	53                   	push   %ebx
  8102a2:	8b 75 10             	mov    0x10(%ebp),%esi
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  8102a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8102a8:	8b 40 0c             	mov    0xc(%eax),%eax
  8102ab:	a3 00 c0 b3 00       	mov    %eax,0xb3c000
	fsipcbuf.read.req_n = n;
  8102b0:	89 35 04 c0 b3 00    	mov    %esi,0xb3c004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  8102b6:	ba 00 00 00 00       	mov    $0x0,%edx
  8102bb:	b8 03 00 00 00       	mov    $0x3,%eax
  8102c0:	e8 65 fe ff ff       	call   81012a <fsipc>
  8102c5:	89 c3                	mov    %eax,%ebx
  8102c7:	85 c0                	test   %eax,%eax
  8102c9:	78 1f                	js     8102ea <devfile_read+0x4d>
	assert(r <= n);
  8102cb:	39 f0                	cmp    %esi,%eax
  8102cd:	77 24                	ja     8102f3 <devfile_read+0x56>
	assert(r <= PGSIZE);
  8102cf:	3d 00 10 00 00       	cmp    $0x1000,%eax
  8102d4:	7f 33                	jg     810309 <devfile_read+0x6c>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  8102d6:	83 ec 04             	sub    $0x4,%esp
  8102d9:	50                   	push   %eax
  8102da:	68 00 c0 b3 00       	push   $0xb3c000
  8102df:	ff 75 0c             	pushl  0xc(%ebp)
  8102e2:	e8 95 ed ff ff       	call   80f07c <memmove>
	return r;
  8102e7:	83 c4 10             	add    $0x10,%esp
}
  8102ea:	89 d8                	mov    %ebx,%eax
  8102ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8102ef:	5b                   	pop    %ebx
  8102f0:	5e                   	pop    %esi
  8102f1:	5d                   	pop    %ebp
  8102f2:	c3                   	ret    
	assert(r <= n);
  8102f3:	68 74 3e 81 00       	push   $0x813e74
  8102f8:	68 8b 2a 81 00       	push   $0x812a8b
  8102fd:	6a 7c                	push   $0x7c
  8102ff:	68 7b 3e 81 00       	push   $0x813e7b
  810304:	e8 90 e3 ff ff       	call   80e699 <_panic>
	assert(r <= PGSIZE);
  810309:	68 86 3e 81 00       	push   $0x813e86
  81030e:	68 8b 2a 81 00       	push   $0x812a8b
  810313:	6a 7d                	push   $0x7d
  810315:	68 7b 3e 81 00       	push   $0x813e7b
  81031a:	e8 7a e3 ff ff       	call   80e699 <_panic>

0081031f <open>:
{
  81031f:	55                   	push   %ebp
  810320:	89 e5                	mov    %esp,%ebp
  810322:	56                   	push   %esi
  810323:	53                   	push   %ebx
  810324:	83 ec 1c             	sub    $0x1c,%esp
  810327:	8b 75 08             	mov    0x8(%ebp),%esi
	if (strlen(path) >= MAXPATHLEN)
  81032a:	56                   	push   %esi
  81032b:	e8 85 eb ff ff       	call   80eeb5 <strlen>
  810330:	83 c4 10             	add    $0x10,%esp
  810333:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  810338:	7f 6c                	jg     8103a6 <open+0x87>
	if ((r = fd_alloc(&fd)) < 0)
  81033a:	83 ec 0c             	sub    $0xc,%esp
  81033d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810340:	50                   	push   %eax
  810341:	e8 79 f8 ff ff       	call   80fbbf <fd_alloc>
  810346:	89 c3                	mov    %eax,%ebx
  810348:	83 c4 10             	add    $0x10,%esp
  81034b:	85 c0                	test   %eax,%eax
  81034d:	78 3c                	js     81038b <open+0x6c>
	strcpy(fsipcbuf.open.req_path, path);
  81034f:	83 ec 08             	sub    $0x8,%esp
  810352:	56                   	push   %esi
  810353:	68 00 c0 b3 00       	push   $0xb3c000
  810358:	e8 91 eb ff ff       	call   80eeee <strcpy>
	fsipcbuf.open.req_omode = mode;
  81035d:	8b 45 0c             	mov    0xc(%ebp),%eax
  810360:	a3 00 c4 b3 00       	mov    %eax,0xb3c400
	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810365:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810368:	b8 01 00 00 00       	mov    $0x1,%eax
  81036d:	e8 b8 fd ff ff       	call   81012a <fsipc>
  810372:	89 c3                	mov    %eax,%ebx
  810374:	83 c4 10             	add    $0x10,%esp
  810377:	85 c0                	test   %eax,%eax
  810379:	78 19                	js     810394 <open+0x75>
	return fd2num(fd);
  81037b:	83 ec 0c             	sub    $0xc,%esp
  81037e:	ff 75 f4             	pushl  -0xc(%ebp)
  810381:	e8 12 f8 ff ff       	call   80fb98 <fd2num>
  810386:	89 c3                	mov    %eax,%ebx
  810388:	83 c4 10             	add    $0x10,%esp
}
  81038b:	89 d8                	mov    %ebx,%eax
  81038d:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810390:	5b                   	pop    %ebx
  810391:	5e                   	pop    %esi
  810392:	5d                   	pop    %ebp
  810393:	c3                   	ret    
		fd_close(fd, 0);
  810394:	83 ec 08             	sub    $0x8,%esp
  810397:	6a 00                	push   $0x0
  810399:	ff 75 f4             	pushl  -0xc(%ebp)
  81039c:	e8 1b f9 ff ff       	call   80fcbc <fd_close>
		return r;
  8103a1:	83 c4 10             	add    $0x10,%esp
  8103a4:	eb e5                	jmp    81038b <open+0x6c>
		return -E_BAD_PATH;
  8103a6:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  8103ab:	eb de                	jmp    81038b <open+0x6c>

008103ad <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  8103ad:	55                   	push   %ebp
  8103ae:	89 e5                	mov    %esp,%ebp
  8103b0:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  8103b3:	ba 00 00 00 00       	mov    $0x0,%edx
  8103b8:	b8 08 00 00 00       	mov    $0x8,%eax
  8103bd:	e8 68 fd ff ff       	call   81012a <fsipc>
}
  8103c2:	c9                   	leave  
  8103c3:	c3                   	ret    

008103c4 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8103c4:	55                   	push   %ebp
  8103c5:	89 e5                	mov    %esp,%ebp
  8103c7:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<sock>");
  8103ca:	68 92 3e 81 00       	push   $0x813e92
  8103cf:	ff 75 0c             	pushl  0xc(%ebp)
  8103d2:	e8 17 eb ff ff       	call   80eeee <strcpy>
	return 0;
}
  8103d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8103dc:	c9                   	leave  
  8103dd:	c3                   	ret    

008103de <devsock_close>:
{
  8103de:	55                   	push   %ebp
  8103df:	89 e5                	mov    %esp,%ebp
  8103e1:	53                   	push   %ebx
  8103e2:	83 ec 10             	sub    $0x10,%esp
  8103e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8103e8:	53                   	push   %ebx
  8103e9:	e8 2e 0c 00 00       	call   81101c <pageref>
  8103ee:	83 c4 10             	add    $0x10,%esp
		return 0;
  8103f1:	ba 00 00 00 00       	mov    $0x0,%edx
	if (pageref(fd) == 1)
  8103f6:	83 f8 01             	cmp    $0x1,%eax
  8103f9:	74 07                	je     810402 <devsock_close+0x24>
}
  8103fb:	89 d0                	mov    %edx,%eax
  8103fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810400:	c9                   	leave  
  810401:	c3                   	ret    
		return nsipc_close(fd->fd_sock.sockid);
  810402:	83 ec 0c             	sub    $0xc,%esp
  810405:	ff 73 0c             	pushl  0xc(%ebx)
  810408:	e8 b9 02 00 00       	call   8106c6 <nsipc_close>
  81040d:	89 c2                	mov    %eax,%edx
  81040f:	83 c4 10             	add    $0x10,%esp
  810412:	eb e7                	jmp    8103fb <devsock_close+0x1d>

00810414 <devsock_write>:
{
  810414:	55                   	push   %ebp
  810415:	89 e5                	mov    %esp,%ebp
  810417:	83 ec 08             	sub    $0x8,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  81041a:	6a 00                	push   $0x0
  81041c:	ff 75 10             	pushl  0x10(%ebp)
  81041f:	ff 75 0c             	pushl  0xc(%ebp)
  810422:	8b 45 08             	mov    0x8(%ebp),%eax
  810425:	ff 70 0c             	pushl  0xc(%eax)
  810428:	e8 76 03 00 00       	call   8107a3 <nsipc_send>
}
  81042d:	c9                   	leave  
  81042e:	c3                   	ret    

0081042f <devsock_read>:
{
  81042f:	55                   	push   %ebp
  810430:	89 e5                	mov    %esp,%ebp
  810432:	83 ec 08             	sub    $0x8,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  810435:	6a 00                	push   $0x0
  810437:	ff 75 10             	pushl  0x10(%ebp)
  81043a:	ff 75 0c             	pushl  0xc(%ebp)
  81043d:	8b 45 08             	mov    0x8(%ebp),%eax
  810440:	ff 70 0c             	pushl  0xc(%eax)
  810443:	e8 ef 02 00 00       	call   810737 <nsipc_recv>
}
  810448:	c9                   	leave  
  810449:	c3                   	ret    

0081044a <fd2sockid>:
{
  81044a:	55                   	push   %ebp
  81044b:	89 e5                	mov    %esp,%ebp
  81044d:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fd, &sfd)) < 0)
  810450:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810453:	52                   	push   %edx
  810454:	50                   	push   %eax
  810455:	e8 b7 f7 ff ff       	call   80fc11 <fd_lookup>
  81045a:	83 c4 10             	add    $0x10,%esp
  81045d:	85 c0                	test   %eax,%eax
  81045f:	78 10                	js     810471 <fd2sockid+0x27>
	if (sfd->fd_dev_id != devsock.dev_id)
  810461:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810464:	8b 0d 08 43 81 00    	mov    0x814308,%ecx
  81046a:	39 08                	cmp    %ecx,(%eax)
  81046c:	75 05                	jne    810473 <fd2sockid+0x29>
	return sfd->fd_sock.sockid;
  81046e:	8b 40 0c             	mov    0xc(%eax),%eax
}
  810471:	c9                   	leave  
  810472:	c3                   	ret    
		return -E_NOT_SUPP;
  810473:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  810478:	eb f7                	jmp    810471 <fd2sockid+0x27>

0081047a <alloc_sockfd>:
{
  81047a:	55                   	push   %ebp
  81047b:	89 e5                	mov    %esp,%ebp
  81047d:	56                   	push   %esi
  81047e:	53                   	push   %ebx
  81047f:	83 ec 1c             	sub    $0x1c,%esp
  810482:	89 c6                	mov    %eax,%esi
	if ((r = fd_alloc(&sfd)) < 0
  810484:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810487:	50                   	push   %eax
  810488:	e8 32 f7 ff ff       	call   80fbbf <fd_alloc>
  81048d:	89 c3                	mov    %eax,%ebx
  81048f:	83 c4 10             	add    $0x10,%esp
  810492:	85 c0                	test   %eax,%eax
  810494:	78 43                	js     8104d9 <alloc_sockfd+0x5f>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810496:	83 ec 04             	sub    $0x4,%esp
  810499:	68 07 04 00 00       	push   $0x407
  81049e:	ff 75 f4             	pushl  -0xc(%ebp)
  8104a1:	6a 00                	push   $0x0
  8104a3:	e8 38 ee ff ff       	call   80f2e0 <sys_page_alloc>
  8104a8:	89 c3                	mov    %eax,%ebx
  8104aa:	83 c4 10             	add    $0x10,%esp
  8104ad:	85 c0                	test   %eax,%eax
  8104af:	78 28                	js     8104d9 <alloc_sockfd+0x5f>
	sfd->fd_dev_id = devsock.dev_id;
  8104b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8104b4:	8b 15 08 43 81 00    	mov    0x814308,%edx
  8104ba:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8104bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8104bf:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8104c6:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8104c9:	83 ec 0c             	sub    $0xc,%esp
  8104cc:	50                   	push   %eax
  8104cd:	e8 c6 f6 ff ff       	call   80fb98 <fd2num>
  8104d2:	89 c3                	mov    %eax,%ebx
  8104d4:	83 c4 10             	add    $0x10,%esp
  8104d7:	eb 0c                	jmp    8104e5 <alloc_sockfd+0x6b>
		nsipc_close(sockid);
  8104d9:	83 ec 0c             	sub    $0xc,%esp
  8104dc:	56                   	push   %esi
  8104dd:	e8 e4 01 00 00       	call   8106c6 <nsipc_close>
		return r;
  8104e2:	83 c4 10             	add    $0x10,%esp
}
  8104e5:	89 d8                	mov    %ebx,%eax
  8104e7:	8d 65 f8             	lea    -0x8(%ebp),%esp
  8104ea:	5b                   	pop    %ebx
  8104eb:	5e                   	pop    %esi
  8104ec:	5d                   	pop    %ebp
  8104ed:	c3                   	ret    

008104ee <accept>:
{
  8104ee:	55                   	push   %ebp
  8104ef:	89 e5                	mov    %esp,%ebp
  8104f1:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  8104f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8104f7:	e8 4e ff ff ff       	call   81044a <fd2sockid>
  8104fc:	85 c0                	test   %eax,%eax
  8104fe:	78 1b                	js     81051b <accept+0x2d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810500:	83 ec 04             	sub    $0x4,%esp
  810503:	ff 75 10             	pushl  0x10(%ebp)
  810506:	ff 75 0c             	pushl  0xc(%ebp)
  810509:	50                   	push   %eax
  81050a:	e8 0e 01 00 00       	call   81061d <nsipc_accept>
  81050f:	83 c4 10             	add    $0x10,%esp
  810512:	85 c0                	test   %eax,%eax
  810514:	78 05                	js     81051b <accept+0x2d>
	return alloc_sockfd(r);
  810516:	e8 5f ff ff ff       	call   81047a <alloc_sockfd>
}
  81051b:	c9                   	leave  
  81051c:	c3                   	ret    

0081051d <bind>:
{
  81051d:	55                   	push   %ebp
  81051e:	89 e5                	mov    %esp,%ebp
  810520:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810523:	8b 45 08             	mov    0x8(%ebp),%eax
  810526:	e8 1f ff ff ff       	call   81044a <fd2sockid>
  81052b:	85 c0                	test   %eax,%eax
  81052d:	78 12                	js     810541 <bind+0x24>
	return nsipc_bind(r, name, namelen);
  81052f:	83 ec 04             	sub    $0x4,%esp
  810532:	ff 75 10             	pushl  0x10(%ebp)
  810535:	ff 75 0c             	pushl  0xc(%ebp)
  810538:	50                   	push   %eax
  810539:	e8 31 01 00 00       	call   81066f <nsipc_bind>
  81053e:	83 c4 10             	add    $0x10,%esp
}
  810541:	c9                   	leave  
  810542:	c3                   	ret    

00810543 <shutdown>:
{
  810543:	55                   	push   %ebp
  810544:	89 e5                	mov    %esp,%ebp
  810546:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810549:	8b 45 08             	mov    0x8(%ebp),%eax
  81054c:	e8 f9 fe ff ff       	call   81044a <fd2sockid>
  810551:	85 c0                	test   %eax,%eax
  810553:	78 0f                	js     810564 <shutdown+0x21>
	return nsipc_shutdown(r, how);
  810555:	83 ec 08             	sub    $0x8,%esp
  810558:	ff 75 0c             	pushl  0xc(%ebp)
  81055b:	50                   	push   %eax
  81055c:	e8 43 01 00 00       	call   8106a4 <nsipc_shutdown>
  810561:	83 c4 10             	add    $0x10,%esp
}
  810564:	c9                   	leave  
  810565:	c3                   	ret    

00810566 <connect>:
{
  810566:	55                   	push   %ebp
  810567:	89 e5                	mov    %esp,%ebp
  810569:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  81056c:	8b 45 08             	mov    0x8(%ebp),%eax
  81056f:	e8 d6 fe ff ff       	call   81044a <fd2sockid>
  810574:	85 c0                	test   %eax,%eax
  810576:	78 12                	js     81058a <connect+0x24>
	return nsipc_connect(r, name, namelen);
  810578:	83 ec 04             	sub    $0x4,%esp
  81057b:	ff 75 10             	pushl  0x10(%ebp)
  81057e:	ff 75 0c             	pushl  0xc(%ebp)
  810581:	50                   	push   %eax
  810582:	e8 59 01 00 00       	call   8106e0 <nsipc_connect>
  810587:	83 c4 10             	add    $0x10,%esp
}
  81058a:	c9                   	leave  
  81058b:	c3                   	ret    

0081058c <listen>:
{
  81058c:	55                   	push   %ebp
  81058d:	89 e5                	mov    %esp,%ebp
  81058f:	83 ec 08             	sub    $0x8,%esp
	if ((r = fd2sockid(s)) < 0)
  810592:	8b 45 08             	mov    0x8(%ebp),%eax
  810595:	e8 b0 fe ff ff       	call   81044a <fd2sockid>
  81059a:	85 c0                	test   %eax,%eax
  81059c:	78 0f                	js     8105ad <listen+0x21>
	return nsipc_listen(r, backlog);
  81059e:	83 ec 08             	sub    $0x8,%esp
  8105a1:	ff 75 0c             	pushl  0xc(%ebp)
  8105a4:	50                   	push   %eax
  8105a5:	e8 6b 01 00 00       	call   810715 <nsipc_listen>
  8105aa:	83 c4 10             	add    $0x10,%esp
}
  8105ad:	c9                   	leave  
  8105ae:	c3                   	ret    

008105af <socket>:

int
socket(int domain, int type, int protocol)
{
  8105af:	55                   	push   %ebp
  8105b0:	89 e5                	mov    %esp,%ebp
  8105b2:	83 ec 0c             	sub    $0xc,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8105b5:	ff 75 10             	pushl  0x10(%ebp)
  8105b8:	ff 75 0c             	pushl  0xc(%ebp)
  8105bb:	ff 75 08             	pushl  0x8(%ebp)
  8105be:	e8 3e 02 00 00       	call   810801 <nsipc_socket>
  8105c3:	83 c4 10             	add    $0x10,%esp
  8105c6:	85 c0                	test   %eax,%eax
  8105c8:	78 05                	js     8105cf <socket+0x20>
		return r;
	return alloc_sockfd(r);
  8105ca:	e8 ab fe ff ff       	call   81047a <alloc_sockfd>
}
  8105cf:	c9                   	leave  
  8105d0:	c3                   	ret    

008105d1 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8105d1:	55                   	push   %ebp
  8105d2:	89 e5                	mov    %esp,%ebp
  8105d4:	53                   	push   %ebx
  8105d5:	83 ec 04             	sub    $0x4,%esp
  8105d8:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8105da:	83 3d d0 b1 b3 00 00 	cmpl   $0x0,0xb3b1d0
  8105e1:	74 26                	je     810609 <nsipc+0x38>
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8105e3:	6a 07                	push   $0x7
  8105e5:	68 00 d0 b3 00       	push   $0xb3d000
  8105ea:	53                   	push   %ebx
  8105eb:	ff 35 d0 b1 b3 00    	pushl  0xb3b1d0
  8105f1:	e8 0f f5 ff ff       	call   80fb05 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  8105f6:	83 c4 0c             	add    $0xc,%esp
  8105f9:	6a 00                	push   $0x0
  8105fb:	6a 00                	push   $0x0
  8105fd:	6a 00                	push   $0x0
  8105ff:	e8 98 f4 ff ff       	call   80fa9c <ipc_recv>
}
  810604:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810607:	c9                   	leave  
  810608:	c3                   	ret    
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810609:	83 ec 0c             	sub    $0xc,%esp
  81060c:	6a 02                	push   $0x2
  81060e:	e8 4a f5 ff ff       	call   80fb5d <ipc_find_env>
  810613:	a3 d0 b1 b3 00       	mov    %eax,0xb3b1d0
  810618:	83 c4 10             	add    $0x10,%esp
  81061b:	eb c6                	jmp    8105e3 <nsipc+0x12>

0081061d <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  81061d:	55                   	push   %ebp
  81061e:	89 e5                	mov    %esp,%ebp
  810620:	56                   	push   %esi
  810621:	53                   	push   %ebx
  810622:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810625:	8b 45 08             	mov    0x8(%ebp),%eax
  810628:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.accept.req_addrlen = *addrlen;
  81062d:	8b 06                	mov    (%esi),%eax
  81062f:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  810634:	b8 01 00 00 00       	mov    $0x1,%eax
  810639:	e8 93 ff ff ff       	call   8105d1 <nsipc>
  81063e:	89 c3                	mov    %eax,%ebx
  810640:	85 c0                	test   %eax,%eax
  810642:	79 09                	jns    81064d <nsipc_accept+0x30>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
		*addrlen = ret->ret_addrlen;
	}
	return r;
}
  810644:	89 d8                	mov    %ebx,%eax
  810646:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810649:	5b                   	pop    %ebx
  81064a:	5e                   	pop    %esi
  81064b:	5d                   	pop    %ebp
  81064c:	c3                   	ret    
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  81064d:	83 ec 04             	sub    $0x4,%esp
  810650:	ff 35 10 d0 b3 00    	pushl  0xb3d010
  810656:	68 00 d0 b3 00       	push   $0xb3d000
  81065b:	ff 75 0c             	pushl  0xc(%ebp)
  81065e:	e8 19 ea ff ff       	call   80f07c <memmove>
		*addrlen = ret->ret_addrlen;
  810663:	a1 10 d0 b3 00       	mov    0xb3d010,%eax
  810668:	89 06                	mov    %eax,(%esi)
  81066a:	83 c4 10             	add    $0x10,%esp
	return r;
  81066d:	eb d5                	jmp    810644 <nsipc_accept+0x27>

0081066f <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  81066f:	55                   	push   %ebp
  810670:	89 e5                	mov    %esp,%ebp
  810672:	53                   	push   %ebx
  810673:	83 ec 08             	sub    $0x8,%esp
  810676:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  810679:	8b 45 08             	mov    0x8(%ebp),%eax
  81067c:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  810681:	53                   	push   %ebx
  810682:	ff 75 0c             	pushl  0xc(%ebp)
  810685:	68 04 d0 b3 00       	push   $0xb3d004
  81068a:	e8 ed e9 ff ff       	call   80f07c <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  81068f:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_BIND);
  810695:	b8 02 00 00 00       	mov    $0x2,%eax
  81069a:	e8 32 ff ff ff       	call   8105d1 <nsipc>
}
  81069f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8106a2:	c9                   	leave  
  8106a3:	c3                   	ret    

008106a4 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  8106a4:	55                   	push   %ebp
  8106a5:	89 e5                	mov    %esp,%ebp
  8106a7:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  8106aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8106ad:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.shutdown.req_how = how;
  8106b2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106b5:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_SHUTDOWN);
  8106ba:	b8 03 00 00 00       	mov    $0x3,%eax
  8106bf:	e8 0d ff ff ff       	call   8105d1 <nsipc>
}
  8106c4:	c9                   	leave  
  8106c5:	c3                   	ret    

008106c6 <nsipc_close>:

int
nsipc_close(int s)
{
  8106c6:	55                   	push   %ebp
  8106c7:	89 e5                	mov    %esp,%ebp
  8106c9:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  8106cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8106cf:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return nsipc(NSREQ_CLOSE);
  8106d4:	b8 04 00 00 00       	mov    $0x4,%eax
  8106d9:	e8 f3 fe ff ff       	call   8105d1 <nsipc>
}
  8106de:	c9                   	leave  
  8106df:	c3                   	ret    

008106e0 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8106e0:	55                   	push   %ebp
  8106e1:	89 e5                	mov    %esp,%ebp
  8106e3:	53                   	push   %ebx
  8106e4:	83 ec 08             	sub    $0x8,%esp
  8106e7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  8106ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8106ed:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8106f2:	53                   	push   %ebx
  8106f3:	ff 75 0c             	pushl  0xc(%ebp)
  8106f6:	68 04 d0 b3 00       	push   $0xb3d004
  8106fb:	e8 7c e9 ff ff       	call   80f07c <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  810700:	89 1d 14 d0 b3 00    	mov    %ebx,0xb3d014
	return nsipc(NSREQ_CONNECT);
  810706:	b8 05 00 00 00       	mov    $0x5,%eax
  81070b:	e8 c1 fe ff ff       	call   8105d1 <nsipc>
}
  810710:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810713:	c9                   	leave  
  810714:	c3                   	ret    

00810715 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  810715:	55                   	push   %ebp
  810716:	89 e5                	mov    %esp,%ebp
  810718:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  81071b:	8b 45 08             	mov    0x8(%ebp),%eax
  81071e:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.listen.req_backlog = backlog;
  810723:	8b 45 0c             	mov    0xc(%ebp),%eax
  810726:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return nsipc(NSREQ_LISTEN);
  81072b:	b8 06 00 00 00       	mov    $0x6,%eax
  810730:	e8 9c fe ff ff       	call   8105d1 <nsipc>
}
  810735:	c9                   	leave  
  810736:	c3                   	ret    

00810737 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  810737:	55                   	push   %ebp
  810738:	89 e5                	mov    %esp,%ebp
  81073a:	56                   	push   %esi
  81073b:	53                   	push   %ebx
  81073c:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  81073f:	8b 45 08             	mov    0x8(%ebp),%eax
  810742:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.recv.req_len = len;
  810747:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	nsipcbuf.recv.req_flags = flags;
  81074d:	8b 45 14             	mov    0x14(%ebp),%eax
  810750:	a3 08 d0 b3 00       	mov    %eax,0xb3d008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  810755:	b8 07 00 00 00       	mov    $0x7,%eax
  81075a:	e8 72 fe ff ff       	call   8105d1 <nsipc>
  81075f:	89 c3                	mov    %eax,%ebx
  810761:	85 c0                	test   %eax,%eax
  810763:	78 1f                	js     810784 <nsipc_recv+0x4d>
		assert(r < 1600 && r <= len);
  810765:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  81076a:	7f 21                	jg     81078d <nsipc_recv+0x56>
  81076c:	39 c6                	cmp    %eax,%esi
  81076e:	7c 1d                	jl     81078d <nsipc_recv+0x56>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  810770:	83 ec 04             	sub    $0x4,%esp
  810773:	50                   	push   %eax
  810774:	68 00 d0 b3 00       	push   $0xb3d000
  810779:	ff 75 0c             	pushl  0xc(%ebp)
  81077c:	e8 fb e8 ff ff       	call   80f07c <memmove>
  810781:	83 c4 10             	add    $0x10,%esp
	}

	return r;
}
  810784:	89 d8                	mov    %ebx,%eax
  810786:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810789:	5b                   	pop    %ebx
  81078a:	5e                   	pop    %esi
  81078b:	5d                   	pop    %ebp
  81078c:	c3                   	ret    
		assert(r < 1600 && r <= len);
  81078d:	68 9e 3e 81 00       	push   $0x813e9e
  810792:	68 8b 2a 81 00       	push   $0x812a8b
  810797:	6a 62                	push   $0x62
  810799:	68 b3 3e 81 00       	push   $0x813eb3
  81079e:	e8 f6 de ff ff       	call   80e699 <_panic>

008107a3 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  8107a3:	55                   	push   %ebp
  8107a4:	89 e5                	mov    %esp,%ebp
  8107a6:	53                   	push   %ebx
  8107a7:	83 ec 04             	sub    $0x4,%esp
  8107aa:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8107ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8107b0:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	assert(size < 1600);
  8107b5:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8107bb:	7f 2e                	jg     8107eb <nsipc_send+0x48>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8107bd:	83 ec 04             	sub    $0x4,%esp
  8107c0:	53                   	push   %ebx
  8107c1:	ff 75 0c             	pushl  0xc(%ebp)
  8107c4:	68 0c d0 b3 00       	push   $0xb3d00c
  8107c9:	e8 ae e8 ff ff       	call   80f07c <memmove>
	nsipcbuf.send.req_size = size;
  8107ce:	89 1d 04 d0 b3 00    	mov    %ebx,0xb3d004
	nsipcbuf.send.req_flags = flags;
  8107d4:	8b 45 14             	mov    0x14(%ebp),%eax
  8107d7:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SEND);
  8107dc:	b8 08 00 00 00       	mov    $0x8,%eax
  8107e1:	e8 eb fd ff ff       	call   8105d1 <nsipc>
}
  8107e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8107e9:	c9                   	leave  
  8107ea:	c3                   	ret    
	assert(size < 1600);
  8107eb:	68 bf 3e 81 00       	push   $0x813ebf
  8107f0:	68 8b 2a 81 00       	push   $0x812a8b
  8107f5:	6a 6d                	push   $0x6d
  8107f7:	68 b3 3e 81 00       	push   $0x813eb3
  8107fc:	e8 98 de ff ff       	call   80e699 <_panic>

00810801 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  810801:	55                   	push   %ebp
  810802:	89 e5                	mov    %esp,%ebp
  810804:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  810807:	8b 45 08             	mov    0x8(%ebp),%eax
  81080a:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	nsipcbuf.socket.req_type = type;
  81080f:	8b 45 0c             	mov    0xc(%ebp),%eax
  810812:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	nsipcbuf.socket.req_protocol = protocol;
  810817:	8b 45 10             	mov    0x10(%ebp),%eax
  81081a:	a3 08 d0 b3 00       	mov    %eax,0xb3d008
	return nsipc(NSREQ_SOCKET);
  81081f:	b8 09 00 00 00       	mov    $0x9,%eax
  810824:	e8 a8 fd ff ff       	call   8105d1 <nsipc>
}
  810829:	c9                   	leave  
  81082a:	c3                   	ret    

0081082b <free>:
	return v;
}

void
free(void *v)
{
  81082b:	55                   	push   %ebp
  81082c:	89 e5                	mov    %esp,%ebp
  81082e:	53                   	push   %ebx
  81082f:	83 ec 04             	sub    $0x4,%esp
  810832:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  810835:	85 db                	test   %ebx,%ebx
  810837:	0f 84 85 00 00 00    	je     8108c2 <free+0x97>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81083d:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810843:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810848:	77 51                	ja     81089b <free+0x70>

	c = ROUNDDOWN(v, PGSIZE);
  81084a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  810850:	89 d8                	mov    %ebx,%eax
  810852:	c1 e8 0c             	shr    $0xc,%eax
  810855:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  81085c:	f6 c4 02             	test   $0x2,%ah
  81085f:	74 50                	je     8108b1 <free+0x86>
		sys_page_unmap(0, c);
  810861:	83 ec 08             	sub    $0x8,%esp
  810864:	53                   	push   %ebx
  810865:	6a 00                	push   $0x0
  810867:	e8 f9 ea ff ff       	call   80f365 <sys_page_unmap>
		c += PGSIZE;
  81086c:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  810872:	8d 83 00 00 00 f8    	lea    -0x8000000(%ebx),%eax
  810878:	83 c4 10             	add    $0x10,%esp
  81087b:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
  810880:	76 ce                	jbe    810850 <free+0x25>
  810882:	68 07 3f 81 00       	push   $0x813f07
  810887:	68 8b 2a 81 00       	push   $0x812a8b
  81088c:	68 81 00 00 00       	push   $0x81
  810891:	68 fa 3e 81 00       	push   $0x813efa
  810896:	e8 fe dd ff ff       	call   80e699 <_panic>
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  81089b:	68 cc 3e 81 00       	push   $0x813ecc
  8108a0:	68 8b 2a 81 00       	push   $0x812a8b
  8108a5:	6a 7a                	push   $0x7a
  8108a7:	68 fa 3e 81 00       	push   $0x813efa
  8108ac:	e8 e8 dd ff ff       	call   80e699 <_panic>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8108b1:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8108b7:	83 e8 01             	sub    $0x1,%eax
  8108ba:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8108c0:	74 05                	je     8108c7 <free+0x9c>
		sys_page_unmap(0, c);
}
  8108c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  8108c5:	c9                   	leave  
  8108c6:	c3                   	ret    
		sys_page_unmap(0, c);
  8108c7:	83 ec 08             	sub    $0x8,%esp
  8108ca:	53                   	push   %ebx
  8108cb:	6a 00                	push   $0x0
  8108cd:	e8 93 ea ff ff       	call   80f365 <sys_page_unmap>
  8108d2:	83 c4 10             	add    $0x10,%esp
  8108d5:	eb eb                	jmp    8108c2 <free+0x97>

008108d7 <malloc>:
{
  8108d7:	55                   	push   %ebp
  8108d8:	89 e5                	mov    %esp,%ebp
  8108da:	57                   	push   %edi
  8108db:	56                   	push   %esi
  8108dc:	53                   	push   %ebx
  8108dd:	83 ec 1c             	sub    $0x1c,%esp
	if (mptr == 0)
  8108e0:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  8108e5:	85 c0                	test   %eax,%eax
  8108e7:	74 74                	je     81095d <malloc+0x86>
	n = ROUNDUP(n, 4);
  8108e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8108ec:	8d 51 03             	lea    0x3(%ecx),%edx
  8108ef:	83 e2 fc             	and    $0xfffffffc,%edx
  8108f2:	89 d6                	mov    %edx,%esi
  8108f4:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  8108f7:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  8108fd:	0f 87 55 01 00 00    	ja     810a58 <malloc+0x181>
	if ((uintptr_t) mptr % PGSIZE){
  810903:	89 c1                	mov    %eax,%ecx
  810905:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81090a:	74 30                	je     81093c <malloc+0x65>
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  81090c:	89 c3                	mov    %eax,%ebx
  81090e:	c1 eb 0c             	shr    $0xc,%ebx
  810911:	8d 54 10 03          	lea    0x3(%eax,%edx,1),%edx
  810915:	c1 ea 0c             	shr    $0xc,%edx
  810918:	39 d3                	cmp    %edx,%ebx
  81091a:	74 64                	je     810980 <malloc+0xa9>
		free(mptr);	/* drop reference to this page */
  81091c:	83 ec 0c             	sub    $0xc,%esp
  81091f:	50                   	push   %eax
  810920:	e8 06 ff ff ff       	call   81082b <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  810925:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
  81092a:	05 00 10 00 00       	add    $0x1000,%eax
  81092f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810934:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
  810939:	83 c4 10             	add    $0x10,%esp
  81093c:	8b 15 d4 b1 b3 00    	mov    0xb3b1d4,%edx
{
  810942:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%ebp)
  810949:	be 00 00 00 00       	mov    $0x0,%esi
		if (isfree(mptr, n + 4))
  81094e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810951:	8d 78 04             	lea    0x4(%eax),%edi
  810954:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
  810958:	e9 86 00 00 00       	jmp    8109e3 <malloc+0x10c>
		mptr = mbegin;
  81095d:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810964:	00 00 08 
	n = ROUNDUP(n, 4);
  810967:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81096a:	8d 51 03             	lea    0x3(%ecx),%edx
  81096d:	83 e2 fc             	and    $0xfffffffc,%edx
  810970:	89 55 dc             	mov    %edx,-0x24(%ebp)
	if (n >= MAXMALLOC)
  810973:	81 fa ff ff 0f 00    	cmp    $0xfffff,%edx
  810979:	76 c1                	jbe    81093c <malloc+0x65>
  81097b:	e9 fd 00 00 00       	jmp    810a7d <malloc+0x1a6>
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  810980:	81 c1 ff 0f 00 00    	add    $0xfff,%ecx
  810986:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
			(*ref)++;
  81098c:	83 41 fc 01          	addl   $0x1,-0x4(%ecx)
			mptr += n;
  810990:	89 f2                	mov    %esi,%edx
  810992:	01 c2                	add    %eax,%edx
  810994:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
			return v;
  81099a:	e9 de 00 00 00       	jmp    810a7d <malloc+0x1a6>
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  81099f:	05 00 10 00 00       	add    $0x1000,%eax
  8109a4:	39 c8                	cmp    %ecx,%eax
  8109a6:	73 66                	jae    810a0e <malloc+0x137>
		if (va >= (uintptr_t) mend
  8109a8:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8109ad:	77 22                	ja     8109d1 <malloc+0xfa>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8109af:	89 c3                	mov    %eax,%ebx
  8109b1:	c1 eb 16             	shr    $0x16,%ebx
  8109b4:	8b 1c 9d 00 d0 7b ef 	mov    -0x10843000(,%ebx,4),%ebx
  8109bb:	f6 c3 01             	test   $0x1,%bl
  8109be:	74 df                	je     81099f <malloc+0xc8>
  8109c0:	89 c3                	mov    %eax,%ebx
  8109c2:	c1 eb 0c             	shr    $0xc,%ebx
  8109c5:	8b 1c 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%ebx
  8109cc:	f6 c3 01             	test   $0x1,%bl
  8109cf:	74 ce                	je     81099f <malloc+0xc8>
  8109d1:	81 c2 00 10 00 00    	add    $0x1000,%edx
  8109d7:	0f b6 75 e3          	movzbl -0x1d(%ebp),%esi
		if (mptr == mend) {
  8109db:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  8109e1:	74 0a                	je     8109ed <malloc+0x116>
  8109e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8109e6:	89 d0                	mov    %edx,%eax
  8109e8:	8d 0c 17             	lea    (%edi,%edx,1),%ecx
  8109eb:	eb b7                	jmp    8109a4 <malloc+0xcd>
			mptr = mbegin;
  8109ed:	ba 00 00 00 08       	mov    $0x8000000,%edx
  8109f2:	be 01 00 00 00       	mov    $0x1,%esi
			if (++nwrap == 2)
  8109f7:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  8109fb:	75 e6                	jne    8109e3 <malloc+0x10c>
  8109fd:	c7 05 d4 b1 b3 00 00 	movl   $0x8000000,0xb3b1d4
  810a04:	00 00 08 
				return 0;	/* out of address space */
  810a07:	b8 00 00 00 00       	mov    $0x0,%eax
  810a0c:	eb 6f                	jmp    810a7d <malloc+0x1a6>
  810a0e:	89 f0                	mov    %esi,%eax
  810a10:	84 c0                	test   %al,%al
  810a12:	74 08                	je     810a1c <malloc+0x145>
  810a14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810a17:	a3 d4 b1 b3 00       	mov    %eax,0xb3b1d4
	for (i = 0; i < n + 4; i += PGSIZE){
  810a1c:	bb 00 00 00 00       	mov    $0x0,%ebx
  810a21:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  810a24:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  810a2a:	39 f7                	cmp    %esi,%edi
  810a2c:	76 57                	jbe    810a85 <malloc+0x1ae>
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810a2e:	83 ec 04             	sub    $0x4,%esp
  810a31:	68 07 02 00 00       	push   $0x207
  810a36:	89 d8                	mov    %ebx,%eax
  810a38:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810a3e:	50                   	push   %eax
  810a3f:	6a 00                	push   $0x0
  810a41:	e8 9a e8 ff ff       	call   80f2e0 <sys_page_alloc>
  810a46:	83 c4 10             	add    $0x10,%esp
  810a49:	85 c0                	test   %eax,%eax
  810a4b:	78 55                	js     810aa2 <malloc+0x1cb>
	for (i = 0; i < n + 4; i += PGSIZE){
  810a4d:	89 f3                	mov    %esi,%ebx
  810a4f:	eb d0                	jmp    810a21 <malloc+0x14a>
			return 0;	/* out of physical memory */
  810a51:	b8 00 00 00 00       	mov    $0x0,%eax
  810a56:	eb 25                	jmp    810a7d <malloc+0x1a6>
		return 0;
  810a58:	b8 00 00 00 00       	mov    $0x0,%eax
  810a5d:	eb 1e                	jmp    810a7d <malloc+0x1a6>
	ref = (uint32_t*) (mptr + i - 4);
  810a5f:	a1 d4 b1 b3 00       	mov    0xb3b1d4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  810a64:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810a67:	c7 84 08 fc 0f 00 00 	movl   $0x2,0xffc(%eax,%ecx,1)
  810a6e:	02 00 00 00 
	mptr += n;
  810a72:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810a75:	01 c2                	add    %eax,%edx
  810a77:	89 15 d4 b1 b3 00    	mov    %edx,0xb3b1d4
}
  810a7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810a80:	5b                   	pop    %ebx
  810a81:	5e                   	pop    %esi
  810a82:	5f                   	pop    %edi
  810a83:	5d                   	pop    %ebp
  810a84:	c3                   	ret    
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  810a85:	83 ec 04             	sub    $0x4,%esp
  810a88:	6a 07                	push   $0x7
  810a8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  810a8d:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810a93:	50                   	push   %eax
  810a94:	6a 00                	push   $0x0
  810a96:	e8 45 e8 ff ff       	call   80f2e0 <sys_page_alloc>
  810a9b:	83 c4 10             	add    $0x10,%esp
  810a9e:	85 c0                	test   %eax,%eax
  810aa0:	79 bd                	jns    810a5f <malloc+0x188>
			for (; i >= 0; i -= PGSIZE)
  810aa2:	85 db                	test   %ebx,%ebx
  810aa4:	78 ab                	js     810a51 <malloc+0x17a>
				sys_page_unmap(0, mptr + i);
  810aa6:	83 ec 08             	sub    $0x8,%esp
  810aa9:	89 d8                	mov    %ebx,%eax
  810aab:	03 05 d4 b1 b3 00    	add    0xb3b1d4,%eax
  810ab1:	50                   	push   %eax
  810ab2:	6a 00                	push   $0x0
  810ab4:	e8 ac e8 ff ff       	call   80f365 <sys_page_unmap>
			for (; i >= 0; i -= PGSIZE)
  810ab9:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  810abf:	83 c4 10             	add    $0x10,%esp
  810ac2:	eb de                	jmp    810aa2 <malloc+0x1cb>

00810ac4 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  810ac4:	55                   	push   %ebp
  810ac5:	89 e5                	mov    %esp,%ebp
  810ac7:	56                   	push   %esi
  810ac8:	53                   	push   %ebx
  810ac9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  810acc:	83 ec 0c             	sub    $0xc,%esp
  810acf:	ff 75 08             	pushl  0x8(%ebp)
  810ad2:	e8 d1 f0 ff ff       	call   80fba8 <fd2data>
  810ad7:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  810ad9:	83 c4 08             	add    $0x8,%esp
  810adc:	68 1f 3f 81 00       	push   $0x813f1f
  810ae1:	53                   	push   %ebx
  810ae2:	e8 07 e4 ff ff       	call   80eeee <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  810ae7:	8b 46 04             	mov    0x4(%esi),%eax
  810aea:	2b 06                	sub    (%esi),%eax
  810aec:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  810af2:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  810af9:	00 00 00 
	stat->st_dev = &devpipe;
  810afc:	c7 83 88 00 00 00 24 	movl   $0x814324,0x88(%ebx)
  810b03:	43 81 00 
	return 0;
}
  810b06:	b8 00 00 00 00       	mov    $0x0,%eax
  810b0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810b0e:	5b                   	pop    %ebx
  810b0f:	5e                   	pop    %esi
  810b10:	5d                   	pop    %ebp
  810b11:	c3                   	ret    

00810b12 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  810b12:	55                   	push   %ebp
  810b13:	89 e5                	mov    %esp,%ebp
  810b15:	53                   	push   %ebx
  810b16:	83 ec 0c             	sub    $0xc,%esp
  810b19:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  810b1c:	53                   	push   %ebx
  810b1d:	6a 00                	push   $0x0
  810b1f:	e8 41 e8 ff ff       	call   80f365 <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  810b24:	89 1c 24             	mov    %ebx,(%esp)
  810b27:	e8 7c f0 ff ff       	call   80fba8 <fd2data>
  810b2c:	83 c4 08             	add    $0x8,%esp
  810b2f:	50                   	push   %eax
  810b30:	6a 00                	push   $0x0
  810b32:	e8 2e e8 ff ff       	call   80f365 <sys_page_unmap>
}
  810b37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  810b3a:	c9                   	leave  
  810b3b:	c3                   	ret    

00810b3c <_pipeisclosed>:
{
  810b3c:	55                   	push   %ebp
  810b3d:	89 e5                	mov    %esp,%ebp
  810b3f:	57                   	push   %edi
  810b40:	56                   	push   %esi
  810b41:	53                   	push   %ebx
  810b42:	83 ec 1c             	sub    $0x1c,%esp
  810b45:	89 c7                	mov    %eax,%edi
  810b47:	89 d6                	mov    %edx,%esi
		n = thisenv->env_runs;
  810b49:	a1 5c b2 b3 00       	mov    0xb3b25c,%eax
  810b4e:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  810b51:	83 ec 0c             	sub    $0xc,%esp
  810b54:	57                   	push   %edi
  810b55:	e8 c2 04 00 00       	call   81101c <pageref>
  810b5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  810b5d:	89 34 24             	mov    %esi,(%esp)
  810b60:	e8 b7 04 00 00       	call   81101c <pageref>
		nn = thisenv->env_runs;
  810b65:	8b 15 5c b2 b3 00    	mov    0xb3b25c,%edx
  810b6b:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  810b6e:	83 c4 10             	add    $0x10,%esp
  810b71:	39 cb                	cmp    %ecx,%ebx
  810b73:	74 1b                	je     810b90 <_pipeisclosed+0x54>
		if (n != nn && ret == 1)
  810b75:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810b78:	75 cf                	jne    810b49 <_pipeisclosed+0xd>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  810b7a:	8b 42 58             	mov    0x58(%edx),%eax
  810b7d:	6a 01                	push   $0x1
  810b7f:	50                   	push   %eax
  810b80:	53                   	push   %ebx
  810b81:	68 26 3f 81 00       	push   $0x813f26
  810b86:	e8 04 dc ff ff       	call   80e78f <cprintf>
  810b8b:	83 c4 10             	add    $0x10,%esp
  810b8e:	eb b9                	jmp    810b49 <_pipeisclosed+0xd>
		ret = pageref(fd) == pageref(p);
  810b90:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
  810b93:	0f 94 c0             	sete   %al
  810b96:	0f b6 c0             	movzbl %al,%eax
}
  810b99:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810b9c:	5b                   	pop    %ebx
  810b9d:	5e                   	pop    %esi
  810b9e:	5f                   	pop    %edi
  810b9f:	5d                   	pop    %ebp
  810ba0:	c3                   	ret    

00810ba1 <devpipe_write>:
{
  810ba1:	55                   	push   %ebp
  810ba2:	89 e5                	mov    %esp,%ebp
  810ba4:	57                   	push   %edi
  810ba5:	56                   	push   %esi
  810ba6:	53                   	push   %ebx
  810ba7:	83 ec 28             	sub    $0x28,%esp
  810baa:	8b 75 08             	mov    0x8(%ebp),%esi
	p = (struct Pipe*) fd2data(fd);
  810bad:	56                   	push   %esi
  810bae:	e8 f5 ef ff ff       	call   80fba8 <fd2data>
  810bb3:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810bb5:	83 c4 10             	add    $0x10,%esp
  810bb8:	bf 00 00 00 00       	mov    $0x0,%edi
  810bbd:	3b 7d 10             	cmp    0x10(%ebp),%edi
  810bc0:	74 4f                	je     810c11 <devpipe_write+0x70>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  810bc2:	8b 43 04             	mov    0x4(%ebx),%eax
  810bc5:	8b 0b                	mov    (%ebx),%ecx
  810bc7:	8d 51 20             	lea    0x20(%ecx),%edx
  810bca:	39 d0                	cmp    %edx,%eax
  810bcc:	72 14                	jb     810be2 <devpipe_write+0x41>
			if (_pipeisclosed(fd, p))
  810bce:	89 da                	mov    %ebx,%edx
  810bd0:	89 f0                	mov    %esi,%eax
  810bd2:	e8 65 ff ff ff       	call   810b3c <_pipeisclosed>
  810bd7:	85 c0                	test   %eax,%eax
  810bd9:	75 3b                	jne    810c16 <devpipe_write+0x75>
			sys_yield();
  810bdb:	e8 e1 e6 ff ff       	call   80f2c1 <sys_yield>
  810be0:	eb e0                	jmp    810bc2 <devpipe_write+0x21>
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  810be2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810be5:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  810be9:	88 4d e7             	mov    %cl,-0x19(%ebp)
  810bec:	89 c2                	mov    %eax,%edx
  810bee:	c1 fa 1f             	sar    $0x1f,%edx
  810bf1:	89 d1                	mov    %edx,%ecx
  810bf3:	c1 e9 1b             	shr    $0x1b,%ecx
  810bf6:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  810bf9:	83 e2 1f             	and    $0x1f,%edx
  810bfc:	29 ca                	sub    %ecx,%edx
  810bfe:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
  810c02:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
		p->p_wpos++;
  810c06:	83 c0 01             	add    $0x1,%eax
  810c09:	89 43 04             	mov    %eax,0x4(%ebx)
	for (i = 0; i < n; i++) {
  810c0c:	83 c7 01             	add    $0x1,%edi
  810c0f:	eb ac                	jmp    810bbd <devpipe_write+0x1c>
	return i;
  810c11:	8b 45 10             	mov    0x10(%ebp),%eax
  810c14:	eb 05                	jmp    810c1b <devpipe_write+0x7a>
				return 0;
  810c16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810c1b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810c1e:	5b                   	pop    %ebx
  810c1f:	5e                   	pop    %esi
  810c20:	5f                   	pop    %edi
  810c21:	5d                   	pop    %ebp
  810c22:	c3                   	ret    

00810c23 <devpipe_read>:
{
  810c23:	55                   	push   %ebp
  810c24:	89 e5                	mov    %esp,%ebp
  810c26:	57                   	push   %edi
  810c27:	56                   	push   %esi
  810c28:	53                   	push   %ebx
  810c29:	83 ec 18             	sub    $0x18,%esp
  810c2c:	8b 7d 08             	mov    0x8(%ebp),%edi
	p = (struct Pipe*)fd2data(fd);
  810c2f:	57                   	push   %edi
  810c30:	e8 73 ef ff ff       	call   80fba8 <fd2data>
  810c35:	89 c3                	mov    %eax,%ebx
	for (i = 0; i < n; i++) {
  810c37:	83 c4 10             	add    $0x10,%esp
  810c3a:	be 00 00 00 00       	mov    $0x0,%esi
  810c3f:	3b 75 10             	cmp    0x10(%ebp),%esi
  810c42:	75 14                	jne    810c58 <devpipe_read+0x35>
	return i;
  810c44:	8b 45 10             	mov    0x10(%ebp),%eax
  810c47:	eb 02                	jmp    810c4b <devpipe_read+0x28>
				return i;
  810c49:	89 f0                	mov    %esi,%eax
}
  810c4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810c4e:	5b                   	pop    %ebx
  810c4f:	5e                   	pop    %esi
  810c50:	5f                   	pop    %edi
  810c51:	5d                   	pop    %ebp
  810c52:	c3                   	ret    
			sys_yield();
  810c53:	e8 69 e6 ff ff       	call   80f2c1 <sys_yield>
		while (p->p_rpos == p->p_wpos) {
  810c58:	8b 03                	mov    (%ebx),%eax
  810c5a:	3b 43 04             	cmp    0x4(%ebx),%eax
  810c5d:	75 18                	jne    810c77 <devpipe_read+0x54>
			if (i > 0)
  810c5f:	85 f6                	test   %esi,%esi
  810c61:	75 e6                	jne    810c49 <devpipe_read+0x26>
			if (_pipeisclosed(fd, p))
  810c63:	89 da                	mov    %ebx,%edx
  810c65:	89 f8                	mov    %edi,%eax
  810c67:	e8 d0 fe ff ff       	call   810b3c <_pipeisclosed>
  810c6c:	85 c0                	test   %eax,%eax
  810c6e:	74 e3                	je     810c53 <devpipe_read+0x30>
				return 0;
  810c70:	b8 00 00 00 00       	mov    $0x0,%eax
  810c75:	eb d4                	jmp    810c4b <devpipe_read+0x28>
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  810c77:	99                   	cltd   
  810c78:	c1 ea 1b             	shr    $0x1b,%edx
  810c7b:	01 d0                	add    %edx,%eax
  810c7d:	83 e0 1f             	and    $0x1f,%eax
  810c80:	29 d0                	sub    %edx,%eax
  810c82:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  810c87:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810c8a:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  810c8d:	83 03 01             	addl   $0x1,(%ebx)
	for (i = 0; i < n; i++) {
  810c90:	83 c6 01             	add    $0x1,%esi
  810c93:	eb aa                	jmp    810c3f <devpipe_read+0x1c>

00810c95 <pipe>:
{
  810c95:	55                   	push   %ebp
  810c96:	89 e5                	mov    %esp,%ebp
  810c98:	56                   	push   %esi
  810c99:	53                   	push   %ebx
  810c9a:	83 ec 1c             	sub    $0x1c,%esp
	if ((r = fd_alloc(&fd0)) < 0
  810c9d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810ca0:	50                   	push   %eax
  810ca1:	e8 19 ef ff ff       	call   80fbbf <fd_alloc>
  810ca6:	89 c3                	mov    %eax,%ebx
  810ca8:	83 c4 10             	add    $0x10,%esp
  810cab:	85 c0                	test   %eax,%eax
  810cad:	0f 88 23 01 00 00    	js     810dd6 <pipe+0x141>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810cb3:	83 ec 04             	sub    $0x4,%esp
  810cb6:	68 07 04 00 00       	push   $0x407
  810cbb:	ff 75 f4             	pushl  -0xc(%ebp)
  810cbe:	6a 00                	push   $0x0
  810cc0:	e8 1b e6 ff ff       	call   80f2e0 <sys_page_alloc>
  810cc5:	89 c3                	mov    %eax,%ebx
  810cc7:	83 c4 10             	add    $0x10,%esp
  810cca:	85 c0                	test   %eax,%eax
  810ccc:	0f 88 04 01 00 00    	js     810dd6 <pipe+0x141>
	if ((r = fd_alloc(&fd1)) < 0
  810cd2:	83 ec 0c             	sub    $0xc,%esp
  810cd5:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810cd8:	50                   	push   %eax
  810cd9:	e8 e1 ee ff ff       	call   80fbbf <fd_alloc>
  810cde:	89 c3                	mov    %eax,%ebx
  810ce0:	83 c4 10             	add    $0x10,%esp
  810ce3:	85 c0                	test   %eax,%eax
  810ce5:	0f 88 db 00 00 00    	js     810dc6 <pipe+0x131>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810ceb:	83 ec 04             	sub    $0x4,%esp
  810cee:	68 07 04 00 00       	push   $0x407
  810cf3:	ff 75 f0             	pushl  -0x10(%ebp)
  810cf6:	6a 00                	push   $0x0
  810cf8:	e8 e3 e5 ff ff       	call   80f2e0 <sys_page_alloc>
  810cfd:	89 c3                	mov    %eax,%ebx
  810cff:	83 c4 10             	add    $0x10,%esp
  810d02:	85 c0                	test   %eax,%eax
  810d04:	0f 88 bc 00 00 00    	js     810dc6 <pipe+0x131>
	va = fd2data(fd0);
  810d0a:	83 ec 0c             	sub    $0xc,%esp
  810d0d:	ff 75 f4             	pushl  -0xc(%ebp)
  810d10:	e8 93 ee ff ff       	call   80fba8 <fd2data>
  810d15:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810d17:	83 c4 0c             	add    $0xc,%esp
  810d1a:	68 07 04 00 00       	push   $0x407
  810d1f:	50                   	push   %eax
  810d20:	6a 00                	push   $0x0
  810d22:	e8 b9 e5 ff ff       	call   80f2e0 <sys_page_alloc>
  810d27:	89 c3                	mov    %eax,%ebx
  810d29:	83 c4 10             	add    $0x10,%esp
  810d2c:	85 c0                	test   %eax,%eax
  810d2e:	0f 88 82 00 00 00    	js     810db6 <pipe+0x121>
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  810d34:	83 ec 0c             	sub    $0xc,%esp
  810d37:	ff 75 f0             	pushl  -0x10(%ebp)
  810d3a:	e8 69 ee ff ff       	call   80fba8 <fd2data>
  810d3f:	c7 04 24 07 04 00 00 	movl   $0x407,(%esp)
  810d46:	50                   	push   %eax
  810d47:	6a 00                	push   $0x0
  810d49:	56                   	push   %esi
  810d4a:	6a 00                	push   $0x0
  810d4c:	e8 d2 e5 ff ff       	call   80f323 <sys_page_map>
  810d51:	89 c3                	mov    %eax,%ebx
  810d53:	83 c4 20             	add    $0x20,%esp
  810d56:	85 c0                	test   %eax,%eax
  810d58:	78 4e                	js     810da8 <pipe+0x113>
	fd0->fd_dev_id = devpipe.dev_id;
  810d5a:	a1 24 43 81 00       	mov    0x814324,%eax
  810d5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810d62:	89 02                	mov    %eax,(%edx)
	fd0->fd_omode = O_RDONLY;
  810d64:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810d67:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)
	fd1->fd_dev_id = devpipe.dev_id;
  810d6e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810d71:	89 02                	mov    %eax,(%edx)
	fd1->fd_omode = O_WRONLY;
  810d73:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810d76:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
	pfd[0] = fd2num(fd0);
  810d7d:	83 ec 0c             	sub    $0xc,%esp
  810d80:	ff 75 f4             	pushl  -0xc(%ebp)
  810d83:	e8 10 ee ff ff       	call   80fb98 <fd2num>
  810d88:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810d8b:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  810d8d:	83 c4 04             	add    $0x4,%esp
  810d90:	ff 75 f0             	pushl  -0x10(%ebp)
  810d93:	e8 00 ee ff ff       	call   80fb98 <fd2num>
  810d98:	8b 4d 08             	mov    0x8(%ebp),%ecx
  810d9b:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  810d9e:	83 c4 10             	add    $0x10,%esp
  810da1:	bb 00 00 00 00       	mov    $0x0,%ebx
  810da6:	eb 2e                	jmp    810dd6 <pipe+0x141>
	sys_page_unmap(0, va);
  810da8:	83 ec 08             	sub    $0x8,%esp
  810dab:	56                   	push   %esi
  810dac:	6a 00                	push   $0x0
  810dae:	e8 b2 e5 ff ff       	call   80f365 <sys_page_unmap>
  810db3:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd1);
  810db6:	83 ec 08             	sub    $0x8,%esp
  810db9:	ff 75 f0             	pushl  -0x10(%ebp)
  810dbc:	6a 00                	push   $0x0
  810dbe:	e8 a2 e5 ff ff       	call   80f365 <sys_page_unmap>
  810dc3:	83 c4 10             	add    $0x10,%esp
	sys_page_unmap(0, fd0);
  810dc6:	83 ec 08             	sub    $0x8,%esp
  810dc9:	ff 75 f4             	pushl  -0xc(%ebp)
  810dcc:	6a 00                	push   $0x0
  810dce:	e8 92 e5 ff ff       	call   80f365 <sys_page_unmap>
  810dd3:	83 c4 10             	add    $0x10,%esp
}
  810dd6:	89 d8                	mov    %ebx,%eax
  810dd8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  810ddb:	5b                   	pop    %ebx
  810ddc:	5e                   	pop    %esi
  810ddd:	5d                   	pop    %ebp
  810dde:	c3                   	ret    

00810ddf <pipeisclosed>:
{
  810ddf:	55                   	push   %ebp
  810de0:	89 e5                	mov    %esp,%ebp
  810de2:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810de5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810de8:	50                   	push   %eax
  810de9:	ff 75 08             	pushl  0x8(%ebp)
  810dec:	e8 20 ee ff ff       	call   80fc11 <fd_lookup>
  810df1:	83 c4 10             	add    $0x10,%esp
  810df4:	85 c0                	test   %eax,%eax
  810df6:	78 18                	js     810e10 <pipeisclosed+0x31>
	p = (struct Pipe*) fd2data(fd);
  810df8:	83 ec 0c             	sub    $0xc,%esp
  810dfb:	ff 75 f4             	pushl  -0xc(%ebp)
  810dfe:	e8 a5 ed ff ff       	call   80fba8 <fd2data>
	return _pipeisclosed(fd, p);
  810e03:	89 c2                	mov    %eax,%edx
  810e05:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e08:	e8 2f fd ff ff       	call   810b3c <_pipeisclosed>
  810e0d:	83 c4 10             	add    $0x10,%esp
}
  810e10:	c9                   	leave  
  810e11:	c3                   	ret    

00810e12 <devcons_close>:
devcons_close(struct Fd *fd)
{
	USED(fd);

	return 0;
}
  810e12:	b8 00 00 00 00       	mov    $0x0,%eax
  810e17:	c3                   	ret    

00810e18 <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  810e18:	55                   	push   %ebp
  810e19:	89 e5                	mov    %esp,%ebp
  810e1b:	83 ec 10             	sub    $0x10,%esp
	strcpy(stat->st_name, "<cons>");
  810e1e:	68 3e 3f 81 00       	push   $0x813f3e
  810e23:	ff 75 0c             	pushl  0xc(%ebp)
  810e26:	e8 c3 e0 ff ff       	call   80eeee <strcpy>
	return 0;
}
  810e2b:	b8 00 00 00 00       	mov    $0x0,%eax
  810e30:	c9                   	leave  
  810e31:	c3                   	ret    

00810e32 <devcons_write>:
{
  810e32:	55                   	push   %ebp
  810e33:	89 e5                	mov    %esp,%ebp
  810e35:	57                   	push   %edi
  810e36:	56                   	push   %esi
  810e37:	53                   	push   %ebx
  810e38:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	for (tot = 0; tot < n; tot += m) {
  810e3e:	be 00 00 00 00       	mov    $0x0,%esi
		memmove(buf, (char*)vbuf + tot, m);
  810e43:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	for (tot = 0; tot < n; tot += m) {
  810e49:	3b 75 10             	cmp    0x10(%ebp),%esi
  810e4c:	73 31                	jae    810e7f <devcons_write+0x4d>
		m = n - tot;
  810e4e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810e51:	29 f3                	sub    %esi,%ebx
  810e53:	83 fb 7f             	cmp    $0x7f,%ebx
  810e56:	b8 7f 00 00 00       	mov    $0x7f,%eax
  810e5b:	0f 47 d8             	cmova  %eax,%ebx
		memmove(buf, (char*)vbuf + tot, m);
  810e5e:	83 ec 04             	sub    $0x4,%esp
  810e61:	53                   	push   %ebx
  810e62:	89 f0                	mov    %esi,%eax
  810e64:	03 45 0c             	add    0xc(%ebp),%eax
  810e67:	50                   	push   %eax
  810e68:	57                   	push   %edi
  810e69:	e8 0e e2 ff ff       	call   80f07c <memmove>
		sys_cputs(buf, m);
  810e6e:	83 c4 08             	add    $0x8,%esp
  810e71:	53                   	push   %ebx
  810e72:	57                   	push   %edi
  810e73:	e8 ac e3 ff ff       	call   80f224 <sys_cputs>
	for (tot = 0; tot < n; tot += m) {
  810e78:	01 de                	add    %ebx,%esi
  810e7a:	83 c4 10             	add    $0x10,%esp
  810e7d:	eb ca                	jmp    810e49 <devcons_write+0x17>
}
  810e7f:	89 f0                	mov    %esi,%eax
  810e81:	8d 65 f4             	lea    -0xc(%ebp),%esp
  810e84:	5b                   	pop    %ebx
  810e85:	5e                   	pop    %esi
  810e86:	5f                   	pop    %edi
  810e87:	5d                   	pop    %ebp
  810e88:	c3                   	ret    

00810e89 <devcons_read>:
{
  810e89:	55                   	push   %ebp
  810e8a:	89 e5                	mov    %esp,%ebp
  810e8c:	83 ec 08             	sub    $0x8,%esp
  810e8f:	b8 00 00 00 00       	mov    $0x0,%eax
	if (n == 0)
  810e94:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  810e98:	74 21                	je     810ebb <devcons_read+0x32>
	while ((c = sys_cgetc()) == 0)
  810e9a:	e8 a3 e3 ff ff       	call   80f242 <sys_cgetc>
  810e9f:	85 c0                	test   %eax,%eax
  810ea1:	75 07                	jne    810eaa <devcons_read+0x21>
		sys_yield();
  810ea3:	e8 19 e4 ff ff       	call   80f2c1 <sys_yield>
  810ea8:	eb f0                	jmp    810e9a <devcons_read+0x11>
	if (c < 0)
  810eaa:	78 0f                	js     810ebb <devcons_read+0x32>
	if (c == 0x04)	// ctl-d is eof
  810eac:	83 f8 04             	cmp    $0x4,%eax
  810eaf:	74 0c                	je     810ebd <devcons_read+0x34>
	*(char*)vbuf = c;
  810eb1:	8b 55 0c             	mov    0xc(%ebp),%edx
  810eb4:	88 02                	mov    %al,(%edx)
	return 1;
  810eb6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  810ebb:	c9                   	leave  
  810ebc:	c3                   	ret    
		return 0;
  810ebd:	b8 00 00 00 00       	mov    $0x0,%eax
  810ec2:	eb f7                	jmp    810ebb <devcons_read+0x32>

00810ec4 <cputchar>:
{
  810ec4:	55                   	push   %ebp
  810ec5:	89 e5                	mov    %esp,%ebp
  810ec7:	83 ec 20             	sub    $0x20,%esp
	char c = ch;
  810eca:	8b 45 08             	mov    0x8(%ebp),%eax
  810ecd:	88 45 f7             	mov    %al,-0x9(%ebp)
	sys_cputs(&c, 1);
  810ed0:	6a 01                	push   $0x1
  810ed2:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810ed5:	50                   	push   %eax
  810ed6:	e8 49 e3 ff ff       	call   80f224 <sys_cputs>
}
  810edb:	83 c4 10             	add    $0x10,%esp
  810ede:	c9                   	leave  
  810edf:	c3                   	ret    

00810ee0 <getchar>:
{
  810ee0:	55                   	push   %ebp
  810ee1:	89 e5                	mov    %esp,%ebp
  810ee3:	83 ec 1c             	sub    $0x1c,%esp
	r = read(0, &c, 1);
  810ee6:	6a 01                	push   $0x1
  810ee8:	8d 45 f7             	lea    -0x9(%ebp),%eax
  810eeb:	50                   	push   %eax
  810eec:	6a 00                	push   $0x0
  810eee:	e8 8e ef ff ff       	call   80fe81 <read>
	if (r < 0)
  810ef3:	83 c4 10             	add    $0x10,%esp
  810ef6:	85 c0                	test   %eax,%eax
  810ef8:	78 06                	js     810f00 <getchar+0x20>
	if (r < 1)
  810efa:	74 06                	je     810f02 <getchar+0x22>
	return c;
  810efc:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  810f00:	c9                   	leave  
  810f01:	c3                   	ret    
		return -E_EOF;
  810f02:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  810f07:	eb f7                	jmp    810f00 <getchar+0x20>

00810f09 <iscons>:
{
  810f09:	55                   	push   %ebp
  810f0a:	89 e5                	mov    %esp,%ebp
  810f0c:	83 ec 20             	sub    $0x20,%esp
	if ((r = fd_lookup(fdnum, &fd)) < 0)
  810f0f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810f12:	50                   	push   %eax
  810f13:	ff 75 08             	pushl  0x8(%ebp)
  810f16:	e8 f6 ec ff ff       	call   80fc11 <fd_lookup>
  810f1b:	83 c4 10             	add    $0x10,%esp
  810f1e:	85 c0                	test   %eax,%eax
  810f20:	78 11                	js     810f33 <iscons+0x2a>
	return fd->fd_dev_id == devcons.dev_id;
  810f22:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810f25:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810f2b:	39 10                	cmp    %edx,(%eax)
  810f2d:	0f 94 c0             	sete   %al
  810f30:	0f b6 c0             	movzbl %al,%eax
}
  810f33:	c9                   	leave  
  810f34:	c3                   	ret    

00810f35 <opencons>:
{
  810f35:	55                   	push   %ebp
  810f36:	89 e5                	mov    %esp,%ebp
  810f38:	83 ec 24             	sub    $0x24,%esp
	if ((r = fd_alloc(&fd)) < 0)
  810f3b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810f3e:	50                   	push   %eax
  810f3f:	e8 7b ec ff ff       	call   80fbbf <fd_alloc>
  810f44:	83 c4 10             	add    $0x10,%esp
  810f47:	85 c0                	test   %eax,%eax
  810f49:	78 3a                	js     810f85 <opencons+0x50>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  810f4b:	83 ec 04             	sub    $0x4,%esp
  810f4e:	68 07 04 00 00       	push   $0x407
  810f53:	ff 75 f4             	pushl  -0xc(%ebp)
  810f56:	6a 00                	push   $0x0
  810f58:	e8 83 e3 ff ff       	call   80f2e0 <sys_page_alloc>
  810f5d:	83 c4 10             	add    $0x10,%esp
  810f60:	85 c0                	test   %eax,%eax
  810f62:	78 21                	js     810f85 <opencons+0x50>
	fd->fd_dev_id = devcons.dev_id;
  810f64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810f67:	8b 15 40 43 81 00    	mov    0x814340,%edx
  810f6d:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  810f6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810f72:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  810f79:	83 ec 0c             	sub    $0xc,%esp
  810f7c:	50                   	push   %eax
  810f7d:	e8 16 ec ff ff       	call   80fb98 <fd2num>
  810f82:	83 c4 10             	add    $0x10,%esp
}
  810f85:	c9                   	leave  
  810f86:	c3                   	ret    

00810f87 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  810f87:	55                   	push   %ebp
  810f88:	89 e5                	mov    %esp,%ebp
  810f8a:	83 ec 08             	sub    $0x8,%esp
	int r;

	if (_pgfault_handler == 0) {
  810f8d:	83 3d 00 e0 b3 00 00 	cmpl   $0x0,0xb3e000
  810f94:	74 0a                	je     810fa0 <set_pgfault_handler+0x19>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
		// panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  810f96:	8b 45 08             	mov    0x8(%ebp),%eax
  810f99:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
}
  810f9e:	c9                   	leave  
  810f9f:	c3                   	ret    
		r = sys_page_alloc((envid_t)0, (void*)(UXSTACKTOP-PGSIZE), PTE_U|PTE_W|PTE_P);
  810fa0:	83 ec 04             	sub    $0x4,%esp
  810fa3:	6a 07                	push   $0x7
  810fa5:	68 00 f0 bf ee       	push   $0xeebff000
  810faa:	6a 00                	push   $0x0
  810fac:	e8 2f e3 ff ff       	call   80f2e0 <sys_page_alloc>
		if(r < 0)
  810fb1:	83 c4 10             	add    $0x10,%esp
  810fb4:	85 c0                	test   %eax,%eax
  810fb6:	78 2a                	js     810fe2 <set_pgfault_handler+0x5b>
		r = sys_env_set_pgfault_upcall((envid_t)0, _pgfault_upcall);
  810fb8:	83 ec 08             	sub    $0x8,%esp
  810fbb:	68 f6 0f 81 00       	push   $0x810ff6
  810fc0:	6a 00                	push   $0x0
  810fc2:	e8 64 e4 ff ff       	call   80f42b <sys_env_set_pgfault_upcall>
		if(r < 0)
  810fc7:	83 c4 10             	add    $0x10,%esp
  810fca:	85 c0                	test   %eax,%eax
  810fcc:	79 c8                	jns    810f96 <set_pgfault_handler+0xf>
			panic("the sys_env_set_pgfault_upcall() return value is wrong!\n");
  810fce:	83 ec 04             	sub    $0x4,%esp
  810fd1:	68 7c 3f 81 00       	push   $0x813f7c
  810fd6:	6a 25                	push   $0x25
  810fd8:	68 b8 3f 81 00       	push   $0x813fb8
  810fdd:	e8 b7 d6 ff ff       	call   80e699 <_panic>
			panic("the sys_page_alloc() return value is wrong!\n");
  810fe2:	83 ec 04             	sub    $0x4,%esp
  810fe5:	68 4c 3f 81 00       	push   $0x813f4c
  810fea:	6a 22                	push   $0x22
  810fec:	68 b8 3f 81 00       	push   $0x813fb8
  810ff1:	e8 a3 d6 ff ff       	call   80e699 <_panic>

00810ff6 <_pgfault_upcall>:
_pgfault_upcall:
	//movl testxixi, %eax 
	//call *%eax 

	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  810ff6:	54                   	push   %esp
	movl _pgfault_handler, %eax
  810ff7:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
	call *%eax
  810ffc:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  810ffe:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %ebx 
  811001:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl 0x30(%esp), %eax 
  811005:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax 
  811009:	83 e8 04             	sub    $0x4,%eax
	movl %ebx, (%eax)
  81100c:	89 18                	mov    %ebx,(%eax)
	movl %eax, 0x30(%esp)
  81100e:	89 44 24 30          	mov    %eax,0x30(%esp)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp 
  811012:	83 c4 08             	add    $0x8,%esp
	popal
  811015:	61                   	popa   
	
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp
  811016:	83 c4 04             	add    $0x4,%esp
	popfl
  811019:	9d                   	popf   
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  81101a:	5c                   	pop    %esp
	
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
  81101b:	c3                   	ret    

0081101c <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  81101c:	55                   	push   %ebp
  81101d:	89 e5                	mov    %esp,%ebp
  81101f:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811022:	89 d0                	mov    %edx,%eax
  811024:	c1 e8 16             	shr    $0x16,%eax
  811027:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  81102e:	b8 00 00 00 00       	mov    $0x0,%eax
	if (!(uvpd[PDX(v)] & PTE_P))
  811033:	f6 c1 01             	test   $0x1,%cl
  811036:	74 1d                	je     811055 <pageref+0x39>
	pte = uvpt[PGNUM(v)];
  811038:	c1 ea 0c             	shr    $0xc,%edx
  81103b:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  811042:	f6 c2 01             	test   $0x1,%dl
  811045:	74 0e                	je     811055 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  811047:	c1 ea 0c             	shr    $0xc,%edx
  81104a:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  811051:	ef 
  811052:	0f b7 c0             	movzwl %ax,%eax
}
  811055:	5d                   	pop    %ebp
  811056:	c3                   	ret    
  811057:	66 90                	xchg   %ax,%ax
  811059:	66 90                	xchg   %ax,%ax
  81105b:	66 90                	xchg   %ax,%ax
  81105d:	66 90                	xchg   %ax,%ax
  81105f:	90                   	nop

00811060 <__udivdi3>:
  811060:	55                   	push   %ebp
  811061:	57                   	push   %edi
  811062:	56                   	push   %esi
  811063:	53                   	push   %ebx
  811064:	83 ec 1c             	sub    $0x1c,%esp
  811067:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  81106b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  81106f:	8b 74 24 34          	mov    0x34(%esp),%esi
  811073:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  811077:	85 d2                	test   %edx,%edx
  811079:	75 4d                	jne    8110c8 <__udivdi3+0x68>
  81107b:	39 f3                	cmp    %esi,%ebx
  81107d:	76 19                	jbe    811098 <__udivdi3+0x38>
  81107f:	31 ff                	xor    %edi,%edi
  811081:	89 e8                	mov    %ebp,%eax
  811083:	89 f2                	mov    %esi,%edx
  811085:	f7 f3                	div    %ebx
  811087:	89 fa                	mov    %edi,%edx
  811089:	83 c4 1c             	add    $0x1c,%esp
  81108c:	5b                   	pop    %ebx
  81108d:	5e                   	pop    %esi
  81108e:	5f                   	pop    %edi
  81108f:	5d                   	pop    %ebp
  811090:	c3                   	ret    
  811091:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811098:	89 d9                	mov    %ebx,%ecx
  81109a:	85 db                	test   %ebx,%ebx
  81109c:	75 0b                	jne    8110a9 <__udivdi3+0x49>
  81109e:	b8 01 00 00 00       	mov    $0x1,%eax
  8110a3:	31 d2                	xor    %edx,%edx
  8110a5:	f7 f3                	div    %ebx
  8110a7:	89 c1                	mov    %eax,%ecx
  8110a9:	31 d2                	xor    %edx,%edx
  8110ab:	89 f0                	mov    %esi,%eax
  8110ad:	f7 f1                	div    %ecx
  8110af:	89 c6                	mov    %eax,%esi
  8110b1:	89 e8                	mov    %ebp,%eax
  8110b3:	89 f7                	mov    %esi,%edi
  8110b5:	f7 f1                	div    %ecx
  8110b7:	89 fa                	mov    %edi,%edx
  8110b9:	83 c4 1c             	add    $0x1c,%esp
  8110bc:	5b                   	pop    %ebx
  8110bd:	5e                   	pop    %esi
  8110be:	5f                   	pop    %edi
  8110bf:	5d                   	pop    %ebp
  8110c0:	c3                   	ret    
  8110c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110c8:	39 f2                	cmp    %esi,%edx
  8110ca:	77 1c                	ja     8110e8 <__udivdi3+0x88>
  8110cc:	0f bd fa             	bsr    %edx,%edi
  8110cf:	83 f7 1f             	xor    $0x1f,%edi
  8110d2:	75 2c                	jne    811100 <__udivdi3+0xa0>
  8110d4:	39 f2                	cmp    %esi,%edx
  8110d6:	72 06                	jb     8110de <__udivdi3+0x7e>
  8110d8:	31 c0                	xor    %eax,%eax
  8110da:	39 eb                	cmp    %ebp,%ebx
  8110dc:	77 a9                	ja     811087 <__udivdi3+0x27>
  8110de:	b8 01 00 00 00       	mov    $0x1,%eax
  8110e3:	eb a2                	jmp    811087 <__udivdi3+0x27>
  8110e5:	8d 76 00             	lea    0x0(%esi),%esi
  8110e8:	31 ff                	xor    %edi,%edi
  8110ea:	31 c0                	xor    %eax,%eax
  8110ec:	89 fa                	mov    %edi,%edx
  8110ee:	83 c4 1c             	add    $0x1c,%esp
  8110f1:	5b                   	pop    %ebx
  8110f2:	5e                   	pop    %esi
  8110f3:	5f                   	pop    %edi
  8110f4:	5d                   	pop    %ebp
  8110f5:	c3                   	ret    
  8110f6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8110fd:	8d 76 00             	lea    0x0(%esi),%esi
  811100:	89 f9                	mov    %edi,%ecx
  811102:	b8 20 00 00 00       	mov    $0x20,%eax
  811107:	29 f8                	sub    %edi,%eax
  811109:	d3 e2                	shl    %cl,%edx
  81110b:	89 54 24 08          	mov    %edx,0x8(%esp)
  81110f:	89 c1                	mov    %eax,%ecx
  811111:	89 da                	mov    %ebx,%edx
  811113:	d3 ea                	shr    %cl,%edx
  811115:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811119:	09 d1                	or     %edx,%ecx
  81111b:	89 f2                	mov    %esi,%edx
  81111d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811121:	89 f9                	mov    %edi,%ecx
  811123:	d3 e3                	shl    %cl,%ebx
  811125:	89 c1                	mov    %eax,%ecx
  811127:	d3 ea                	shr    %cl,%edx
  811129:	89 f9                	mov    %edi,%ecx
  81112b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81112f:	89 eb                	mov    %ebp,%ebx
  811131:	d3 e6                	shl    %cl,%esi
  811133:	89 c1                	mov    %eax,%ecx
  811135:	d3 eb                	shr    %cl,%ebx
  811137:	09 de                	or     %ebx,%esi
  811139:	89 f0                	mov    %esi,%eax
  81113b:	f7 74 24 08          	divl   0x8(%esp)
  81113f:	89 d6                	mov    %edx,%esi
  811141:	89 c3                	mov    %eax,%ebx
  811143:	f7 64 24 0c          	mull   0xc(%esp)
  811147:	39 d6                	cmp    %edx,%esi
  811149:	72 15                	jb     811160 <__udivdi3+0x100>
  81114b:	89 f9                	mov    %edi,%ecx
  81114d:	d3 e5                	shl    %cl,%ebp
  81114f:	39 c5                	cmp    %eax,%ebp
  811151:	73 04                	jae    811157 <__udivdi3+0xf7>
  811153:	39 d6                	cmp    %edx,%esi
  811155:	74 09                	je     811160 <__udivdi3+0x100>
  811157:	89 d8                	mov    %ebx,%eax
  811159:	31 ff                	xor    %edi,%edi
  81115b:	e9 27 ff ff ff       	jmp    811087 <__udivdi3+0x27>
  811160:	8d 43 ff             	lea    -0x1(%ebx),%eax
  811163:	31 ff                	xor    %edi,%edi
  811165:	e9 1d ff ff ff       	jmp    811087 <__udivdi3+0x27>
  81116a:	66 90                	xchg   %ax,%ax
  81116c:	66 90                	xchg   %ax,%ax
  81116e:	66 90                	xchg   %ax,%ax

00811170 <__umoddi3>:
  811170:	55                   	push   %ebp
  811171:	57                   	push   %edi
  811172:	56                   	push   %esi
  811173:	53                   	push   %ebx
  811174:	83 ec 1c             	sub    $0x1c,%esp
  811177:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  81117b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  81117f:	8b 74 24 30          	mov    0x30(%esp),%esi
  811183:	8b 7c 24 38          	mov    0x38(%esp),%edi
  811187:	89 da                	mov    %ebx,%edx
  811189:	85 c0                	test   %eax,%eax
  81118b:	75 43                	jne    8111d0 <__umoddi3+0x60>
  81118d:	39 df                	cmp    %ebx,%edi
  81118f:	76 17                	jbe    8111a8 <__umoddi3+0x38>
  811191:	89 f0                	mov    %esi,%eax
  811193:	f7 f7                	div    %edi
  811195:	89 d0                	mov    %edx,%eax
  811197:	31 d2                	xor    %edx,%edx
  811199:	83 c4 1c             	add    $0x1c,%esp
  81119c:	5b                   	pop    %ebx
  81119d:	5e                   	pop    %esi
  81119e:	5f                   	pop    %edi
  81119f:	5d                   	pop    %ebp
  8111a0:	c3                   	ret    
  8111a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111a8:	89 fd                	mov    %edi,%ebp
  8111aa:	85 ff                	test   %edi,%edi
  8111ac:	75 0b                	jne    8111b9 <__umoddi3+0x49>
  8111ae:	b8 01 00 00 00       	mov    $0x1,%eax
  8111b3:	31 d2                	xor    %edx,%edx
  8111b5:	f7 f7                	div    %edi
  8111b7:	89 c5                	mov    %eax,%ebp
  8111b9:	89 d8                	mov    %ebx,%eax
  8111bb:	31 d2                	xor    %edx,%edx
  8111bd:	f7 f5                	div    %ebp
  8111bf:	89 f0                	mov    %esi,%eax
  8111c1:	f7 f5                	div    %ebp
  8111c3:	89 d0                	mov    %edx,%eax
  8111c5:	eb d0                	jmp    811197 <__umoddi3+0x27>
  8111c7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8111ce:	66 90                	xchg   %ax,%ax
  8111d0:	89 f1                	mov    %esi,%ecx
  8111d2:	39 d8                	cmp    %ebx,%eax
  8111d4:	76 0a                	jbe    8111e0 <__umoddi3+0x70>
  8111d6:	89 f0                	mov    %esi,%eax
  8111d8:	83 c4 1c             	add    $0x1c,%esp
  8111db:	5b                   	pop    %ebx
  8111dc:	5e                   	pop    %esi
  8111dd:	5f                   	pop    %edi
  8111de:	5d                   	pop    %ebp
  8111df:	c3                   	ret    
  8111e0:	0f bd e8             	bsr    %eax,%ebp
  8111e3:	83 f5 1f             	xor    $0x1f,%ebp
  8111e6:	75 20                	jne    811208 <__umoddi3+0x98>
  8111e8:	39 d8                	cmp    %ebx,%eax
  8111ea:	0f 82 b0 00 00 00    	jb     8112a0 <__umoddi3+0x130>
  8111f0:	39 f7                	cmp    %esi,%edi
  8111f2:	0f 86 a8 00 00 00    	jbe    8112a0 <__umoddi3+0x130>
  8111f8:	89 c8                	mov    %ecx,%eax
  8111fa:	83 c4 1c             	add    $0x1c,%esp
  8111fd:	5b                   	pop    %ebx
  8111fe:	5e                   	pop    %esi
  8111ff:	5f                   	pop    %edi
  811200:	5d                   	pop    %ebp
  811201:	c3                   	ret    
  811202:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811208:	89 e9                	mov    %ebp,%ecx
  81120a:	ba 20 00 00 00       	mov    $0x20,%edx
  81120f:	29 ea                	sub    %ebp,%edx
  811211:	d3 e0                	shl    %cl,%eax
  811213:	89 44 24 08          	mov    %eax,0x8(%esp)
  811217:	89 d1                	mov    %edx,%ecx
  811219:	89 f8                	mov    %edi,%eax
  81121b:	d3 e8                	shr    %cl,%eax
  81121d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  811221:	89 54 24 04          	mov    %edx,0x4(%esp)
  811225:	8b 54 24 04          	mov    0x4(%esp),%edx
  811229:	09 c1                	or     %eax,%ecx
  81122b:	89 d8                	mov    %ebx,%eax
  81122d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811231:	89 e9                	mov    %ebp,%ecx
  811233:	d3 e7                	shl    %cl,%edi
  811235:	89 d1                	mov    %edx,%ecx
  811237:	d3 e8                	shr    %cl,%eax
  811239:	89 e9                	mov    %ebp,%ecx
  81123b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81123f:	d3 e3                	shl    %cl,%ebx
  811241:	89 c7                	mov    %eax,%edi
  811243:	89 d1                	mov    %edx,%ecx
  811245:	89 f0                	mov    %esi,%eax
  811247:	d3 e8                	shr    %cl,%eax
  811249:	89 e9                	mov    %ebp,%ecx
  81124b:	89 fa                	mov    %edi,%edx
  81124d:	d3 e6                	shl    %cl,%esi
  81124f:	09 d8                	or     %ebx,%eax
  811251:	f7 74 24 08          	divl   0x8(%esp)
  811255:	89 d1                	mov    %edx,%ecx
  811257:	89 f3                	mov    %esi,%ebx
  811259:	f7 64 24 0c          	mull   0xc(%esp)
  81125d:	89 c6                	mov    %eax,%esi
  81125f:	89 d7                	mov    %edx,%edi
  811261:	39 d1                	cmp    %edx,%ecx
  811263:	72 06                	jb     81126b <__umoddi3+0xfb>
  811265:	75 10                	jne    811277 <__umoddi3+0x107>
  811267:	39 c3                	cmp    %eax,%ebx
  811269:	73 0c                	jae    811277 <__umoddi3+0x107>
  81126b:	2b 44 24 0c          	sub    0xc(%esp),%eax
  81126f:	1b 54 24 08          	sbb    0x8(%esp),%edx
  811273:	89 d7                	mov    %edx,%edi
  811275:	89 c6                	mov    %eax,%esi
  811277:	89 ca                	mov    %ecx,%edx
  811279:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  81127e:	29 f3                	sub    %esi,%ebx
  811280:	19 fa                	sbb    %edi,%edx
  811282:	89 d0                	mov    %edx,%eax
  811284:	d3 e0                	shl    %cl,%eax
  811286:	89 e9                	mov    %ebp,%ecx
  811288:	d3 eb                	shr    %cl,%ebx
  81128a:	d3 ea                	shr    %cl,%edx
  81128c:	09 d8                	or     %ebx,%eax
  81128e:	83 c4 1c             	add    $0x1c,%esp
  811291:	5b                   	pop    %ebx
  811292:	5e                   	pop    %esi
  811293:	5f                   	pop    %edi
  811294:	5d                   	pop    %ebp
  811295:	c3                   	ret    
  811296:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  81129d:	8d 76 00             	lea    0x0(%esi),%esi
  8112a0:	89 da                	mov    %ebx,%edx
  8112a2:	29 fe                	sub    %edi,%esi
  8112a4:	19 c2                	sbb    %eax,%edx
  8112a6:	89 f1                	mov    %esi,%ecx
  8112a8:	89 c8                	mov    %ecx,%eax
  8112aa:	e9 4b ff ff ff       	jmp    8111fa <__umoddi3+0x8a>
